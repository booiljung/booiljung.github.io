<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:NextCloud, OpenProject, GitLab을 활용한 연구 개발조직 워크플로우 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>NextCloud, OpenProject, GitLab을 활용한 연구 개발조직 워크플로우 안내서</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">조직 운영</a> / <a href="index.html">조직 워크플로</a> / <span>NextCloud, OpenProject, GitLab을 활용한 연구 개발조직 워크플로우 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>NextCloud, OpenProject, GitLab을 활용한 연구 개발조직 워크플로우 안내서</h1>
<h2>1. 서론</h2>
<h3>1.1 목표 및 범위</h3>
<p>본 안내서는 연구 개발(R&amp;D) 조직이 NextCloud, OpenProject, GitLab이라는 세 가지 강력한 오픈소스 플랫폼을 유기적으로 통합하여, 데이터 주권을 확보하고, 프로젝트 관리의 투명성을 높이며, 연구 개발의 재현성을 보장하는 포괄적인 워크플로우를 구축하는 것을 목표로 한다. 이는 각 도구의 기능 목록을 나열하는 것을 넘어, 플랫폼 간의 시너지를 극대화하여 R&amp;D 프로세스 전반을 혁신하는 전략적 프레임워크를 제공하는 데 중점을 둔다.1 본 안내서에서 다루는 범위는 아이디어 발상 및 데이터 관리부터 프로젝트 계획, 실행, 코드 개발, 그리고 최종 결과물 도출 및 공유에 이르는 R&amp;D 생애주기 전체를 포괄한다.</p>
<h3>1.2 핵심 가치 제안</h3>
<p>본 안내서에서 제안하는 통합 소프트웨어 스택의 핵심 가치는 조직의 가장 중요한 자산인 연구 데이터와 지적 재산(IP)을 외부 서비스에 의존하지 않고 조직 내부의 인프라에서 완벽하게 통제할 수 있다는 점에 있다.2 이를 통해 데이터 주권을 확립하고, GDPR과 같은 엄격한 데이터 보호 규정을 준수하며, 민감한 정보의 유출 위험을 원천적으로 차단한다. 또한, 아이디어 발상부터 최종 결과물 도출까지의 전 과정을 단일화된 시스템 내에서 체계적으로 추적하고 자동화함으로써, 단순한 비용 절감을 넘어 R&amp;D 프로세스 자체의 신뢰성과 효율성을 근본적으로 혁신하는 것을 목표로 한다.</p>
<h3>1.3 대상 독자</h3>
<p>본 안내서는 R&amp;D 조직의 리더, 최고 기술 책임자(CTO), 수석 연구원, 프로젝트 관리자(PM) 등 기술 도입과 프로세스 개선에 대한 의사결정권을 가진 기술 전문가를 주요 독자로 상정한다. 이들은 데이터 보안, 프로세스 효율화, 연구 결과의 신뢰성 확보에 높은 가치를 두며, 실질적인 도입을 위한 전략적, 기술적 지침을 필요로 한다.</p>
<p>R&amp;D 워크플로우의 전체 구조를 직관적으로 이해하고 각 도구의 명확한 역할을 파악하는 것은 성공적인 통합의 첫걸음이다. 각 도구는 R&amp;D 프로세스의 특정 단계를 전담하는 전문 부서와 같이 명확한 책임과 역할을 부여받아야 한다. 연구 개발은 통상적으로 ‘데이터 및 아이디어 생성’, ‘계획 및 관리’, ’실행 및 검증’의 흐름을 따르며, 세 가지 플랫폼은 이 흐름에 자연스럽게 대응한다. NextCloud는 비정형 데이터와 초기 아이디어를 다루는 ‘생성’ 단계의 허브 역할을, OpenProject는 이를 구체적인 계획으로 전환하고 관리하는 ‘계획 및 관리’ 단계의 지휘 본부 역할을, GitLab은 실제 코드와 분석을 통해 가설을 ’실행 및 검증’하는 재현 가능한 환경의 역할을 수행한다. 이러한 역할 분담은 아래 표에 명시된 바와 같이, 전체 워크플로우의 개념적 지도를 제공하며, 이어지는 상세 내용을 이해하는 데 있어 핵심적인 기준점이 될 것이다.</p>
<p><strong>Table 1: R&amp;D 워크플로우 내 도구별 핵심 역할</strong></p>
<table><thead><tr><th>도구 (Tool)</th><th>핵심 역할 (Core Role)</th><th>주요 활동 (Key Activities)</th><th>관리 대상 (Managed Assets)</th></tr></thead><tbody>
<tr><td><strong>NextCloud</strong></td><td>데이터 및 협업 허브 (Data &amp; Collaboration Hub)</td><td>파일 공유 및 동기화, 실시간 문서 공동 편집, 화상 회의, 아이디어 스케치, 지식 베이스 구축</td><td>원시 데이터, 실험 데이터, 참고 문헌, 제안서, 회의록, 연구 노트, 초기 아이디어</td></tr>
<tr><td><strong>OpenProject</strong></td><td>프로젝트 지휘 본부 (Project Command Center)</td><td>프로젝트 계획 수립, 작업 패키지(실험, 태스크) 정의 및 추적, 일정 관리(Gantt), 자원 할당, 애자일 스프린트 운영</td><td>프로젝트, 마일스톤, 작업 패키지(Work Packages), 산출물, 리스크, 예산, 타임라인</td></tr>
<tr><td><strong>GitLab</strong></td><td>재현 가능한 개발 환경 (Reproducible Development Environment)</td><td>소스 코드 버전 관리, 기술 문서(LaTeX) 형상 관리, CI/CD 파이프라인을 통한 분석 자동화, 이슈 트래킹</td><td>소스 코드, 분석 스크립트, 모델 아키텍처, 설정 파일, LaTeX 문서, Docker 이미지, CI/CD 파이프라인</td></tr>
</tbody></table>
<h2>2. 부: 협업과 데이터 자산의 허브: NextCloud 활용 전략</h2>
<h3>2.1  연구 데이터의 중앙화 및 버전 관리</h3>
<h4>2.1.1 데이터 주권 확보</h4>
<p>R&amp;D 조직의 가장 중요한 자산은 연구 과정에서 생성되는 데이터와 그로부터 파생되는 지적 재산이다. NextCloud는 온프레미스(On-premise) 또는 조직이 통제하는 프라이빗 클라우드 환경에 서버를 직접 구축하는 것을 기본 전제로 한다.1 이는 데이터의 물리적, 논리적 통제권을 조직 내부에 완벽하게 유지함을 의미한다. 외부 상용 클라우드 서비스를 사용할 때 필연적으로 발생하는 데이터 주권 상실, 제3자에 의한 데이터 접근 가능성, 예측 불가능한 서비스 정책 변경, 특정 벤더에 대한 종속(Lock-in) 등의 문제를 원천적으로 해결한다. 특히 군사, 항공, 의료 등 고도의 보안이 요구되는 분야의 연구 기관에게 데이터의 완전한 통제는 선택이 아닌 필수 사항이다.</p>
<h4>2.1.2 강력한 접근 제어 및 공유</h4>
<p>데이터를 중앙화하는 것만큼 중요한 것은 통제된 방식으로 안전하게 공유하는 것이다. NextCloud는 내장된 파일 접근 제어(File Access Control) 기능을 통해 정교한 데이터 거버넌스 정책을 수립할 수 있게 한다.5 관리자는 사용자 그룹, IP 주소 범위, 파일의 MIME 타입, 요청 시간 등 다양한 조건을 조합하여 파일 접근을 허용하거나 차단하는 규칙을 설정할 수 있다. 예를 들어, ’재무팀 그룹은 내부 네트워크에서만 PDF 파일에 접근할 수 있다’와 같은 정책을 쉽게 구현할 수 있다.</p>
<p>외부 협력 기관이나 파트너와의 데이터 공유 시에도 다층적인 보안 장치가 제공된다. 모든 공유 링크에 대해 암호 설정, 접근 횟수 제한, 자동 만료일 지정이 가능하며, ‘파일 드롭(File Drop)’ 기능을 통해 외부 사용자가 폴더의 기존 내용을 보지 못하고 파일만 업로드하게 할 수도 있다.5 특히 민감한 문서 공유 시에는 ‘보안 보기(Secure View)’ 기능을 활성화하여 수신자가 문서를 웹 브라우저에서 워터마크가 표시된 상태로 열람만 할 수 있고, 다운로드, 인쇄, 복사-붙여넣기는 차단할 수 있다.8 더 나아가, ‘비디오 인증(Video Verification)’ 기능을 사용하면 수신자가 공유 파일에 접근하기 전에 NextCloud Talk를 통한 화상 통화로 신원을 확인해야 하므로, 최고 수준의 보안을 요구하는 상황에 대응할 수 있다.8</p>
<p>이러한 강력한 보안 및 통제 기능은 단순히 데이터를 보호하는 수단을 넘어, 조직 내 연구원들이 중앙 플랫폼을 신뢰하고 자신의 중요한 데이터를 적극적으로 공유 및 관리하도록 유도하는 근본적인 신뢰의 기반이 된다. 연구원들이 시스템의 보안을 신뢰하지 않는다면, 데이터는 중앙화되지 않고 개인의 PC나 비인가된 외부 서비스에 파편화될 것이며, 이는 협업의 비효율과 보안 사고의 잠재적 위험을 야기한다. 따라서 NextCloud의 보안 철학은 이후에 논의될 OpenProject 및 GitLab과의 통합 워크플로우 전체가 성공적으로 작동하기 위한 가장 핵심적인 전제 조건이다.</p>
<h4>2.1.3 파일 버전 관리 및 복구</h4>
<p>연구 과정에서는 수많은 데이터 수정과 문서 개정이 발생한다. NextCloud는 파일이 수정되거나 덮어쓰일 때마다 이전 버전을 자동으로 저장하는 강력한 버전 관리 기능을 내장하고 있다.1 사용자는 파일의 상세 정보 탭에서 모든 버전의 목록을 확인하고, 특정 시점의 버전과 현재 버전을 비교하거나 클릭 한 번으로 이전 상태로 파일을 복원할 수 있다. 이는 실수로 인한 데이터 손실을 방지할 뿐만 아니라, 특정 분석 결과가 어떤 버전의 데이터셋을 기반으로 도출되었는지 추적해야 하는 연구 환경에서 필수적인 기능이다. 관리자는 저장 공간 정책에 따라 버전이 보관되는 기간이나 최대 개수를 설정할 수 있다.</p>
<h3>2.2  아이디어 구체화 및 문서 협업</h3>
<h4>2.2.1 실시간 공동 편집</h4>
<p>R&amp;D 프로젝트의 시작은 아이디어를 구체적인 문서로 만드는 것에서 출발한다. NextCloud는 LibreOffice 기반의 Nextcloud Office 또는 ONLYOFFICE와의 긴밀한 통합을 통해, 워드 프로세서(<code>.docx</code>), 스프레드시트(<code>.xlsx</code>), 프레젠테이션(<code>.pptx</code>) 등 표준 오피스 문서를 여러 사용자가 웹 브라우저에서 동시에 편집할 수 있는 환경을 제공한다.1 각 사용자의 커서 위치와 편집 내용이 실시간으로 반영되므로, 별도의 파일을 주고받으며 버전을 관리하는 번거로움 없이 연구 제안서, 실험 계획서, 결과 보고서 등을 효율적으로 작성할 수 있다. 특히, 문서 편집 화면 내에서 NextCloud Talk를 즉시 실행하여 관련 팀원과 채팅이나 화상 회의를 시작할 수 있는 기능은, 문서의 특정 내용에 대해 즉각적인 논의가 필요할 때 컨텍스트 전환 없이 원활한 소통을 가능하게 한다.8</p>
<h4>2.2.2 브레인스토밍 및 시각화</h4>
<p>초기 아이디어 단계에서는 텍스트보다 시각적인 도구가 더 효과적일 수 있다. NextCloud Whiteboard는 무한한 캔버스를 제공하는 디지털 화이트보드 앱으로, 팀원들이 실시간으로 함께 아이디어를 스케치하고, 다이어그램을 그리며, 프로세스 흐름도를 설계하는 등 창의적인 브레인스토밍을 지원한다.12 다양한 색상과 도형, 이미지 삽입 기능을 활용하여 복잡한 개념을 시각적으로 구조화할 수 있으며, 완성된 작업물은 PNG나 SVG와 같은 표준 이미지 파일로 내보내 다른 문서에 첨부하거나 공유할 수 있다.</p>
<h4>2.2.3 지식 베이스 구축</h4>
<p>연구 프로젝트에서 생성되는 지식과 노하우를 체계적으로 축적하고 공유하는 것은 조직의 중요한 자산 관리 활동이다. NextCloud는 마크다운(Markdown) 기반의 간단하고 강력한 노트 앱인 NextCloud Text를 기본으로 제공한다.13 이를 활용하여 개인적인 연구 노트나 회의록을 쉽게 작성할 수 있다. 더 나아가, Collectives 앱을 설치하면 여러 Text 페이지를 구조화된 지식 베이스, 즉 내부 위키(Wiki)로 구축하고 관리할 수 있다.11 실험 절차(SOP), 분석 방법론, 자주 묻는 질문(FAQ) 등을 Collectives 페이지로 정리해두면, 신규 팀원이 빠르게 업무에 적응하고 조직 전체의 지식 수준을 상향 평준화하는 데 크게 기여할 수 있다.</p>
<h3>2.3  R&amp;D 조직을 위한 파일 및 폴더 구조화 모범 사례</h3>
<h4>2.3.1 일관된 명명 규칙</h4>
<p>체계적인 파일 관리는 검색의 효율성과 직결된다. 프로젝트의 모든 구성원이 따라야 할 일관된 파일 명명 규칙을 수립하는 것은 매우 중요하다. 좋은 명명 규칙은 파일의 이름만으로도 그 내용과 맥락을 유추할 수 있게 한다. 일반적으로 날짜, 프로젝트 식별자, 데이터 유형, 연구자 이니셜, 버전 정보 등을 조합하여 사용한다.14</p>
<ul>
<li>
<p><strong>날짜 형식:</strong> <code>YYYYMMDD</code> (예: <code>20250815</code>) 형식을 사용하면 파일이 항상 시간순으로 정렬된다.</p>
</li>
<li>
<p><strong>구분자:</strong> 단어와 메타데이터 요소를 구분하기 위해 공백이나 특수문자 대신 언더스코어(<code>_</code>)나 하이픈(<code>-</code>)을 사용한다.</p>
</li>
<li>
<p><strong>버전:</strong> <code>v01</code>, <code>v02</code>와 같이 두 자리 숫자로 버전을 표기하면 10번째 버전 이후에도 정렬이 깨지지 않는다.</p>
</li>
</ul>
<p><strong>예시:</strong> <code>20250815_PROJ-A_RawData_JHK_v01.csv</code></p>
<p>위 예시는 ’2025년 8월 15일에 A 프로젝트와 관련하여 연구원 JHK가 생성한 첫 번째 버전의 원시 데이터’라는 정보를 명확하게 전달한다.</p>
<h4>2.3.2 계층적 폴더 구조</h4>
<p>일관된 폴더 구조는 프로젝트 자산을 논리적으로 정리하고, 팀원들이 필요한 파일을 쉽게 찾을 수 있도록 돕는다. 일반적으로 프로젝트 단위로 최상위 폴더를 생성하고, 그 아래에 연구 활동의 단계나 자산 유형에 따라 표준화된 하위 폴더를 구성하는 것이 효과적이다.14</p>
<p><strong>예시 폴더 구조:</strong></p>
<pre><code>/Project_Alpha/
├── 01_Data/
│   ├── 01_Raw/
│   └── 02_Processed/
├── 02_Documents/
│   ├── 01_Proposals/
│   ├── 02_Meeting_Notes/
│   └── 03_Reports/
├── 03_Code/
├── 04_Results/
│   ├── 01_Figures/
│   └── 02_Tables/
└── 05_Admin/
    └── 01_Contracts/
</code></pre>
<p>이러한 구조를 템플릿으로 만들어두고, 새로운 프로젝트가 시작될 때마다 복사하여 사용하면 모든 프로젝트에서 일관성을 유지할 수 있다.</p>
<h4>2.3.3 워크스페이스(Workspaces) 활용</h4>
<p>NextCloud의 워크스페이스는 각 폴더에 맥락(Context)을 부여하는 강력한 기능이다.5 폴더 보기 화면의 상단 영역에 마크다운 형식의 노트, 할 일 목록(To-do list), 그리고 중요한 파일이나 외부 링크 바로가기를 추가할 수 있다. 예를 들어,</p>
<p><code>01_Data</code> 폴더의 워크스페이스에는 해당 폴더에 저장되어야 할 데이터의 형식과 명명 규칙을 명시하고, <code>04_Results</code> 폴더에는 결과 해석 시 주의해야 할 사항이나 관련 OpenProject 작업 패키지 링크를 추가할 수 있다. 이는 폴더의 목적과 사용 방법을 팀원들에게 명확하게 전달하여 협업의 오류를 줄이고 효율성을 높이는 데 매우 유용하다.</p>
<h2>3. 부: 프로젝트 관리 프레임워크 구축: OpenProject 도입</h2>
<h3>3.1  R&amp;D 프로젝트 생애주기 모델링</h3>
<h4>3.1.1 하이브리드 방법론의 중요성</h4>
<p>R&amp;D 프로젝트는 본질적으로 불확실성을 내포하고 있다. 한편으로는 명확한 목표와 일정을 가진 예측 가능한 개발 활동이 존재하지만, 다른 한편으로는 결과 예측이 어려운 탐색적 연구 활동이 혼재한다. 이러한 특성 때문에 단일한 프로젝트 관리 방법론을 적용하기 어렵다. OpenProject는 이러한 R&amp;D 프로젝트의 이중적 성격을 효과적으로 관리할 수 있도록 전통적인 폭포수(Waterfall) 모델과 현대적인 애자일(Agile) 방법론을 모두 지원하며, 이를 하나의 프로젝트 내에서 유연하게 결합하는 하이브리드 접근 방식을 제공한다.3 예를 들어, 프로젝트의 전체적인 로드맵과 주요 마일스톤은 Gantt 차트를 통해 관리하면서, 단기적인 실험 및 개발 사이클은 애자일 보드를 통해 운영할 수 있다.</p>
<h4>3.1.2 단계별 게이트(Phase-Gate) 프로세스</h4>
<p>특히 장기적이고 복잡한 연구 과제는 아이디어 발상, 타당성 검토, 프로토타입 개발, 내부 검증, 상용화 준비 등 명확한 단계를 거치게 된다. ‘단계별 게이트(Phase-Gate)’ 프로세스는 각 단계가 끝나는 시점에 공식적인 검토 회의(Gate)를 거쳐, 해당 프로젝트를 다음 단계로 진행시킬지(Go), 수정을 거쳐 보완할지(Recycle), 아니면 중단할지(Kill)를 결정하는 체계적인 의사결정 방법론이다.19 OpenProject에서는 각 단계를 ‘단계(Phase)’ 유형의 작업 패키지로, 게이트 검토 시점을 ’마일스톤(Milestone)’으로 설정하여 이 프로세스를 효과적으로 시스템화할 수 있다. 이를 통해 프로젝트의 진행 상황을 객관적으로 평가하고, 자원의 낭비를 막으며, 비즈니스 목표와의 정렬을 지속적으로 확인할 수 있다.</p>
<h3>3.2  작업 패키지(Work Package) 기반 실험 및 태스크 추적</h3>
<h4>3.2.1 작업의 원자 단위 정의</h4>
<p>OpenProject의 관리 철학의 핵심에는 ’작업 패키지(Work Package)’라는 개념이 있다. 작업 패키지는 프로젝트 목표를 달성하기 위해 수행되어야 할 작업의 가장 작은 관리 단위를 의미한다.3 R&amp;D 환경에서 이는 ‘신규 알고리즘 A에 대한 성능 실험’, ‘X 물질에 대한 데이터 수집’, ‘1차 결과 분석 보고서 작성’, ‘동료 검토(Peer Review) 수행’ 등 구체적인 연구 활동 하나하나에 해당한다. 모든 활동을 작업 패키지로 생성하고 관리함으로써, 프로젝트의 모든 진행 상황을 누락 없이 추적하고, 누가 무엇을 언제까지 해야 하는지에 대한 책임 소재를 명확히 할 수 있다.</p>
<h4>3.2.2 상세 정보 및 진행 상황 관리</h4>
<p>각 작업 패키지는 단순한 ‘할 일’ 목록을 넘어, 해당 작업에 대한 모든 정보를 담는 컨테이너 역할을 한다. 담당자, 시작일과 종료일, 예상 소요 시간, 현재 상태(예: 신규, 진행 중, 검토 중, 완료), 우선순위, 상세 설명 등을 체계적으로 기록할 수 있다.21 진행률(<code>% Complete</code>)은 작업의 상태가 변경될 때마다 미리 정의된 값으로 자동 업데이트되거나(Status-based), 예상 시간 대비 실제 소요 시간을 기반으로 계산되도록(Work-based) 설정할 수 있다.22</p>
<p>작업 패키지의 가장 강력한 기능 중 하나는 ‘활동(Activity)’ 탭이다. 이 탭에는 해당 작업 패키지와 관련된 모든 변경 이력(상태 변경, 담당자 변경 등)과 팀원 간의 토론(댓글)이 시간 순서대로 모두 기록된다.23 이는 특정 작업의 진행 과정에서 어떤 논의가 있었고 어떤 의사결정이 내려졌는지를 완벽하게 추적할 수 있게 하여, 프로젝트의 투명성과 책임성을 극대화한다.</p>
<p>이러한 특성은 작업 패키지를 단순한 관리 도구를 넘어 ’과학적 기록’의 역할을 수행하게 한다. 일반적인 프로젝트 관리에서 ’태스크’는 완료 여부가 중요하지만, R&amp;D에서 ’실험’이나 ’분석’은 그 과정과 결과 자체가 중요한 지식 자산이다. 왜 이 실험을 시작했는지(배경), 어떤 가정과 방법으로 수행했는지(방법론), 결과는 어떠했고 어떤 논의가 있었는지(결과 및 토론)가 모두 기록되어야 한다. OpenProject의 작업 패키지는 설명, 댓글, 파일 첨부, 상태 변경 이력 등 풍부한 정보를 담을 수 있는 디지털 컨테이너로서, 이러한 ’실험 노트’의 역할을 완벽하게 수행할 수 있다. 따라서 팀 문화를 구축할 때, 작업 패키지 하나를 하나의 작은 연구 활동에 대한 완결된 기록으로 취급하도록 장려해야 한다. 이렇게 체계적으로 관리된 작업 패키지들은 프로젝트가 종료된 후에도 왜 특정 연구 방향이 성공했거나 실패했는지에 대한 귀중한 근거 자료이자, 조직의 지식 자산으로 남게 된다.</p>
<h3>3.3  Gantt 차트를 이용한 장기 로드맵 및 마일스톤 관리</h3>
<h4>3.3.1 시각적 타임라인 계획</h4>
<p>Gantt 차트는 프로젝트의 전체적인 시간 계획을 시각적으로 표현하는 가장 효과적인 도구이다. OpenProject의 Gantt 차트 모듈은 프로젝트의 시작부터 끝까지 모든 작업 패키지를 타임라인 위에 막대 형태로 표시한다.20 이를 통해 팀원과 이해관계자들은 프로젝트의 전체적인 흐름과 각 작업의 일정을 한눈에 파악할 수 있다. 특히, 작업 패키지 간의 의존 관계(예: ‘A 작업이 끝나야 B 작업을 시작할 수 있다’)를 화살표로 연결하여 설정할 수 있어, 특정 작업의 지연이 전체 프로젝트에 미치는 영향을 즉각적으로 파악하고 대응할 수 있다. ‘논문 초고 제출’, ‘프로토타입 개발 완료’, ‘특허 출원’ 등 프로젝트의 중요한 성과 목표는 마일스톤으로 표시하여, 전체 로드맵 상에서 핵심적인 이정표를 명확히 관리할 수 있다.</p>
<h4>3.3.2 동적 일정 조정</h4>
<p>연구 프로젝트는 계획대로 진행되지 않는 경우가 많다. 예상치 못한 문제 발생이나 새로운 발견으로 인해 일정을 조정해야 할 필요가 빈번하게 발생한다. OpenProject의 Gantt 차트는 이러한 변화에 유연하게 대응할 수 있도록 설계되었다.25 사용자는 타임라인 상에서 작업 막대를 마우스로 끌어다 놓는(Drag and Drop) 방식으로 손쉽게 일정을 변경할 수 있다. 만약 변경된 작업이 다른 작업들과 의존 관계로 연결되어 있다면, 후행 작업들의 시작일과 종료일도 자동으로 함께 조정되어, 복잡한 일정 재수립 과정을 간소화하고 계획의 일관성을 유지해준다.</p>
<h3>3.4  애자일 보드를 통한 반복적 연구 스프린트 운영</h3>
<h4>3.4.1 단기 집중 및 빠른 피드백</h4>
<p>불확실성이 높은 탐색적 연구 단계나 빠른 프로토타이핑이 필요한 개발 단계에서는 장기적인 계획보다 단기적인 목표를 설정하고 반복적으로 실행하며 배우는 애자일 방식이 더 효과적이다. OpenProject는 스크럼(Scrum)과 칸반(Kanban)을 포함한 다양한 애자일 보드를 지원하여, 이러한 반복적 연구 스프린트 운영을 가능하게 한다.18 팀은 백로그(Backlog)에 있는 연구 아이디어나 실험 과제들 중에서 우선순위가 높은 항목들을 선택하여 2주에서 4주 단위의 스프린트(Sprint) 계획을 수립한다. 그리고 칸반 보드를 이용해 각 작업 패키지의 상태를 ‘할 일(To Do)’, ‘진행 중(In Progress)’, ‘완료(Done)’ 등의 열(Column) 사이에서 이동시키며 진행 상황을 시각적으로 관리한다. 이는 팀이 단기 목표에 집중하고, 스프린트가 끝날 때마다 결과물을 검토하며 빠른 피드백을 통해 다음 방향을 설정하는 데 도움을 준다.</p>
<h4>3.4.2 유연한 워크플로우</h4>
<p>모든 R&amp;D 팀의 작업 방식은 고유하다. OpenProject의 애자일 보드는 이러한 다양성을 수용할 수 있도록 높은 수준의 유연성을 제공한다. 팀은 자신들의 고유한 연구 프로세스에 맞춰 보드의 열을 자유롭게 추가, 수정, 삭제할 수 있다.18 예를 들어, 일반적인 ‘To Do - In Progress - Done’ 구조 대신, ’아이디어(Idea) → 실험 설계(Experiment Design) → 데이터 수집(Data Collection) → 분석 실행(Execution) → 동료 검토(Peer Review) → 완료(Done)’와 같이 연구의 실제 단계를 반영하는 맞춤형 워크플로우를 보드에 구현할 수 있다. 이러한 맞춤형 보드는 팀의 작업 흐름을 명확하게 시각화하고, 병목 현상이 발생하는 단계를 식별하여 프로세스를 개선하는 데 기여한다.</p>
<h2>4. 부: 재현 가능한 연구 및 개발 환경: GitLab 구현</h2>
<h3>4.1  코드, 스크립트, 기술 문서(LaTeX)의 형상 관리</h3>
<h4>4.1.1 모든 것의 버전 관리</h4>
<p>과학적 연구의 신뢰성은 재현 가능성에서 나온다. GitLab은 Git 버전 관리 시스템을 기반으로, 연구에 사용되는 모든 텍스트 기반 자산의 변경 이력을 체계적으로 관리하는 환경을 제공한다. 이는 Python이나 R로 작성된 분석 스크립트, 시뮬레이션 모델의 소스 코드, 서버 환경을 정의하는 설정 파일(e.g., Dockerfile), 그리고 연구 결과를 담은 <code>LaTeX</code> 논문에 이르기까지 모든 것을 포함한다.26 모든 변경 사항은 ’커밋(commit)’이라는 단위로 기록되며, 각 커밋은 고유한 식별자를 가지므로 특정 시점의 프로젝트 상태를 언제든지 정확하게 복원할 수 있다. 이는 “어제까지는 잘 되던 코드가 왜 오늘 안 되지?“와 같은 문제를 해결하고, 특정 분석 결과가 어떤 버전의 코드로 생성되었는지를 명확히 추적할 수 있게 하는, 재현 가능한 연구의 가장 기본적인 출발점이다.</p>
<h4>4.1.2 LaTeX 문서 협업</h4>
<p><code>LaTeX</code>는 수식 표현이 뛰어나고 문서 구조가 논리적이라 R&amp;D 논문 작성에 널리 사용되지만, 여러 저자가 공동으로 작업할 때 버전 관리에 어려움을 겪는 경우가 많다. GitLab을 사용하여 <code>LaTeX</code> 소스 파일(<code>.tex</code>)을 관리하면 이러한 문제를 효과적으로 해결할 수 있다. 각 저자는 자신의 컴퓨터에서 문서를 수정한 후 변경 사항을 중앙 리포지토리로 푸시(push)한다. 다른 저자가 동시에 같은 부분을 수정하여 충돌(conflict)이 발생하더라도, Git의 병합(merge) 도구를 사용하여 두 변경 사항을 비교하고 손쉽게 통합할 수 있다. 특히, 문장의 끝마다 줄바꿈을 하는 스타일로 <code>.tex</code> 파일을 작성하면, <code>git diff</code> 명령어를 통해 어느 문장이 추가, 삭제, 수정되었는지 명확하게 확인할 수 있어 변경 사항 검토가 매우 용이해진다.28 또한, 논문에 포함되는 이미지나 데이터 파일과 같은 바이너리 파일의 경우, GitLab의 파일 잠금(File Locking) 기능을 사용하면 한 사람이 파일을 수정하는 동안 다른 사람이 덮어쓰는 것을 방지하여 의도치 않은 데이터 손실을 막을 수 있다.27</p>
<h3>4.2  연구 프로젝트를 위한 Git 브랜칭 전략</h3>
<h4>4.2.1 R&amp;D 맞춤형 GitFlow</h4>
<p>효과적인 버전 관리를 위해서는 체계적인 브랜칭 전략이 필수적이다. 소프트웨어 개발 분야에서 널리 사용되는 GitFlow 모델은 안정적인 릴리즈 관리와 병렬적인 기능 개발을 조화롭게 지원하는 강력한 프레임워크다.29 R&amp;D 프로젝트 역시 안정적으로 관리되어야 하는 ’최종 결과물’과 유연하게 시도되어야 하는 ’새로운 실험’이 공존하므로, GitFlow의 핵심 철학을 연구 환경에 맞게 변형하여 적용하는 것이 매우 효과적이다.</p>
<p>이러한 접근 방식의 핵심은, 소프트웨어 개발 중심의 용어를 연구자에게 친숙하고 직관적인 용어로 재해석하여 버전 관리 전략의 도입 장벽을 낮추고, R&amp;D 프로세스와의 자연스러운 정합성을 확보하는 데 있다. 예를 들어, 새로운 기능을 개발하는 <code>feature</code> 브랜치는 새로운 가설을 검증하는 <code>experiment</code> 브랜치로, 제품 출시를 준비하는 <code>release</code> 브랜치는 논문이나 보고서 작성을 준비하는 <code>analysis</code> 브랜치로 개념을 전환할 수 있다. 이러한 재해석은 단순히 이름을 바꾸는 것을 넘어, Git의 강력한 버전 관리 체계를 연구의 자연스러운 흐름에 녹여내는 과정이다. 그 결과, <code>git log</code>는 단순한 코드 변경 기록의 나열이 아니라, 가설 수립, 실험 진행, 결과 도출, 논문 작성에 이르는 연구의 전체 과정을 담은 ’과학적 서사(scientific narrative)’가 된다.</p>
<h4>4.2.2 Table 2: 연구 프로젝트를 위한 GitFlow 변형 브랜칭 전략</h4>
<table><thead><tr><th>원본 GitFlow 브랜치</th><th>R&amp;D 변형 브랜치</th><th>역할 및 목적</th></tr></thead><tbody>
<tr><td><code>master</code> / <code>main</code></td><td><code>main</code></td><td><strong>출판/최종본 상태.</strong> 논문 게재, 최종 보고서 제출, 안정화된 모델/데이터셋 릴리즈 등 공식적인 연구 성과물을 반영한다. <code>main</code> 브랜치로의 병합은 프로젝트의 중요한 이정표(milestone)를 의미하며, 이 브랜치의 코드는 항상 재현 가능하고 안정적인 상태를 유지해야 한다.</td></tr>
<tr><td><code>develop</code></td><td><code>develop</code></td><td><strong>연구 통합 브랜치.</strong> 개별 <code>experiment</code> 브랜치에서 수행되고 검증된 실험 결과, 안정화된 분석 코드, 개선된 기능 등이 통합되는 브랜치다. 항상 최신 연구 진행 상태를 반영하며, 다음 <code>analysis</code> 브랜치나 새로운 <code>experiment</code> 브랜치의 시작점이 된다.</td></tr>
<tr><td><code>feature/*</code></td><td><code>experiment/*</code></td><td><strong>개별 실험 브랜치.</strong> 새로운 가설, 다른 모델 아키텍처, 새로운 데이터 전처리 방법 등 독립적인 실험을 수행하기 위한 공간이다. <code>develop</code> 브랜치에서 분기하며, 실험이 성공적으로 완료되면 <code>develop</code>으로 다시 병합된다. 실패한 실험은 병합하지 않고 폐기할 수 있어, <code>develop</code> 브랜치의 안정성을 해치지 않고 자유로운 탐색이 가능하다. 예: <code>experiment/bert-finetuning-with-new-dataset</code>.</td></tr>
<tr><td><code>release/*</code></td><td><code>analysis/*</code></td><td><strong>분석/논문 준비 브랜치.</strong> 특정 학회나 저널 제출을 목표로 결과를 종합하고, 그래프를 생성하며, 논문을 작성하는 등 최종 결과물을 준비하는 브랜치다. <code>develop</code> 브랜치에서 분기하며, 이 브랜치에서는 새로운 실험 추가는 금지되고, 오직 결과 재현, 시각화 코드 개선, 버그 수정, 문서 작업만 허용된다. 작업이 완료되면 <code>main</code>과 <code>develop</code> 브랜치 양쪽으로 병합된다. 예: <code>analysis/neurips-2025-submission</code>.</td></tr>
<tr><td><code>hotfix/*</code></td><td><code>hotfix/*</code></td><td><strong>긴급 수정 브랜치.</strong> 이미 <code>main</code> 브랜치에 반영된(예: 출판된) 연구 결과물에서 심각한 오류가 발견되었을 때, 이를 긴급하게 수정하기 위해 사용된다. <code>main</code> 브랜치에서 직접 분기하며, 수정이 완료되면 <code>main</code>과 <code>develop</code> 브랜치 모두에 병합하여 오류가 재발하지 않도록 한다.</td></tr>
</tbody></table>
<h3>4.3  GitLab CI/CD를 통한 분석 파이프라인 자동화</h3>
<h4>4.3.1 재현 가능한 연구의 핵심</h4>
<p>재현 가능한 연구를 위해서는 ‘누가, 언제, 어떤 환경에서 실행하든’ 동일한 결과가 나와야 한다. GitLab CI/CD(Continuous Integration/Continuous Deployment)는 이러한 요구사항을 충족시키는 핵심적인 도구다. 프로젝트의 루트 디렉토리에 <code>.gitlab-ci.yml</code>이라는 설정 파일을 작성하여, 데이터 전처리, 모델 학습, 성능 평가, 결과 시각화에 이르는 전체 분석 과정을 스크립트로 정의할 수 있다.31 개발자가 코드를 수정하여 리포지토리에 푸시(push)할 때마다, GitLab은 이 <code>.gitlab-ci.yml</code> 파일을 읽어 정의된 파이프라인을 자동으로 실행한다. 이는 모든 분석 과정이 인간의 수작업 개입 없이 자동화됨을 의미하며, 이를 통해 분석 과정의 재현성과 신뢰성을 근본적으로 보장한다.32</p>
<h4>4.3.2 컨테이너 기반 환경 격리</h4>
<p>“제 컴퓨터에서는 잘 실행됐는데, 다른 컴퓨터에서는 오류가 나요.“는 연구 협업에서 가장 흔하게 발생하는 문제 중 하나다. 이는 주로 각자의 컴퓨터에 설치된 라이브러리 버전이나 운영체제가 다르기 때문에 발생한다. GitLab CI/CD는 Docker 컨테이너 기술을 활용하여 이 문제를 완벽하게 해결한다.32</p>
<p><code>.gitlab-ci.yml</code> 파일에 분석에 필요한 특정 버전의 Python, R, 그리고 관련 라이브러리들이 모두 설치된 Docker 이미지를 지정하면, GitLab CI Runner는 항상 해당 컨테이너 환경 내에서 분석 작업을 실행한다. 즉, 분석 환경 자체가 코드(Dockerfile)로 관리되고 버전 제어되므로, 환경 의존성 문제가 원천적으로 제거되고 완벽한 이식성과 재현성을 확보할 수 있다.</p>
<h4>4.3.3 결과물(Artifacts) 관리</h4>
<p>CI/CD 파이프라인이 실행된 후 생성되는 최종 결과물(예: 학습된 모델 파일, 성능 지표가 담긴 CSV 파일, 결과 그래프 이미지 등)은 ’아티팩트(Artifacts)’로 지정하여 GitLab 서버에 저장할 수 있다.31 사용자는 GitLab 웹 인터페이스를 통해 각 파이프라인 실행의 아티팩트를 손쉽게 다운로드하여 결과를 확인할 수 있다. 또한, 파이프라인을 여러 단계(Stage)로 구성할 경우, 이전 단계에서 생성된 아티팩트를 다음 단계의 입력으로 전달하여 복잡한 워크플로우를 구성하는 것도 가능하다. 예를 들어, ‘build’ 단계에서 데이터를 전처리하고, ‘test’ 단계에서 해당 데이터를 사용하여 모델을 테스트한 후, ‘deploy’ 단계에서 테스트를 통과한 모델을 저장소에 배포하는 식이다.</p>
<h3>4.4  이슈 트래커를 활용한 기술적 문제 및 실험 관리</h3>
<h4>4.4.1 체계적인 문제 해결</h4>
<p>연구 개발 과정은 끊임없는 문제 해결의 연속이다. 코드의 버그, 성능 개선이 필요한 부분, 새롭게 시도해볼 만한 실험 아이디어 등 모든 논의와 관리 대상을 GitLab 이슈(Issue)로 등록하여 체계적으로 관리할 수 있다.33 각 이슈에는 담당자, 마감일, 그리고 ‘버그(bug)’, ‘개선(enhancement)’, ‘아이디어(idea)’, ’질문(question)’과 같은 레이블(Label)을 부여하여 이슈의 성격과 우선순위를 명확히 할 수 있다. 이를 통해 팀은 현재 해결해야 할 과제들을 한눈에 파악하고, 작업의 누락이나 중복을 방지하며, 자원을 효율적으로 배분할 수 있다.</p>
<h4>4.4.2 토론과 의사결정의 장</h4>
<p>GitLab 이슈는 단순한 작업 목록이 아니라, 특정 주제에 대한 심도 있는 토론과 의사결정이 이루어지는 협업의 장이다. 이슈의 댓글(Comment) 기능을 통해 팀원들은 특정 버그의 원인에 대해 논의하고, 새로운 실험 설계에 대한 의견을 교환하며, 기술적인 문제에 대한 해결책을 함께 모색할 수 있다.33 모든 논의 과정이 텍스트로 기록되기 때문에, 나중에 프로젝트에 합류한 사람도 과거의 의사결정 맥락을 쉽게 파악할 수 있다. 이는 R&amp;D의 핵심적인 문화인 동료 검토(peer review)와 지식 공유를 시스템적으로 지원하는 강력한 도구다.</p>
<h4>4.4.3 모범 사례 적용</h4>
<p>효과적인 이슈 관리를 위해서는 명확하고 실행 가능한 이슈를 작성하는 문화가 중요하다. GitLab은 이슈 템플릿(Issue Template) 기능을 제공하여, 이슈 생성 시 특정 양식을 따르도록 유도할 수 있다. 예를 들어, 버그 리포트 템플릿에는 ‘버그 재현을 위한 단계’, ‘기대했던 결과’, ‘실제로 나타난 결과’, ‘스크린샷 또는 로그 파일’, ’실행 환경 정보(OS, 라이브러리 버전 등)’와 같은 항목을 미리 포함시켜, 보고자가 문제 해결에 필요한 정보를 충분히 제공하도록 할 수 있다.34 이는 불필요한 커뮤니케이션 비용을 줄이고 문제 해결 속도를 높이는 데 크게 기여한다.</p>
<h2>5. 부: 통합 워크플로우 시나리오</h2>
<p>개별 도구의 기능은 그 자체로도 강력하지만, 이들의 진정한 가치는 서로 ’연결’될 때 발현된다. NextCloud의 파일, OpenProject의 작업, GitLab의 코드가 각자의 사일로에 머무는 것이 아니라, 서로를 참조하고 상태를 동기화하며, 하나의 활동이 다른 시스템의 자동화를 촉발하는 유기적인 생태계를 구성할 때, R&amp;D 워크플로우는 비로소 통합적인 힘을 갖게 된다. 예를 들어, NextCloud에 저장된 제안서 파일이 OpenProject의 특정 과업에 직접 연결되고 35, 그 과업의 진행 상황이 GitLab의 코드 커밋에 의해 자동으로 업데이트될 때 36, 프로젝트의 모든 관련 정보가 하나의 맥락으로 통합되어 ’단일 진실 공급원(Single Source of Truth)’이 형성된다. 이러한 연결은 단순히 정보를 조회하는 것을 넘어, GitLab의 커밋이 OpenProject 작업 상태를 변경하고 38, 이것이 다시 NextCloud 사용자에게 알림을 보내는 35 연쇄적인 자동화 반응을 가능하게 한다. 다음 시나리오들은 이러한 통합 워크플로우가 실제 R&amp;D 업무 프로세스에서 어떻게 구체화되는지를 단계별로 보여준다.</p>
<h3>5.1  시나리오 1: 신규 연구 과제 착수</h3>
<ol>
<li><strong>NextCloud (아이디어 구체화 및 자료 수집):</strong></li>
</ol>
<ul>
<li>
<p>연구 기획팀은 NextCloud에 <code>Project_Nebula</code> 폴더를 생성한다.</p>
</li>
<li>
<p><code>Project_Proposal.docx</code> 파일을 만들고, Nextcloud Office의 실시간 공동 편집 기능을 이용해 팀원들과 함께 연구 목표, 배경, 방법론, 기대 효과 등을 구체화한다.11</p>
</li>
<li>
<p>관련 시장 조사 자료, 경쟁 기술 분석 보고서, 참고 논문 PDF 파일들을 같은 폴더에 업로드하여 과제 기획에 필요한 모든 자료를 중앙에서 관리한다.</p>
</li>
</ul>
<ol start="2">
<li><strong>OpenProject (프로젝트 생성 및 계획 수립):</strong></li>
</ol>
<ul>
<li>
<p>과제 승인 후, 프로젝트 관리자는 OpenProject에 ’Project Nebula’라는 신규 프로젝트를 생성한다.</p>
</li>
<li>
<p>프로젝트의 주요 단계인 ‘1단계: 문헌 연구 및 기술 분석’, ‘2단계: 핵심 알고리즘 개발’, ’3단계: 프로토타입 구현 및 검증’을 마일스톤으로 설정한다.</p>
</li>
<li>
<p>1단계에 해당하는 ‘선행 기술 논문 30편 분석’, ‘특허 동향 조사’ 등의 구체적인 활동들을 작업 패키지로 생성하고, 담당자와 예상 완료일을 지정한다.20</p>
</li>
</ul>
<ol start="3">
<li><strong>NextCloud-OpenProject 연동 (컨텍스트 연결):</strong></li>
</ol>
<ul>
<li>
<p>OpenProject의 ‘Project Nebula’ 프로젝트 설정에서 ‘파일 저장소(File storages)’ 메뉴를 통해 NextCloud의 <code>Project_Nebula</code> 폴더를 공식 저장소로 연동한다.35</p>
</li>
<li>
<p>프로젝트의 최상위 작업 패키지(‘Project Nebula 기획 및 착수’)의 ‘파일(Files)’ 탭에서, NextCloud에 저장된 <code>Project_Proposal.docx</code> 파일을 직접 연결한다. 이제 팀원들은 OpenProject에서 과제의 목표를 확인하고, 클릭 한 번으로 관련 제안서 원본을 바로 열람할 수 있다.</p>
</li>
</ul>
<ol start="4">
<li><strong>GitLab (리포지토리 생성 및 연동):</strong></li>
</ol>
<ul>
<li>
<p>개발 리더는 GitLab에 <code>project-nebula</code>라는 이름의 신규 리포지토리를 생성한다. 3.2절에서 제시된 R&amp;D 맞춤형 브랜칭 전략에 따라 <code>main</code>과 <code>develop</code> 브랜치를 초기화한다.</p>
</li>
<li>
<p>OpenProject의 프로젝트 설정에서 ‘GitLab’ 탭을 활성화하고, 생성된 <code>project-nebula</code> 리포지토리를 Webhook과 API 토큰을 이용해 연결한다.36</p>
</li>
<li>
<p>이제 연구 개발자들은 OpenProject의 특정 작업 패키지(예: ‘알고리즘 프로토타입 구현’) 내에서 ‘브랜치 생성’ 버튼을 클릭하여, 작업 패키지 정보가 자동으로 포함된 이름의 <code>experiment</code> 브랜치를 GitLab에 직접 생성할 수 있다.</p>
</li>
</ul>
<h3>5.2  시나리오 2: 실험 데이터 분석 및 결과 공유</h3>
<ol>
<li><strong>GitLab (코드 개발 및 실행 요청):</strong></li>
</ol>
<ul>
<li>
<p>데이터 과학자는 OpenProject의 작업 패키지 #123 (‘사용자 행동 패턴 분석 모델 개발’)을 할당받는다.</p>
</li>
<li>
<p>GitLab에서 <code>experiment/user-behavior-model</code> 브랜치를 생성하고, 데이터 전처리 및 분석 스크립트(<code>analysis.py</code>)를 작성한다.</p>
</li>
<li>
<p>코드 작성이 완료되면, 변경 사항을 커밋하고 중앙 리포지토리로 푸시(push)한다. 이때 커밋 메시지에 <code>Refs OP#123: Implement initial clustering model</code>과 같이 관련 OpenProject 작업 패키지 ID를 명시적으로 포함한다.37</p>
</li>
</ul>
<ol start="2">
<li><strong>GitLab CI/CD (자동 분석 실행):</strong></li>
</ol>
<ul>
<li>
<p><code>experiment</code> 브랜치로의 푸시 이벤트는 <code>.gitlab-ci.yml</code>에 정의된 CI/CD 파이프라인을 자동으로 트리거한다.40</p>
</li>
<li>
<p>파이프라인의 첫 번째 잡(job)은 NextCloud에 저장된 원시 데이터(<code>raw_logs.csv</code>)를 WebDAV 프로토콜을 통해 안전하게 다운로드한다.</p>
</li>
<li>
<p>두 번째 잡은 <code>analysis.py</code> 스크립트를 실행하여 데이터 분석을 수행하고, 결과물인 <code>results.csv</code> 파일과 <code>cluster_distribution.png</code> 그래프를 생성한다. 이 결과물들은 파이프라인의 아티팩트로 저장된다.31</p>
</li>
</ul>
<ol start="3">
<li><strong>OpenProject (진행 상황 자동 업데이트):</strong></li>
</ol>
<ul>
<li>
<p>GitLab의 커밋 푸시 활동은 설정된 Webhook을 통해 실시간으로 OpenProject에 통지된다.</p>
</li>
<li>
<p>작업 패키지 #123의 ‘활동(Activity)’ 탭에는 “JHK pushed a commit to experiment/user-behavior-model“이라는 내용과 함께 커밋 메시지 및 GitLab 링크가 자동으로 기록된다.36 이를 통해 프로젝트 관리자는 별도의 보고 없이도 개발 진행 상황을 투명하게 파악할 수 있다.</p>
</li>
</ul>
<ol start="4">
<li><strong>NextCloud (결과물 자동 업로드):</strong></li>
</ol>
<ul>
<li>GitLab CI/CD 파이프라인의 마지막 단계(deploy)에서는, 생성된 아티팩트(<code>results.csv</code>, <code>cluster_distribution.png</code>)를 NextCloud API 또는 WebDAV 클라이언트를 사용하여 NextCloud의 <code>/Project_Nebula/04_Results/</code> 폴더에 자동으로 업로드하는 스크립트가 실행된다.41</li>
</ul>
<ol start="5">
<li><strong>OpenProject (결과 보고 및 검토 요청):</strong></li>
</ol>
<ul>
<li>
<p>데이터 과학자는 분석이 완료된 후, OpenProject 작업 패키지 #123의 상태를 ’진행 중(In Progress)’에서 ’검토 요청(For Review)’으로 변경한다.</p>
</li>
<li>
<p>댓글(comment)을 통해 “@팀장님, 초기 클러스터링 분석 완료되었습니다. 결과 파일은 NextCloud에서 확인 가능합니다.“라고 보고하며, NextCloud에 업로드된 결과 파일에 대한 공유 링크를 함께 첨부한다.</p>
</li>
</ul>
<h3>5.3  시나리오 3: LaTeX 논문 작성 및 공동 검토</h3>
<ol>
<li><strong>GitLab (버전 관리 및 자동 빌드):</strong></li>
</ol>
<ul>
<li>
<p>논문 주저자는 <code>develop</code> 브랜치에서 <code>analysis/neurips-2025-submission</code> 브랜치를 생성한다.</p>
</li>
<li>
<p><code>paper.tex</code>, <code>references.bib</code>, 그리고 관련 이미지 파일들을 리포지토리에 추가하고 논문 초고를 작성한다.</p>
</li>
<li>
<p><code>.gitlab-ci.yml</code> 파일에는 <code>texlive/texlive-full</code>과 같은 공식 <code>LaTeX</code> Docker 이미지를 사용하여, <code>.tex</code> 파일이 푸시될 때마다 <code>pdflatex</code>와 <code>bibtex</code> 명령어를 실행하여 <code>paper.pdf</code> 파일을 자동으로 컴파일하는 잡이 정의되어 있다.43 컴파일된 PDF는 아티팩트로 저장된다.</p>
</li>
</ul>
<ol start="2">
<li><strong>NextCloud (PDF 공유 및 피드백 수집):</strong></li>
</ol>
<ul>
<li>
<p>CI/CD 파이프라인의 마지막 단계는 성공적으로 컴파일된 <code>paper.pdf</code> 파일을 NextCloud의 <code>/Project_Nebula/02_Documents/04_Drafts/</code> 폴더에 자동으로 업로드한다. 파일 이름에는 커밋 해시나 버전 번호를 포함하여(<code>paper_v1.2.pdf</code>) 버전을 명확히 한다.</p>
</li>
<li>
<p>주저자는 NextCloud에서 이 PDF 파일에 대한 ’링크 공유’를 생성하고, 공동 저자 및 외부 검토자들에게 전달한다. 이때 ‘댓글 허용’ 권한을 부여한다.8</p>
</li>
</ul>
<ol start="3">
<li><strong>NextCloud-ONLYOFFICE (PDF 주석 달기):</strong></li>
</ol>
<ul>
<li>
<p>검토자들은 별도의 PDF 뷰어 프로그램 없이, 웹 브라우저에서 직접 NextCloud에 접속하여 논문 PDF를 열람한다.</p>
</li>
<li>
<p>ONLYOFFICE 통합 기능을 통해, PDF의 특정 텍스트나 그림에 하이라이트를 하거나, 수정 제안, 질문 등의 주석(Annotation)과 댓글을 직접 남길 수 있다.44 모든 피드백이 단일 파일에 중앙 집중화되어 관리된다.</p>
</li>
</ul>
<ol start="4">
<li><strong>OpenProject (수정 사항 관리):</strong></li>
</ol>
<ul>
<li>
<p>주저자는 NextCloud에 수집된 모든 피드백을 검토한 후, ‘서론 부분 재작성’, ‘그림 3의 해상도 개선’, ‘관련 연구 섹션 보강’ 등 주요 수정 사항들을 OpenProject에 별도의 작업 패키지로 등록한다.</p>
</li>
<li>
<p>각 작업 패키지의 설명란에는 NextCloud PDF의 특정 댓글에 대한 링크를 첨부하여, 수정의 근거와 맥락을 명확히 한다.</p>
</li>
</ul>
<ol start="5">
<li><strong>GitLab (수정 및 최종 병합):</strong></li>
</ol>
<ul>
<li>
<p>저자들은 OpenProject에 등록된 작업 패키지들을 기반으로 <code>.tex</code> 소스 파일을 체계적으로 수정하고, 각 수정 사항이 완료될 때마다 관련 작업 패키지 ID를 포함하여 커밋한다.</p>
</li>
<li>
<p>모든 수정이 완료되고 최종 검토를 거친 후, <code>analysis/neurips-2025-submission</code> 브랜치를 <code>develop</code>으로, 그리고 최종적으로 <code>main</code> 브랜치로 병합하여 논문 제출 버전을 확정한다. <code>main</code> 브랜치의 해당 커밋에는 <code>neurips-2025-submission</code>이라는 태그(tag)를 부여하여 중요한 버전을 기록한다.</p>
</li>
</ul>
<h3>5.4  자동화 심화: Webhook과 API를 활용한 워크플로우 최적화</h3>
<p>위에 제시된 시나리오들은 각 플랫폼의 기본 연동 기능을 활용한 것이다. 더 나아가, 각 플랫폼이 제공하는 Webhook과 API를 활용하면 조직의 고유한 요구사항에 맞는 더욱 정교하고 강력한 자동화 워크플로우를 구축할 수 있다.</p>
<ul>
<li>
<p><strong>Webhook 기반 실시간 이벤트 연동:</strong> Webhook은 특정 이벤트가 발생했을 때 지정된 URL로 실시간 알림(HTTP POST 요청)을 보내는 기능이다. 이를 활용하면, 예를 들어 GitLab에서 새로운 머지 리퀘스트(Merge Request)가 생성되면 45, 해당 내용을 OpenProject의 관련 작업 패키지에 자동으로 댓글로 추가할 수 있다. 반대로, OpenProject에서 작업 패키지의 상태가 ’완료’로 변경되면, GitLab의 관련 브랜치를 자동으로 삭제하거나, NextCloud의 특정 폴더에 알림 파일을 생성하는 등의 연쇄 반응을 설계할 수 있다.</p>
</li>
<li>
<p><strong>API를 통한 커스텀 스크립팅:</strong> 각 플랫폼은 외부 애플리케이션이 자신들의 기능과 데이터에 프로그래밍 방식으로 접근할 수 있도록 REST API를 제공한다.38 이를 활용하여 Python이나 셸 스크립트로 커스텀 자동화 로직을 구현할 수 있다. 예를 들어, OpenProject에서 ‘데이터 수집’ 유형의 신규 작업 패키지가 생성되면, 이를 감지하여 NextCloud에 해당 과제를 위한 표준 폴더 구조(</p>
</li>
</ul>
<p><code>01_Data</code>, <code>02_Documents</code> 등)를 자동으로 생성하는 스크립트를 작성할 수 있다. 또한, n8n이나 Zapier와 같은 로우코드(low-code) 워크플로우 자동화 도구를 활용하면, 복잡한 코딩 없이도 이러한 API 기반 연동을 시각적인 인터페이스로 손쉽게 구현할 수 있다.42</p>
<h2>6. 부: R&amp;D 조직을 위한 핵심 수식 관리</h2>
<h3>6.1  <code>LaTeX</code> 수식 작성 기본 원칙 및 모범 사례</h3>
<p>R&amp;D 결과물을 담는 보고서와 논문에서 수식은 아이디어와 방법론을 정확하고 간결하게 전달하는 핵심적인 언어다. <code>LaTeX</code>는 이러한 수식을 표현하는 데 가장 강력한 도구이지만, 협업과 버전 관리 환경에서는 몇 가지 원칙을 따르는 것이 중요하다.</p>
<ul>
<li>
<p><strong>가독성과 일관성:</strong> 복잡한 수식은 <code>amsmath</code> 패키지의 <code>align</code>이나 <code>gather</code> 환경을 사용하여 여러 줄로 명확하게 나누어 작성한다. 모든 중요한 수식에는 <code>\label{eq:short_name}</code>과 같이 고유한 레이블을 부여하고, 본문에서는 <code>\ref{eq:short_name}</code>이나 <code>\eqref{eq:short_name}</code>을 사용하여 참조한다. 이는 수식 번호가 변경되더라도 자동으로 업데이트되도록 보장한다. 또한, 프로젝트 전반에 걸쳐 반복적으로 사용되는 수학적 표현이나 변수는 <code>\newcommand{\loss}{\mathcal{L}}</code>와 같이 사용자 정의 매크로로 정의하여 일관성을 유지하고, 나중에 표기법을 변경해야 할 때 용이하게 대처할 수 있다.</p>
</li>
<li>
<p><strong>버전 관리 용이성:</strong> Git과 같은 버전 관리 시스템에서 변경 사항을 효과적으로 추적하기 위해, 가급적 한 줄에 하나의 논리적 단위(수식 한 줄, 선언문 하나 등)만 작성하는 것이 좋다.28 이렇게 하면</p>
</li>
</ul>
<p><code>git diff</code>를 실행했을 때, 수식의 어느 부분이 정확히 변경되었는지를 명확하게 보여주어 코드 리뷰와 충돌 해결을 훨씬 쉽게 만든다.</p>
<h3>6.2  주요 과학 및 머신러닝 분야별 <code>LaTeX</code> 수식 예제</h3>
<p>R&amp;D 조직, 특히 데이터 과학 및 머신러닝 분야의 연구원들은 반복적으로 특정 수식들을 사용하게 된다. 이러한 핵심 수식들을 표준화된 <code>LaTeX</code> 코드로 정리하여 제공하면, 문서 작성의 효율성을 높이고 팀 내 표기법의 일관성을 유지하며, 잠재적인 오류를 줄일 수 있다. 아래 표는 일종의 ‘수식 코드 라이브러리’ 또는 ‘치트 시트(Cheat Sheet)’ 역할을 하며, 연구원들이 필요할 때마다 복사하여 즉시 사용할 수 있는 실용적인 자산을 제공한다.</p>
<h4>6.2.1 Table 3: 주요 머신러닝 모델 및 통계 분석 <code>LaTeX</code> 수식 코드</h4>
<table><thead><tr><th>수식 명칭 (Equation Name)</th><th><code>LaTeX</code> 코드 (<code>LaTeX</code> Code)</th></tr></thead><tbody>
<tr><td>평균 제곱 오차 (Mean Squared Error, MSE)</td><td><span class="math math-inline">L_{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2</span></td></tr>
<tr><td>교차 엔트로피 손실 (Cross-Entropy Loss)</td><td><span class="math math-inline">L_{CE} = - \sum_{i=1}^{C} y_i \log(\hat{y}_i)</span></td></tr>
<tr><td>L2 정규화 (L2 Regularization)</td><td><span class="math math-inline">\Omega(\theta) = \frac{1}{2} \lambda \Vert \theta \Vert_2^2</span></td></tr>
<tr><td>소프트맥스 함수 (Softmax Function)</td><td><span class="math math-inline">\sigma(z)_j = \frac{e^{z_j}}{\sum_{k=1}^{K} e^{z_k}}</span></td></tr>
<tr><td>어텐션 메커니즘 (Scaled Dot-Product Attention) 48</td><td><span class="math math-inline">\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V</span></td></tr>
<tr><td>베이즈 정리 (Bayes’ Theorem)</td><td><span class="math math-inline">P(A \vert B) = \frac{P(B \vert A) P(A)}{P(B)}</span></td></tr>
<tr><td>시그모이드 함수 (Sigmoid Function)</td><td><span class="math math-inline">\sigma(x) = \frac{1}{1 + e^{-x}}</span></td></tr>
<tr><td>코사인 유사도 (Cosine Similarity)</td><td><span class="math math-inline">\text{similarity} = \cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{\Vert \mathbf{A} \Vert \Vert \mathbf{B} \Vert}</span></td></tr>
</tbody></table>
<h2>7. 결론</h2>
<h3>7.1 통합 워크플로우의 핵심 가치 요약</h3>
<p>본 안내서에서 제시한 NextCloud, OpenProject, GitLab의 통합 워크플로우는 단순한 도구의 조합을 넘어, R&amp;D 조직의 운영 방식 자체를 혁신할 수 있는 강력한 프레임워크다. 이 워크플로우가 제공하는 네 가지 핵심 가치는 다음과 같이 요약할 수 있다.</p>
<ol>
<li>
<p><strong>데이터 주권 (Data Sovereignty):</strong> 민감한 연구 데이터와 지적 재산을 외부 서비스의 통제에서 벗어나 조직 내부에서 완벽하게 소유하고 관리함으로써, 최고 수준의 보안과 규정 준수를 달성한다.</p>
</li>
<li>
<p><strong>프로세스 투명성 (Process Transparency):</strong> 아이디어 발상부터 프로젝트 계획, 코드 개발, 결과 도출에 이르는 R&amp;D 전 과정을 단일화된 시스템 내에서 추적하고 감사할 수 있는 체계를 구축하여, 의사결정의 근거를 명확히 하고 책임성을 강화한다.</p>
</li>
<li>
<p><strong>협업 효율성 (Collaboration Efficiency):</strong> 데이터, 계획, 코드가 유기적으로 연결된 환경을 제공하여, 팀원들이 불필요한 컨텍스트 전환 없이 자신의 역할에 집중하고, 정보의 사일로화를 방지하며, 원활한 소통과 지식 공유를 촉진한다.</p>
</li>
<li>
<p><strong>연구 재현성 (Research Reproducibility):</strong> 코드, 데이터, 환경을 모두 버전으로 관리하고 분석 파이프라인을 자동화함으로써, 인간의 개입으로 인한 오류를 최소화하고 과학적 발견의 신뢰성과 객관성을 근본적으로 보장한다.</p>
</li>
</ol>
<h3>7.2 성공적인 도입을 위한 제언</h3>
<p>이러한 혁신적인 워크플로우를 성공적으로 조직에 정착시키기 위해서는 기술적인 구축뿐만 아니라, 전략적인 접근이 필요하다.</p>
<ul>
<li>
<p><strong>문화적 변화 관리:</strong> 새로운 도구의 도입은 기술적 문제를 넘어, 조직 구성원들의 일하는 방식과 습관의 변화를 요구한다. 따라서 명확한 가이드라인을 제공하고, 지속적인 교육과 워크숍을 통해 사용자의 숙련도를 높이며, 모든 논의와 결과물을 시스템에 기록하는 ‘문서화 우선(Documentation-First)’ 문화를 장려하는 것이 성공의 가장 중요한 열쇠다.</p>
</li>
<li>
<p><strong>점진적 도입 전략:</strong> 세 가지 플랫폼의 모든 기능을 한 번에 완벽하게 도입하려는 시도는 구성원들에게 과도한 부담을 줄 수 있다. 대신, 조직이 현재 겪고 있는 가장 시급한 문제(예: 파편화된 파일 관리)를 해결하는 것부터 시작하는 것이 좋다. 예를 들어, 먼저 NextCloud를 도입하여 데이터 중앙화를 달성한 후, 점진적으로 OpenProject를 연동하여 프로젝트 관리를 체계화하고, 마지막으로 GitLab을 통합하여 개발 프로세스를 고도화하는 단계적인 접근 방식이 효과적이다.</p>
</li>
<li>
<p><strong>커뮤니티 및 전문가 활용:</strong> NextCloud, OpenProject, GitLab은 모두 전 세계적으로 수많은 개발자와 사용자가 참여하는 활발한 오픈소스 커뮤니티를 기반으로 하고 있다. 시스템 구축 및 운영 과정에서 발생하는 문제들은 대부분 커뮤니티 포럼이나 문서를 통해 해결책을 찾을 수 있다.49 또한, 시스템의 안정성과 보안이 매우 중요한 미션 크리티컬 환경에서는, 각 플랫폼의 공식 파트너나 전문 컨설팅 기업의 지원을 받아 안정적인 시스템을 구축하고 장기적인 기술 지원을 받는 것을 적극적으로 고려해야 한다.50 이는 초기 투자 비용을 상회하는 안정성과 효율성을 가져다줄 것이다.</p>
</li>
</ul>
<h2>8. 참고 자료</h2>
<ol>
<li>Content collaboration platform - Nextcloud Hub, https://nextcloud.com/hub/</li>
<li>About Nextcloud, https://nextcloud.com/about/</li>
<li>Project management software for IT &amp; technology companies - OpenProject, https://www.openproject.org/project-management-it-technology/</li>
<li>GitLab Direction, https://about.gitlab.com/direction/</li>
<li>Nextcloud Files - Open source file sync and share platform, https://nextcloud.com/files/</li>
<li>OpenProject - Open Source Project Management Software, https://www.openproject.org/</li>
<li>Nextcloud - ArchWiki - Arch Linux, https://wiki.archlinux.org/title/Nextcloud</li>
<li>Sharing in Nextcloud, https://nextcloud.com/sharing/</li>
<li>Open source content collaboration platform - Nextcloud, https://nextcloud.com/content-collaboration-platform/</li>
<li>Nextcloud - Open source content collaboration platform, https://nextcloud.com/</li>
<li>Nextcloud Office - Self-hosted online office suite, https://nextcloud.com/office/</li>
<li>Nextcloud features that put you in control, https://nextcloud.com/features/</li>
<li>6 collaboration tools for business in Nextcloud Hub, https://nextcloud.com/blog/6-nextcloud-hub-collaboration-tools-for-business-productivity/</li>
<li>Organize your files | Data management - MIT Libraries, https://libraries.mit.edu/data-management/store/organize/</li>
<li>2 Naming Files - Effective Data Science, https://eds-notes.zakvarty.com/102-workflows-naming-files</li>
<li>File Naming Conventions - Harvard Biomedical Data Management, https://datamanagement.hms.harvard.edu/plan-design/file-naming-conventions</li>
<li>Reproducible Workflows - Data Science Lessons, https://datasci.kitzes.com/lessons/python/reproducible_workflow.html</li>
<li>Agile Project Management Software Open Source - OpenProject, https://www.openproject.org/collaboration-software-features/agile-project-management/</li>
<li>R&amp;D Project Management: key elements and best practices - Triskell Software, https://triskellsoftware.com/blog/randd-project-management-key-elements-best-practices/</li>
<li>Project Management Process Open Source - OpenProject, https://www.openproject.org/collaboration-software-features/project-management-process/</li>
<li>Work packages - OpenProject, https://www.openproject.org/docs/user-guide/projects/project-settings/work-packages/</li>
<li>Manage work package progress tracking - OpenProject, https://www.openproject.org/docs/system-admin-guide/manage-work-packages/work-package-progress-tracking/</li>
<li>Project and work package activity - OpenProject, https://www.openproject.org/docs/user-guide/activity/</li>
<li>What Is OpenProject? Uses, Features and Pricing - ProjectManager, https://www.projectmanager.com/blog/openproject</li>
<li>Gantt charts - OpenProject, https://www.openproject.org/docs/user-guide/gantt-chart/</li>
<li>What is GitLab Flow?, https://about.gitlab.com/topics/version-control/what-is-gitlab-flow/</li>
<li>How to implement version control with GitLab, https://about.gitlab.com/topics/version-control/how-implement-version-control/</li>
<li>Using LaTeX with Version Control - Reddit, https://www.reddit.com/r/LaTeX/comments/2mra3o/using_latex_with_version_control/</li>
<li>Gitflow Workflow | Atlassian Git Tutorial, https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow</li>
<li>A successful Git branching model - nvie.com, https://nvie.com/posts/a-successful-git-branching-model/</li>
<li>GitLab CI: Feature Overview, Tutorial and Best Practice - Codefresh, https://codefresh.io/learn/gitlab-ci/</li>
<li>How GitLab can help in research reproducibility, https://about.gitlab.com/blog/gitlab-and-reproducibility/</li>
<li>Issues | GitLab Docs, https://docs.gitlab.com/user/project/issues/</li>
<li>10 Essential Issue Tracking Best Practices for Streamlined Software Development, https://ones.com/blog/issue-tracking-best-practices-software-development/</li>
<li>Nextcloud integration - OpenProject, https://www.openproject.org/docs/user-guide/file-management/nextcloud-integration/</li>
<li>GitLab integration - OpenProject, https://www.openproject.org/docs/system-admin-guide/integrations/gitlab-integration/</li>
<li>GitLab integration - OpenProject, https://www.openproject.org/integrations/gitlab/</li>
<li>doc/user/project/integrations/open_project.md - GitLab, https://gitlab.com/gitlab-org/gitlab-ce/blob/e15c6c8d0058f229d5c7f39bd4babcd3b4b0a5fc/doc/user/project/integrations/open_project.md</li>
<li>Nextcloud integration - OpenProject, https://www.openproject.org/integrations/nextcloud/</li>
<li>GitLab CI/CD <code>workflow</code> keyword, https://docs.gitlab.com/ci/yaml/workflow/</li>
<li>Automated File Transfer from GitLab to Nextcloud via WebDAV/SSH - ℹ️ Support, https://help.nextcloud.com/t/automated-file-transfer-from-gitlab-to-nextcloud-via-webdav-ssh/217340</li>
<li>GitLab and Nextcloud: Automate Workflows with n8n, https://n8n.io/integrations/gitlab/and/nextcloud/</li>
<li>Changes · Compiling LaTeX documents with GitLab CI · Wiki · Island of TeX / images / texlive, https://gitlab.com/islandoftex/images/texlive/-/wikis/Compiling-LaTeX-documents-with-GitLab-CI/diff?version_id=4fb5b61ad0b27547358c08462ece71332244d2b6</li>
<li>How to collaborate on PDF files within Nextcloud - OnlyOffice, https://www.onlyoffice.com/blog/2024/11/collaborate-on-pdf-files-within-nextcloud</li>
<li>Webhooks - GitLab Docs, https://docs.gitlab.com/user/project/integrations/webhooks/</li>
<li>Integration of OpenProject project manager in Nextcloud - GitHub, https://github.com/nextcloud/integration_openproject</li>
<li>Trigger pipelines with the API - GitLab Docs, https://docs.gitlab.com/ci/triggers/</li>
<li>Classical ML Equations in LaTeX, https://blmoistawinde.github.io/ml_equations_latex/</li>
<li>OpenProject Community Edition - Free and Open Source, https://www.openproject.org/community-edition/</li>
<li>OpenProject integrations, https://www.openproject.org/integrations/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>