<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:LIO-SAM 코드 설명</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>LIO-SAM 코드 설명</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">SLAM (Simultaneous Localization and Mapping)</a> / <a href="index.html">LIO-SAM</a> / <span>LIO-SAM 코드 설명</span></nav>
                </div>
            </header>
            <article>
                <h1>LIO-SAM 코드 설명</h1>
<h2>1.  서론</h2>
<h3>1.1 SLAM 기술의 발전과 센서 융합의 필요성</h3>
<p>동시적 위치 추정 및 지도 작성(Simultaneous Localization and Mapping, SLAM) 기술은 자율 이동 로봇이 미지의 환경에서 자신의 위치를 파악하고 동시에 주변 환경의 지도를 구축하는 핵심적인 기술이다.1 이는 로봇의 자율 주행, 경로 계획, 장애물 회피 등 고차원적인 작업을 수행하기 위한 근본적인 전제 조건이다. 지난 수십 년간 SLAM 기술은 비약적인 발전을 이루었으며, 초기에는 단일 센서를 활용하는 연구가 주를 이루었다.</p>
<p>그러나 단일 센서 기반의 SLAM 시스템은 본질적인 한계를 가진다. 시각 SLAM(Visual SLAM)은 카메라를 주 센서로 사용하며, 저렴하고 풍부한 환경 정보를 얻을 수 있다는 장점이 있지만 조명 변화에 매우 민감하고, 텍스처가 부족한 환경에서는 특징점 추출에 실패하여 추적 성능이 급격히 저하된다.1 반면, 라이다(LiDAR, Light Detection and Ranging) SLAM은 레이저를 이용하여 주변 환경까지의 거리를 정밀하게 측정하므로 조명 변화에 강인하고 높은 정확도의 3D 구조 정보를 획득할 수 있다. 하지만 복도나 넓은 공터와 같이 기하학적 특징이 부족한 환경에서는 스캔 정합(scan matching)이 모호해져 위치 추정에 실패할 수 있다.1</p>
<h3>1.2 LiDAR와 IMU의 상보성</h3>
<p>이러한 단일 센서의 한계를 극복하기 위해 다중 센서 융합(multi-sensor fusion) 기술이 필수적인 해결책으로 부상했다. 특히 LiDAR와 관성 측정 장치(IMU, Inertial Measurement Unit)의 조합은 매우 강력한 상보성을 제공한다. LiDAR는 일반적으로 10-20 Hz의 낮은 주파수로 주변 환경의 정밀한 3D 스캔 데이터를 제공하여 누적 오차(drift)가 적은 위치 추정을 가능하게 한다. 반면, IMU는 100 Hz 이상의 높은 주파수로 가속도와 각속도 정보를 제공하여 빠르고 급격한 움직임을 민첩하게 측정할 수 있지만, 측정값을 적분하여 위치를 추정하는 과정에서 오차가 빠르게 누적되는 단점이 있다.6</p>
<p>이 두 센서를 융합하면, IMU는 LiDAR 스캔 사이의 고주파 움직임을 보간하여 LiDAR 데이터의 왜곡을 보정하고, 스캔 정합의 초기 추정치를 제공하여 정확도와 강인성을 높인다. 동시에, LiDAR는 정확한 저주파 위치 정보를 제공하여 IMU의 누적 오차와 바이어스(bias)를 지속적으로 보정해준다. 이처럼 두 센서는 서로의 단점을 보완하며 전체 시스템의 성능을 극대화한다.</p>
<h3>1.3 LOAM의 유산과 한계</h3>
<p>LiDAR 기반 SLAM 분야에서 Ji Zhang과 Sanjiv Singh의 LOAM(Lidar Odometry and Mapping)은 기념비적인 연구로 평가받는다.6 LOAM은 LiDAR 스캔에서 곡률(curvature) 기반으로 에지(edge)와 평면(planar) 특징점을 추출하고, 이를 각각 점-선(point-to-line) 및 점-평면(point-to-plane) 거리 최소화 문제로 풀어 고속의 주행 거리 측정(odometry)과 저속의 지도 작성을 병렬적으로 수행하는 독창적인 아키텍처를 제시했다. 이 방식은 당시 최고 수준의 정확도를 달성하며 이후 수많은 LiDAR SLAM 연구의 기반이 되었다.</p>
<p>하지만 LOAM은 루프 폐쇄(loop closure) 기능이 없어 이전에 방문했던 장소를 재인식하여 누적된 오차를 전역적으로 보정할 수 없었다. 또한, GPS와 같은 절대적인 위치 정보를 통합할 수 있는 체계적인 프레임워크가 부재하여 장시간, 대규모 환경에서는 드리프트가 필연적으로 누적되는 한계를 가졌다.8</p>
<h3>1.4 LIO-SAM의 핵심 기여</h3>
<p>LIO-SAM(Lidar Inertial Odometry via Smoothing and Mapping)은 바로 이러한 LOAM의 한계를 극복하고 현대적인 SLAM 패러다임을 제시한 연구이다.6 LIO-SAM의 핵심 기여는 크게 두 가지로 요약할 수 있다. 첫째, LiDAR와 IMU 데이터를 강결합(tightly-coupled) 방식으로 융합한다. 이는 각 센서의 원시 측정값을 통합된 최적화 문제 내에서 함께 처리하여 상호작용을 극대화하는 방식이다. 둘째, 전체 시스템을 요인 그래프(factor graph) 기반의 평활화 및 매핑(smoothing and mapping) 프레임워크 위에 구축했다.5</p>
<p>이러한 요인 그래프 구조는 LIO-SAM에 이전 SLAM 시스템들과는 차별화되는 강력한 유연성과 확장성을 부여한다. 기존의 필터 기반 방식(예: 확장 칼만 필터)이나 LOAM의 ad-hoc 최적화 방식이 과거의 상태를 다시 고려하지 못하고 오직 미래의 상태만을 추정하는 순방향(forward-propagating) 문제 해결 방식이었던 반면, 요인 그래프는 로봇의 전체 궤적과 모든 측정값을 하나의 거대한 제약 조건 네트워크로 유지한다. 이는 SLAM 문제를 단일 시점의 상태 추정 문제가 아닌, 전체 궤적에 대한 평활화(smoothing) 문제로 재정의하는 패러다임의 전환을 의미한다. 이로 인해 LIO-SAM은 IMU 사전 적분, LiDAR 주행 거리 측정과 같은 상대적 측정(relative measurement)뿐만 아니라, GPS나 루프 폐쇄와 같은 절대적 측정(absolute measurement)까지도 ’요인(factor)’이라는 일관된 형태로 그래프에 추가하여 전역적으로 최적화할 수 있게 되었다.5 이 아키텍처적 선택은 LIO-SAM이 LOAM을 뛰어넘는 높은 전역적 정확도와 강인성을 달성하게 된 근본적인 원인이다.</p>
<h2>2.  LIO-SAM 시스템 아키텍처</h2>
<h3>2.1 전체 데이터 흐름</h3>
<p>LIO-SAM 시스템은 3D LiDAR, IMU, 그리고 선택적으로 GPS 수신기로부터 센서 데이터를 입력받는다. 이 입력 데이터들은 여러 단계의 처리를 거쳐 최종적으로 로봇의 실시간 6자유도(6-DoF) 궤적과 주변 환경의 3D 포인트 클라우드 맵을 출력한다. 전체 시스템은 네 가지 종류의 요인, 즉 (a) IMU 사전 적분 요인, (b) LiDAR 주행 거리 측정 요인, (c) GPS 요인, (d) 루프 폐쇄 요인을 생성하여 하나의 요인 그래프를 구성하고, 이를 지속적으로 최적화함으로써 전역적으로 일관된 해를 찾아낸다.5</p>
<h3>2.2 핵심 소프트웨어 모듈 분석</h3>
<p>LIO-SAM은 로봇 운영체제(ROS, Robot Operating System) 환경에서 여러 노드(node)가 유기적으로 상호작용하는 형태로 구현되어 있다. 각 노드는 특정 역할을 수행하며, 시스템의 핵심 기능은 주로 세 개의 C++ 소스 파일에 구현되어 있다.12</p>
<ul>
<li>
<p><strong><code>imageProjection.cpp</code>:</strong> 이 모듈은 센서 데이터 처리의 가장 앞단에 위치한다. 원시(raw) LiDAR 포인트 클라우드 데이터를 입력받아 전처리를 수행한다. LIO-SAM은 포인트 클라우드 내 각 포인트의 상대적 타임스탬프(timestamp)와 링 번호(ring number) 정보를 요구하는데, 이는 포인트 클라우드 왜곡 보정(deskewing)과 데이터 구조화에 필수적이다.12 이 모듈은 IMU 사전 적분 모듈로부터 전달받은 고주파의 운동 정보를 이용하여, LiDAR 스캔이 진행되는 동안 발생한 로봇의 움직임으로 인한 포인트 클라우드의 왜곡을 보정한다. 왜곡 보정이 완료된 포인트 클라우드에 대해 LOAM과 유사한 방식으로 각 포인트의 곡률을 계산하여, 기하학적 특징에 따라 에지(edge) 및 평면(planar) 특징점을 추출하고 다음 단계로 전달한다.</p>
</li>
<li>
<p><strong><code>imuPreintegration.cpp</code>:</strong> 이 모듈은 IMU 데이터를 처리하는 핵심부이다. IMU 센서로부터 높은 주파수(예: 200Hz 이상)의 가속도 및 각속도 데이터를 수신하여, 두 LiDAR 키프레임(keyframe) 사이의 상대적인 움직임(회전, 속도, 위치 변화)을 미리 계산하는 사전 적분(pre-integration)을 수행한다. 이 사전 적분 결과는 세 가지 중요한 용도로 사용된다. 첫째, <code>imageProjection.cpp</code> 모듈에 전달되어 포인트 클라우드 왜곡 보정에 사용된다. 둘째, <code>mapOptimization.cpp</code> 모듈에 전달되어 LiDAR 스캔 매칭 시 필요한 초기 추정치를 제공한다. 셋째, 요인 그래프에 추가될 IMU 요인을 생성한다. 특히 이 모듈은 실시간 성능을 보장하기 위해 독특한 구조를 가진다. IMU 바이어스 추정을 위해 LiDAR 주행 거리 측정 요인과 IMU 요인만을 포함하는 작은 규모의 요인 그래프를 독립적으로 유지하고, 이를 주기적으로 최적화한 뒤 리셋한다. 이 구조 덕분에 전역 최적화의 계산 부하와 무관하게 항상 최신의 IMU 바이어스 추정치를 확보하고 고주파의 주행 거리 측정을 출력할 수 있다.12</p>
</li>
<li>
<p><strong><code>mapOptimization.cpp</code>:</strong> 이 모듈은 LIO-SAM의 두뇌에 해당하는 전역 최적화 엔진이다. 다른 모듈들로부터 IMU 사전 적분 요인, LiDAR 주행 거리 측정 요인, 그리고 선택적으로 GPS 요인과 루프 폐쇄 요인을 모두 수신하여 하나의 거대한 전역 요인 그래프를 구성하고 유지한다. 이 그래프의 최적화는 GTSAM(Georgia Tech Smoothing and Mapping) 라이브러리에서 제공하는 iSAM2(incremental Smoothing and Mapping 2) 솔버를 통해 수행된다. iSAM2는 새로운 요인이 추가될 때마다 전체 그래프를 재계산하는 대신, 변화의 영향을 받는 부분만을 효율적으로 업데이트하는 증분(incremental) 최적화 기법을 사용하므로, 대규모 환경에서도 실시간 성능을 유지할 수 있다.5</p>
</li>
</ul>
<h3>2.3 슬라이딩 윈도우 기반 로컬 맵 관리</h3>
<p>대규모 환경에서 SLAM을 수행할 때, 새로운 LiDAR 스캔을 지금까지 누적된 모든 포인트 클라우드로 구성된 전역 맵(global map)에 정합하는 것은 엄청난 계산 비용을 요구한다. LIO-SAM은 이러한 문제를 해결하고 실시간 성능을 확보하기 위해 효율적인 슬라이딩 윈도우(sliding window) 기반의 로컬 맵 관리 전략을 채택했다.6</p>
<p>새로운 키프레임이 생성되면, 이 키프레임은 전체 맵이 아닌, 시간적으로 가장 최근의 고정된 개수(예: 25개)의 이전 키프레임들, 즉 “서브-키프레임(sub-keyframes)” 집합에만 정합된다. 이 서브-키프레임들의 포인트 클라우드를 월드 좌표계로 변환하여 합친 후 복셀(voxel) 그리드 필터로 다운샘플링하여 로컬 맵을 생성한다. 새로운 키프레임은 바로 이 로컬 맵에 대해서만 스캔 매칭을 수행한다. 이 ’로컬 스케일’에서의 정합은 ‘글로벌 스케일’ 정합에 비해 계산량을 획기적으로 줄여주며, LIO-SAM의 뛰어난 실시간 성능을 가능하게 하는 핵심 요소이다.5 또한, 슬라이딩 윈도우에서 밀려나는 아주 오래된 LiDAR 스캔과 관련 요인들은 최적화 과정에서 한계화(marginalization) 기법을 통해 제거된다. 이는 요인 그래프의 크기가 무한정 커지는 것을 방지하고 계산 복잡도를 일정하게 유지하는 데 기여한다.6</p>
<p>이러한 시스템 설계에는 중요한 공학적 타협이 숨어 있다. LIO-SAM의 공식 문서에서 언급된 두 개의 분리된 요인 그래프, 즉 <code>mapOptimization.cpp</code>의 전역 그래프와 <code>imuPreintegration.cpp</code>의 고주파 지역 그래프는 실시간 성능을 보장하기 위한 의도적인 설계이다.12 전역 그래프는 루프 폐쇄와 같은 복잡한 연산이 포함될 경우 최적화에 시간이 소요될 수 있다. 그러나 주기적으로 리셋되는 <code>imuPreintegration.cpp</code>의 지역 그래프는 이러한 전역 최적화의 지연과 무관하게 항상 IMU 측정 주기와 동기화된 고주파의 실시간 주행 거리 측정 결과를 출력하는 것을 보장한다. 이 이중 그래프 아키텍처는 고주파의 실시간 로컬 제어에 필요한 응답성과 저주파의 전역 지도 일관성에 필요한 정확성이라는 두 마리 토끼를 모두 잡기 위한 실용적인 해법이다. 이는 LIO-SAM이 “실시간보다 최대 10배 빠르게” 작동할 수 있다고 주장하는 근거가 된다.12</p>
<h2>3.  IMU 사전 적분</h2>
<h3>3.1 IMU 측정 모델</h3>
<p>IMU는 3축 가속도계와 3축 자이로스코프로 구성되어, 로봇의 바디(body) 좌표계를 기준으로 선형 가속도와 각속도를 측정한다. 하지만 이 측정값은 순수한 운동 정보 외에 여러 오차 요인을 포함하고 있다. IMU의 측정 모델은 일반적으로 다음과 같이 수학적으로 표현된다.13</p>
<p>가속도계 측정값 <span class="math math-inline">\hat{\mathbf{a}}_t</span>는 시간 <span class="math math-inline">t</span>에서의 실제 선형 가속도 <span class="math math-inline">\mathbf{a}_t</span>, 천천히 변하는 가속도계 바이어스 <span class="math math-inline">\mathbf{b}_{a_t}</span>, 월드 좌표계의 중력 벡터 <span class="math math-inline">\mathbf{g}_w</span>가 현재 로봇의 자세 <span class="math math-inline">\mathbf{R}_{w_t}</span>에 의해 변환된 성분, 그리고 가우시안 백색 잡음 <span class="math math-inline">\mathbf{n}_a</span>의 합으로 모델링된다.</p>
<p><span class="math math-display">
\hat{\mathbf{a}}_t = \mathbf{a}_t + \mathbf{b}_{a_t} + \mathbf{R}_{w_t} \mathbf{g}_w + \mathbf{n}_a
</span></p>
<p>자이로스코프 측정값 <span class="math math-inline">\hat{\boldsymbol{\omega}}_t</span>는 실제 각속도 <span class="math math-inline">\boldsymbol{\omega}_t</span>, 자이로스코프 바이어스 <span class="math math-inline">\mathbf{b}_{\omega_t}</span>, 그리고 가우시안 백색 잡음 <span class="math math-inline">\mathbf{n}_\omega</span>의 합으로 모델링된다.</p>
<p><span class="math math-display">
\hat{\boldsymbol{\omega}}_t = \boldsymbol{\omega}_t + \mathbf{b}_{\omega_t} + \mathbf{n}_\omega
</span></p>
<p>여기서 바이어스 <span class="math math-inline">\mathbf{b}_{a_t}</span>와 <span class="math math-inline">\mathbf{b}_{\omega_t}</span>는 시간에 따라 느리게 변하는 랜덤 워크(random walk)로 가정된다. 이러한 오차 요인들, 특히 바이어스는 적분 과정에서 누적되어 심각한 드리프트의 원인이 되므로, SLAM 시스템 내에서 반드시 추정하고 보정해야 한다.</p>
<h3>3.2 사전 적분의 원리</h3>
<p>요인 그래프 기반의 최적화 SLAM에서는 매 반복(iteration)마다 로봇의 상태 추정치가 계속해서 업데이트된다. 만약 두 키프레임 사이의 상대적인 움직임을 계산하기 위해 그 사이에 존재하는 수백 개의 IMU 측정값을 매번 다시 적분한다면 엄청난 계산 비용이 발생할 것이다.15</p>
<p>IMU 사전 적분(preintegration)은 이러한 비효율을 해결하기 위해 제안된 기법이다. 핵심 아이디어는 두 키프레임 <span class="math math-inline">i</span>와 <span class="math math-inline">j</span> 사이의 상대적인 움직임을 계산할 때, 월드 좌표계나 시작 시점 <span class="math math-inline">i</span>의 상태(자세 <span class="math math-inline">R_i</span>, 속도 <span class="math math-inline">v_i</span>)에 의존하지 않고, 오직 시작 시점 <span class="math math-inline">i</span>의 바디 좌표계를 기준으로 한 상대 운동 제약만을 미리 계산해 두는 것이다. 이렇게 사전 적분된 값은 시작 상태가 최적화 과정에서 어떻게 변하든 재사용될 수 있어, 반복적인 재적분을 피하게 해준다.16</p>
<h3>3.3 On-Manifold 사전 적분 이론</h3>
<p>로봇의 자세를 나타내는 회전(rotation)은 3차원 유클리드 공간이 아닌, SO(3)라는 특별한 기하학적 구조를 가진 리 그룹(Lie group) 매니폴드(manifold) 상에 존재한다. On-Manifold 사전 적분 이론은 이러한 회전의 비유클리드적 특성을 올바르게 다루어 적분 과정에서 발생하는 오차를 최소화하는 정교한 수학적 프레임워크이다.16 이는 단순히 3차원 벡터를 적분하는 것과 달리, 매니폴드 상의 접선 공간(tangent space)에서 증분을 계산하고 이를 다시 매니폴드로 사영하는 지수 사상(exponential map)을 사용하여 회전을 올바르게 누적한다.</p>
<p>두 키프레임 <span class="math math-inline">i</span>와 <span class="math math-inline">j</span> 사이의 시간 간격 <span class="math math-inline">t \in [t_i, t_j]</span>에 대해, IMU 측정값(<span class="math math-inline">\hat{\mathbf{a}}_k</span>, <span class="math math-inline">\hat{\boldsymbol{\omega}}_k</span>)을 이용하여 <span class="math math-inline">i</span>의 바디 좌표계를 기준으로 한 상대적 회전 <span class="math math-inline">\Delta\mathbf{R}_{ij}</span>, 속도 <span class="math math-inline">\Delta\mathbf{v}_{ij}</span>, 위치 <span class="math math-inline">\Delta\mathbf{p}_{ij}</span>는 다음과 같이 이산 시간(discrete-time) 형태로 누적하여 계산된다. 이 수식들은 VINS-Mono와 Forster의 선구적인 연구에서 유도된 형태를 따른다.13</p>
<p>상대 회전 <span class="math math-inline">\Delta\mathbf{R}_{ij}</span>는 각 시간 스텝 <span class="math math-inline">k</span>에서의 각속도 측정값을 이용하여 계산된 작은 회전들을 순차적으로 곱하여 얻는다.</p>
<p><span class="math math-display">
\Delta\mathbf{R}_{ij} = \prod_{k=i}^{j-1} \text{Exp}((\hat{\boldsymbol{\omega}}_k - \mathbf{b}_{g_k})\Delta t)
</span></p>
<p>상대 속도 <span class="math math-inline">\Delta\mathbf{v}_{ij}</span>는 각 시간 스텝에서의 가속도 측정값을 이전까지 누적된 상대 회전 <span class="math math-inline">\Delta\mathbf{R}_{ik}</span>로 변환하여 더함으로써 계산된다.</p>
<p><span class="math math-display">
\Delta\mathbf{v}_{ij} = \sum_{k=i}^{j-1} \Delta\mathbf{R}_{ik}(\hat{\mathbf{a}}_k - \mathbf{b}_{a_k})\Delta t
</span></p>
<p>상대 위치 <span class="math math-inline">\Delta\mathbf{p}_{ij}</span>는 각 시간 스텝에서의 속도 증분과 가속도에 의한 위치 변화를 함께 누적하여 계산한다.</p>
<p><span class="math math-display">
\Delta\mathbf{p}_{ij} = \sum_{k=i}^{j-1}
</span></p>
<p>여기서 <span class="math math-inline">\text{Exp}(\cdot)</span>는 접선 공간의 벡터를 SO(3) 매니폴드 상의 회전 행렬로 변환하는 지수 사상을 의미한다.</p>
<p>또한, IMU 측정값에 포함된 가우시안 잡음 <span class="math math-inline">\mathbf{n}_a, \mathbf{n}_\omega</span>이 사전 적분 과정 동안 어떻게 누적되어 최종 결과의 불확실성에 영향을 미치는지 모델링하는 불확실성 전파(uncertainty propagation) 과정이 필수적이다. 각 사전 적분 항(<span class="math math-inline">\Delta\mathbf{R}_{ij}</span>, <span class="math math-inline">\Delta\mathbf{v}_{ij}</span>, <span class="math math-inline">\Delta\mathbf{p}_{ij}</span>)에 대한 공분산(covariance) 행렬 <span class="math math-inline">\mathbf{\Sigma}_{ij}</span>을 함께 계산하며, 이는 요인 그래프 최적화 시 각 측정의 신뢰도를 나타내는 정보 행렬(information matrix)로 사용된다.16</p>
<h3>3.4 바이어스 보정</h3>
<p>사전 적분은 특정 바이어스 추정치(<span class="math math-inline">\bar{\mathbf{b}}_a</span>, <span class="math math-inline">\bar{\mathbf{b}}_g</span>)를 가정하고 계산된다. 만약 최적화 과정에서 이 바이어스 추정치가 <span class="math math-inline">\delta\mathbf{b}</span>만큼 미세하게 업데이트되면, 모든 사전 적분 값을 처음부터 다시 계산하는 대신, 바이어스 변화에 대한 1차 테일러 근사(first-order Taylor approximation)를 이용하여 기존 값을 효율적으로 보정한다. 이는 계산 비용을 획기적으로 절감시킨다.13 예를 들어, 상대 속도</p>
<p><span class="math math-inline">\Delta\mathbf{v}_{ij}</span>의 보정은 다음과 같이 표현할 수 있다.</p>
<p><span class="math math-display">
\Delta\mathbf{v}_{ij}(\mathbf{b}_a, \mathbf{b}_g) \approx \Delta\hat{\mathbf{v}}_{ij} + \mathbf{J}_{\mathbf{b}_a}^{\Delta v}\delta\mathbf{b}_a + \mathbf{J}_{\mathbf{b}_g}^{\Delta v}\delta\mathbf{b}_g
</span></p>
<p>여기서 <span class="math math-inline">\mathbf{J}</span>는 해당 바이어스에 대한 사전 적분 값의 자코비안(Jacobian) 행렬이다.</p>
<p>LIO-SAM에서 IMU 사전 적분은 시스템의 핵심적인 연결고리 역할을 한다. LiDAR가 10-20 Hz로 동작하는 반면 IMU는 100-1000 Hz로 동작하는 비동기적 센서 시스템에서, 사전 적분은 두 LiDAR 키프레임 사이에 발생한 모든 고주파 IMU 데이터를 손실 없이 압축하여 하나의 의미 있는 상대 운동 제약으로 변환하는 ‘시간적 접착제(temporal glue)’ 역할을 수행한다.7 이 덕분에 저주파의 키프레임 기반 요인 그래프가 고주파 IMU 데이터의 풍부한 정보를 온전히 활용할 수 있게 되며, 이것이 바로 강결합 융합의 본질이다. 사전 적분된 결과는 (1) LiDAR 포인트 클라우드의 왜곡 보정, (2) LiDAR 주행 거리 측정의 정확한 초기 추정치 제공, (3) 요인 그래프에서 두 연속 상태 노드를 연결하는 강력한 제약 조건 생성이라는 세 가지 핵심적인 역할을 수행하며 시스템 전체의 성능을 뒷받침한다.5</p>
<h2>4.  LiDAR 주행 거리 측정</h2>
<h3>4.1 특징점 추출</h3>
<p>LIO-SAM은 LiDAR 스캔으로부터 주행 거리 측정을 계산하기 위해 LOAM과 동일한 특징점 추출 방식을 채택한다.5 이 방식은 포인트 클라우드를 기하학적으로 의미 있는 소수의 특징점으로 압축하여, 이후의 스캔 매칭 과정의 계산 효율성과 강인성을 높이는 것을 목표로 한다.</p>
<p>먼저, 각 포인트의 지역적인 기하학적 특성을 평가하기 위해 곡률(curvature)을 계산한다. 특정 포인트 <span class="math math-inline">i</span>의 곡률 <span class="math math-inline">c</span>는 해당 포인트가 속한 스캔 라인(ring) 상의 이웃한 점들의 집합 <span class="math math-inline">S</span>(예: <span class="math math-inline">i</span>의 앞뒤 5개 점)를 이용하여 계산된다. 곡률은 이웃 점들과의 거리 벡터 합의 크기로 정의되며, 이는 해당 지점의 표면이 얼마나 평탄한지를 나타내는 척도로 작용한다.20</p>
<p>$$<br />
c = \frac{1}{|S| \cdot ||\mathbf{p}_i||} |</p>
<p>| \sum_{j \in S, j \neq i} (\mathbf{p}_i - \mathbf{p}_j) ||<br />
$$</p>
<p>여기서 <span class="math math-inline">\mathbf{p}_i</span>는 포인트 <span class="math math-inline">i</span>의 3D 좌표이다. 곡률 값이 크면 해당 지점이 날카로운 모서리(에지)일 가능성이 높고, 값이 작으면 평평한 표면(평면)일 가능성이 높다.</p>
<p>계산된 곡률 값을 기준으로, 각 스캔 라인을 여러 하위 영역으로 분할하고 각 영역에서 특정 개수의 특징점을 선별한다. 이는 특징점이 전체 스캔에 걸쳐 고르게 분포되도록 하기 위함이다. LIO-SAM은 LOAM과 같이 단순히 ’에지’와 ’평면’으로만 분류하지 않고, 더 많은 제약 조건을 확보하기 위해 네 가지 유형으로 특징점을 분류한다.20</p>
<table><thead><tr><th>특징 유형 (Feature Type)</th><th>곡률 (Curvature)</th><th>선택 기준 (Selection Criteria)</th></tr></thead><tbody>
<tr><td>Sharp Edge Point</td><td>높음 (High)</td><td>각 스캔 영역에서 곡률이 가장 큰 <span class="math math-inline">N</span>개 포인트</td></tr>
<tr><td>Less Sharp Edge Point</td><td>비교적 높음 (Relatively High)</td><td>Sharp Edge를 제외하고 곡률이 큰 <span class="math math-inline">M</span>개 포인트</td></tr>
<tr><td>Planar Surface Point</td><td>낮음 (Low)</td><td>각 스캔 영역에서 곡률이 가장 작은 <span class="math math-inline">K</span>개 포인트</td></tr>
<tr><td>Less Planar Surface Point</td><td>비교적 낮음 (Relatively Low)</td><td>Planar Surface를 제외하고 곡률이 작은 <span class="math math-inline">L</span>개 포인트</td></tr>
</tbody></table>
<p>이렇게 추출된 특징점들만이 다음 단계인 스캔 매칭 과정에 사용된다.</p>
<h3>4.2 스캔 매칭</h3>
<p>스캔 매칭은 새로 들어온 키프레임 <span class="math math-inline">F_{k+1}</span>의 특징점들을 이전에 구축된 로컬 맵 <span class="math math-inline">M_k</span>에 정합하여 두 프레임 간의 상대적인 변환(회전 및 이동) <span class="math math-inline">\Delta T_{k, k+1}</span>을 추정하는 과정이다.5</p>
<p>이 과정에서 가장 중요한 첫 단계는 정확한 초기 추정치(initial guess)를 확보하는 것이다. LOAM이 단순한 등속도 모델을 사용했던 것과 달리, LIO-SAM은 IMU 사전 적분을 통해 얻은 매우 정확한 상대 변환을 초기 추정치로 사용한다.5 이 정확한 초기값은 비선형 최적화 과정의 수렴 속도를 높이고, 잘못된 지역 최솟값(local minima)에 빠질 위험을 크게 줄여준다.</p>
<p>초기 추정치를 이용하여 <span class="math math-inline">F_{k+1}</span>의 특징점들을 로컬 맵 <span class="math math-inline">M_k</span>의 좌표계로 변환한 후, 각 특징점에 대한 대응 관계(correspondence)를 찾고, 이들 사이의 기하학적 오차를 최소화하는 비선형 최적화 문제를 푼다.</p>
<ul>
<li>
<p><strong>에지 특징점:</strong> <span class="math math-inline">F_{k+1}</span>의 에지 특징점 <span class="math math-inline">p_e</span>에 대해, 로컬 맵 <span class="math math-inline">M_k</span>에서 가장 가까운 에지 라인을 찾는다. 이 라인이 두 점 <span class="math math-inline">p_a, p_b</span>로 정의될 때, 점-선(point-to-line) 거리 <span class="math math-inline">d_e</span>를 잔차(residual)로 정의한다.</p>
<p><span class="math math-display">
d_e = \frac{|(\mathbf{p}_e - \mathbf{p}_a) \times (\mathbf{p}_e - \mathbf{p}_b)|}{| \mathbf{p}_a - \mathbf{p}_b |}
</span></p>
</li>
<li>
<p><strong>평면 특징점:</strong> <span class="math math-inline">F_{k+1}</span>의 평면 특징점 <span class="math math-inline">p_p</span>에 대해, 로컬 맵 <span class="math math-inline">M_k</span>에서 가장 가까운 평면 패치를 찾는다. 이 평면이 세 점 <span class="math math-inline">p_a, p_b, p_c</span>로 정의될 때, 점-평면(point-to-plane) 거리 <span class="math math-inline">d_p</span>를 잔차로 정의한다.</p>
<p><span class="math math-display">
d_p = \frac{|(\mathbf{p}_p - \mathbf{p}_a) \cdot ((\mathbf{p}_b - \mathbf{p}_a) \times (\mathbf{p}_c - \mathbf{p}_a))|}{|(\mathbf{p}_b - \mathbf{p}_a) \times (\mathbf{p}_c - \mathbf{p}_a)|}
</span></p>
</li>
</ul>
<p>모든 특징점에 대한 이러한 거리 잔차들의 제곱 합을 최소화하는 상대 변환 <span class="math math-inline">\Delta T_{k, k+1}</span>을 찾는 것이 최적화의 목표이다. 이 문제는 일반적으로 가우스-뉴턴(Gauss-Newton) 또는 레벤버그-마르쿼트(Levenberg-Marquardt)와 같은 반복적인 최적화 기법을 사용하여 해결된다. 최종적으로 얻어진 <span class="math math-inline">\Delta T_{k, k+1}</span>은 요인 그래프에 추가될 ’LiDAR 주행 거리 측정 요인’이 된다.5</p>
<h3>4.3 키프레임 선택 전략</h3>
<p>모든 LiDAR 스캔을 요인 그래프에 추가하여 최적화하는 것은 계산적으로 비효율적이며 불필요하다. LIO-SAM은 로봇의 움직임이 거의 없을 때 중복된 정보를 추가하는 것을 피하기 위해 키프레임 선택 전략을 사용한다. 이전 키프레임 대비 로봇의 자세 변화가 특정 임계값(예: 위치 변화 1m 또는 회전 변화 10도)을 초과할 경우에만 현재 스캔을 새로운 키프레임으로 선정하여 요인 그래프에 추가한다. 이 전략은 계산량을 효과적으로 관리하면서도 시스템의 정확도를 유지하는 데 중요한 역할을 한다.5</p>
<p>LIO-SAM의 LiDAR 주행 거리 측정 과정은 IMU와의 강력한 공생 관계를 보여준다. (1) IMU 사전 적분은 LiDAR 스캔 매칭에 매우 정확한 운동 사전 정보(prior)를 제공한다.6 (2) 이 정확한 사전 정보는 특징점 대응 관계 탐색 공간을 크게 줄여 스캔 매칭을 더 빠르고 강인하게 만들며, 지역 최솟값에 빠지는 것을 방지한다. (3) 성공적인 LiDAR 스캔 매칭의 결과(매우 정확한 상대 변환)는 다시 요인 그래프에서 IMU의 느리게 변하는 바이어스를 추정하고 보정하는 측정값으로 사용된다.5 (4) 보정된 IMU 바이어스는 다음 사이클에서 더욱 정확한 사전 적분을 가능하게 한다. 이처럼 각 센서의 처리 결과가 다른 센서의 근본적인 파라미터를 개선하는 데 사용되는 긴밀한 피드백 루프야말로 ‘강결합’ 융합의 정수이며, LIO-SAM이 까다로운 동적 환경에서도 낮은 드리프트를 유지하는 핵심적인 이유이다.</p>
<h2>5.  요인 그래프 최적화</h2>
<h3>5.1 요인 그래프 개요</h3>
<p>요인 그래프(Factor Graph)는 SLAM과 같은 복잡한 추정 문제를 확률적 추론의 관점에서 모델링하고 해결하기 위한 강력한 그래피컬 모델이다. 이는 변수 노드(variable node)와 요인 노드(factor node)라는 두 종류의 노드로 구성된 이분 그래프(bipartite graph)이다.22</p>
<ul>
<li>
<p><strong>변수 노드:</strong> 우리가 추정하고자 하는 미지의 상태 변수들을 나타낸다. LIO-SAM에서는 로봇의 특정 시점에서의 자세(position, orientation), 속도(velocity), 그리고 IMU 바이어스(biases) 등이 해당된다.</p>
</li>
<li>
<p><strong>요인 노드:</strong> 센서 측정이나 시스템 모델로부터 얻어지는 변수들 간의 확률적 제약(probabilistic constraint)을 나타낸다. 각 요인은 연결된 변수들에 대한 확률 분포(또는 비용 함수)를 정의한다.</p>
</li>
</ul>
<p>SLAM 문제를 요인 그래프로 모델링하면, 전체 시스템의 상태 <span class="math math-inline">X</span>에 대한 최적의 해를 찾는 것은 모든 요인들의 곱으로 표현되는 결합 확률 분포를 최대화하는 최대 사후 확률(Maximum a Posteriori, MAP) 추정 문제가 된다.5 이는 비선형 최소 제곱(nonlinear least-squares) 문제로 변환될 수 있으며, 목표는 모든 요인에서 발생하는 오차(잔차)의 제곱 합을 최소화하는 상태 변수 <span class="math math-inline">X</span>를 찾는 것이다.</p>
<p><span class="math math-display">
\hat{X} = \underset{X}{\text{argmax}} \ P(X|Z) \propto \underset{X}{\text{argmax}} \prod_i f_i(X_i) \equiv \underset{X}{\text{argmin}} \sum_i ||h_i(X_i) - z_i||^2_{\Sigma_i}
</span></p>
<p>여기서 <span class="math math-inline">Z</span>는 모든 측정값의 집합, <span class="math math-inline">f_i</span>는 요인, <span class="math math-inline">h_i</span>는 측정 모델, <span class="math math-inline">z_i</span>는 실제 측정값, <span class="math math-inline">\Sigma_i</span>는 측정 노이즈의 공분산 행렬이다.</p>
<h3>5.2 LIO-SAM의 4가지 핵심 요인</h3>
<p>LIO-SAM은 시스템의 상태를 정확하게 추정하기 위해 네 가지 종류의 핵심적인 요인을 구성하여 요인 그래프에 통합한다.5</p>
<ol>
<li>
<p><strong>IMU 사전 적분 요인 (IMU Preintegration Factor):</strong> 두 연속적인 키프레임의 상태 노드 <span class="math math-inline">(x_i, x_{i+1})</span>를 연결하는 이진 요인(binary factor)이다. 이 요인은 IMU 사전 적분을 통해 계산된 두 상태 간의 상대 운동(<span class="math math-inline">\Delta R, \Delta v, \Delta p</span>)과, 그래프 상에서 두 상태 변수로부터 계산된 실제 상대 운동 간의 차이(잔차)를 최소화하도록 제약을 가한다. 이 요인은 LiDAR 스캔 사이의 고주파 움직임을 제약하는 역할을 한다.</p>
</li>
<li>
<p><strong>LiDAR 주행 거리 측정 요인 (LiDAR Odometry Factor):</strong> IMU 요인과 마찬가지로 두 연속 상태 노드 <span class="math math-inline">(x_i, x_{i+1})</span>를 연결하는 이진 요인이다. LiDAR 스캔 매칭을 통해 계산된 상대 변환 <span class="math math-inline">\Delta T_{i, i+1}</span>과 두 상태 간의 상대 변환의 잔차를 최소화한다. 이 요인은 시스템의 주된 위치 및 자세 정보를 제공하는 핵심 제약이다.</p>
</li>
<li>
<p><strong>GPS 요인 (GPS Factor):</strong> 단일 상태 노드 <span class="math math-inline">x_i</span>에 직접 연결되는 단항 요인(unary factor)이다. GPS 수신기로부터 얻은 절대 위치 측정값을 제공하여, 시간이 지남에 따라 누적되는 주행 거리 측정의 드리프트를 전역 좌표계 기준으로 보정하는 역할을 한다. LIO-SAM은 무조건적으로 GPS 요인을 추가하지 않고, 현재 추정된 위치의 공분산(불확실성)이 GPS 측정값의 공분산보다 클 때만 요인을 추가하여, 부정확한 GPS 측정값이 시스템에 미치는 악영향을 최소화하는 전략을 사용한다.5</p>
</li>
<li>
<p><strong>루프 폐쇄 요인 (Loop Closure Factor):</strong> 시간적으로 멀리 떨어져 있지만 공간적으로 가까운 두 상태 노드 <span class="math math-inline">(x_i, x_j)</span> (단, <span class="math math-inline">j \gg i</span>)를 연결하는 이진 요인이다. 로봇이 이전에 방문했던 장소를 재인식하면(예: 유클리드 거리 기반 탐색 및 스캔 매칭), 두 시점 간의 상대 변환을 계산하여 요인 그래프에 새로운 제약으로 추가한다. 이 요인은 궤적 전체에 걸쳐 누적된 오차를 극적으로 줄여 전역적으로 일관된 지도를 생성하는 데 결정적인 역할을 한다.5</p>
</li>
</ol>
<h3>5.3 GTSAM과 iSAM2를 이용한 증분 최적화</h3>
<p>LIO-SAM은 이러한 복잡한 요인 그래프의 비선형 최적화 문제를 해결하기 위한 백엔드(back-end)로 GTSAM(Georgia Tech Smoothing and Mapping) 라이브러리를 사용한다.11 GTSAM은 로보틱스와 컴퓨터 비전 분야의 평활화 및 매핑 문제를 효율적으로 해결하기 위해 특별히 설계된 C++ 라이브러리이다.</p>
<p>새로운 측정값이 들어올 때마다 전체 요인 그래프를 처음부터 다시 최적화하는 것은 실시간 SLAM 시스템에서는 불가능하다. LIO-SAM은 GTSAM이 제공하는 iSAM2(incremental Smoothing and Mapping 2) 알고리즘을 사용하여 이 문제를 해결한다. iSAM2는 새로운 요인이 그래프에 추가될 때, 전체 그래프를 재선형화하고 풀이하는 대신, 베이즈 트리(Bayes Tree)라는 자료 구조를 사용하여 변화의 영향을 받는 변수들만 효율적으로 찾아내어 부분적으로 업데이트한다. 이 증분 평활화 및 매핑 기법 덕분에 LIO-SAM은 대규모 환경에서도 요인 그래프를 실시간으로 유지하고 최적화할 수 있다.5</p>
<p>LIO-SAM의 진정한 영향력은 요인 그래프라는 추상화된 구조를 통해 센서 융합을 위한 ‘플러그 앤 플레이(plug-and-play)’ 플랫폼을 제시했다는 점에 있다. 새로운 센서를 시스템에 통합하는 과정은 (1) 해당 센서의 측정값을 시스템 상태와 연관 짓는 측정 모델을 정의하고, (2) 이 모델에 기반한 오차(잔차)와 불확실성을 나타내는 새로운 ’요인’을 설계하여 기존 그래프에 추가하는 것으로 단순화된다. 이러한 유연성 덕분에 LIO-SAM의 기본 구조 위에서 시각 정보를 추가한 LVI-SAM 25, 저가형 GNSS를 지원하는 LIO_SAM_6AXIS 26, 의미론적 정보를 활용하는 연구 2 등 수많은 확장 연구가 파생될 수 있었다. 이는 LIO-SAM이 단순한 하나의 알고리즘을 넘어, 현대 다중 센서 SLAM 연구의 핵심적인 베이스라인이자 교육 도구로 자리매김하게 된 이유이다.</p>
<h2>6.  LIO-SAM 생태계 및 파생 연구</h2>
<h3>6.1 실용적 구현</h3>
<p>LIO-SAM은 학술적 기여를 넘어, 실제 로봇 시스템에 적용하기 용이하도록 잘 구성된 오픈소스 프로젝트로 공개되었다. ROS(Robot Operating System)를 기반으로 구현되어 있어, 표준화된 메시지 인터페이스를 통해 다양한 LiDAR, IMU 센서와 쉽게 연동할 수 있다.11 사용자는 프로젝트와 함께 제공되는</p>
<p><code>config/params.yaml</code> 파일을 통해 센서 데이터의 ROS 토픽 이름, 센서 간의 좌표계 변환(extrinsic calibration), 특징점 추출 및 키프레임 생성과 관련된 다양한 파라미터를 자신의 하드웨어 구성에 맞게 손쉽게 설정할 수 있다.11 이러한 실용성과 접근성 덕분에 LIO-SAM은 전 세계 수많은 연구자와 개발자 커뮤니티에서 널리 채택되고 있다.</p>
<h3>6.2 주요 파생 알고리즘</h3>
<p>LIO-SAM의 성공적인 아키텍처와 뛰어난 성능은 수많은 후속 연구와 파생 오픈소스 프로젝트에 영감을 주었다. 이들은 LIO-SAM의 핵심 아이디어를 계승하면서 특정 환경이나 센서 구성에 대한 성능을 개선하거나 새로운 기능을 추가하는 방향으로 발전했다.</p>
<ul>
<li>
<p><strong>LVI-SAM:</strong> LIO-SAM에 시각-관성 시스템(Visual-Inertial System, VIS)을 강결합 방식으로 통합한 알고리즘이다. LIO-SAM의 LiDAR-관성 시스템(LIS)과 시각-관성 시스템(VIS)이 상호 보완적으로 동작하도록 설계되었다. 이를 통해 기하학적 구조는 풍부하지만 시각적 텍스처가 부족한 환경(예: 터널)과, 텍스처는 풍부하지만 기하학적 구조가 부족한 환경(예: 넓은 평원) 모두에서 강인한 성능을 발휘한다. 한 시스템이 실패하더라도 다른 시스템이 독립적으로 동작하여 전체 시스템의 안정성을 높였다.25</p>
</li>
<li>
<p><strong>FAST-LIO-SAM:</strong> LiDAR-관성 주행 거리 측정의 프론트엔드(front-end)로 계산 효율성이 매우 높은 FAST-LIO2를 사용하고, 백엔드(back-end)로는 LIO-SAM의 포즈 그래프 최적화(Pose Graph Optimization, PGO) 및 루프 폐쇄 모듈을 결합한 하이브리드 방식의 알고리즘이다. 이는 FAST-LIO2의 빠른 처리 속도와 LIO-SAM의 강력한 전역 최적화 능력의 장점을 모두 취하려는 시도이다.28</p>
</li>
<li>
<p><strong>IA-LIO-SAM:</strong> Ouster 사의 LiDAR 센서가 제공하는 표준적인 3D 좌표 정보 외에, 각 포인트의 반사 강도(intensity)와 주변광(ambient) 채널 정보를 특징점 매칭 과정에 추가로 활용하는 알고리즘이다. 기하학적 정보만으로는 구분이 어려운 특징점들에 대해 추가적인 정보를 제공함으로써, 특히 구조적으로 유사한 패턴이 반복되는 환경에서 스캔 매칭의 정확도와 강인성을 향상시킨다.30</p>
</li>
<li>
<p><strong>기타 변형:</strong> 이 외에도 LIO-SAM을 기반으로 한 다양한 목적의 프로젝트들이 활발하게 개발되고 있다. <code>LIO_SAM_6AXIS</code>는 9축 IMU 대신 더 보편적인 6축 IMU와 저가형 GNSS 수신기를 쉽게 통합할 수 있도록 지원을 강화했다.26</p>
</li>
</ul>
<p><code>LIO-SAM-Localization</code>은 SLAM 기능 대신, LIO-SAM으로 사전에 구축된 맵 내부에서 로봇의 실시간 위치를 추정하는 순수 지역화(localization) 기능에 초점을 맞추어 코드를 수정한 버전이다.31 또한, 계산 집약적인 스캔 매칭 부분을 CUDA를 이용해 가속하는 GPU 기반 버전도 연구되고 있다.32</p>
<p>이러한 다양한 파생 연구들은 LIO-SAM의 아키텍처가 얼마나 유연하고 확장 가능한지를 명확히 보여준다. 아래 표는 LIO-SAM과 주요 파생 알고리즘들의 핵심적인 차이점을 요약한 것이다.</p>
<table><thead><tr><th>알고리즘 (Algorithm)</th><th>핵심 개선 사항 (Key Improvement)</th><th>추가 센서 (Additional Sensors)</th><th>주요 목표 (Primary Goal)</th><th>소스 (Source)</th></tr></thead><tbody>
<tr><td><strong>LIO-SAM</strong></td><td>요인 그래프 기반 강결합 LiDAR-IMU 융합</td><td>(GPS)</td><td>고정확도, 실시간 SLAM</td><td>6</td></tr>
<tr><td>LVI-SAM</td><td>시각-관성 시스템(VIS) 추가 통합</td><td>Camera</td><td>질감/구조 부족 환경에서의 강인성 향상</td><td>25</td></tr>
<tr><td>FAST-LIO-SAM</td><td>FAST-LIO2 프론트엔드 결합</td><td>-</td><td>계산 효율성 및 정확도 향상</td><td>28</td></tr>
<tr><td>IA-LIO-SAM</td><td>Intensity &amp; Ambient 채널 활용</td><td>Ouster LiDAR</td><td>특징 매칭 정확도 향상</td><td>30</td></tr>
<tr><td>LIO-SAM-Localization</td><td>사전 구축 맵 기반 위치 추정 기능</td><td>-</td><td>Localization in prior map</td><td>31</td></tr>
</tbody></table>
<h2>7.  성능 비교 및 분석</h2>
<h3>7.1 LOAM, LeGO-LOAM과의 비교</h3>
<p>LIO-SAM의 성능을 평가하기 위해서는 그 선행 연구인 LOAM 및 LeGO-LOAM과의 비교가 필수적이다.</p>
<ul>
<li>
<p><strong>아키텍처 관점:</strong> LOAM과 그 경량화 버전인 LeGO-LOAM은 두 개의 병렬 스레드, 즉 고주파의 주행 거리 측정(odometry) 스레드와 저주파의 매핑(mapping) 스레드가 ad-hoc 방식으로 동작하는 구조를 가진다. 반면, LIO-SAM은 모든 센서 측정과 제약 조건을 요인 그래프라는 단일 통합 프레임워크 내에서 원칙에 입각하여 최적화한다. 이 구조적 차이는 전역 일관성 확보 능력에서 결정적인 차이를 만들어낸다.8</p>
</li>
<li>
<p><strong>드리프트 보정 관점:</strong> LOAM은 루프 폐쇄나 GPS와 같은 전역 보정 메커니즘이 전혀 없다. LeGO-LOAM은 유클리드 거리 기반의 간단한 루프 폐쇄 기능을 추가했지만, 여전히 누적된 오차를 완전히 해소하기에는 한계가 있다.8 LIO-SAM은 요인 그래프를 통해 루프 폐쇄와 GPS 요인을 체계적으로 통합함으로써, 장거리 주행 시 누적되는 드리프트를 효과적으로 제거하고 전역적으로 일관된 궤적과 지도를 생성할 수 있다.5</p>
</li>
<li>
<p><strong>정확도 관점:</strong> 다수의 비교 연구 결과는 LIO-SAM의 우수성을 입증한다. 특히 긴 복도와 같이 기하학적 특징이 부족하여 스캔 매칭이 어려운 퇴화된(degenerated) 환경이나, 대규모 루프가 포함된 장거리 궤적에서 LIO-SAM은 LeGO-LOAM보다 월등히 높은 위치 추정 정확도를 보인다.27 이는 IMU와의 강결합을 통해 단기적인 움직임을 정확히 추정하고, 루프 폐쇄 및 GPS를 통해 장기적인 드리프트를 보정하는 LIO-SAM의 능력이 복합적으로 작용한 결과이다.</p>
</li>
</ul>
<h3>7.2 LIO-SAM의 강점과 한계</h3>
<p>LIO-SAM의 성공 요인은 다음과 같은 강점들로 요약할 수 있다.</p>
<ul>
<li>
<p><strong>높은 정확도와 강인성:</strong> LiDAR와 IMU의 강결합 융합, 그리고 요인 그래프 기반의 전역 최적화를 통해 매우 낮은 드리프트와 높은 정확도를 달성한다.</p>
</li>
<li>
<p><strong>실시간 성능:</strong> 슬라이딩 윈도우 기반의 로컬 스캔 매칭과 iSAM2를 이용한 증분 최적화 기법은 대규모 환경에서도 실시간 처리를 가능하게 한다.6</p>
</li>
<li>
<p><strong>뛰어난 확장성:</strong> 요인 그래프 아키텍처는 GPS, 카메라 등 다른 센서 정보를 ‘요인’ 형태로 쉽게 추가할 수 있는 유연성을 제공한다.5</p>
</li>
</ul>
<p>하지만 LIO-SAM 역시 완벽하지 않으며 다음과 같은 한계를 가진다.</p>
<ul>
<li>
<p><strong>초기화 의존성:</strong> 시스템 시작 시, IMU 바이어스와 중력 방향 등을 정확하게 추정하기 위해서는 충분한 초기 움직임이 필요하다. 정지 상태에서 시작하거나 움직임이 매우 적을 경우 초기화에 실패하거나 부정확한 결과를 낼 수 있다.</p>
</li>
<li>
<p><strong>극심한 퇴화 환경:</strong> 특징점이 극도로 부족한 매우 긴 터널이나 사방이 트인 넓은 공터와 같은 환경에서는 LiDAR로부터 얻을 수 있는 기하학적 제약이 부족하여 IMU 드리프트를 완전히 억제하지 못하고 위치 추정 오차가 누적될 수 있다. 이러한 문제는 LVI-SAM과 같은 시각 정보 융합을 통해 일부 완화될 수 있다.25</p>
</li>
</ul>
<p>LIO-SAM은 ’실시간 SLAM’의 개념을 한 단계 발전시켰다. 과거의 ’실시간’이 단순히 센서 입력 속도를 따라가는 주행 거리 측정에 국한되었다면, LIO-SAM은 두 가지 차원의 실시간 성능을 동시에 달성한다. 첫째, <code>imuPreintegration</code> 모듈의 독립적인 그래프를 통해 지역 장애물 회피와 같은 즉각적인 작업에 필요한 고주파, 저지연의 자세 추정치를 제공한다.12 둘째,</p>
<p><code>mapOptimization</code> 모듈의 iSAM2를 통해 전역 경로 계획과 같은 상위 레벨 작업에 필요한 전역적으로 일관된 궤적과 지도를 거의 실시간으로 유지하고 업데이트한다.5 이처럼 지역적 반응성과 전역적 일관성을 동시에 만족시키는 능력은 LIO-SAM이 현대 SLAM 시스템의 새로운 성능 기준을 제시했음을 의미한다.</p>
<h2>8.  결론</h2>
<h3>8.1 기술적 성과 요약</h3>
<p>LIO-SAM은 LiDAR와 IMU 센서 데이터를 요인 그래프라는 통합된 최적화 프레임워크 상에서 강결합한 기념비적인 연구이다. On-Manifold IMU 사전 적분 이론을 정교하게 적용하여 고주파의 관성 측정 정보를 손실 없이 활용하고, 슬라이딩 윈도우 기반의 효율적인 로컬 스캔 매칭과 iSAM2를 이용한 증분 평활화 기법을 통해 실시간 성능과 높은 정확도를 동시에 달성했다.5 이는 이전 세대의 LiDAR SLAM 기술인 LOAM이 가졌던 전역 최적화 부재의 한계를 명확히 극복하고, 현대적인 비선형 최적화 기반 SLAM의 새로운 표준을 제시한 중요한 기술적 성과이다.</p>
<h3>8.2 SLAM 분야에 미친 영향</h3>
<p>LIO-SAM은 단순히 뛰어난 성능의 알고리즘을 넘어, SLAM 연구 및 개발 생태계에 지대한 영향을 미쳤다. 요인 그래프 기반 최적화 방식의 실질적인 효용성과 강력함을 입증함으로써, 이후 등장하는 수많은 LiDAR-관성 SLAM 연구의 표준적인 베이스라인(baseline)으로 자리매김했다. 또한, 잘 관리되는 오픈소스 프로젝트로 공개되어 전 세계의 연구자들이 쉽게 접근하고 수정하며 확장할 수 있는 기반을 제공했다. 그 결과 LVI-SAM, FAST-LIO-SAM 등 LIO-SAM의 아키텍처에 영감을 받은 수많은 후속 연구와 파생 프로젝트가 탄생했으며, 이는 활발하고 건강한 오픈소스 SLAM 생태계를 형성하는 데 크게 기여했다.25</p>
<h3>8.3 미래 연구 방향</h3>
<p>LIO-SAM이 제시한 강력한 프레임워크는 앞으로의 SLAM 연구를 위한 풍부한 가능성을 열어두고 있다. 첫째, 현재의 기하학적 정보에 더하여 딥러닝 기반의 의미론적 정보(semantic information)를 요인으로 융합하는 연구가 가능하다. 이를 통해 동적인 객체(차량, 보행자)를 구별하고 제거하여 동적 환경에서의 강인성을 획기적으로 높일 수 있다.2 둘째, 단일 로봇을 넘어 다중 로봇 협력 SLAM으로 시스템을 확장할 수 있다. 여러 로봇이 각자의 요인 그래프를 구축하고, 로봇 간의 상대적 관측이 발생했을 때 이를 루프 폐쇄 요인과 유사한 형태로 연결함으로써, 더 빠르고 강인하게 대규모 환경의 지도를 공동으로 구축할 수 있을 것이다. LIO-SAM은 이처럼 미래 SLAM 기술의 발전을 이끌어 나갈 견고한 초석으로서 그 가치를 이어나갈 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>LPVIMO-SAM: Tightly-coupled LiDAR/Polarization Vision/Inertial/Magnetometer/Optical Flow Odometry via Smoothing and Mapping - arXiv, https://arxiv.org/html/2504.20380v1</li>
<li>LIO-SAM++: A Lidar-Inertial Semantic SLAM with Association Optimization and Keyframe Selection - MDPI, https://www.mdpi.com/1424-8220/24/23/7546</li>
<li>Comparison of Visual and LiDAR SLAM Algorithms using NASA Flight Test Data, https://ntrs.nasa.gov/api/citations/20220017949/downloads/Comparison_of_Visual_and_LiDAR_SLAM_Algorithms_using_NASA_Flight_Test_Data_FINAL.pdf</li>
<li>A Review of Simultaneous Localization and Mapping Algorithms Based on Lidar - MDPI, https://www.mdpi.com/2032-6653/16/2/56</li>
<li>LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and …, https://arxiv.org/pdf/2007.00258</li>
<li>LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping, https://www.researchgate.net/publication/362412728_LIO-SAM_Tightly-coupled_Lidar_Inertial_Odometry_via_Smoothing_and_Mapping</li>
<li>A Comprehensive Introduction of Visual-Inertial Navigation - arXiv, https://arxiv.org/pdf/2307.11758</li>
<li>Evaluation of Lidar-based 3D SLAM algorithms in SubT environment, https://www.unileoben.ac.at/fileadmin/shares/illuMINEation/Publications/lio_evaluation.pdf</li>
<li>An Improved Simultaneous Localization and Mapping Method Fusing LeGO-LOAM and Scan Context for Underground Coalmine - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC8778426/</li>
<li>LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping - arXiv, https://arxiv.org/abs/2007.00258</li>
<li>LIO_SAM - Autoware Documentation, https://autowarefoundation.github.io/autoware-documentation/pr-347/how-to-guides/creating-maps-for-autoware/open-source-slam/lio-sam/</li>
<li>LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping - GitHub, https://github.com/TixiaoShan/LIO-SAM</li>
<li>A Robust Parallel Initialization Method for Monocular Visual-Inertial …, https://www.mdpi.com/1424-8220/22/21/8307</li>
<li>VINS Mono Body-Of-Knowledge | ai Werkstatt, https://www.aiwerkstatt.com/wp-content/uploads/2020/08/VINS-Mono-Body-Of-Knowledge.pdf</li>
<li>On-Manifold Preintegration Theory for Fast and Accurate Visual-Inertial Navigation, https://kvmanohar22.github.io/notes/w02/main.pdf</li>
<li>IMU Preintegration on Manifold for Efficient Visual-Inertial Maximum-a-Posteriori Estimation - Robotics and Perception Group, https://rpg.ifi.uzh.ch/docs/RSS15_Forster.pdf</li>
<li>IMU Preintegration on Manifold for Efficient Visual-Inertial Maximum-a-Posteriori Estimation - Robotics, https://www.roboticsproceedings.org/rss11/p06.pdf</li>
<li>On-Manifold Preintegration for Real-Time Visual-Inertial Odometry, https://arxiv.org/abs/1512.02363</li>
<li>IMU Preintegration on Manifold for Efficient Visual-Inertial Maximum-a-Posteriori Estimation : r/oculus - Reddit, https://www.reddit.com/r/oculus/comments/3bp9r2/imu_preintegration_on_manifold_for_efficient/</li>
<li>detectLOAMFeatures - Detect LOAM feature points in point cloud - MATLAB - MathWorks, https://www.mathworks.com/help/lidar/ref/detectloamfeatures.html</li>
<li>Visual Odometry Based on Point Cloud Curvature - Bryan House Publishing, https://www.bryanhousepub.org/src/static/pdf/JRSE-2020-2-1_10.pdf</li>
<li>Factor Graphs and GTSAM, https://gtsam.org/tutorials/intro.html</li>
<li>Factor Graphs for Navigation Applications: A Tutorial, https://navi.ion.org/content/71/3/navi.653</li>
<li>Map Partition and Loop Closure in a Factor Graph Based SAM System - Simple search, https://liu.diva-portal.org/smash/get/diva2:1509264/FULLTEXT01.pdf</li>
<li>(PDF) LVI-SAM: Tightly-coupled Lidar-Visual-Inertial Odometry via Smoothing and Mapping, https://www.researchgate.net/publication/351063772_LVI-SAM_Tightly-coupled_Lidar-Visual-Inertial_Odometry_via_Smoothing_and_Mapping</li>
<li>JokerJohn/LIO_SAM_6AXIS: LIO_SAM for 6-axis IMU and GNSS. - GitHub, https://github.com/JokerJohn/LIO_SAM_6AXIS</li>
<li>LIO-SAM++: A Lidar-Inertial Semantic SLAM with Association Optimization and Keyframe Selection - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC11644182/</li>
<li>engcang/FAST-LIO-SAM-SC-QN: A SLAM implementation combining FAST-LIO2 with pose graph optimization and loop closing based on ScanContext, Quatro, and Nano-GICP - GitHub, https://github.com/engcang/FAST-LIO-SAM-SC-QN</li>
<li>a SLAM implementation combining FAST-LIO2 with pose graph optimization and loop closing based on LIO-SAM paper - GitHub, https://github.com/engcang/FAST-LIO-SAM</li>
<li>minwoo0611/IA_LIO_SAM: IA-LIO-SAM is enhanced LIO-SAM using Intensity and Ambient channel from OUSTER LiDAR. - GitHub, https://github.com/minwoo0611/IA_LIO_SAM</li>
<li>harshalkataria/LIO-SAM-Localization: Estimate the odometry of a robot in pre-built map using LIO-SAM - GitHub, https://github.com/harshalkataria/LIO-SAM-Localization</li>
<li>lio-sam · GitHub Topics, https://github.com/topics/lio-sam</li>
<li>Quantitative comparison of the proposed method, LIO-SAM and LeGO-LOAM (m)., https://www.researchgate.net/figure/Quantitative-comparison-of-the-proposed-method-LIO-SAM-and-LeGO-LOAM-m_tbl2_366690779</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>