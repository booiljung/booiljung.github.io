<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.3 수치적 안정성과 재계산(Recomputation) 전략</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.3 수치적 안정성과 재계산(Recomputation) 전략</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>4.3 수치적 안정성과 재계산(Recomputation) 전략</span></nav>
                </div>
            </header>
            <article>
                <h1>4.3 수치적 안정성과 재계산(Recomputation) 전략</h1>
<p>현대 딥러닝 시스템, 특히 자연어 처리(NLP)와 게놈 분석, 긴 오디오 파형 처리와 같이 초장문 시퀀스(Long Sequence)를 다루는 분야에서 모델의 성공 여부는 단순히 아키텍처의 이론적 우수성에만 달려 있지 않다. 이론적으로 완벽한 수식이라 할지라도, 이를 유한한 정밀도(Finite Precision)를 가진 하드웨어 위에서 구현할 때 발생하는 수치적 불안정성(Numerical Instability)과 메모리 대역폭(Memory Bandwidth)의 물리적 한계는 모델의 학습 불가능성을 초래하거나 추론 성능을 치명적으로 저하시키는 원인이 된다. Mamba 아키텍처가 트랜스포머(Transformer)의 이차 복잡도(Quadratic Complexity) 문제를 해결하고 선형 시간(Linear-Time) 추론을 달성하며 ‘포스트 트랜스포머’ 시대의 강력한 대안으로 부상할 수 있었던 배경에는, 선택적 상태 공간 모델(Selective State Space Model, SSM)이라는 새로운 패러다임뿐만 아니라 이를 뒷받침하는 정교한 시스템 엔지니어링이 존재한다.1</p>
<p>본 절에서는 Mamba 시스템 구현의 가장 핵심적이고 난해한 부분인 수치적 안정성 확보 방안과 역전파(Backpropagation) 시의 메모리 효율성을 극대화하기 위한 재계산(Recomputation) 전략을 심층적으로 분석한다. 이는 단순한 최적화 기법의 나열이 아니라, 연속 시간(Continuous-Time) 시스템을 이산 하드웨어에 매핑하는 과정에서 필연적으로 발생하는 동역학적 불안정성을 제어하고, GPU의 메모리 계층 구조(Memory Hierarchy)를 극한까지 활용하기 위한 하드웨어-소프트웨어 공동 설계(Co-design)의 정수를 보여준다.</p>
<h2>1.  상태 공간 모델의 수치적 난제: 시변 동역학의 딜레마</h2>
<p>Mamba의 핵심인 선택적 SSM은 입력 데이터에 따라 시스템의 파라미터가 동적으로 변화하는 시변(Time-Varying) 시스템이다. 이는 기존의 선형 시불변(Linear Time-Invariant, LTI) 시스템인 S4 등이 가졌던 한계, 즉 문맥에 따른 적응형 추론(Content-Aware Reasoning)이 불가능하다는 단점을 극복하게 해주었으나, 동시에 수치적 안정성 측면에서는 훨씬 더 까다로운 도전 과제를 안겨주었다.1</p>
<h3>1.1  순환(Recurrence) 구조와 오차의 지수적 증폭</h3>
<p>기본적으로 SSM은 잠재 상태(Latent State) <span class="math math-inline">h_t</span>를 통해 과거의 정보를 압축하여 현재로 전달한다. Mamba의 상태 업데이트 식은 다음과 같이 이산화된 형태를 띤다.<br />
<span class="math math-display">
h_t = \bar{A}_t h_{t-1} + \bar{B}_t x_t
</span><br />
여기서 <span class="math math-inline">\bar{A}_t = \exp(\Delta_t A)</span>는 상태 전이(State Transition) 행렬이다. 문제는 이 연산이 시퀀스 길이 <span class="math math-inline">L</span>만큼 반복적으로 수행된다는 점이다. 만약 특정 시점 <span class="math math-inline">t</span>에서 작은 수치적 오차 <span class="math math-inline">\epsilon</span>이 발생한다면, 이 오차는 이후의 모든 시점 <span class="math math-inline">t+k</span>에 영향을 미치게 된다. 특히 <span class="math math-inline">\bar{A}_t</span>의 고유값(Eigenvalue)의 크기가 1보다 클 경우, 오차는 스텝이 반복됨에 따라 지수적으로 증폭(Exponential Explosion)되어 그라디언트 폭발(Gradient Explosion)을 유발하고 학습을 발산시킨다. 반대로 고유값이 1보다 지나치게 작을 경우, 정보는 빠르게 소실(Vanishing)되어 장기 의존성(Long-Range Dependency)을 학습할 수 없게 된다.4</p>
<p>트랜스포머의 어텐션 메커니즘은 모든 토큰 간의 관계를 직접 계산하므로 이러한 순차적 오차 누적 문제에서 상대적으로 자유롭다. 그러나 순환 신경망(RNN)의 일종인 SSM은 본질적으로 이 문제에 취약하며, 특히 수백만 토큰(<span class="math math-inline">&gt; 1M</span>)을 다루는 Mamba의 경우 그 위험성은 극대화된다.3 더욱이 Mamba는 입력 <span class="math math-inline">x_t</span>에 따라 <span class="math math-inline">\Delta_t</span>가 변하는 구조이므로, <span class="math math-inline">\bar{A}_t</span>가 고정되지 않고 매 시점 요동친다. 이는 시스템의 안정성 분석을 고전적인 선형 대수학의 고유값 분석보다 훨씬 복잡한 동역학 시스템(Dynamical Systems) 이론의 영역으로 확장시킨다.4</p>
<h3>1.2  이산화(Discretization)와 반정밀도 연산의 충돌</h3>
<p>최신 LLM 학습은 연산 속도와 메모리 효율을 위해 FP16(Half Precision) 또는 BF16(Bfloat16)과 같은 저정밀도 포맷을 사용한다. 그러나 SSM의 이산화 과정, 특히 <span class="math math-inline">\exp(\Delta A)</span>와 같은 지수 함수 연산은 입력값의 작은 변화에도 출력값이 민감하게 반응한다. FP16은 표현할 수 있는 수의 범위(Dynamic Range)가 좁고 가수부(Mantissa)의 정밀도가 낮아, <span class="math math-inline">\Delta</span>가 매우 작거나 클 때 치명적인 언더플로우(Underflow) 또는 오버플로우(Overflow)를 발생시킬 수 있다.8</p>
<p>예를 들어, “Induction Heads“와 같이 정밀한 복사(Copying) 작업이 필요한 태스크에서, 모델은 특정 정보를 장기간 보존하기 위해 <span class="math math-inline">\Delta</span>를 0에 가깝게 만들어야 할 수 있다. 이때 FP16의 정밀도 한계로 인해 <span class="math math-inline">\Delta</span>가 0으로 함몰되거나(Collapse to zero), 반대로 정보 삭제를 위해 큰 값을 가질 때 <span class="math math-inline">\bar{A}</span>가 발산해버리는 현상이 발생한다. 이러한 수치적 불안정성은 모델이 문맥 정보를 정확히 추적(State Tracking)하는 것을 방해하며, 결과적으로 “환각(Hallucination)“이나 문맥 소실과 같은 성능 저하로 이어진다.4 따라서 Mamba는 이러한 하드웨어적 제약을 극복하기 위해 소프트웨어 레벨에서의 파라미터화 전략과 커널 레벨에서의 정밀도 관리 전략을 동시에 구사해야 한다.</p>
<h2>2.  수치적 안정성을 위한 파라미터화(Parameterization) 전략</h2>
<p>Mamba의 설계자들은 학습 과정에서 파라미터가 불안정한 영역으로 이탈하는 것을 방지하기 위해 수학적, 구조적 제약 조건을 도입했다. 이는 최적화 과정(Optimization Landscape)을 안정적인 영역으로 제한하는 일종의 ‘안전장치’ 역할을 한다.</p>
<h3>2.1  <span class="math math-inline">\Delta</span> (Delta)의 Softplus 파라미터화와 해상도 불변성</h3>
<p>이산화 단계 크기인 <span class="math math-inline">\Delta</span>는 연속 시간 시스템을 이산 시간으로 샘플링하는 간격을 의미한다. 물리적으로 시간 간격은 음수가 될 수 없으므로 <span class="math math-inline">\Delta &gt; 0</span> 조건이 필수적이다. 만약 <span class="math math-inline">\Delta</span>가 음수가 되면, <span class="math math-inline">\exp(\Delta A)</span>의 동작은 예측 불가능해지며 시스템의 인과성(Causality)이 깨질 수 있다. Mamba는 이를 보장하기 위해 <span class="math math-inline">\Delta</span>를 직접 학습시키는 대신, <code>softplus</code> 함수를 통과시킨 값을 사용한다.5<br />
<span class="math math-display">
\Delta = \text{softplus}(\text{Parameter} + \text{Broadcast}(s_\Delta(x)))
</span></p>
<p><span class="math math-display">
\text{softplus}(x) = \log(1 + e^x)
</span></p>
<p>Softplus 함수는 정의역 전체에 대해 치역이 양수(<span class="math math-inline">0, \infty</span>)이며, 미분 가능하다. 또한 <span class="math math-inline">x</span>가 작을 때는 0에 점근하고 클 때는 선형 함수에 근사하는 특성을 가진다. 이는 <span class="math math-inline">\Delta</span>가 0 이하로 떨어지는 것을 구조적으로 차단하여 수치적 안정성을 확보한다.</p>
<p><strong>초기화의 중요성:</strong> <span class="math math-inline">\Delta</span>의 초기값은 모델이 입력 시퀀스를 어떤 해상도로 바라볼지를 결정한다. Mamba는 <span class="math math-inline">\Delta</span>가 너무 작거나(정보 변화 무시) 너무 크지(정보 과잉 반영) 않도록, 초기값을 <span class="math math-inline">0.001</span>에서 <span class="math math-inline">0.1</span> 사이의 범위로 제한하여 초기화한다.11 이는 학습 초기 단계에서 그라디언트 흐름을 원활하게 하고, 모델이 시퀀스의 국소적 패턴(Local Pattern)과 전역적 패턴(Global Pattern)을 균형 있게 학습할 수 있는 기반을 마련한다. 또한, 이러한 파라미터화는 모델이 샘플링 속도 변화에 강건한 ’해상도 불변성(Resolution Invariance)’을 갖추도록 돕는다.2</p>
<h3>2.2  행렬 A의 구조적 제약: 대각화와 음수 고유값</h3>
<p>상태 전이 행렬 <span class="math math-inline">A</span>는 시스템의 장기 기억 능력을 좌우하는 가장 중요한 요소이다. Mamba에서는 연산 효율성을 위해 <span class="math math-inline">A</span>를 대각 행렬(Diagonal Matrix)로 제약하는 S4D(Structured State Space with Diagonal) 구조를 채택했다. 대각 행렬 구조는 각 상태 채널이 독립적으로 진화하도록 하여 GPU 병렬 연산을 용이하게 한다.3</p>
<p>더욱 중요한 것은 안정성을 위한 **음수 고유값 제약(Negative Eigenvalue Constraint)**이다. 선형 시스템 이론에 따르면, 연속 시간 시스템 <span class="math math-inline">\dot{h} = Ah</span>가 안정적(Stable)이려면 <span class="math math-inline">A</span>의 모든 고유값의 실수부(Real Part)가 음수여야 한다 (<span class="math math-inline">\text{Re}(\lambda) &lt; 0</span>). 실수부가 양수인 고유값이 존재하면 해당 모드는 시간이 지남에 따라 무한히 발산한다. Mamba는 이를 강제하기 위해 <span class="math math-inline">A</span>를 다음과 같이 파라미터화한다.4<br />
<span class="math math-display">
A = -\exp(A_{\text{log}})
</span><br />
여기서 <span class="math math-inline">A_{\text{log}}</span>는 실제 학습되는 파라미터이다. 지수 함수를 취해 양수로 만든 뒤 음의 부호를 붙임으로써, 학습이 진행되는 동안 <span class="math math-inline">A</span>의 원소들은 항상 음수 값을 유지하게 된다. 이는 시스템이 Bounded-Input Bounded-Output (BIBO) 안정성을 만족하도록 강제하며, Lyapunov 안정성 이론에 따라 상태 <span class="math math-inline">h_t</span>가 발산하지 않음을 수학적으로 보장한다.4</p>
<p><strong>HiPPO 초기화의 역할:</strong> 단순한 안정성을 넘어, ’무엇을 기억할 것인가’를 결정하는 초기화 전략으로 HiPPO(High-order Polynomial Projection Operators) 이론이 적용된다. Mamba는 S4D-Real 초기화를 사용하여, <span class="math math-inline">A</span> 행렬이 과거의 입력을 다항식 기저(Polynomial Basis)로 압축하여 저장하도록 유도한다. 이는 수만 스텝 이전의 정보도 잊지 않고 보존할 수 있는 수학적 토대를 제공하며, 랜덤 초기화가 가지는 학습 실패 위험을 획기적으로 낮춘다.13</p>
<p><strong>최신 연구 동향 - 음수 고유값의 역설:</strong> 흥미롭게도 최근 연구 7는 이러한 ‘항상 음수’ 제약이 특정 태스크(예: Parity Check, State Tracking)에서는 오히려 성능을 저해할 수 있음을 지적한다. 상태 추적이나 진동(Oscillation) 패턴 학습을 위해서는 복소수 고유값이나 양수 고유값이 일시적으로 필요할 수 있다는 것이다. 이는 Mamba 이후의 연구들(예: Mamba-2, DeltaNet)에서 안정성과 표현력(Expressivity) 사이의 트레이드오프를 조절하기 위한 새로운 초기화 기법이나 복소수 파라미터 도입 논의로 이어지고 있다.</p>
<h2>3.  하드웨어 인식(Hardware-Aware) 알고리즘: 커널 융합과 혼합 정밀도</h2>
<p>Mamba가 이론적인 우아함을 넘어 실제 하드웨어에서 트랜스포머를 능가하는 속도를 낼 수 있었던 것은, GPU 아키텍처의 특성을 극한으로 활용한 구현 전략 덕분이다. 이 전략의 핵심은 메모리 계층 구조(Memory Hierarchy)의 병목을 해소하는 **커널 융합(Kernel Fusion)**과 수치 정밀도를 보장하는 **혼합 정밀도 스캔(Mixed Precision Scan)**이다.</p>
<h3>3.1  GPU 메모리 계층 구조와 I/O 병목 해소</h3>
<p>최신 GPU(A100, H100 등)는 연산 장치(Core)의 속도가 메모리 대역폭(HBM Bandwidth)보다 훨씬 빠른 구조적 불균형을 가지고 있다. 즉, 연산 자체보다 데이터를 메모리에서 가져오고 쓰는 시간(I/O Latency)이 전체 실행 시간을 지배한다. 이를 ‘Memory-Bound’ 상태라고 한다.1</p>
<p>Mamba의 순환 연산은 매 시점마다 크기가 큰 잠재 상태 <span class="math math-inline">h_t</span> (Shape: <span class="math math-inline">B \times L \times D \times N</span>)를 읽고 업데이트해야 한다. 여기서 <span class="math math-inline">N</span>(상태 차원, 보통 16)은 채널 차원 <span class="math math-inline">D</span>를 확장한 것이므로, 전체 데이터 양은 입력 <span class="math math-inline">x</span>의 <span class="math math-inline">N</span>배에 달한다. 만약 표준 PyTorch 구현처럼 매 스텝마다 <span class="math math-inline">h_t</span>를 HBM(High Bandwidth Memory)에 썼다가 다시 읽는다면, 엄청난 I/O 오버헤드로 인해 선형 시간 복잡도의 이점은 사라지고 만다.17</p>
<p>Mamba는 이를 해결하기 위해 <strong>커널 융합(Kernel Fusion)</strong> 기술을 적용한다.</p>
<ol>
<li><strong>HBM에서 파라미터 로드:</strong> 입력 데이터 <span class="math math-inline">u, \Delta, B, C</span> (크기 <span class="math math-inline">O(BLD)</span>)를 상대적으로 느린 HBM에서 빠른 온-칩 메모리인 **SRAM(Static Random Access Memory)**으로 블록 단위로 로드한다.</li>
<li><strong>SRAM 내 고속 연산:</strong> SRAM 내부에서 이산화(<span class="math math-inline">\bar{A}, \bar{B}</span> 계산)와 순환(Scan) 연산을 수행한다. 이때 중간 상태인 <span class="math math-inline">h_t</span> (크기 <span class="math math-inline">O(BLDN)</span>)는 HBM에 기록하지 않고, SRAM 내의 레지스터 파일(Register File)이나 공유 메모리(Shared Memory)에만 일시적으로 유지하며 업데이트한다.</li>
<li><strong>최종 출력만 HBM 저장:</strong> 모든 스캔이 완료된 후, 최종 출력 <span class="math math-inline">y_t</span> (크기 <span class="math math-inline">O(BLD)</span>)만을 다시 HBM에 기록한다.17</li>
</ol>
<p>이러한 방식은 메모리 I/O를 <span class="math math-inline">O(BLDN)</span>에서 <span class="math math-inline">O(BLD)</span>로 <span class="math math-inline">N</span>배만큼 획기적으로 줄여주며, 실제 하드웨어에서 Mamba가 이론적 최대 속도에 근접하게 실행될 수 있는 물리적 기반을 제공한다. 이는 FlashAttention이 어텐션 행렬을 HBM에 쓰지 않고 SRAM에서 처리하는 것과 동일한 원리이다.20</p>
<h3>3.2  수치 안정성을 위한 혼합 정밀도 스캔 (Mixed Precision Scan)</h3>
<p>GPU의 텐서 코어(Tensor Core)를 활용하기 위해서는 FP16/BF16 연산이 필수적이지만, 앞서 언급했듯 SSM의 순환 연산은 정밀도에 극도로 민감하다. Mamba는 속도와 안정성이라는 두 마리 토끼를 잡기 위해 <strong>혼합 정밀도 전략</strong>을 매우 정교하게 적용한다.</p>
<ul>
<li><strong>저장 포맷 (Storage Format):</strong> 입력 <span class="math math-inline">u</span>, 파라미터 <span class="math math-inline">\Delta, B, C</span> 등은 메모리 절약을 위해 HBM에는 <strong>FP16</strong> 또는 <strong>BF16</strong>으로 저장된다. 이는 모델의 파라미터 용량을 줄이고 데이터 전송 속도를 높인다.22</li>
<li><strong>연산 포맷 (Computation Format):</strong> SRAM 내부에서 수행되는 스캔 연산, 특히 상태 <span class="math math-inline">h_t</span>가 누적(Accumulation)되는 과정(<span class="math math-inline">h_t = \bar{A}h_{t-1} + \bar{B}x_t</span>)은 반드시 **FP32(Single Precision)**로 수행된다.22 이는 수백만 번의 반복적인 덧셈과 곱셈 과정에서 발생하는 반올림 오차(Round-off Error)가 누적되어 전체 시퀀스를 망가뜨리는 것을 방지한다.</li>
<li><strong>민감한 함수 처리:</strong> <span class="math math-inline">\Delta</span>에 의한 지수 함수 연산(<code>exp</code>)과 <code>softplus</code>, 그리고 게이팅 메커니즘의 <code>SiLU</code> 함수 등은 수치적으로 폭발하거나 소실되기 쉬우므로, 이들 또한 FP32 정밀도로 계산된 후 다시 FP16으로 캐스팅(Casting)된다.8</li>
</ul>
<p>아래 표는 Mamba와 일반적인 트랜스포머 구현에서의 정밀도 관리 전략을 비교한 것이다.</p>
<table><thead><tr><th><strong>연산 단계</strong></th><th><strong>Transformer (Standard)</strong></th><th><strong>Mamba (Hardware-Aware)</strong></th><th><strong>이유 및 효과</strong></th></tr></thead><tbody>
<tr><td><strong>Input Load</strong></td><td>FP16/BF16</td><td>FP16/BF16</td><td>HBM 대역폭 절약</td></tr>
<tr><td><strong>Main Compute</strong></td><td>FP16 (MatMul)</td><td><strong>FP32 (Recurrent Scan)</strong></td><td>순환 오차 누적 방지 (안정성 필수)</td></tr>
<tr><td><strong>Activation</strong></td><td>FP16</td><td><strong>FP32 (Exp, Softplus)</strong></td><td>지수 함수의 수치적 민감성 제어</td></tr>
<tr><td><strong>State Storage</strong></td><td>N/A (Stateless)</td><td><strong>FP32 (in SRAM/Registers)</strong></td><td>중간 상태(<span class="math math-inline">h</span>)의 정밀도 유지</td></tr>
<tr><td><strong>Output Write</strong></td><td>FP16/BF16</td><td>FP16/BF16</td><td>다음 레이어로의 전송 효율</td></tr>
</tbody></table>
<p>18</p>
<p>이러한 정밀한 혼합 정밀도 설계는 사용자가 별도로 설정하지 않아도 <code>selective_scan_cuda</code> 커널 내부에서 자동으로 처리되며, 파이토치(PyTorch) 레벨에서는 투명하게 작동한다. 이는 개발자가 수치적 세부 사항을 신경 쓰지 않고도 안정적인 학습을 할 수 있게 해주는 Mamba 시스템 구현의 백미이다.</p>
<h2>4.  재계산(Recomputation) 전략: 역전파의 메모리 혁명</h2>
<p>딥러닝 모델의 학습(Training) 시에는 역전파를 위해 순전파(Forward Pass) 때 계산된 중간 값들을 저장해 두어야 한다(Activation Storing). 그러나 Mamba의 경우, 중간 상태인 <span class="math math-inline">h</span>의 크기가 <span class="math math-inline">B \times L \times D \times N</span>으로 매우 거대하다. 시퀀스 길이 <span class="math math-inline">L</span>이 100만(<span class="math math-inline">1M</span>)에 달할 때, 이를 모두 HBM에 저장하는 것은 수백 GB의 메모리를 요구하므로 물리적으로 불가능하다. Mamba는 이 문제를 해결하기 위해 <strong>커널 레벨 재계산(Kernel-Level Recomputation)</strong> 전략을 채택한다.1</p>
<h3>4.1  메모리 vs 연산 트레이드오프</h3>
<p>재계산 전략의 기본 아이디어는 “메모리를 아끼기 위해 연산을 두 번 한다“는 것이다. HBM 접근은 느리고 비싸지만, GPU 코어의 연산 능력(FLOPS)은 상대적으로 풍부하고 저렴하다. 따라서 거대한 상태 데이터를 저장하는 대신, 역전파 시점에 필요한 데이터를 다시 계산해내는 것이 전체 학습 속도와 효율성 면에서 훨씬 유리하다.18</p>
<p>전통적인 ‘Gradient Checkpointing’ (또는 Activation Checkpointing)은 레이어의 입력과 출력만을 저장하고 레이어 내부 연산을 다시 수행하는 방식이다. Mamba의 재계산은 이보다 한 단계 더 나아가 <strong>CUDA 커널 내부</strong>에서 최적화된 형태로 수행된다.</p>
<h3>4.2  Mamba의 Backward Pass 메커니즘</h3>
<p>Mamba의 재계산 과정은 다음과 같이 정교하게 설계되어 있다.27</p>
<ol>
<li><strong>순전파 (Forward Pass):</strong></li>
</ol>
<ul>
<li>HBM에는 입력 데이터(<span class="math math-inline">u, \Delta, B, C</span>)와 최종 출력(<span class="math math-inline">y</span>)만을 저장한다.</li>
<li>중간 상태인 <span class="math math-inline">h_t</span>는 SRAM에서 계산된 직후 다음 스텝 계산에 사용되고 덮어씌워진다(Overwritten). 즉, <span class="math math-inline">h</span>의 전체 궤적(Trajectory)은 HBM에 저장되지 않는다.</li>
<li>대신 역전파 가속을 위해 긴 시퀀스를 일정 간격(예: 청크 단위)으로 나눈 뒤, 각 청크의 **경계 상태(Boundary States)**나 **중간 스캔 상태(Scan Intermediates)**만을 드문드문 저장한다.29</li>
</ul>
<ol start="2">
<li><strong>역전파 (Backward Pass):</strong></li>
</ol>
<ul>
<li>그라디언트를 계산해야 할 때, 저장해 둔 입력(<span class="math math-inline">u, \Delta, B, C</span>)과 경계 상태를 HBM에서 다시 로드한다.</li>
<li>SRAM 내부에서 **순전파 연산을 다시 수행(Re-run)**하여, 필요한 시점의 <span class="math math-inline">h_t</span>를 순간적으로 복원한다.</li>
<li>복원된 <span class="math math-inline">h_t</span>와 상위 레이어에서 넘어온 그라디언트(<span class="math math-inline">\partial L / \partial y</span>)를 결합하여 현재 레이어의 파라미터에 대한 그라디언트(<span class="math math-inline">\partial L / \partial A, \partial L / \partial B</span> 등)를 계산한다.</li>
<li>이 모든 과정이 하나의 융합된 커널(<code>selective_scan_bwd</code>) 안에서 이루어지므로, 재계산된 <span class="math math-inline">h_t</span>를 HBM에 썼다가 읽는 불필요한 오버헤드가 전혀 발생하지 않는다.</li>
</ul>
<h3>4.3  효율성 분석 및 FlashAttention과의 비교</h3>
<p>이러한 재계산 전략 덕분에 Mamba의 학습 시 메모리 사용량은 시퀀스 길이 <span class="math math-inline">L</span>에 대해 선형적(<span class="math math-inline">O(BLD)</span>)이며, 상태 차원 <span class="math math-inline">N</span>에 대해서는 거의 상수에 가깝게 유지된다. 이는 Mamba가 수백만 토큰의 긴 시퀀스를 단일 GPU에서 학습할 수 있는 결정적인 이유이다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Gradient Checkpointing (PyTorch Default)</strong></th><th><strong>Mamba Kernel Recomputation</strong></th></tr></thead><tbody>
<tr><td><strong>저장 대상</strong></td><td>레이어의 입/출력 (Layer Boundaries)</td><td>입력 (<span class="math math-inline">u, \Delta, B, C</span>) 및 Scan Intermediates</td></tr>
<tr><td><strong>메모리 절약</strong></td><td>레이어 내부 Activation 절약</td><td><strong>거대한 잠재 상태(<span class="math math-inline">h</span>) 전체 절약</strong></td></tr>
<tr><td><strong>연산 오버헤드</strong></td><td>Forward 연산 전체 재실행 (100% 추가)</td><td>Scan 연산만 재실행 (약 30-40% 추가)</td></tr>
<tr><td><strong>구현 레벨</strong></td><td>Framework Level (Python)</td><td><strong>Kernel Level (CUDA/C++)</strong></td></tr>
<tr><td><strong>I/O 효율</strong></td><td>HBM I/O 발생 가능</td><td><strong>SRAM 내 처리로 HBM I/O 최소화</strong></td></tr>
</tbody></table>
<p>17</p>
<p>Mamba의 방식은 FlashAttention-2의 역전파 방식과 유사하지만, 순차적 의존성이 있는 Recurrence 구조를 복원해야 한다는 점에서 더 복잡한 제어 로직을 요구한다. Mamba는 이를 위해 역방향 스캔(Reverse Scan)을 위한 별도의 커널 로직을 구현하여, 시간의 역순으로 그라디언트를 전파하면서 상태를 복원하는 고난도의 기술을 적용했다.18</p>
<h2>5.  확장성과 학습 안정성 (Scalability &amp; Stability)</h2>
<p>Mamba의 수치적 안정성과 재계산 전략은 소규모 실험실 모델을 넘어, 수십억(Billions) 파라미터 규모의 거대 모델로 확장될 때 그 진가를 발휘한다.</p>
<h3>5.1  대규모 모델에서의 안정성 (Scaling Laws)</h3>
<p>모델의 크기가 커질수록(<span class="math math-inline">1B \to 3B \to 7B</span>), 파라미터 공간은 넓어지고 최적화 난이도는 상승한다. Mamba는 FP32 기반의 내부 연산과 구조적 파라미터화 덕분에, 모델 크기가 커져도 학습 손실(Training Loss)이 튀거나 발산하지 않고 안정적으로 수렴하는 특성을 보인다.1 특히 Transformer 기반 모델들이 대규모 학습 시 겪는 “Loss Spike” 현상이 Mamba에서는 현저히 적게 관찰되는데, 이는 상태 공간의 에너지를 제한하는 <span class="math math-inline">A</span> 행렬의 음수 제약과 Softplus <span class="math math-inline">\Delta</span>가 강력한 규제(Regularization) 효과를 발휘하기 때문으로 분석된다.4</p>
<h3>5.2  양자화(Quantization)와 미래의 과제</h3>
<p>최근에는 Mamba 모델을 엣지 디바이스 등에 배포하기 위해 FP8이나 INT8로 양자화하려는 시도가 이어지고 있다. 그러나 Mamba의 Scan 연산은 이상치(Outlier)에 민감하여, 단순한 양자화(Post-Training Quantization) 적용 시 성능이 트랜스포머보다 더 급격히 하락하는 경향이 있다.32</p>
<p>이에 대한 대응으로 **H2 Quantization (Hybrid, Hardware-friendly)**과 같이, 가중치(Weight)는 텐서 단위로, 활성화(Activation)는 채널 단위로 양자화하거나, 이상치를 동적으로 필터링하는 OuroMamba와 같은 기법들이 제안되고 있다.32 이는 Mamba의 수치적 특성을 고려한 전용 양자화 방법론이 필수적임을 시사한다.</p>
<h2>6.  결론: 견고한 시스템 아키텍처의 승리</h2>
<p>결론적으로 Mamba의 <strong>수치적 안정성</strong>과 <strong>재계산 전략</strong>은 단순한 구현상의 디테일이 아니라, 아키텍처의 생존을 결정짓는 핵심 기술이다.</p>
<ul>
<li><strong><span class="math math-inline">\Delta</span>의 Softplus 및 <span class="math math-inline">A</span>의 음수 제약</strong>은 시변 동역학 시스템이 발산하지 않고 안정적으로 학습될 수 있는 수학적 토대를 마련했다.</li>
<li><strong>SRAM 기반의 FP32 혼합 정밀도 스캔</strong>은 GPU 하드웨어의 특성을 고려하여 속도 저하 없이 정밀도 문제를 해결했다.</li>
<li><strong>커널 레벨 재계산 전략</strong>은 메모리라는 물리적 장벽을 허물어, 트랜스포머가 감히 도달하지 못했던 백만 토큰 길이의 문맥 처리를 가능하게 했다.</li>
</ul>
<p>이러한 시스템적 혁신은 Mamba가 단순한 이론적 제안을 넘어, 실제 거대 언어 모델(LLM) 및 유전체 분석 모델의 백본(Backbone)으로 자리 잡게 한 원동력이며, 향후 등장할 Mamba-2 및 하이브리드 아키텍처들이 나아가야 할 시스템 엔지니어링의 기준점을 제시하고 있다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://openreview.net/forum?id=tEYskw1VY2</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://arxiv.org/pdf/2312.00752</li>
<li>Here Comes Mamba: The Selective State Space Model, https://towardsdatascience.com/here-comes-mamba-the-selective-state-space-model-435e5d17a451/</li>
<li>MAMBA STATE-SPACE MODELS ARE LYAPUNOV - OpenReview, https://openreview.net/pdf?id=XDfyJqlB4T</li>
<li>A question about matrix A · Issue #326 · state-spaces/mamba - GitHub, https://github.com/state-spaces/mamba/issues/326</li>
<li>CENCY AND OVER-SMOOTHING - OpenReview, https://openreview.net/pdf?id=pymXpl4qvi</li>
<li>UNLOCKING STATE-TRACKING IN LINEAR RNNS THROUGH …, https://proceedings.iclr.cc/paper_files/paper/2025/file/5a0ce3abb720b740419e193c87afd080-Paper-Conference.pdf</li>
<li>Train With Mixed Precision - NVIDIA Docs, https://docs.nvidia.com/deeplearning/performance/mixed-precision-training/index.html</li>
<li>Mixed Precision Training - Paperspace Blog, https://blog.paperspace.com/mixed-precision-training-overview/</li>
<li>(PDF) Unlocking State-Tracking in Linear RNNs Through Negative …, https://www.researchgate.net/publication/385945327_Unlocking_State-Tracking_in_Linear_RNNs_Through_Negative_Eigenvalues</li>
<li>some confusion about mamba block · Issue #281 - GitHub, https://github.com/state-spaces/mamba/issues/281</li>
<li>Phylliida/MambaLens: Mamba support for transformer lens - GitHub, https://github.com/Phylliida/MambaLens</li>
<li>sparse mamba: introducing controllability, observability, and stability …, https://arxiv.org/pdf/2409.00563</li>
<li>History of State Space Models (SSM) in 2022 - Hugging Face, https://huggingface.co/blog/lbourdois/ssm-2022</li>
<li>Unlocking State-Tracking in Linear RNNs Through Negative …, https://openreview.net/forum?id=UvTo3tVBk2</li>
<li>State Space Duality (Mamba-2) Part I - The Model | Tri Dao, https://tridao.me/blog/2024/mamba2-part1-model/</li>
<li>Mamba: Make Sequence Models Fast Again | by Dong-Keon Kim, https://medium.com/@kdk199604/mamba-make-sequence-models-fast-again-540245a49155</li>
<li>Mamba on AMD GPUs with ROCm, https://rocm.blogs.amd.com/artificial-intelligence/mamba/README.html</li>
<li>Mamba: SSM, Theory, and Implementation in Keras and TensorFlow, https://medium.com/data-science/mamba-ssm-theory-and-implementation-in-keras-and-tensorflow-32d6d4b32546</li>
<li>Mamba: The Hard Way - Ebrahim Pichka, https://epichka.com/annotated-papers/mamba/</li>
<li>Mamba2: The Hardware-Algorithm Co-Design That Unified Attention …, https://medium.com/@danieljsmit/mamba2-the-hardware-algorithm-co-design-that-unified-attention-and-state-space-models-77856d2ac4f4</li>
<li>Tiled Flash Linear Attention: More Efficient Linear … - OpenReview, https://openreview.net/pdf/2aade266e5cf669740d1a6576caff6b3d7c10d8c.pdf</li>
<li>Tiled Flash Linear Attention: More Efficient Linear RNN and xLSTM …, https://www.researchgate.net/publication/389947383_Tiled_Flash_Linear_Attention_More_Efficient_Linear_RNN_and_xLSTM_Kernels</li>
<li>Tensor Cores and mixed precision <em>matrix multiplication</em> - output in …, https://discuss.pytorch.org/t/tensor-cores-and-mixed-precision-matrix-multiplication-output-in-float32/42831</li>
<li>Characterizing the Behavior of Training Mamba-based State Space …, https://arxiv.org/html/2508.17679v1</li>
<li>How State Space Models Are Challenging Transformers - Medium, https://medium.com/@aftab001x/the-mamba-revolution-how-state-space-models-are-challenging-transformers-4ad3b276b9a8</li>
<li>SS2D反向传播问题记录【未解决】_notimplementederror - CSDN博客, https://blog.csdn.net/weixin_45231460/article/details/139534681</li>
<li>modeling_phi4flash.py · microsoft/Phi-4-mini-flash-reasoning at refs …, https://huggingface.co/microsoft/Phi-4-mini-flash-reasoning/blob/refs%2Fpr%2F8/modeling_phi4flash.py</li>
<li>selective_scan_cuda · Issue #605 · state-spaces/mamba - GitHub, https://github.com/state-spaces/mamba/issues/605</li>
<li>Frontier Training Kernels for Transformers (FA2) and SSMs … - Zyphra, https://www.zyphra.com/post/training-transformers-and-hybrid-models-on-amd-mi300x</li>
<li>Vision Mamba: Like a Vision Transformer but Better, https://towardsdatascience.com/vision-mamba-like-a-vision-transformer-but-better-3b2660c35848/</li>
<li>An End-to-End Vision Mamba Accelerator for Edge Computing …, https://arxiv.org/html/2508.02977v1</li>
<li>OuroMamba: A Data-Free Quantization Framework for Vision Mamba, https://arxiv.org/html/2503.10959v2</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>