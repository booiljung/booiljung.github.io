<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:8.3 MambaExtend & LongMamba - 훈련 없는(Training-Free) 컨텍스트 확장과 글로벌 채널 필터링</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>8.3 MambaExtend & LongMamba - 훈련 없는(Training-Free) 컨텍스트 확장과 글로벌 채널 필터링</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>8.3 MambaExtend & LongMamba - 훈련 없는(Training-Free) 컨텍스트 확장과 글로벌 채널 필터링</span></nav>
                </div>
            </header>
            <article>
                <h1>8.3 MambaExtend &amp; LongMamba - 훈련 없는(Training-Free) 컨텍스트 확장과 글로벌 채널 필터링</h1>
<h2>1.  서론: 선형 복잡도 모델의 딜레마와 확장의 필요성</h2>
<p>현대 인공지능 연구의 최전선에서 거대 언어 모델(Large Language Model, LLM)은 텍스트 이해와 생성 능력에서 비약적인 발전을 이루었다. 그러나 이러한 발전의 이면에는 트랜스포머(Transformer) 아키텍처의 근본적인 구조적 한계, 즉 시퀀스 길이(<span class="math math-inline">L</span>)에 따라 연산량과 메모리 사용량이 이차적(<span class="math math-inline">O(L^2)</span>)으로 증가한다는 ‘어텐션 병목(Attention Bottleneck)’ 현상이 자리 잡고 있다. 이는 수천 토큰을 넘어 수만, 수십만 토큰에 이르는 긴 문맥(Long Context)을 처리해야 하는 법률 문서 분석, 장편 소설 창작, 유전체학(Genomics) 분석과 같은 과업에서 막대한 컴퓨팅 자원을 요구하며 실용적인 배포를 가로막는 장벽이 되어왔다.</p>
<p>이러한 배경 속에서 등장한 상태 공간 모델(State Space Models, SSM), 그중에서도 맘바(Mamba) 아키텍처는 시퀀스 길이에 대해 선형적(<span class="math math-inline">O(L)</span>)인 연산 복잡도와 추론 시 상수(<span class="math math-inline">O(1)</span>) 메모리 요구량을 앞세워 트랜스포머의 강력한 대항마로 부상했다. 맘바는 순환 신경망(RNN)의 효율성과 합성곱 신경망(CNN)의 병렬 처리 이점을 결합한 선택적 상태 공간(Selective State Space) 메커니즘을 통해 긴 시퀀스를 효율적으로 압축하고 처리할 수 있는 가능성을 보여주었다.1</p>
<p>하지만 맘바와 같은 순환 구조 모델은 ’고정된 크기의 상태(State)’에 모든 과거 정보를 압축해야 한다는 본질적인 특성으로 인해, 훈련 시 보지 못한 긴 길이의 시퀀스에 대해 일반화(Extrapolation)하는 데 심각한 어려움을 겪는다. 트랜스포머는 KV 캐시(KV Cache)를 통해 과거의 모든 토큰 정보를 명시적으로 저장하고 필요할 때 검색할 수 있는 반면, 맘바는 제한된 용량의 은닉 상태(Hidden State)를 지속적으로 업데이트하는 과정에서 오래된 정보나 덜 중요해 보이는 정보를 필연적으로 소실하게 된다. 이는 문맥의 길이가 모델이 사전 학습된 길이(Pre-training Context Length)를 초과할 때 급격한 성능 저하로 이어진다.3</p>
<p>본 장에서는 이러한 맘바 모델의 한계를 극복하기 위해 제안된 최신 연구 흐름인 <strong>‘훈련 없는(Training-Free) 컨텍스트 확장’</strong> 방법론을 심층적으로 다룬다. 특히, 이산화 단계(Discretization Step)의 재조정을 통해 시간적 해상도를 조절하는 <strong>MambaExtend</strong>와, 모델 내부의 채널 특성을 분석하여 중요 정보를 선별적으로 보존하는 <strong>LongMamba</strong>를 중심으로 논의를 전개한다. 이 두 방법론은 추가적인 대규모 재학습(Retraining)이나 파인튜닝(Fine-tuning) 없이 기존의 사전 학습된 체크포인트를 활용하여 컨텍스트 윈도우를 수십 배 확장할 수 있다는 점에서 비용 효율적이며 실용적인 가치를 지닌다. 우리는 이들의 이론적 배경, 구동 원리, 그리고 실험적 검증 결과를 통해 SSM 기반 모델이 나아가야 할 장기 기억 보존의 해법을 모색하고자 한다.</p>
<h2>2.  맘바의 장기 기억 상실 메커니즘과 이론적 배경</h2>
<p>맘바 모델이 긴 문맥 처리에서 겪는 성능 저하의 원인을 규명하기 위해서는, 이 모델의 근간이 되는 연속 시간(Continuous-time) 시스템의 동역학(Dynamics)과 이를 디지털 컴퓨터에서 처리하기 위해 수행하는 이산화(Discretization) 과정을 수학적으로 이해해야 한다.</p>
<h3>2.1  선택적 상태 공간 모델(Selective SSM)의 구조</h3>
<p>맘바는 입력 시퀀스 <span class="math math-inline">x(t) \in \mathbb{R}</span>를 은닉 상태 <span class="math math-inline">h(t) \in \mathbb{R}^N</span>로 매핑하고, 이를 다시 출력 <span class="math math-inline">y(t) \in \mathbb{R}</span>로 변환하는 선형 시불변(LTI) 시스템에서 출발하여, 입력에 따라 파라미터가 변하는 시변(Time-varying) 시스템으로 발전한 형태다. 연속 시간에서의 상태 방정식은 다음과 같다.5<br />
<span class="math math-display">
h&#39;(t) = A h(t) + B x(t)
</span></p>
<p><span class="math math-display">
y(t) = C h(t)
</span></p>
<p>여기서 <span class="math math-inline">A \in \mathbb{R}^{N \times N}</span>는 시스템의 상태 전이(State Transition)를 관장하는 행렬이며, <span class="math math-inline">B</span>와 <span class="math math-inline">C</span>는 각각 입력과 출력의 투영(Projection) 행렬이다. 딥러닝 모델, 특히 텍스트와 같은 이산 데이터에 이를 적용하기 위해서는 ‘제로 오더 홀드(Zero-Order Hold, ZOH)’ 방식을 사용하여 연속 시스템을 이산화해야 한다. 타임스텝 <span class="math math-inline">k</span>에서의 이산화된 점화식은 다음과 같이 표현된다.<br />
<span class="math math-display">
h_k = \bar{A}_k h_{k-1} + \bar{B}_k x_k
</span></p>
<p><span class="math math-display">
y_k = C_k h_k
</span></p>
<p>이 과정에서 맘바의 핵심 혁신인 ’선택성(Selectivity)’이 개입한다. 기존 SSM과 달리 맘바는 이산화 파라미터 <span class="math math-inline">\bar{A}_k</span>와 <span class="math math-inline">\bar{B}_k</span>가 입력 <span class="math math-inline">x_k</span>에 의존하여 동적으로 변한다. 이는 타임스케일 파라미터 <span class="math math-inline">\Delta_k</span>를 통해 조절된다.<br />
<span class="math math-display">
\Delta_k = \text{Softplus}(\text{Linear}(x_k)) \\ \bar{A}_k = \exp(\Delta_k A) \\ \bar{B}_k = (\Delta_k A)^{-1} (\exp(\Delta_k A) - I) \cdot \Delta_k B
</span><br />
이 <span class="math math-inline">\Delta_k</span>는 모델이 현재 입력 <span class="math math-inline">x_k</span>를 얼마나 중요하게 받아들일지, 그리고 과거의 상태 <span class="math math-inline">h_{k-1}</span>를 얼마나 유지하거나 망각할지를 결정하는 ‘게이트(Gate)’ 역할을 수행한다. <span class="math math-inline">\Delta_k</span>가 크면 현재 입력의 영향력이 커지고 과거 정보는 빠르게 소멸(Forget)하며, <span class="math math-inline">\Delta_k</span>가 작으면 과거 상태가 오랫동안 유지된다.1</p>
<h3>2.2  상태 공간의 지수적 붕괴(Exponential Decay)와 정보 병목</h3>
<p>문제는 행렬 <span class="math math-inline">A</span>의 수학적 성질에서 비롯된다. SSM의 안정적인 학습을 위해 <span class="math math-inline">A</span>는 보통 HiPPO(High-order Polynomial Projection Operator) 이론에 기반하여 초기화되며, 이는 <span class="math math-inline">A</span>의 고유값(Eigenvalues)이 음의 실수부(Negative Real Part)를 갖도록 유도한다. 따라서 <span class="math math-inline">\Delta_k &gt; 0</span>일 때, <span class="math math-inline">\bar{A}_k = \exp(\Delta_k A)</span>의 고유값 크기는 1보다 작게 된다 (<span class="math math-inline">|\lambda(\bar{A}_k)| &lt; 1</span>).</p>
<p>시퀀스 길이가 길어질수록, 초기 시점의 정보 <span class="math math-inline">h_0</span>가 현재 시점 <span class="math math-inline">t</span>의 상태 <span class="math math-inline">h_t</span>에 미치는 영향은 누적된 상태 전이 행렬의 곱에 의해 결정된다.<br />
<span class="math math-display">
h_t = \left( \prod_{i=1}^{t} \bar{A}_i \right) h_0 + \sum_{j=1}^{t} \left( \prod_{i=j+1}^{t} \bar{A}_i \right) \bar{B}_j x_j
</span><br />
여기서 <span class="math math-inline">\prod \bar{A}_i</span> 항은 시퀀스 길이가 훈련 시 보았던 길이 <span class="math math-inline">L_{train}</span>을 초과하여 <span class="math math-inline">L_{inference} \rightarrow \infty</span>로 갈수록 0에 수렴하게 된다.7 이를 ‘상태 붕괴(State Collapse)’ 또는 ’지수적 기억 감퇴(Exponential Memory Decay)’라 한다. 훈련 범위 내에서는 모델이 이 감퇴 속도를 적절히 학습하여 필요한 정보를 유지하지만, 훈련 범위를 벗어난 긴 시퀀스에서는 감퇴가 누적되어 초기 정보가 완전히 소실되는 현상이 발생한다.</p>
<p>더욱이 맘바의 고정된 상태 크기 <span class="math math-inline">N</span>은 정보 용량(Capacity)의 물리적 한계를 의미한다. 트랜스포머가 무한히 늘어나는 KV 캐시에 모든 정보를 저장하는 것과 달리, 맘바는 새로운 정보가 유입될 때마다 제한된 <span class="math math-inline">N</span> 차원의 공간에 이를 압축해 넣어야 한다. 이는 정보 이론적으로 ’손실 압축(Lossy Compression)’에 해당하며, 문맥이 길어질수록 정보의 밀도가 높아져 결국 ‘기억 용량 포화(Memory Capacity Saturation)’ 상태에 도달하게 된다. 이로 인해 모델은 가장 최근의 정보만을 기억하고 초기의 중요한 지시사항이나 문맥을 잊어버리는 치명적인 망각 현상을 겪게 된다.4</p>
<h3>2.3  분포 밖(Out-of-Distribution, OOD) 이산화 문제</h3>
<p>MambaExtend 연구진은 성능 저하의 또 다른 핵심 원인으로 ’이산화 단계의 분포 불일치(Distribution Shift)’를 지목했다. 추론 시 시퀀스 길이가 길어지면, 누적되는 <span class="math math-inline">\Delta_k</span>의 총합이 훈련 시 관측된 분포를 크게 벗어나게 된다. 이는 상태 전이 과정에서 수치적 불안정성을 야기하고, 모델이 학습하지 못한 영역의 상태 공간으로 궤적을 이탈하게 만든다. 즉, 개별 <span class="math math-inline">\Delta_k</span> 값 자체는 정상 범위일지라도, 긴 시퀀스에 걸쳐 누적된 효과는 모델이 감당할 수 없는 수준의 변형을 초래하는 것이다.11 이러한 OOD 현상은 단순한 정보 소실을 넘어, 모델의 언어 모델링 능력(Perplexity) 자체를 붕괴시키는 주된 요인으로 작용한다.</p>
<hr />
<h2>3.  MambaExtend: 시간적 해상도의 재조정과 이산화 보정</h2>
<p>이러한 이론적 배경 하에, <strong>MambaExtend</strong>는 트랜스포머의 ‘위치 보간(Positional Interpolation)’ 기법에서 영감을 받아 훈련 없이 맘바 모델의 컨텍스트를 확장하는 방법론으로 제안되었다. 이 접근법의 핵심은 모델이 인지하는 시간의 흐름을 조절하여, 물리적으로 더 긴 시퀀스를 마치 훈련된 길이의 시퀀스처럼 처리하도록 유도하는 것이다.</p>
<h3>3.1  방법론적 핵심: 이산화 단계(<span class="math math-inline">\Delta</span>) 스케일링</h3>
<p>MambaExtend는 각 레이어의 이산화 파라미터 <span class="math math-inline">\Delta_t</span>에 학습 가능한 스케일링 팩터(Scaling Factor) <span class="math math-inline">s \in \mathbb{R}</span>를 도입한다.<br />
<span class="math math-display">
\tilde{\Delta}_{t, l} = s_l \cdot \Delta_{t, l}
</span><br />
여기서 <span class="math math-inline">l</span>은 레이어 인덱스를 나타낸다. 일반적으로 <span class="math math-inline">0 &lt; s_l \le 1</span>의 값을 가지도록 설정되는데, 이는 이산화의 간격을 촘촘하게 만드는 효과가 있다. 물리적 비유를 들자면, 1초 간격으로 샘플링하던 데이터를 0.5초 간격으로 샘플링하도록 변경하는 것과 유사하다. 이렇게 되면 실제로는 2배 긴 시간 동안 데이터가 들어오더라도, 모델 내부의 상태 전이 시스템 관점에서는 기존과 동일한 수의 스텝만이 진행된 것으로 인식하게 된다.</p>
<p>수식적으로 <span class="math math-inline">\bar{A}_t = \exp(\Delta_t A)</span>에서 <span class="math math-inline">\Delta_t</span>가 작아지면 <span class="math math-inline">\bar{A}_t</span>는 단위 행렬 <span class="math math-inline">I</span>에 더 가까워진다 (<span class="math math-inline">\lim_{\Delta \to 0} \exp(\Delta A) = I</span>). 이는 상태 <span class="math math-inline">h_t</span>가 이전 상태 <span class="math math-inline">h_{t-1}</span>와 더 유사하게 유지됨을 의미하며, 결과적으로 정보의 붕괴 속도(Decay Rate)를 늦추는 효과를 가져온다.13 이를 통해 맘바 모델은 훈련 길이보다 훨씬 긴 시퀀스에서도 급격한 상태 변화나 발산 없이 안정적인 추론을 수행할 수 있게 된다.</p>
<h3>3.2  최적화 전략: 그래디언트 기반 및 제로 오더 최적화</h3>
<p>단순히 모든 레이어의 <span class="math math-inline">\Delta</span>를 일괄적으로 줄이는 것은 최적의 해법이 아니다. 레이어마다 담당하는 정보의 추상화 수준과 시간적 의존성이 다르기 때문이다. MambaExtend는 소량의 보정 데이터셋(Calibration Set, 예: PG-19의 일부 챕터)을 사용하여 각 레이어별 최적의 스케일링 팩터 <span class="math math-inline">{s_1,..., s_L}</span>을 찾아내는 과정을 수행한다. 이때 모델의 원본 가중치(Weights)는 동결(Frozen) 상태를 유지하므로, 대규모 재학습에 비해 계산 비용이 극히 낮다.11</p>
<p>연구진은 두 가지 최적화 알고리즘을 제안한다:</p>
<ol>
<li>그래디언트 기반 최적화 (Gradient-based Optimization):</li>
</ol>
<p>스케일링 팩터 <span class="math math-inline">s</span>를 학습 가능한 파라미터로 설정하고, 보정 데이터에 대한 언어 모델링 손실(Loss)을 최소화하는 방향으로 역전파(Backpropagation)를 수행한다.</p>
<ul>
<li><strong>장점:</strong> 정확한 그래디언트 정보를 활용하므로 수렴 속도가 빠르고 최적해에 근접할 가능성이 높다.</li>
<li><strong>단점:</strong> 역전파를 위해 계산 그래프를 유지해야 하므로 메모리 사용량이 상대적으로 높다.</li>
</ul>
<ol start="2">
<li>제로 오더 최적화 (Zeroth-Order Optimization):</li>
</ol>
<p>미분 불가능한 상황이나 메모리 제약이 극심한 엣지 디바이스 환경을 고려하여, 그래디언트 계산 없이 <span class="math math-inline">s</span>를 최적화한다. 이는 진화 전략(Evolution Strategy)과 유사하게, <span class="math math-inline">s</span> 값에 작은 섭동(Perturbation)을 주었을 때의 손실 함수 변화를 관측하여 업데이트 방향을 추정한다.</p>
<ul>
<li><strong>장점:</strong> 역전파가 필요 없어 메모리 효율이 극대화된다. MambaExtend 연구 결과, 기존 파인튜닝 대비 피크 메모리 사용량을 최대 3.87배까지 줄일 수 있었다.12</li>
<li><strong>단점:</strong> 그래디언트 기반 방식보다는 수렴 정밀도가 다소 낮을 수 있다.</li>
</ul>
<p>이러한 최적화 과정을 통해 MambaExtend는 전체 파라미터를 튜닝하는 방식 대비 약 <span class="math math-inline">5.42 \times 10^6</span>배 적은 파라미터 업데이트만으로도, 문맥 길이를 2k 토큰에서 64k 토큰까지 32배 확장하는 데 성공했다. 이는 맘바 모델의 외삽(Extrapolation) 능력을 획기적으로 향상시킨 결과로 평가받는다.12</p>
<h3>3.3  Mamba Modulation: <span class="math math-inline">A</span> 행렬에 대한 직접적 개입</h3>
<p>MambaExtend와 밀접하게 관련된, 혹은 그 확장선상에 있는 연구로 <strong>Mamba Modulation</strong>이 있다. 이 연구는 <span class="math math-inline">\Delta</span>를 스케일링하는 간접적인 방식 대신, 상태 전이 행렬 <span class="math math-inline">A</span> 자체의 스펙트럼(Spectrum)을 직접 조절하는 것이 더 효과적일 수 있다는 가설을 제시한다.7</p>
<p>MambaExtend가 <span class="math math-inline">\exp(s \cdot \Delta \cdot A)</span>를 통해 사실상 <span class="math math-inline">A</span>에 스칼라배를 하는 효과를 낸다면, Mamba Modulation은 <span class="math math-inline">A</span>의 고유값 분포를 분석하여 장기 기억에 방해가 되는 성분을 선별적으로 억제하거나 강화한다. 실험 결과, <span class="math math-inline">A</span> 행렬을 직접 스케일링하는 방식이 <span class="math math-inline">\Delta</span>를 조절하는 방식보다 PG-19 데이터셋 등의 장기 문맥 과제에서 약 10% 더 우수한 펄플렉서티 개선 효과를 보였다는 보고가 있다.[7, 13] 이는 맘바의 장기 기억 능력이 단순히 시간의 흐름(<span class="math math-inline">\Delta</span>)뿐만 아니라, 시스템 고유의 동역학적 특성(<span class="math math-inline">A</span>)에 깊이 의존하고 있음을 시사한다. Mamba Modulation은 MambaExtend의 방법론적 프레임워크를 공유하면서도, 제어 대상을 보다 근본적인 시스템 행렬로 옮겨 성능을 고도화한 사례라 할 수 있다.</p>
<h2>4.  LongMamba: 글로벌 채널의 발견과 선택적 정보 필터링</h2>
<p>MambaExtend가 시스템 전체의 시간적 해상도를 조절하여 붕괴를 지연시키는 ‘거시적’ 접근이라면, <strong>LongMamba</strong>는 모델 내부의 채널별 역할을 규명하고 중요 정보만을 선별하여 저장하는 ’미시적’이고 ’구조적’인 접근을 취한다. 이 방법론은 맘바의 모든 은닉 채널이 동일한 방식으로 작동하지 않는다는 <strong>‘채널의 이원화’</strong> 발견에서 출발한다.8</p>
<h3>4.1  핵심 발견: 로컬 채널 vs 글로벌 채널</h3>
<p>LongMamba 연구진은 훈련된 맘바 모델의 은닉 상태 채널들의 수용 영역(Receptive Field)을 분석한 결과, 채널들이 명확히 두 가지 그룹으로 나뉜다는 사실을 밝혀냈다.8</p>
<ol>
<li>로컬 채널 (Local Channels):</li>
</ol>
<p>이 채널들은 훈련 시퀀스 길이(<span class="math math-inline">L_{train}</span>)보다 훨씬 짧은 유효 수용 영역을 가진다. 어텐션 맵을 시각화해보면, 마치 합성곱(Convolution) 필터나 슬라이딩 윈도우 어텐션(Sliding Window Attention)처럼 현재 토큰 주변의 국소적인 정보만을 강하게 참조한다. 이들은 문법적 구조나 인접 단어 간의 관계를 파악하는 역할을 하며, 시퀀스 길이가 길어져도 정보 붕괴의 영향을 거의 받지 않는다. 이미 짧은 정보만을 유지하도록 학습되었기 때문이다.</p>
<ol start="2">
<li>글로벌 채널 (Global Channels):</li>
</ol>
<p>이 채널들은 훈련 시퀀스 전체(<span class="math math-inline">L_{train}</span>)에 필적하는 매우 긴 수용 영역을 가진다. 이들은 문맥 전체의 주제, 장기적인 의존성, 핵심 키워드 등 ’글로벌 정보’를 요약하고 저장하는 역할을 수행한다. 문제의 핵심은 바로 여기에 있다. 시퀀스 길이가 훈련 길이를 초과(<span class="math math-inline">L_{inference} \gg L_{train}</span>)하게 되면, 이 글로벌 채널들은 용량의 한계에 도달한다. 새로운 토큰들이 계속 유입됨에 따라 기존에 저장해 둔 중요한 장기 정보가 희석되거나 덮어씌워지며(Overwritten), 이로 인해 모델의 장기 기억 능력이 상실된다. LongMamba는 바로 이 글로벌 채널의 붕괴를 막는 데 집중한다.</p>
<h3>4.2  1단계: 채널 분류 (Channel Classification) 알고리즘</h3>
<p>LongMamba는 추론 전에 단 한 번의 분석을 통해 글로벌 채널을 식별한다. 식별 기준은 **누적 붕괴율(Cumulative Decay Rate)**이다. 채널 <span class="math math-inline">k</span>가 훈련 길이 <span class="math math-inline">L</span> 동안 겪는 정보 감퇴의 총량은 상태 전이 행렬의 곱으로 표현된다.<br />
<span class="math math-display">
\text{Decay}_k(L) = \prod_{t=1}^{L} \bar{A}_{t, k}
</span><br />
여기서 <span class="math math-inline">\bar{A}_{t, k}</span>는 시점 <span class="math math-inline">t</span>, 채널 <span class="math math-inline">k</span>에서의 이산화된 전이 값이다. LongMamba는 이 누적 붕괴 값이 특정 임계값 <span class="math math-inline">\theta</span>보다 큰 채널을 글로벌 채널로 정의한다.8<br />
<span class="math math-display">
\text{Class}(k) = \begin{cases} \text{Global}, &amp; \text{if } \prod_{t=1}^{L} \bar{A}_{t, k} &gt; \theta \\ \text{Local}, &amp; \text{otherwise} \end{cases}
</span><br />
임계값 <span class="math math-inline">\theta</span>는 경험적으로 설정되며, 연구에 따르면 <span class="math math-inline">10^{-4}</span>에서 <span class="math math-inline">10^{-2}</span> 사이의 값에서 최적의 성능을 보인다. 이보다 붕괴율이 낮은(값이 작은) 채널은 이미 정보를 빠르게 잊도록 설계된 로컬 채널이므로 별도의 조치를 취하지 않는다.</p>
<h3>4.3  2단계: 토큰 필터링(Token Filtering)을 통한 수용 영역 확장</h3>
<p>식별된 글로벌 채널에 대해서는 훈련 길이를 초과하는 시퀀스가 들어올 때, 모든 정보를 무차별적으로 저장하는 대신 **‘중요한 정보’**만을 선별하여 상태를 업데이트한다. 이를 통해 한정된 메모리 용량을 효율적으로 사용하여 실질적인 수용 영역을 확장한다.</p>
<p>필터링은 다음과 같은 수정된 상태 업데이트 규칙을 따른다.<br />
<span class="math math-display">
h_t = \begin{cases} \bar{A}_t h_{t-1} + \bar{B}_t x_t, &amp; \text{if Score}(x_t) &gt; \tau \\ h_{t-1}, &amp; \text{otherwise} \end{cases}
</span><br />
즉, 토큰 <span class="math math-inline">x_t</span>의 중요도 점수(Score)가 기준치 <span class="math math-inline">\tau</span>를 넘지 못하면, 해당 토큰은 글로벌 채널의 상태 업데이트에 반영되지 않고 건너뛰어지며(Skipped), 이전 상태 <span class="math math-inline">h_{t-1}</span>가 그대로 유지된다. 이는 불필요한 노이즈 정보가 장기 기억을 오염시키는 것을 방지한다.8</p>
<p>중요도 점수 산정 방식:</p>
<p>가장 일반적인 방식은 <span class="math math-inline">\Delta</span>-Guided Filtering이다. 맘바의 메커니즘 상 <span class="math math-inline">\Delta_t</span> 값은 입력에 따른 정보 유입량을 조절하는 게이트 역할을 한다. <span class="math math-inline">\Delta_t</span>가 크다는 것은 모델이 해당 시점에서 상태를 크게 업데이트하고자 한다는 의도, 즉 해당 토큰이 정보량이 많다는 것을 내포한다. 따라서 LongMamba는 별도의 학습 없이 <span class="math math-inline">\Delta_t</span>의 크기 자체를 중요도 지표로 활용한다.18</p>
<p>이 외에도 정보 엔트로피(Entropy)를 기반으로 불확실성이 높은 토큰을 중요하다고 판단하는 변형 연구들도 존재한다.19 이러한 필터링 메커니즘은 맘바 모델이 수만 토큰의 텍스트를 읽으면서도 마치 사람이 요약 노트를 작성하듯 핵심 정보만을 골라내어 글로벌 채널에 저장하게 만든다.</p>
<h3>4.4  기존 접근법(DeciMamba)과의 비교</h3>
<p>LongMamba 이전에 제안된 <strong>DeciMamba</strong> 역시 불필요한 토큰을 제거하여 연산 효율을 높이고자 했으나, 몇 가지 결정적인 차이가 있다.8</p>
<ol>
<li><strong>훈련 필요성:</strong> DeciMamba는 토큰을 선별하기 위한 별도의 ’가지치기 레이어(Pruning Layer)’를 긴 시퀀스에 대해 추가로 훈련시켜야 한다. 반면 LongMamba는 사전 학습된 모델의 내부 파라미터(<span class="math math-inline">\Delta</span>)를 그대로 활용하므로 완전한 <strong>Training-Free</strong> 방식이다.</li>
<li><strong>적용 대상:</strong> DeciMamba는 모든 채널에 대해 일괄적으로 토큰을 제거하여 시퀀스 길이 자체를 줄이는 데 초점을 맞춘다. 반면 LongMamba는 **채널별(Channel-wise)**로 접근하여, 로컬 채널은 모든 토큰을 보게 하고 글로벌 채널만 필터링하는 정교한 전략을 구사한다. 이는 로컬 문맥의 손상을 막으면서 장기 기억력만 강화하는 결과를 낳는다. 실험 결과 LongMamba는 DeciMamba 대비 RULER 벤치마크 등에서 월등히 높은 정확도를 기록했다.8</li>
</ol>
<h2>5.  종합 성능 평가 및 벤치마크 분석</h2>
<p>MambaExtend와 LongMamba의 유효성은 다양한 벤치마크를 통해 검증되었다. 특히 긴 문맥 처리 능력을 평가하는 ‘Needle In A Haystack’ (Passkey Retrieval) 테스트와 실제 언어 이해력을 측정하는 LongBench, RULER 벤치마크에서의 성과가 두드러진다.</p>
<h3>5.1  패스키 검색 (Passkey Retrieval) 성능 분석</h3>
<p>패스키 검색은 수만 토큰의 무의미한 텍스트(Haystack) 사이에 숨겨진 특정 숫자 조합(Needle)을 찾아내는 과제로, 모델의 극한 장기 기억 능력을 평가하는 표준 지표다.</p>
<ul>
<li><strong>Vanilla Mamba:</strong> 시퀀스 길이가 훈련 길이(2k)를 넘어서는 순간 성능이 0%로 급락한다. 이는 새로운 정보가 이전 정보를 덮어쓰는 맘바의 구조적 한계를 적나라하게 보여준다.</li>
<li><strong>LongMamba:</strong> 놀랍게도 16k, 32k 길이의 시퀀스에서도 <strong>100%에 가까운 검색 정확도</strong>를 유지한다. 특히 32k 토큰 길이 실험에서 바닐라 맘바가 0%를 기록할 때 LongMamba는 73%~100% 수준의 정확도를 회복했다.8 이는 필터링 메커니즘이 ’패스키’와 같이 정보량이 높은 토큰을 정확히 식별하여 글로벌 채널에 보존했음을 입증한다.</li>
<li><strong>MambaExtend:</strong> MambaExtend 또한 64k 토큰까지 확장된 문맥에서 높은 검색 성공률을 보였다. 이는 시간 해상도를 조절하는 방식 역시 정보의 휘발을 막는 데 유효함을 시사한다.12</li>
</ul>
<table><thead><tr><th><strong>모델</strong></th><th><strong>2k (훈련 길이)</strong></th><th><strong>8k</strong></th><th><strong>16k</strong></th><th><strong>32k</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td>Vanilla Mamba</td><td>100%</td><td>&lt; 10%</td><td>0%</td><td>0%</td><td>훈련 길이 초과 시 즉시 붕괴</td></tr>
<tr><td><strong>LongMamba</strong></td><td>100%</td><td>100%</td><td><strong>99.8%</strong></td><td><strong>73% ~ 100%</strong></td><td>글로벌 채널 필터링 효과 입증</td></tr>
<tr><td><strong>MambaExtend</strong></td><td>100%</td><td>100%</td><td>98.5%</td><td>95%</td><td>이산화 보정을 통한 안정성 확보</td></tr>
</tbody></table>
<h3>5.2  RULER 및 LongBench 벤치마크</h3>
<p>단순 검색을 넘어선 종합적인 언어 이해 능력을 평가하는 RULER 및 LongBench 벤치마크에서도 두 방법론은 탁월한 성과를 거두었다.</p>
<ul>
<li><strong>RULER 벤치마크:</strong> LongMamba는 바닐라 모델 대비 평균 <strong>4.8배</strong>의 정확도 향상을 기록했으며, 기존의 DeciMamba 대비 <strong>2.6배</strong> 높은 성능을 보였다.8 이는 단순히 정보를 기억하는 것을 넘어, 문맥을 이해하고 추론하는 능력까지 확장되었음을 의미한다.</li>
<li><strong>언어 모델링 (Perplexity):</strong> MambaExtend는 PG-19와 같은 긴 호흡의 문학 텍스트 데이터셋에서 특히 강점을 보였다. 64k 길이까지 확장했을 때 펄플렉서티 증가를 최소화하며 문맥의 흐름을 놓치지 않았다. 이는 MambaExtend가 문장 전체의 리듬과 구조를 유지하는 데 유리한 ‘거시적 조절’ 방식을 택했기 때문이다.13</li>
</ul>
<h3>5.3  효율성 비교</h3>
<p>두 방법론 모두 ’효율성’이라는 맘바의 정체성을 훼손하지 않는다.</p>
<ul>
<li><strong>메모리 및 속도:</strong> MambaExtend는 추론 시 추가적인 연산 오버헤드가 사실상 ’제로’에 가깝다. LongMamba는 토큰별 중요도 계산이 필요하지만, 이는 단순한 산술 연산이므로 전체 지연 시간(Latency) 증가는 <strong>4% 미만</strong>에 불과하다.16 이는 트랜스포머의 어텐션 연산이 길이에 따라 기하급수적으로 느려지는 것과 대조적이다.</li>
</ul>
<h2>6.  LAMB 및 최신 하이브리드 접근법: 미래를 향한 제언</h2>
<p>MambaExtend와 LongMamba가 제시한 ’훈련 없는 확장’의 패러다임은 최근 **LAMB (Long-context Attention-guided Mamba)**와 같은 하이브리드 연구로 진화하고 있다.18</p>
<p>LAMB는 LongMamba의 토큰 필터링 아이디어를 계승하되, <span class="math math-inline">\Delta</span> 값에만 의존하던 중요도 판단 기준을 <strong>어텐션(Attention)</strong> 메커니즘으로 고도화했다. 맘바와 트랜스포머를 결합한 하이브리드 모델이나, 맘바 내부의 가상 어텐션 스코어를 근사하여 사용하는 방식을 통해, 모델은 더욱 정교하게 ‘어떤 정보를 저장하고 어떤 정보를 버릴지’ 결정할 수 있게 되었다. LAMB는 LongMamba 대비 최대 **30.35%**의 추가적인 성능 향상을 보고하고 있어, 향후 맘바의 컨텍스트 확장이 단순한 수치적 보정을 넘어 ‘지능적 메모리 관리’ 시스템으로 발전할 것임을 예고한다.</p>
<h2>7.  결론</h2>
<p>MambaExtend와 LongMamba는 “순환 모델은 긴 문맥을 기억할 수 없다“는 통념을 깨고, 훈련 데이터의 한계를 뛰어넘는 SSM의 잠재력을 증명해 냈다. MambaExtend는 수학적 이산화 과정의 재해석을 통해 모델의 시간적 인지 범위를 확장했고, LongMamba는 모델 내부의 채널별 기능 분화를 규명하여 구조적인 메모리 관리 해법을 제시했다.</p>
<p>이 두 연구는 막대한 비용이 드는 재학습(Retraining) 없이도 기존 모델을 재활용하여 긴 문맥 처리가 가능하다는 점에서 경제적, 환경적 가치가 매우 크다. 특히, 맘바의 선형 복잡도라는 강력한 이점을 유지하면서 트랜스포머의 전유물이었던 장기 기억 능력을 확보했다는 점은, 향후 엣지 디바이스나 실시간 처리 시스템에서 맘바가 주류 아키텍처로 자리 잡을 수 있는 강력한 근거가 된다. 앞으로의 연구는 이 두 가지 접근법의 장점, 즉 MambaExtend의 거시적 안정성과 LongMamba의 미시적 정보 보존 능력을 통합하여, 무한한 길이의 시퀀스에서도 인간처럼 효율적으로 정보를 습득하고 기억하는 ‘영구적 문맥(Infinite Context)’ 모델을 향해 나아가야 할 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Mamba for Dummies: Efficient Linear-Time LLMs Explained - Michiel Horstman - Medium, https://michielh.medium.com/mamba-for-dummies-linear-time-llms-explained-0d4b51efcf9f</li>
<li>Mamba (deep learning architecture) - Wikipedia, https://en.wikipedia.org/wiki/Mamba_(deep_learning_architecture)</li>
<li>arXiv:2408.15496v4 [cs.CL] 1 Jan 2025, https://arxiv.org/pdf/2408.15496</li>
<li>Exploring the Limitations of Mamba in COPY and CoT Reasoning - arXiv, https://arxiv.org/html/2410.03810v2</li>
<li>What Is A Mamba Model? | IBM, https://www.ibm.com/think/topics/mamba-model</li>
<li>Mamba Explained - The Gradient, https://thegradient.pub/mamba-explained/</li>
<li>Mamba Modulation On the Length Generalization of Mamba - arXiv, https://arxiv.org/html/2509.19633v1</li>
<li>LongMamba: Enhancing Mamba’s Long Context Capabilities via Training-Free Receptive Field Enlargement - arXiv, https://arxiv.org/html/2504.16053v1</li>
<li>LongMamba: Enhancing Mamba’s Long-Context Capabilities via Training-Free Receptive Field Enlargement | OpenReview, https://openreview.net/forum?id=fMbLszVO1H</li>
<li>[D] What Are the Fundamental Drawbacks of Mamba Compared to Transformers? - Reddit, https://www.reddit.com/r/MachineLearning/comments/1ayog60/d_what_are_the_fundamental_drawbacks_of_mamba/</li>
<li>MambaExtend: A Training-Free Approach to Improve Long Context Extension of Mamba, https://iclr.cc/media/iclr-2025/Slides/29980.pdf</li>
<li>ICLR Poster MambaExtend: A Training-Free Approach to Improve Long Context Extension of Mamba, https://iclr.cc/virtual/2025/poster/29980</li>
<li>Mamba Modulation On the Length Generalization of Mamba - arXiv, https://arxiv.org/html/2509.19633v3</li>
<li>MambaExtend: A Training-Free Approach to Improve Long Context Extension of Mamba, https://openreview.net/forum?id=LgzRo1RpLS</li>
<li>Track: Poster Session 6 - ICLR 2026, https://iclr.cc/virtual/2025/session/31976</li>
<li>LongMamba: Enhancing Mamba’s Long Context Capabilities via Training-Free Receptive Field Enlargement, https://lemonandrabbit.github.io/</li>
<li>Stuffed Mamba: Oversized States Lead to the Inability to Forget - arXiv, https://arxiv.org/html/2410.07145v3</li>
<li>LAMB: A Training-Free Method to Enhance the Long-Context Understanding of SSMs via Attention-Guided Token Filtering - ACL Anthology, https://aclanthology.org/2025.acl-short.96.pdf</li>
<li>MambaMIL+: Modeling Long-Term Contextual Patterns for Gigapixel Whole Slide Image - arXiv, https://arxiv.org/html/2512.17726v1</li>
<li>jzhang38/LongMamba: Some preliminary explorations of Mamba’s context scaling. - GitHub, https://github.com/jzhang38/LongMamba</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>