<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.1 선형 시간 불변(LTI) 시스템의 한계와 입력 의존적(Input-Dependent) 파라미터</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.1 선형 시간 불변(LTI) 시스템의 한계와 입력 의존적(Input-Dependent) 파라미터</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>3.1 선형 시간 불변(LTI) 시스템의 한계와 입력 의존적(Input-Dependent) 파라미터</span></nav>
                </div>
            </header>
            <article>
                <h1>3.1 선형 시간 불변(LTI) 시스템의 한계와 입력 의존적(Input-Dependent) 파라미터</h1>
<h3>0.1  서론: 시퀀스 모델링의 패러다임 전환과 구조적 딜레마</h3>
<p>현대 인공지능 연구, 특히 자연어 처리(NLP)와 복합 시퀀스 모델링(Sequence Modeling) 분야에서 가장 두드러진 화두는 ’효율성’과 ‘표현력’ 사이의 줄타기이다. 지난 수년간 트랜스포머(Transformer) 아키텍처는 어텐션(Attention) 메커니즘을 통해 입력 데이터 간의 장거리 의존성(Long-range Dependency)을 포착하는 데 탁월한 성능을 보이며 사실상의 표준(De Facto Standard)으로 자리 잡았다. 그러나 트랜스포머의 어텐션 연산은 시퀀스 길이 <span class="math math-inline">L</span>에 대해 <span class="math math-inline">O(L^2)</span>의 2차 시간 복잡도와 메모리 복잡도를 요구한다는 치명적인 구조적 한계를 내재하고 있다. 이는 문맥(Context)의 길이가 길어질수록 연산 비용이 기하급수적으로 증가함을 의미하며, 결과적으로 긴 문서 요약, 유전체(DNA) 분석, 고해상도 오디오 처리 등 ’롱 컨텍스트(Long Context)’가 필수적인 영역에서의 확장을 저해하는 주된 병목으로 작용해왔다.1</p>
<p>이러한 배경 속에서 선형 복잡도(<span class="math math-inline">O(L)</span>)를 가지면서도 긴 시퀀스를 효과적으로 처리할 수 있는 대안으로 구조적 상태 공간 모델(Structured State Space Models, SSM)이 재조명되었다. 특히 S4(Structured State Space Sequence) 모델로 대표되는 초기 SSM들은 제어 공학의 연속 시간(Continuous-time) 시스템 이론을 딥러닝에 접목하여, 학습 시에는 병렬화가 가능한 합성곱(Convolution) 연산을, 추론 시에는 효율적인 재귀(Recurrent) 연산을 수행하는 ’이중성(Dual Nature)’을 통해 계산 효율성을 극대화했다.3 그러나 이들 초기 모델은 오디오 파형과 같은 연속적 신호 처리에서는 놀라운 성과를 거두었음에도 불구하고, 텍스트와 같은 이산적(Discrete) 데이터 처리에서는 트랜스포머에 비해 현저히 낮은 성능을 보였다.</p>
<p>본 장에서는 이러한 성능 격차의 근본 원인이 SSM의 기반이 되는 ‘선형 시간 불변(Linear Time Invariant, LTI)’ 시스템의 경직성에 있음을 이론적으로 규명한다. LTI 시스템이 제공하는 계산적 이점이 역설적으로 데이터의 내용(Content)에 따른 동적 추론을 방해하는 족쇄가 됨을 밝히고, 이를 극복하기 위해 제안된 Mamba 아키텍처의 핵심인 ’입력 의존적 파라미터(Input-Dependent Parameters)’와 ’선택 메커니즘(Selection Mechanism)’의 원리를 심층 분석한다. 나아가, LTI 시스템의 합성곱 등가성이 깨짐에 따라 발생하는 계산적 난제를 해결하기 위해 도입된 하드웨어 인식 알고리즘(Hardware-Aware Algorithm)과 병렬 스캔(Parallel Scan) 기법을 상세히 기술함으로써, 차세대 시퀀스 모델이 나아가야 할 방향성을 제시한다.</p>
<h3>0.2  선형 시간 불변(LTI) 시스템의 이론적 구조와 결정론적 한계</h3>
<h4>0.2.1  LTI 시스템의 수학적 정의와 상태 공간의 정적 특성</h4>
<p>상태 공간 모델(SSM)의 근간을 이루는 선형 시간 불변(LTI) 시스템은 시스템의 거동이 선형성(Linearity)과 시불변성(Time-Invariance)이라는 두 가지 강력한 제약 조건을 만족하는 시스템을 의미한다.5 물리학과 제어 이론에서 출발한 이 개념은 복잡한 동적 시스템을 해석 가능한 형태로 단순화하는 데 지대한 공헌을 했다. 연속 시간(Continuous-time) <span class="math math-inline">t</span>에서의 단일 입력 <span class="math math-inline">x(t)</span>와 단일 출력 <span class="math math-inline">y(t)</span>를 갖는 LTI 시스템은 잠재 상태(Latent State) <span class="math math-inline">h(t) \in \mathbb{R}^N</span>를 매개로 하여 다음과 같은 1차 상미분방정식(ODE)으로 기술된다.<br />
<span class="math math-display">
h&#39;(t) = \mathbf{A}h(t) + \mathbf{B}x(t)
</span></p>
<p><span class="math math-display">
y(t) = \mathbf{C}h(t)
</span></p>
<p>여기서 <span class="math math-inline">\mathbf{A} \in \mathbb{R}^{N \times N}</span>는 상태 전이 행렬(State Transition Matrix), <span class="math math-inline">\mathbf{B} \in \mathbb{R}^{N \times 1}</span>는 입력 행렬, <span class="math math-inline">\mathbf{C} \in \mathbb{R}^{1 \times N}</span>는 출력 행렬을 나타낸다. LTI 시스템의 핵심은 이 시스템 행렬 <span class="math math-inline">\mathbf{A}, \mathbf{B}, \mathbf{C}</span>가 시간 <span class="math math-inline">t</span>에 의존하지 않는 **고정된 상수(Constant)**라는 점이다.6</p>
<p>이러한 시불변성(Time-Invariance)은 시스템이 언제 입력을 받든 동일한 방식으로 반응함을 보장한다. 즉, 입력 신호 <span class="math math-inline">x(t)</span>가 시간적으로 <span class="math math-inline">\tau</span>만큼 이동(Shift)하여 <span class="math math-inline">x(t-\tau)</span>가 되더라도, 출력 신호는 그저 <span class="math math-inline">y(t-\tau)</span>로 동일하게 이동할 뿐, 신호의 형태나 시스템의 반응 특성 자체는 변하지 않는다. 이는 시스템의 임펄스 응답(Impulse Response)이 고정되어 있음을 의미하며, 전체 시퀀스에 걸쳐 균일한 동역학(Dynamics)이 적용됨을 시사한다.</p>
<h4>0.2.2  합성곱 정리(Convolution Theorem)와 효율성의 역설</h4>
<p>LTI 시스템이 딥러닝, 특히 긴 시퀀스 처리에 매력적인 대안으로 부상한 가장 큰 이유는 재귀적 연산과 합성곱 연산 간의 등가성 때문이다. 고정된 파라미터를 갖는 선형 시스템의 출력은 입력 신호와 시스템의 임펄스 응답 커널 <span class="math math-inline">K</span> 간의 합성곱(Convolution)으로 표현될 수 있다.5<br />
<span class="math math-display">
y(t) = (x * K)(t) = \int_{-\infty}^{\infty} x(\tau)K(t-\tau) d\tau
</span><br />
이산 시간(Discrete-time)으로 변환된 SSM에서도 이 성질은 유지된다. 입력 시퀀스 <span class="math math-inline">x = (x_0, x_1, \dots, x_{L-1})</span>에 대해, 전체 출력 <span class="math math-inline">y</span>는 전역적인 합성곱 필터 <span class="math math-inline">\bar{K}</span>와의 연산을 통해 한 번에 계산될 수 있다.<br />
<span class="math math-display">
y = x * \bar{K}
</span><br />
이때 필터 <span class="math math-inline">\bar{K}</span>는 시스템 행렬 <span class="math math-inline">\bar{\mathbf{A}}, \bar{\mathbf{B}}, \mathbf{C}</span>로부터 유도되는 값(<span class="math math-inline">\bar{K} = (\mathbf{C}\bar{\mathbf{B}}, \mathbf{C}\bar{\mathbf{A}}\bar{\mathbf{B}}, \dots, \mathbf{C}\bar{\mathbf{A}}^{L-1}\bar{\mathbf{B}})</span>)으로, 입력 데이터와 무관하게 미리 계산할 수 있다. 이는 고속 푸리에 변환(FFT)을 활용할 경우 연산 복잡도를 <span class="math math-inline">O(L^2)</span>에서 <span class="math math-inline">O(L \log L)</span>로 획기적으로 낮출 수 있음을 의미한다.9 S4 모델은 이 특성을 활용하여 GPU에서 고도로 병렬화된 학습을 가능하게 했으며, RNN이 가진 순차적 처리의 병목을 해소했다.</p>
<p>그러나 이러한 <strong>효율성의 원천인 ’고정된 커널’은 동시에 ’표현력의 한계’라는 치명적인 역설을 낳는다.</strong> 모든 입력 토큰에 대해 동일한 필터가 적용된다는 것은, 모델이 입력된 정보의 중요도를 동적으로 판단하거나 문맥에 따라 처리 방식을 달리할 수 없음을 의미하기 때문이다.11</p>
<h4>0.2.3  스펙트럼 관점에서의 한계: 저역 통과 필터의 덫</h4>
<p>LTI 시스템의 한계를 주파수 도메인(Frequency Domain)에서 분석하면 그 경직성이 더욱 명확해진다. LTI 시스템은 입력 신호의 특정 주파수 성분을 증폭하거나 감쇠시키는 필터(Filter)로 작동한다. 일반적인 SSM의 초기화 방식(예: HiPPO)은 과거의 정보를 오랫동안 기억하기 위해 상태 전이 행렬 <span class="math math-inline">\mathbf{A}</span>를 특정 구조로 설정하는데, 이는 주로 저주파 성분(장기 추세)을 보존하는 방향으로 작용한다.</p>
<p>문제는 텍스트 데이터와 같은 이산 정보가 매끄러운(Smooth) 신호가 아니라는 점이다. 텍스트는 불연속적이고 급격한 의미 변화를 포함하며, 특정 토큰(예: ‘not’, ‘however’)은 전체 문맥을 뒤집는 고주파적 성격을 띤다. LTI 기반의 모델은 이러한 급격한 정보의 변화를 고정된 대역폭의 필터로 뭉개버리는 경향이 있으며, 이는 문맥의 세밀한 뉘앙스를 포착해야 하는 언어 모델링에서 치명적인 성능 저하로 이어진다.1</p>
<h3>0.3  내용 기반 추론(Content-Based Reasoning)의 실패와 이산 데이터의 특수성</h3>
<h4>0.3.1  내용 기반 추론의 정의와 필요성</h4>
<p>’내용 기반 추론(Content-Based Reasoning)’이란 모델이 입력된 데이터의 값(Value)과 내용(Content)을 근거로 다음에 취할 행동이나 집중해야 할 정보를 결정하는 능력을 말한다.6 이는 인간이 글을 읽을 때 접속사나 관사 같은 기능어(Functional Words)는 가볍게 훑고 지나가지만, 핵심 키워드나 인물 이름에는 주의를 기울여 기억하는 인지 과정과 유사하다.</p>
<p>트랜스포머의 셀프 어텐션(Self-Attention) 메커니즘은 쿼리(Query)와 키(Key)의 내적을 통해 입력 토큰 간의 유사도를 계산하고, 이를 바탕으로 가중치를 동적으로 할당함으로써 내용 기반 추론을 완벽하게 수행한다. 반면, LTI 시스템은 입력 내용이 무엇이든 간에 미리 정해진 감쇠율과 전이 규칙에 따라 정보를 처리한다. 즉, LTI 모델은 **’입력을 본다(See)’기보다는 ‘입력을 흘려보낸다(Flow)’**는 표현이 더 적합하다.</p>
<h4>0.3.2  합성 과제(Synthetic Tasks)를 통한 실패 양상 분석</h4>
<p>Mamba 연구진은 LTI 모델의 한계를 명확히 입증하기 위해 두 가지 핵심적인 합성 과제를 제시하고, 기존 모델(S4, H3 등)이 이에 실패함을 보여주었다.14</p>
<ol>
<li>선택적 복사(Selective Copying) 과제:</li>
</ol>
<p>이 과제는 입력 시퀀스 내에 무작위 간격으로 배치된 ’유의미한 토큰(Target)’과 그 사이를 채우는 ’노이즈 토큰(Noise)’을 구분하고, 나중에 유의미한 토큰들만을 순서대로 출력하는 능력을 테스트한다.</p>
<ul>
<li><strong>LTI의 실패 원인:</strong> LTI 모델의 <span class="math math-inline">\mathbf{B}</span> (입력 가중치)와 <span class="math math-inline">\mathbf{C}</span> (출력 가중치)는 시간 불변이므로, 특정 시점의 입력이 노이즈인지 타겟인지에 따라 가중치를 조절할 수 없다. 또한 상태 전이 행렬 <span class="math math-inline">\bar{\mathbf{A}}</span>가 고정되어 있어, 타겟 토큰을 보았을 때만 상태를 업데이트하고 노이즈를 볼 때는 상태를 유지(Skip)하는 식의 ‘게이팅(Gating)’ 동작이 불가능하다. 결과적으로 LTI 모델은 모든 정보를 균일하게 혼합(Mix)하여 기억하려다 용량 초과로 실패하거나, 단순히 최근 정보만을 기억하는 경향을 보인다.3</li>
</ul>
<ol start="2">
<li>유도 헤드(Induction Heads) 과제:</li>
</ol>
<p>유도 헤드는 LLM의 인컨텍스트 러닝(In-Context Learning) 능력의 기반이 되는 메커니즘으로, “[A]… [A] -&gt;“와 같은 패턴 복사를 수행한다. 즉, 과거에 [A] 뒤에가 왔다는 사실을 기억하고, 다시 [A]가 등장했을 때 문맥을 조회하여를 예측해야 한다.</p>
<ul>
<li><strong>LTI의 실패 원인:</strong> 이 작업을 수행하려면 모델은 현재 입력이 [A]임을 인식하고, 과거의 기억 저장소에서 [A]가 등장했던 시점을 찾아 그 뒤의를 인출(Recall)해야 한다. 이는 전적으로 입력 내용([A])에 의존적인 상호작용이다. LTI 시스템은 시간의 흐름에 따른 고정된 감쇠(Decay)만을 모델링하므로, 내용에 기반한 연관 검색(Associative Recall)을 수행할 수 없다.15</li>
</ul>
<h4>0.3.3  이산적 데이터(Discrete Modality)와 연속적 데이터의 간극</h4>
<p>오디오나 비디오와 같은 연속 신호 데이터는 인접한 샘플 간의 상관관계가 높고 변화가 부드럽다. 이러한 데이터에서는 LTI 시스템의 고정된 필터링이 노이즈 제거와 특징 추출에 효과적일 수 있다. 그러나 텍스트, DNA 염기서열, 프로그래밍 코드와 같은 이산 데이터는 토큰 하나하나가 독립적이고 급격한 의미 변화를 내포한다. 예를 들어, 문장 중간의 마침표(.) 하나는 이전까지의 문맥을 종결시키고 새로운 문맥을 시작하라는 강력한 신호이다. LTI 시스템은 이러한 이산적 트리거(Discrete Trigger)에 반응하여 상태를 리셋(Reset)하거나 특정 정보를 강하게 래치(Latch)하는 유연성이 부족하다.1 이는 LTI 모델이 언어 모델링에서 트랜스포머에 뒤처질 수밖에 없었던 근본적인 물리적 한계이다.</p>
<h3>0.4  Mamba의 해법: 입력 의존적 파라미터와 선택 메커니즘</h3>
<h4>0.4.1  선형 시변(LTV) 시스템으로의 진화</h4>
<p>Mamba 아키텍처는 LTI의 한계를 극복하기 위해 **“시스템의 파라미터를 입력의 함수로 만든다”**는 직관적이면서도 강력한 아이디어를 도입했다. 이를 통해 시스템은 선형 시간 불변(LTI)에서 <strong>선형 시변(Linear Time-Varying, LTV)</strong> 시스템으로 그 성격이 근본적으로 변화한다.6</p>
<p>기존 SSM에서 <span class="math math-inline">(\mathbf{\Delta}, \mathbf{B}, \mathbf{C})</span>가 모든 시점 <span class="math math-inline">t</span>에 대해 동일한 상수였다면, Mamba에서는 이들이 입력 토큰 <span class="math math-inline">x_t</span>에 따라 매 시점 변화하는 텐서가 된다.<br />
<span class="math math-display">
\mathbf{B}_t = s_B(x_t)
</span></p>
<p><span class="math math-display">
\mathbf{C}_t = s_C(x_t)
</span></p>
<p><span class="math math-display">
\mathbf{\Delta}_t = s_\Delta(x_t)
</span></p>
<p>여기서 <span class="math math-inline">s_B, s_C, s_\Delta</span>는 입력 <span class="math math-inline">x_t</span>로부터 파라미터를 생성하는 학습 가능한 투영 레이어(Projection Layer)이다. 이 단순한 변화가 가져오는 파급력은 실로 막대하다. 모델은 이제 입력되는 토큰의 내용을 보고, 이 정보를 상태 공간(Hidden State)에 얼마나 강하게 입력할지(<span class="math math-inline">\mathbf{B}_t</span>), 현재 상태를 얼마나 출력에 반영할지(<span class="math math-inline">\mathbf{C}_t</span>), 그리고 가장 중요하게는 과거의 기억을 얼마나 유지하거나 망각할지(<span class="math math-inline">\mathbf{\Delta}_t</span>)를 토큰 단위로 미세 조정할 수 있게 된다.18</p>
<h4>0.4.2  선택 메커니즘(Selection Mechanism)의 수학적 정식화</h4>
<p>선택 메커니즘의 구체적인 구현과 차원(Dimension)의 변화를 상세히 살펴보자. 배치 크기를 <span class="math math-inline">B</span>, 시퀀스 길이를 <span class="math math-inline">L</span>, 입력 채널 차원을 <span class="math math-inline">D</span>, 잠재 상태 차원(State Expansion Factor)을 <span class="math math-inline">N</span>이라고 가정한다.</p>
<ol>
<li>파라미터 생성 (<span class="math math-inline">s_B, s_C</span>):</li>
</ol>
<p>입력 <span class="math math-inline">x \in \mathbb{R}^{B \times L \times D}</span>는 선형 변환(Linear Layer)을 통해 <span class="math math-inline">\mathbf{B}</span>와 <span class="math math-inline">\mathbf{C}</span>를 생성한다. 기존 SSM에서 <span class="math math-inline">\mathbf{B}, \mathbf{C}</span>가 시간 축이 없는 <span class="math math-inline">\mathbb{R}^{D \times N}</span> 형태의 고정 행렬이었던 것과 달리, Mamba의 <span class="math math-inline">\mathbf{B}_t, \mathbf{C}_t</span>는 각 토큰마다 <span class="math math-inline">N</span> 차원의 벡터를 가지며, 전체 시퀀스에 대해 <span class="math math-inline">\mathbb{R}^{B \times L \times N}</span>의 형상을 띤다.20 이는 모델이 각 시점마다 고유한 입력/출력 필터를 가지게 됨을 의미한다.<br />
<span class="math math-display">
   s_B(x) = \text{Linear}_N(x), \quad s_C(x) = \text{Linear}_N(x)
</span><br />
이산화 간격 <span class="math math-inline">\mathbf{\Delta}_t</span>와 게이팅(Gating):</p>
<p>가장 핵심적인 파라미터는 시간 간격(Step Size)을 나타내는 <span class="math math-inline">\mathbf{\Delta}</span>이다. Mamba는 <span class="math math-inline">\mathbf{\Delta}</span>를 입력 의존적으로 만듦으로써 RNN의 ‘게이팅’ 메커니즘을 SSM에 통합시켰다. <span class="math math-inline">\mathbf{\Delta}_t</span>는 다음과 같이 계산된다.1</p>
<p><span class="math math-display">\mathbf{\Delta}_t = \text{Softplus}(\text{Parameter} + \text{Broadcast}_D(\text{Linear}_1(x_t)))</span></p>
<ul>
<li><strong>Linear<span class="math math-inline">_1(x_t)</span>:</strong> 입력을 1차원 스칼라로 투영하여 해당 토큰의 ‘중요도’ 또는 ’속도’를 판단한다.</li>
<li><strong>Broadcast<span class="math math-inline">_D</span>:</strong> 이를 <span class="math math-inline">D</span> 차원으로 확장하여 모든 채널에 적용한다.</li>
<li><strong>Softplus:</strong> <span class="math math-inline">\mathbf{\Delta}</span>는 시간 간격으로서 반드시 양수(Positive)여야 하므로, ReLU의 부드러운 근사 함수인 Softplus(<span class="math math-inline">\log(1+e^x)</span>)를 사용하여 양수성을 보장한다.</li>
</ul>
<p>이 <span class="math math-inline">\mathbf{\Delta}_t</span>는 이산화 수식 <span class="math math-inline">\bar{\mathbf{A}}_t = \exp(\mathbf{\Delta}_t \mathbf{A})</span>를 통해 상태 전이 행렬 <span class="math math-inline">\bar{\mathbf{A}}_t</span>에 직접적인 영향을 미친다.</p>
<ul>
<li><strong><span class="math math-inline">\mathbf{\Delta}_t \to \infty</span> (큰 값):</strong> <span class="math math-inline">\bar{\mathbf{A}}_t \to 0</span>에 가까워지며(고유값이 음수일 때), 이는 현재 입력 <span class="math math-inline">x_t</span>에 집중(Focus)하고 과거 상태 <span class="math math-inline">h_{t-1}</span>을 빠르게 망각(Reset)하는 효과를 낸다.</li>
<li><strong><span class="math math-inline">\mathbf{\Delta}_t \to 0</span> (작은 값):</strong> <span class="math math-inline">\bar{\mathbf{A}}_t \to I</span> (Identity)에 가까워지며, 현재 입력을 무시하고 이전 상태를 그대로 유지(Persist)하는 효과를 낸다.</li>
</ul>
<p>이는 LSTM의 입력 게이트(Input Gate) 및 망각 게이트(Forget Gate)와 수학적으로 유사한 역할을 수행하며, Mamba가 불필요한 정보를 필터링하고 중요한 정보를 장기간 보존할 수 있게 하는 핵심 기제이다.6</p>
<h4>3.1.4.3 차원 확장과 정보의 흐름 제어</h4>
<p>기존 LTI SSM은 채널 간의 상호작용 없이 각 채널을 독립적으로 처리(S4D 등)하거나 고정된 믹싱을 수행했다. Mamba의 선택 메커니즘은 파라미터가 <span class="math math-inline">(B, L, N)</span> 차원을 가짐으로써, 배치 내의 각 샘플(Sequence)마다, 그리고 시퀀스 내의 각 토큰(Time)마다 서로 다른 동역학을 적용한다.</p>
<p>특히 <span class="math math-inline">\mathbf{\Delta}_t</span>가 <span class="math math-inline">(B, L, D)</span> 차원을 가짐으로써, 모델은 각 채널(Feature)별로 정보의 흐름 속도를 다르게 조절할 수 있다. 어떤 채널은 문법적 구조를 파악하기 위해 짧은 문맥을 유지하고, 어떤 채널은 주제어를 추적하기 위해 긴 문맥을 유지하는 식의 다층적 시간 척도(Multi-scale Temporal Resolution) 학습이 가능해진다.</p>
<h3>3.1.5 계산적 난제: 합성곱의 상실과 하드웨어 인식 알고리즘</h3>
<h4>3.1.5.1 합성곱 등가성의 붕괴와 재귀의 부활</h4>
<p>선택 메커니즘을 도입하여 시스템을 시변(LTV) 시스템으로 전환한 대가는 ’계산 효율성’의 상실이었다. <span class="math math-inline">\mathbf{A}, \mathbf{B}</span>가 시간에 따라 변하게 되면서(<span class="math math-inline">\bar{\mathbf{A}}_t, \bar{\mathbf{B}}_t</span>), 더 이상 전체 시스템을 단일 커널 <span class="math math-inline">\bar{K}</span>와의 합성곱 <span class="math math-inline">y = x * \bar{K}</span>로 표현할 수 없게 된다. 이는 곧 <span class="math math-inline">O(L \log L)</span>의 효율적인 FFT 기반 학습이 불가능해짐을 의미한다.11</p>
<p>이제 모델은 매 시점 <span class="math math-inline">t</span>마다 달라지는 전이 행렬을 적용하여 순차적으로 상태를 업데이트해야 하는 상황에 직면한다.<br />
<span class="math math-display">
h_t = \bar{\mathbf{A}}_t h_{t-1} + \bar{\mathbf{B}}_t x_t
</span><br />
나이브(Naive)한 구현으로 이를 수행할 경우, GPU와 같은 병렬 가속기에서 루프(Loop)를 돌려야 하므로 <span class="math math-inline">O(L)</span>의 선형 시간이 걸리지만, 병렬성을 활용하지 못해 실제 수행 시간은 매우 느려진다. 이는 트랜스포머의 어텐션 병렬화에 익숙해진 현대 딥러닝 환경에서 수용하기 어려운 퇴보일 수 있다.</p>
<h4>3.1.5.2 병렬 스캔(Parallel Scan) 알고리즘: 순차성의 병렬화</h4>
<p>이 딜레마를 해결하기 위해 Mamba는 <strong>병렬 스캔(Parallel Scan)</strong>, 또는 <strong>접두사 합(Prefix Sum)</strong> 알고리즘을 도입하여 재귀 연산의 병렬화를 달성했다.26</p>
<p>스캔 알고리즘은 결합법칙(Associativity)이 성립하는 연산 <span class="math math-inline">\circ</span>에 대해, 시퀀스 <span class="math math-inline">a_1, a_2, \dots, a_n</span>의 누적 연산 결과 <span class="math math-inline">s_k = a_1 \circ a_2 \circ \dots \circ a_k</span>를 병렬로 계산하는 기법이다. 선형 재귀 식 <span class="math math-inline">h_t = \bar{\mathbf{A}}_t h_{t-1} + \bar{\mathbf{B}}_t x_t</span>는 행렬 곱셈과 덧셈으로 이루어져 있으며, 이는 결합법칙을 만족한다.</p>
<p>구체적으로, 상태 전이 연산을 하나의 연산자(Operator)로 정의하면, 시간 <span class="math math-inline">i</span>에서 <span class="math math-inline">j</span>까지의 누적 전이 효과를 미리 병렬로 계산할 수 있다. 예를 들어 <span class="math math-inline">h_4</span>를 계산하기 위해 <span class="math math-inline">h_1 \to h_2 \to h_3 \to h_4</span>를 순서대로 기다릴 필요 없이, <span class="math math-inline">(h_1 \to h_2)</span>와 <span class="math math-inline">(h_3 \to h_4)</span>를 동시에 계산하고 이를 합치는(Merge) 방식(Up-sweep &amp; Down-sweep)을 사용한다. 이를 통해 Mamba는 시변 시스템임에도 불구하고 시퀀스 길이에 대해 로그 시간 복잡도(<span class="math math-inline">O(\log L)</span>) 수준의 병렬 학습 속도를 확보한다.10</p>
<h4>3.1.5.3 하드웨어 인식(Hardware-Aware) 구현: 메모리 병목의 해소</h4>
<p>병렬 스캔만으로는 충분하지 않다. 선택 메커니즘에 의해 생성되는 중간 파라미터들(<span class="math math-inline">\bar{\mathbf{A}}, \bar{\mathbf{B}}, \mathbf{\Delta}</span>)은 <span class="math math-inline">(B, L, D, N)</span>과 같이 거대한 차원을 가지며, 이를 GPU의 고대역폭 메모리(HBM)에 모두 저장하고 읽어오는 과정(Memory I/O)은 막대한 병목 현상을 유발한다.</p>
<p>Mamba는 이를 해결하기 위해 FlashAttention의 철학을 계승한 <strong>하드웨어 인식 구현</strong>을 채택했다.1</p>
<ol>
<li><strong>커널 퓨전(Kernel Fusion):</strong> 이산화, 스캔, 출력 투영 등 일련의 연산을 단일 GPU 커널로 통합한다.</li>
<li><strong>SRAM 중심 연산:</strong> 거대한 중간 상태 행렬을 HBM에 구체화(Materialize)하지 않는다. 대신, 입력 <span class="math math-inline">x</span>와 파라미터만을 빠른 온칩 메모리인 SRAM으로 로드한 뒤, SRAM 내부에서 이산화와 스캔 연산을 수행하고 최종 결과 <span class="math math-inline">y</span>만을 HBM에 기록한다.</li>
<li><strong>재계산(Recomputation):</strong> 역전파(Backpropagation) 시 필요한 중간 상태들을 저장해두는 대신, 순전파(Forward pass) 때와 마찬가지로 SRAM 내에서 빠르게 재계산하는 방식을 사용하여 메모리 사용량을 획기적으로 줄인다.</li>
</ol>
<p>이러한 최적화를 통해 Mamba는 이론적으로는 연산량이 증가했음에도 불구하고, 실제 하드웨어 상에서는 기존의 LTI SSM이나 트랜스포머보다 빠른 처리 속도(Throughput)와 낮은 메모리 점유율을 달성할 수 있었다.2</p>
<h3>3.1.6 소결: LTI의 구조적 경직성을 넘어서</h3>
<p>선형 시간 불변(LTI) 시스템은 지난 수십 년간 신호 처리와 제어 이론의 근간이 되어왔으며, 초기 SSM 모델들을 통해 딥러닝 효율화의 가능성을 보여주었다. 그러나 고정된 파라미터와 정적인 필터링 메커니즘은 문맥에 따른 유연한 대처가 필수적인 언어 모델링과 이산 데이터 처리에서 명확한 한계를 드러냈다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>LTI SSM (S4, H3 등)</strong></th><th><strong>선택적 SSM (Mamba)</strong></th></tr></thead><tbody>
<tr><td><strong>시스템 역학</strong></td><td>선형 시간 불변 (Static Dynamics)</td><td>선형 시변 (Time-Varying Dynamics)</td></tr>
<tr><td><strong>파라미터</strong></td><td>고정 상수 (<span class="math math-inline">A, B, C</span>)</td><td>입력의 함수 (<span class="math math-inline">A(x), B(x), C(x)</span>)</td></tr>
<tr><td><strong>핵심 연산</strong></td><td>전역적 합성곱 (FFT)</td><td>재귀적 병렬 스캔 (Parallel Scan)</td></tr>
<tr><td><strong>추론 능력</strong></td><td>전체 시퀀스 균일 처리</td><td>내용 기반 필터링 및 게이팅 (Content-Based)</td></tr>
<tr><td><strong>강점</strong></td><td>연속 신호(오디오) 처리, 초고속 학습</td><td>이산 데이터(텍스트) 처리, 문맥 압축</td></tr>
<tr><td><strong>실패 사례</strong></td><td>선택적 복사, 유도 헤드 과제 실패</td><td>해당 과제 완벽 수행 및 일반화</td></tr>
</tbody></table>
<p><strong>표 3.1.1</strong> LTI SSM과 Mamba의 구조적 및 기능적 비교</p>
<p>Mamba가 제시한 ’입력 의존적 파라미터’와 ’선택 메커니즘’은 SSM을 정적인 필터에서 동적인 정보 처리 장치로 진화시켰다. <span class="math math-inline">\mathbf{\Delta}</span>를 통한 시간적 게이팅은 정보의 저장과 삭제를 능동적으로 제어하게 했으며, 하드웨어 인식 병렬 스캔 알고리즘은 합성곱의 상실이라는 계산적 비용을 성공적으로 상쇄했다. 결론적으로 3.1절에서 논의한 기술적 도약들은 SSM이 단순한 효율성 도구를 넘어, 트랜스포머를 대체하거나 보완할 수 있는 강력한 차세대 파운데이션 모델(Foundation Model) 아키텍처로 자리매김하는 결정적인 계기가 되었다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/pdf/2312.00752</li>
<li>[2312.00752] Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/abs/2312.00752</li>
<li>Mamba Simplified - Part 2 - S4 and Mamba - Prem AI Blog, 12월 25, 2025에 액세스, https://blog.premai.io/s4-and-mamba/</li>
<li>M 2 Rec: Multi-scale Mamba for Efficient Sequential Recommendation - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2505.04445v1</li>
<li>Linear time-invariant system - Wikipedia, 12월 25, 2025에 액세스, https://en.wikipedia.org/wiki/Linear_time-invariant_system</li>
<li>Deepfake Detection Using Mamba (Selective State Space Model) - IJFMR, 12월 25, 2025에 액세스, https://www.ijfmr.com/papers/2025/6/63645.pdf</li>
<li>Zero to Mamba: An intuitive explanation to the Mamba Architecture | by AI Club, IITM, 12월 25, 2025에 액세스, https://medium.com/@aiclub.iitm/zero-to-mamba-an-intuitive-explanation-to-the-mamba-architecture-d52265b771ab</li>
<li>Discrete-Time Linear Time-Invariant (LTI) Systems - The Convolution Sum - Fosco Connect, 12월 25, 2025에 액세스, https://www.fiberoptics4sale.com/blogs/wave-optics/discrete-time-linear-time-invariant-lti-systems-the-convolution-sum</li>
<li>Mamba: An SSM Method for Efficient and Powerful Sequence Modeling - Medium, 12월 25, 2025에 액세스, https://medium.com/@akdemir_bahadir/mamba-an-ssm-method-for-efficient-and-powerful-sequence-modeling-5dec8f1c849b</li>
<li>Hardware-Aware Algorithm for Selective State Space Models | HackerNoon, 12월 25, 2025에 액세스, https://hackernoon.com/hardware-aware-algorithm-for-selective-state-space-models</li>
<li>A Survey of Mamba - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2408.01129v4</li>
<li>Mamba architecture : A Leap Forward in Sequence Modeling | by Puneet Hegde - Medium, 12월 25, 2025에 액세스, https://medium.com/@puneetthegde22/mamba-architecture-a-leap-forward-in-sequence-modeling-370dfcbfe44a</li>
<li>Linear-Time Sequence Modeling: An In-Depth Analysis of State Space Models and the Mamba Architecture as Alternatives to Quadratic Attention | Uplatz Blog, 12월 25, 2025에 액세스, https://uplatz.com/blog/linear-time-sequence-modeling-an-in-depth-analysis-of-state-space-models-and-the-mamba-architecture-as-alternatives-to-quadratic-attention/</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2312.00752v2</li>
<li>Induction Heads as an Essential Mechanism for Pattern Matching in In-context Learning | Request PDF - ResearchGate, 12월 25, 2025에 액세스, https://www.researchgate.net/publication/392505694_Induction_Heads_as_an_Essential_Mechanism_for_Pattern_Matching_in_In-context_Learning</li>
<li>Mamba Selective State Space Model - Emergent Mind, 12월 25, 2025에 액세스, https://www.emergentmind.com/topics/mamba-based-selective-state-space-model</li>
<li>Mamba (deep learning architecture) - Wikipedia, 12월 25, 2025에 액세스, https://en.wikipedia.org/wiki/Mamba_(deep_learning_architecture)</li>
<li>Comprehensive Breakdown of Selective Structured State Space Model — Mamba (S5). | by Freedom Preetham | Autonomous Agents | Medium, 12월 25, 2025에 액세스, https://medium.com/autonomous-agents/comprehensive-breakdown-of-selective-structured-state-space-model-mamba-s5-441e8b94ecaf</li>
<li>Mamba Explained - The Gradient, 12월 25, 2025에 액세스, https://thegradient.pub/mamba-explained/</li>
<li>SPATIAL-MAMBA: EFFECTIVE VISUAL STATE SPACE MODELS VIA STRUCTURE-AWARE STATE FUSION - ICLR Proceedings, 12월 25, 2025에 액세스, https://proceedings.iclr.cc/paper_files/paper/2025/file/b7216f4a324864e1f592c18de4d83d10-Paper-Conference.pdf</li>
<li>[D] Question about shapes of Mamba algorithm : r/MachineLearning - Reddit, 12월 25, 2025에 액세스, https://www.reddit.com/r/MachineLearning/comments/1eub39f/d_question_about_shapes_of_mamba_algorithm/</li>
<li>Mamba-MLP-Transformer Architecture - Emergent Mind, 12월 25, 2025에 액세스, https://www.emergentmind.com/topics/mamba-mlp-transformer-architecture</li>
<li>The Hidden Attention of Mamba Models - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2403.01590v2</li>
<li>gated delta networks: improving mamba2 with delta rule - arXiv, 12월 25, 2025에 액세스, <a href="https://arxiv.org/pdf/2412.06464">https://arxiv.org/pdf/2412.06464?</a></li>
<li>Fast Vision Mamba: Pooling Spatial Dimensions for Accelerated Processing - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2502.00594v1</li>
<li>On the Tradeoffs of SSMs and Transformers | Goomba Lab, 12월 25, 2025에 액세스, https://goombalab.github.io/blog/2025/tradeoffs/</li>
<li>A Visual Guide to Mamba and State Space Models - Maarten Grootendorst, 12월 25, 2025에 액세스, https://www.maartengrootendorst.com/blog/mamba/</li>
<li>Along comes a Mamba: an evolution in sequence models based on state space models | by Wilbur de Souza | Medium, 12월 25, 2025에 액세스, https://medium.com/@wilburdes/along-comes-a-mamba-an-evolution-in-sequence-models-based-on-state-space-models-2bd3d0e02d86</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>