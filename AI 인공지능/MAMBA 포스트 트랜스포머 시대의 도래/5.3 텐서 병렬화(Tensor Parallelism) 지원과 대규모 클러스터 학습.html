<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.3 텐서 병렬화(Tensor Parallelism) 지원과 대규모 클러스터 학습</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.3 텐서 병렬화(Tensor Parallelism) 지원과 대규모 클러스터 학습</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>5.3 텐서 병렬화(Tensor Parallelism) 지원과 대규모 클러스터 학습</span></nav>
                </div>
            </header>
            <article>
                <h1>5.3 텐서 병렬화(Tensor Parallelism) 지원과 대규모 클러스터 학습</h1>
<h2>1.  서론: 초거대 언어 모델과 분산 학습의 난제</h2>
<p>현대 인공지능, 특히 대규모 언어 모델(LLM)의 발전은 모델의 파라미터 수와 학습 데이터의 양을 기하급수적으로 늘리는 ’스케일링 법칙(Scaling Law)’에 의해 견인되어 왔다. 수천억 개(Hundreds of Billions)의 파라미터를 가진 모델을 학습시키기 위해서는 단일 GPU의 메모리와 연산 능력으로는 불가능하며, 수천 개의 GPU를 고속 인터커넥트(Interconnect)로 연결한 대규모 클러스터가 필수적이다. 이러한 환경에서 모델 학습의 효율성은 개별 연산 유닛의 속도뿐만 아니라, GPU 간의 데이터 통신 비용을 얼마나 최소화하느냐에 달려 있다.</p>
<p>트랜스포머(Transformer) 아키텍처는 그 등장부터 병렬 처리에 최적화된 구조를 가지고 있었다. 어텐션(Attention) 메커니즘과 피드포워드 신경망(MLP)은 행렬 곱셈(Matrix Multiplication) 기반으로 동작하여 GPU의 텐서 코어(Tensor Core) 활용도가 높고, 텐서 병렬화(Tensor Parallelism, TP)와 같은 모델 병렬화 기법을 적용하기 용이했다. 그러나 시퀀스 길이가 길어질수록 연산량과 메모리 사용량이 시퀀스 길이의 제곱(<span class="math math-inline">O(L^2)</span>)으로 증가하는 구조적 한계는 긴 문맥(Long Context) 처리가 필요한 현대 AI의 요구사항과 충돌하기 시작했다.</p>
<p>이에 대한 대안으로 등장한 상태 공간 모델(State Space Models, SSM), 그중에서도 Mamba 아키텍처는 선형 복잡도(<span class="math math-inline">O(L)</span>)를 무기로 내세웠다. 이론적으로 Mamba는 긴 시퀀스에서도 일정한 메모리와 선형적인 연산 시간을 보장하므로, 트랜스포머의 병목을 해결할 구원투수로 여겨졌다. 그러나 초기 Mamba-1 모델은 ’순환(Recurrence)’이라는 본질적인 특성으로 인해 대규모 클러스터 기반의 분산 학습, 특히 텐서 병렬화 적용에 있어 심각한 공학적 난관에 봉착했다. 순차적 의존성은 병렬화를 방해했고, 이를 우회하기 위한 기법들은 과도한 통신 오버헤드를 유발했다.</p>
<p>본 장에서는 Mamba-2가 도입한 <strong>구조적 상태 공간 쌍대성(Structured State Space Duality, SSD)</strong> 프레임워크가 어떻게 이러한 병렬화의 난제를 수학적으로, 그리고 시스템적으로 해결했는지 심층 분석한다. 우리는 Mamba-1이 겪었던 텐서 병렬화의 한계를 규명하고, Mamba-2가 이를 극복하기 위해 채택한 <strong>행렬 믹서(Matrix Mixer)</strong> 구조와 <strong>블록 분해(Block Decomposition)</strong> 알고리즘을 상세히 다룬다. 나아가 NVIDIA의 Megatron-LM과 같은 최신 분산 학습 프레임워크 상에서 구현된 텐서 병렬화, 시퀀스 병렬화(Sequence Parallelism), 그리고 컨텍스트 병렬화(Context Parallelism)의 구체적인 메커니즘을 기술하고, Jamba 및 Granite 4.0과 같은 최신 하이브리드 모델들이 어떻게 수천 장의 H100 GPU 클러스터에서 효율적으로 학습될 수 있었는지에 대한 실증적 사례를 제시한다.</p>
<h2>2.  Mamba-1의 구조적 한계와 분산 학습의 병목</h2>
<p>Mamba-2의 혁신성을 온전히 이해하기 위해서는, 먼저 Mamba-1이 대규모 분산 학습 환경에서 겪었던 구조적 비효율성을 명확히 짚고 넘어가야 한다. 단일 GPU에서의 학습 효율성과 수천 개의 GPU가 상호작용하는 클러스터 레벨에서의 효율성은 전혀 다른 차원의 문제이다.</p>
<h3>2.1  선택적 스캔(Selective Scan)의 순차적 의존성과 하드웨어 불일치</h3>
<p>Mamba-1의 핵심 기여인 ’선택적 스캔(Selective Scan)’은 입력 데이터에 따라 동적으로 변하는 파라미터(<span class="math math-inline">B, C, \Delta</span>)를 도입하여 모델의 정보 선별 능력을 극대화했다. 그러나 이 알고리즘은 본질적으로 순환 신경망(RNN)의 형태를 띠고 있다. 시점 <span class="math math-inline">t</span>의 은닉 상태(Hidden State) <span class="math math-inline">h_t</span>는 이전 시점 <span class="math math-inline">h_{t-1}</span>이 계산된 이후에만 결정될 수 있다.<br />
<span class="math math-display">
h_t = \bar{A}_t h_{t-1} + \bar{B}_t x_t
</span><br />
이러한 순차적 의존성(Sequential Dependency)은 병렬 연산에 최적화된 GPU 하드웨어와 근본적인 불일치를 일으킨다. Mamba-1은 이를 해결하기 위해 병렬 스캔(Parallel Scan, Blelloch Algorithm)을 도입하여 연산 속도를 높였으나, 이는 여전히 메모리 대역폭(Memory Bandwidth)에 민감한 작업이다. 분산 학습 환경에서는 GPU 내부의 메모리 이동뿐만 아니라 GPU 간, 노드 간의 통신이 발생하는데, 순차적 의존성이 강한 알고리즘은 이러한 통신 지연(Latency)을 숨기기(Hiding) 어렵게 만든다.1</p>
<h3>2.2  텐서 병렬화(TP) 적용 시 발생하는 통신 오버헤드 (Double All-Reduce)</h3>
<p>초거대 언어 모델 학습의 표준 기법인 텐서 병렬화(Tensor Parallelism)는 거대한 행렬 연산을 여러 GPU로 쪼개어 수행하는 기술이다. 트랜스포머의 MLP나 어텐션 레이어는 일반적으로 입력 투영(Input Projection)을 열 방향(Column-wise)으로 쪼개고, 출력 투영(Output Projection)을 행 방향(Row-wise)으로 쪼개는 방식을 사용한다. 이 경우, 레이어의 끝단에서 각 GPU의 부분적인 결과값을 합치기 위해 <strong>단 한 번의 All-Reduce</strong> 통신만 수행하면 된다.</p>
<p>반면, Mamba-1의 구조는 텐서 병렬화에 친화적이지 않다. Mamba-1의 SSM 파라미터들은 레이어의 입력 <span class="math math-inline">x</span>가 아닌, 내부적인 1D 합성곱(Convolution)과 활성화 함수를 거친 중간 상태(Inner Activations)에 의존하여 생성된다.</p>
<p>이는 모델을 병렬화할 때 각 GPU가 독립적으로 파라미터를 생성할 수 없음을 의미하거나, 혹은 파라미터 생성을 위해 추가적인 통신이 필요함을 의미한다. 구체적으로 Mamba-1 레이어를 텐서 병렬화하려면, 중간 단계에서 상태 동기화가 필요하여 레이어당 두 번의 All-Reduce 연산이 요구된다.3</p>
<p>All-Reduce는 클러스터 내 모든 GPU가 데이터를 주고받아야 하는 고비용 연산이다. 레이어마다 통신 횟수가 두 배로 늘어난다는 것은, 네트워크 대역폭이 병목이 되는 대규모 클러스터에서 학습 속도가 절반 가까이 떨어질 수 있음을 시사한다. 이는 Mamba-1이 단일 디바이스에서는 빠를지 몰라도, 수천 억 파라미터 규모로 확장(Scaling-up)하는 데에는 치명적인 제약이 되었다.</p>
<h3>2.3  커널 융합(Kernel Fusion)의 한계와 메모리 IO</h3>
<p>Mamba-1은 학습 속도를 높이기 위해 하드웨어 인식(Hardware-Aware) 알고리즘을 사용하여 HBM(High Bandwidth Memory)과 SRAM 사이의 데이터 이동을 최소화하는 커널 융합을 수행했다. 그러나 이러한 최적화는 단일 GPU 내에서의 동작을 가정한 것이다. 텐서 병렬화가 적용되면 연산의 중간 결과물이 다른 GPU로 전송되어야 하므로, 융합된 커널을 강제로 분리해야 하는 경우가 발생한다. 이는 Mamba-1이 자랑하던 메모리 효율성을 저하시키고, 재계산(Recomputation) 비용을 증가시키는 결과를 초래했다.</p>
<h2>3.  Mamba-2와 구조적 상태 공간 쌍대성(SSD): 병렬화의 열쇠</h2>
<p>Mamba-2는 이러한 구조적 병목을 해결하기 위해 SSM을 근본적으로 재해석했다. 그 핵심에는 <strong>구조적 상태 공간 쌍대성(SSD)</strong> 이론이 있다. SSD는 순차적인 SSM 연산과 2차적(Quadratic) 어텐션 연산이 수학적으로 연결되어 있음을 증명하고, 이를 통해 SSM을 GPU 친화적인 행렬 곱셈(Matrix Multiplication) 형태로 변환할 수 있는 길을 열었다.</p>
<h3>3.1  행렬 믹서(Matrix Mixer)와 스칼라 구조의 도입</h3>
<p>Mamba-2는 텐서 병렬화를 용이하게 하기 위해 상태 행렬 <span class="math math-inline">A</span>에 강력한 제약을 가했다. 기존 Mamba-1이나 S4 모델이 대각 행렬(Diagonal Matrix) 혹은 더 복잡한 구조를 허용했던 것과 달리, Mamba-2는 <span class="math math-inline">A</span>를 스칼라 값의 대각 행렬(<span class="math math-inline">A_t = a_t I</span>) 구조로 제한했다.5</p>
<p>언뜻 보기에 이는 모델의 표현력을 저하시키는 제약처럼 보일 수 있다. 그러나 이 제약은 각 채널(Channel) 혹은 헤드(Head) 내의 모든 상태 차원(State Dimension, <span class="math math-inline">N</span>)이 동일한 감쇠(Decay) 역학을 공유하게 함으로써, 복잡한 순환 연산을 단순한 행렬 곱셈으로 치환 가능하게 만든다. 이를 통해 SSM 연산은 거대한 **반분리 행렬(Semiseparable Matrix)**과 입력 벡터의 곱셈(<span class="math math-inline">Y = MX</span>)으로 표현될 수 있다. 여기서 <span class="math math-inline">M</span>은 인과적 마스킹(Causal Masking)이 적용된 어텐션 행렬과 유사한 형태를 띠게 된다.</p>
<h3>3.2  블록 분해(Block Decomposition) 알고리즘의 병렬성</h3>
<p>SSD 프레임워크 하에서, SSM의 연산은 시퀀스 전체에 대해 순차적으로 수행될 필요가 없다. 대신 시퀀스를 길이 <span class="math math-inline">Q</span>의 블록(Block) 또는 청크(Chunk)로 나누어 병렬 처리하는 <strong>블록 분해 알고리즘</strong>이 적용된다.</p>
<ul>
<li><strong>대각 블록(Intra-Chunk):</strong> 각 청크 내부의 연산은 국소적인 어텐션(Local Attention)과 수학적으로 동치인 2차 형식(Quadratic Form)으로 계산된다. 이는 GPU의 텐서 코어가 가장 잘 처리하는 고밀도 행렬 곱셈(GEMM) 연산이므로 매우 빠르게 수행된다.7</li>
<li><strong>비대각 블록(Inter-Chunk):</strong> 청크와 청크 사이의 정보 전달은 ’상태(State)’를 통해 이루어진다. 이전 청크의 최종 상태가 다음 청크의 초기 상태로 전달되는 구조다. 중요한 점은 이 상태 전달 연산이 저랭크(Low-Rank) 행렬 곱셈으로 표현되며, 전송해야 할 데이터의 크기가 트랜스포머의 KV 캐시(<span class="math math-inline">L \times D</span>)에 비해 훨씬 작은 <span class="math math-inline">N \times P</span> (상태 차원 <span class="math math-inline">\times</span> 헤드 차원) 수준이라는 것이다.</li>
</ul>
<p>이러한 블록 분해는 Mamba-2가 긴 시퀀스를 처리할 때도 트랜스포머의 제곱 복잡도 병목에 걸리지 않으면서, 동시에 Mamba-1의 순차적 병목을 피해 병렬성을 확보할 수 있게 해준다.</p>
<h3>3.3  병렬 투영(Parallel Projection) 아키텍처</h3>
<p>Mamba-2는 SSD 이론을 바탕으로 시스템 아키텍처를 ‘병렬 투영’ 구조로 재편했다. Mamba-1에서는 입력 투영과 SSM 파라미터 생성 네트워크가 직렬로 연결되어 있었으나, Mamba-2에서는 <span class="math math-inline">A, B, C</span>를 포함한 모든 SSM 파라미터가 레이어의 입력 <span class="math math-inline">x</span>에 대한 직접적인 함수로 정의된다.</p>
<p>즉, <span class="math math-inline">x</span>가 입력되면 독립적인 선형 레이어를 통해 <span class="math math-inline">B, C, \Delta</span>가 동시에(Parallel) 생성된다. 이는 트랜스포머의 <span class="math math-inline">Q, K, V</span> 생성 방식과 유사하며, 덕분에 텐서 병렬화 적용 시 입력 투영 행렬 <span class="math math-inline">W_{in}</span>을 채널 차원을 따라 분할(Shard)하는 것만으로 완벽한 병렬화가 가능해진다.</p>
<p>결과적으로 Mamba-2는 레이어당 <strong>단 1회의 All-Reduce</strong> 통신만으로 텐서 병렬화를 구현할 수 있게 되었다.4 이는 Mamba-1 대비 통신 비용을 50% 절감한 것이며, 트랜스포머 아키텍처와 동일한 통신 효율성을 달성했음을 의미한다. 이 변화가 대규모 클러스터 학습 가능 여부를 가르는 결정적인 분기점이 되었다.</p>
<h2>4.  대규모 클러스터 학습을 위한 병렬화 구현 전략</h2>
<p>이론적으로 확보된 병렬성을 실제 수천 장의 GPU 클러스터에서 구현하기 위해서는 구체적인 분산 처리 전략이 필요하다. NVIDIA의 Megatron-LM과 같은 프레임워크에서 Mamba-2는 텐서 병렬화(TP), 시퀀스 병렬화(SP), 그리고 컨텍스트 병렬화(CP)의 세 가지 축을 중심으로 구현된다.</p>
<h3>4.1  텐서 병렬화(Tensor Parallelism, TP)의 구현 상세</h3>
<p>Mamba-2의 텐서 병렬화는 Megatron-LM의 스타일을 따라 다음과 같이 단계적으로 수행된다. TP 차수(Degree)를 <span class="math math-inline">T_{p}</span>라고 할 때, 각 GPU는 전체 모델의 <span class="math math-inline">1/T_{p}</span> 만큼의 파라미터를 보유하고 연산한다.</p>
<ol>
<li>입력 투영 분할 (Column Parallelism):</li>
</ol>
<p>입력 벡터 <span class="math math-inline">u</span>가 주어졌을 때, 입력 투영 행렬 <span class="math math-inline">W_{in}</span>은 열(Column) 방향으로 <span class="math math-inline">T_{p}</span>개로 분할된다. 각 GPU <span class="math math-inline">i</span>는 <span class="math math-inline">W_{in}^{(i)}</span>를 가지고 있으며, 로컬 입력 복제본에 대해 <span class="math math-inline">u_i = u W_{in}^{(i)}</span>를 계산한다. 이 연산은 GPU 간 통신 없이 수행된다.4</p>
<ol start="2">
<li>독립적 로컬 SSM 연산 (Independent Head Processing):</li>
</ol>
<p>Mamba-2는 멀티 헤드(Multi-Head) 구조를 도입했다. 전체 헤드 개수 <span class="math math-inline">H</span>는 <span class="math math-inline">T_{p}</span>로 나누어지며, 각 GPU는 <span class="math math-inline">H/T_{p}</span> 개의 헤드를 담당한다. SSD 알고리즘에 의해 각 헤드는 독립적으로 연산이 가능하므로, 각 GPU는 자신이 담당하는 헤드들에 대해서만 SSM 연산(또는 SSD 블록 연산)을 수행한다. 이 단계에서도 GPU 간 통신은 전혀 발생하지 않는다.</p>
<ol start="3">
<li>그룹화된 정규화 (Grouped Normalization):</li>
</ol>
<p>일반적인 LayerNorm은 전체 채널에 대한 통계량을 필요로 하여 All-Reduce가 필요할 수 있다. Mamba-2는 이를 방지하기 위해 그룹 정규화(Group Norm)를 사용하며, 그룹의 수가 TP 차수의 배수가 되도록 설정한다. 이를 통해 정규화 과정도 각 GPU 내에서 로컬하게 완료된다.</p>
<ol start="4">
<li>출력 투영 분할 (Row Parallelism) 및 All-Reduce:</li>
</ol>
<p>SSM의 출력 <span class="math math-inline">y_i</span>는 출력 투영 행렬 <span class="math math-inline">W_{out}</span>을 통과해야 한다. <span class="math math-inline">W_{out}</span>은 행(Row) 방향으로 분할되어 있으며(<span class="math math-inline">W_{out}^{(i)}</span>), 각 GPU는 <span class="math math-inline">z_i = y_i W_{out}^{(i)}</span>를 계산한다. 최종적으로 모델의 출력 <span class="math math-inline">z</span>는 모든 GPU의 부분합(<span class="math math-inline">\sum z_i</span>)이므로, 이때 레이어 내 유일한 All-Reduce 통신이 발생하여 결과를 동기화한다.</p>
<p>이러한 설계는 통신 병목을 최소화하여 GPU 수가 늘어나도 연산 효율이 급격히 떨어지지 않는 선형적인 확장성(Scaling)을 보장한다.</p>
<h3>4.2  시퀀스 병렬화(Sequence Parallelism, SP)와 Ring P2P 통신</h3>
<p>텐서 병렬화는 모델의 크기를 감당하기 위한 것이라면, 시퀀스 병렬화는 단일 GPU 메모리에 담기지 않는 긴 시퀀스(예: 128K, 1M 토큰)를 처리하기 위한 기술이다. Mamba-2의 SSD 구조는 시퀀스 병렬화 구현에 있어 트랜스포머보다 더욱 효율적인 메커니즘을 제공한다.</p>
<ul>
<li>청크 분할 및 상태 전달 (Chunking and State Passing):</li>
</ul>
<p>긴 시퀀스는 여러 GPU에 분산되어 저장된다. 각 GPU는 자신이 담당하는 시퀀스 청크(Chunk)에 대해 로컬 연산을 수행한다. 이때 필요한 것은 이전 GPU가 처리한 시퀀스의 ‘최종 상태(Final State)’ 뿐이다.</p>
<p>트랜스포머가 시퀀스 병렬화를 위해 Ring Attention을 수행할 때 거대한 KV 블록을 지속적으로 순환시켜야 하는 것과 달리, Mamba-2는 압축된 상태 행렬(크기 <span class="math math-inline">N \times P</span>)만을 인접한 GPU로 전송(Send/Recv)하면 된다.7</p>
<ul>
<li>
<p><strong>통신 효율성 비교:</strong></p>
</li>
<li>
<p><strong>Transformer (Ring Attention):</strong> 통신량 <span class="math math-inline">O(L \times D)</span>. 시퀀스 길이 <span class="math math-inline">L</span>에 비례하여 통신량이 증가한다.</p>
</li>
<li>
<p><strong>Mamba-2 (State Passing):</strong> 통신량 <span class="math math-inline">O(N \times P)</span>. 시퀀스 길이와 무관하게 고정된 작은 크기의 상태값만 전송한다.</p>
</li>
</ul>
<p>이 차이는 초장문 문맥(Ultra-Long Context) 학습 시 Mamba-2가 트랜스포머 대비 압도적인 처리량(Throughput)을 낼 수 있는 핵심 요인이다. Megatron-LM 구현에서는 잔차 연결(Residual)과 LayerNorm에 대해서도 Reduce-Scatter와 All-Gather를 조합한 시퀀스 병렬화를 적용하여 활성화 메모리(Activation Memory) 사용량을 GPU 개수에 비례하여 감소시킨다.7</p>
<h3>4.3  가변 길이 시퀀스(Variable Sequence Length)와 패딩 제거</h3>
<p>대규모 데이터셋 학습 시, 배치(Batch) 내의 시퀀스 길이는 제각각이다. 트랜스포머는 이를 처리하기 위해 최대 길이에 맞춰 패딩(Padding) 토큰을 채워 넣고, 어텐션 마스크를 사용하여 연산을 건너뛰는 방식을 사용한다. 이는 불필요한 연산 낭비를 초래한다.</p>
<p>Mamba-2는 SSD의 순환적 특성을 이용하여 이를 우아하게 해결한다. 전체 배치를 하나의 긴 1차원 시퀀스로 연결(Packing)한 뒤, 각 개별 시퀀스가 끝나는 지점(eos)에서 상태 전이 행렬 <span class="math math-inline">A_t</span>를 0으로 설정한다. <span class="math math-inline">A_t=0</span>은 이전 상태 <span class="math math-inline">h_{t-1}</span>을 잊어버리고 새로운 상태를 시작하라는 의미이므로, 별도의 마스킹이나 복잡한 인덱싱 없이도 자연스럽게 시퀀스 간의 정보 혼합을 방지할 수 있다.4 이는 학습 구현을 단순화할 뿐만 아니라, 유효 토큰에 대해서만 연산을 수행하므로 실질적인 학습 처리량을 극대화한다.</p>
<h2>5.  하드웨어 가속 및 인프라 최적화</h2>
<p>Mamba-2의 병렬화 알고리즘은 최신 GPU 아키텍처의 발전과 맞물려 시너지를 낸다. 특히 NVIDIA H100과 같은 최신 가속기에서의 성능 특성은 SSM이 더 이상 실험적인 모델이 아니라 엔터프라이즈급 워크로드에 적합함을 보여준다.</p>
<h3>5.1  A100 vs H100: 행렬 곱셈 엔진으로의 전환</h3>
<p>Mamba-1의 스캔 알고리즘은 메모리 대역폭에 크게 의존했기 때문에, 연산 능력(FLOPS)보다는 메모리 속도가 중요했다. 반면, SSD 기반의 Mamba-2는 연산의 대부분을 **행렬 곱셈(MatMul)**으로 변환했다. 이는 GPU의 텐서 코어(Tensor Core)를 100% 활용할 수 있음을 의미한다.</p>
<p>H100 GPU는 A100 대비 약 3배 높은 FP16/BF16 연산 성능과 3.35 TB/s의 메모리 대역폭을 제공한다. 더 중요한 것은 H100에 탑재된 Transformer Engine과 FP8 텐서 코어이다. Mamba-2는 SSD 알고리즘의 수치적 안정성을 바탕으로 FP8 연산을 적극적으로 활용할 수 있다. 실제 벤치마크에서 H100을 사용한 Mamba-2 학습은 A100 대비 2배 이상의 처리량을 기록하며, 이는 순수 트랜스포머 모델의 가속폭을 상회하는 경우가 많다.11</p>
<h3>5.2  통신 대역폭과 NVLink 활용</h3>
<p>대규모 클러스터(예: SuperPOD)에서는 노드 간 통신이 성능의 병목이 된다. Mamba-2의 텐서 병렬화는 레이어당 1회의 All-Reduce만을 요구하므로, 트랜스포머와 동일한 수준의 통신 대역폭 효율을 가진다. 더 나아가 시퀀스 병렬화 시 발생하는 상태 전달(State Passing) 통신은 데이터 양이 매우 적어, NVLink가 없는 이더넷 기반의 저사양 클러스터에서도 상대적으로 높은 성능을 유지할 수 있는 장점이 있다. 이는 최고 사양의 HPC 환경뿐만 아니라, 다양한 클라우드 환경에서의 배포 유연성을 높여준다.</p>
<h2>6.  실제 대규모 클러스터 학습 사례 및 성능 분석</h2>
<p>이론과 구현이 실제 대규모 모델 학습에서 어떤 성과로 이어졌는지, 최신 모델들의 사례를 통해 확인해 본다.</p>
<h3>6.1  AI21 Labs의 Jamba: 하이브리드 MoE와 3D 병렬화</h3>
<p>Jamba-1.5는 Mamba 레이어와 트랜스포머 레이어를 결합하고, 여기에 전문가 믹스(MoE)를 더한 하이브리드 아키텍처다. 총 파라미터 398B(활성 94B)에 달하는 이 거대 모델은 256K 토큰이라는 긴 문맥을 학습하기 위해 **텐서 병렬화(TP), 시퀀스 병렬화(SP), 전문가 병렬화(Expert Parallelism, EP)**가 결합된 3D 병렬화 전략을 사용했다.13</p>
<p>주목할 점은 Jamba가 Mamba 레이어 덕분에 동일한 크기의 트랜스포머 모델(Mixtral 8x7B 등) 대비 **3배 높은 처리량(Throughput)**을 기록했다는 것이다.14 특히 256K 길이의 긴 문맥 학습에서 트랜스포머는 KV 캐시로 인한 메모리 부족(OOM)과 연산량 폭증을 겪지만, Jamba는 8장의 H100 80GB GPU만으로도 이를 처리할 수 있었다. 이는 Mamba-2의 효율적인 텐서/시퀀스 병렬화 지원 없이는 불가능한 성과이다.</p>
<h3>6.2  IBM Granite 4.0: 선형 스케일링의 실증</h3>
<p>IBM의 Granite 4.0은 Mamba-2와 트랜스포머를 9:1 비율로 섞은 아키텍처를 채택했다. IBM의 기술 보고서에 따르면, 이 모델은 긴 문맥 처리 시 메모리 사용량을 기존 트랜스포머 대비 70% 절감했다.15</p>
<p>학습 스케일링 그래프(Weak Scaling Plot)를 분석해보면, 시퀀스 길이가 증가함에 따라 트랜스포머의 학습 시간은 급격한 곡선을 그리며 상승하는 반면, Granite 4.0은 완만한 선형 증가세를 보인다. 이는 수천 개의 GPU를 사용하는 대규모 학습 시, 데이터 처리량을 획기적으로 늘릴 수 있음을 의미한다. Granite 4.0은 최대 512K 토큰 길이의 데이터로 학습되었으며, 이는 Mamba-2의 병렬화 효율성이 극단적인 문맥 길이에서도 무너지지 않음을 증명한다.</p>
<h3>6.3  NVIDIA의 비교 실험: 18배의 속도 차이</h3>
<p>NVIDIA의 공식 벤치마크는 시퀀스 길이에 따른 Mamba-2와 트랜스포머의 성능 격차를 극명하게 보여준다. 시퀀스 길이가 2K일 때 Mamba-2는 트랜스포머와 유사하거나 약간 느린 속도를 보이지만(MLP 오버헤드 등), 시퀀스 길이가 256K에 도달하면 <strong>Mamba-2 레이어는 트랜스포머 레이어보다 18배 더 빠르게 학습</strong>된다.16 이는 텐서 병렬화와 SSD 알고리즘이 결합되어 <span class="math math-inline">O(N^2)</span>의 족쇄를 완전히 끊어냈기에 가능한 결과이다.</p>
<p>&lt;표 5.3.1&gt; 시퀀스 길이에 따른 Transformer vs Mamba-2 학습 속도 비교 (H100 기준)</p>
<table><thead><tr><th><strong>시퀀스 길이 (Tokens)</strong></th><th><strong>Transformer (FlashAttn-2)</strong></th><th><strong>Mamba-2 (SSD)</strong></th><th><strong>속도 향상 (Speedup)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td>2,048 (2K)</td><td>1.0x (기준)</td><td>~0.9x - 1.0x</td><td>-</td><td>짧은 시퀀스에서는 유사함</td></tr>
<tr><td>8,192 (8K)</td><td>1.0x (기준)</td><td>~1.8x</td><td>~1.8배</td><td>선형 스케일링 효과 시작</td></tr>
<tr><td>32,768 (32K)</td><td>1.0x (기준)</td><td>~5.5x</td><td>~5.5배</td><td>트랜스포머 병목 심화</td></tr>
<tr><td>262,144 (256K)</td><td>1.0x (기준)</td><td><strong>~18.0x</strong></td><td><strong>18배</strong></td><td>Mamba-2의 압도적 우위 입증 16</td></tr>
</tbody></table>
<h2>7.  결론: 포스트 트랜스포머를 위한 인프라의 완성</h2>
<p>5.3장에서 살펴본 바와 같이, Mamba-2와 SSD 프레임워크의 등장은 SSM 아키텍처가 가지고 있던 ’학습 효율성’이라는 마지막 퍼즐 조각을 맞추었다. Mamba-1이 이론적인 가능성을 보여주었다면, Mamba-2는 텐서 병렬화 지원을 통해 그 가능성을 엔지니어링 현실로 구현했다.</p>
<p>레이어당 1회의 All-Reduce로 통신 비용을 최소화한 텐서 병렬화, 상태 전달(State Passing)을 통해 무한한 문맥 확장을 가능케 한 시퀀스 병렬화, 그리고 최신 H100 GPU의 텐서 코어를 극한으로 활용하는 블록 분해 알고리즘은 Mamba-2를 대규모 클러스터 학습에 가장 적합한 모델 중 하나로 만들었다. Jamba와 Granite 4.0의 성공 사례는 이러한 기술적 진보가 단순히 논문 속의 수식이 아니라, 실제 엔터프라이즈 AI의 비용 절감과 성능 향상으로 직결되고 있음을 시사한다. 이제 Mamba 아키텍처는 트랜스포머의 대안을 넘어, 초거대/초장문 모델 시대를 지탱하는 핵심 인프라 기술로 자리 잡았다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>On the Tradeoffs of SSMs and Transformers | Goomba Lab, https://goombalab.github.io/blog/2025/tradeoffs/</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://arxiv.org/html/2312.00752v2</li>
<li>State Space Duality (Mamba-2) Part IV - The Systems | Goomba Lab, https://goombalab.github.io/blog/2024/mamba2-part4-systems/</li>
<li>State Space Duality (Mamba-2) Part IV - The Systems | Tri Dao, https://tridao.me/blog/2024/mamba2-part4-systems/</li>
<li>State Space Duality (Mamba-2) Part I - The Model | Tri Dao, https://tridao.me/blog/2024/mamba2-part1-model/</li>
<li>State Space Duality (Mamba-2) Part I - The Model | Goomba Lab, https://goombalab.github.io/blog/2024/mamba2-part1-model/</li>
<li>Mamba-2: Algorithms and Systems, https://pli.princeton.edu/blog/2024/mamba-2-algorithms-and-systems</li>
<li>State Space Duality (Mamba-2) Part III - The Algorithm | Tri Dao, https://tridao.me/blog/2024/mamba2-part3-algorithm/</li>
<li>Developer guide for Activation Memory reduction - AWS Neuron SDK, https://awsdocs-neuron.readthedocs-hosted.com/en/latest/libraries/neuronx-distributed/activation_memory_reduction_developer_guide.html</li>
<li>Mamba 2 | PDF | Matrix (Mathematics) | Tensor - Scribd, https://www.scribd.com/document/748683510/mamba2</li>
<li>Comparing NVIDIA H100 vs A100 GPUs for AI Workloads - OpenMetal, https://openmetal.io/resources/blog/nvidia-h100-vs-a100-gpu-comparison/</li>
<li>H100 vs A100 comparison: Best GPU for LLMs, vision models, and …, https://northflank.com/blog/h100-vs-a100</li>
<li>Jamba-1.5: Hybrid Transformer-Mamba Models at Scale - arXiv, https://arxiv.org/pdf/2408.12570</li>
<li>Jamba: A Hybrid Transformer-Mamba Language Model - arXiv, https://arxiv.org/pdf/2403.19887</li>
<li>IBM Granite 4.0: Hyper-efficient, High Performance Hybrid Models …, https://www.ibm.com/new/announcements/ibm-granite-4-0-hyper-efficient-high-performance-hybrid-models</li>
<li>NVIDIA NeMo Accelerates LLM Innovation with Hybrid State Space …, https://developer.nvidia.com/blog/nvidia-nemo-accelerates-llm-innovation-with-hybrid-state-space-model-support/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>