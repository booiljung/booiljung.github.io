<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.2 장기 의존성 문제(Long-Range Dependency)와 HiPPO 이론</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.2 장기 의존성 문제(Long-Range Dependency)와 HiPPO 이론</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>2.2 장기 의존성 문제(Long-Range Dependency)와 HiPPO 이론</span></nav>
                </div>
            </header>
            <article>
                <h1>2.2 장기 의존성 문제(Long-Range Dependency)와 HiPPO 이론</h1>
<p>시퀀스 모델링(Sequence Modeling)의 역사는 곧 ’기억(Memory)’과의 투쟁이라 해도 과언이 아니다. 인공지능이 인간의 언어를 이해하고, 복잡한 시계열 데이터를 분석하며, 나아가 긴 문맥 속에서 인과관계를 추론하기 위해서는 과거의 정보를 현재까지 온전하게 보존하는 능력이 필수적이다. 그러나 딥러닝의 태동기부터 지금까지, 이 ‘장기 의존성(Long-Range Dependency, LRD)’ 문제는 연구자들에게 가장 거대한 장벽으로 존재해왔다. 트랜스포머(Transformer) 아키텍처가 어텐션(Attention) 메커니즘을 통해 이 문제를 획기적으로 개선한 것은 사실이나, 시퀀스 길이의 제곱(<span class="math math-inline">O(N^2)</span>)에 비례하는 연산 비용과 메모리 한계는 여전히 물리적인 제약으로 남아 있다.</p>
<p>이러한 배경 속에서 등장한 <strong>HiPPO (High-Order Polynomial Projection Operators)</strong> 이론은 단순히 기존 모델의 성능을 개선하는 차원을 넘어, 기억을 다루는 수학적 패러다임 자체를 근본적으로 재정의했다. 알버트 구(Albert Gu)와 크리스토퍼 레(Christopher Ré) 등이 제안한 이 이론은 “과거를 어떻게 기억할 것인가?“라는 질문에 대해, 이산적인(Discrete) 데이터 포인트의 저장이 아닌, 연속적인(Continuous) 함수 근사(Function Approximation)라는 새로운 관점을 제시한다.1 본 장에서는 순환 신경망(RNN)이 겪었던 기억 소실의 근본 원인을 진단하고, 이를 극복하기 위해 도입된 HiPPO 이론의 수학적 배경, 르장드르 다항식(Legendre Polynomials)을 이용한 최적 투영 메커니즘, 그리고 이것이 어떻게 현대적인 상태 공간 모델(SSM)과 Mamba 아키텍처의 핵심 기반이 되었는지를 심층적으로 분석한다.</p>
<h2>1.  기억의 본질적 난제: 기울기 소실과 이산 시간의 한계</h2>
<p>전통적인 시퀀스 모델링, 특히 RNN(Recurrent Neural Network)과 그 변형인 LSTM(Long Short-Term Memory), GRU(Gated Recurrent Unit)는 시간을 <span class="math math-inline">t=1, 2, \dots</span>와 같이 이산적인 단계(Step)의 연속으로 간주한다. 이러한 모델들은 각 시점 <span class="math math-inline">t</span>에서 입력 <span class="math math-inline">x_t</span>와 이전 시점의 은닉 상태(Hidden State) <span class="math math-inline">h_{t-1}</span>를 받아 현재의 상태 <span class="math math-inline">h_t</span>를 갱신하는 점화식(Recurrence) 구조를 갖는다.<br />
<span class="math math-display">
h_t = \sigma(W_h h_{t-1} + W_x x_t + b)
</span><br />
여기서 <span class="math math-inline">\sigma</span>는 비선형 활성화 함수, <span class="math math-inline">W</span>는 가중치 행렬이다. 이 구조는 직관적이지만, 역전파(Backpropagation) 과정에서 치명적인 약점을 노출한다. 시간을 거슬러 올라가며 기울기(Gradient)를 계산할 때, 가중치 행렬 <span class="math math-inline">W_h</span>가 반복적으로 곱해지기 때문이다. 만약 <span class="math math-inline">W_h</span>의 고유값(Eigenvalue)이 1보다 작으면 기울기는 지수적(Exponentially)으로 0에 수렴하여 소멸하고(Vanishing Gradient), 1보다 크면 발산한다(Exploding Gradient). LSTM이 게이팅(Gating) 메커니즘을 통해 이를 어느 정도 완화했음에도 불구하고, 수천, 수만 스텝 이상의 아주 먼 과거 정보를 보존하는 것은 여전히 난제로 남았다.2</p>
<p>HiPPO 이론은 이 문제의 원인을 ‘기억을 다루는 방식’ 자체에서 찾는다. 기존 RNN이 이전 상태를 단순히 비선형 변환하여 넘겨주는 방식이라면, HiPPO는 “과거의 모든 입력 데이터를 하나의 함수로 보고, 이를 가장 잘 설명하는 다항식 계수들을 유지하자“는 접근을 취한다. 이는 기억의 문제를 <strong>‘온라인 함수 근사(Online Function Approximation)’</strong> 문제로 치환하는 혁신적인 발상이다.2</p>
<h3>1.1  연속 시간(Continuous-Time)으로의 관점 전환</h3>
<p>데이터가 비록 이산적인 타임스탬프로 수집된다 하더라도, 그 기저에 깔린 현상은 연속적인 시간 속에서 발생한다. HiPPO는 이산적인 시퀀스 <span class="math math-inline">u_k</span>를 처리하기에 앞서, 이를 잠재적인 연속 함수 <span class="math math-inline">f(t)</span>로 모델링한다. 연속 시간 영역에서의 모델링은 다음과 같은 강력한 이점을 제공한다.</p>
<ol>
<li><strong>타임스케일 강건성(Timescale Robustness):</strong> 입력 신호의 속도가 변하거나(예: 음성 속도 변화), 샘플링 간격이 불규칙하더라도(Irregular Sampling), 연속 함수 모델은 수학적으로 일관된 처리가 가능하다.1</li>
<li><strong>수학적 도구의 활용:</strong> 미적분학, 특히 직교 다항식(Orthogonal Polynomials)과 미분 방정식(ODE) 이론을 직접적으로 적용하여 ’기억’을 최적화(Optimization) 문제로 정의할 수 있다.</li>
</ol>
<h2>2.  온라인 함수 근사(Online Function Approximation)와 힐베르트 공간</h2>
<p>HiPPO의 핵심 목표는 시간 <span class="math math-inline">t</span>까지 들어온 입력 함수 <span class="math math-inline">f(\tau)</span> (<span class="math math-inline">0 \le \tau \le t</span>)의 전체 역사를 고정된 크기 <span class="math math-inline">N</span>의 메모리 벡터 <span class="math math-inline">c(t) \in \mathbb{R}^N</span>으로 압축하는 것이다. 이때 정보의 손실을 최소화하기 위해 ’근사 오차(Approximation Error)’를 정의해야 하며, 이는 함수 공간(Function Space)인 힐베르트 공간(Hilbert Space)에서의 내적(Inner Product)과 측도(Measure)를 통해 정식화된다.</p>
<h3>2.1  측도(Measure)와 가중치</h3>
<p>임의의 시점 <span class="math math-inline">t</span>에서, 과거의 정보들에 대해 어느 정도의 중요도를 부여할 것인가를 결정하는 것이 바로 **측도 <span class="math math-inline">\mu(t)</span>**이다. HiPPO 프레임워크는 측도의 정의에 따라 다양한 기억 메커니즘을 유도할 수 있음을 보여준다.1</p>
<p>근사 문제는 다음과 같이 정의된다. <span class="math math-inline">N</span>차원 다항식 공간 <span class="math math-inline">\mathcal{G}</span> 내의 다항식 <span class="math math-inline">g^{(t)}</span>를 찾되, 입력 함수 <span class="math math-inline">f</span>와의 차이를 측도 <span class="math math-inline">\mu(t)</span>에 대해 최소화하는 것이다.<br />
<span class="math math-display">
\min_{g \in \mathcal{G}} \| f_{\le t} - g \|_{\mu(t)}^2 = \min_{g \in \mathcal{G}} \int_{0}^{t} |f(x) - g(x)|^2 d\mu(t)(x)
</span><br />
이 최소화 문제의 해는 힐베르트 공간의 투영 정리(Projection Theorem)에 의해 유일하게 결정된다. 즉, 메모리 벡터 <span class="math math-inline">c(t)</span>는 입력 함수 <span class="math math-inline">f</span>를 기저 다항식들에 대해 투영(Projection)한 계수(Coefficients)들의 집합이 된다.</p>
<h3>2.2  직교 다항식(Orthogonal Polynomials)의 기저 선정</h3>
<p>근사를 위한 기저 함수로는 <strong>직교 다항식</strong>이 사용된다. 직교 다항식은 서로 다른 차수의 다항식들이 주어진 측도 하에서 내적이 0이 되는 성질을 가진다. 이는 각 계수 <span class="math math-inline">c_n(t)</span>를 독립적으로 계산할 수 있게 해주며, 수치적 안정성을 보장한다. HiPPO 이론에서는 주로 **르장드르 다항식(Legendre Polynomials)**이 사용되는데, 이는 구간 내에서 균등한 가중치를 갖는 측도와 관련이 깊다.5</p>
<p>메모리 벡터 <span class="math math-inline">c(t)</span>의 <span class="math math-inline">n</span>번째 요소 <span class="math math-inline">c_n(t)</span>는 다음과 같이 표현된다.<br />
<span class="math math-display">
c_n(t) = \langle f_{\le t}, p_n^{(t)} \rangle_{\mu(t)}
</span><br />
여기서 <span class="math math-inline">p_n^{(t)}</span>는 시간 <span class="math math-inline">t</span>에 맞게 스케일링되거나 이동된 <span class="math math-inline">n</span>차 직교 다항식 기저이다.</p>
<h2>3.  HiPPO-LegS: 스케일링된 르장드르(Scaled Legendre) 시스템</h2>
<p>HiPPO 프레임워크 내에서 가장 중요하고 널리 사용되는 변형은 바로 **HiPPO-LegS (Scaled Legendre)**이다. 이는 2.2장의 핵심 주제인 장기 의존성 문제 해결의 열쇠를 쥐고 있는 모델이다.</p>
<h3>3.1  슬라이딩 윈도우 vs. 전체 역사(Full History)</h3>
<p>기존의 많은 시계열 모델(예: LMU, Legendre Memory Unit)은 고정된 크기의 윈도우 $$ 내의 정보만을 근사하는 방식을 취했다. 이를 HiPPO 프레임워크에서는 **HiPPO-LegT (Translated Legendre)**라 부른다.3 LegT는 최근 정보에 집중하는 데에는 유리하지만, 윈도우 크기 <span class="math math-inline">W</span>를 벗어난 오래된 정보는 완전히 망각한다는 치명적인 단점이 있다.</p>
<p>반면, <strong>HiPPO-LegS</strong>는 시간 <span class="math math-inline">t</span>가 흐름에 따라 적분 구간 <span class="math math-inline">[0, t]</span> 전체를 대상으로 균등한 가중치를 부여하는 측도(Scaled Measure)를 사용한다.1</p>
<ul>
<li><strong>측도:</strong> <span class="math math-inline">\mu^{(t)}(x) = \frac{1}{t} \mathbb{I}_{[0, t]}(x)</span> (구간 <span class="math math-inline">[0, t]</span>에서의 균등 분포)</li>
<li><strong>의미:</strong> 시간이 지날수록(<span class="math math-inline">t</span>가 커질수록) 과거의 특정 시점 <span class="math math-inline">x</span>가 차지하는 비중(<span class="math math-inline">1/t</span>)은 줄어들지만, 결코 0이 되어 사라지지는 않는다. 즉, <strong>정보가 압축(Compression)될 뿐 소실되지는 않는다.</strong></li>
</ul>
<p>이러한 특성 덕분에 HiPPO-LegS는 이론적으로 무한한 길이의 문맥을 처리할 수 있는 잠재력을 갖게 된다. 이는 “모든 역사를 기억하라“는 HiPPO의 철학을 가장 잘 대변하는 구현체이다.</p>
<h3>2.2.3.2 HiPPO-LegS ODE의 유도</h3>
<p>HiPPO의 천재성은 매 시점마다 적분을 처음부터 다시 계산하는 것이 아니라, 계수 <span class="math math-inline">c(t)</span>가 만족하는 미분 방정식(ODE)을 찾아내어 실시간으로 갱신한다는 데 있다. 투영 계수 <span class="math math-inline">c(t)</span>의 시간 도함수 <span class="math math-inline">\dot{c}(t)</span>를 구하기 위해 라이프니츠 적분 규칙과 르장드르 다항식의 재귀 관계를 적용하면, 다음과 같은 선형 상태 공간 형태(Linear State Space Form)의 ODE를 얻을 수 있다.3<br />
<span class="math math-display">
\frac{d}{dt} c(t) = -\frac{1}{t} A c(t) + \frac{1}{t} B f(t)
</span><br />
이 식은 HiPPO-LegS의 동역학을 완벽하게 기술한다. 여기서 주목할 점은 <span class="math math-inline">1/t</span>라는 항이다. 이 항은 시간이 지남에 따라 상태 갱신의 속도를 조절하는 역할을 하며, 이는 뒤에서 설명할 타임스케일 강건성의 수학적 기반이 된다.</p>
<h3>2.2.3.3 HiPPO 행렬 <span class="math math-inline">A</span>의 구조와 의미</h3>
<p>위 ODE에서 등장하는 행렬 <span class="math math-inline">A \in \mathbb{R}^{N \times N}</span>는 <strong>HiPPO 행렬</strong>이라 불리며, 다음과 같은 매우 독특하고 구체적인 구조를 갖는다.3<br />
<span class="math math-display">
A_{nk} = \begin{cases} (2n+1)^{1/2}(2k+1)^{1/2} &amp; \text{if } n &gt; k \\ n+1 &amp; \text{if } n = k \\ 0 &amp; \text{if } n &lt; k \end{cases}
</span></p>
<p><span class="math math-display">
B_n = (2n+1)^{1/2}
</span></p>
<p>이 행렬 <span class="math math-inline">A</span>는 하삼각 행렬(Lower Triangular Matrix)에 가까운 형태(엄밀히는 대각 성분 포함 하삼각에 <span class="math math-inline">2k+1</span> 항들이 곱해진 형태)를 띤다.</p>
<ul>
<li><strong>구조적 해석:</strong> <span class="math math-inline">n &gt; k</span>인 경우에만 값이 존재한다는 것은, 고차(High-order) 다항식의 계수 변화가 저차(Low-order) 다항식의 계수로부터 영향을 받는다는 것을 의미한다. 즉, 정보가 저차 모멘트(평균, 추세 등)에서 고차 모멘트(상세한 변동)로 전파되는 구조를 갖는다.</li>
<li><strong>고정된 파라미터:</strong> 중요한 점은 행렬 <span class="math math-inline">A</span>와 벡터 <span class="math math-inline">B</span>가 학습 가능한 파라미터가 아니라, 르장드르 다항식의 수학적 성질에 의해 <strong>고정된(Fixed) 상수</strong>라는 것이다. HiPPO는 학습을 통해 기억하는 법을 배우는 것이 아니라, **수학적으로 최적화된 기억 메커니즘을 모델에 주입(Inject)**하는 것이다.2</li>
</ul>
<p>이 HiPPO 행렬 <span class="math math-inline">A</span>는 이후 S4(Structured State Spaces) 모델과 Mamba 모델의 상태 전이 행렬 초기화에 사용되며, 모델이 학습 초기부터 장기 의존성을 포착할 수 있게 하는 결정적인 귀납적 편향(Inductive Bias)으로 작용한다.8</p>
<h2>2.2.4 장기 의존성 문제의 수학적 해결</h2>
<p>HiPPO 이론이 장기 의존성 문제를 해결하는 메커니즘은 기존 RNN의 한계를 정면으로 돌파한다.</p>
<h3>2.2.4.1 기울기 소실(Vanishing Gradient)의 극복</h3>
<p>표준 RNN에서 <span class="math math-inline">t</span> 스텝 떨어진 과거의 정보가 현재에 미치는 영향(기울기)은 <span class="math math-inline">W^t</span>에 비례하여 지수적으로 감소한다(<span class="math math-inline">\lambda^t</span>). 그러나 HiPPO-LegS 시스템에서는 이 감쇠(Decay)가 **다항적(Polynomially)**으로 일어난다.</p>
<p>HiPPO 논문의 <strong>Proposition 5</strong>는 이에 대한 이론적 보증을 제공한다.</p>
<blockquote>
<p>“어떤 시점 <span class="math math-inline">t_0 &lt; t_1</span>에 대해, HiPPO-LegS 연산자의 <span class="math math-inline">t_1</span> 시점 출력에 대한 <span class="math math-inline">t_0</span> 시점 입력의 기울기 노름(Gradient Norm)은 <span class="math math-inline">\Theta(1/t_1)</span>의 오더를 따른다.“2</p>
</blockquote>
<p>지수적 감쇠(<span class="math math-inline">e^{-\alpha t}</span>)는 순식간에 0에 가까워지지만, 다항적 감쇠(<span class="math math-inline">1/t</span>)는 훨씬 느리게 줄어든다. 이는 수천, 수만 스텝 이전의 정보라 하더라도 그 기울기가 완전히 사라지지 않고 유의미한 값으로 살아남아 역전파될 수 있음을 의미한다. 이것이 바로 HiPPO 기반 모델들이 극도로 긴 시퀀스(Long Sequence)를 학습할 수 있는 근본적인 이유이다.2</p>
<h3>2.2.4.2 타임스케일 강건성(Timescale Robustness)</h3>
<p>HiPPO-LegS의 또 다른 강력한 특징은 입력 신호의 속도 변화에 강하다는 점이다. ODE 식 <span class="math math-inline">\dot{c} = -\frac{1}{t}Ac + \frac{1}{t}Bf</span>는 시간 스케일 <span class="math math-inline">t</span>에 대해 불변성(Invariance)을 갖는다. 이를 Dilation Equivariance라 한다.1</p>
<p>예를 들어, 1초 동안 “안녕하세요“라고 말한 오디오 신호와 2초 동안 느리게 “안-녕-하-세-요“라고 말한 신호를 처리할 때, HiPPO-LegS는 내부적으로 동일한 함수 형상(Shape)을 인식하여 유사한 메모리 표현(Representation)을 생성할 수 있다. 이는 고정된 샘플링 속도나 시퀀스 길이에 얽매였던 기존 모델들과 구별되는 큰 장점이다.</p>
<h3>2.2.4.3 정보 압축의 물리적 해석</h3>
<p>메모리 벡터 <span class="math math-inline">c(t)</span>의 각 요소는 물리적으로 무엇을 의미하는가? <span class="math math-inline">c_0(t)</span>는 전체 입력의 평균(DC 성분)을, <span class="math math-inline">c_1(t)</span>는 선형적인 추세(Linear Trend)를, <span class="math math-inline">c_2(t)</span>는 2차 곡선의 곡률을 나타내는 식이다.1 차수 <span class="math math-inline">N</span>이 높아질수록 더 미세한 고주파(High-frequency) 변동을 포착한다. 따라서 <span class="math math-inline">N</span>을 충분히 크게 잡으면 원본 신호를 거의 완벽하게 복원(Reconstruction)할 수 있으며, <span class="math math-inline">N</span>을 작게 잡으면 신호의 주요 특징(Low-frequency)만을 매끄럽게 요약(Smoothing)하여 저장하게 된다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>RNN / LSTM</strong></th><th><strong>HiPPO-LegS</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>기억 방식</strong></td><td>이전 상태의 비선형 변환</td><td>과거 이력의 최적 다항식 근사</td><td></td></tr>
<tr><td><strong>과거 가중치</strong></td><td>지수적 감쇠 (Exponential Decay)</td><td>다항적 감쇠 (<span class="math math-inline">1/t</span>)</td><td>장기 기억 보존의 핵심</td></tr>
<tr><td><strong>시간 관점</strong></td><td>이산적 단계 (Discrete Steps)</td><td>연속적 함수 (Continuous Function)</td><td>샘플링 불변성 확보</td></tr>
<tr><td><strong>파라미터</strong></td><td>학습 가능한 가중치 행렬</td><td>고정된 수학적 상수 행렬 (<span class="math math-inline">A, B</span>)</td><td>귀납적 편향 주입</td></tr>
<tr><td><strong>윈도우</strong></td><td>고정 윈도우 또는 흐릿한 기억</td><td>전체 역사 (Full History) 스케일링</td><td>무한 문맥 대응 가능</td></tr>
</tbody></table>
<h2>2.2.5 이산화(Discretization)와 시스템 구현</h2>
<p>HiPPO 이론은 연속 시간 영역에서 유도되었지만, 실제 AI 모델은 디지털 하드웨어(GPU/TPU) 상에서 이산적인 데이터(토큰, 시계열 샘플)를 처리한다. 따라서 연속 ODE를 이산적인 점화식으로 변환하는 <strong>이산화(Discretization)</strong> 과정이 필수적이다.</p>
<p>연속 시스템 <span class="math math-inline">\dot{x}(t) = A(t)x(t) + B(t)u(t)</span>를 이산 시간 시스템 <span class="math math-inline">x_{k+1} = \bar{A}_k x_k + \bar{B}_k u_k</span>로 변환하기 위해, HiPPO는 **일반화된 쌍선형 변환(Generalized Bilinear Transform, GBT)**이나 <strong>Zero-Order Hold (ZOH)</strong> 방식을 사용한다.3</p>
<h3>2.2.5.1 단계 크기(Step Size) <span class="math math-inline">\Delta t</span>의 역할</h3>
<p>이산화 과정에서 샘플링 간격인 단계 크기 <span class="math math-inline">\Delta t</span>는 매우 중요한 역할을 한다. HiPPO-LegS에서 <span class="math math-inline">\Delta t</span>는 고정된 상수가 아니라 입력에 따라 달라질 수 있다. 특히 Mamba 아키텍처로 넘어가면서, 이 <span class="math math-inline">\Delta</span>를 입력 <span class="math math-inline">x_t</span>에 대한 함수 <span class="math math-inline">\Delta(x_t)</span>로 만듦으로써 모델이 정보의 흐름을 동적으로 제어할 수 있게 되었다. 즉, <span class="math math-inline">\Delta</span>가 크면 현재 입력을 오랫동안 기억(상태 반영 비중 증가)하고, <span class="math math-inline">\Delta</span>가 작으면 현재 입력을 무시(이전 상태 유지)하는 식의 게이팅 효과를 낼 수 있다. 하지만 순수 HiPPO 이론 단계에서는 수학적으로 유도된 고정된 <span class="math math-inline">\Delta</span> 혹은 시계열 데이터의 타임스탬프 간격을 그대로 사용하여 “있는 그대로의 시간“을 모델링한다.11</p>
<h2>2.2.6 HiPPO에서 S4, 그리고 Mamba로의 진화적 연결</h2>
<p>HiPPO 이론은 그 자체로도 강력한 성능을 보였지만, 딥러닝 모델의 레이어로서 효율적으로 사용되기 위해서는 몇 가지 산을 넘어야 했다. 이 과정이 바로 S4와 Mamba로 이어지는 기술적 진보의 역사이다.</p>
<h3>2.2.6.1 계산 복잡도의 문제와 S4의 등장</h3>
<p>HiPPO 행렬 <span class="math math-inline">A</span>는 <span class="math math-inline">N \times N</span> 크기의 밀집 행렬(Dense Matrix)이다. 이를 단순한 점화식으로 계산하면 스텝당 <span class="math math-inline">O(N^2)</span>의 연산이 필요하다. 이는 트랜스포머의 어텐션보다는 낫지만, <span class="math math-inline">N</span>이 커질수록(더 정밀한 기억을 위해) 부담이 된다.</p>
<p>이를 해결하기 위해 등장한 S4 (Structured State Spaces) 모델은 HiPPO 행렬을 NPLR (Normal Plus Low-Rank) 형태로 분해할 수 있음을 발견했다.12<br />
<span class="math math-display">
A = V \Lambda V^* - P Q^\top
</span><br />
이러한 구조적 특성을 이용하면, 상태 갱신과 컨볼루션 연산을 <span class="math math-inline">O(N \log N)</span> 혹은 <span class="math math-inline">O(N)</span>의 복잡도로 수행할 수 있다. S4는 HiPPO-LegS 행렬을 초기화 값으로 사용하여, 학습 시작부터 장기 기억 능력을 갖춘 상태로 모델을 최적화했다.</p>
<h3>2.2.6.2 대각화(Diagonalization)와 S4D</h3>
<p>S4 이후 연구자들은 복잡한 NPLR 구조 대신, 더 단순한 대각 행렬(Diagonal Matrix)만으로도 HiPPO의 성능을 낼 수 있는지 탐구했다. 그 결과 **S4D (Structured State Space with Diagonalization)**가 제안되었다. S4D는 HiPPO 행렬을 복소수 영역에서 대각화하여 근사함으로써, 구현 난이도를 획기적으로 낮추면서도 성능을 유지했다.13 Mamba 역시 이러한 대각화된 HiPPO 초기화(S4D-Lin, S4D-Real)를 기본으로 채택하고 있다.8</p>
<h3>2.2.6.3 선택적(Selective) SSM으로의 도약: Mamba</h3>
<p>HiPPO와 S4가 “모든 과거를 효율적으로 기억하는 방법“을 제공했다면, Mamba는 여기에 “무엇을 기억하고 무엇을 망각할지 선택하는 지능“을 더했다. Mamba의 **선택적 SSM(Selective SSM)**은 HiPPO의 연속 시간 기억 메커니즘을 기반으로 하되, 이산화 파라미터(<span class="math math-inline">\Delta, B, C</span>)를 입력에 따라 가변적으로 만듦으로써(Input-Dependent), 불필요한 정보는 과감히 버리고 중요한 정보만을 HiPPO 메모리 공간에 압축 저장하는 능력을 갖추었다. 하지만 Mamba의 선택적 메커니즘이 제대로 작동하기 위해서는, 그 기저에 깔린 상태 공간이 장기 정보를 손실 없이 보존할 수 있는 잠재력(Capacity)을 갖추어야 하며, 그 잠재력은 전적으로 HiPPO 행렬의 수학적 성질에서 기인한다.15 즉, HiPPO 없이는 Mamba의 장기 기억도 불가능하다.</p>
<h2>2.2.7 실증적 검증: 벤치마크가 증명한 우월성</h2>
<p>HiPPO 이론의 우수성은 단순한 수학적 증명에 그치지 않고, 가혹한 벤치마크 테스트를 통해 입증되었다.</p>
<ol>
<li><strong>Permuted MNIST (pMNIST):</strong> 이미지의 픽셀 순서를 무작위로 섞은 후 순차적으로 입력하여 숫자를 분류하는 이 작업은, 지역적 패턴(Local Structure)을 파괴하고 오직 장기 의존성(픽셀 간의 먼 거리 관계)에 의존해야만 풀 수 있는 난제이다. HiPPO-LegS는 이 태스크에서 98.3%라는 경이적인 정확도를 기록하며, 당시의 LSTM(약 89-90%)과 트랜스포머(약 97%)를 모두 압도하고 SOTA(State-of-the-Art)를 갱신했다.1</li>
<li><strong>Copying Task:</strong> 긴 시퀀스 끝에 특정 패턴을 기억해내는 작업에서도 HiPPO는 훈련 속도와 정확도 면에서 타 모델들을 압도했다. 특히 시퀀스 길이가 늘어날수록 LSTM은 성능이 급격히 저하되는 반면, HiPPO는 일관된 성능을 유지했다.16</li>
<li><strong>궤적 분류(Trajectory Classification):</strong> 시계열 데이터의 타임스탬프가 누락되거나 왜곡된 상황에서도 HiPPO는 연속 시간 모델링의 이점을 살려 높은 분류 정확도를 보였다. 이는 HiPPO가 단순히 순서를 기억하는 것이 아니라, 데이터가 그리는 ’함수의 궤적’을 이해하고 있음을 방증한다.2</li>
</ol>
<h2>2.2.8 결론 및 시사점</h2>
<p>2.2장에서 살펴본 HiPPO 이론은 시퀀스 모델링 분야에 “기억이란 무엇인가?“라는 근원적인 질문을 던지고, 이에 대해 “기억은 최적 다항식 투영을 통한 온라인 함수 근사“라는 우아하고도 강력한 수학적 해답을 제시했다.</p>
<ul>
<li>HiPPO는 이산 시간 RNN의 고질적인 병폐인 기울기 소실 문제를 연속 시간 ODE와 다항적 기울기 감쇠 특성으로 해결했다.</li>
<li>르장드르 다항식과 측도 이론을 결합하여, 과거의 모든 정보를 고정된 크기의 벡터에 최적으로 압축하는 HiPPO-LegS 알고리즘을 탄생시켰다.</li>
<li>이러한 이론적 토대는 S4를 거쳐 Mamba로 이어지는 ‘포스트 트랜스포머’ 시대의 핵심 기술적 기반이 되었다.</li>
</ul>
<p>HiPPO 이론은 우리가 데이터를 바라보는 관점을 ’점(Point)’에서 ’선(Function)’으로 확장시켰다. 이 관점의 전환이야말로, Mamba가 수백만 토큰의 문맥을 다루면서도 선형 시간 복잡도(<span class="math math-inline">O(N)</span>)를 유지할 수 있게 만든, 가장 깊은 곳에 숨겨진 엔진이라 할 수 있다. 이제 우리는 이 엔진을 장착한 Mamba가 어떻게 실제 아키텍처로 구현되어 트랜스포머의 아성을 위협하게 되었는지, 다음 장들을 통해 구체적으로 살펴보게 될 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>HiPPO: Recurrent Memory with Optimal Polynomial Projections - Hazy Research, 12월 25, 2025에 액세스, https://hazyresearch.stanford.edu/blog/2020-12-05-hippo</li>
<li>[2008.07669] HiPPO: Recurrent Memory with Optimal Polynomial Projections - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/abs/2008.07669</li>
<li>HiPPO: Recurrent Memory with Optimal Polynomial Projections, 12월 25, 2025에 액세스, https://proceedings.neurips.cc/paper/2020/file/102f0bb6efb3a6128a3c750dd16729be-Paper.pdf</li>
<li>State-Space Models - Ernest K. Ryu, 12월 25, 2025에 액세스, https://ernestryu.com/courses/FM/SSM.pdf</li>
<li>HiPPO Matrices | Hung-Yueh Chiang, 12월 25, 2025에 액세스, https://hychiang.info/blog/2024/hippo_matrices/</li>
<li>HiPPO: Recurrent Memory with Optimal Polynomial Projections - NSF Public Access Repository, 12월 25, 2025에 액세스, https://par.nsf.gov/servlets/purl/10214620</li>
<li>How to Train Your HiPPO: State Space Models with Generalized Orthogonal Basis Projections - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/pdf/2206.12037</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2312.00752v2</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/pdf/2312.00752</li>
<li>HiPPO: Recurrent Memory with Optimal Polynomial Projections, 12월 25, 2025에 액세스, https://proceedings.neurips.cc/paper_files/paper/2020/file/102f0bb6efb3a6128a3c750dd16729be-Supplemental.pdf</li>
<li>Conceptual Questions regarding S4/HiPPO · Issue #40 · state-spaces/s4 - GitHub, 12월 25, 2025에 액세스, https://github.com/state-spaces/s4/issues/40</li>
<li>State Space Models for Event Cameras - arXiv, 12월 25, 2025에 액세스, https://arxiv.org/html/2402.15584v2</li>
<li>On the Parameterization and Initialization of Diagonal State Space Models, 12월 25, 2025에 액세스, https://papers.neurips.cc/paper_files/paper/2022/file/e9a32fade47b906de908431991440f7c-Paper-Conference.pdf</li>
<li>On the Parameterization and Initialization of Diagonal State Space Models - IBM Research, 12월 25, 2025에 액세스, https://research.ibm.com/publications/on-the-parameterization-and-initialization-of-diagonal-state-space-models</li>
<li>Mamba Simplified - Part 2 - S4 and Mamba - Prem AI Blog, 12월 25, 2025에 액세스, https://blog.premai.io/s4-and-mamba/</li>
<li>[Quick Review] HiPPO: Recurrent Memory with Optimal Polynomial Projections - Liner, 12월 25, 2025에 액세스, https://liner.com/review/hippo-recurrent-memory-with-optimal-polynomial-projections</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>