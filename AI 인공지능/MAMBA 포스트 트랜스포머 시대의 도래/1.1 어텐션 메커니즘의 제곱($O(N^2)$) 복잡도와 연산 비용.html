<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.1 어텐션 메커니즘의 제곱($O(N^2)$) 복잡도와 연산 비용</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.1 어텐션 메커니즘의 제곱($O(N^2)$) 복잡도와 연산 비용</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>1.1 어텐션 메커니즘의 제곱($O(N^2)$) 복잡도와 연산 비용</span></nav>
                </div>
            </header>
            <article>
                <h1>1.1 어텐션 메커니즘의 제곱(<span class="math math-inline">O(N^2)</span>) 복잡도와 연산 비용</h1>
<p>현대 인공지능의 지형도는 2017년 구글 브레인(Google Brain) 팀이 발표한 “Attention Is All You Need“라는 논문 하나로 완전히 재편되었다. 트랜스포머(Transformer) 아키텍처는 순환신경망(RNN)이 지배하던 시퀀스 모델링의 패러다임을 병렬 처리 기반의 어텐션(Attention) 메커니즘으로 전환시켰고, 이는 곧 GPT 시리즈와 같은 거대언어모델(LLM)의 폭발적인 성장을 견인하는 동력이 되었다.1 그러나 영광의 이면에는 치명적인 구조적 결함이 자리 잡고 있다. 트랜스포머를 왕좌에 올린 일등 공신인 ‘셀프 어텐션(Self-Attention)’ 메커니즘이, 아이러니하게도 모델의 확장을 가로막는 가장 거대한 장벽으로 작용하고 있다는 사실이다. 본 장에서는 트랜스포머 아키텍처가 긴 시퀀스를 처리할 때 직면하는 근본적인 한계인 제곱(<span class="math math-inline">O(N^2)</span>) 복잡도의 수학적 기원과 그로 인한 막대한 연산 비용의 실체를 철저하게 해부한다. 이는 단순한 알고리즘의 비효율성 문제를 넘어, 왜 우리가 트랜스포머를 넘어선 새로운 아키텍처, 즉 맘바(Mamba)와 같은 상태 공간 모델(SSM)을 모색해야만 하는지에 대한 기술적 당위성을 증명하는 과정이다.</p>
<h2>1.  셀프 어텐션의 수학적 해부와 제곱 복잡도의 기원</h2>
<p>트랜스포머의 연산 비용을 논리적으로 규명하기 위해서는 먼저 그 심장부인 ’스케일드 닷-프로덕트 어텐션(Scaled Dot-Product Attention)’의 연산 과정을 수학적으로 분해해야 한다. 어텐션 메커니즘은 입력 시퀀스의 모든 토큰이 서로를 참조하여 문맥을 파악하는 과정이다. 입력 시퀀스의 길이를 <span class="math math-inline">N</span>, 각 토큰의 임베딩 차원을 <span class="math math-inline">d</span>라고 정의할 때, 입력 행렬 <span class="math math-inline">X \in \mathbb{R}^{N \times d}</span>는 세 가지 다른 표현형인 쿼리(Query, <span class="math math-inline">Q</span>), 키(Key, <span class="math math-inline">K</span>), 밸류(Value, <span class="math math-inline">V</span>)로 변환된다.</p>
<h3>1.1 선형 투영(Linear Projection): 선형 복잡도의 구간</h3>
<p>어텐션 연산의 첫 단계는 입력 <span class="math math-inline">X</span>에 가중치 행렬 <span class="math math-inline">W^Q, W^K, W^V \in \mathbb{R}^{d \times d}</span>를 곱하여 <span class="math math-inline">Q, K, V</span>를 생성하는 선형 투영 과정이다.3<br />
<span class="math math-display">
Q = XW^Q, \quad K = XW^K, \quad V = XW^V
</span><br />
이 단계에서의 연산 복잡도는 행렬 곱셈(Matrix Multiplication)에 의해 결정된다. <span class="math math-inline">N \times d</span> 크기의 행렬과 <span class="math math-inline">d \times d</span> 크기의 행렬을 곱하는 연산은 <span class="math math-inline">O(N \cdot d^2)</span>의 연산량(FLOPs)을 요구한다.3 여기서 주목해야 할 점은 이 단계의 복잡도가 시퀀스 길이 <span class="math math-inline">N</span>에 대해 **선형(Linear)**이라는 사실이다. <span class="math math-inline">N</span>이 2배가 되면 연산량도 정확히 2배가 된다. 만약 트랜스포머가 이와 같은 선형 연산만으로 구성되었다면, 긴 문맥 처리는 지금처럼 심각한 난제가 되지 않았을 것이다. 이 단계까지는 GPU의 병렬 처리 능력을 십분 활용할 수 있는 효율적인 구간이다.</p>
<h3>1.2 <span class="math math-inline">QK^T</span> 연산: 제곱 폭발(Quadratic Explosion)의 발화점</h3>
<p>문제의 핵심이자 ’트랜스포머의 저주’가 시작되는 지점은 바로 쿼리와 키의 내적을 통해 어텐션 스코어(Attention Score)를 계산하는 단계다. 셀프 어텐션의 정의에 따라, 시퀀스 내의 모든 토큰은 자기 자신을 포함한 다른 모든 토큰과의 관계(Similarity)를 계산해야 한다. 이를 행렬 연산으로 표현하면 <span class="math math-inline">Q</span>와 <span class="math math-inline">K</span>의 전치 행렬(<span class="math math-inline">K^T</span>)을 곱하는 것이 된다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
이 수식은 단순해 보이지만, 차원 분석(Dimensional Analysis)을 수행하면 그 안에 숨겨진 비용의 실체가 드러난다.</p>
<ol>
<li>어텐션 스코어 행렬 생성 (<span class="math math-inline">QK^T</span>):</li>
</ol>
<p><span class="math math-inline">Q</span> 행렬은 <span class="math math-inline">N \times d</span> 크기를 가지며, <span class="math math-inline">K^T</span> 행렬은 <span class="math math-inline">d \times N</span> 크기를 가진다. 두 행렬을 곱하면 결과물은 <span class="math math-inline">N \times N</span> 크기의 정사각 행렬이 된다.3 이 과정에서 수행되는 연산의 횟수는 약 <span class="math math-inline">2N^2d</span> (곱셈과 덧셈 포함)이다. 즉, 연산 복잡도가 <span class="math math-inline">O(N^2 \cdot d)</span>가 된다. 시퀀스 길이 <span class="math math-inline">N</span>이 증가함에 따라 연산량은 제곱으로 폭증한다. 예를 들어, 시퀀스 길이가 2배가 되면(<span class="math math-inline">2N</span>), 연산량은 4배(<span class="math math-inline">4N^2</span>)가 되고, 10배가 되면 100배가 된다.7</p>
<ol start="2">
<li>소프트맥스(Softmax) 및 정규화:</li>
</ol>
<p>생성된 <span class="math math-inline">N \times N</span> 크기의 어텐션 스코어 행렬에 대해 각 행(row)별로 소프트맥스 연산을 수행한다. 이 연산은 <span class="math math-inline">N^2</span>개의 모든 요소에 대해 지수 함수(exponential)를 계산하고 합계를 나누는 과정을 포함하므로 <span class="math math-inline">O(N^2)</span>의 복잡도를 가진다.3 비록 <span class="math math-inline">d</span> 항이 붙지 않아 행렬 곱셈보다는 가벼워 보일 수 있으나, 뒤에서 논의할 메모리 대역폭(Memory Bandwidth) 관점에서는 <span class="math math-inline">N^2</span> 데이터를 읽고 써야 하므로 매우 치명적인 비용을 유발한다.5</p>
<ol start="3">
<li>가중 합 계산 (<span class="math math-inline">Score \cdot V</span>):</li>
</ol>
<p>소프트맥스를 통과한 <span class="math math-inline">N \times N</span> 확률 행렬과 <span class="math math-inline">N \times d</span> 크기의 <span class="math math-inline">V</span> 행렬을 곱하여 최종 출력을 산출한다. 이 연산 역시 <span class="math math-inline">N \times N</span> 행렬과 <span class="math math-inline">N \times d</span> 행렬의 곱셈이므로 <span class="math math-inline">O(N^2 \cdot d)</span>의 복잡도를 가진다.3</p>
<p>결과적으로, 단 하나의 어텐션 헤드(Head)에서 발생하는 시간 복잡도는 <span class="math math-inline">O(N^2 d)</span>로 요약된다. 전체 트랜스포머 레이어의 복잡도는 <span class="math math-inline">O(N^2 d + Nd^2)</span>로 표현할 수 있다.9 초기 트랜스포머 모델들이 다루던 번역 작업과 같이 문장 길이가 짧은 경우(<span class="math math-inline">N \ll d</span>), <span class="math math-inline">d^2</span> 항이 지배적이어서 <span class="math math-inline">N^2</span>의 영향력이 크지 않았다. 그러나 문서 요약, 장편 소설 생성, 유전체 분석 등 <span class="math math-inline">N</span>이 수만에서 수백만에 이르는 ‘롱 컨텍스트(Long Context)’ 영역으로 넘어오면서 <span class="math math-inline">N^2</span> 항은 전체 연산 비용을 완전히 장악하게 되었다.6</p>
<h2>2.  메모리 복잡도와 활성화 텐서(Activation Tensor)의 비대화</h2>
<p>연산 속도(FLOPs)보다 더욱 시급하고 치명적인 문제는 **메모리(Memory)**다. 현대 AI 가속기(GPU, TPU)의 발전 역사를 살펴보면, 연산 능력(Tensor Core Performance)은 기하급수적으로 증가한 반면, 메모리 용량(VRAM Capacity)과 대역폭(Bandwidth)의 증가는 상대적으로 더디게 진행되었다. 이러한 하드웨어 발전의 불균형은 트랜스포머의 <span class="math math-inline">O(N^2)</span> 메모리 복잡도를 더욱 고통스러운 병목으로 만든다.</p>
<h3>2.1 어텐션 행렬(Attention Matrix)의 공간 점유: <span class="math math-inline">N^2</span>의 물리적 무게</h3>
<p>표준 어텐션 구현에서 <span class="math math-inline">QK^T</span> 연산의 결과물인 <span class="math math-inline">N \times N</span> 어텐션 스코어 행렬(<span class="math math-inline">P</span>)은 메모리에 ‘물리적으로’ 실존해야 한다.7 훈련(Training) 과정에서 역전파(Backpropagation)를 수행하기 위해서는 순전파(Forward pass) 때 계산된 어텐션 확률값들이 반드시 저장되어 있어야 그라디언트(Gradient)를 계산할 수 있기 때문이다. 이를 ’활성화 텐서(Activation Tensor)’라고 하며, 긴 시퀀스 학습 시 모델 파라미터보다 훨씬 더 많은 메모리를 점유하는 주범이다.11</p>
<p>메모리 요구량을 수식으로 구체화해보자. 배치 크기(Batch Size) <span class="math math-inline">B</span>, 헤드 수 <span class="math math-inline">H</span>, 시퀀스 길이 <span class="math math-inline">N</span>이라고 할 때, 어텐션 행렬 하나를 저장하는 데 필요한 요소(element)의 수는 <span class="math math-inline">B \cdot H \cdot N^2</span>개다. 대부분의 학습에서 사용하는 FP16(16-bit Floating Point) 정밀도를 기준(2 bytes)으로 할 때, 필요한 메모리 용량(Bytes)은 다음과 같다.13<br />
<span class="math math-display">
\text{Memory}_{Attention} \approx 2 \times B \times H \times N^2 \text{ (Bytes)}
</span><br />
이 수식이 현실에서 어떤 의미를 가지는지 시뮬레이션해보면 그 심각성이 명확해진다. (가정: <span class="math math-inline">B=1</span>, <span class="math math-inline">H=32</span>, Precision=FP16)</p>
<p><strong>[표 1-1] 시퀀스 길이에 따른 단일 어텐션 레이어의 활성화 메모리 점유량</strong></p>
<table><thead><tr><th><strong>시퀀스 길이 (N)</strong></th><th><strong>어텐션 행렬 요소 수 (N2)</strong></th><th><strong>단일 레이어 메모리 (32 Heads)</strong></th><th><strong>비고 및 하드웨어 제약</strong></th></tr></thead><tbody>
<tr><td><strong>512</strong></td><td>262,144</td><td>약 16 MB</td><td>초기 BERT 모델 수준. 메모리 부담 미미함.</td></tr>
<tr><td><strong>2,048</strong></td><td>4,194,304</td><td>약 256 MB</td><td>GPT-3 수준. 관리 가능한 범위.</td></tr>
<tr><td><strong>8,192</strong></td><td>67,108,864</td><td><strong>4 GB</strong></td><td>소비자용 GPU(24GB)에서 부담 시작.</td></tr>
<tr><td><strong>32,768</strong></td><td>1,073,741,824</td><td><strong>64 GB</strong></td><td><strong>A100 80GB 단일 GPU 한계점 도달.</strong></td></tr>
<tr><td><strong>128,000</strong></td><td>16,384,000,000</td><td><strong>1 TB</strong></td><td><strong>현존 단일 GPU 처리 불가능 (OOM).</strong></td></tr>
<tr><td><strong>1,000,000</strong></td><td><span class="math math-inline">10^{12}</span></td><td><strong>60 TB</strong></td><td>슈퍼컴퓨터 클러스터 필요.</td></tr>
</tbody></table>
<p>위 표는 단 <strong>하나의 레이어</strong>에서 생성되는 중간 활성화 텐서의 크기만을 나타낸 것이다. 거대언어모델이 통상적으로 수십 개(예: GPT-3 175B는 96개 레이어)의 레이어를 가진다는 점을 고려하면, <span class="math math-inline">N=32k</span> 수준만 되어도 단순한 어텐션 매트릭스 저장만으로 수 테라바이트의 메모리가 필요하게 된다.14 이는 현존하는 최고 사양의 GPU인 NVIDIA H100(80GB)으로도 감당하기 힘든 수준이며, 학습 도중 발생하는 ‘Out of Memory (OOM)’ 오류의 가장 주된 원인이다.12</p>
<h3>2.2 활성화 메모리가 모델 크기를 압도하는 역설</h3>
<p>과거의 딥러닝 모델들은 모델 자체의 가중치(Weights)가 메모리의 대부분을 차지했다. 그러나 트랜스포머 기반의 롱 컨텍스트 모델링에서는 **활성화 메모리(Activation Memory)**가 모델 가중치 메모리를 압도하는 현상이 발생한다.11 모델 파라미터 수는 고정되어 있지만, 활성화 메모리는 입력 데이터의 길이 <span class="math math-inline">N</span>의 제곱에 비례하여 늘어나기 때문이다. 이는 모델 학습 시 배치 크기를 극도로 줄이거나(Batch size=1), 모델 병렬화(Model Parallelism)와 같은 복잡한 분산 처리 엔지니어링을 강제하는 원인이 되며 17, 결과적으로 시스템 전체의 효율성을 급격히 떨어뜨린다.</p>
<h2>3.  연산 비용의 물리적 한계: 메모리 벽(Memory Wall)과 대역폭</h2>
<p><span class="math math-inline">O(N^2)</span>의 문제는 단순히 GPU 코어가 계산을 많이 해야 한다는 것(Compute Bound)에 그치지 않는다. 더 근본적이고 해결하기 어려운 문제는 **데이터 이동(Data Movement)**에 있다. 현대 컴퓨팅 아키텍처에서 프로세서의 연산 속도는 메모리의 데이터 전송 속도보다 훨씬 빠르게 발전해왔다. 이를 <strong>메모리 벽(Memory Wall)</strong> 문제라 한다. 트랜스포머의 어텐션 메커니즘은 이 메모리 벽 문제에 가장 취약한 구조를 가지고 있다.18</p>
<h3>3.1 산술 강도(Arithmetic Intensity)와 어텐션의 비효율성</h3>
<p>알고리즘의 하드웨어 효율성은 종종 ’산술 강도(Arithmetic Intensity)’로 평가된다. 이는 메모리에서 1바이트의 데이터를 가져왔을 때(IO), 프로세서가 몇 번의 연산(FLOPs)을 수행하는지를 나타내는 비율이다.19</p>
<ul>
<li><strong>높은 산술 강도 (이상적):</strong> 데이터를 한 번 가져와서 수백, 수천 번 재사용하며 연산하는 경우. (예: 큰 차원의 행렬 곱셈, CNN의 합성곱 연산). 이 경우 성능은 GPU의 연산 속도(TFLOPS)에 의해 결정된다.</li>
<li><strong>낮은 산술 강도 (현실의 어텐션):</strong> 어텐션 연산, 특히 <span class="math math-inline">N \times N</span> 행렬을 다루는 과정은 산술 강도가 매우 낮다. <span class="math math-inline">N^2</span>개의 데이터를 메모리에서 읽어와서 소프트맥스(지수 함수 및 나눗셈)와 같은 비교적 가벼운 연산만 수행하고 다시 메모리에 써야 하기 때문이다.8</li>
</ul>
<p>NVIDIA A100 GPU를 기준으로 볼 때, 메모리 대역폭은 약 1.5 TB/s인 반면 연산 능력은 312 TFLOPS에 달한다. 이 균형점(Ratio)은 약 208이다.18 즉, 1바이트를 가져올 때마다 최소 208회의 연산을 수행해야 GPU를 100% 활용할 수 있다. 그러나 표준 어텐션 연산은 이 비율에 턱없이 미치지 못한다.</p>
<h3>3.2 HBM 병목 현상 (IO Bottleneck)</h3>
<p>표준적인 PyTorch 등의 프레임워크로 구현된 어텐션에서는 다음과 같은 비효율적인 메모리 접근 패턴이 반복된다 7:</p>
<ol>
<li><strong><span class="math math-inline">Q \cdot K^T</span> 연산:</strong> <span class="math math-inline">Q</span>와 <span class="math math-inline">K</span>를 HBM(High Bandwidth Memory)에서 읽어와 연산 후, <span class="math math-inline">N \times N</span> 크기의 거대한 중간 결과를 HBM에 **기록(Write)**한다. (<span class="math math-inline">N^2</span> 접근)</li>
<li><strong>마스킹 및 소프트맥스:</strong> HBM에서 <span class="math math-inline">N \times N</span> 행렬을 다시 <strong>읽어와(Read)</strong> 마스킹과 소프트맥스를 수행하고, 그 결과를 다시 HBM에 **기록(Write)**한다. (<span class="math math-inline">2N^2</span> 접근)</li>
<li><strong>드롭아웃(Dropout):</strong> (학습 시) 확률적으로 0으로 만드는 마스크를 적용하기 위해 또다시 읽고 쓴다. (<span class="math math-inline">2N^2</span> 접근)</li>
<li><strong><span class="math math-inline">Score \cdot V</span> 연산:</strong> 소프트맥스 결과와 <span class="math math-inline">V</span>를 읽어와 곱셈을 수행한다. (<span class="math math-inline">N^2</span> 접근)</li>
</ol>
<p>이처럼 <span class="math math-inline">N^2</span>에 비례하는 방대한 데이터를 느린 HBM과 빠른 GPU 코어(SRAM) 사이에서 끊임없이 왕복시켜야 한다. 시퀀스 길이가 길어질수록 GPU 코어는 데이터를 기다리며 노는 시간(Stall)이 길어진다. 즉, 트랜스포머의 긴 시퀀스 처리는 <strong>연산(Compute) 제한적</strong>이라기보다 <strong>메모리 대역폭(Bandwidth) 제한적</strong>인 작업이 된다.18 이것이 바로 100%의 GPU 로드율을 보이면서도 실제 처리 속도는 현저히 느린 현상의 원인이다.</p>
<h3>3.3 FlashAttention이 시사하는 바</h3>
<p>이러한 IO 병목을 해결하기 위해 등장한 FlashAttention 8은 타일링(Tiling) 기법을 사용하여 <span class="math math-inline">N \times N</span> 행렬을 HBM에 기록하지 않고 SRAM 내부에서 연산을 종결지음으로써 HBM 접근을 획기적으로 줄였다. 그러나 FlashAttention조차도 <span class="math math-inline">O(N^2)</span>라는 알고리즘 자체의 연산 복잡도(FLOPs)를 줄이지는 못했다. 단지 메모리 접근 효율을 높여 ‘숨겨진’ <span class="math math-inline">N^2</span> 비용을 일부 상쇄했을 뿐이다.8 FlashAttention의 등장은 역설적으로 트랜스포머의 병목이 연산량 그 자체보다도 데이터 이동 비용에 얼마나 깊게 종속되어 있는지를 증명하는 사례라 할 수 있다.</p>
<h2>4.  에너지 효율성과 환경적 비용: 지속 불가능한 확장</h2>
<p><span class="math math-inline">O(N^2)</span> 복잡도는 단순히 속도가 느려지거나 메모리가 부족해지는 문제를 넘어, 막대한 전력 소비와 환경적 비용으로 직결된다. 2025년 현재, AI 모델의 탄소 발자국과 에너지 효율성은 기술적 이슈를 넘어 윤리적, 경제적 이슈로 부상했다.24 트랜스포머의 비효율성은 시퀀스 길이가 늘어날수록 에너지 소비를 기하급수적으로 증가시킨다.</p>
<h3>4.1 학습(Training) 에너지 비용의 비선형적 증가</h3>
<p>학습 과정에서 시퀀스 길이를 2배 늘리면, 단순 계산으로도 어텐션 연산량은 4배가 된다. 하지만 실제 에너지 비용은 4배 이상으로 폭증한다. 메모리 부족을 회피하기 위해 ‘재계산(Rematerialization)’ 또는 ‘Gradient Checkpointing’ 기법을 사용해야 하기 때문이다.26 이 기법은 메모리를 절약하기 위해 역전파 단계에서 순전파의 연산을 다시 수행하는 방식이다. 즉, 메모리 공간을 확보하기 위해 중복 연산을 수행함으로써 전력을 추가로 소모하게 된다. 8k 컨텍스트로 모델을 학습하는 것은 2k 컨텍스트 모델보다 단순히 4배의 에너지가 드는 것이 아니라, 메모리 스와핑과 통신 오버헤드, 재계산 비용까지 포함하여 훨씬 더 많은 에너지를 태워야 한다.27</p>
<h3>4.2 추론(Inference) 단계의 ‘Pre-fill’ 에너지 쇼크</h3>
<p>추론 단계, 특히 사용자가 입력한 긴 프롬프트를 처리하는 ‘Pre-fill’ 단계에서도 <span class="math math-inline">O(N^2)</span> 비용이 그대로 발생한다. 100페이지 분량의 문서를 요약해달라는 요청(약 50k 토큰)이 들어왔다고 가정해보자. 첫 번째 요약 단어를 생성하기도 전에, 모델은 입력된 50k 토큰 전체에 대해 <span class="math math-inline">50,000^2</span>에 비례하는 어텐션 연산을 수행해야 한다. 이는 순간적으로 막대한 전력을 소모하며 28, 클라우드 서비스 제공자에게는 높은 운영 비용(OpEx)으로, 사용자에게는 느린 초기 응답 시간(TTFT: Time To First Token)으로 전가된다.</p>
<p>이러한 에너지 비효율성은 스마트폰이나 IoT 기기와 같은 <strong>온디바이스(On-device) AI 환경</strong>에서 트랜스포머의 탑재를 가로막는 결정적인 요인이다. 배터리로 구동되는 기기에서 <span class="math math-inline">N^2</span>의 연산을 수행하는 것은 하드웨어의 열 설계 전력(TDP)을 초과하는 발열과 급격한 배터리 소모를 유발하기 때문이다.25</p>
<h2>5.  문맥 길이 확장의 딜레마 (Context Length Scaling Dilemma)</h2>
<p>트랜스포머의 <span class="math math-inline">O(N^2)</span> 특성은 모델 설계자와 연구자들에게 가혹한 트레이드오프(Trade-off)를 강요해왔다. 이는 단순히 “더 큰 GPU를 사면 해결되는” 문제가 아니라, 아키텍처의 지속 가능성에 대한 근본적인 의문을 제기한다.</p>
<ol>
<li><strong>성능 vs. 비용의 불균형:</strong> 모델의 성능(Perplexity)은 일반적으로 문맥 길이가 길어질수록 좋아진다.8 더 많은 정보를 참조할 수 있기 때문이다. 그러나 비용은 제곱으로 증가하므로, 어느 시점부터는 성능 향상분보다 비용 증가분이 훨씬 커지는 ’비용 체증의 법칙’이 적용된다. 이는 AI의 경제성을 심각하게 저해한다.</li>
<li><strong>근시안적 모델링 (Short-sighted Modeling):</strong> 비용 문제로 인해 대부분의 상용 트랜스포머 모델은 2k, 4k, 혹은 8k 토큰 등으로 문맥 길이를 인위적으로 제한해왔다.7 이는 모델이 책 한 권의 서사를 온전히 파악하거나, 긴 법률 문서의 앞뒤 모순을 찾아내거나, 수십만 줄의 코드 베이스 전체를 이해하는 것을 구조적으로 불가능하게 만든다. 이러한 ’기억 상실’은 모델의 지능을 제한하는 핵심 요인이다.</li>
<li><strong>패치워크식 해결책의 한계:</strong> 이를 극복하기 위해 Sparse Attention, Linear Attention, Windowed Attention 등 수많은 변형(Variant)들이 제안되었다.10 그러나 이들은 대개 전체 문맥을 보지 못해 성능이 떨어지거나(Global interaction 상실), 하드웨어 가속 효율이 떨어져(Irregular memory access) 실제 속도 향상은 미미한 경우가 많았다.8 <span class="math math-inline">O(N^2)</span>라는 본질적인 병목을 우회하려는 시도들은 결국 트랜스포머의 핵심 장점인 ’밀도 높은 문맥 이해’를 희생하는 결과를 낳았다.</li>
</ol>
<h3>5.1 결론: 구조적 한계의 임계점</h3>
<p>결론적으로, <strong>1.1절에서 논의한 어텐션 메커니즘의 제곱(<span class="math math-inline">O(N^2)</span>) 복잡도와 연산 비용</strong>은 트랜스포머 아키텍처가 ’범용 시퀀스 모델(General Sequence Model)’로 진화하는 것을 막는 가장 단단한 **유리천장(Glass Ceiling)**이다. 유전체 분석, 장편 소설 창작, 초고해상도 영상 처리, 시계열 데이터 분석 등 <span class="math math-inline">N</span>이 수십만에서 수백만에 이르는 영역에서 트랜스포머는 그 계산 비용의 무게를 견디지 못하고 붕괴한다.</p>
<p>트랜스포머의 어텐션은 모든 토큰을 평등하게, 그리고 동시에 바라보려 한다. 그러나 모든 것을 다 보려는 그 탐욕스러운(Greedy) 구조가 역설적으로 더 많은 것을 보지 못하게 만드는 족쇄가 되었다. 이것이 바로 선형 복잡도(<span class="math math-inline">O(N)</span>)를 가지면서도 트랜스포머의 성능을 유지할 수 있는 새로운 아키텍처, 즉 Mamba와 같은 상태 공간 모델(SSM)이 포스트 트랜스포머 시대의 필연적인 대안으로 부상하는 근본적인 이유이다. 다음 절에서는 이러한 연산 비용 문제와 맞물려 추론 속도를 결정적으로 저하시키는 또 다른 요인인 KV 캐시의 문제에 대해 논의한다.</p>
<p><strong>[표 1-2] 제곱 복잡도의 다층적 비용 요약</strong></p>
<table><thead><tr><th><strong>분석 차원</strong></th><th><strong>복잡도</strong></th><th><strong>물리적 의미 및 병목 현상</strong></th></tr></thead><tbody>
<tr><td><strong>수학적 연산 (Time)</strong></td><td><span class="math math-inline">O(N^2 \cdot d)</span></td><td><span class="math math-inline">QK^T</span> 내적으로 인한 FLOPs의 기하급수적 증가. <span class="math math-inline">N=100k</span> 시 사실상 처리 불가.</td></tr>
<tr><td><strong>메모리 용량 (Space)</strong></td><td><span class="math math-inline">O(N^2)</span></td><td><span class="math math-inline">N \times N</span> 어텐션 스코어 행렬 저장 불가. OOM 발생의 주원인.</td></tr>
<tr><td><strong>메모리 대역폭 (IO)</strong></td><td><span class="math math-inline">IO(N^2)</span></td><td>HBM과 SRAM 간의 과도한 데이터 이동으로 인한 ‘Memory Wall’ 봉착.</td></tr>
<tr><td><strong>에너지 효율 (Power)</strong></td><td><span class="math math-inline">\propto N^2</span></td><td>긴 시퀀스 처리 시 전력 소비 급증, 온디바이스 및 친환경 AI 구현의 걸림돌.</td></tr>
<tr><td><strong>확장성 (Scalability)</strong></td><td>제한적</td><td>100k+ 이상의 초장문 처리가 경제적/물리적으로 불가능에 가까움.</td></tr>
</tbody></table>
<h2>6. 참고 자료</h2>
<ol>
<li>Attention is All you Need - NIPS papers, https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf</li>
<li>Transformer (deep learning) - Wikipedia, https://en.wikipedia.org/wiki/Transformer_(deep_learning)</li>
<li>Computational Complexity of Self-Attention in the Transformer Model - Stack Overflow, https://stackoverflow.com/questions/65703260/computational-complexity-of-self-attention-in-the-transformer-model</li>
<li>The Q, K, V Matrices - Arpit Bhayani, https://arpitbhayani.me/blogs/qkv-matrices/</li>
<li>Computational Complexity of Self-Attention in the … - Codemia, https://codemia.io/knowledge-hub/path/computational_complexity_of_self-attention_in_the_transformer_model</li>
<li>Attention Mechanism Complexity Analysis | by Mridul Rao | Medium, https://medium.com/@mridulrao674385/attention-mechanism-complexity-analysis-7314063459b1</li>
<li>FlashAttention: Fast Transformer Training with Long Sequences - Stanford CRFM, https://crfm.stanford.edu/2023/01/13/flashattention.html</li>
<li>FLASHATTENTION: Fast and Memory-Efficient Exact Attention with IO-Awareness - OpenReview, https://openreview.net/pdf?id=H4DqfPSibmx</li>
<li>Attention Is All You Need - arXiv, https://arxiv.org/html/1706.03762v7</li>
<li>A Look Back and a Glimpse Ahead At Transformers in AI - Sapien, https://www.sapien.io/blog/a-look-back-and-a-glimpse-ahead-at-transformers-in-ai</li>
<li>Formula to compute approximate memory requirements of Transformer models, https://stats.stackexchange.com/questions/563919/formula-to-compute-approximate-memory-requirements-of-transformer-models</li>
<li>Efficiently Training 7B LLM with 1 Million Sequence Length on 8 GPUs - arXiv, https://arxiv.org/html/2407.12117v1</li>
<li>Transformer Memory Arithmetic: Understanding all the Bytes in nanoGPT - Edward Rees, https://erees.dev/transformer-memory/</li>
<li>Mini-Sequence Transformer: Optimizing Intermediate Memory for Long Sequences Training, https://arxiv.org/html/2407.15892v1</li>
<li>Optimizing Intermediate Memory for Long Sequences Training - NIPS papers, https://proceedings.neurips.cc/paper_files/paper/2024/file/b063829b922fdeb4fa3472dd3471ff43-Paper-Conference.pdf</li>
<li>Efficiency comparison for different sequence lengths. OOM indicates… | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/Efficiency-comparison-for-different-sequence-lengths-OOM-indicates-Out-Of-Memory-error_tbl1_398801208</li>
<li>GPT Training Memory Estimation - NeMo Practice | Jianbin Chang - al-folio, https://shjwudp.github.io/blog/2023/gpt-training-memory-estimation-nemo-training-practice/</li>
<li>Transformer Inference Arithmetic | kipply’s blog, https://kipp.ly/transformer-inference-arithmetic/</li>
<li>All About Transformer Inference | How To Scale Your Model - GitHub Pages, https://jax-ml.github.io/scaling-book/inference/</li>
<li>A guide to LLM inference and performance - Baseten, https://www.baseten.co/blog/llm-transformer-inference-guide/</li>
<li>Mind the Memory Gap: Unveiling GPU Bottlenecks in Large-Batch LLM Inference - arXiv, https://arxiv.org/html/2503.08311v2</li>
<li>FlashAttention: Fast and Memory-Efficient Exact Attention … - arXiv, https://arxiv.org/abs/2205.14135</li>
<li>The Evolution of Attention Mechanisms: Scaling Transformers Smartly | by Aadishagrawal, https://medium.com/@aadishagrawal/the-evolution-of-attention-mechanisms-scaling-transformers-smartly-73cb96f991cf</li>
<li>A Comparative Study of Resource Utilization for Variants of Self-Attention - arXiv, https://arxiv.org/html/2507.07247v1</li>
<li>Energy-Efficient Transformer Inference: Optimization Strategies for Time Series Classification - arXiv, https://arxiv.org/html/2502.16627v2</li>
<li>The FLOPs Calculus of Language Model Training | by Dzmitry Bahdanau | Medium, https://medium.com/@dzmitrybahdanau/the-flops-calculus-of-language-model-training-3b19c1f025e4</li>
<li>From Human Effort to AI Efficiency: How LLMs &amp; hardware acceleration Optimize Energy Consumption | by Engram Network | Medium, https://medium.com/@engramnetwork/from-human-effort-to-ai-efficiency-how-llms-hardware-acceleration-optimize-energy-consumption-6cdb475c6a45</li>
<li>12월 25, 2025에 액세스, [https://www.newline.co/@zaoyang/energy-saving-techniques-for-llm-inference–e508c121#:<sub>:text=Control%20Sequence%20Length,length%20a%20model%20can%20handle.](https://www.newline.co/@zaoyang/energy-saving-techniques-for-llm-inference–e508c121#:</sub>:text=Control Sequence Length, <a href="https://www.newline.co/@zaoyang/energy-saving-techniques-for-llm-inference--e508c121#:~:text=Control%20Sequence%20Length,length%20a%20model%20can%20handle.">https://www.newline.co/@zaoyang/energy-saving-techniques-for-llm-inference–e508c121#:~:text=Control%20Sequence%20Length,length%20a%20model%20can%20handle.</a></li>
<li>Energy-Saving Techniques for LLM Inference - Newline.co, https://www.newline.co/@zaoyang/energy-saving-techniques-for-llm-inference–e508c121</li>
<li>Adaptive Attention Span in Transformers - ACL Anthology, https://aclanthology.org/P19-1032.pdf</li>
<li>CAB: Comprehensive Attention Benchmarking on Long Sequence Modeling - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v202/zhang23r/zhang23r.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>