<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.1 연속 시간 시스템의 이산화(Discretization)와 순환 신경망(RNN)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.1 연속 시간 시스템의 이산화(Discretization)와 순환 신경망(RNN)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>2.1 연속 시간 시스템의 이산화(Discretization)와 순환 신경망(RNN)</span></nav>
                </div>
            </header>
            <article>
                <h1>2.1 연속 시간 시스템의 이산화(Discretization)와 순환 신경망(RNN)</h1>
<p>현대 인공지능 연구, 특히 시퀀스 모델링(Sequence Modeling) 분야에서 트랜스포머(Transformer) 아키텍처가 이룩한 성과는 실로 지대하다. 그러나 어텐션 메커니즘의 2차 시간 복잡도(<span class="math math-inline">O(L^2)</span>)가 초래하는 연산 효율성의 한계는 연구자들로 하여금 새로운 패러다임을 모색하게 만들었다. 그 대안으로 급부상한 맘바(Mamba) 아키텍처와 그 이론적 근간이 되는 상태 공간 모델(State Space Model, SSM)은 딥러닝 모델링의 관점을 근본적으로 전환할 것을 요구한다. 그것은 바로 ’이산적(Discrete)’인 토큰의 세계에서 ’연속적(Continuous)’인 신호의 세계로 회귀하는 것이다. 본 절에서는 SSM의 핵심 메커니즘인 ‘이산화(Discretization)’ 과정을 수학적, 물리적, 그리고 신경망적 관점에서 심층적으로 분석한다. 우리는 연속 시간 시스템이 어떻게 디지털 연산이 가능한 형태로 변환되는지, 그리고 이 변환된 형태가 어떻게 우리가 익히 알고 있는 순환 신경망(RNN)과 수학적으로 정확히 등가를 이루는지 규명할 것이다. 이 과정은 단순히 수식을 변환하는 기교가 아니라, 물리 세계의 동역학(Dynamics)을 인공지능 모델 내부에 주입하는 철학적, 공학적 토대임을 밝힌다.</p>
<h2>1.  서론: 연속 시간(Continuous-Time) 패러다임의 부활</h2>
<p>우리가 살아가는 물리적 세계는 본질적으로 연속적이다. 소리는 공기의 연속적인 진동이며, 주가는 매 순간 변동하고, 생체 신호는 끊김 없는 파형을 그린다. 그러나 컴퓨터 과학과 딥러닝의 주류는 오랫동안 이산적인 데이터 처리에 집중해 왔다. 텍스트는 개별적인 단어(토큰)의 나열로, 이미지는 픽셀의 격자로 취급되었다.1 이러한 이산적 접근은 계산의 편의를 제공했지만, 데이터가 가진 시간적 연속성과 해상도(Resolution)에 대한 정보를 일부 소실시키는 결과를 낳았다.</p>
<p>상태 공간 모델(SSM)은 이러한 한계를 극복하기 위해 제어 이론(Control Theory)과 신호 처리(Signal Processing) 분야에서 차용된 개념이다. SSM은 데이터를 고정된 간격의 점들이 아닌, 시간에 따라 흐르는 연속적인 함수 <span class="math math-inline">x(t)</span>와 <span class="math math-inline">y(t)</span>로 모델링한다. 딥러닝 모델이 연속 시간 시스템을 학습한다는 것은, 데이터가 샘플링되기 이전의 원본 신호가 가진 내재적인 물리 법칙을 학습한다는 것을 의미한다. 이는 모델이 1초에 100번 샘플링된 오디오로 학습했더라도, 1초에 1000번 샘플링된 데이터에 별도의 재학습 없이 적용될 수 있는 ’해상도 불변성(Resolution Invariance)’을 가능하게 한다.1</p>
<p>하지만 디지털 컴퓨터는 연속적인 미분방정식을 직접 풀 수 없다. 따라서 연속적인 모델을 디지털 하드웨어(GPU) 위에서 실행 가능한 형태로 변환하는 과정이 필수적인데, 이것이 바로 **이산화(Discretization)**이다. 이산화는 아날로그 세계의 미분방정식을 디지털 세계의 점화식(Recurrence)으로 번역하는 통역사이며, 이 번역 과정에서 파생되는 수학적 구조가 맘바와 같은 최신 SSM 모델의 성능을 결정짓는 핵심 요소가 된다.</p>
<h2>2.  상태 공간 모델의 물리적 기초와 수학적 정의</h2>
<p>이산화를 논하기에 앞서, 우리가 이산화하고자 하는 대상인 연속 시간 상태 공간 모델(Continuous-Time SSM)의 정체를 명확히 할 필요가 있다. SSM은 입력을 잠재 상태(Latent State) <span class="math math-inline">h(t)</span>를 통해 출력으로 매핑하는 시스템으로, 다음과 같은 1계 선형 상미분방정식(First-Order Linear ODE)으로 정의된다.3<br />
<span class="math math-display">
\begin{aligned} \dot{h}(t) &amp;= \mathbf{A}h(t) + \mathbf{B}x(t) \\ y(t) &amp;= \mathbf{C}h(t) + \mathbf{D}x(t) \end{aligned}
</span><br />
이 수식의 각 항은 물리적 시스템의 동역학을 구성하는 구체적인 요소들을 대변한다. 이를 직관적으로 이해하기 위해 고전 역학의 질량-용수철-댐퍼(Mass-Spring-Damper) 시스템을 예로 들어 분석해 보자.6</p>
<p><strong>물리적 유추: 질량-용수철-댐퍼 시스템 (Mass-Spring-Damper Analogy)</strong></p>
<p>질량 <span class="math math-inline">m</span>인 물체가 용수철 상수 <span class="math math-inline">k</span>인 용수철에 매달려 있고, 점성 마찰 계수 <span class="math math-inline">c</span>인 댐퍼(Damper)가 진동을 억제하며, 외부에서 힘 <span class="math math-inline">u(t)</span>가 가해지는 상황을 고려하자. 뉴턴의 제2법칙에 의해 이 시스템의 운동 방정식은 다음과 같은 2계 미분방정식으로 기술된다.7<br />
<span class="math math-display">
m\ddot{q}(t) + c\dot{q}(t) + kq(t) = u(t)
</span><br />
여기서 <span class="math math-inline">q(t)</span>는 물체의 변위(위치)를 나타낸다. 이 2계 미분방정식을 1계 미분방정식 형태인 상태 공간 모델로 변환하기 위해, 우리는 ’상태 변수(State Variable)’를 도입해야 한다. 상태 변수는 시스템의 현재 상황을 완벽하게 기술하여 미래를 예측하는 데 필요한 최소한의 정보 집합이다. 이 경우, 위치 <span class="math math-inline">q(t)</span>와 속도 <span class="math math-inline">\dot{q}(t)</span>가 상태 변수가 된다. 이를 벡터 <span class="math math-inline">h(t)</span>로 묶으면 다음과 같다.9<br />
<span class="math math-display">
h(t) = \begin{bmatrix} q(t) \\ \dot{q}(t) \end{bmatrix}
</span><br />
이제 운동 방정식을 행렬 형태로 재정리하면 다음과 같은 상태 방정식(State Equation)을 얻는다.<br />
<span class="math math-display">
\frac{d}{dt} \begin{bmatrix} q(t) \\ \dot{q}(t) \end{bmatrix} = \begin{bmatrix} 0 &amp; 1 \\ -k/m &amp; -c/m \end{bmatrix} \begin{bmatrix} q(t) \\ \dot{q}(t) \end{bmatrix} + \begin{bmatrix} 0 \\ 1/m \end{bmatrix} u(t)
</span><br />
이 식에서 우리는 SSM의 핵심 행렬들의 물리적 의미를 명확히 파악할 수 있다.11</p>
<ul>
<li><strong>시스템 행렬 <span class="math math-inline">\mathbf{A}</span> (State Matrix):</strong> <span class="math math-inline">\mathbf{A} = \begin{bmatrix} 0 &amp; 1 \ -k/m &amp; -c/m \end{bmatrix}</span>는 시스템의 고유한 성질을 결정한다. <span class="math math-inline">-k/m</span> 항은 용수철의 복원력(탄성)을, <span class="math math-inline">-c/m</span> 항은 댐퍼의 마찰력(에너지 소산)을 나타낸다. 딥러닝 모델에서 학습되는 <span class="math math-inline">\mathbf{A}</span> 행렬은 데이터 내부에 숨겨진 이러한 ‘보이지 않는 역학 구조’—예를 들어 언어에서의 문법적 제약이나 문맥의 흐름—를 모델링하는 것이다. <span class="math math-inline">\mathbf{A}</span>의 고유값(Eigenvalue)은 시스템의 안정성을 결정하며, 실수부가 음수일 경우 상태는 시간이 지남에 따라 0으로 수렴(망각)한다.5</li>
<li><strong>입력 행렬 <span class="math math-inline">\mathbf{B}</span> (Input Matrix):</strong> <span class="math math-inline">\mathbf{B} = \begin{bmatrix} 0 \ 1/m \end{bmatrix}</span>는 외부 입력 <span class="math math-inline">u(t)</span>가 시스템의 상태 변화에 기여하는 방식을 결정한다. 여기서 입력(힘)은 위치가 아닌 속도(가속도)에 직접적인 영향을 준다는 것을 알 수 있다. 딥러닝에서 <span class="math math-inline">\mathbf{B}</span>는 입력 데이터(토큰 임베딩 등)를 잠재 공간(Latent Space)으로 투영하는 역할을 한다.4</li>
<li><strong>출력 행렬 <span class="math math-inline">\mathbf{C}</span> (Output Matrix):</strong> 우리가 관측하고자 하는 것이 물체의 위치라면 <span class="math math-inline">y(t) = \begin{bmatrix} 1 &amp; 0 \end{bmatrix} h(t) = q(t)</span>가 된다. <span class="math math-inline">\mathbf{C}</span>는 내부의 잠재 상태 <span class="math math-inline">h(t)</span>를 우리가 관측 가능한 출력 <span class="math math-inline">y(t)</span>로 변환하는 선형 변환이다.10</li>
<li><strong>직접 전달 행렬 <span class="math math-inline">\mathbf{D}</span> (Feedthrough Matrix):</strong> 입력이 상태를 거치지 않고 출력으로 바로 연결되는 경로이다. 딥러닝에서는 이를 잔차 연결(Residual Connection, Skip Connection)로 해석하며, 계산의 편의를 위해 종종 생략되거나 별도의 경로로 취급된다.14</li>
</ul>
<p>이처럼 SSM은 단순한 행렬 연산이 아니라, 입력 신호가 시간에 따라 어떻게 저장(메모리)되고, 변형(역학)되며, 출력(관측)되는지를 기술하는 물리적 시뮬레이션 엔진이다. 맘바와 같은 최신 모델들은 수천, 수만 차원의 거대한 상태 공간에서 이러한 시뮬레이션을 수행함으로써 텍스트나 유전체 서열과 같은 복잡한 데이터의 패턴을 학습한다.</p>
<h2>3.  이산화(Discretization)의 원리: 아날로그에서 디지털로</h2>
<p>앞서 정의한 연속 시간 SSM은 이론적으로 아름답지만, 이를 컴퓨터에서 구현하기 위해서는 반드시 이산 시간(Discrete-Time) 시스템으로 변환해야 한다. 이 과정이 바로 이산화이며, 여기에는 ‘샘플링 간격(Time Step)’ 또는 ’시간 척도(Timescale)’라고 불리는 파라미터 <span class="math math-inline">\Delta</span> (Delta)가 도입된다.2</p>
<p>이산화는 연속적인 파라미터 <span class="math math-inline">(\mathbf{A}, \mathbf{B})</span>와 시간 간격 <span class="math math-inline">\Delta</span>를 입력받아, 이산적인 점화식을 구성하는 파라미터 <span class="math math-inline">(\mathbf{\bar{A}}, \mathbf{\bar{B}})</span>를 출력하는 함수로 정의될 수 있다.<br />
<span class="math math-display">
(\mathbf{\bar{A}}, \mathbf{\bar{B}}) = \text{Discretize}(\mathbf{A}, \mathbf{B}, \Delta)
</span><br />
이산화된 시스템은 다음과 같은 선형 점화식(Linear Recurrence) 형태를 띤다.<br />
<span class="math math-display">
h_k = \mathbf{\bar{A}} h_{k-1} + \mathbf{\bar{B}} x_k
</span><br />
여기서 <span class="math math-inline">h_k</span>는 시간 <span class="math math-inline">t = k\Delta</span>에서의 상태 벡터 <span class="math math-inline">h(k\Delta)</span>를 의미하며, <span class="math math-inline">x_k</span>는 해당 시점의 입력 샘플 <span class="math math-inline">x(k\Delta)</span>이다. 이 식은 시스템의 현재 상태 <span class="math math-inline">h_k</span>가 바로 이전 상태 <span class="math math-inline">h_{k-1}</span>과 현재 입력 <span class="math math-inline">x_k</span>의 선형 결합으로 결정됨을 보여준다.</p>
<p>이산화를 수행하는 방법에는 여러 가지가 있으며, 각 방법은 연속 시스템을 근사하는 방식과 오차 특성에 따라 구별된다. 대표적인 방법으로는 오일러 방법(Euler Method), 쌍일차 변환(Bilinear Transform), 그리고 0차 유지(Zero-Order Hold, ZOH)가 있다. S4 모델과 맘바 모델은 서로 다른 이산화 기법을 선호하는데, 이는 각 모델이 추구하는 설계 철학과 밀접한 관련이 있다.2</p>
<h2>4.  0차 유지(Zero-Order Hold, ZOH) 기법의 심층 유도와 의미</h2>
<p>맘바(Mamba) 아키텍처는 기본적으로 <strong>0차 유지(ZOH)</strong> 방식을 채택하고 있다.17 ZOH는 디지털-아날로그 변환(DAC) 과정에서 가장 흔히 사용되는 모델로, 샘플링 간격 <span class="math math-inline">\Delta</span> 동안 입력 신호 <span class="math math-inline">x(t)</span>가 일정한 값 <span class="math math-inline">x_k</span>를 유지한다고 가정한다. 즉, 시간 구간 <span class="math math-inline">t \in</span> 동안 <span class="math math-inline">x(t) = x_k</span> (상수)이다.</p>
<p>이 가정이 왜 중요한지, 그리고 이를 통해 어떻게 이산화 수식이 유도되는지 단계별로 살펴보자. 미분방정식의 일반해를 구하는 ’상수 변환법(Variation of Parameters)’을 적용하면, 초기 시간 <span class="math math-inline">t_k</span>에서 <span class="math math-inline">t_{k+1} = t_k + \Delta</span>까지의 상태 <span class="math math-inline">h(t_{k+1})</span>은 다음과 같이 적분 형태로 표현된다.18<br />
<span class="math math-display">
h(t_{k+1}) = e^{\mathbf{A}(t_{k+1}-t_k)} h(t_k) + \int_{t_k}^{t_{k+1}} e^{\mathbf{A}(t_{k+1} - \tau)} \mathbf{B} x(\tau) d\tau
</span><br />
이 식의 첫 번째 항 <span class="math math-inline">e^{\mathbf{A}\Delta} h(t_k)</span>는 외부 입력이 없을 때 시스템의 자연적인 진화(Natural Response)를 나타낸다. 두 번째 항인 적분식은 입력 <span class="math math-inline">x(\tau)</span>가 시스템에 가한 강제 응답(Forced Response)을 누적한 것이다.</p>
<p>ZOH 가정에 따르면, 적분 구간 내에서 입력 <span class="math math-inline">x(\tau)</span>는 상수 <span class="math math-inline">x_k</span>이므로 적분 기호 밖으로 빼낼 수 있다.<br />
<span class="math math-display">
h_{k+1} = e^{\mathbf{A}\Delta} h_k + \left( \int_{t_k}^{t_{k+1}} e^{\mathbf{A}(t_{k+1} - \tau)} d\tau \right) \mathbf{B} x_k
</span><br />
이제 적분 항을 계산하기 위해 변수 치환 <span class="math math-inline">u = t_{k+1} - \tau</span>를 수행하면 <span class="math math-inline">d\tau = -du</span>이고, 적분 구간은 <span class="math math-inline">\Delta</span>에서 <span class="math math-inline">0</span>으로 바뀐다(부호 변경으로 <span class="math math-inline">0</span>에서 <span class="math math-inline">\Delta</span>).<br />
<span class="math math-display">
\int_{0}^{\Delta} e^{\mathbf{A}u} du = \mathbf{A}^{-1} (e^{\mathbf{A}\Delta} - \mathbf{I})
</span><br />
이를 대입하면 최종적으로 ZOH에 의한 이산화 파라미터 공식을 얻는다.14<br />
<span class="math math-display">
\begin{aligned} \mathbf{\bar{A}} &amp;= \exp(\mathbf{A}\Delta) \\ \mathbf{\bar{B}} &amp;= (\mathbf{A}\Delta)^{-1} (\exp(\mathbf{A}\Delta) - \mathbf{I}) \cdot (\Delta \mathbf{B}) \end{aligned}
</span><br />
<strong>ZOH 수식의 심층 해석:</strong></p>
<ol>
<li><strong>행렬 지수함수(Matrix Exponential)의 등장:</strong> <span class="math math-inline">\mathbf{\bar{A}}</span>는 단순한 행렬 곱이 아니라 <span class="math math-inline">\exp(\mathbf{A}\Delta)</span>라는 지수함수 꼴을 띤다. 이는 <span class="math math-inline">\Delta</span>라는 시간 동안 시스템 행렬 <span class="math math-inline">\mathbf{A}</span>에 의해 상태가 얼마나 회전하거나 감쇠/증폭되는지를 정확하게 반영한다. <span class="math math-inline">\mathbf{A}</span>가 대각 행렬(Diagonal Matrix)일 경우, 이 연산은 원소별(Element-wise) 지수함수로 단순화되어 계산 효율이 극적으로 향상된다. 맘바는 이를 활용하여 <span class="math math-inline">\mathbf{A}</span>를 대각 행렬로 제약하거나 구조화한다.2</li>
<li><strong><span class="math math-inline">\Delta</span>의 게이팅(Gating) 역할:</strong> 수식 <span class="math math-inline">\mathbf{\bar{A}} = \exp(\mathbf{A}\Delta)</span>에서, <span class="math math-inline">\mathbf{A}</span>의 대각 원소들이 음수(안정 시스템)라고 가정하자(예: <span class="math math-inline">A_{ii} = -1</span>). 이때 <span class="math math-inline">\Delta</span>가 커지면 <span class="math math-inline">\exp(-1 \cdot \Delta)</span>는 0에 가까워진다. 즉, <strong>시간 간격이 길어질수록 과거의 상태 <span class="math math-inline">h_k</span>는 더 많이 망각된다.</strong> 반대로 <span class="math math-inline">\Delta</span>가 0에 가까우면 <span class="math math-inline">\exp(0) = 1</span>이 되어 상태가 그대로 보존된다. 이는 <span class="math math-inline">\Delta</span>가 정보의 유지와 망각을 제어하는 <strong>망각 게이트(Forget Gate)</strong> 역할을 수행함을 수학적으로 보여준다. 이것이 맘바가 LSTM이나 GRU와 같은 게이팅 메커니즘을 내재화할 수 있는 이론적 근거이다.20</li>
<li><strong>입력에 대한 정밀한 반영:</strong> <span class="math math-inline">\mathbf{\bar{B}}</span> 항은 단순히 입력에 상수를 곱하는 것이 아니라, <span class="math math-inline">\Delta</span> 시간 동안 입력이 시스템에 누적되어 미치는 영향을 적분한 값이다. 이는 오일러 방법(<span class="math math-inline">\mathbf{\bar{B}} \approx \Delta \mathbf{B}</span>)보다 훨씬 정교하며, 입력 신호의 동적 특성을 더 잘 보존한다.</li>
</ol>
<h2>5.  주요 이산화 기법의 비교: 오일러, 쌍일차 변환, 그리고 ZOH</h2>
<p>SSM의 발전 과정에서 다양한 이산화 기법이 시도되었다. 초기 연구와 S4 모델은 주로 **쌍일차 변환(Bilinear Transform)**을 사용한 반면, 맘바는 <strong>ZOH</strong>를 선택했다. 이 선택의 배경에는 각 기법이 가진 수학적 특성과 딥러닝 모델로서의 적합성 차이가 존재한다.22</p>
<p>다음 표는 주요 이산화 기법들의 특성을 비교 분석한 것이다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>오일러 방법 (Euler Method)</strong></th><th><strong>쌍일차 변환 (Bilinear Transform)</strong></th><th><strong>0차 유지 (Zero-Order Hold, ZOH)</strong></th></tr></thead><tbody>
<tr><td><strong>근사 원리</strong></td><td>미분을 차분으로 1차 근사 (<span class="math math-inline">\dot{h} \approx \frac{h_{k+1}-h_k}{\Delta}</span>)</td><td>적분을 사다리꼴 공식으로 근사</td><td>입력 신호를 계단 함수(Step Function)로 가정</td></tr>
<tr><td><strong>이산 행렬 <span class="math math-inline">\mathbf{\bar{A}}</span></strong></td><td><span class="math math-inline">\mathbf{I} + \Delta \mathbf{A}</span></td><td><span class="math math-inline">(\mathbf{I} - \frac{\Delta}{2}\mathbf{A})^{-1}(\mathbf{I} + \frac{\Delta}{2}\mathbf{A})</span></td><td><span class="math math-inline">\exp(\mathbf{A}\Delta)</span></td></tr>
<tr><td><strong>주파수 특성</strong></td><td>불안정할 수 있음 (허수축 매핑 왜곡)</td><td>전체 주파수 축을 단위원으로 매핑 (Aliasing 방지)</td><td>저주파 대역에서 정확, 고주파에서 위상 지연 발생</td></tr>
<tr><td><strong>직관적 해석</strong></td><td>“현재 기울기로 다음 단계 예측”</td><td>“과거와 미래의 평균으로 근사”</td><td><strong>“현재 입력을 <span class="math math-inline">\Delta</span> 동안 유지”</strong></td></tr>
<tr><td><strong>주요 적용 모델</strong></td><td>초기 단순 SSM 실험</td><td><strong>S4 (Structured State Spaces)</strong></td><td><strong>Mamba</strong>, DSS</td></tr>
<tr><td><strong>계산 복잡도</strong></td><td>매우 낮음 (행렬 덧셈/곱셈)</td><td>역행렬 연산 필요 (대각화 시 <span class="math math-inline">O(N)</span> 가능)</td><td>행렬 지수함수 필요 (대각화 시 <span class="math math-inline">O(N)</span> 가능)</td></tr>
<tr><td><strong>RNN 연결성</strong></td><td>잔차 연결 (<span class="math math-inline">h + \Delta h&#39;</span>)과 유사</td><td>복잡한 순환 가중치 구조</td><td>**Gated RNN (Forget Gate)**와 수학적 등가</td></tr>
</tbody></table>
<p><strong>S4가 쌍일차 변환을 선택한 이유:</strong> S4 모델은 긴 시퀀스의 장기 의존성(Long-Range Dependency)을 포착하기 위해 ‘HiPPO’ 행렬과 같은 특수한 구조의 <span class="math math-inline">\mathbf{A}</span>를 사용했다. 쌍일차 변환은 아날로그 시스템의 안정성(Stability)을 디지털 도메인으로 완벽하게 보존(A-stable)하는 특성이 있어, 매우 긴 시계열 데이터를 처리할 때 수치적 안정성을 보장하기에 유리했다.24 또한 주파수 응답 측면에서 왜곡이 적어 신호 처리 관점에서 선호되었다.</p>
<p><strong>맘바가 ZOH를 선택한 이유:</strong> 맘바는 시불변(Time-Invariant) 시스템인 S4와 달리, 입력에 따라 파라미터가 변하는 <strong>선택적(Selective)</strong> 시스템을 지향한다. ZOH의 수식 <span class="math math-inline">\mathbf{\bar{A}} = \exp(\mathbf{A}\Delta)</span>는 <span class="math math-inline">\Delta</span>를 가변적으로 조절함으로써 정보의 수명을 직관적으로 제어할 수 있게 해준다. “입력을 특정 시간 <span class="math math-inline">\Delta</span> 동안 유지한다“는 물리적 해석은 맘바의 ‘선택적 정보 압축’ 메커니즘과 완벽하게 부합한다. 또한 ZOH 방식은 게이트가 달린 RNN(Gated RNN)과의 구조적 유사성이 가장 높아, 기존 딥러닝 연구의 직관을 SSM에 적용하기에 가장 적합하다.16</p>
<h2>6.  순환 신경망(RNN)과의 구조적 등가성 및 차별성</h2>
<p>이산화된 SSM은 다음과 같은 점화식으로 귀결된다.<br />
<span class="math math-display">
h_k = \mathbf{\bar{A}} h_{k-1} + \mathbf{\bar{B}} x_k
</span><br />
이 식을 전통적인 순환 신경망(RNN)의 기본 수식과 비교해 보자.<br />
<span class="math math-display">
h_t = \sigma( \mathbf{W}_{hh} h_{t-1} + \mathbf{W}_{xh} x_t + b )
</span><br />
여기서 <span class="math math-inline">\sigma</span>는 비선형 활성화 함수(tanh, ReLU 등)이다. 이산화된 SSM은 본질적으로 **“선형 활성화 함수를 사용하는 RNN”**으로 볼 수 있다.3</p>
<ul>
<li><span class="math math-inline">\mathbf{\bar{A}}</span>는 RNN의 순환 가중치 행렬 <span class="math math-inline">\mathbf{W}_{hh}</span>에 해당한다.</li>
<li><span class="math math-inline">\mathbf{\bar{B}}</span>는 입력 가중치 행렬 <span class="math math-inline">\mathbf{W}_{xh}</span>에 해당한다.</li>
</ul>
<p><strong>그러나 단순한 RNN과는 결정적인 차이가 있다.</strong></p>
<ol>
<li>파라미터의 생성(Generation) vs. 학습(Learning):</li>
</ol>
<p>일반적인 RNN은 <span class="math math-inline">\mathbf{W}_{hh}</span>와 <span class="math math-inline">\mathbf{W}_{xh}</span> 행렬 자체를 학습 가능한 파라미터로 두고 무작위 값으로 초기화하여 학습한다. 반면, SSM은 연속 시간 파라미터 <span class="math math-inline">\mathbf{A}, \mathbf{B}</span>와 시간 척도 <span class="math math-inline">\Delta</span>를 학습하고, 매 단계마다 이산화 공식(ZOH 등)을 통해 <span class="math math-inline">\mathbf{\bar{A}}, \mathbf{\bar{B}}</span>를 **계산(Compute)**하여 사용한다. 이는 모델에 강력한 수학적 구조(Structure)를 강제하는 것이다. 예를 들어, <span class="math math-inline">\mathbf{\bar{A}} = \exp(\mathbf{A}\Delta)</span>라는 제약 조건은 순환 가중치가 무작위로 발산하는 것을 막고, 학습된 물리적 역학을 따르도록 유도한다. 이는 RNN이 겪는 그래디언트 소실/폭발 문제를 구조적으로 완화하는 효과가 있다.21</p>
<ol start="2">
<li>해상도 불변성(Resolution Invariance):</li>
</ol>
<p>RNN의 <span class="math math-inline">\mathbf{W}_{hh}</span>는 고정된 값이다. 만약 데이터를 2배 더 촘촘하게 샘플링하면, RNN은 문맥을 파악하기 위해 2배 더 많은 단계를 거쳐야 하므로 성능이 저하되거나 재학습이 필요하다. 그러나 SSM은 샘플링 속도가 바뀌면 <span class="math math-inline">\Delta</span> 값만 조정하여 <span class="math math-inline">\mathbf{\bar{A}}</span>와 <span class="math math-inline">\mathbf{\bar{B}}</span>를 재계산하면 된다. 즉, 모델의 파라미터(<span class="math math-inline">\mathbf{A}, \mathbf{B}</span>)는 데이터의 해상도와 무관한 연속적인 시간 위의 역학을 담고 있다.1</p>
<ol start="3">
<li>가변적 시간 척도와 게이팅(Gating):</li>
</ol>
<p>맘바에서 <span class="math math-inline">\Delta</span>는 입력 <span class="math math-inline">x_k</span>에 의존하는 함수 <span class="math math-inline">\Delta(x_k)</span>가 된다.<br />
<span class="math math-display">
   \Delta_k = \text{Softplus}(\text{Linear}(x_k))
</span><br />
이에 따라 순환 가중치 <span class="math math-inline">\mathbf{\bar{A}}_k = \exp(\mathbf{A}\Delta_k)</span>도 매 시점마다 변하게 된다. 이것이 바로 맘바를 단순한 선형 시불변(LTI) 시스템에서 벗어나게 하는 핵심이다. 입력에 따라 <span class="math math-inline">\Delta</span>가 커지면 현재 입력을 중시하고 과거를 잊으며, <span class="math math-inline">\Delta</span>가 작으면 과거 기억을 오래 유지한다. 이는 LSTM이나 GRU의 게이팅 메커니즘과 기능적으로 동일하지만, 그 근원이 경험적인 엔지니어링이 아닌 **‘가변적 시간 척도(Variable Timescale)에 따른 이산화’**라는 물리적 해석에서 비롯된다는 점이 다르다.20</p>
<h4>6.0.1  결론: 이산화, 딥러닝을 위한 미적분학의 다리</h4>
<p>2.1절을 정리하며, 우리는 연속 시간 시스템의 이산화가 단순히 컴퓨터 시뮬레이션을 위한 기술적 전처리가 아님을 확인했다. 그것은 트랜스포머의 이산적 토큰 처리 방식이 가진 한계를 넘어, 데이터의 연속적인 본질을 포착하고 모델링하기 위한 필수적인 수학적 도구이다.</p>
<p>0차 유지(ZOH) 기법을 통해 유도된 점화식은 SSM을 RNN의 한 형태로 통합시켰다. 그러나 이 ’SSM 기반 RNN’은 기존의 블랙박스형 RNN과 달리, 미분방정식에 기반한 명확한 해석 가능성과 해상도 불변성, 그리고 <span class="math math-inline">\Delta</span> 파라미터를 통한 정교한 정보 제어 능력을 갖추고 있다. 맘바는 이러한 이산화의 특성을 십분 활용하여, 입력 내용에 따라 시간을 늘리거나 줄이는(Time Dilation/Compression) 것과 같은 효과를 내며 정보를 선택적으로 압축한다.</p>
<p>이어지는 2.2절에서는 이러한 SSM이 어떻게 수천 단계 이상의 장기 의존성(Long-Range Dependency) 문제를 수학적으로 해결하는지, HiPPO 이론을 중심으로 살펴볼 것이다. 이산화가 SSM의 ’몸체(Body)’를 구성했다면, HiPPO 이론은 그 몸체가 기억을 유지할 수 있게 하는 ’뇌(Brain)’의 초기화 원리를 제공한다. 이 두 가지의 결합이 비로소 맘바를 포스트 트랜스포머 시대의 강력한 경쟁자로 만들었다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>A Visual Guide to Mamba and State Space Models - Maarten Grootendorst, https://www.maartengrootendorst.com/blog/mamba/</li>
<li>Structured State Space Models Visually Explained - Towards Data Science, https://towardsdatascience.com/structured-state-space-models-visually-explained-86cfe2757386/</li>
<li>What Are State Space Models? - IBM, https://www.ibm.com/think/topics/state-space-model</li>
<li>State-Space Model Definitions - NI - National Instruments, https://www.ni.com/docs/en-US/bundle/labview-advanced-signal-processing-toolkit/page/state-space-model-definitions-advanced-signal.html</li>
<li>ss - State-space model - MATLAB - MathWorks, https://www.mathworks.com/help/control/ref/ss.html</li>
<li>Introduction: System Modeling - Control Tutorials for MATLAB and Simulink, <a href="https://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&amp;section=SystemModeling">https://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SystemModeling</a></li>
<li>Mass-Spring-Damper Systems The Theory, https://faculty.washington.edu/seattle/physics227/reading/reading-3b.pdf</li>
<li>The Mass-Spring-Damper Model, https://people.cam.cornell.edu/mfh72/sources/esmi2019/esmi2019_msd.pdf</li>
<li>State Space Representation Made Easy | Mass-Spring-Damper System Explained, https://www.youtube.com/watch?v=pgZ5cLd5vkk</li>
<li>State Space Representations of Linear Physical Systems, https://lpsa.swarthmore.edu/Representations/SysRepSS.html</li>
<li>Introductory Control Systems Introduction to State-Space Models, https://kamman-dynamics-control.org/wp-content/uploads/2021/01/50-me360state-space-models.pdf</li>
<li>developing the equations of motion for two-mass vibration examples - rotor lab.tamu.edu, <a href="https://rotorlab.tamu.edu/Dynamics_and_Vibrations/Lectures%20(pdf)%20and%20homework/Particle%20Kinetics%202/L14-18.pdf">https://rotorlab.tamu.edu/Dynamics_and_Vibrations/Lectures%20(pdf)%20and%20homework/Particle%20Kinetics%202/L14-18.pdf</a></li>
<li>Understanding State Space Models (SSMs) like LSSL, H3, S4 and Mamba - Tinkerd, https://tinkerd.net/blog/machine-learning/state-space-models/</li>
<li>Technologies on Effectiveness and Efficiency: A Survey of State Spaces Models - arXiv, https://arxiv.org/pdf/2503.11224</li>
<li>Mamba: SSM, Theory, and Implementation in Keras and TensorFlow, https://towardsdatascience.com/mamba-ssm-theory-and-implementation-in-keras-and-tensorflow-32d6d4b32546/</li>
<li>Mamba No. 5 (A Little Bit Of…) - Sparse Notes, https://jameschen.io/jekyll/update/2024/02/12/mamba.html</li>
<li>Mamba Explained - The Gradient, https://thegradient.pub/mamba-explained/</li>
<li>Spatial-Mamba: Effective Visual State Space Models via Structure-aware State Fusion - arXiv, https://arxiv.org/html/2410.15091v1</li>
<li>A Deep Dive into MAMBA and State Space Models for Long-Sequence Modeling - HackMD, https://ssm-ed2.pages.dev/</li>
<li>MAMBA and State Space Models Explained | by Astarag Mohapatra - Medium, https://athekunal.medium.com/mamba-and-state-space-models-explained-b1bf3cb3bb77</li>
<li>Mamba Simplified - Part 2 - S4 and Mamba - Prem AI Blog, https://blog.premai.io/s4-and-mamba/</li>
<li>Discretization Using ZOH, FOH and Tustis bilinear Transformation, https://electronics.stackexchange.com/questions/234003/discretization-using-zoh-foh-and-tustis-bilinear-transformation</li>
<li>Im confused by Matlab’s dontinuous-to-discrete conversion methods and how they work, https://www.mathworks.com/matlabcentral/answers/627953-im-confused-by-matlab-s-dontinuous-to-discrete-conversion-methods-and-how-they-work</li>
<li>Bilinear transform - Wikipedia, https://en.wikipedia.org/wiki/Bilinear_transform</li>
<li>modeling sequences with structured state spaces a dissertation submitted to the department of depart - Stacks are the Stanford, https://stacks.stanford.edu/file/druid:mb976vf9362/gu_dissertation-augmented.pdf</li>
<li>[D] Can someone describe how the SSM in Mamba is much different than the concepts in a GRU / LSTM Cell? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/18iph6a/d_can_someone_describe_how_the_ssm_in_mamba_is/</li>
<li>How Mamba Beats Transformers at Long Sequences - Galileo AI, https://galileo.ai/blog/mamba-linear-scaling-transformers</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>