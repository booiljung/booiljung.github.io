<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.2 Mamba 블록 구조 - MLP와 Attention의 통합 및 간소화</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.2 Mamba 블록 구조 - MLP와 Attention의 통합 및 간소화</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>4.2 Mamba 블록 구조 - MLP와 Attention의 통합 및 간소화</span></nav>
                </div>
            </header>
            <article>
                <h1>4.2 Mamba 블록 구조 - MLP와 Attention의 통합 및 간소화</h1>
<h2>1.  서론: 이질성에서 동질성으로의 아키텍처 진화</h2>
<p>현대 인공지능, 특히 자연어 처리(NLP)와 시퀀스 모델링 분야의 비약적인 발전은 트랜스포머(Transformer) 아키텍처의 등장과 그 궤를 같이한다. 트랜스포머는 시퀀스 내의 장거리 의존성(Long-range dependency)을 포착하는 데 탁월한 성능을 보였으나, 그 구조적 근간은 본질적으로 이질적(Heterogeneous)인 모듈의 결합에 의존하고 있다.1 트랜스포머 블록은 시퀀스 차원에서의 정보 혼합(Mixing)을 담당하는 다중 헤드 자기 주의(Multi-Head Self-Attention, MSA) 모듈과, 채널 차원에서의 정보 변환 및 비선형성을 담당하는 위치별 피드포워드 네트워크(Position-wise Feed-Forward Network, FFN) 또는 다층 퍼셉트론(MLP) 모듈로 명확히 양분되어 있다. 이러한 ’혼합(Mixing)’과 ’매핑(Mapping)’의 명시적 분리는 모델 설계의 직관성을 제공했으나, 동시에 계산 복잡도와 메모리 접근 패턴에서의 비효율성을 초래하는 원인이 되었다.3</p>
<p>특히 Attention 메커니즘이 내포한 <span class="math math-inline">O(L^2)</span>의 2차 복잡도(Quadratic Complexity)는 긴 문맥(Context)을 처리하는 데 있어 치명적인 병목으로 작용하며, 이를 해결하기 위한 수많은 선형 Attention(Linear Attention) 및 희소 Attention(Sparse Attention) 연구가 진행되었음에도 불구하고, 성능과 효율성 사이의 트레이드오프를 완벽히 극복하지는 못했다.5 이러한 배경에서 등장한 Mamba 아키텍처는 기존의 패러다임을 전복하는 구조적 혁신을 제안한다. Mamba는 Attention과 MLP라는 두 개의 분리된 모듈을 사용하는 대신, 이를 하나의 통합된 ’Mamba 블록’으로 대체함으로써 아키텍처의 동질성(Homogeneity)을 확보하고, 구조적 간소화를 통해 연산 효율성을 극대화한다.4</p>
<p>Mamba 블록은 단순히 기존의 상태 공간 모델(State Space Model, SSM)을 트랜스포머에 삽입한 것이 아니다. 이는 트랜스포머의 MLP 블록 구조, 특히 게이트형 MLP(Gated MLP)의 설계를 차용하고, 이를 H3(Hungry Hungry Hippos) 아키텍처의 게이팅 메커니즘과 정교하게 융합한 결과물이다.2 본 절에서는 Mamba 블록이 어떻게 Attention의 시퀀스 혼합 능력과 MLP의 채널 변환 능력을 단일 블록 내에서 통합했는지, 그리고 이러한 통합이 가져오는 수학적, 공학적 이점은 무엇인지 심층적으로 분석한다. 우리는 Mamba 블록의 내부 텐서 역학(Tensor Dynamics)을 해부하고, 선택적 SSM(Selective SSM)이 어떻게 Attention의 기능을 대체하면서도 선형 복잡도를 유지하는지, 그리고 이것이 포스트 트랜스포머 시대의 새로운 표준이 될 수 있는 이론적 근거를 제시한다.</p>
<h2>2.  기존 시퀀스 모델링 아키텍처의 구조적 딜레마</h2>
<p>Mamba 블록의 통합 설계를 온전히 이해하기 위해서는 먼저 기존 아키텍처들이 직면했던 구조적 한계와 딜레마를 면밀히 살펴볼 필요가 있다.</p>
<h3>2.1  트랜스포머의 이원화된 처리 구조와 병목</h3>
<p>트랜스포머 모델의 기본 단위인 트랜스포머 블록은 크게 두 단계의 처리를 거친다. 첫 번째는 Attention 레이어로, 이는 “토큰들이 서로 대화하는 공간“이다. 쿼리(Query), 키(Key), 밸류(Value) 행렬 간의 상호작용을 통해 시퀀스 전체의 문맥 정보를 수집하고 가중치를 계산한다. 이 과정은 전역적인 수용 영역(Receptive Field)을 제공하지만, 시퀀스 길이가 길어질수록 연산량과 메모리 요구량이 기하급수적으로 증가한다.8 두 번째 단계인 MLP 레이어는 “각 토큰이 스스로를 숙고하는 공간“이다. Attention을 통해 수집된 정보를 바탕으로, 각 토큰의 벡터 표현을 고차원으로 확장했다가 다시 축소하는 과정을 통해 복잡한 특징을 추출한다.</p>
<p>이러한 이원화된 구조는 하드웨어 최적화 관점에서 상당한 오버헤드를 발생시킨다. Attention 연산은 대규모 KV 캐시(Key-Value Cache)를 필요로 하여 메모리 대역폭 집약적(Memory-bound)인 특성을 가지는 반면, MLP 연산은 대규모 행렬 곱셈을 포함하여 연산 집약적(Compute-bound)인 특성을 가진다.6 서로 다른 특성을 가진 두 모듈이 번갈아 배치되는 구조는 GPU와 같은 가속기에서 파이프라인을 최적화하거나 메모리 계층을 효율적으로 활용하는 데 제약을 가한다. 또한, 전체 파라미터의 약 2/3를 차지하는 MLP 블록이 시퀀스 혼합(Temporal Mixing)에는 전혀 관여하지 않는다는 점은 파라미터 효율성 측면에서 낭비적 요소로 지적되어 왔다.</p>
<h3>2.2  초기 SSM의 한계와 H3 아키텍처의 복잡성</h3>
<p>S4(Structured State Space Sequence) 모델과 같은 초기 SSM은 순환적(Recurrent) 연산과 컨볼루션(Convolution) 연산의 이중성을 활용하여 긴 시퀀스를 효율적으로 처리할 수 있는 가능성을 보여주었다.1 그러나 이들은 선형 시불변(Linear Time Invariant, LTI) 시스템에 기반을 두고 있어, 입력 데이터의 내용에 따라 동적으로 반응하는 능력, 즉 ‘내용 기반 추론(Content-aware Reasoning)’ 능력이 부족했다. 이는 언어 모델링과 같이 문맥에 따른 단어의 의미 변화가 심한 작업에서 트랜스포머에 비해 성능이 떨어지는 주된 원인이었다.3</p>
<p>이를 극복하기 위해 제안된 H3(Hungry Hungry Hippos) 아키텍처는 SSM을 두 개의 게이트 연결 사이에 배치하고, 표준적인 로컬 컨볼루션(Local Convolution)을 추가하여 “Shift-SSM” 구조를 형성했다. H3는 이론적으로 선형 Attention과 유사한 메커니즘을 구현하며 SSM의 성능을 트랜스포머 수준으로 끌어올리는 데 기여했다.5 H3의 구조는 다음과 같이 표현될 수 있다:<br />
<span class="math math-display">
y = \text{SSM}(x \cdot \sigma(W_1 x)) \cdot \sigma(W_2 x)
</span><br />
그러나 H3는 구조적으로 매우 복잡했다. 입력 투영, 시프트 연산(Shift operation), SSM 연산, 그리고 여러 단계의 게이팅과 곱셈 연산이 얽혀 있어, 실제 구현 시 하드웨어 효율성을 저해하는 요소가 많았다. 특히, Shift-SSM과 Main-SSM이라는 두 종류의 SSM을 혼용하고, 이를 다시 게이팅 메커니즘으로 감싸는 구조는 모델의 깊이를 깊게 쌓거나 대규모로 확장하는 데 있어 최적화 난이도를 높이는 요인이었다.13 Mamba는 이러한 복잡한 H3 아키텍처를 기반으로 하되, 이를 현대적인 LLM에서 널리 사용되는 Gated MLP 구조와 융합함으로써 “간소화(Simplification)“를 달성하고, 동시에 성능을 극대화하는 방향으로 진화했다.</p>
<h2>3.  Mamba 블록의 아키텍처 해부: Gated MLP와 SSM의 통합</h2>
<p>Mamba 아키텍처의 핵심은 트랜스포머의 Attention 블록과 MLP 블록을 각각 별도로 두는 대신, 이들을 통합하여 하나의 균일한 블록(Homogeneous Block)을 형성한다는 데 있다. 이를 위해 Mamba는 트랜스포머의 MLP 블록, 특히 SwiGLU(Swish Gated Linear Unit) 활성화 함수를 사용하는 Gated MLP의 구조적 틀을 차용한다.4 Mamba 블록은 이 Gated MLP 구조 내부에 핵심 연산 요소로 선택적 SSM(Selective SSM)을 배치함으로써, 정보의 비선형 변환과 시퀀스 혼합을 동시에 수행한다.</p>
<h3>3.1  입력 투영(Input Projection) 및 확장(Expansion)</h3>
<p>Mamba 블록의 데이터 흐름은 입력 텐서 <span class="math math-inline">x</span> (형상: <span class="math math-inline">B \times L \times D</span>)를 처리하는 것으로 시작된다. 여기서 <span class="math math-inline">B</span>는 배치 크기, <span class="math math-inline">L</span>은 시퀀스 길이, <span class="math math-inline">D</span>는 모델의 은닉 차원(Hidden Dimension)이다. 첫 번째 단계는 입력을 더 높은 차원으로 투영하여 정보를 확장하는 것이다. 이는 트랜스포머의 FFN이 은닉 차원을 4배 등으로 확장하는 것과 유사한 개념이나, Mamba에서는 확장 계수(Expansion Factor) <span class="math math-inline">E</span>를 사용하여 채널 차원을 <span class="math math-inline">E \times D</span>로 확장한다. 일반적으로 Mamba 모델에서는 <span class="math math-inline">E=2</span>를 사용한다.3</p>
<p>이 투영 과정에서 Mamba의 독특한 구조적 특징인 **이중 경로(Dual Branch)**가 형성된다. 입력 <span class="math math-inline">x</span>는 선형 투영(Linear Projection)을 통해 두 개의 서로 다른 경로로 분기된다.</p>
<ol>
<li><strong>메인 브랜치 (Main Branch):</strong> 실제 SSM 연산과 시퀀스 혼합이 수행되는 경로이다.</li>
<li><strong>게이트 브랜치 (Gate Branch):</strong> 정보의 흐름을 제어하고 필터링하는 경로이다.</li>
</ol>
<p>이를 수식으로 표현하면 다음과 같다:<br />
<span class="math math-display">
x_{proj} = \text{Linear}_{in}(x) \quad (\text{Shape}: B \times L \times 2ED)
</span><br />
투영된 결과 <span class="math math-inline">x_{proj}</span>는 채널 차원을 기준으로 두 개의 텐서로 분할(chunk)된다. 하나는 메인 브랜치의 입력 <span class="math math-inline">u</span>가 되고, 다른 하나는 게이트 브랜치의 입력 <span class="math math-inline">z</span>가 된다. 두 텐서 모두 <span class="math math-inline">B \times L \times ED</span>의 형상을 가진다.16</p>
<h4>3.1.1  1D 컨볼루션 (Short Convolution): 지역적 맥락의 포착</h4>
<p>메인 브랜치로 진입한 입력 <span class="math math-inline">u</span>는 먼저 1D 컨볼루션 레이어를 통과한다. Mamba 논문과 구현체에서는 일반적으로 커널 크기 4의 1D 컨볼루션을 사용한다.3<br />
<span class="math math-display">
x&#39;_{conv} = \text{Conv1d}(u) \quad (\text{Kernel Size}=4, \text{Groups}=ED)
</span><br />
이 짧은 1D 컨볼루션(Short Convolution)은 아키텍처 내에서 매우 중요한, 하지만 종종 간과되는 역할을 수행한다. SSM이 본질적으로 순환적 특성을 통해 무한히 긴 시퀀스의 정보를 압축하는 데 강점이 있다면, 이 컨볼루션 레이어는 **“지역적 맥락(Local Context)”**을 포착하는 역할을 담당한다.5</p>
<p>언어 모델링과 같은 시퀀스 데이터에서는 인접한 토큰 간의 관계(예: n-gram 정보, 문법적 호응)가 매우 중요하다. SSM의 순환 상태(State)가 전역적인 정보를 요약한다면, 이 Conv1d 레이어는 SSM이 처리하기 전에 인접한 토큰들 사이의 상호작용을 미리 계산하여 지역적인 특징을 추출한다. 이는 H3 아키텍처에서 사용되었던 ’Shift-SSM’을 더 단순하고 효율적인 연산으로 대체한 것으로 볼 수 있으며, 모델의 학습 안정성과 성능을 높이는 데 기여한다.12 이 컨볼루션은 채널별(Depthwise)로 수행되므로 파라미터 수가 적고 연산 비용이 매우 낮다.</p>
<p>컨볼루션 이후에는 비선형 활성화 함수인 SiLU(Sigmoid Linear Unit)가 적용된다.<br />
<span class="math math-display">
x_{act} = \text{SiLU}(x&#39;_{conv})
</span><br />
이 단계까지는 트랜스포머의 FFN 구조와 유사하지만, 시퀀스 차원에서의 연산(Conv1d)이 포함되어 있다는 점에서 차이가 있다.</p>
<h4>3.1.2  선택적 SSM (Selective SSM): 아키텍처의 심장</h4>
<p>활성화된 입력 <span class="math math-inline">x_{act}</span>는 이제 Mamba 아키텍처의 가장 핵심적인 부분인 선택적 SSM(Selective SSM, S6) 모듈로 진입한다. 여기서 기존의 LTI(Linear Time Invariant) SSM과 결정적인 차별점이 발생한다. 기존 SSM(S4 등)에서는 시스템 행렬 <span class="math math-inline">A, B, C</span>가 시간과 입력에 관계없이 고정되어 있었으나, Mamba에서는 입력 <span class="math math-inline">x_{act}</span>에 따라 <span class="math math-inline">B, C, \Delta</span> 파라미터가 매 시점마다 동적으로 생성된다.1</p>
<ol>
<li>입력 의존적 파라미터 생성 (Input-Dependent Parameterization):</li>
</ol>
<p>입력 텐서 <span class="math math-inline">x_{act}</span> (형상: <span class="math math-inline">B \times L \times ED</span>)로부터 선형 투영을 통해 <span class="math math-inline">\Delta</span> (시간 스텝/이산화 계수), <span class="math math-inline">B</span> (입력 제어 행렬), <span class="math math-inline">C</span> (출력 제어 행렬)를 생성한다.<br />
<span class="math math-display">
   \Delta, B, C = \text{Linear}_{SSM}(x_{act})
</span><br />
이때 <span class="math math-inline">\Delta</span>는 <span class="math math-inline">B \times L \times ED</span>의 형상을 가지며, <span class="math math-inline">B</span>와 <span class="math math-inline">C</span>는 <span class="math math-inline">B \times L \times N</span>의 형상을 가진다 (<span class="math math-inline">N</span>은 SSM의 상태 차원). 이 과정은 모델이 시퀀스의 현재 내용(Content)에 따라 정보를 선별적으로 기억하거나 망각할 수 있는 능력을 부여한다. 예를 들어, <span class="math math-inline">\Delta</span> 값이 크면 현재 입력이 상태(State)에 미치는 영향이 커지고 과거 정보는 빠르게 잊혀지며(Reset), 반대로 <span class="math math-inline">\Delta</span> 값이 작으면 과거의 상태가 오래 유지된다(Memory).4 이는 Attention 메커니즘의 “내용 기반 주소 지정(Content-based addressing)“과 기능적으로 동등한 효과를 낸다.</p>
<ol start="2">
<li>이산화 (Discretization) 및 상태 업데이트:</li>
</ol>
<p>생성된 연속 시간(Continuous-time) 파라미터들은 ZOH(Zero-Order Hold) 방식을 통해 이산화된 파라미터 <span class="math math-inline">\bar{A}, \bar{B}</span>로 변환된다.<br />
<span class="math math-display">
   \bar{A}_t = \exp(\Delta_t A)\\
   \bar{B}_t = (\Delta_t A)^{-1}(\exp(\Delta_t A) - I) \cdot \Delta_t B_t
</span><br />
이후 상태 공간 방정식에 따라 잠재 상태(Latent State) <span class="math math-inline">h_t</span>가 업데이트되고 출력 <span class="math math-inline">y_t</span>가 계산된다.<br />
<span class="math math-display">
h_t = \bar{A}_t h_{t-1} + \bar{B}_t x_{act, t} </span>   <span class="math math-display"> y_t = C_t h_t
   </span><br />
이 연산은 순환적(Recurrent) 성격을 띠지만, Mamba는 이를 GPU 하드웨어에 최적화된 <strong>선택적 스캔(Selective Scan)</strong> 알고리즘을 통해 병렬적으로 처리한다.3 선택적 스캔은 Prefix Sum(누적 합) 알고리즘의 원리를 이용하여, 순차적인 의존성을 가진 연산을 <span class="math math-inline">O(\log L)</span>의 병렬 깊이로 수행할 수 있게 한다. 또한, 커널 퓨전(Kernel Fusion)을 통해 중간 상태 <span class="math math-inline">h_t</span>를 HBM(High Bandwidth Memory)에 저장하지 않고 고속 SRAM에서만 처리함으로써 메모리 대역폭 병목을 획기적으로 줄인다.3</p>
<h4>4.2.3.4 게이팅 및 출력 투영 (Gating and Output Projection)</h4>
<p>SSM 모듈을 통과하여 시퀀스 혼합이 이루어진 출력 <span class="math math-inline">y</span>는, 앞서 분리해 둔 게이트 브랜치의 신호 <span class="math math-inline">z</span>와 결합된다. 게이트 브랜치 입력 <span class="math math-inline">z</span> 역시 활성화 함수(SiLU)를 통과한다.</p>
<p><span class="math math-display">z_{act} = \text{SiLU}(z)</span>최종적으로 SSM의 출력과 게이트 활성화 값이 요소별 곱(Element-wise Multiplication)을 수행한다.<br />
<span class="math math-display">
y_{gated} = y \odot z_{act}
</span><br />
이 구조는 **SwiGLU (Swish Gated Linear Unit)**와 수학적으로, 구조적으로 매우 유사하다.14 트랜스포머의 최신 변형들(PaLM, LLaMA 등)에서 사용되는 SwiGLU는 <span class="math math-inline">x \cdot \text{SiLU}(W_g x)</span> 형태를 띠는데, Mamba는 여기서 <span class="math math-inline">x</span>에 해당하는 부분에 선택적 SSM 변환을 적용한 <span class="math math-inline">SSM(x) \cdot \text{SiLU}(z)</span> 형태를 취한다. 즉, SSM이 MLP 내부의 선형 변환 경로 중 하나를 대체하여 시퀀스 혼합 기능을 수행하도록 통합된 것이다.4</p>
<p>마지막으로, 출력 투영 레이어를 통해 확장된 차원 <span class="math math-inline">ED</span>를 원래의 모델 차원 <span class="math math-inline">D</span>로 축소(복원)한다.<br />
<span class="math math-display">
Output = \text{Linear}_{out}(y_{gated}) \quad (\text{Shape}: B \times L \times D)
</span><br />
여기에 잔차 연결(Residual Connection)이 더해져 다음 Mamba 블록으로 전달된다.</p>
<h3>3.2  Attention과 MLP의 기능적 융합 및 텐서 역학 분석</h3>
<p>Mamba 블록 구조는 단순히 부품을 조립한 것이 아니라, 트랜스포머의 두 가지 핵심 기능인 ’정보 라우팅’과 ’비선형 변환’을 하나로 융합한 철학적 결과물이다. 이를 텐서 역학(Tensor Dynamics)의 관점에서 분석하면 통합의 효율성이 더욱 명확해진다.4</p>
<h4>3.2.1  Mamba 블록 내부 텐서 흐름도</h4>
<p>다음 표는 Mamba 블록 내부의 데이터 처리 단계별 텐서 형상과 연산 내용을 요약한 것이다.</p>
<table><thead><tr><th><strong>단계 (Stage)</strong></th><th><strong>연산 설명 (Operation)</strong></th><th><strong>입력 형상 (Input Shape)</strong></th><th><strong>출력 형상 (Output Shape)</strong></th><th><strong>비고 (Remarks)</strong></th></tr></thead><tbody>
<tr><td><strong>Input</strong></td><td>블록 입력</td><td><span class="math math-inline">(B, L, D)</span></td><td>-</td><td><span class="math math-inline">B</span>: 배치, <span class="math math-inline">L</span>: 길이, <span class="math math-inline">D</span>: 모델 차원</td></tr>
<tr><td><strong>Projection</strong></td><td><code>Linear(D -&gt; 2*E*D)</code></td><td><span class="math math-inline">(B, L, D)</span></td><td><span class="math math-inline">(B, L, 2ED)</span></td><td>확장 계수 <span class="math math-inline">E</span> (보통 2)</td></tr>
<tr><td><strong>Split</strong></td><td>Main/Gate 분기</td><td><span class="math math-inline">(B, L, 2ED)</span></td><td><span class="math math-inline">(B, L, ED)</span> x 2</td><td><span class="math math-inline">u</span> (SSM용), <span class="math math-inline">z</span> (Gate용)</td></tr>
<tr><td><strong>Conv1d</strong></td><td>지역 컨볼루션</td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, ED)</span></td><td>Main 브랜치 적용, 커널 크기 4</td></tr>
<tr><td><strong>Activation</strong></td><td><code>SiLU</code></td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, ED)</span></td><td>비선형성 주입</td></tr>
<tr><td><strong>SSM Params</strong></td><td><code>Linear(ED -&gt; N+N+D)</code></td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, N)</span></td><td><span class="math math-inline">\Delta, B, C</span> 생성 (<span class="math math-inline">N</span>: 상태 차원)</td></tr>
<tr><td><strong>SSM Core</strong></td><td><code>Selective Scan</code></td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, ED)</span></td><td>잠재 상태 <span class="math math-inline">h: (B, L, ED, N)</span></td></tr>
<tr><td><strong>Gating</strong></td><td><code>y * SiLU(z)</code></td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, ED)</span></td><td>Gate 브랜치와 결합 (SwiGLU 유사)</td></tr>
<tr><td><strong>Output Proj</strong></td><td><code>Linear(ED -&gt; D)</code></td><td><span class="math math-inline">(B, L, ED)</span></td><td><span class="math math-inline">(B, L, D)</span></td><td>차원 복원 및 축소</td></tr>
</tbody></table>
<p>위 표에서 확인할 수 있듯이, Mamba 블록은 내부적으로 차원을 확장(<span class="math math-inline">E</span>배)하여 풍부한 표현력을 확보한 뒤, SSM을 통해 시퀀스 정보를 압축 및 혼합하고, 다시 원래 차원으로 복원하는 “확장-처리-복원“의 흐름을 따른다. 여기서 중요한 점은 <strong>SSM 연산이 확장된 차원(<span class="math math-inline">ED</span>)에서 각 채널별로 독립적으로(Channel-wise) 수행된다</strong>는 것이다. 이는 트랜스포머의 Multi-Head Attention이 헤드별로 정보를 나누어 처리하는 것과 유사한 효과를 내면서도, 헤드 간의 복잡한 연산이나 Attention Map 계산 비용을 제거했다.3</p>
<h4>3.2.2  정보 라우팅(Routing)과 변환(Transformation)의 융합</h4>
<p>트랜스포머에서 Attention은 시퀀스 전체를 스캔하여 정보를 어디서 가져올지 결정하는 ‘라우팅’ 역할을, MLP는 각 토큰의 정보를 가공하는 ‘변환’ 역할을 수행한다. Mamba 블록은 이 경계를 허문다.</p>
<ul>
<li><strong>선택적 SSM 파트:</strong> 입력 <span class="math math-inline">x_t</span>에 따라 <span class="math math-inline">\Delta, B, C</span> 파라미터가 변하므로, 특정 시점의 정보가 은닉 상태 <span class="math math-inline">h</span>에 얼마나 반영될지(Write), 그리고 <span class="math math-inline">h</span>에서 얼마나 추출될지(Read)를 동적으로 결정한다. 이는 Attention의 <span class="math math-inline">Softmax(QK^T)</span> 가중치 계산과 기능적으로 동등하며, 결과적으로 시퀀스 내의 정보를 <strong>라우팅</strong>한다. 이 과정은 <span class="math math-inline">O(N^2)</span>의 비용 없이 <span class="math math-inline">O(N)</span>의 비용으로 수행된다.4</li>
<li><strong>Gated MLP 파트:</strong> 투영(Projection) 레이어와 활성화 함수, 그리고 게이팅 메커니즘은 각 채널별로 정보를 <strong>변환</strong>하고 필터링한다.</li>
</ul>
<p>따라서 Mamba 블록은 “시간 축 혼합(Temporal Mixing)“과 “채널 축 혼합(Channel Mixing)“을 하나의 블록 내에서 동시에, 그리고 유기적으로 수행한다. 이는 트랜스포머가 Attention 블록 다음에 MLP 블록을 배치해야만 했던 이중 구조를 단일 블록의 적층으로 단순화시킨다.2</p>
<h4>3.2.3  암시적 어텐션 (Implicit Attention)</h4>
<p>최근 연구에 따르면, Mamba의 선택적 SSM 메커니즘은 **“암시적 어텐션(Implicit Attention)”**으로 해석될 수 있다.20 Mamba는 명시적인 Attention 행렬(<span class="math math-inline">A \in \mathbb{R}^{L \times L}</span>)을 계산하거나 저장하지 않지만, 그 내부의 상태 업데이트 과정(수식 (10) 등)을 펼쳐보면(unroll), 각 토큰이 과거의 모든 토큰에 대해 가지는 유효 가중치를 역추적할 수 있다.</p>
<p>트랜스포머의 Attention 행렬이 쿼리와 키의 내적에 의해 결정되는 전역적이고 정적인 스냅샷이라면, Mamba의 암시적 Attention은 순환적인 게이팅의 누적 효과로 나타난다. 이는 Mamba가 Transformer보다 훨씬 더 많은 수의 “유효 Attention 행렬“을 내부적으로 생성하고 있음을 시사하며(채널마다 다른 역학을 가지므로), 이는 Mamba가 적은 파라미터로도 높은 성능을 내는 원인 중 하나로 분석된다. 시각화 연구 결과, Mamba의 암시적 Attention 맵은 Transformer의 Attention 맵과 유사하게 지역적 패턴과 장거리 의존성 패턴을 모두 포착하는 것으로 확인되었다.21</p>
<h3>3.3  아키텍처 간소화의 공학적 파급 효과</h3>
<p>Mamba 블록 구조의 통합 및 간소화는 모델 설계, 학습, 추론의 전 과정에 걸쳐 심대한 공학적 이점을 제공한다.</p>
<h4>3.3.1  동질적 아키텍처(Homogeneous Architecture)와 확장성</h4>
<p>트랜스포머 아키텍처는 <code>Attention -&gt; Add&amp;Norm -&gt; MLP -&gt; Add&amp;Norm</code>의 이질적 블록 반복으로 구성된다. 반면 Mamba는 <code>Mamba Block -&gt; Add&amp;Norm</code>의 단순 반복 구조를 가진다. 이러한 동질성은 모델의 깊이 확장(Scaling depth)을 더 직관적으로 만들고, 대규모 분산 학습 시 파이프라인 병렬화(Pipeline Parallelism)나 텐서 병렬화(Tensor Parallelism)를 구현할 때 로드 밸런싱(Load Balancing)을 용이하게 한다.3 모든 레이어가 동일한 메모리 사용량과 연산 패턴을 가지므로, 특정 레이어(예: Attention)에서 메모리 스파이크가 발생하는 현상을 방지할 수 있어 하드웨어 리소스 관리 측면에서 유리하다.</p>
<h4>3.3.2  하이퍼파라미터 튜닝의 단순화</h4>
<p>Attention과 MLP가 분리된 구조에서는 각 모듈의 크기 비율(보통 1:4), Attention 헤드의 수, 헤드 차원 등 튜닝해야 할 하이퍼파라미터가 복잡하게 얽혀 있다. 반면 Mamba 블록은 통합된 구조 덕분에 주요 하이퍼파라미터가 블록의 차원(<span class="math math-inline">D</span>), 상태 차원(<span class="math math-inline">N</span>, 보통 16), 확장 계수(<span class="math math-inline">E</span>, 보통 2) 등으로 단순화된다. 이는 새로운 데이터셋이나 도메인에 모델을 적용할 때 탐색해야 할 하이퍼파라미터 공간을 줄여주며, 연구 및 개발의 효율성을 높인다.24</p>
<h4>3.3.3  추론 효율성과 선형 복잡도</h4>
<p>가장 극적인 이점은 추론 시점에서 드러난다. 트랜스포머는 시퀀스 길이가 길어질수록 KV 캐시의 크기가 선형적으로 증가하고, Attention 연산량은 2차적으로 증가한다. 반면, Mamba는 학습 시에는 병렬 처리(Parallel Scan)를 통해 트랜스포머와 유사한 속도로 학습하고, 추론 시에는 순환 모드(Recurrent Mode)로 전환하여 고정된 크기의 상태(State)만을 유지한다. 이는 시퀀스 길이에 관계없이 토큰 생성 시 <strong>상수 시간(<span class="math math-inline">O(1)</span>) 복잡도</strong>와 <strong>상수 메모리(<span class="math math-inline">O(1)</span>) 사용량</strong>을 보장한다.1</p>
<p>실험 결과에 따르면, Mamba는 100만 토큰 이상의 긴 시퀀스에서도 메모리 부족(OOM) 없이 처리가 가능하며, 트랜스포머 대비 최대 5배 이상의 추론 처리량(Throughput)을 보인다. 이는 긴 문맥을 요구하는 문서 요약, DNA 서열 분석, 고해상도 오디오/비디오 생성 등의 작업에서 Mamba가 트랜스포머를 대체할 수 있는 강력한 근거가 된다.4</p>
<h3>3.4  비교 분석: Transformer vs. H3 vs. Mamba</h3>
<p>Mamba 블록의 우수성을 명확히 하기 위해, 주요 아키텍처들과의 구조적 비교를 수행한다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Transformer (Attention + MLP)</strong></th><th><strong>H3 (Shift-SSM + SSM)</strong></th><th><strong>Mamba (Selective SSM + Gated MLP)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 연산</strong></td><td><span class="math math-inline">O(L^2)</span> Matrix Multiply</td><td><span class="math math-inline">O(L \log L)</span> FFT / Scan</td><td><span class="math math-inline">O(L)</span> Parallel Scan</td></tr>
<tr><td><strong>블록 구조</strong></td><td>이질적 (Attn &amp; MLP 분리)</td><td>복잡함 (SSM 샌드위치 구조)</td><td><strong>통합 및 단순화 (Single Block)</strong></td></tr>
<tr><td><strong>시퀀스 혼합</strong></td><td>Multi-Head Attention</td><td>Shift-SSM + Main SSM</td><td><strong>Conv1d + Selective SSM</strong></td></tr>
<tr><td><strong>채널 변환</strong></td><td>Position-wise MLP</td><td>Gated Projection</td><td><strong>Gated MLP (SwiGLU 구조)</strong></td></tr>
<tr><td><strong>내용 기반 선택</strong></td><td>명시적 (Attention Weights)</td><td>제한적</td><td><strong>내재적 (Input-dependent Parameters)</strong></td></tr>
<tr><td><strong>추론 속도</strong></td><td>시퀀스 길이에 따라 저하</td><td>빠름</td><td><strong>매우 빠름 (Constant Time)</strong></td></tr>
</tbody></table>
<p>H3 아키텍처와 비교했을 때, Mamba는 H3가 시퀀스 혼합을 위해 사용했던 복잡한 Shift-SSM을 단순한 <strong>Conv1d</strong>로 대체하고, 두 개의 게이트로 감싸져 있던 SSM 구조를 하나의 <strong>Gated MLP</strong> 프레임워크로 통합함으로써 간결성을 확보했다.5 실험 결과, Mamba는 H3와 유사하거나 더 적은 파라미터로도 언어 모델링 및 합성 작업(Copying Task 등)에서 월등히 높은 성능을 보였으며, 이는 “단순한 것이 더 강력하다(Simpler is stronger)“는 딥러닝의 격언을 다시 한번 입증한다.13</p>
<h3>3.5  결론: 포스트 트랜스포머를 향한 도약</h3>
<p>요약하자면, Mamba 블록 구조(4.2)는 트랜스포머 시대의 이원적 사고(Attention 대 MLP)를 극복하고, 시퀀스 모델링의 본질인 “상태 관리(State Management)“와 “정보 변환(Information Transformation)“을 단일한 계산 단위로 통합해낸 혁신적인 아키텍처이다.</p>
<ol>
<li><strong>구조적 통합:</strong> Gated MLP 구조 내에 선택적 SSM을 삽입함으로써, 비선형 변환과 시퀀스 혼합을 동시에, 효율적으로 수행한다.</li>
<li><strong>선택적 메커니즘:</strong> 입력에 따라 동적으로 변하는 SSM 파라미터를 통해 Attention의 문맥 인식 능력을 선형 복잡도로 구현했다.</li>
<li><strong>구현의 간소화:</strong> H3 등 이전 SSM 아키텍처의 불필요한 복잡성을 제거하고, 하드웨어 친화적인 설계를 통해 실제 연산 속도를 극대화했다.</li>
</ol>
<p>이러한 통합 및 간소화는 Mamba가 단순히 “빠른 RNN“에 머무르지 않고, 대규모 언어 모델(LLM) 및 다양한 모달리티의 백본으로서 트랜스포머를 대체하거나 보완할 수 있는 강력한 후보가 된 근본적인 이유이다. Mamba 블록은 딥러닝 아키텍처가 복잡성을 줄이면서도 성능을 높이는 방향으로 진화할 수 있음을 보여주는 중요한 사례이며, 향후 등장할 하이브리드 모델이나 더 진보된 SSM 기반 모델들의 초석이 될 것이다. 다음 절에서는 이러한 Mamba 블록이 실제 하드웨어 상에서 어떻게 구현되고 최적화되는지, 그 구현의 핵심인 ’하드웨어 인지 알고리즘’에 대해 다룬다.</p>
<h2>4. 참고 자료</h2>
<ol>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://arxiv.org/abs/2312.00752</li>
<li>Mamba-MLP-Transformer Architecture - Emergent Mind, https://www.emergentmind.com/topics/mamba-mlp-transformer-architecture</li>
<li>Mamba: Make Sequence Models Fast Again | by Dong-Keon Kim, https://medium.com/@kdk199604/mamba-make-sequence-models-fast-again-540245a49155</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://arxiv.org/pdf/2312.00752</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://arxiv.org/html/2312.00752v2</li>
<li>Mamba: New Selective State Space Model vs Transformer - ALLPCB, https://www.allpcb.com/allelectrohub/mamba-new-selective-state-space-model-vs-transformer</li>
<li>Mamba (deep learning architecture) - Wikipedia, https://en.wikipedia.org/wiki/Mamba_(deep_learning_architecture)</li>
<li>Towards Mamba State Space Models for Images, Videos and Time …, https://towardsdatascience.com/towards-mamba-state-space-models-for-images-videos-and-time-series-1e0bfdb5933a/</li>
<li>[D] - Why MAMBA did not catch on? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/1hpg91o/d_why_mamba_did_not_catch_on/</li>
<li>Mamba-360: Survey of State Space Models as Transformer … - arXiv, https://arxiv.org/html/2404.16112v1</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces, https://openreview.net/forum?id=tEYskw1VY2</li>
<li>Mamba architecture : A Leap Forward in Sequence Modeling, https://medium.com/@puneetthegde22/mamba-architecture-a-leap-forward-in-sequence-modeling-370dfcbfe44a</li>
<li>MAMBA: LINEAR-TIME SEQUENCE MODELING WITH SELECTIVE …, https://openreview.net/pdf?id=AL1fq05o7H</li>
<li>Transformer Design Guide (Part 2: Modern Architecture), https://rohitbandaru.github.io/blog/Transformer-Design-Guide-Pt2/</li>
<li>What Is A Mamba Model? | IBM, https://www.ibm.com/think/topics/mamba-model</li>
<li>What is a Mamba model - GeeksforGeeks, https://www.geeksforgeeks.org/artificial-intelligence/what-is-a-mamba-model/</li>
<li>Mamba Explained - The Gradient, https://thegradient.pub/mamba-explained/</li>
<li>A Deep Dive into MAMBA and State Space Models for Long …, https://ssm-ed2.pages.dev/</li>
<li>Here Comes Mamba: The Selective State Space Model, https://towardsdatascience.com/here-comes-mamba-the-selective-state-space-model-435e5d17a451/</li>
<li>The Hidden Attention of Mamba Models - arXiv, https://arxiv.org/html/2403.01590v1</li>
<li>Hidden Attention of Mamba Models | PDF - Scribd, https://www.scribd.com/document/895312249/Hidden-Attention-of-Mamba-Models</li>
<li>The Hidden Attention of Mamba Models - arXiv, https://arxiv.org/html/2403.01590v2</li>
<li>A Mamba Foundation Model for Time Series Forecasting - arXiv, https://arxiv.org/html/2411.02941v1</li>
<li>How Selective State Space Models Boost Mamba’s Performance, https://hackernoon.com/how-selective-state-space-models-boost-mambas-performance</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>