<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.2 선택적 스캔(Selective Scan) 알고리즘과 정보의 압축 및 선별</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.2 선택적 스캔(Selective Scan) 알고리즘과 정보의 압축 및 선별</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">MAMBA - 포스트 트랜스포머 시대의 도래</a> / <span>3.2 선택적 스캔(Selective Scan) 알고리즘과 정보의 압축 및 선별</span></nav>
                </div>
            </header>
            <article>
                <h1>3.2 선택적 스캔(Selective Scan) 알고리즘과 정보의 압축 및 선별</h1>
<p>인공지능 시퀀스 모델링의 역사에서 ’효율성(Efficiency)’과 ’표현력(Expressivity)’은 양립하기 어려운 두 마리 토끼였다. 트랜스포머(Transformer) 아키텍처는 어텐션 메커니즘(Attention Mechanism)을 통해 시퀀스 내의 모든 토큰 간 상호작용을 모델링함으로써 압도적인 표현력을 증명했지만, 시퀀스 길이의 제곱(<span class="math math-inline">O(N^2)</span>)에 비례하는 연산 복잡도와 추론 시 키-값(KV) 캐시 메모리의 선형적 증가라는 비용을 치러야 했다.1 반면, 순환 신경망(RNN)이나 초기 상태 공간 모델(SSM)은 선형 시간(<span class="math math-inline">O(N)</span>) 추론과 고정된 메모리 사용량이라는 뛰어난 효율성을 가졌음에도 불구하고, 긴 문맥을 효과적으로 압축하고 복원하는 능력, 즉 표현력의 한계에 부딪혔다.</p>
<p>Mamba 아키텍처의 핵심인 <strong>선택적 스캔(Selective Scan)</strong> 알고리즘은 이 오랜 딜레마를 해결하기 위한 결정적인 기술적 도약이다. 본 절에서는 Mamba가 어떻게 기존 SSM의 선형 시불변(LTI) 제약을 타파하고 ’선택(Selection)’이라는 새로운 패러다임을 도입했는지, 그리고 이를 하드웨어 수준에서 구현하기 위해 어떠한 알고리즘적 혁신과 최적화를 수행했는지 심층적으로 분석한다. 나아가, 정보 이론적 관점에서 선택적 스캔이 시퀀스 데이터를 어떻게 압축하고 선별하여 ’문맥(Context)’을 ’상태(State)’로 변환하는지에 대한 메커니즘을 규명한다.</p>
<h2>1.  선형 시불변(LTI) 시스템의 구조적 한계와 선택의 필요성</h2>
<p>Mamba의 선택적 스캔 알고리즘을 온전히 이해하기 위해서는 먼저 기존의 구조화된 상태 공간 모델(Structured SSM), 특히 S4(Structured State Space for Sequence Modeling)와 같은 모델들이 기반하고 있는 선형 시불변(Linear Time-Invariant, LTI) 시스템의 본질적 특성과 그 한계를 명확히 인식해야 한다.</p>
<h3>1.1  LTI 시스템의 등방성(Isotropy)과 정보 처리의 경직성</h3>
<p>전통적인 SSM은 연속적인 시간의 역학을 모델링하는 미분 방정식을 이산화하여 시퀀스 데이터를 처리한다. 이때 계산의 효율성을 극대화하기 위해 모델의 핵심 파라미터인 <span class="math math-inline">(\Delta, \mathbf{A}, \mathbf{B}, \mathbf{C})</span>를 시간 <span class="math math-inline">t</span>에 관계없이 고정된 상수로 설정하는 LTI 시스템을 채택해 왔다.2<br />
<span class="math math-display">
\begin{aligned} h_t &amp;= \bar{\mathbf{A}}h_{t-1} + \bar{\mathbf{B}}x_t \\ y_t &amp;= \mathbf{C}h_t \end{aligned}
</span><br />
위 식에서 행렬 <span class="math math-inline">\bar{\mathbf{A}}</span>와 <span class="math math-inline">\bar{\mathbf{B}}</span>가 모든 시점 <span class="math math-inline">t</span>에서 동일하다는 것은, 모델이 입력 시퀀스의 내용(Content)이 무엇이든, 시점 <span class="math math-inline">t</span>가 언제이든 상관없이 **동일한 역학(Dynamics)**을 적용하여 상태를 업데이트한다는 것을 의미한다.4 이를 정보 처리의 관점에서 해석하면 ’등방성(Isotropy)’이라고 할 수 있다. 즉, 모델은 입력되는 모든 토큰을 평등하게 대우하며, 특정 정보에 더 집중하거나 특정 정보를 무시하는 동적인 제어 능력이 결여되어 있다.</p>
<p>LTI 성질은 수학적으로 거대한 이점을 제공한다. 시스템의 역학이 고정되어 있으므로, 전체 시퀀스에 대한 연산은 입력 <span class="math math-inline">x</span>와 고정된 커널 <span class="math math-inline">\mathbf{K}</span> 간의 합성곱(Convolution)으로 축약될 수 있다(<span class="math math-inline">y = x * \mathbf{K}</span>). 합성곱 정리에 따라 이는 주파수 도메인에서의 곱셈과 같아지며, 고속 푸리에 변환(FFT)을 활용하여 <span class="math math-inline">O(N \log N)</span>의 복잡도로 매우 효율적인 병렬 학습이 가능해진다.1 이것이 초기 SSM들이 트랜스포머의 대항마로 주목받았던 이유이다.</p>
<p>그러나 언어(Language), 유전체(Genomics), 오디오 등 복잡한 실제 데이터는 본질적으로 시변(Time-varying) 특성을 갖는다. 문장의 문맥을 이해하기 위해서는 ‘그것(it)’, ’하지만(but)’과 같은 기능어보다는 핵심 명사나 동사에 더 많은 가중치를 두어야 하며, 문맥의 전환이 일어날 때는 이전 상태를 일부 망각(Reset)하고 새로운 정보를 받아들여야 한다.4 LTI 모델은 이러한 ’내용 기반 추론(Content-based Reasoning)’을 수행할 수 없다. 모든 토큰을 동일한 필터로 처리하는 LTI 모델은 정보를 선택적으로 압축하지 못하고, 불필요한 노이즈까지 상태 공간에 누적시킴으로써 긴 시퀀스에서 성능 저하를 겪게 된다.2</p>
<h3>1.2  선택 메커니즘(Selection Mechanism)의 수학적 정식화</h3>
<p>Mamba는 이러한 LTI의 한계를 극복하기 위해 파라미터들이 입력 데이터에 따라 동적으로 변화하는 **선택 메커니즘(Selection Mechanism)**을 도입하였다. 이는 단순한 파라미터 튜닝이 아니라, 모델의 근본적인 작동 방식을 ’시불변’에서 ’시변’으로 전환하는 구조적 혁신이다.2</p>
<p>Mamba에서는 주요 파라미터인 <span class="math math-inline">\mathbf{B}, \mathbf{C}, \Delta</span>를 입력 <span class="math math-inline">x_t</span>의 함수로 정의한다. 구체적인 수식은 다음과 같다7:<br />
<span class="math math-display">
\begin{aligned} \mathbf{B}_t &amp;= \text{Linear}_N(x_t) \\ \mathbf{C}_t &amp;= \text{Linear}_N(x_t) \\ \Delta_t &amp;= \text{Softplus}(\text{Parameter} + \text{Linear}_1(x_t)) \end{aligned}
</span></p>
<ul>
<li><strong><span class="math math-inline">\mathbf{B}_t</span> (입력 투영):</strong> 현재 입력 <span class="math math-inline">x_t</span>가 상태 <span class="math math-inline">h_t</span>에 얼마나 강하게 반영될지를 결정한다. 즉, ’기록할 가치가 있는 정보인가?’를 판단하는 게이트 역할을 한다.</li>
<li><strong><span class="math math-inline">\mathbf{C}_t</span> (출력 투영):</strong> 현재 상태 <span class="math math-inline">h_t</span>에서 어떤 정보를 추출하여 출력 <span class="math math-inline">y_t</span>로 내보낼지를 결정한다.</li>
<li><strong><span class="math math-inline">\Delta_t</span> (시간 간격/집중도):</strong> 가장 중요한 파라미터로, 정보가 상태 공간에 머무르는 시간을 제어한다. 수학적으로는 이산화(Discretization)의 간격을 의미하지만, 기능적으로는 정보의 ’망각’과 ’유지’를 결정하는 핵심 스위치이다.6</li>
</ul>
<p>이러한 입력 의존적(Input-dependent) 파라미터화는 모델이 매 시점마다 입력된 토큰의 중요도를 평가하고, 그에 따라 자신의 내부 역학을 재구성할 수 있게 한다. 예를 들어, 문맥상 중요하지 않은 ‘필러(Filler)’ 단어가 들어오면 <span class="math math-inline">\Delta_t</span>를 작게 하여 상태 업데이트를 최소화하고(Ignore), 중요한 키워드가 들어오면 <span class="math math-inline">\Delta_t</span>를 크게 하여 해당 정보를 상태에 깊이 각인시킨다(Focus).9</p>
<h3>1.3  합성곱의 붕괴와 새로운 과제</h3>
<p>선택 메커니즘의 도입은 모델링 능력 면에서 비약적인 향상을 가져오지만, 계산 효율성 측면에서는 심각한 문제를 야기한다. 파라미터가 시간에 따라 변하게 되면(<span class="math math-inline">\bar{\mathbf{A}} \to \bar{\mathbf{A}}_t</span>), 교환 법칙이 성립하지 않아 더 이상 전체 연산을 단일 합성곱 커널로 표현할 수 없게 된다.1</p>
<p><strong>표 3.2.1 시퀀스 모델링 아키텍처 비교</strong></p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>트랜스포머 (Attention)</strong></th><th><strong>LTI SSM (S4 등)</strong></th><th><strong>선택적 SSM (Mamba)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 연산</strong></td><td>행렬 곱셈 (<span class="math math-inline">QK^T</span>)</td><td>합성곱 (Convolution)</td><td>선택적 스캔 (Selective Scan)</td></tr>
<tr><td><strong>시간 복잡도 (학습)</strong></td><td><span class="math math-inline">O(N^2)</span> (이차)</td><td><span class="math math-inline">O(N \log N)</span> (준선형)</td><td><span class="math math-inline">O(N)</span> (선형)</td></tr>
<tr><td><strong>시간 복잡도 (추론)</strong></td><td><span class="math math-inline">O(N)</span> (KV 캐시 의존)</td><td><span class="math math-inline">O(1)</span> (상수)</td><td><span class="math math-inline">O(1)</span> (상수)</td></tr>
<tr><td><strong>메모리 복잡도</strong></td><td><span class="math math-inline">O(N^2)</span> 또는 <span class="math math-inline">O(N)</span></td><td><span class="math math-inline">O(N)</span></td><td><span class="math math-inline">O(N)</span></td></tr>
<tr><td><strong>역학 특성</strong></td><td>시변 (입력 의존적)</td><td>시불변 (LTI)</td><td>시변 (입력 의존적)</td></tr>
<tr><td><strong>정보 압축</strong></td><td>비압축 (모든 이력 저장)</td><td>등방성 압축</td><td><strong>선택적 압축</strong></td></tr>
<tr><td><strong>주요 한계</strong></td><td>긴 문맥에서 비용 과다</td><td>내용 기반 추론 불가</td><td>병렬화 구현 난이도 상</td></tr>
</tbody></table>
<p>표 3.2.1에서 볼 수 있듯이, Mamba는 LTI SSM의 효율성(선형 복잡도)과 트랜스포머의 표현력(시변 역학)을 동시에 달성하는 것을 목표로 한다. 그러나 합성곱을 사용할 수 없게 된 상황에서 순차적인 재귀(Recurrence) 연산(<span class="math math-inline">h_t = \bar{\mathbf{A}}_t h_{t-1} + \dots</span>)으로 회귀한다면, GPU의 병렬 처리 능력을 활용하지 못하고 느린 RNN과 다를 바가 없게 된다. 이 딜레마를 해결하는 것이 바로 ‘선택적 스캔(Selective Scan)’ 알고리즘이다.</p>
<h2>2.  선택적 스캔 알고리즘: 순차적 의존성과 병렬화의 역설</h2>
<p>Mamba의 선택적 스캔 알고리즘은 순차적인 의존성을 가진 재귀 연산을 현대적인 병렬 컴퓨팅 하드웨어에서 효율적으로 수행하기 위한 알고리즘적 해법이다. 이는 컴퓨터 과학의 고전적인 기법인 <strong>병렬 접두어 합(Parallel Prefix Sum)</strong> 또는 <strong>스캔(Scan)</strong> 알고리즘을 상태 공간 모델에 적용한 것이다.2</p>
<h3>2.1  이산화(Discretization)와 제로 오더 홀드(ZOH)</h3>
<p>선택적 스캔을 수행하기 전, 연속 파라미터는 이산 파라미터로 변환되어야 한다. Mamba는 이 과정에서 <strong>제로 오더 홀드(Zero-Order Hold, ZOH)</strong> 방식을 채택한다. ZOH는 시간 간격 <span class="math math-inline">\Delta</span> 동안 입력 값이 일정하게 유지된다고 가정하는 물리적 직관에 기반한다.3<br />
<span class="math math-display">
\begin{aligned} \bar{\mathbf{A}}_t &amp;= \exp(\Delta_t \mathbf{A}) \\ \bar{\mathbf{B}}_t &amp;= (\Delta_t \mathbf{A})^{-1}(\exp(\Delta_t \mathbf{A}) - \mathbf{I}) \cdot \Delta_t \mathbf{B}_t \end{aligned}
</span><br />
여기서 <span class="math math-inline">\bar{\mathbf{A}}_t</span>와 <span class="math math-inline">\bar{\mathbf{B}}_t</span>는 이제 시점 <span class="math math-inline">t</span>마다 변하는 값이 된다. 특히 <span class="math math-inline">\bar{\mathbf{A}}_t</span>는 지수 함수(<span class="math math-inline">\exp</span>)를 포함하고 있어 계산 비용이 높을 수 있으나, Mamba는 행렬 <span class="math math-inline">\mathbf{A}</span>를 대각 행렬(Diagonal Matrix)로 제약함으로써 이 연산을 요소별(Element-wise) 연산으로 단순화하였다.12 이는 상태 벡터의 각 차원이 서로 독립적으로 업데이트되도록 하여 연산 효율성을 높이는 동시에, 모델의 표현력을 유지하는 중요한 설계 선택이다.</p>
<h3>2.2  병렬 연관 스캔(Parallel Associative Scan)의 원리</h3>
<p>순차적인 재귀식 <span class="math math-inline">h_t = \bar{\mathbf{A}}_t h_{t-1} + \bar{\mathbf{B}}_t x_t</span>를 <span class="math math-inline">t=1</span>부터 <span class="math math-inline">L</span>까지 차례대로 계산하면 <span class="math math-inline">O(L)</span> 단계가 필요하다. 그러나 이 연산은 **결합 법칙(Associativity)**을 만족하는 선형 연산자 형태로 재정의될 수 있다.10</p>
<p>우리가 구하고자 하는 것은 각 시점 <span class="math math-inline">t</span>에서의 누적된 상태 <span class="math math-inline">h_t</span>이다. 이를 위해 상태 업데이트 과정을 하나의 연산자 <span class="math math-inline">\bullet</span>으로 정의해 보자. 두 개의 연속된 연산 <span class="math math-inline">(u_i, v_i)</span>와 <span class="math math-inline">(u_j, v_j)</span>가 있을 때, 이를 결합하는 연산은 다음과 같은 형태를 띤다.<br />
<span class="math math-display">
(A_j, B_j x_j) \bullet (A_i, B_i x_i) = (A_j A_i, A_j B_i x_i + B_j x_j)
</span></p>
<p>이 연산은 결합 법칙 <span class="math math-inline">(a \bullet b) \bullet c = a \bullet (b \bullet c)</span>를 만족한다. 결합 법칙이 성립한다는 것은 연산의 순서를 변경해도 결과가 같음을 의미하며, 이는 곧 분할 정복(Divide and Conquer)을 통한 병렬 처리가 가능함을 시사한다.</p>
<p>Mamba는 Blelloch 스캔 알고리즘10과 유사한 방식을 사용하여 시퀀스 전체를 트리(Tree) 구조로 처리한다.</p>
<ol>
<li><strong>업 스윕(Up-sweep) 단계:</strong> 인접한 요소들끼리 짝을 지어 병렬로 연산을 수행한다. (<span class="math math-inline">t_1</span>과 <span class="math math-inline">t_2</span>, <span class="math math-inline">t_3</span>과 <span class="math math-inline">t_4</span> 등). 이 결과들을 다시 짝지어 상위 노드로 올린다. 이 과정은 <span class="math math-inline">O(\log L)</span> 깊이의 트리 구조를 형성한다.</li>
<li><strong>다운 스윕(Down-sweep) 단계:</strong> 루트 노드에서부터 계산된 중간 값들을 아래로 전파하여, 각 시점 <span class="math math-inline">t</span>에서의 최종 누적 상태 <span class="math math-inline">h_t</span>를 계산한다.</li>
</ol>
<p>이러한 병렬 스캔 알고리즘을 통해 Mamba는 순차적 의존성을 가짐에도 불구하고, GPU의 수천 개의 코어를 동시에 활용하여 <span class="math math-inline">O(\log L)</span> 시간에 가까운 속도로 전체 시퀀스의 상태를 계산해 낼 수 있다.10 이는 학습 시 트랜스포머와 대등한 병렬성을 보장하며, RNN이 겪었던 ’시간에 따른 역전파(BPTT)’의 비효율성을 근본적으로 해결한다.</p>
<h3>2.3  스캔 vs 합성곱 vs 어텐션</h3>
<p>선택적 스캔은 합성곱과 어텐션의 중간 지점에 위치한 독특한 특성을 갖는다.</p>
<ul>
<li><strong>합성곱 대비:</strong> 전체를 한 번에 보는 전역적(Global) 커널은 아니지만, 재귀적 연결을 통해 무한한 수용 영역(Receptive Field)을 갖는다. 입력에 따라 가중치가 변하므로 훨씬 유연하다.</li>
<li><strong>어텐션 대비:</strong> 어텐션은 모든 토큰 쌍(<span class="math math-inline">N^2</span>)을 명시적으로 계산하여 정보를 가져오지만, 스캔은 상태 <span class="math math-inline">h</span>를 매개로 정보를 압축하여 전달한다. 따라서 메모리 사용량이 시퀀스 길이에 선형적(<span class="math math-inline">O(N)</span>)이다.</li>
</ul>
<p>Mamba의 스캔 알고리즘은 단순히 계산을 빠르게 하는 것을 넘어, 모델이 긴 시퀀스 내에서 정보를 어떻게 흘려보낼지를 결정하는 ’정보의 고속도로’를 건설하는 것과 같다. 이 고속도로는 고정된 경로가 아니라, 교통량(입력 데이터)에 따라 차선을 넓히거나 좁히는(가변 <span class="math math-inline">\Delta</span>) 지능형 시스템이다.</p>
<h2>3.  하드웨어 인식(Hardware-Aware) 설계와 메모리 최적화</h2>
<p>선택적 스캔 알고리즘이 이론적으로 병렬화가 가능하다 하더라도, 실제 GPU 하드웨어 환경에서 이를 구현하는 것은 또 다른 차원의 문제이다. 특히 최신 GPU(A100, H100 등)에서는 연산 속도(FLOPS)보다 메모리 대역폭(Memory Bandwidth)이 성능의 병목이 되는 경우가 많다. Mamba는 이 문제를 해결하기 위해 하드웨어의 물리적 특성을 고려한 최적화 전략을 구사한다.</p>
<h3>3.1  메모리 계층 구조(Memory Hierarchy)와 IO 병목</h3>
<p>GPU 메모리는 크게 용량이 크지만 속도가 느린 **HBM(High Bandwidth Memory)**과, 용량은 작지만 속도가 매우 빠른 **SRAM(Static RAM, 온칩 캐시)**으로 나뉜다.9</p>
<p>선택적 SSM을 나이브하게 구현할 경우, 중간 계산 결과인 크기 <span class="math math-inline">(B, L, D, N)</span>의 상태 <span class="math math-inline">h</span>와 시변 파라미터 <span class="math math-inline">\bar{\mathbf{A}}, \bar{\mathbf{B}}</span>를 모두 HBM에 썼다가 다시 읽어야 한다. 상태 차원 <span class="math math-inline">N</span>(보통 16~32)이 곱해지므로, 이는 입력 <span class="math math-inline">x</span> <span class="math math-inline">(B, L, D)</span> 대비 <span class="math math-inline">N</span>배나 많은 메모리 입출력(IO)을 유발한다. 이로 인해 연산 장치는 데이터가 도착하기를 기다리며 유휴(Idle) 상태가 되고, 전체적인 학습 속도가 저하된다.6</p>
<h3>3.2  커널 융합(Kernel Fusion)과 SRAM 연산</h3>
<p>Mamba는 FlashAttention14의 아이디어를 차용하여 <strong>커널 융합(Kernel Fusion)</strong> 기술을 적용한다. 핵심은 **“중간 상태를 HBM에 기록하지 않는다”**는 것이다.</p>
<ol>
<li><strong>입력 로드:</strong> HBM에서 파라미터 <span class="math math-inline">\Delta, \mathbf{A}, \mathbf{B}, \mathbf{C}</span>와 입력 <span class="math math-inline">x</span>를 SRAM으로 읽어온다.</li>
<li><strong>SRAM 내 처리:</strong> SRAM 내부에서 이산화(Discretization)와 병렬 스캔(Recursion) 연산을 모두 수행한다. SRAM은 대역폭이 HBM보다 월등히 높으므로, 여기서 발생하는 빈번한 데이터 접근은 병목이 되지 않는다.</li>
<li><strong>출력 저장:</strong> 최종 계산된 출력 <span class="math math-inline">y</span>만을 HBM에 다시 기록한다. 크기가 큰 중간 상태 <span class="math math-inline">h</span>는 연산이 끝나면 SRAM에서 소멸된다.</li>
</ol>
<p>이 방식을 통해 Mamba는 HBM 접근 횟수를 획기적으로 줄여, 메모리 대역폭 한계에 갇히지 않고 연산 코어의 성능을 최대한 끌어올릴 수 있다. 실험 결과, 이러한 하드웨어 인식 구현은 표준 PyTorch 구현 대비 최대 40배 빠른 속도를 보여주었다.4</p>
<h3>3.3  재계산(Recomputation) 전략을 통한 메모리 절약</h3>
<p>학습(Training) 단계에서는 역전파(Backpropagation)를 위해 순전파(Forward pass) 때 계산한 중간 값들이 필요하다. 그러나 앞서 설명한 대로 Mamba는 중간 상태 <span class="math math-inline">h</span>를 HBM에 저장하지 않는다. 그렇다면 역전파는 어떻게 수행하는가?</p>
<p>Mamba는 재계산(Recomputation) 또는 체크포인팅(Checkpointing) 기법을 사용한다.2 역전파 단계에서 기울기(Gradient)를 계산할 때 필요한 중간 상태값이 있다면, 이를 메모리에서 찾는 대신 SRAM 내에서 입력으로부터 다시 계산해 버리는 것이다.</p>
<p>직관적으로 연산을 두 번 하는 것이 비효율적으로 보일 수 있지만, 현대 GPU 아키텍처에서는 “연산이 메모리 접근보다 훨씬 싸다(Compute is cheaper than IO)”. 메모리에서 거대한 행렬을 불러오는 시간을 기다리는 것보다, 빠른 SRAM에서 데이터를 다시 계산하는 것이 전체 실행 시간(Wall-clock time) 측면에서 훨씬 빠르다.</p>
<p>이러한 재계산 전략 덕분에 Mamba는 배치 크기(Batch Size)를 키우거나 시퀀스 길이를 늘려도 메모리 부족(OOM) 현상을 겪지 않고 선형적인 메모리 확장성을 유지할 수 있다. 이는 수백만 토큰 길이의 시퀀스를 처리할 수 있는 Mamba의 확장성(Scalability)을 뒷받침하는 하드웨어적 기반이다.2</p>
<h2>4.  정보의 압축(Compression)과 선별(Selection): 이론적 메커니즘</h2>
<p>기술적 구현을 넘어, Mamba의 선택적 스캔이 갖는 진정한 의의는 정보 이론적 관점에서 시퀀스 데이터를 다루는 방식에 있다. 3.1절의 동기 부여에서 언급되었듯, 시퀀스 모델링의 본질은 **“방대한 문맥(Context)을 제한된 상태(State)로 얼마나 효율적으로 압축하느냐”**에 달려 있다.2</p>
<h3>4.1  <span class="math math-inline">\Delta</span> (Delta): 정보의 게이트키퍼(Gatekeeper)</h3>
<p>Mamba에서 <span class="math math-inline">\Delta_t</span> 파라미터는 단순한 시간 간격 이상의 의미를 갖는다. 이는 RNN의 게이팅 메커니즘(LSTM의 Forget/Input Gate)을 일반화한 것으로 볼 수 있다.2</p>
<p>수식 <span class="math math-inline">h_t = (1 - \Delta_t \mathbf{A}) h_{t-1} + \Delta_t \mathbf{B}_t x_t</span> (근사적 형태)를 살펴보면 <span class="math math-inline">\Delta_t</span>의 역할이 명확해진다.</p>
<ul>
<li><strong>큰 <span class="math math-inline">\Delta_t</span> (Focus &amp; Reset):</strong> <span class="math math-inline">\Delta_t</span> 값이 커지면, 현재 입력 <span class="math math-inline">x_t</span>가 상태에 미치는 영향(<span class="math math-inline">\Delta_t \mathbf{B}_t x_t</span>)이 커지고, 반대로 이전 상태 <span class="math math-inline">h_{t-1}</span>의 영향은 줄어든다(망각). 이는 모델이 “지금 들어오는 정보가 중요하니, 과거의 잡음을 지우고 이것을 확실히 기록해라“라고 판단하는 것과 같다.</li>
<li><strong>작은 <span class="math math-inline">\Delta_t</span> (Ignore &amp; Persistence):</strong> <span class="math math-inline">\Delta_t</span> 값이 작아 0에 수렴하면, 현재 입력항은 무시되고 이전 상태 <span class="math math-inline">h_{t-1}</span>이 거의 그대로 유지된다. 이는 “지금 들어오는 정보는 노이즈이니 무시하고, 기존에 기억하고 있는 중요한 정보를 계속 유지해라“라는 신호이다.9</li>
</ul>
<p>이러한 메커니즘을 통해 Mamba는 고정된 크기의 상태 공간 <span class="math math-inline">N</span> 안에 무한히 긴 시퀀스의 정보를 담을 수 있다. 모든 정보를 담는 것이 아니라, <strong>’선택적’으로 중요한 정보만을 남기고 나머지는 버리는(Filtering)</strong> 과정을 통해 정보의 밀도를 높이는 것이다. 이는 손실 압축(Lossy Compression)이지만, 문맥 이해에 필수적인 정보(Signal)는 보존하고 불필요한 정보(Noise)는 제거한다는 점에서 지능적인 압축이다.3</p>
<h3>4.2  유도 헤드(Induction Heads)와 인컨텍스트 러닝(In-Context Learning)</h3>
<p>Mamba 논문에서는 선택 메커니즘의 효과를 입증하기 위해 <strong>유도 헤드(Induction Heads)</strong> 작업을 분석한다.2 유도 헤드는 LLM이 문맥 내에서 패턴을 학습하는 능력(In-Context Learning)의 원천으로 알려져 있다. 예를 들어, <code>[A]... [A] -&gt;?</code> 패턴에서 <code>?</code>가 ``임을 예측하는 능력이다.</p>
<p>기존 LTI SSM은 이러한 복사(Copying) 작업에 취약했다. 정보를 선택적으로 저장할 수 없기 때문에, <code>[A]</code>와 <code>사이의 수많은 토큰들이 상태 공간을 오염시켜 </code>[A]<code>에 대한 기억을 희석시키기 때문이다. 반면, Mamba는 선택 메커니즘을 통해 </code>[A]<code>와</code>가 등장하는 시점에는 <span class="math math-inline">\Delta</span>를 높여 정보를 강하게 기록하고, 중간 구간에서는 <span class="math math-inline">\Delta</span>를 낮추어 기억을 보존함으로써, 트랜스포머 수준의 완벽한 패턴 복원 능력을 보여준다.5</p>
<p>이는 Mamba가 단순한 순환 신경망을 넘어, 트랜스포머의 ‘검색(Retrieval)’ 능력에 버금가는 ‘연상 기억(Associative Memory)’ 능력을 갖추었음을 시사한다. 트랜스포머가 모든 과거 기록을 펼쳐놓고 찾아보는 방식(Random Access)이라면, Mamba는 중요한 정보만을 추려서 요약 노트에 적어두고 필요할 때 바로 꺼내 보는 방식(Compressed State Access)인 셈이다.3</p>
<h3>4.3  비전(Vision) 및 타 도메인으로의 확장성</h3>
<p>선택적 스캔 알고리즘의 정보 압축 원리는 텍스트에만 국한되지 않는다. 최근 연구인 BIMBA16와 같은 비디오 질의응답 모델이나 Vision Mamba13는 선택적 스캔을 시공간(Spatiotemporal) 데이터에 적용한 사례이다.</p>
<p>긴 비디오 영상에는 배경이나 정적인 장면 등 중복 정보가 매우 많다. 선택적 스캔 알고리즘은 이러한 비디오 시퀀스에서 ’움직임이 있는 구간’이나 ’질의와 관련된 프레임’에서만 선택적으로 상태를 업데이트함으로써, 거대한 비디오 데이터를 효율적인 토큰 시퀀스로 압축한다. 이는 Mamba의 선택적 스캔이 데이터의 모달리티(Modality)를 불문하고, **“고차원 데이터에서 유의미한 저차원 특징을 추출하는 범용적인 엔진”**으로 작동할 수 있음을 보여준다.16</p>
<h2>5.  결론: 포스트 트랜스포머를 향한 알고리즘적 토대</h2>
<p>3.2절에서 상세히 다룬 선택적 스캔 알고리즘은 Mamba 아키텍처가 표방하는 ‘포스트 트랜스포머’ 시대의 기술적 근거이다. Mamba는 LTI 시스템의 편안한 안주(합성곱과 효율성)를 거부하고, 시변 역학이라는 험난한 길을 선택했다. 그리고 그 길에서 만난 계산 복잡도의 장벽을 병렬 스캔 알고리즘과 하드웨어 인식 최적화라는 정교한 엔지니어링으로 돌파하였다.</p>
<p>요약하자면, 선택적 스캔 알고리즘은 다음과 같은 의의를 갖는다.</p>
<ol>
<li><strong>구조적 혁신:</strong> 고정된 필터(LTI)에서 입력에 반응하는 적응형 필터(Selection)로의 진화.</li>
<li><strong>계산적 혁신:</strong> 순차적 모델의 한계를 넘는 <span class="math math-inline">O(N)</span> 시간 복잡도와 병렬 학습의 동시 구현.</li>
<li><strong>정보적 혁신:</strong> 무차별적 정보 수집(Attention)이 아닌, 지능적 정보 선별과 압축을 통한 효율적 문맥 관리.</li>
</ol>
<p>이러한 혁신을 통해 Mamba는 트랜스포머가 독점하던 대규모 언어 모델링의 영역뿐만 아니라, 유전체 분석, 긴 비디오 처리 등 트랜스포머가 효율성 문제로 진입하기 어려웠던 초장문(Ultra-long Context) 영역으로 인공지능의 지평을 확장하고 있다. 선택적 스캔은 단순한 속도 개선이 아니라, 기계가 정보를 처리하고 기억하는 방식에 대한 근본적인 재설계라 할 수 있다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>A Visual Guide to Mamba and State Space Models - Maarten Grootendorst, https://www.maartengrootendorst.com/blog/mamba/</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, https://arxiv.org/pdf/2312.00752</li>
<li>Mamba Explained - The Gradient, https://thegradient.pub/mamba-explained/</li>
<li>Comprehensive Breakdown of Selective Structured State Space Model — Mamba (S5). | by Freedom Preetham | Autonomous Agents | Medium, https://medium.com/autonomous-agents/comprehensive-breakdown-of-selective-structured-state-space-model-mamba-s5-441e8b94ecaf</li>
<li>Mamba: Make Sequence Models Fast Again | by Dong-Keon Kim - Medium, https://medium.com/@kdk199604/mamba-make-sequence-models-fast-again-540245a49155</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, https://arxiv.org/html/2312.00752v2</li>
<li>From Mamba to Mamba-2, https://n1o.github.io/posts/from-mamba-to-mamba2/</li>
<li>BIMBA: Selective-Scan Compression for Long-Range Video Question Answering - arXiv, https://arxiv.org/html/2503.09590v1</li>
<li>Mamba architecture : A Leap Forward in Sequence Modeling | by Puneet Hegde - Medium, https://medium.com/@puneetthegde22/mamba-architecture-a-leap-forward-in-sequence-modeling-370dfcbfe44a</li>
<li>Mamba No. 5 (A Little Bit Of…) | Sparse Notes, https://jameschen.io/jekyll/update/2024/02/12/mamba.html</li>
<li>NumByNum :: Mamba — Linear Time Sequence Modeling with Selective State Spaces (Gu et al., 2023) Reviewed | by Aria Lee | Medium, https://medium.com/@AriaLeeNotAriel/numbynum-mamba-linear-time-sequence-modeling-with-selective-state-spaces-reviewed-b4c17b991b3c</li>
<li>The Hidden Attention of Mamba Models - arXiv, https://arxiv.org/html/2403.01590v1</li>
<li>Here Comes Mamba: The Selective State Space Model | Towards Data Science, https://towardsdatascience.com/here-comes-mamba-the-selective-state-space-model-435e5d17a451/</li>
<li>state-spaces/mamba: Mamba SSM architecture - GitHub, https://github.com/state-spaces/mamba</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - Arxiv Dives, https://ghost.oxen.ai/mamba-linear-time-sequence-modeling-with-selective-state-spaces-arxiv-dives/</li>
<li>BIMBA: Selective-Scan Compression for Long-Range Video Question Answering - Liner, https://liner.com/review/bimba-selectivescan-compression-for-longrange-video-question-answering</li>
<li>BIMBA: Selective-Scan Compression for Long-Range Video Question Answering - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2025/papers/Islam_BIMBA_Selective-Scan_Compression_for_Long-Range_Video_Question_Answering_CVPR_2025_paper.pdf</li>
<li>MambaIC: State Space Models for High-Performance Learned Image Compression - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2025/papers/Zeng_MambaIC_State_Space_Models_for_High-Performance_Learned_Image_Compression_CVPR_2025_paper.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>