<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:팩터 그래프 기반 최적화</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>팩터 그래프 기반 최적화</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../index.html">최적화 (Optimizations)</a> / <a href="index.html">비선형최소제곱문제 최적화</a> / <span>팩터 그래프 기반 최적화</span></nav>
                </div>
            </header>
            <article>
                <h1>팩터 그래프 기반 최적화</h1>
<h2>1. 제1장 서론: 확률적 추정과 그래피컬 모델</h2>
<h3>1.1  로보틱스 및 컴퓨터 비전에서의 추정 문제 개관</h3>
<p>로보틱스 및 컴퓨터 비전 분야의 핵심 과제는 본질적으로 불확실한 환경에서 불완전하고 노이즈가 섞인 센서 데이터를 기반으로 시스템의 상태(state)를 추정하는 것이다.1 이러한 추정 문제는 동시적 위치 추정 및 지도 작성(Simultaneous Localization and Mapping, SLAM), 다중 시점 영상으로부터 3차원 구조를 복원하는 Structure from Motion(SFM), 그리고 관성 측정 장치(IMU), GPS, 카메라 등 이종(heterogeneous) 센서의 데이터를 통합하는 다중 센서 융합(Multi-Sensor Fusion) 등 다양한 형태로 나타난다.3 이 문제들은 공통적으로 수많은 변수와 제약 조건으로 이루어진 대규모 비선형 최적화 문제로 귀결된다.</p>
<p>과거 수십 년간 칼만 필터(Kalman Filter)와 그 변형들(EKF, UKF 등)은 센서 융합 및 상태 추정 분야의 주력 도구로 사용되어 왔다. 칼만 필터는 이전 상태 추정치에 현재의 측정값을 재귀적으로 반영하여 현재 상태를 갱신하는 필터링(filtering) 기법이다. 선형 시스템과 가우시안 노이즈라는 가정 하에 최적의 해를 제공하지만, SLAM과 같이 고도로 비선형적이고, 과거의 상태와 현재의 관측이 복잡하게 얽힌 문제에서는 근본적인 한계에 직면한다.3 필터링 방식은 과거의 모든 정보를 이전 상태의 평균과 공분산이라는 통계량으로 압축하기 때문에, 한번 발생한 선형화 오차를 되돌릴 수 없는 정보 손실을 야기한다.</p>
<p>이러한 한계를 극복하기 위해 등장한 패러다임이 바로 스무딩(smoothing)이다. 스무딩은 특정 시점의 상태만이 아닌, 전체 시간 동안의 궤적(trajectory)을 한 번에 최적화하는 접근법이다. 이는 새로운 측정값이 들어왔을 때, 현재 상태뿐만 아니라 과거 상태에 대한 추정치까지도 개선할 수 있게 해준다. 특히 로봇이 이전에 방문했던 장소를 다시 인식하는 루프 폐쇄(loop closure) 상황에서, 스무딩은 누적된 오차를 전역적으로 보정하여 일관성 있는 해를 찾는 데 결정적인 역할을 한다.6 이처럼 로보틱스 추정 분야의 발전은, 계산 능력의 향상과 더불어, 로봇이 자신의 경험 전체를 바탕으로 “뒤늦게 깨닫고” 과거의 추정치를 수정할 수 있는 능력을 부여한, 보다 정교한 추정 패러다임으로의 전환 과정으로 이해할 수 있다.</p>
<h3>1.2  그래피컬 모델의 필요성</h3>
<p>스무딩과 같은 대규모 최적화 문제를 효과적으로 다루기 위해서는 문제의 기저에 깔린 구조를 명확하게 파악하고 활용하는 것이 필수적이다. 그래피컬 모델(Graphical Model)은 복잡한 확률 분포 내 변수들 간의 조건부 독립 관계를 노드와 간선으로 구성된 그래프 형태로 시각화하는 강력한 수학적 도구이다.4 그래피컬 모델을 사용하면 다음과 같은 이점을 얻을 수 있다.</p>
<ol>
<li>
<p><strong>직관적인 문제 표현:</strong> 변수 간의 복잡한 상호 의존성을 직관적으로 이해하고 모델링할 수 있다.</p>
</li>
<li>
<p><strong>구조적 통찰:</strong> 문제의 구조, 특히 희소성(sparsity)을 명시적으로 드러낸다. 대부분의 로보틱스 문제에서 특정 측정값은 전체 상태 변수 중 극히 일부에만 영향을 미치는데, 이러한 국소성(locality)은 그래프의 연결 구조에 그대로 반영된다.</p>
</li>
<li>
<p><strong>효율적인 추론 알고리즘 설계:</strong> 그래프의 구조적 특성을 활용하여 계산적으로 효율적인 추론 및 최적화 알고리즘을 설계할 수 있다. 희소성은 대규모 선형 시스템을 빠르게 풀 수 있는 열쇠가 된다.10</p>
</li>
</ol>
<h3>1.3  베이즈 네트워크에서 팩터 그래프로의 전환</h3>
<p>그래피컬 모델에는 여러 종류가 있으며, 그중 베이즈 네트워크(Bayesian Networks)와 팩터 그래프(Factor Graphs)가 로보틱스 분야에서 주로 사용된다.</p>
<p><strong>베이즈 네트워크</strong>는 유향 비순환 그래프(Directed Acyclic Graph, DAG)를 사용하여 변수 간의 인과 관계나 생성 모델(generative model)을 표현한다. 각 노드는 확률 변수를 나타내고, 방향성이 있는 간선은 부모 노드에서 자식 노드로의 조건부 의존성을 의미한다. 전체 결합 확률 분포는 각 노드의 조건부 확률 분포(Conditional Probability Distribution, CPD)의 곱으로 인수분해된다.8 베이즈 네트워크는 “상태가 어떻게 측정값을 생성하는가“와 같은 과정을 모델링하는 데 매우 직관적이다.</p>
<p>하지만 추론(inference), 즉 관측값이 주어졌을 때 미지의 상태 변수에 대한 사후 확률(posterior probability)을 계산하는 관점에서는 베이즈 네트워크의 구조가 다소 부자연스러울 수 있다. 모든 확률적 제약을 명시적으로 표현하는 데 한계가 있기 때문이다.10</p>
<p>이러한 배경에서 <strong>팩터 그래프</strong>가 대안으로 부상했다. 팩터 그래프는 베이즈 네트워크와 마르코프 랜덤 필드(Markov Random Fields, MRF)를 일반화한 모델로, 전역 함수(예: 사후 확률)가 어떻게 여러 개의 국소 함수, 즉 “팩터(factor)“의 곱으로 인수분해되는지를 가장 직접적이고 명시적으로 표현하는 이분 그래프(bipartite graph)이다.4 모든 베이즈 네트워크는 팩터 그래프로 쉽게 변환될 수 있으며, 이 변환 과정에서 문제의 기저에 있는 대칭적이고 제약 기반의 구조가 더욱 명확하게 드러난다.17 다음 표는 주요 그래피컬 모델의 특징을 비교한다.</p>
<p><strong>표 1: 그래피컬 모델 비교</strong></p>
<table><thead><tr><th>특징</th><th>베이즈 네트워크 (BN)</th><th>마르코프 랜덤 필드 (MRF)</th><th>팩터 그래프 (FG)</th></tr></thead><tbody>
<tr><td>그래프 종류</td><td>유향 비순환 그래프 (DAG)</td><td>무방향 그래프</td><td>무방향 이분 그래프</td></tr>
<tr><td>표현 대상</td><td><code>&lt;code&gt;$P(X_i \vert Pa(X_i))$&lt;/code&gt;</code></td><td><code>&lt;code&gt;$\psi_c(X_c)$&lt;/code&gt;</code></td><td><code>&lt;code&gt;$f_a(X_a)$&lt;/code&gt;</code></td></tr>
<tr><td>인수분해</td><td><code>&lt;code&gt;$P(X) = \prod_i P(X_i \vert Pa(X_i))$&lt;/code&gt;</code></td><td><code>&lt;code&gt;$P(X) = \frac{1}{Z} \prod_c \psi_c(X_c)$&lt;/code&gt;</code></td><td><code>&lt;code&gt;$P(X) \propto \prod_a f_a(X_a)$&lt;/code&gt;</code></td></tr>
<tr><td>장점</td><td>인과 관계 모델링 용이</td><td>순환적 의존성 표현 가능</td><td>가장 일반적인 인수분해 표현, 모듈성</td></tr>
<tr><td>단점</td><td>순환적 의존성 표현 불가</td><td>정규화 상수 <code>&lt;code&gt;$Z$&lt;/code&gt;</code> 계산 어려움</td><td>시각적으로 복잡해질 수 있음</td></tr>
</tbody></table>
<p>이 표에서 볼 수 있듯이, 팩터 그래프는 가장 유연하고 일반적인 형태의 인수분해를 표현할 수 있어 다양한 로보틱스 추정 문제를 모델링하는 데 가장 적합한 프레임워크를 제공한다.2</p>
<h2>2. 제2장 팩터 그래프의 기본 원리</h2>
<h3>2.1  변수 노드와 팩터 노드</h3>
<p>팩터 그래프의 근간을 이루는 두 가지 핵심 요소는 변수 노드(variable node)와 팩터 노드(factor node)이다. 이들의 정의와 역할은 다음과 같다.19</p>
<ul>
<li>
<p><strong>변수 노드 (Variable Nodes):</strong> 추정하고자 하는 미지의 확률 변수(random variables)를 나타낸다. 로보틱스 응용에서는 로봇의 시점별 포즈(위치와 방향), 환경 내 랜드마크의 3차원 위치, IMU 센서의 편향(bias) 등이 변수 노드에 해당한다. 그래픽 표현에서는 일반적으로 속이 빈 원(open circle)으로 그려진다.19</p>
</li>
<li>
<p><strong>팩터 노드 (Factor Nodes):</strong> 하나 이상의 변수들 간의 확률적 제약(probabilistic constraint) 또는 관계를 나타내는 함수를 의미한다. 이러한 제약은 시스템의 물리적 모델이나 센서 측정으로부터 파생된다. 예를 들어, 로봇의 움직임을 기술하는 모션 모델, 특정 위치에서 랜드마크를 관측한 측정 모델, 혹은 시스템의 초기 상태에 대한 사전 정보(prior knowledge) 등이 모두 팩터로 표현된다. 그래픽 표현에서는 일반적으로 속이 채워진 사각형(filled square)으로 그려진다.10</p>
</li>
</ul>
<p>팩터 그래프는 이 두 종류의 노드로 구성된 **이분 그래프(bipartite graph)**이다. 이는 그래프 내의 모든 간선(edge)이 반드시 변수 노드와 팩터 노드 사이에만 존재함을 의미한다. 변수 노드끼리 또는 팩터 노드끼리 직접 연결되는 간선은 존재하지 않는다.19</p>
<h3>2.2  전역 확률 분포의 인수분해</h3>
<p>팩터 그래프의 가장 중요한 특징은 복잡한 전역 함수, 특히 모든 변수에 대한 결합 확률 분포(joint probability distribution)가 어떻게 여러 개의 더 단순한 국소 함수, 즉 “팩터“의 곱으로 표현되는지를 시각적으로 명확하게 보여준다는 점이다.8</p>
<p>수학적으로, 전체 변수 집합을 <code>&lt;code&gt;$X = \{X_1, X_2,..., X_n\}$&lt;/code&gt;</code>이라 할 때, 이 변수들에 대한 전역 함수 <code>&lt;code&gt;$g(X)$&lt;/code&gt;</code>는 다음과 같이 인수분해될 수 있다.</p>
<pre><code>g(X_1,..., X_n) = \prod_{i} f_i(X_i)
</code></pre>
<p>여기서 각 <code>&lt;code&gt;$f_i$&lt;/code&gt;</code>는 팩터를 나타내는 함수이며, <code>&lt;code&gt;$X_i$&lt;/code&gt;</code>는 전체 변수 집합 <code>&lt;code&gt;$X$&lt;/code&gt;</code>의 부분 집합으로, 해당 팩터 <code>&lt;code&gt;$f_i$&lt;/code&gt;</code>가 의존하는 변수들의 집합이다.8 팩터 그래프의 연결 구조는 이 인수분해를 그대로 반영한다. 즉, 팩터 노드</p>
<p><code>&lt;code&gt;$f_i$&lt;/code&gt;</code>는 그것이 함수 인자로 사용하는 모든 변수 노드 <code>&lt;code&gt;$X_j \in X_i$&lt;/code&gt;</code>와 간선으로 연결된다.16</p>
<p>이러한 구조는 문제의 모듈성과 확장성을 구조적으로 보장하는 중요한 역할을 한다. 전통적인 상태 공간 모델에서는 새로운 종류의 센서를 추가하려면 시스템의 상태 전파 및 측정 업데이트 방정식을 전반적으로 수정해야 할 수 있다. 그러나 팩터 그래프에서는 새로운 센서 정보를 추가하는 것이 단순히 새로운 팩터 노드를 생성하고, 이 팩터가 제약을 가하는 변수 노드(예: 특정 시점의 로봇 포즈)에 연결하는 작업만으로 완료된다.24 기존의 다른 팩터들은 전혀 수정할 필요가 없다. 이는 문제의 각 정보 조각(센서 측정, 모션 모델 등)이 독립적인 “모듈“로 취급되기 때문이다. 이러한 특성 덕분에 팩터 그래프는 복잡한 다중 센서 시스템을 설계하고 유지보수하기 위한 강력한 공학적 원칙(모듈화)을 수학적 모델링에 직접 통합한 것으로 볼 수 있으며, 종종 “플러그 앤 플레이(plug and play)” 기능으로 설명된다.25</p>
<h2>3. 제3장 최대 사후 확률(MAP) 추정과 팩터 그래프</h2>
<h3>3.1  MAP 추정 문제의 확률적 공식화</h3>
<p>로보틱스에서 대부분의 추정 문제는 주어진 모든 측정값 <code>&lt;code&gt;$Z$&lt;/code&gt;</code>를 바탕으로, 가장 가능성 있는 상태 변수 <code>&lt;code&gt;$X$&lt;/code&gt;</code>의 집합을 찾는 것을 목표로 한다. 이는 통계적으로 사후 확률(posterior probability) <code>&lt;code&gt;$P(X|Z)$&lt;/code&gt;</code>를 최대화하는 해를 찾는 문제와 같다. 이를 <strong>최대 사후 확률(Maximum a Posteriori, MAP)</strong> 추정이라고 한다.8</p>
<p>베이즈 정리(Bayes’ theorem)에 따르면, 사후 확률은 가능도(likelihood)와 사전 확률(prior)의 곱에 비례한다.</p>
<pre><code>P(X \vert Z) \propto P(Z \vert X) P(X)
</code></pre>
<p>여기서 <code>&lt;code&gt;$P(Z|X)$&lt;/code&gt;</code>는 상태 <code>&lt;code&gt;$X$&lt;/code&gt;</code>가 주어졌을 때 측정값 <code>&lt;code&gt;$Z$&lt;/code&gt;</code>가 관측될 확률, 즉 가능도이며, <code>&lt;code&gt;$P(X)$&lt;/code&gt;</code>는 측정과 무관하게 상태 <code>&lt;code&gt;$X$&lt;/code&gt;</code>에 대해 우리가 이미 가지고 있는 사전 지식, 즉 사전 확률이다.10 따라서 MAP 추정 문제는 다음 최적화 문제를 푸는 것과 동일하다.</p>
<pre><code>X^* = \underset{X}{\mathrm{argmax}} \, P(X \vert Z) = \underset{X}{\mathrm{argmax}} \, \left[ P(Z \vert X) P(X) \right]
</code></pre>
<p>5</p>
<h3>3.2  팩터 그래프를 이용한 문제 모델링</h3>
<p>MAP 추정 문제의 핵심인 사후 확률 <code>&lt;code&gt;$P(X|Z)$&lt;/code&gt;</code>는 팩터 그래프를 사용하여 자연스럽게 모델링될 수 있다. 사후 확률을 구성하는 각 확률적 요소들은 팩터 그래프의 팩터 노드에 직접적으로 대응된다.</p>
<ul>
<li>
<p><strong>사전 정보 팩터 (Prior Factor):</strong> 사전 확률 <code>&lt;code&gt;$P(X)$&lt;/code&gt;</code>는 상태 변수에 대한 초기 지식을 나타낸다. 예를 들어, 로봇이 좌표계의 원점에서 출발한다는 정보는 초기 포즈 변수 <code>&lt;code&gt;$x_0$&lt;/code&gt;</code>에 대한 확률 분포 <code>&lt;code&gt;$P(x_0)$&lt;/code&gt;</code>로 표현되며, 이는 <code>&lt;code&gt;$x_0$&lt;/code&gt;</code>에만 연결된 단항 팩터(unary factor)가 된다.8</p>
</li>
<li>
<p><strong>모션 모델 팩터 (Motion Model Factor):</strong> 로봇의 움직임은 일반적으로 마르코프 가정(Markov assumption)을 따른다고 가정한다. 즉, 시점 <code>&lt;code&gt;$t$&lt;/code&gt;</code>에서의 상태 <code>&lt;code&gt;$x_t$&lt;/code&gt;</code>는 바로 이전 시점 <code>&lt;code&gt;$t-1$&lt;/code&gt;</code>의 상태 <code>&lt;code&gt;$x_{t-1}$&lt;/code&gt;</code>과 그 사이에 가해진 제어 입력(예: 바퀴 회전 수) <code>&lt;code&gt;$u_t$&lt;/code&gt;</code>에만 의존한다. 이는 조건부 확률 <code>&lt;code&gt;$P(x_t | x_{t-1}, u_t)$&lt;/code&gt;</code>로 모델링되며, 두 연속적인 포즈 변수 <code>&lt;code&gt;$x_{t-1}$&lt;/code&gt;</code>과 <code>&lt;code&gt;$x_t$&lt;/code&gt;</code>를 연결하는 이진 팩터(binary factor)로 표현된다.7</p>
</li>
<li>
<p><strong>측정 모델 팩터 (Measurement Model Factor):</strong> 센서 측정값 <code>&lt;code&gt;$z_k$&lt;/code&gt;</code>는 특정 상태 변수들(예: 로봇의 포즈 <code>&lt;code&gt;$x_i$&lt;/code&gt;</code>와 랜드마크의 위치 <code>&lt;code&gt;$l_j$&lt;/code&gt;</code>)에 의존한다. 이 관계는 가능도 함수 <code>&lt;code&gt;$L(x_i, l_j; z_k) \propto P(z_k | x_i, l_j)$&lt;/code&gt;</code>로 표현되며, 변수 노드 <code>&lt;code&gt;$x_i$&lt;/code&gt;</code>와 <code>&lt;code&gt;$l_j$&lt;/code&gt;</code>를 연결하는 팩터가 된다.8</p>
</li>
</ul>
<p>이러한 요소들을 모두 결합하면, 전체 사후 확률은 여러 팩터의 곱으로 자연스럽게 인수분해된다. 예를 들어, 간단한 SLAM 문제의 사후 확률은 다음과 같이 표현될 수 있다.</p>
<pre><code>P(X \vert Z) \propto \underbrace{P(x_0)}_{\text{Prior}} \prod_t \underbrace{P(x_t \vert x_{t-1}, u_t)}_{\text{Motion Model}} \prod_k \underbrace{P(z_k \vert x_{i_k}, l_{j_k})}_{\text{Measurement Model}}
</code></pre>
<p>이 식의 우변에 있는 각각의 확률적 항(사전 확률, 모션 모델, 측정 모델)이 팩터 그래프의 개별 팩터 노드에 정확히 대응된다.8 이처럼 팩터 그래프는 베이즈 추론 문제의 구조를 물리적, 시간적 구조와 직접 연결하여 시각화하는 강력한 도구이다. 그래프의 수평적 체인 구조(</p>
<p><code>&lt;code&gt;$x_0 - x_1 -... - x_T$&lt;/code&gt;</code>)는 시간의 흐름에 따른 로봇의 궤적을 나타내고 8, 측정 모델 팩터는 특정 포즈에서 관측된 랜드마크를 연결하며 공간적 관계를 표현한다. 특히, 루프 폐쇄는 시간적으로 멀리 떨어진 두 포즈 노드를 연결하는 팩터를 생성하여, 누적된 오차를 보정하는 데 결정적인 정보를 제공하는 구조를 명확히 보여준다.10</p>
<h2>4. 제4장 비선형 최소 제곱 최적화로의 변환</h2>
<p>확률적 MAP 추정 문제를 실제 계산 가능한 최적화 문제로 변환하는 과정은 팩터 그래프 프레임워크의 핵심적인 부분이다. 이 변환은 주로 가우시안 노이즈 모델 가정과 로그 가능도(log-likelihood)를 통해 이루어진다.</p>
<h3>4.1  가우시안 노이즈 모델의 역할</h3>
<p>실제 세계의 많은 물리적 시스템에서 센서 측정 노이즈나 프로세스 불확실성은 중심극한정리에 따라 가우시안(정규) 분포로 근사할 수 있다. 이는 팩터 그래프 기반 최적화에서 가장 널리 사용되는 기본 가정이다.6 다변량 가우시안 분포의 확률 밀도 함수(PDF)는 평균</p>
<p><code>&lt;code&gt;$\mu$&lt;/code&gt;</code>와 공분산 <code>&lt;code&gt;$\Sigma$&lt;/code&gt;</code>에 대해 다음과 같은 지수 함수 형태로 표현된다.</p>
<pre><code>p(x) \propto \exp \left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right)
</code></pre>
<p>5</p>
<p>이 지수 형태는 이후 로그 변환을 통해 문제를 단순화하는 데 결정적인 역할을 한다.</p>
<h3>4.2  오차 함수와 마할라노비스 거리</h3>
<p>각 팩터 <code>&lt;code&gt;$f_i$&lt;/code&gt;</code>는 특정 변수 집합 <code>&lt;code&gt;$X_i$&lt;/code&gt;</code>에 대한 제약을 나타낸다. 이 제약은 보통 예측 모델과 실제 측정값 간의 차이를 통해 정의된다. 측정 모델 함수를 <code>&lt;code&gt;$h_i(X_i)$&lt;/code&gt;</code>(주어진 상태 <code>&lt;code&gt;$X_i$&lt;/code&gt;</code>에서 예상되는 측정값), 실제 측정값을 <code>&lt;code&gt;$z_i$&lt;/code&gt;</code>라고 할 때, <strong>오차(error)</strong> 또는 <strong>잔차(residual)</strong> 벡터 <code>&lt;code&gt;$e_i(X_i)$&lt;/code&gt;</code>는 다음과 같이 정의된다.</p>
<pre><code>e_i(X_i) = h_i(X_i) - z_i
</code></pre>
<p>19</p>
<p>단순히 오차 벡터의 유클리드 거리 제곱을 최소화하는 것은 측정의 불확실성을 고려하지 않는 것이다. 예를 들어, 신뢰도가 높은 센서(작은 불확실성)의 측정 오차는 신뢰도가 낮은 센서(큰 불확실성)의 오차보다 더 큰 패널티를 받아야 한다. 이러한 가중치를 부여하기 위해 마할라노비스 거리(Mahalanobis distance) 제곱을 사용한다. 이는 측정의 공분산 행렬 <code><span class="math math-inline">\Sigma_i</span></code>의 역행렬인 정보 행렬 <code><span class="math math-inline">\Omega_i = \Sigma_i^{-1}</span></code>을 이용한 가중 제곱합으로 정의된다.</p>
<pre><code>\| e_i(X_i) \|^2_{\Sigma_i} = e_i(X_i)^T \Sigma_i^{-1} e_i(X_i)
</code></pre>
<p>31</p>
<p>이는 통계적으로 정규화된 오차의 제곱합을 의미하며, 각 오차 성분을 해당 방향의 표준편차로 나눈 것과 유사한 효과를 가진다.</p>
<h3>4.3  로그 가능도를 통한 비용 함수 유도</h3>
<p>MAP 추정의 목표인 사후 확률 <code>&lt;code&gt;$P(X|Z)$&lt;/code&gt;</code>를 최대화하는 것은, 로그 함수가 단조 증가 함수라는 성질을 이용하여 음의 로그 사후 확률 <code>&lt;code&gt;$-\log P(X|Z)$&lt;/code&gt;</code>를 최소화하는 것과 동일하다.</p>
<pre><code>X^* = \underset{X}{\mathrm{argmax}} \, P(X \vert Z) = \underset{X}{\mathrm{argmin}} \, (-\log P(X \vert Z))
</code></pre>
<p>3</p>
<p>사후 확률은 팩터들의 곱 <code><span class="math math-inline">P(X|Z) \propto \prod_i f_i(X_i)</span></code>이므로, 로그를 취하면 팩터들의 로그값의 합이 된다.</p>
<pre><code>-\log P(X \vert Z) \propto -\sum_i \log f_i(X_i)
</code></pre>
<p>여기서 각 팩터 <code>&lt;code&gt;$f_i$&lt;/code&gt;</code>가 오차 <code>&lt;code&gt;$e_i(X_i)$&lt;/code&gt;</code>에 대해 평균이 0이고 공분산이 <code>&lt;code&gt;$\Sigma_i$&lt;/code&gt;</code>인 가우시안 분포를 따른다고 가정하면, 팩터의 확률 밀도는 <code>&lt;code&gt;$f_i(X_i) \propto \exp(-\frac{1}{2} \| e_i(X_i) \|^2_{\Sigma_i})$&lt;/code&gt;</code>가 된다. 여기에 음의 로그를 취하면 지수 항만 남게 된다.</p>
<pre><code>-\log f_i(X_i) \propto \frac{1}{2} \| h_i(X_i) - z_i \|^2_{\Sigma_i}
</code></pre>
<p>5</p>
<p>결론적으로, 모든 팩터에 대해 가우시안 노이즈를 가정하면, MAP 추정 문제는 모든 팩터에 대한 마할라노비스 거리 제곱의 합을 최소화하는 비선형 최소 제곱(Non-linear Least Squares, NLLS) 문제와 완전히 동일해진다.</p>
<pre><code>X^* = \underset{X}{\mathrm{argmin}} \sum_i \| h_i(X_i) - z_i \|^2_{\Sigma_i}
</code></pre>
<p>5</p>
<p>이 변환 과정은 확률적 추정 문제와 결정론적 최적화 문제 사이의 근본적인 다리 역할을 한다. 가우시안 가정이라는 이 “다리“를 통해, 복잡한 확률 분포를 직접 다루는 대신, 수치적으로 잘 정의되고 수십 년간 연구되어 온 강력한 비선형 최소 제곱 해법들을 직접 적용할 수 있게 된다. 이는 로보틱스 추정 문제를 해결 가능한 계산 문제로 변환하는 핵심 열쇠이며, 팩터 그래프 기반 최적화 프레임워크의 강력한 이론적 기반을 형성한다.</p>
<h2>5. 제5장 비선형 최적화 해법</h2>
<p>팩터 그래프 기반 MAP 추정 문제는 비선형 최소 제곱(NLLS) 문제로 귀결된다. 예측 함수 <code>&lt;code&gt;$h_i(X)$&lt;/code&gt;</code>가 변수 <code>&lt;code&gt;$X$&lt;/code&gt;</code>에 대해 비선형이기 때문에, 이 문제는 일반적으로 닫힌 형태의 해석적 해(closed-form solution)가 존재하지 않는다.32 따라서 해를 찾기 위해 반복적인 수치 최적화 기법을 사용해야 한다.</p>
<h3>5.1  반복적 선형화</h3>
<p>NLLS 문제 해결의 핵심 아이디어는 **반복적 선형화(iterative linearization)**이다. 즉, 비선형 문제를 현재의 추정치 근방에서 선형 문제로 근사하고, 이 선형 문제를 풀어 해를 점진적으로 개선해 나가는 과정을 반복하는 것이다.</p>
<p>구체적으로, 현재의 추정치를 <code>&lt;code&gt;$X_k$&lt;/code&gt;</code>라고 할 때, 각 오차 함수 <code>&lt;code&gt;$e_i(X)$&lt;/code&gt;</code>를 <code>&lt;code&gt;$X_k$&lt;/code&gt;</code> 주변에서 1차 테일러 급수(Taylor series)로 전개하여 선형으로 근사한다.</p>
<pre><code>e_i(X_k + \Delta X) \approx e_i(X_k) + J_i(X_k) \Delta X
</code></pre>
<p>여기서 <code>&lt;code&gt;$\Delta X$&lt;/code&gt;</code>는 현재 추정치로부터의 작은 변화량(증분, increment)이며, <code>&lt;code&gt;$J_i(X_k)$&lt;/code&gt;</code>는 <code>&lt;code&gt;$X_k$&lt;/code&gt;</code>에서 계산된 오차 함수 <code>&lt;code&gt;$e_i$&lt;/code&gt;</code>의 자코비안 행렬(Jacobian matrix)이다.5 이 선형화된 오차 함수를 원래의 비용 함수에 대입하면,</p>
<p><code>&lt;code&gt;$\Delta X$&lt;/code&gt;</code>에 대한 선형 최소 제곱 문제가 된다. 이 문제를 풀어 최적의 증분 <code>&lt;code&gt;$\Delta X^*$&lt;/code&gt;</code>를 구한 뒤, 다음 추정치 <code>&lt;code&gt;$X_{k+1}$&lt;/code&gt;</code>을 업데이트한다.</p>
<pre><code>X_{k+1} = X_k + \Delta X^*
</code></pre>
<p>이 과정을 추정치가 더 이상 변하지 않거나, 비용 함수의 감소량이 매우 작아질 때까지, 즉 수렴할 때까지 반복한다.19</p>
<h3>5.2  가우스-뉴턴 알고리즘</h3>
<p><strong>가우스-뉴턴(Gauss-Newton) 알고리즘</strong>은 반복적 선형화를 통해 얻어진 선형 최소 제곱 문제를 푸는 표준적인 방법 중 하나이다. 각 반복 단계에서 풀어야 할 문제는 다음과 같다.</p>
<pre><code>\Delta X^* = \underset{\Delta X}{\mathrm{argmin}} \sum_i \| e_i(X_k) + J_i(X_k) \Delta X \|^2_{\Sigma_i}
</code></pre>
<p>이 문제의 해는 **정규 방정식(Normal Equation)**이라 불리는 선형 시스템을 통해 얻어진다.</p>
<pre><code>(J^T \Omega J) \Delta X = -J^T \Omega e
</code></pre>
<p>여기서 <code>&lt;code&gt;$J$&lt;/code&gt;</code>는 모든 자코비안 <code>&lt;code&gt;$J_i$&lt;/code&gt;</code>를 수직으로 쌓은 전체 자코비안 행렬, <code>&lt;code&gt;$e$&lt;/code&gt;</code>는 모든 오차 벡터 <code>&lt;code&gt;$e_i$&lt;/code&gt;</code>를 쌓은 전체 오차 벡터, <code>&lt;code&gt;$\Omega$&lt;/code&gt;</code>는 모든 정보 행렬 <code>&lt;code&gt;$\Sigma_i^{-1}$&lt;/code&gt;</code>을 대각 블록으로 갖는 블록 대각 행렬이다.19 행렬</p>
<p><code>&lt;code&gt;$H = J^T \Omega J$&lt;/code&gt;</code>는 <strong>정보 행렬(Information Matrix)</strong> 또는 근사 헤시안(approximate Hessian)이라고 불린다. 이 선형 시스템을 <code>&lt;code&gt;$\Delta X$&lt;/code&gt;</code>에 대해 풀면 현재 단계의 최적 업데이트 값을 얻을 수 있다.</p>
<h3>5.3  레벤버그-마쿼트 알고리즘</h3>
<p>가우스-뉴턴 방법은 해에 충분히 가까울 때 매우 빠르게 수렴하지만, 초기 추정치가 해에서 멀거나 정보 행렬 <code>&lt;code&gt;$H$&lt;/code&gt;</code>가 양의 준정부호(positive semi-definite)가 아닐 경우 불안정해지거나 발산할 수 있다.33</p>
<p><strong>레벤버그-마쿼트(Levenberg-Marquardt, LM) 알고리즘</strong>은 이러한 문제를 해결하기 위해 정규 방정식에 감쇠 항(damping term) <code>&lt;code&gt;$\lambda$&lt;/code&gt;</code>를 추가하여 안정성을 높인 기법이다.</p>
<pre><code>(J^T \Omega J + \lambda I) \Delta X = -J^T \Omega e
</code></pre>
<p>34</p>
<p>감쇠 인자 <code><span class="math math-inline">\lambda \ge 0</span></code>는 알고리즘의 동작을 조절하는 역할을 한다.</p>
<ul>
<li>
<p><code>&lt;code&gt;$\lambda$&lt;/code&gt;</code>가 0에 가까우면, LM 알고리즘은 가우스-뉴턴 방법과 거의 동일하게 동작하며 빠른 수렴 속도를 보인다.</p>
</li>
<li>
<p><code>&lt;code&gt;$\lambda$&lt;/code&gt;</code>가 매우 크면, 대각 항이 지배적이 되어 알고리즘은 가장 가파른 방향으로 조금씩 이동하는 경사 하강법(Gradient Descent)과 유사하게 동작하며, 안정성은 높지만 수렴 속도는 느려진다.</p>
</li>
</ul>
<p>LM 알고리즘은 매 반복마다 비용 함수가 실제로 감소했는지 확인하고, 그 결과에 따라 <code>&lt;code&gt;$\lambda$&lt;/code&gt;</code> 값을 동적으로 조절한다. 이를 통해 가우스-뉴턴의 빠른 수렴 속도와 경사 하강법의 안정성을 효과적으로 결합하여 강인한 최적화를 수행한다.19 이와 같은 기법들을 신뢰 영역(Trust Region) 방법이라고도 부른다.</p>
<h3>5.4  희소 행렬의 활용</h3>
<p>팩터 그래프 기반 최적화의 가장 큰 계산적 이점은 문제의 **희소성(sparsity)**을 활용하는 데 있다. 로보틱스 문제의 대부분은 국소적인 상호작용을 특징으로 한다. 예를 들어, 특정 시점의 센서 측정은 해당 시점의 로봇 포즈와 관측된 랜드마크에만 영향을 미칠 뿐, 시간적으로나 공간적으로 멀리 떨어진 다른 변수들과는 무관하다.10</p>
<p>이러한 국소성은 팩터 그래프의 연결 구조에 그대로 반영되며, 결과적으로 자코비안 행렬 <code>&lt;code&gt;$J$&lt;/code&gt;</code>와 정보 행렬 <code>&lt;code&gt;$H$&lt;/code&gt;</code>가 매우 희소한 구조를 갖게 만든다. <code>&lt;code&gt;$J$&lt;/code&gt;</code>의 각 행(하나의 팩터에 해당)은 해당 팩터에 연결된 소수의 변수에 대응하는 열에만 0이 아닌 값을 가진다.4</p>
<p>이러한 희소성은 우연이 아니라 문제의 물리적 구조에서 비롯된 필연적인 결과이다. 센서는 “여기“에서 “저기“를 볼 뿐, 세상의 모든 것을 동시에 보지 않는다. 팩터 그래프는 이러한 물리적 희소성을 수학적 희소성으로 직접 변환하는 다리 역할을 하며, 이것이 대규모 SLAM 문제를 실시간에 가깝게 풀 수 있게 하는 핵심 원동력이다. 이 희소성을 활용하는 특수한 선형 대수 기법들, 예를 들어 희소 콜레스키 분해(sparse Cholesky factorization)나 사전 조건화된 켤레 기울기법(Preconditioned Conjugate Gradient, PCG) 등을 사용하면, 변수의 수가 수십만 개에 달하는 거대한 선형 시스템 <code>&lt;code&gt;$H\Delta X = -b$&lt;/code&gt;</code>를 매우 효율적으로 풀 수 있다.5</p>
<p>다음 표는 주요 비선형 최소 제곱 최적화 알고리즘의 특성을 비교한다.</p>
<p><strong>표 2: 비선형 최소 제곱 최적화 알고리즘 비교</strong></p>
<table><thead><tr><th>알고리즘</th><th>업데이트 규칙</th><th>수렴 속도</th><th>안정성/강인성</th><th>계산 비용 (1회 반복)</th><th>특징</th></tr></thead><tbody>
<tr><td>경사 하강법</td><td><code>&lt;code&gt;$\Delta X \propto -J^T e$&lt;/code&gt;</code></td><td>1차 (느림)</td><td>높음 (수렴 보장)</td><td>낮음</td><td>전역적 수렴 보장, 지그재그 현상</td></tr>
<tr><td>가우스-뉴턴</td><td><code>&lt;code&gt;$(J^T J)\Delta X = -J^T e$&lt;/code&gt;</code></td><td>2차 (빠름)</td><td>낮음 (발산 가능)</td><td>중간 (자코비안 필요)</td><td>헤시안 근사, 초기 추정치에 민감</td></tr>
<tr><td>레벤버그-마쿼트</td><td><code>&lt;code&gt;$(J^T J + \lambda I)\Delta X = -J^T e$&lt;/code&gt;</code></td><td>1차~2차 (가변)</td><td>높음</td><td>중간</td><td>가우스-뉴턴과 경사 하강법의 혼합, 신뢰 영역 기법</td></tr>
</tbody></table>
<p>이 표는 각 알고리즘의 핵심적인 트레이드오프(속도 대 안정성)를 명확히 보여준다. 팩터 그래프 최적화에서 왜 단순한 경사 하강법이나 공격적인 가우스-뉴턴 대신, 이 둘을 절충한 레벤버그-마쿼트나 다른 신뢰 영역 기법이 표준으로 사용되는지에 대한 이론적 근거를 제공한다.19</p>
<h2>6. 제6장 로보틱스 응용 사례 심층 분석</h2>
<p>팩터 그래프는 그 유연성과 표현력 덕분에 로보틱스와 컴퓨터 비전의 다양한 추정 문제에 성공적으로 적용되어 왔다. 겉보기에는 다른 문제들이지만, 팩터 그래프라는 통일된 언어를 통해 모두 “상태 변수와 그들 사이의 확률적 제약“이라는 동일한 구조로 모델링될 수 있다.</p>
<h3>6.1  동시적 위치 추정 및 지도 작성 (SLAM)</h3>
<p>SLAM은 로봇이 미지의 환경을 탐색하면서 자신의 위치를 추정하고 동시에 주변 환경의 지도를 작성하는 문제이다. 팩터 그래프는 SLAM 문제를 자연스럽게 표현하는 데 매우 적합하다.</p>
<ul>
<li>
<p><strong>포즈 그래프 SLAM (Pose-SLAM):</strong> 이 방식은 SLAM 문제에서 랜드마크의 위치를 명시적으로 추정하지 않고, 로봇의 궤적, 즉 일련의 포즈(<code>&lt;code&gt;$x_0, x_1,...$&lt;/code&gt;</code>)만을 최적화하는 데 집중한다.35</p>
</li>
<li>
<p><strong>변수:</strong> 로봇의 시점별 포즈 <code>&lt;code&gt;$x_t = (p_t, \theta_t)$&lt;/code&gt;</code>.</p>
</li>
<li>
<p><strong>팩터:</strong></p>
</li>
</ul>
<ol>
<li>
<p><strong>주행기록계(Odometry) 팩터:</strong> 로봇 내부 센서(예: 휠 인코더, IMU)로부터 얻은 연속된 두 포즈 <code>&lt;code&gt;$x_{t-1}$&lt;/code&gt;</code>과 <code>&lt;code&gt;$x_t$&lt;/code&gt;</code> 사이의 상대적인 움직임 제약.</p>
</li>
<li>
<p><strong>루프 폐쇄(Loop Closure) 팩터:</strong> 로봇이 이전에 방문했던 장소를 다시 인식했을 때(예: LiDAR 스캔 매칭이나 시각적 특징점 매칭을 통해), 시간적으로 멀리 떨어진 두 포즈 <code>&lt;code&gt;$x_i$&lt;/code&gt;</code>와 <code>&lt;code&gt;$x_j$&lt;/code&gt;</code> 사이에 생성되는 상대적 위치 제약.7</p>
</li>
</ol>
<ul>
<li>
<p><strong>목표:</strong> 이 모든 제약(팩터)들을 가장 잘 만족시키는 전역적으로 일관된 포즈들의 집합(궤적)을 찾는 것이다. 루프 폐쇄 팩터는 시간이 지남에 따라 누적된 주행기록계 오차를 보정하는 데 결정적인 역할을 한다.</p>
</li>
<li>
<p><strong>랜드마크 기반 SLAM (Landmark-based SLAM):</strong> 이 방식은 로봇의 포즈와 함께 환경 내 랜드마크의 위치를 명시적으로 상태 변수에 포함하여 동시에 추정한다.27</p>
</li>
<li>
<p><strong>변수:</strong> 로봇의 포즈 <code>&lt;code&gt;$x_t$&lt;/code&gt;</code>와 랜드마크의 위치 <code>&lt;code&gt;$l_j$&lt;/code&gt;</code>.</p>
</li>
<li>
<p><strong>팩터:</strong> 주행기록계 팩터 외에, 포즈 <code>&lt;code&gt;$x_t$&lt;/code&gt;</code>에서 랜드마크 <code>&lt;code&gt;$l_j$&lt;/code&gt;</code>를 관측했을 때 생성되는 <strong>측정 팩터</strong>가 추가된다. 이 팩터는 로봇의 포즈와 랜드마크 위치 간의 기하학적 관계(예: 거리, 방위, 픽셀 좌표)를 제약한다.36</p>
</li>
<li>
<p><strong>그래프 구조:</strong> 로봇 포즈들은 시간 순서에 따라 체인 형태로 연결되고, 각 랜드마크는 그 랜드마크를 관측한 여러 포즈 노드들과 연결되는 특징적인 구조를 가진다.36</p>
</li>
</ul>
<h3>6.2  다중 센서 융합</h3>
<p>현대의 로봇 시스템은 IMU, GPS, 카메라, LiDAR, 주행기록계 등 다양한 센서를 탑재하여 강인성과 정확성을 높인다. 팩터 그래프는 이러한 이종, 비동기 센서 데이터를 융합하기 위한 이상적인 프레임워크를 제공한다.6</p>
<ul>
<li>
<p><strong>모델링:</strong> 각기 다른 센서로부터의 측정값은 그 측정의 물리적 의미를 나타내는 고유한 팩터로 모델링된다. 예를 들어, IMU 측정은 두 연속 상태 간의 동역학적 제약을, GPS 측정은 특정 상태의 절대 위치에 대한 제약을, 카메라 측정은 포즈와 3D 점 간의 투영 기하 제약을 나타내는 팩터가 된다.</p>
</li>
<li>
<p><strong>장점:</strong></p>
</li>
<li>
<p><strong>비동기 및 다중 속도 처리:</strong> 팩터 그래프의 가장 큰 장점 중 하나는 각 센서 데이터를 발생하는 즉시 해당 시점의 변수 노드에 연결되는 팩터로 추가할 수 있다는 점이다. 50Hz로 동작하는 카메라와 200Hz로 동작하는 IMU, 10Hz로 동작하는 GPS 데이터를 융합 주기에 맞춰 동기화할 필요 없이 자연스럽게 통합할 수 있다.24</p>
</li>
<li>
<p><strong>유연성 및 강인성:</strong> 특정 센서의 신호가 일시적으로 끊기거나(예: 터널 안에서의 GPS 신호 손실) 사용할 수 없게 되면, 해당 센서로부터의 팩터를 그래프에 추가하지 않으면 그만이다. 시스템의 다른 부분은 영향을 받지 않고 나머지 센서 정보만으로 계속해서 상태를 추정할 수 있다. 이는 “플러그 앤 플레이“와 같은 유연성을 제공한다.25</p>
</li>
<li>
<p><strong>IMU 사전적분 (Pre-integration):</strong> IMU와 같이 매우 높은 주파수로 데이터를 출력하는 센서의 경우, 매 측정마다 새로운 상태 변수와 팩터를 추가하면 그래프가 너무 빠르게 커져 계산 부담이 커진다. IMU 사전적분은 두 키프레임(keyframe) 사이의 수많은 IMU 측정값들을 하나의 상대적인 움직임 제약으로 요약(사전적분)하는 효율적인 기법이다. 이를 통해 최적화의 변수 개수를 줄이면서도 IMU의 고주파 정보를 손실 없이 통합할 수 있다.25</p>
</li>
</ul>
<h3>6.3  Structure from Motion (SFM) 및 번들 조정</h3>
<p>SFM은 여러 장의 2D 이미지 컬렉션으로부터 3D 장면 구조와 카메라의 위치 및 방향을 동시에 복원하는 컴퓨터 비전 기술이다.38</p>
<ul>
<li>
<p><strong>팩터 그래프 모델링:</strong></p>
</li>
<li>
<p><strong>변수:</strong> 각 이미지를 촬영한 카메라의 포즈(회전 및 위치) <code>&lt;code&gt;$T_i$&lt;/code&gt;</code>와 3D 점들의 위치 <code>&lt;code&gt;$p_j$&lt;/code&gt;</code>.</p>
</li>
<li>
<p><strong>팩터:</strong> SFM의 핵심은 **재투영 오차(reprojection error)**이다. 이는 3D 점 <code>&lt;code&gt;$p_j$&lt;/code&gt;</code>를 추정된 카메라 포즈 <code>&lt;code&gt;$T_i$&lt;/code&gt;</code>를 통해 2D 이미지 평면에 투영했을 때의 좌표와, 실제 이미지에서 관측된 해당 점의 2D 특징점 좌표 사이의 차이를 나타낸다. 각 관측에 대해 이 재투영 오차를 최소화하는 팩터가 생성된다.10</p>
</li>
<li>
<p><strong>번들 조정 (Bundle Adjustment):</strong> 이는 SFM의 마지막 단계에서 모든 카메라 포즈와 3D 점 위치를 동시에 최적화하여 재투영 오차의 총합을 최소화하는 대규모 비선형 최적화 과정을 의미한다. 이는 팩터 그래프 기반 최적화와 본질적으로 동일한 문제이다.39</p>
</li>
</ul>
<p>이처럼 SLAM의 “포즈-랜드마크 제약”, 센서 융합의 “동역학적/절대적 제약”, SFM의 “카메라-3D점 제약“은 모두 팩터 그래프라는 단일한 추상적 개념으로 통합된다. 따라서 SLAM을 위해 개발된 최적화 엔진(예: GTSAM)은 팩터의 종류만 바꾸면 SFM이나 센서 융합 문제에도 거의 그대로 적용될 수 있다. 이는 개별 문제 영역을 뛰어넘는 강력한 “통합 프레임워크“를 제공하며, 코드 재사용성과 연구 개발의 효율성을 극대화한다.40</p>
<h2>7. 제7장 고급 기법 및 주제</h2>
<p>기본적인 팩터 그래프 최적화 프레임워크를 실제 로봇 시스템에 적용하기 위해서는 몇 가지 고급 기법들이 필수적으로 요구된다. 이러한 기법들은 장시간 동작, 비유클리드 공간에서의 상태 표현, 그리고 비정상적인 측정값 처리와 같은 현실 세계의 도전 과제들을 해결하기 위해 개발되었다.</p>
<h3>7.1  점진적 최적화</h3>
<p>로봇이 계속해서 움직이며 새로운 센서 데이터를 수집함에 따라 팩터 그래프의 크기는 시간이 지남에 따라 무한정 커질 수 있다. 매번 새로운 측정값이 들어올 때마다 전체 그래프를 처음부터 다시 최적화하는 배치(batch) 방식은 계산량이 누적되어 실시간 처리가 불가능해진다.43 이를 해결하기 위한 기법들이 점진적 최적화이다.</p>
<ul>
<li>
<p><strong>iSAM (incremental Smoothing and Mapping):</strong> iSAM과 그 발전된 형태인 iSAM2는 이전의 최적화 계산 결과를 재활용하여 새로운 변수와 팩터가 추가되었을 때 효율적으로 해를 업데이트하는 기법이다. 특히 iSAM2는 **베이즈 트리(Bayes Tree)**라는 자료 구조를 사용하여, 새로운 정보가 추가되었을 때 그래프 전체가 아닌, 영향을 받는 부분만 국소적으로 재계산한다. 이를 통해 거의 일정한 시간 복잡도로 최적화를 수행할 수 있다.10</p>
</li>
<li>
<p><strong>슬라이딩 윈도우 최적화 (Sliding Window Optimization):</strong> 이 기법은 계산 복잡도를 일정하게 유지하기 위해 최근의 일정 시간(window) 내의 변수와 팩터만 최적화 대상으로 삼는다. 윈도우에서 벗어나는 가장 오래된 변수는 **한계화(marginalization)**를 통해 제거된다. 한계화는 제거되는 변수에 대한 정보를 윈도우 내에 남아있는 변수들에 대한 새로운 사전 정보 팩터로 압축하여 남기는 과정이다. 이를 통해 과거 정보의 손실을 최소화하면서 계산량을 제어할 수 있다.17</p>
</li>
</ul>
<h3>7.2  비선형 다양체 상에서의 최적화</h3>
<p>로봇의 3차원 방향(rotation)이나 포즈(pose, 위치와 방향의 결합)와 같은 상태 변수들은 단순한 벡터 공간이 아닌, **비선형 다양체(non-linear manifold)**라는 특별한 기하학적 공간에 속한다. 예를 들어, 3차원 회전은 3차원 특수 직교군 <code>&lt;code&gt;$SO(3)$&lt;/code&gt;</code>에, 3차원 강체 변환(포즈)은 3차원 특수 유클리드군 <code>&lt;code&gt;$SE(3)$&lt;/code&gt;</code>에 속한다.3</p>
<p>이러한 공간에서는 일반적인 벡터 덧셈이 잘 정의되지 않는다. 예를 들어, 두 회전 행렬을 단순히 더하면 더 이상 회전 행렬이 아니다. 따라서 최적화 과정에서 계산된 증분 <code>&lt;code&gt;$\Delta X$&lt;/code&gt;</code>를 현재 추정치 <code>&lt;code&gt;$X_k$&lt;/code&gt;</code>에 더하여 <code>&lt;code&gt;$X_{k+1}$&lt;/code&gt;</code>을 업데이트할 때, 단순 덧셈 <code>&lt;code&gt;$X_{k+1} = X_k + \Delta X$&lt;/code&gt;</code>을 사용할 수 없다.</p>
<p>대신, 다양체의 기하학적 구조를 고려한 업데이트 연산이 필요하다. 이는 보통 다양체의 특정 점에서의 접평면(tangent space)이라는 국소적인 벡터 공간을 활용하여 이루어진다. 증분 <code>&lt;code&gt;$\Delta X$&lt;/code&gt;</code>는 이 접평면 상의 벡터로 계산되며, **지수 사상(exponential map)**과 관련된 **리트랙션(retraction)**이라는 연산을 통해 다양체 상의 점으로 다시 매핑된다. 이 업데이트는 <code>&lt;code&gt;$X_{k+1} = X_k \oplus \Delta X$&lt;/code&gt;</code>와 같이 표현된다.5 이러한 처리를 통해 비유클리드 공간에 속하는 변수들을 수학적으로 올바르게 최적화할 수 있다.</p>
<h3>7.3  강인한 추정</h3>
<p>가우시안 노이즈 가정에 기반한 표준적인 최소 제곱 최적화는 **이상치(outlier)**에 매우 취약하다. 이상치란 잘못된 데이터 연관(data association)이나 비정상적인 센서 오작동으로 인해 발생하는, 통계 모델에서 크게 벗어난 측정값을 의미한다. 단 하나의 큰 오차를 가진 팩터가 전체 비용 함수에 막대한 영향을 미쳐, 최적화 결과를 완전히 왜곡시킬 수 있다.3</p>
<p>**강인한 추정(Robust Estimation)**은 이러한 이상치의 영향을 줄이기 위한 기법이다. 핵심 아이디어는 비용 함수를 수정하여, 오차가 특정 임계값을 넘어서면 그 영향력이 더 이상 제곱으로 증가하지 않도록 제한하는 것이다. 이를 위해 표준적인 제곱 오차 대신 <strong>강인한 비용 함수(robust cost function)</strong> 또는 **M-추정량(M-estimator)**을 사용한다. 대표적인 강인한 비용 함수로는 Huber, Cauchy, Geman-McClure 등이 있다.46</p>
<p>이러한 접근법은 최적화 과정에서 이상치로 판단되는 측정값에 해당하는 팩터의 가중치를 동적으로 낮추는 효과를 낸다. 이 과정을 **반복적 재가중 최소 제곱(Iteratively Reweighted Least Squares, IRLS)**이라고도 부르며, 전체 해의 강인성을 크게 향상시킨다.46</p>
<p>이상의 세 가지 고급 기법들은 팩터 그래프 최적화가 학술적 이론을 넘어 실제 로봇에 탑재 가능한 실용적인 솔루션으로 거듭나게 한 필수 요소들이다. 점진적 최적화는 로봇의 지속적인 동작을 가능하게 하고, 다양체 최적화는 3차원 공간에서의 움직임을 올바르게 모델링하며, 강인한 추정은 불완전한 실제 환경에서의 실패를 방지한다. 이 세 가지는 팩터 그래프 최적화의 실용성을 떠받치는 삼각대(tripod of practicality)를 형성한다.</p>
<h2>8. 제8장 주요 소프트웨어 프레임워크 비교 및 활용</h2>
<p>팩터 그래프 기반 최적화를 구현하기 위해 여러 강력한 오픈소스 소프트웨어 라이브러리가 개발되었다. 그중 가장 널리 사용되는 것은 GTSAM, g2o, 그리고 Ceres Solver이다. 이들의 선택은 단순히 기술적인 결정을 넘어, 문제에 접근하는 방식과 철학을 선택하는 것과 같다.</p>
<h3>8.1  GTSAM, g2o, Ceres Solver 비교 분석</h3>
<ul>
<li>
<p><strong>GTSAM (Georgia Tech Smoothing and Mapping):</strong></p>
</li>
<li>
<p><strong>철학:</strong> “문제의 구조를 먼저 생각하라.” 팩터 그래프와 베이즈 네트워크를 라이브러리의 핵심 패러다임으로 채택하여, 사용자가 문제의 확률적, 기하학적 구조를 명시적으로 모델링하도록 유도한다. 이는 복잡한 로보틱스 문제에 대한 체계적이고 원칙적인 접근을 가능하게 한다.41</p>
</li>
<li>
<p><strong>특징:</strong> iSAM2를 통한 강력한 점진적 추론 기능이 가장 큰 특징이다.42 또한</p>
</li>
</ul>
<p><code>&lt;code&gt;$SO(3)$&lt;/code&gt;</code>, <code>&lt;code&gt;$SE(3)$&lt;/code&gt;</code> 등 로보틱스에 필수적인 다양한 다양체 타입을 풍부하게 내장하고 있다.42</p>
<ul>
<li>
<p><strong>g2o (General Graph Optimization):</strong></p>
</li>
<li>
<p><strong>철학:</strong> “효율적인 그래프 최적화를 위한 확장 가능한 툴킷을 제공한다.” 이름처럼 일반적인 그래프 기반 비선형 오차 함수 최적화에 초점을 맞춘 프레임워크이다.48</p>
</li>
<li>
<p><strong>특징:</strong> 높은 확장성을 가져 사용자가 새로운 정점(vertex)과 간선(edge) 타입을 쉽게 정의할 수 있다. ORB-SLAM과 같은 고전적인 Visual SLAM 시스템에서 널리 사용되어 검증된 성능을 보인다.50</p>
</li>
<li>
<p><strong>Ceres Solver:</strong></p>
</li>
<li>
<p><strong>철학:</strong> “최적화는 내가 처리할 테니, 당신은 비용 함수만 정의하라.” Google에서 개발한 대규모 비선형 최적화 라이브러리로, 그래프 구조에 국한되지 않는 더 일반적인 NLLS 솔버이다.52</p>
</li>
<li>
<p><strong>특징:</strong> 강력한 자동 미분(automatic differentiation) 기능을 제공하여 사용자가 복잡한 자코비안 행렬을 수동으로 계산할 필요가 없다.47 유연성이 매우 높고, 가장 큰 사용자 커뮤니티를 보유하고 있어 문서화와 지원이 풍부하다. Cartographer SLAM의 기본 솔버로 채택되었다.47</p>
</li>
</ul>
<p>다음 표는 세 라이브러리의 주요 특징을 요약하여 비교한다.</p>
<p><strong>표 3: 최적화 라이브러리 비교</strong></p>
<table><thead><tr><th>항목</th><th>GTSAM</th><th>g2o</th><th>Ceres Solver</th></tr></thead><tbody>
<tr><td>핵심 패러다임</td><td>팩터 그래프 모델링</td><td>일반 그래프 최적화</td><td>일반 비선형 최소 제곱</td></tr>
<tr><td>자동 미분</td><td>제한적 (Expression)</td><td>지원 안함</td><td>강력하게 지원</td></tr>
<tr><td>점진적 최적화</td><td>iSAM2 (핵심 기능)</td><td>일부 지원</td><td>직접 구현 필요</td></tr>
<tr><td>다양체 지원</td><td>내장 (핵심 기능)</td><td>내장</td><td>확장 기능으로 지원</td></tr>
<tr><td>주요 사용처</td><td>학계 연구, 현대 SLAM</td><td>ORB-SLAM, 고전적 V-SLAM</td><td>Google, Cartographer, 범용</td></tr>
<tr><td>장점</td><td>명확한 모델링, iSAM2</td><td>확장성, 특정 문제에 최적화</td><td>유연성, 자동 미분, 대규모 커뮤니티</td></tr>
<tr><td>단점</td><td>수동 자코비안 필요, 복잡한 빌드</td><td>상대적으로 작은 커뮤니티</td><td>그래프 모델링 직접 구현 필요</td></tr>
<tr><td>라이선스</td><td>BSD</td><td>BSD (최신), LGPL/GPL (구버전)</td><td>Apache 2.0</td></tr>
</tbody></table>
<p>이 표는 각 라이브러리의 철학적 차이와 기술적 장단점을 명확히 보여준다. 예를 들어, 빠른 프로토타이핑과 범용성이 중요하다면 자동 미분을 지원하는 Ceres가 유리할 수 있다. 반면, 장기 자율주행과 같이 점진적 업데이트 성능이 핵심적인 응용 분야에서는 GTSAM의 iSAM2가 더 적합할 수 있다.47</p>
<h3>8.2  GTSAM을 이용한 2D SLAM 예제 구현 및 분석</h3>
<p>GTSAM을 사용하여 간단한 2D 랜드마크 기반 SLAM 문제를 모델링하고 최적화하는 과정은 다음과 같다.</p>
<ul>
<li>
<p><strong>문제 설정:</strong> 2D 평면을 움직이는 로봇이 주행기록계로 자신의 움직임을 측정하고, 미지의 랜드마크들에 대한 상대적인 거리와 방위를 측정하는 시나리오를 가정한다.</p>
</li>
<li>
<p><strong>구현 단계 (MATLAB/Python 의사코드 기반):</strong></p>
</li>
</ul>
<ol>
<li>그래프 객체 생성:</li>
</ol>
<p>최적화 문제를 담을 비선형 팩터 그래프 객체를 생성한다.</p>
<p>graph = NonlinearFactorGraph() 36</p>
<ol start="2">
<li>변수 추가:</li>
</ol>
<p>symbol 함수를 사용하여 각 포즈(<code>‘x’</code>, 1), (<code>‘x’</code>, 2),… 와 랜드마크(<code>‘l’</code>, 1), (<code>‘l’</code>, 2),… 에 대한 고유한 키(key)를 생성한다. 이 키들을 사용하여 변수를 그래프에 추가한다.</p>
<p>graph.add(Pose2(key_x1))</p>
<p>graph.add(Point2(key_l1)) 36</p>
<ol start="3">
<li>팩터 추가:</li>
</ol>
<p>측정과 모델에 해당하는 팩터를 생성하여 관련 변수 키들과 함께 그래프에 추가한다.</p>
<ul>
<li>사전 정보: prior_noise = noiseModel.Diagonal(…)</li>
</ul>
<p>graph.add(PriorFactorPose2(key_x1, initial_pose, prior_noise))</p>
<ul>
<li>주행기록계: odometry_noise = noiseModel.Diagonal(…)</li>
</ul>
<p>graph.add(BetweenFactorPose2(key_x1, key_x2, odometry_measurement, odometry_noise))</p>
<ul>
<li>랜드마크 측정: measurement_noise = noiseModel.Diagonal(…)</li>
</ul>
<p>graph.add(BearingRangeFactor2D(key_x2, key_l1, bearing_range_measurement, measurement_noise)) 36</p>
<ol start="4">
<li>초기값 설정:</li>
</ol>
<p>최적화를 시작하기 위해 모든 변수에 대한 초기 추정치를 제공해야 한다. Values 객체를 생성하고 각 변수 키에 해당하는 초기값을 insert 메서드로 추가한다. 좋은 초기값은 수렴 속도와 결과의 질에 큰 영향을 미친다.</p>
<p>initial_estimate = Values()</p>
<p>initial_estimate.insert(key_x1, pose_guess_x1)</p>
<p>initial_estimate.insert(key_l1, landmark_guess_l1) 10</p>
<ol start="5">
<li>최적화 수행:</li>
</ol>
<p>원하는 최적화 알고리즘(예: Levenberg-Marquardt)을 선택하여 옵티마이저를 생성하고, optimize 메서드를 호출하여 최적의 해를 구한다.</p>
<p>optimizer = LevenbergMarquardtOptimizer(graph, initial_estimate)</p>
<p>result = optimizer.optimize() 35</p>
<ol start="6">
<li>결과 분석:</li>
</ol>
<p>최적화 결과(result)에는 각 변수에 대한 최적의 추정치가 담겨 있다. 이를 추출하여 로봇의 궤적과 랜드마크 지도를 시각화하고, 필요하다면 각 변수에 대한 불확실성(공분산)을 계산하여 분석할 수 있다.</p>
<p>이러한 과정을 통해 복잡한 SLAM 문제를 체계적이고 모듈화된 방식으로 모델링하고, 강력한 비선형 최적화 기법을 적용하여 정확한 해를 구할 수 있다.</p>
<h2>9. 제9장 결론 및 전망</h2>
<h3>9.1  팩터 그래프 기반 최적화의 장점 요약</h3>
<p>팩터 그래프 기반 최적화는 지난 20년간 로보틱스와 컴퓨터 비전 분야의 상태 추정 문제에 대한 접근 방식을 근본적으로 변화시켰다. 이는 단순히 새로운 알고리즘의 등장을 넘어, 문제 해결을 위한 통합적인 철학을 제시했다. 그 핵심 장점은 다음과 같이 요약할 수 있다.</p>
<ul>
<li>
<p><strong>통합된 모델링 프레임워크:</strong> SLAM, SFM, 센서 융합 등 표면적으로 달라 보이는 다양한 추정 문제들을 ’변수’와 ’팩터’라는 일관된 언어로 모델링할 수 있는 강력한 추상화를 제공한다.</p>
</li>
<li>
<p><strong>효율적인 계산:</strong> 문제의 물리적, 시간적 국소성을 그래프의 희소성으로 직접 변환하여, 대규모 문제도 효율적으로 해결할 수 있는 계산적 토대를 마련한다.</p>
</li>
<li>
<p><strong>원칙적인 불확실성 처리:</strong> 베이즈 추론에 깊이 뿌리를 두고 있어, 센서 노이즈와 모델의 불확실성을 체계적이고 통계적으로 타당한 방식으로 다룬다.</p>
</li>
<li>
<p><strong>모듈성 및 확장성:</strong> 새로운 센서나 제약 조건을 기존 시스템의 수정 없이 팩터 형태로 쉽게 추가할 수 있는 유연한 구조를 제공하여, 복잡한 시스템의 개발과 유지보수를 용이하게 한다.</p>
</li>
</ul>
<h3>9.2  향후 연구 방향 및 과제</h3>
<p>팩터 그래프는 이미 성숙한 기술이지만, 여전히 활발한 연구가 진행되고 있으며 미래의 자율 시스템을 위한 새로운 가능성을 열어가고 있다. 주요 연구 방향은 다음과 같다.</p>
<ul>
<li>
<p><strong>딥러닝과의 결합:</strong> 딥러닝 기술을 활용하여 팩터 그래프의 구성 요소를 데이터로부터 학습하려는 시도가 활발하다. 예를 들어, 복잡한 센서의 측정 모델이나 데이터 연관 관계를 결정하는 팩터를 신경망으로 대체하거나, 최적화 과정 자체를 학습 기반으로 개선하는 연구가 진행 중이다.59 이는 전통적인 모델 기반 접근법의 한계를 극복하고, 더욱 복잡하고 비정형적인 환경에 대한 강인성을 높일 수 있을 것으로 기대된다.</p>
</li>
<li>
<p><strong>분산 최적화 및 다중 로봇 시스템:</strong> 여러 로봇이 협력하여 SLAM을 수행하는 다중 로봇 시스템에서, 각 로봇이 자신의 로컬 팩터 그래프를 유지하면서 통신을 통해 정보를 공유하고 전역적으로 일관된 해를 찾는 분산 최적화 기법이 중요한 연구 주제이다. 이는 통신 대역폭과 계산 부하를 효율적으로 관리하면서 대규모 협력 매핑 및 측위를 가능하게 할 것이다.44</p>
</li>
<li>
<p><strong>비-가우시안 및 다중 모드 추론:</strong> 현실 세계의 불확실성은 항상 단일 가우시안 분포로 표현되지 않는다. 데이터 연관의 모호성이나 비선형성이 강한 시스템에서는 사후 확률 분포가 여러 개의 봉우리를 갖는 다중 모드(multi-modal) 형태를 띨 수 있다. 가우시안 가정을 넘어서 이러한 복잡한 분포를 직접 다룰 수 있는 강인하고 일반적인 추론 기법에 대한 연구가 요구된다.3</p>
</li>
<li>
<p><strong>동적 환경으로의 확장:</strong> 대부분의 현재 SLAM 시스템은 환경이 정적(static)이라는 가정 하에 동작한다. 그러나 실제 환경에는 움직이는 사람, 차량 등 동적 객체들이 존재한다. 팩터 그래프 프레임워크를 확장하여 이러한 동적 객체들을 추적하고, 시간에 따라 변화하는 환경 자체를 모델링하는 연구는 미래 자율주행 및 서비스 로봇 기술의 핵심 과제이다.</p>
</li>
</ul>
<p>결론적으로, 팩터 그래프 기반 최적화는 로보틱스 추정 문제에 대한 강력하고 원칙적인 해결책을 제공했으며, 앞으로도 인공지능의 다른 분야, 특히 딥러닝과 융합하며 자율 시스템의 지능을 한 단계 더 발전시키는 데 핵심적인 역할을 계속할 것이다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>Factor Graphs in Robotics. What is a Factor Graph? | by Sai Swaroop Reddy V | Medium, https://medium.com/@swaroop.vennapusa/factor-graphs-in-robotics-e853db435695</li>
<li>Factor Graphs for Robot Perception by Frank Dellaert - Goodreads, https://www.goodreads.com/book/show/57873122-factor-graphs-for-robot-perception</li>
<li>Factor Graphs for Navigation Applications: A Tutorial, https://navi.ion.org/content/navi/71/3/navi.653.full.pdf</li>
<li>Factor Graphs for Robot Perception - CMU School of Computer …, https://www.cs.cmu.edu/~kaess/pub/Dellaert17fnt.pdf</li>
<li>miniSAM: A Flexible Factor Graph Non-linear Least Squares Optimization Framework, https://project.inria.fr/ppniv19/files/2019/11/PPNIV19-paper_Dong.pdf</li>
<li>Factor graph optimization for GNSS/INS integration: A comparison with the extended Kalman filter - The Institute of Navigation, https://navi.ion.org/content/68/2/315</li>
<li>A Tutorial on Graph-Based SLAM, http://www2.informatik.uni-freiburg.de/~stachnis/pdf/grisetti10titsmag.pdf</li>
<li>Factor Graphs and GTSAM: A Hands-on Introduction - GT Digital Repository, https://repository.gatech.edu/server/api/core/bitstreams/b3606eb4-ce55-4c16-8495-767bd46f0351/content</li>
<li>Graphical Models, http://swoh.web.engr.illinois.edu/courses/IE598/handout/graph.pdf</li>
<li>Factor Graphs and GTSAM, https://gtsam.org/tutorials/intro.html</li>
<li>What are Factor Graphs? - GTSAM, https://gtsam.org/2020/06/01/factor-graphs.html</li>
<li>Factor Graphs: Exploiting Structure in Robotics - Annual Reviews, https://www.annualreviews.org/doi/10.1146/annurev-control-061520-010504</li>
<li>Bayesian Networks Factor Graphs the Case-Factor Algorithm and the Junction Tree Algorithm 1 Bayesian Networks - TTIC, https://home.ttic.edu/~dmcallester/ttic101-07/lectures/graphmodels/graphmodels.pdf</li>
<li>1 Inference in Graphical Models, https://dellaert.github.io/20S-3630/notes/1-hmm-inference.pdf</li>
<li>Contents 1 Inference in Graphical Models, https://dellaert.github.io/21S-3630/notes/N6_Inference_Factor_Graphs.pdf</li>
<li>An Introduction to Factor Graphs, https://people.binf.ku.dk/~thamelry/MLSB08/hal.pdf</li>
<li>Factor Graphs for Robot Perception - Now Publishers, https://www.nowpublishers.com/article/DownloadSummary/ROB-043</li>
<li>Extending Factor Graphs so as to Unify Directed and Undirected Graphical Models - arXiv, https://arxiv.org/abs/1212.2486</li>
<li>Factor Graphs for Navigation Applications: A Tutorial, https://navi.ion.org/content/71/3/navi.653</li>
<li>pgmpy.org, <a href="https://pgmpy.org/models/factorgraph.html#:~:text=They%20allow%20efficient%20computation%20of,between%20variables%20and%20factor%20nodes.">https://pgmpy.org/models/factorgraph.html#:~:text=They%20allow%20efficient%20computation%20of,between%20variables%20and%20factor%20nodes.</a></li>
<li>Factor Graph — 1.0.0 | pgmpy docs, https://pgmpy.org/models/factorgraph.html</li>
<li>Welcome to Factor Graphs - Emma Benjaminson, https://sassafras13.github.io/FactorGraphs/</li>
<li>Factor Graph - DeepDive, http://deepdive.stanford.edu/assets/factor_graph.pdf</li>
<li>An Improved Multi-Sensor Fusion Navigation Algorithm Based on the Factor Graph - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC5375927/</li>
<li>Information Fusion in Navigation Systems via Factor Graph Based Incremental Smoothing - CMU School of Computer Science, https://www.cs.cmu.edu/~kaess/pub/Indelman13ras.pdf</li>
<li>Factor Graph Based Incremental Smoothing in Inertial Navigation Systems - Carnegie Mellon University Robotics Institute, https://www.ri.cmu.edu/pub_files/2012/7/Indelman12fusion.pdf</li>
<li>Graph SLAM - Washington, <a href="https://courses.cs.washington.edu/courses/cse571/23sp/slides/L09/Lecture09_Modern%20SLAM.pdf">https://courses.cs.washington.edu/courses/cse571/23sp/slides/L09/Lecture09_Modern%20SLAM.pdf</a></li>
<li>PROBABILISTIC ROBOTICS, https://docs.ufpr.br/~danielsantos/ProbabilisticRobotics.pdf</li>
<li>Map Indoor Area Using Lidar SLAM and Factor Graph - MATLAB &amp; Simulink - MathWorks, https://www.mathworks.com/help/nav/ug/map-indoor-area-using-lidar-slam-and-factor-graph.html</li>
<li>Gaussian function - Wikipedia, https://en.wikipedia.org/wiki/Gaussian_function</li>
<li>Introduction to Factor Graph — miniSAM 0.1 documentation, https://minisam.readthedocs.io/factor_graph.html</li>
<li>Non-linear least squares - Wikipedia, https://en.wikipedia.org/wiki/Non-linear_least_squares</li>
<li>
<ol start="13">
<li>Nonlinear least squares, http://www.seas.ucla.edu/~vandenbe/133A/lectures/nlls.pdf</li>
</ol>
</li>
<li>Levenberg–Marquardt algorithm - Wikipedia, <a href="https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm">https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm</a></li>
<li>2D Pose SLAM in GTSAM - Piazza, https://piazza.com/class_profile/get_resource/hbl3nsqea3z6uo/hf5dj0hcfey5fi</li>
<li>Landmark-based SLAM — GTSAM 4.0.2 documentation - Read the Docs, https://gtsam-jlblanco-docs.readthedocs.io/en/latest/LandmarkBasedSLAM.html</li>
<li>Resilient Factor Graph-Based GNSS/IMU/Vision/Odo Integrated Navigation Scheme Enhanced by Noise Approximate Gaussian Estimation in Challenging Environments - MDPI, https://www.mdpi.com/2072-4292/16/12/2176</li>
<li>Factor Graphs and GTSAM: A Hands-on Introduction - Georgia Institute of Technology, https://sites.cc.gatech.edu/home/dellaert/FrankDellaert/Frank_Dellaert/Entries/2013/5/10_Factor_Graphs_Tutorial_files/gtsam.pdf</li>
<li>DEPARTMENT OF INFORMATICS Factor Grouping for Efficient Bundle Adjustment, https://cvg.cit.tum.de/_media/members/demmeln/chan2022ma.pdf</li>
<li>Structure from Motion — GTSAM 4.0.2 documentation, https://gtsam-jlblanco-docs.readthedocs.io/en/latest/StructureFromMotion.html</li>
<li>GTSAM | GTSAM is a BSD-licensed C++ library that implements sensor fusion for robotics and computer vision using factor graphs., https://gtsam.org/</li>
<li>GTSAM 4.0 Tutorial Theory, Programming, and Applications - Jing Dong, https://dongjing3309.github.io/files/gtsam-tutorial.pdf</li>
<li>Generic Node Removal for Factor-Graph SLAM - CMU School of Computer Science, https://www.cs.cmu.edu/~kaess/pub/CarlevarisBianco14tro.pdf</li>
<li>[PDF] Factor Graphs for Robot Perception | Semantic Scholar, https://www.semanticscholar.org/paper/Factor-Graphs-for-Robot-Perception-Dellaert-Kaess/d30c40f372976914f6a433d9bd6c70a2eea54832</li>
<li>Optimize factor graph - MATLAB - MathWorks, https://www.mathworks.com/help/nav/ref/factorgraph.optimize.html</li>
<li>Look Ma, No RANSAC - GTSAM, https://gtsam.org/2019/09/20/robust-noise-model.html</li>
<li>G2O vs GTSAM vs Ceres Solver from a programmer’s perspective | by Jianzhu Huai, https://medium.com/@jianzhuhuai0108/g2o-vs-gtsam-vs-ceres-solver-from-a-programmers-perspective-f45ac68a90fd</li>
<li>g2o: A General Framework for Graph Optimization - OpenSLAM.org, https://openslam-org.github.io/g2o.html</li>
<li>RainerKuemmerle/g2o: g2o: A General Framework for Graph Optimization - GitHub, https://github.com/RainerKuemmerle/g2o</li>
<li>A Comparison of Graph Optimization Approaches for Pose Estimation in SLAM - Laboratory for Autonomous Systems and Mobile Robotics, https://lamor.fer.hr/images/50036607/2021-ajuric-comparison-mipro.pdf</li>
<li>(PDF) G2o: A general framework for graph optimization - ResearchGate, https://www.researchgate.net/publication/224252449_G2o_A_general_framework_for_graph_optimization</li>
<li>Ceres Solver — A Large Scale Non-linear Optimization Library, http://ceres-solver.org/</li>
<li>ceres-solver/ceres-solver: A large scale non-linear optimization library - GitHub, https://github.com/ceres-solver/ceres-solver</li>
<li>g2o vs. Ceres: Optimizing Scan Matching in Cartographer SLAM - arXiv, https://arxiv.org/html/2507.07142v1</li>
<li>A Comparison of Graph Optimization Approaches for Pose Estimation in SLAM, <a href="https://www.semanticscholar.org/paper/A-Comparison-of-Graph-Optimization-Approaches-for-Juric-Kende%C5%A1/0cf3ae33d92f24f62f53158186533e8566f57fde">https://www.semanticscholar.org/paper/A-Comparison-of-Graph-Optimization-Approaches-for-Juric-Kende%C5%A1/0cf3ae33d92f24f62f53158186533e8566f57fde</a></li>
<li>What is GTSAM? Competitors, Complementary Techs &amp; Usage | Sumble, https://sumble.com/tech/gtsam</li>
<li>GTSAM is a library of C++ classes that implement smoothing and mapping (SAM) in robotics and vision, using factor graphs and Bayes networks as the underlying computing paradigm rather than sparse matrices. - GitHub, https://github.com/borglab/gtsam</li>
<li>Hexagonal 2D SLAM · Caesar.jl - JuliaRobotics, https://juliarobotics.org/Caesar.jl/v0.9/examples/basic_hexagonal2d/</li>
<li>Factor Graphs and Robust Perception | Michael Kaess | Tartan SLAM Series - YouTube, https://www.youtube.com/watch?v=JmR2YpkLNt0</li>
<li>[PDF] G2o: A general framework for graph optimization - Semantic Scholar, <a href="https://www.semanticscholar.org/paper/G2o%3A-A-general-framework-for-graph-optimization-K%C3%BCmmerle-Grisetti/24d1afc81644877f6fc34a5a15d7a41e03a4e522">https://www.semanticscholar.org/paper/G2o%3A-A-general-framework-for-graph-optimization-K%C3%BCmmerle-Grisetti/24d1afc81644877f6fc34a5a15d7a41e03a4e522</a></li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>