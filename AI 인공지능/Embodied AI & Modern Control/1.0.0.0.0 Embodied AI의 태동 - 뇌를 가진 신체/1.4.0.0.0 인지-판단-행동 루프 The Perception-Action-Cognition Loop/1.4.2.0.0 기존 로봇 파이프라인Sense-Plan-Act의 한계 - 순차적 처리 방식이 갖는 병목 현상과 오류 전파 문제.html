<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.4.2 기존 로봇 파이프라인(Sense-Plan-Act)의 한계: 순차적 처리 방식이 갖는 병목 현상과 오류 전파 문제.</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.4.2 기존 로봇 파이프라인(Sense-Plan-Act)의 한계: 순차적 처리 방식이 갖는 병목 현상과 오류 전파 문제.</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 1. Embodied AI의 태동: 뇌를 가진 신체</a> / <a href="index.html">1.4 인지-판단-행동 루프 (The Perception-Action-Cognition Loop)</a> / <span>1.4.2 기존 로봇 파이프라인(Sense-Plan-Act)의 한계: 순차적 처리 방식이 갖는 병목 현상과 오류 전파 문제.</span></nav>
                </div>
            </header>
            <article>
                <h1>1.4.2 기존 로봇 파이프라인(Sense-Plan-Act)의 한계: 순차적 처리 방식이 갖는 병목 현상과 오류 전파 문제.</h1>
<h2>1.  서론: 인지주의 로봇 공학의 이상과 물리적 세계의 충돌</h2>
<p>로봇 공학의 역사, 특히 자율 시스템(Autonomous Systems)의 발전을 논할 때 <strong>Sense-Plan-Act (SPA)</strong> 아키텍처는 단순한 기술적 방법론을 넘어 하나의 시대를 정의하는 철학적 패러다임으로 자리 잡고 있다. 1960년대 중반부터 1980년대 중반까지 인공지능(AI) 연구를 지배했던 이 접근 방식은 “지능(Intelligence)“을 정보의 입력, 처리, 그리고 출력이라는 일련의 논리적 연산 과정으로 규명하려는 시도였다.1 당시 연구자들은 컴퓨터가 수학적 정리를 증명하거나 체스를 두는 것처럼, 로봇 또한 물리적 세계를 기호(Symbol)로 변환하여 내부에서 조작함으로써 지능적으로 행동할 수 있다고 믿었다. 이러한 믿음은 <strong>기호주의 AI(Symbolic AI)</strong> 와 <strong>인지주의(Cognitivism)</strong> 의 핵심이었으며, 이를 물리적 기계에 구현한 결정체가 바로 SPA 아키텍처, 혹은 <strong>SMPA (Sense-Model-Plan-Act)</strong> 모델이었다.3</p>
<p>그러나 이 이상적인 청사진은 실험실의 통제된 환경을 벗어나는 순간 가혹한 현실에 직면했다. 로봇이 감각 기관(Sensors)을 통해 받아들이는 정보는 불완전하고 노이즈가 가득했으며, 이를 바탕으로 수립한 논리적으로 완벽한 계획(Plan)은 모터와 바퀴의 미세한 오차나 예상치 못한 환경의 변화로 인해 실행 단계(Act)에서 무참히 붕괴되기 일쑤였다. 본 장에서는 현대 로봇 공학이 딥러닝 기반의 End-to-End 학습이나 반응형(Reactive) 아키텍처로 선회하기 전, 수십 년간 표준으로 군림했던 SPA 파이프라인의 구조적 한계를 심층적으로 해부한다.</p>
<p>특히 우리는 두 가지 핵심적인 문제에 집중할 것이다. 첫째는 <strong>계산적 병목(Computational Bottleneck)</strong> 현상이다. 감지에서 행동으로 이어지는 순차적 처리 과정이 어떻게 로봇을 “생각하느라 움직이지 못하는 기계“로 만들었는지, 그리고 그 이면에 깔린 기호 접지(Symbol Grounding)와 탐색 복잡도(Search Complexity)의 문제를 분석한다.3 둘째는 <strong>오류 전파(Error Propagation)</strong> 메커니즘이다. 각 단계가 독립적인 모듈로 분리된 순차적 파이프라인에서, 초기 단계의 미세한 오차가 어떻게 후속 단계로 증폭되어 시스템 전체의 연쇄 실패(Cascading Failure)를 유발하는지 수학적, 공학적 관점에서 고찰한다.5 나아가 이 아키텍처가 전제하고 있는 <strong>닫힌 세계 가설(Closed World Assumption)</strong> 과 <strong>정적 세계관</strong>이 현대의 역동적인 비정형 환경(Unstructured Environment)과 왜 양립할 수 없는지를 밝힘으로써, 차세대 로봇 아키텍처가 해결해야 할 과제를 명확히 한다.</p>
<h2>2.  Sense-Plan-Act (SPA) 아키텍처의 구조적 해부와 철학적 배경</h2>
<h3>2.1  순차적 정보 처리의 3단계 파이프라인</h3>
<p>SPA 아키텍처는 인간의 인지 과정을 공학적으로 모사하려는 시도에서 출발했다. 이는 복잡한 자율 주행이나 조작(Manipulation) 작업을 기능적으로 명확히 구분된 세 가지 하위 시스템으로 분할하여 정복하려는 환원주의적 설계 사상을 반영한다.1</p>
<h4>2.1.1  감지(Sense) 및 모델링(Model): 물리 세계의 디지털 복제</h4>
<p>첫 번째 단계인 ’감지(Sense)’는 로봇이 카메라, 라이다(LiDAR), 소나(Sonar), 접촉 센서 등을 통해 외부 환경의 물리적 신호를 수집하는 과정이다.1 그러나 SPA 패러다임에서 이 단계의 핵심은 단순한 데이터 수집이 아니라, 수집된 로우 데이터(Raw Data)를 로봇의 두뇌가 이해할 수 있는 <strong>세계 모델(World Model)</strong> 로 변환하는 데 있다.8 이를 흔히 <strong>모델링(Modeling)</strong> 또는 <strong>지각(Perception)</strong> 단계라고 부르며, SPA를 SMPA(Sense-Model-Plan-Act)라고 부르는 이유이기도 하다.4</p>
<p>이 과정에서 로봇은 아날로그적이고 연속적인 현실 세계를 이산적이고 논리적인 <strong>기호(Symbol)</strong> 의 집합으로 추상화한다. 예를 들어, 카메라 이미지의 픽셀 배열은 경계선 검출(Edge Detection)과 영역 분할(Segmentation)을 거쳐 “전방 3미터, 좌표 (x, y)에 장애물 <span class="math math-inline">O_1</span>이 존재함“이라는 명제로 변환된다. 이 모델은 로봇의 메모리 내에 저장되는 환경의 지도(Map)이자 상태 기술(State Description)이 되며, 이후의 모든 계획 과정은 실제 세계가 아닌 이 내부 모델을 대상으로 수행된다.9</p>
<h4>2.1.2  계획(Plan): 기호 논리 공간에서의 탐색</h4>
<p>구축된 세계 모델은 <strong>계획기(Planner)</strong> 로 전달된다. 계획기는 현재 로봇의 상태(Initial State)와 목표 상태(Goal State) 사이의 간극을 분석하고, 로봇이 수행 가능한 행동 연산자(Operators)들을 조합하여 목표를 달성할 수 있는 일련의 행동 시퀀스를 생성한다.1 1970년대의 대표적인 계획 시스템인 STRIPS(Stanford Research Institute Problem Solver)는 “A 지점에서 B 지점으로 이동”, “물체 C를 들어 올림“과 같은 고수준의 행동들을 논리적으로 연결하여 최적의 경로를 산출했다.11</p>
<p>이 단계는 본질적으로 방대한 상태 공간(State Space)을 뒤지는 <strong>탐색(Search)</strong> 문제로 귀결된다. 계획기는 물리적 실행 가능성보다는 논리적 정합성에 초점을 맞추며, “만약 내가 이 행동을 하면 세상은 이렇게 변할 것이다“라는 예측 모델에 의존하여 미래를 시뮬레이션한다. 중요한 점은 이 과정이 <strong>오프라인(Offline)</strong> 혹은 <strong>정적(Static)</strong> 으로 이루어진다는 점이다. 계획이 수립되는 동안 로봇은 멈춰 서서 연산에 집중한다.3</p>
<h4>2.1.3  행동(Act): 계획의 맹목적 실행</h4>
<p>마지막 단계인 ’행동(Act)’은 계획기가 생성한 행동 지령을 실제 물리적 움직임으로 변환하는 과정이다. “좌표 (x, y)로 이동하라“는 고수준 명령은 제어기(Controller)에 의해 휠 모터의 전압이나 로봇 팔의 관절 토크(Torque) 명령으로 분해된다.1 고전적 SPA 구조에서 행동 모듈은 계획 모듈의 지시를 충실히 이행하는 ’손발’의 역할에 그치며, 실행 도중에 환경을 다시 감지하여 계획을 수정하는 피드백 루프는 매우 제한적이거나 느렸다. 이는 행동 단계가 본질적으로 <strong>개방 루프(Open-Loop)</strong> 제어의 성격을 띠게 만들었다.13</p>
<h3>2.2  고전적 아키텍처의 데이터 흐름과 가정</h3>
<p>SPA 아키텍처의 데이터 흐름은 <span class="math math-inline">Sense \rightarrow Model \rightarrow Plan \rightarrow Act</span>의 단방향 선형 구조를 가진다. 이는 소프트웨어 공학적으로는 모듈 간의 독립성을 보장하고 개발 및 디버깅을 용이하게 하는 장점이 있다.3 각 모듈은 입출력이 명확한 블랙박스로 취급될 수 있기 때문이다. 그러나 이러한 구조는 다음과 같은 강력하고도 위험한 가정들에 기반하고 있었다.</p>
<ol>
<li><strong>세계는 정적이다(Quasi-static Environment):</strong> 감지하고 계획하는 동안 세상은 변하지 않고 멈춰 있어야 한다.</li>
<li><strong>모델은 완전하다(Perfect Modeling):</strong> 센서 데이터로부터 구축된 세계 모델은 현실을 충분히 정확하게 반영한다.</li>
<li><strong>행동은 결정론적이다(Deterministic Action):</strong> 계획된 행동은 오차 없이 정확하게 수행된다.</li>
</ol>
<p>이러한 가정들은 체스 게임이나 공장 자동화와 같은 통제된 환경에서는 유효했으나, 셰이키(Shakey)와 같은 이동 로봇이 마주한 실제 환경에서는 처참한 실패의 원인이 되었다. 로드니 브룩스(Rodney Brooks)는 이를 두고 “고전적 AI는 표상(Representation)에 집착하느라 현실과의 상호작용을 잃어버렸다“고 비판하며, 이 순차적 파이프라인이 지능의 병목임을 지적했다.15</p>
<table><thead><tr><th><strong>단계</strong></th><th><strong>주요 기능</strong></th><th><strong>입력 데이터</strong></th><th><strong>출력 데이터</strong></th><th><strong>주요 가정</strong></th></tr></thead><tbody>
<tr><td><strong>Sense</strong></td><td>데이터 수집 및 전처리</td><td>물리적 신호 (빛, 소리 등)</td><td>Raw Sensor Data (픽셀, 거리값)</td><td>센서는 신뢰할 수 있으며 노이즈는 제거 가능하다.</td></tr>
<tr><td><strong>Model</strong></td><td>환경의 기호적 추상화</td><td>Raw Sensor Data</td><td>World Model (지도, 객체 위치)</td><td>모델은 실제 세계와 1:1로 대응된다 (Isomorphism).</td></tr>
<tr><td><strong>Plan</strong></td><td>행동 시퀀스 생성</td><td>World Model, Goal</td><td>Plan (행동 목록)</td><td>세계는 계획 수립 중에 변하지 않는다.</td></tr>
<tr><td><strong>Act</strong></td><td>물리적 구동</td><td>Plan</td><td>Motor Commands (전압, 토크)</td><td>지령된 행동은 물리적으로 정확히 수행된다.</td></tr>
</tbody></table>
<h2>3.  첫 번째 병목: 감지(Sensing)와 세계 모델링의 계산 비용과 정보 손실</h2>
<p>SPA 아키텍처가 실시간 로봇 제어에 실패한 첫 번째 원인은 ‘감지 및 모델링’ 단계에서 발생하는 막대한 계산 비용과 필연적인 정보 손실에 있다. 로봇이 “본다“는 것은 단순히 카메라의 셔터를 누르는 것이 아니라, 무의미한 픽셀의 나열에서 의미를 추출하는 고도의 인지 과정이기 때문이다.</p>
<h3>3.1  기호 접지 문제(Symbol Grounding Problem)와 계산 폭발</h3>
<p>로봇의 두뇌(컴퓨터)는 “문(Door)”, “충돌(Collision)”, “이동(Move)“과 같은 추상적 기호를 처리하지만, 로봇의 신체(센서)는 오직 전압의 변화나 0과 1의 비트 스트림만을 받아들인다. 이 둘 사이의 간극을 메우는 것을 <strong>기호 접지 문제(Symbol Grounding Problem)</strong> 라 한다.1</p>
<p>초기 로봇인 셰이키는 흑백 카메라를 통해 입력된 영상을 분석하여 방의 구조를 파악해야 했다. 1960년대 말의 컴퓨팅 파워(PDP-10 등)로 640x480 해상도의 이미지를 처리하는 것은 엄청난 도전이었다. 셰이키는 이미지의 노이즈를 제거하고, 경계선(Edge)을 추출하고, 이 선들을 연결하여 사각형이나 삼각형 같은 기하학적 형태를 인식한 뒤, 이것이 “장애물“인지 “바닥“인지 식별하는 과정을 거쳤다.2</p>
<p>이 과정은 순수하게 연산 집약적이다. 하나의 장면을 해석하여 세계 모델을 업데이트하는 데만 수십 분에서 수 시간이 소요되기도 했다. SPA 구조상, 모델링이 완료되지 않으면 계획 단계로 넘어갈 수 없다. 따라서 로봇은 한 번 움직일 때마다 오랫동안 멈춰 서서 “눈앞의 이 픽셀 덩어리가 무엇인지“를 계산해야 했다. 이는 자율 주행 차량이나 드론과 같이 고속으로 이동해야 하는 현대의 로봇 시스템에서는 치명적인 지연(Latency)을 야기한다. 오늘날의 딥러닝 기반 객체 인식(Object Detection)조차도 고성능 GPU 없이는 실시간 처리가 어려울 만큼, ’감지’는 여전히 값비싼 과정이다.14</p>
<h3>3.2  정보의 과잉 압축과 돌이킬 수 없는 손실</h3>
<p>역설적으로, 모델링 과정은 정보를 생성하는 과정이 아니라 <strong>정보를 버리는(Lossy)</strong> 과정이다. 계획기(Planner)가 처리할 수 있는 형태(기호)로 데이터를 변환하기 위해, 센서가 포착한 풍부한 물리적 정보는 과감하게 생략되거나 추상화된다.19</p>
<p>예를 들어, 라이다 센서는 장애물의 표면 질감, 색상, 미세한 요철 등을 감지할 수 있지만, SPA 파이프라인의 모델링 모듈은 이를 단순히 “점유 격자(Occupancy Grid)의 1(장애물 있음)” 또는 “3D Bounding Box“로 압축해버린다. 이 과정에서 ‘물체가 부드러운지 딱딱한지’, ’바닥이 미끄러운지 거친지’와 같은 중요한 물리적 맥락(Context)이 소실된다.</p>
<p>이러한 <strong>정보 손실(Information Loss)</strong> 은 이후 단계에서 복구할 수 없다. 계획기는 “장애물 있음“이라는 기호만 보고 경로를 생성하므로, 그것이 밀고 지나갈 수 있는 커튼인지 절대 피해야 할 콘크리트 벽인지 구분하지 못한다. 만약 로봇이 커튼을 벽으로 인식하여 모델링했다면, 계획기는 불필요하게 먼 길을 돌아가는 비효율적인 경로를 생성할 것이다.19 현대의 End-to-End 학습 모델이 로우 데이터(Raw Data)를 행동 출력 직전까지 유지하며 이러한 손실을 최소화하려는 것과 대비되는 부분이다.20</p>
<h3>3.3  정적 세계의 환상과 동기화 실패</h3>
<p>SPA 아키텍처는 모델링이 수행되는 시간 <span class="math math-inline">\Delta t_{model}</span> 동안 세계가 정지해 있다고 가정한다. 로봇이 <span class="math math-inline">t=0</span> 시점에 센서 데이터를 획득하고, 복잡한 연산을 거쳐 <span class="math math-inline">t=10s</span> 시점에 세계 모델 업데이트를 완료했다고 가정하자. 이 시점에서 로봇이 가지고 있는 모델은 “지금(<span class="math math-inline">t=10s</span>)“의 세계가 아니라 “10초 전(<span class="math math-inline">t=0</span>)“의 과거이다.8</p>
<p>만약 그 10초 사이에 보행자가 이동했거나 조명이 바뀌었다면, 로봇의 내부 모델과 실제 세계 사이에는 <strong>불일치(Mismatch)</strong> 가 발생한다. 계획기는 이미 낡아버린 모델을 바탕으로 미래를 계획하게 되며, 이는 필연적으로 실행 오류로 이어진다. 이 불일치를 줄이기 위해 센싱 주기를 높이면 연산 부하가 증가하여 <span class="math math-inline">\Delta t_{model}</span>이 다시 늘어나는 딜레마에 빠지게 된다. 이것이 고전적 로봇들이 동적 환경(Dynamic Environment)에서 맥을 추지 못했던 근본적인 이유이다.3</p>
<h2>4.  두 번째 병목: 계획(Planning)의 계산 복잡도와 정지된 시간</h2>
<p>세계 모델이 구축된 후, 로봇은 목표 달성을 위한 최적의 행동 순서를 찾아야 한다. 이 계획(Planning) 단계는 인공지능의 정수(Essence)로 여겨졌으나, 동시에 로봇을 무한한 계산의 늪에 빠뜨리는 주범이기도 했다.</p>
<h3>4.1  상태 공간의 폭발과 NP-난해성(NP-Hardness)</h3>
<p>고전적 계획 알고리즘인 STRIPS나 A* 탐색은 상태 공간(State Space)을 탐색하여 초기 상태에서 목표 상태로 가는 경로를 찾는다.10 문제는 현실 세계의 자유도(Degrees of Freedom, DoF)가 조금만 증가해도, 고려해야 할 상태의 수가 지수함수적으로(Exponentially) 폭발한다는 것이다. 이를 <strong>차원의 저주(Curse of Dimensionality)</strong> 라 한다.22</p>
<p>예를 들어, 격자 지도(Grid Map) 위를 움직이는 로봇의 경로 계획은 비교적 간단하다. 하지만 로봇 팔(Manipulator)이 6개의 관절을 움직여 물체를 잡고 이동시키는 문제(Pick-and-Place), 혹은 여러 대의 로봇이 서로 충돌하지 않고 이동하는 다중 에이전트 경로 계획(Multi-Agent Path Finding) 문제로 확장되면, 계산 복잡도는 급격히 증가하여 <strong>PSPACE-complete</strong> 혹은 <strong>NP-Hard</strong> 클래스에 속하게 된다.22</p>
<p>이는 최적의 해를 찾는 데 걸리는 시간이 문제의 크기에 따라 기하급수적으로 늘어남을 의미한다. 복잡한 환경에서 완벽한 계획을 수립하기 위해 로봇은 수 시간, 심지어 수 일을 계산해야 할 수도 있다. SPA 아키텍처는 “생각(계획)이 끝날 때까지 행동하지 않는다“는 원칙을 고수했으므로, 로봇은 계산이 완료될 때까지 망부석처럼 서 있을 수밖에 없었다. 연구자들은 이를 <strong>“생각하는 것은 행동하지 않는 것을 의미한다(Thinking implies not acting)”</strong> 는 역설로 표현하며 비판했다.3</p>
<h3>4.2  결정론적 계획의 취약성과 확률적 고려의 한계</h3>
<p>초기 SPA 시스템의 계획기는 대부분 <strong>결정론적(Deterministic)</strong> 이었다. 즉, “상태 A에서 행동 u를 하면 반드시 상태 B가 된다(<span class="math math-inline">f(A, u) = B</span>)“고 가정했다.24 이는 계산을 단순화해주지만, 불확실한 현실 세계와는 맞지 않는다. 바퀴는 미끄러지고(Slip), 센서는 오작동하며, 배터리 전압에 따라 모터 출력은 달라진다.5</p>
<p>이러한 불확실성을 반영하기 위해 확률적 로보틱스(Probabilistic Robotics)나 마르코프 결정 과정(MDP, POMDP)과 같은 방법론이 도입되었다.25 이들은 “행동 u를 했을 때 상태 B가 될 확률은 90%, 상태 C가 될 확률은 10%“와 같이 확률 분포를 고려하여 계획을 수립한다. 그러나 모든 가능한 확률적 결과(Contingency)를 고려하여 최적의 정책(Policy)을 계산하는 것은 결정론적 계획보다 훨씬 더 큰 연산 비용을 요구한다.27</p>
<p>SPA 파이프라인에서 실시간성을 확보하기 위해 연구자들은 종종 불확실성을 무시하고 단순화된 모델을 사용하거나(휴리스틱), 계획의 지평(Horizon)을 짧게 줄이는 타협을 해야 했다. 그러나 이는 장기적인 목표 달성을 어렵게 만들거나, 예상치 못한 상황에서 계획이 붕괴되는 결과를 초래했다. 결국 “완벽한 계획“과 “신속한 행동” 사이의 트레이드오프(Trade-off)는 SPA 구조 내에서 해결하기 어려운 난제로 남았다.29</p>
<h3>4.3  재계획(Replanning)의 부담</h3>
<p>계획된 행동을 실행하다가 오류가 발생하거나 환경이 변하면, 로봇은 가던 길을 멈추고 처음부터 다시 계획을 수립해야 한다(Replanning). SPA 구조에서는 계획 모듈이 매우 무겁기 때문에, 잦은 재계획은 시스템 전체를 마비시킨다.8 문이 닫혀 있어서 이동 계획이 실패했다면, 로봇은 그 자리에서 멈춰 서서 센서 데이터를 다시 모으고, 모델을 업데이트하고, 새로운 경로를 찾는 긴 과정을 반복해야 한다. 이는 동적 환경에서 로봇의 반응성(Reactivity)을 현저히 떨어뜨리는 요인이다.</p>
<h2>5.  순차적 파이프라인의 치명적 결함: 오류 전파(Error Propagation) 메커니즘</h2>
<p>SPA 아키텍처의 가장 심각한 공학적 결함은 각 단계가 순차적으로 연결되어 있어, 앞 단계의 작은 오류가 다음 단계로 전달되며 증폭된다는 점이다. 이를 <strong>오류 전파(Error Propagation)</strong> 또는 <strong>연쇄 실패(Cascading Failure)</strong> 라 한다.5 피드백 루프가 느슨하거나 없는 개방 루프 구조 탓에, 시스템은 스스로 오류를 수정할 기회를 갖지 못하고 파국으로 치닫게 된다.</p>
<h3>5.1  감지 오차의 증폭과 나비 효과</h3>
<p>모든 물리적 센서는 필연적으로 노이즈(Noise)를 포함한다. 예를 들어, 로봇의 바퀴 회전수를 통해 위치를 추정하는 오도메트리(Odometry) 센서가 1%의 오차율을 가진다고 가정하자. 로봇이 1미터를 이동했을 때, 실제 위치와 로봇이 생각하는 위치(모델 상의 위치) 사이에는 1cm의 오차가 발생한다.5</p>
<p>SPA 파이프라인에서 이 1cm의 오차는 단순히 “약간 부정확한 데이터“로 끝나는 것이 아니라, 다음 단계인 계획(Plan) 의 전제 조건을 뒤흔드는 씨앗이 된다.<br />
<span class="math math-display">
z_{sense} = x_{real} + \epsilon_{noise}
</span><br />
여기서 <span class="math math-inline">z_{sense}</span>는 센서값, <span class="math math-inline">x_{real}</span>은 실제 값, <span class="math math-inline">\epsilon_{noise}</span>는 노이즈다. 모델링 단계에서 이 노이즈가 걸러지지 않으면, 계획기는 잘못된 위치 <span class="math math-inline">\hat{x}</span>를 참(Truth)으로 간주하고 경로를 생성한다.</p>
<p>만약 로봇이 좁은 문(폭 80cm, 로봇 폭 70cm)을 통과해야 한다면, 1cm의 위치 오차는 충돌 여부를 결정짓는 치명적인 변수가 된다. 더 심각한 것은 계획 함수가 비선형적(Non-linear)일 경우, 입력의 미세한 오차가 출력(행동 지령)의 거대한 변화를 초래한다는 점이다. 장애물 모서리 좌표의 아주 작은 오차로 인해, 계획기는 장애물의 왼쪽으로 회피하려던 경로를 오른쪽으로 급선회하도록 변경할 수 있으며, 이는 전혀 다른 행동 결과를 낳는다.33</p>
<h3>5.2  모델 불일치(Model Mismatch)와 현실의 괴리</h3>
<p>로드니 브룩스는 “현실과의 괴리“를 지적하며, 내부 모델(Representation)은 아무리 정교해도 현실의 근사치(Approximation)일 뿐이라고 강조했다.15 그러나 SPA의 계획기는 이 근사치를 절대적인 현실로 취급한다. 이를 <strong>모델 불일치(Model Mismatch)</strong> 문제라 한다.21</p>
<p>지도가 실제 환경과 조금이라도 다르면(예: 지도에는 벽이 직선인데 실제로는 약간 휘어 있는 경우), 계획된 경로는 현실에서 실행 불가능하거나 위험할 수 있다. 예를 들어, 로봇 팔이 컵을 잡는 계획을 세울 때, 모델 상의 컵 위치와 실제 위치가 5mm만 어긋나도 로봇은 컵을 잡는 대신 컵을 쳐서 넘어뜨리게 된다. SPA 구조는 실행 중에 이러한 불일치를 감지하고 즉각적으로 보정하는 <strong>폐쇄 루프(Closed-Loop)</strong> 피드백 메커니즘이 부족했기 때문에, 로봇은 컵이 넘어지는 것을 보면서도 미리 계획된 ‘잡기’ 동작을 허공에 계속 수행하는 우스꽝스럽고도 위험한 모습을 보이곤 했다.13</p>
<h3>5.3  행동 단계의 맹목성과 사고의 불가피성</h3>
<p>행동(Act) 단계에서 하위 제어기는 상위 계획기가 내려준 명령을 맹목적으로 수행한다. 고전적 계층 구조(Hierarchical Architecture)에서 행동 모듈은 자신의 판단 권한이 거의 없다.8</p>
<p>“전방으로 5초간 전진하라“는 명령을 받은 제어기는 전방에 갑자기 아이가 뛰어들더라도, 상위 계획기로부터 “멈춰라“는 새로운 명령이 내려오기 전까지는 전진을 멈추지 않는다. 문제는 그 새로운 명령이 생성되기까지(감지 <span class="math math-inline">\to</span> 모델링 <span class="math math-inline">\to</span> 재계획) 너무 오랜 시간이 걸린다는 것이다.17</p>
<p>오류 전파 과정을 요약하면 다음과 같다:</p>
<ol>
<li><strong>Sense:</strong> 센서 노이즈 발생 (<span class="math math-inline">\epsilon_{sense}</span>)</li>
<li><strong>Model:</strong> 노이즈가 포함된 데이터를 기반으로 부정확한 지도 작성 (지도 오차 <span class="math math-inline">\epsilon_{map}</span>)</li>
<li><strong>Plan:</strong> 부정확한 지도를 바탕으로, 현실과 맞지 않는 경로 계획 수립 (계획 오차 <span class="math math-inline">\epsilon_{plan}</span>)</li>
<li><strong>Act:</strong> 잘못된 계획을 실행하며, 액추에이터 자체의 오차까지 더해짐 (실행 오차 <span class="math math-inline">\epsilon_{act}</span>)</li>
<li><strong>Result:</strong> 총 오차 <span class="math math-inline">\sum \epsilon</span>가 임계치를 초과하여 임무 실패 또는 충돌 발생.</li>
</ol>
<p>이러한 연쇄적 오류 증폭 구조는 로봇이 복잡하고 정밀한 작업을 수행하는 것을 가로막는 가장 큰 장벽이었다.</p>
<h2>6.  이론적 족쇄: 닫힌 세계 가설(Closed World Assumption)과 프레임 문제</h2>
<p>SPA 아키텍처가 현실 세계에서 실패한 것은 하드웨어 성능 부족 때문만이 아니라, 그 밑바닥에 깔린 논리적 가정들이 현실 세계의 본질과 모순되었기 때문이다. 그중 가장 대표적인 것이 <strong>닫힌 세계 가설</strong>과 <strong>프레임 문제</strong>이다.</p>
<h3>6.1  닫힌 세계 가설(Closed World Assumption, CWA)의 비현실성</h3>
<p>CWA는 “지식 베이스(Knowledge Base)에 참(True)이라고 명시되지 않은 모든 사실은 거짓(False)이다“라고 가정하는 논리적 규칙이다.36 이는 데이터베이스 관리 시스템이나 닫힌 실험실 환경에서는 효율적인 추론을 가능하게 한다. 예를 들어, 로봇의 지도에 “방 A에는 의자가 있다“는 정보만 있다면, 로봇은 “방 A에는 책상은 없다“고 확신하고 행동할 수 있다.</p>
<p>그러나 로봇이 활동해야 하는 <strong>개방된 세계(Open World)</strong> 에서는 “모르는 것“이 곧 “없는 것“이 아니다.8 지도에 없는 새로운 물체가 언제든지 나타날 수 있고, 문이 열려 있을 수도, 닫혀 있을 수도 있다. SPA 기반 로봇은 자신이 알지 못하는(모델링되지 않은) 장애물을 만나면, 그것의 존재를 부정하고 그대로 충돌하거나, 자신의 세계관이 붕괴되어 아무런 판단도 내리지 못하는 ‘얼어붙음(Freezing)’ 상태에 빠진다.</p>
<p>셰이키 로봇은 사전에 완벽하게 정의된 블록 월드(Block World)에서만 작동할 수 있었다. 만약 연구자가 몰래 블록 하나를 추가하거나 위치를 옮기면, 셰이키는 센서 데이터와 내부 모델의 모순을 해결하지 못하고 작동을 멈췄다.39 CWA는 로봇이 예측 불가능한 상황(Unforeseen Situations)에 유연하게 대처하는 것을 원천적으로 차단하는 족쇄가 되었다.38</p>
<h3>6.2  프레임 문제 (The Frame Problem): 변하지 않는 것을 기술하는 부담</h3>
<p>기호 논리 기반 계획 시스템(STRIPS 등)이 겪는 가장 유명한 난제는 <strong>프레임 문제(The Frame Problem)</strong> 이다.8 이는 어떤 행동을 했을 때 “변하는 것“뿐만 아니라 “변하지 않는 것“들까지 모두 논리적으로 기술해야 하는 부담을 의미한다.</p>
<p>로봇이 “컵을 집어 올린다(PickUp)“는 행동을 계획한다고 하자. 계획기는 이 행동의 결과로 “컵의 위치가 로봇 손으로 바뀜“을 추론한다. 하지만 논리적으로 완벽성을 기하기 위해서는, 이 행동으로 인해 “방의 불이 꺼지지 않음”, “벽의 색깔이 변하지 않음”, “창문의 위치가 바뀌지 않음” 등 무수히 많은 ’변하지 않는 사실(Non-effects)’들을 보장해야 한다. 그렇지 않으면 로봇은 “컵을 집었더니 천장이 무너질 수도 있다“는 불확실성 때문에 행동을 주저하게 된다.</p>
<p>초기 AI 연구자들은 ’프레임 공리(Frame Axioms)’를 추가하여 이를 해결하려 했으나, 환경이 복잡해질수록 기술해야 할 공리의 수가 폭발적으로 증가하여 계산 불가능한 상태에 이르렀다.40 셰이키가 간단한 행동 하나를 하기 위해 수십 분간 멈춰 있었던 주된 이유 중 하나가 바로 이 프레임 문제를 해결하기 위해 불필요한 논리적 검증을 수행했기 때문이다. 인간이나 동물은 본능적으로 행동과 무관한 정보를 무시(Ignore)하지만, 고전적 SPA 로봇은 무엇을 무시해도 좋은지조차 계산해야 했다.</p>
<h2>7.  사례 연구: 셰이키(Shakey)의 유산과 교훈</h2>
<p>SRI 인터내셔널이 1966년부터 1972년까지 개발한 <strong>셰이키(Shakey)</strong> 는 SPA 아키텍처의 정점을 보여주는 동시에, 그 한계를 역사에 각인시킨 기념비적인 로봇이다.41 “최초의 전자 인간(First Electronic Person)“이라 불렸던 셰이키는 카메라, 거리 측정기, 범퍼 센서를 갖추고 무선으로 대형 컴퓨터(PDP-10)와 연결되어 있었다.</p>
<h3>7.1  셰이키의 성공과 실패</h3>
<p>셰이키는 “방 D로 가서 블록 9를 문 4 옆으로 밀어라“와 같은 자연어 명령을 이해하고 수행할 수 있었다. STRIPS 계획기를 통해 복잡한 임무를 하위 동작으로 분해하고 순차적으로 실행하는 능력은 당시로서는 혁명적이었다.42</p>
<p>그러나 셰이키는 이름 그대로 자주 “비틀거렸다(Shakey)”. 조명 조건이 조금만 바뀌어도 비전 시스템은 벽과 바닥의 경계를 찾지 못해 엉뚱한 지도를 그렸고, 바퀴가 헛돌아 위치 추정에 실패하면 벽에 부딪혔다.2 연구진은 환경을 단순화(벽 아래에 검은 띠를 두르는 등)하여 셰이키를 도왔지만, 이는 SPA 아키텍처가 고도로 통제된 환경(Structured Environment)에서만 작동할 수 있음을 자인하는 꼴이었다.</p>
<h3>7.2  역사적 교훈: 표상과 실재의 분리</h3>
<p>셰이키 프로젝트가 남긴 가장 큰 교훈은 “완벽한 내부 모델과 논리적 추론이 지능적 행동을 보장하지 않는다“는 것이다.17 로봇의 지능은 머릿속(모델)이 아니라 세상과의 상호작용 속에 존재해야 했다. 이는 이후 1980년대 후반, 로드니 브룩스의 <strong>포섭 아키텍처(Subsumption Architecture)</strong> 와 행동 기반 로봇 공학(Behavior-Based Robotics)이 등장하는 직접적인 계기가 되었다.15 브룩스는 셰이키와 같은 SPA 로봇을 비판하며 “세계 그 자체가 가장 좋은 모델이며, 가장 최신의 모델이다. 굳이 내부에 모델을 복제하여 유지할 필요가 없다“고 주장했다.</p>
<h2>8.  결론: 순차적 처리의 한계를 넘어</h2>
<p>SPA 아키텍처는 로봇 공학의 여명기에 지능형 로봇의 논리적 청사진을 제시했다는 점에서 그 가치가 있다. 감지, 계획, 행동이라는 기능적 분해는 여전히 유용한 개념적 틀이며, 현대의 많은 로봇 시스템도 여전히 이 구조의 변형을 사용하고 있다.8</p>
<p>그러나 <strong>순차적 파이프라인</strong>이 갖는 태생적 한계—계산 병목으로 인한 실시간성 부재, 오류 전파로 인한 시스템의 취약성, 닫힌 세계 가설로 인한 유연성 부족—은 로봇이 통제된 환경을 벗어나 실제 세계(Real World)로 진출하는 것을 오랫동안 가로막았다. “생각하느라 움직이지 못하는” SPA 로봇의 한계를 극복하기 위해, 로봇 공학은 <strong>반응형(Reactive)</strong> 아키텍처, <strong>하이브리드(Hybrid)</strong> 아키텍처, 그리고 최근의 <strong>End-to-End 학습</strong> 기반 모델로 진화해 왔다.20 특히 최신 비전-언어-행동(VLA) 모델들은 감지에서 행동으로 이어지는 경로를 단일 신경망으로 통합함으로써, 정보 손실과 병목 현상을 해결하고 유연한 일반화 능력을 보여주고 있다.</p>
<p>다음 1.4.3장에서는 이러한 한계를 극복하기 위해 등장한 대안적 패러다임들, 특히 브룩스의 포섭 아키텍처와 현대적 딥러닝 접근법이 어떻게 “생각“과 “행동“의 관계를 재정립했는지 살펴볼 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Robotics/Computer Control/Control Architectures/Sense-Plan-Act - Wikibooks, open books for an open world, https://en.wikibooks.org/wiki/Robotics/Computer_Control/Control_Architectures/Sense-Plan-Act</li>
<li>Shakey - CHM Revolution - Computer History Museum, https://www.computerhistory.org/revolution/artificial-intelligence-robotics/13/289</li>
<li>14 Robot System Architectures, https://web.stanford.edu/class/cs237b/pdfs/lecture/lecture_14.pdf</li>
<li>Agent Architectures in Robotics: A Guide to Autonomous and Intelligent Systems - SmythOS, https://smythos.com/developers/agent-development/agent-architectures-in-robotics/</li>
<li>Symbolic Error Analysis and Robot Planning, - DTIC, https://apps.dtic.mil/sti/tr/pdf/ADA121007.pdf</li>
<li>Cascading Failure Propagation and Perfect Storms in Interdependent Infrastructures | ASCE OPEN: Multidisciplinary Journal of Civil Engineering | Vol 3, No 1, https://ascelibrary.org/doi/10.1061/AOMJAH.AOENG-0045</li>
<li>Sense Plan Act (SPA) - ROBOTC, https://www.robotc.net/files/pdf/vex-natural-language/hp_spa.pdf</li>
<li>(PDF) Sense-Plan-Act in Robotic Applications - ResearchGate, https://www.researchgate.net/publication/349248621_Sense-Plan-Act_in_Robotic_Applications</li>
<li>The Robot Architecture Framework - eLib, <a href="https://elib.dlr.de/214106/1/AF_D%C3%B6mel_Druckversion.pdf">https://elib.dlr.de/214106/1/AF_D%C3%B6mel_Druckversion.pdf</a></li>
<li>STRIPS: A New Approach to the Application of .Theorem Proving to Problem Solving’ - Stanford AI Lab, https://ai.stanford.edu/~nilsson/OnlinePubs-Nils/PublishedPapers/strips.pdf</li>
<li>SHAKEY THE ROBOT - SRI International, https://www.sri.com/wp-content/uploads/2021/12/629.pdf</li>
<li>STRIPS: A New Approach to the Application of Theorem Proving to Problem Solving, https://www.semanticscholar.org/paper/STRIPS%3A-A-New-Approach-to-the-Application-of-to-Fikes-Nilsson/c547e1f79e6039d05c5ae433a36612d7f8e4d3f5</li>
<li>Lessons for Robotics From the Control Architecture of the Octopus - Frontiers, https://www.frontiersin.org/journals/robotics-and-ai/articles/10.3389/frobt.2022.862391/full</li>
<li>The Robotics Breakout Moment | Salesforce Ventures, https://salesforceventures.com/perspectives/the-robotics-breakout-moment/</li>
<li>Oral History of Rodney Brooks - IEEE Xplore, https://ieeexplore.ieee.org/iel7/85/10332940/10333114.pdf</li>
<li>Elephants Don’t Play Chess - People, https://people.csail.mit.edu/brooks/papers/elephants.ps</li>
<li>Reinventing Shakey - Department of Computing, https://www.doc.ic.ac.uk/~mpsha/shakey.pdf</li>
<li>Will embodied AI create robotic coworkers? - McKinsey, https://www.mckinsey.com/industries/industrials/our-insights/will-embodied-ai-create-robotic-coworkers</li>
<li>iWalker: Imperative Visual Planning for Walking Humanoid Robot - arXiv, https://arxiv.org/html/2409.18361v5</li>
<li>ActionFlow: A Pipelined Action Acceleration for Vision Language Models on Edge - arXiv, https://arxiv.org/html/2512.20276v1</li>
<li>Analysis of Model Mismatch Effects for a Model-Based Gas Source Localization Strategy Incorporating Advection Knowledge - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC6387390/</li>
<li>The Parameterized Complexity of Coordinated Motion Planning - DROPS, https://drops.dagstuhl.de/storage/00lipics/lipics-vol258-socg2023/LIPIcs.SoCG.2023.28/LIPIcs.SoCG.2023.28.pdf</li>
<li>Computational Complexity of Motion Planning of a Robot through Simple Gadgets - arXiv, https://arxiv.org/abs/1806.03539</li>
<li>Deterministic Model | FlowHunt, https://www.flowhunt.io/glossary/deterministic-model/</li>
<li>Probabilistic Algorithms in Robotics - Washington, https://courses.cs.washington.edu/courses/cse599j/12sp/papers/ThrunProbRobotics-AIMagazine.pdf</li>
<li>Probabilistic Algorithms in Robotics - CMU School of Computer Science, https://www.cs.cmu.edu/~thrun/papers/thrun.probrob.pdf</li>
<li>Probabilistic Planning for Behavior-Based Robots∗, https://idm-lab.org/bib/abstracts/papers/flairs01.pdf</li>
<li>iCORPP: Interleaved commonsense reasoning and probabilistic planning on robots - UT Austin Computer Science, https://www.cs.utexas.edu/~pstone/Papers/bib2html-links/shiqi_ras2024.pdf</li>
<li>A Comprehensive Survey of Path Planning Algorithms for Autonomous Systems and Mobile Robots: Traditional and Modern Approaches - IEEE Xplore, https://ieeexplore.ieee.org/iel8/6287639/10820123/11195089.pdf</li>
<li>Reinventing Shakey - Association for the Advancement of Artificial Intelligence (AAAI), https://cdn.aaai.org/Symposia/Fall/1998/FS-98-02/FS98-02-017.pdf</li>
<li>Analysis and Evaluation of Fault Propagation Behavior in Integrated Avionics Systems Considering Cascading Failures - MDPI, https://www.mdpi.com/2226-4310/11/8/608</li>
<li>Practical Aspects of Model-Based Collision Detection - Frontiers, https://www.frontiersin.org/journals/robotics-and-ai/articles/10.3389/frobt.2020.571574/full</li>
<li>Symbolic Error Analysis and Robot Planning - DSpace@MIT, https://dspace.mit.edu/handle/1721.1/5658</li>
<li>Is there a future for AI without representation? - arXiv, https://arxiv.org/pdf/2503.18955</li>
<li>Robot Model Identification and Learning: A Modern Perspective, https://par.nsf.gov/servlets/purl/10530091</li>
<li>Robot Task Planning and Situation Handling in Open Worlds - arXiv, https://arxiv.org/html/2210.01287v2</li>
<li>Closed-world assumption - Wikipedia, https://en.wikipedia.org/wiki/Closed-world_assumption</li>
<li>View of Open-World Reasoning for Service Robots - AAAI Publications, https://ojs.aaai.org/index.php/ICAPS/article/view/3541/3409</li>
<li>Explainable and Interpretable Methods for Handling Robot Task Failures - research.chalmers.se, https://research.chalmers.se/publication/545206/file/545206_Fulltext.pdf</li>
<li>STRIPS: A New Approach to the Application of Theorem Proving to Problem Solving - ResearchGate, https://www.researchgate.net/profile/Richard-Fikes/publication/237331771_STRIPS_A_NEW_APPROACH_TO_THE_APPLICATION_OF/links/54107c600cf2d8daaad3d16c/STRIPS-A-NEW-APPROACH-TO-THE-APPLICATION-OF.pdf?origin=scientificContributions</li>
<li>Shakey the Robot - SRI, https://www.sri.com/hoi/shakey-the-robot/</li>
<li>Shakey the robot - Wikipedia, https://en.wikipedia.org/wiki/Shakey_the_robot</li>
<li>75 Years of Innovation: Shakey the Robot - SRI International, https://www.sri.com/press/story/75-years-of-innovation-shakey-the-robot/</li>
<li>Shakey the Robot - Stanford AI Lab, https://ai.stanford.edu/~nilsson/OnlinePubs-Nils/shakey-the-robot.pdf</li>
<li>Lessons for Robotics From the Control Architecture of the Octopus - PMC - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC9339708/</li>
<li>End-to-end Autonomous Driving: Challenges and Frontiers - arXiv, https://arxiv.org/html/2306.16927v3</li>
<li>[PDF] Shakey the Robot | Semantic Scholar, https://www.semanticscholar.org/paper/Shakey-the-Robot-Nilsson/476ba2a1c5204d46e420506afacb4b0da6abb868</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>