<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.3.2 VolSDF와 NeuS: 표면 재구성의 정밀도 향상</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.3.2 VolSDF와 NeuS: 표면 재구성의 정밀도 향상</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 5. 뉴럴 3D 표현과 렌더링 (Neural 3D Representations)</a> / <a href="index.html">5.3 기하학적 정밀함: SDF와 점유 네트워크 (Occupancy Networks)</a> / <span>5.3.2 VolSDF와 NeuS: 표면 재구성의 정밀도 향상</span></nav>
                </div>
            </header>
            <article>
                <h1>5.3.2 VolSDF와 NeuS: 표면 재구성의 정밀도 향상</h1>
<h2>1.  서론: 뉴럴 렌더링의 패러다임 전환과 표면의 재발견</h2>
<h3>1.1  NeRF의 성공과 기하학적 한계</h3>
<p>2020년, 뉴럴 래디언스 필드(Neural Radiance Fields, NeRF)의 등장은 컴퓨터 비전과 그래픽스 커뮤니티에 거대한 충격을 안겨주었다. NeRF는 3D 장면을 다층 퍼셉트론(MLP)이라는 신경망 내에 연속적인 볼륨 밀도(volume density, <span class="math math-inline">\sigma</span>)와 뷰 의존적 색상(color, <span class="math math-inline">\mathbf{c}</span>)으로 인코딩함으로써, 기존의 이산적인 복원 방식(Mesh, Voxel)들이 보여주지 못했던 포토리얼리스틱한 뷰 합성(View Synthesis) 성능을 입증했다.1 그러나 NeRF가 합성한 새로운 시점의 이미지는 시각적으로 완벽해 보일지라도, 그 내부를 지탱하는 3D 기하학(Geometry)은 종종 부정확하거나 노이즈가 심한 상태로 남아 있었다.</p>
<p>NeRF의 볼륨 렌더링 방정식은 본질적으로 “어떻게 하면 입력 이미지의 픽셀 색상과 렌더링된 색상의 차이를 최소화할 것인가?“라는 광도 측정적(photometric) 오차 최소화에 초점을 맞춘다.3 이 과정에서 네트워크는 물체의 표면을 명확한 경계면으로 정의하기보다는, 렌더링 결과값만 맞다면 불투명한 구름(fog)이나 부유물(floater)을 공간에 배치하는 방식으로 ’속임수’를 쓰기도 한다. 그 결과, NeRF 모델에서 등가면(iso-surface) 추출 알고리즘인 마칭 큐브(Marching Cubes)를 적용하여 메쉬를 추출해보면, 실제 물체의 형상과는 거리가 먼 울퉁불퉁하고 거친 표면이 얻어지는 경우가 빈번했다.4</p>
<h3>1.2  묵시적 표면(Implicit Surface)과 부호 거리 함수(SDF)의 부상</h3>
<p>로봇 공학(Robotics), 증강 현실(AR), 물리 시뮬레이션과 같은 응용 분야에서는 단순한 이미지 합성을 넘어, 물체와의 상호작용을 위한 정밀한 3D 형상 정보가 필수적이다.7 예를 들어, 로봇이 물체를 파지(Grasping)하거나 주행 로봇이 환경 지도를 작성(SLAM)할 때는 물체의 정확한 표면 좌표와 법선 벡터(Normal Vector)가 요구된다.8</p>
<p>이러한 요구에 부응하기 위해, 밀도(<span class="math math-inline">\sigma</span>) 대신 **부호 거리 함수(Signed Distance Function, SDF)**를 뉴럴 네트워크의 출력으로 사용하는 연구들이 대두되었다. SDF, 즉 <span class="math math-inline">f(\mathbf{x})</span>는 공간상의 점 <span class="math math-inline">\mathbf{x}</span>에서 가장 가까운 표면까지의 거리를 나타내며, 표면 내부에서는 음수, 외부에서는 양수, 그리고 표면상에서는 정확히 0의 값을 가진다 (<span class="math math-inline">f(\mathbf{x}) = 0</span>). SDF는 수학적으로 정의된 명확한 표면(Zero-level set)을 제공하며, 이는 기하학적 정밀도를 보장하는 강력한 제약 조건으로 작용한다.10</p>
<p>초기의 SDF 기반 뉴럴 렌더링 연구인 IDR(Implicit Differentiable Renderer)은 표면 렌더링(Surface Rendering) 방식을 채택하여 높은 품질의 표면을 복원했으나, 마스크(Mask) 정보가 필요하고 초기화에 민감하다는 단점이 있었다.2 이를 극복하기 위해, SDF의 기하학적 장점과 NeRF의 볼륨 렌더링이 가진 강건함(Robustness)을 결합하려는 시도가 이어졌으며, 그 정점에 있는 두 가지 핵심 알고리즘이 바로 <strong>VolSDF</strong>와 <strong>NeuS</strong>이다.</p>
<p>본 장에서는 VolSDF와 NeuS가 어떻게 SDF를 미분 가능한 볼륨 렌더링 파이프라인에 통합했는지, 그리고 그 과정에서 발생하는 ‘기하학적 편향(Geometric Bias)’ 문제를 어떻게 수학적으로 해결했는지를 심층 분석한다. 나아가 이들 방법론이 로봇 공학 및 정밀 3D 복원 분야에 미친 영향과 최신 발전 동향까지 포괄적으로 다룬다.</p>
<hr />
<h2>2.  이론적 배경: 볼륨 렌더링과 기하학적 편향의 딜레마</h2>
<h3>2.1  볼륨 렌더링 방정식의 재해석</h3>
<p>VolSDF와 NeuS를 이해하기 위해서는 먼저 표준 볼륨 렌더링 방정식을 SDF의 관점에서 재해석해야 한다. 광선 <span class="math math-inline">\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}</span>가 장면을 통과할 때, 픽셀의 색상 <span class="math math-inline">C(\mathbf{r})</span>은 다음과 같이 적분된다.<br />
<span class="math math-display">
C(\mathbf{r}) = \int_{t_n}^{t_f} T(t) \sigma(t) \mathbf{c}(t, \mathbf{d}) dt
</span><br />
여기서 <span class="math math-inline">T(t) = \exp\left(-\int_{t_n}^t \sigma(s) ds\right)</span>는 투과율(Transmittance)로, 광선이 <span class="math math-inline">t</span> 지점까지 가려지지 않고 도달할 확률을 의미한다. <span class="math math-inline">\sigma(t)</span>는 볼륨 밀도, <span class="math math-inline">\mathbf{c}</span>는 색상이다. 이 식을 가중치 함수 <span class="math math-inline">w(t)</span>를 사용하여 다시 쓰면 <span class="math math-inline">C(\mathbf{r}) = \int w(t) \mathbf{c}(t) dt</span>가 되며, 여기서 가중치 <span class="math math-inline">w(t) = T(t)\sigma(t)</span>는 광선이 정확히 거리 <span class="math math-inline">t</span>에서 멈출 확률 밀도 함수(PDF)가 된다.12</p>
<h3>2.2  기하학적 편향(Geometric Bias)의 발생 원인</h3>
<p>이상적인 표면 재구성을 위해서는 가중치 함수 <span class="math math-inline">w(t)</span>가 실제 물체의 표면 위치, 즉 SDF가 <span class="math math-inline">f(\mathbf{x})=0</span>이 되는 지점에서 최대값(Peak)을 가져야 한다. 그래야만 렌더링된 색상이 물체 표면의 색상을 정확히 반영하게 되고, 이를 통해 학습된 기하학(SDF)이 실제 형상과 일치하게 된다.3</p>
<p>그러나 NeRF에서 사용하듯 SDF를 단순히 밀도 함수로 변환(예: <span class="math math-inline">\sigma(x) = \text{ReLU}(-f(x))</span> 또는 단순 시그모이드 변환)하여 렌더링 식에 대입하면 심각한 문제가 발생한다.</p>
<p>밀도가 표면 근처에서 높아지도록 설계하더라도, 투과율 <span class="math math-inline">T(t)</span>는 밀도가 0이 아닌 구간에 진입하자마자 즉시 감소하기 시작한다 (<span class="math math-inline">T(t)</span>는 단조 감소 함수이다). 따라서 <span class="math math-inline">w(t) = T(t)\sigma(t)</span>의 곱을 계산해보면, <span class="math math-inline">\sigma(t)</span>가 최대가 되는 지점(표면)보다 <span class="math math-inline">T(t)</span>가 아직 높은 지점, 즉 **표면보다 약간 앞선 공간(camera-side)**에서 가중치 <span class="math math-inline">w(t)</span>의 피크가 형성된다.</p>
<p>이러한 현상을 <strong>기하학적 편향(Geometric Bias)</strong> 또는 **가시성 편향(Visibility Bias)**이라 부른다.3</p>
<ul>
<li><strong>결과:</strong> 네트워크는 렌더링 오차를 줄이기 위해 표면의 위치를 실제보다 뒤로 미루거나, 표면을 부풀려서(bloated) 편향을 상쇄하려 한다. 이는 결과적으로 뚱뚱한 메쉬, 디테일의 소실, 오목한 부분의 부정확한 복원을 초래한다.</li>
<li><strong>딜레마:</strong> 밀도를 높여 표면을 뚜렷하게 만들수록 <span class="math math-inline">T(t)</span>의 감소가 빨라져 편향이 심해지고, 밀도를 낮추면 표면이 흐릿해져(fuzzy) 정확한 형상을 정의하기 어려워진다.</li>
</ul>
<p>VolSDF와 NeuS는 이 딜레마를 해결하기 위해 각기 다른 수학적 접근법을 제시했다.</p>
<h2>3.  VolSDF: 통계적 밀도 모델링과 오차 제어</h2>
<p>VolSDF(Volume Rendering of Neural Implicit Surfaces)는 기하학적 형상을 **라플라스 분포(Laplace Distribution)**의 누적 분포 함수(CDF)로 모델링함으로써, 밀도와 SDF 간의 관계를 통계적으로 정립했다.10</p>
<h3>3.1  라플라스 분포 기반의 밀도 함수 정의</h3>
<p>VolSDF는 밀도 <span class="math math-inline">\sigma(\mathbf{x})</span>를 SDF 값 <span class="math math-inline">f(\mathbf{x})</span>의 변환으로 정의하되, 물체의 표면이 불투명한 매질로 전이되는 경계임을 착안하여 다음과 같은 수식을 제안했다.<br />
<span class="math math-display">
\sigma(\mathbf{x}) = \alpha \Psi_\beta(-f(\mathbf{x}))
</span></p>
<p><span class="math math-display">
\Psi_\beta(s) = \begin{cases} \frac{1}{2}\exp(\frac{s}{\beta}) &amp; \text{if } s \le 0 \\ 1 - \frac{1}{2}\exp(-\frac{s}{\beta}) &amp; \text{if } s &gt; 0 \end{cases}
</span></p>
<p>여기서 <span class="math math-inline">\Psi_\beta</span>는 평균이 0이고 스케일(scale)이 <span class="math math-inline">\beta</span>인 라플라스 분포의 CDF이다.16 논문의 실제 구현에서는 밀도가 표면 내부에서 일정 수준 이상 유지되어야 하므로, CDF 자체보다는 라플라스 밀도 함수(PDF)의 형태를 변형하여 밀도를 정의하기도 한다. 핵심은 <strong><span class="math math-inline">\beta</span> 파라미터</strong>의 역할이다.</p>
<ul>
<li><strong><span class="math math-inline">\beta</span>의 의미:</strong> <span class="math math-inline">\beta</span>는 표면의 ‘두께’ 혹은 전이 구간의 ’부드러움’을 나타낸다. <span class="math math-inline">\beta</span>가 클수록 밀도는 공간 전체에 넓게 퍼지고, <span class="math math-inline">\beta</span>가 0에 수렴할수록 밀도는 표면(<span class="math math-inline">f(\mathbf{x})=0</span>) 근처에서 급격히 변하는 델타 함수(Delta function)와 같은 거동을 보인다.10</li>
<li><strong>귀납적 편향(Inductive Bias):</strong> VolSDF는 <span class="math math-inline">\beta</span>를 학습 가능한 파라미터로 설정한다. 학습 초기에는 큰 <span class="math math-inline">\beta</span> 값으로 시작하여 전체 공간에 대한 탐색을 용이하게 하고(Global exploration), 학습이 진행됨에 따라 네트워크가 <span class="math math-inline">\beta</span>를 줄여나가며 표면을 날카롭게(Sharpening) 만든다. 이는 “물체는 명확한 경계를 가진 고체이다“라는 사전 지식을 네트워크 최적화 과정에 자연스럽게 주입하는 효과를 낸다.15</li>
</ul>
<h3>3.2  오차 한계(Error Bound)와 적응형 샘플링</h3>
<p>VolSDF의 가장 큰 이론적 기여 중 하나는 볼륨 렌더링 적분 시 발생하는 수치적 오차에 대한 상한(Bound)을 유도하고, 이를 기반으로 <strong>적응형 샘플링(Adaptive Sampling)</strong> 알고리즘을 제안한 것이다.15</p>
<p>일반적인 NeRF는 계층적 샘플링(Hierarchical Sampling)을 위해 별도의 ‘Coarse’ 네트워크를 학습시켜야 했다. 반면 VolSDF는 현재 학습된 SDF 네트워크와 <span class="math math-inline">\beta</span> 값만 있으면, 어떤 구간을 얼마나 촘촘하게 샘플링해야 불투명도 근사 오차가 특정 값 <span class="math math-inline">\epsilon</span> 이하가 될지를 수학적으로 계산할 수 있다.</p>
<ol>
<li><strong>불투명도 근사:</strong> SDF의 Lipschitz 연속성(Lipschitz continuity)을 가정하면, 현재 광선 상의 한 점에서의 SDF 값과 <span class="math math-inline">\beta</span>를 통해 다음 구간 내에서 밀도가 얼마나 급격히 변할지 예측 가능하다.</li>
<li><strong>샘플링 전략:</strong> VolSDF는 이 예측을 바탕으로 표면 근처(<span class="math math-inline">f(\mathbf{x}) \approx 0</span>)에서는 매우 높은 밀도로 샘플링하고, 표면에서 먼 빈 공간(Empty space)은 과감하게 건너뛰거나 드문드문 샘플링한다.</li>
<li><strong>효과:</strong> 이는 별도의 Coarse 네트워크 없이도 효율적이고 정밀한 렌더링을 가능하게 하며, 특히 얇은 구조물이나 복잡한 위상(Topology)을 가진 물체에서 디테일 손실을 방지한다.17</li>
</ol>
<h3>3.3  VolSDF의 한계와 시사점</h3>
<p>VolSDF는 밀도 함수를 통계적으로 우아하게 정의했지만, 앞서 언급한 ‘기하학적 편향’ 문제를 완전히 제거하지는 못했다. <span class="math math-inline">w(t) = T(t)\sigma(t)</span>에서 <span class="math math-inline">T(t)</span>의 영향으로 인해 가중치의 피크는 여전히 미세하게 표면 앞쪽으로 이동한다. <span class="math math-inline">\beta</span>가 작아질수록 이 편향은 줄어들지만, 학습 초기나 <span class="math math-inline">\beta</span>가 충분히 수렴하지 않은 상태에서는 형상이 부풀어 오르는 경향이 있다.6 그럼에도 불구하고 VolSDF는 안정적인 학습 수렴성과 수학적으로 보장된 샘플링 전략 덕분에 로봇 매핑 및 객체 복원 분야에서 강력한 베이스라인으로 자리 잡았다.9</p>
<h2>4.  NeuS: 편향 없는(Unbiased) 렌더링을 위한 혁신</h2>
<p>NeuS(Neural Implicit Surfaces)는 기하학적 편향 문제를 정면으로 돌파하기 위해 제안되었다. NeuS의 핵심 목표는 **“1차 근사(평면 가정) 하에서 가중치 함수 <span class="math math-inline">w(t)</span>의 최대값이 정확히 SDF의 0-레벨 셋에 위치하도록 보장하는 것”**이다.3</p>
<h3>4.1  불투명 밀도(Opaque Density)의 유도</h3>
<p>NeuS 연구진은 기존의 방식(SDF <span class="math math-inline">\to</span> 밀도 <span class="math math-inline">\to</span> 가중치) 대신, 역발상으로 이상적인 가중치 함수 <span class="math math-inline">w(t)</span>의 형태를 먼저 정의하고 이로부터 밀도 함수를 유도하는 방식을 택했다.</p>
<p>이상적인 가중치 함수 <span class="math math-inline">w(t)</span>는 표면 위치에서 최대가 되는 종 모양(Bell-shaped) 함수여야 한다. NeuS는 로지스틱 시그모이드 함수 <span class="math math-inline">\Phi_s(x) = (1+e^{-sx})^{-1}</span>를 활용하여, 가중치 함수를 정규화된 시그모이드 함수의 도함수 형태로 정의하고자 했다.21</p>
<p>이산적인(Discrete) 경우, 두 샘플링 지점 <span class="math math-inline">t_i</span>와 <span class="math math-inline">t_{i+1}</span> 사이의 가중치 <span class="math math-inline">w_i</span>는 해당 구간에서 불투명도가 얼마나 증가했는지를 나타내야 하므로 다음과 같이 설정할 수 있다.<br />
<span class="math math-display">
w(t) \approx \Phi_s(f(t)) - \Phi_s(f(t+\Delta t))
</span><br />
(※ 표면을 통과할 때 SDF 값 <span class="math math-inline">f(t)</span>는 양수에서 음수로 변하므로, <span class="math math-inline">\Phi_s</span> 값은 1에서 0으로 감소한다. 따라서 그 차이는 양수가 되며, 표면 구간에서 가장 큰 값을 가진다.)</p>
<p>하지만 볼륨 렌더링 방정식은 여전히 <span class="math math-inline">w(t) = T(t)\sigma(t)</span> 형식을 따라야 한다. NeuS는 이 두 조건을 일치시키기 위해 새로운 <strong>불투명 밀도(Opaque Density, <span class="math math-inline">\rho</span>)</strong> 개념을 도입하고, 이를 수식적으로 유도해냈다.11<br />
<span class="math math-display">
\sigma(t) = \max \left( \frac{-\frac{d\Phi_s}{dt}(f(t))}{\Phi_s(f(t))}, 0 \right)
</span><br />
여기서 체인 룰(Chain rule)에 의해 <span class="math math-inline">\frac{d\Phi_s}{dt} = \frac{d\Phi_s}{df} \cdot \frac{df}{dt}</span>가 된다. <span class="math math-inline">\frac{df}{dt}</span>는 시선 방향(View direction)과 표면 법선(Normal) 간의 내적인 <span class="math math-inline">-\cos(\theta)</span>에 해당한다. 최종적으로 NeuS의 밀도 수식은 다음과 같이 표현된다.<br />
<span class="math math-display">
\sigma(t) = \max \left( \frac{s \cdot e^{-sf(t)}}{(1+e^{-sf(t)})^2} \cdot |\cos(\theta)| \cdot \frac{1}{\Phi_s(f(t))}, 0 \right)
</span><br />
이 수식은 매우 중요한 의미를 갖는다. 분모에 있는 <span class="math math-inline">\Phi_s(f(t))</span> 항이 볼륨 렌더링 적분 시 발생하는 투과율 <span class="math math-inline">T(t)</span>의 감소 효과를 수학적으로 상쇄(Cancel out)시키는 역할을 한다. 그 결과, 최종 가중치 <span class="math math-inline">w(t)</span>는 SDF 도함수 형태인 <span class="math math-inline">s \cdot e^{-sf(t)} / (1+e^{-sf(t)})^2</span> (즉, 로지스틱 분포의 PDF)를 정확히 따르게 되며, 이 분포의 중심은 <span class="math math-inline">f(t)=0</span>이다.</p>
<h3>4.2  학습 가능한 파라미터 <span class="math math-inline">s</span>와 분산 제어</h3>
<p>NeuS 또한 VolSDF의 <span class="math math-inline">\beta</span>와 유사하게, 시그모이드 함수의 경사를 조절하는 파라미터 <span class="math math-inline">s</span>를 학습한다. <span class="math math-inline">s</span>는 표준편차의 역수(precision)에 해당한다.3</p>
<ul>
<li>학습이 진행됨에 따라 네트워크는 <span class="math math-inline">s</span> 값을 증가시킨다.</li>
<li><span class="math math-inline">s</span>가 커지면 시그모이드 함수 <span class="math math-inline">\Phi_s</span>는 계단 함수(Heaviside step function)에 가까워지고, 유도된 가중치 함수 <span class="math math-inline">w(t)</span>는 델타 함수에 수렴한다.</li>
<li>이는 렌더링 과정에서 표면의 위치를 매우 국소적으로(Locally) 특정하게 하며, 결과적으로 매우 날카롭고 정교한 표면 재구성을 가능하게 한다.</li>
</ul>
<h3>4.3  NeuS의 편향 없음(Unbiasedness)에 대한 논의</h3>
<p>NeuS는 평면(Planar) 표면 가정 하에서 편향이 없음을 증명했다. 그러나 실제 3D 물체는 곡면을 포함하며, 시선 방향이 표면과 거의 평행한(Tangent) 경우나 곡률(Curvature)이 매우 큰 부분에서는 여전히 편향이 발생할 수 있다는 지적이 있다.6</p>
<p>예를 들어24 연구는 시선이 표면을 스치듯이 지나가는 경우 NeuS의 가중치 적분이 여전히 불안정할 수 있음을 보였으며, 이를 보정하기 위해 법선 벡터와 시선 벡터의 각도(angle-weighted)를 고려한 개선된 렌더링 공식을 제안하기도 했다. 또한 4는 NeuS의 색상 손실(Color Loss)이 기하학적 적분을 최적화하는 과정에서 여전히 모호함을 남길 수 있어, 명시적인 포인트 클라우드나 법선 제약(Normal Priors)이 필요함을 역설했다.</p>
<hr />
<h2>5.  심층 비교 분석: VolSDF 대 NeuS</h2>
<p>VolSDF와 NeuS는 모두 SDF 기반 뉴럴 렌더링의 획기적인 발전을 이끌었으나, 그 접근 방식과 특성에는 분명한 차이가 존재한다.</p>
<h3>5.1  성능 및 품질 비교 (Benchmarks)</h3>
<p>DTU 데이터셋이나 BlendedMVS와 같은 표준 벤치마크에서의 성능을 비교해보면 다음과 같은 특징이 관찰된다.25</p>
<table><thead><tr><th><strong>특징 비교</strong></th><th><strong>VolSDF</strong></th><th><strong>NeuS</strong></th></tr></thead><tbody>
<tr><td><strong>밀도 모델링</strong></td><td>라플라스 CDF 기반 (통계적 접근)</td><td>편향 제거를 위한 역유도 (Opaque Density)</td></tr>
<tr><td><strong>표면 품질</strong></td><td>전체적으로 매끄럽고(Smooth) 연결성이 좋음.</td><td>디테일이 살아있고 날카로운(Sharp) 모서리 표현 우수.</td></tr>
<tr><td><strong>재구성 정확도</strong></td><td>Chamfer Distance 기준 매우 우수하나 미세 디테일은 뭉개질 수 있음.</td><td>얇은 구조물이나 복잡한 텍스처 영역에서 더 높은 정밀도 보임.</td></tr>
<tr><td><strong>학습 안정성</strong></td><td>기하학적 귀납 편향(<span class="math math-inline">\beta</span>) 덕분에 초기 수렴이 매우 안정적임.</td><td>초기화에 따라 국소 최적해(Local Minima)에 빠질 위험이 다소 있음.</td></tr>
<tr><td><strong>학습 속도</strong></td><td>오차 한계 기반 적응형 샘플링으로 효율적 계산 가능.</td><td>고품질 복원을 위해 더 많은 샘플링이나 긴 학습 시간이 요구되기도 함.</td></tr>
</tbody></table>
<p><strong>Chamfer Distance (CD) 비교:</strong> 25 및 26의 표에 따르면, DTU 데이터셋에서 NeuS는 평균 CD 0.87~0.5 수준을 기록하며, VolSDF 또한 0.4~0.8 수준으로 경쟁력 있는 성능을 보인다. (수치는 데이터셋 설정 및 전처리에 따라 상이할 수 있음). 일반적으로 VolSDF는 노이즈가 많은 데이터나 마스크가 없는 상황에서 더 강건한(Robust) 모습을 보이고, NeuS는 텍스처가 풍부하고 조명 조건이 잘 통제된 환경에서 더 정밀한 디테일을 복원한다.</p>
<h3>5.2  구현상의 차이와 엔지니어링</h3>
<ul>
<li><strong>VolSDF</strong>는 샘플링 알고리즘 자체가 핵심이다. SDF 값을 지속적으로 모니터링하며 빈 공간을 건너뛰는 알고리즘은 렌더링 속도를 높이는 데 기여한다.15</li>
<li><strong>NeuS</strong>는 밀도 수식의 분모에 <span class="math math-inline">\Phi_s(f(t))</span>가 들어가기 때문에 수치적 안정성(Numerical Stability)을 위해 0으로 나누는 것을 방지하는 클리핑(Clipping)이나 작은 상수(<span class="math math-inline">\epsilon</span>) 추가가 필수적이다.14</li>
</ul>
<h2>6.  한계를 넘어서: 최신 변형 모델 및 확장 연구</h2>
<p>VolSDF와 NeuS의 기본 아이디어를 바탕으로, 더 높은 정밀도와 속도, 그리고 일반화 성능을 달성하기 위한 후속 연구들이 폭발적으로 등장했다. 본 절에서는 15,000 단어 리포트의 깊이를 더하기 위해 주요 확장 모델들을 상세히 다룬다.</p>
<h3>6.1  Geo-NeuS: 기하학적 일관성의 명시적 주입</h3>
<p>NeuS는 색상 손실(Color Loss)만으로 기하학을 학습하므로, 텍스처가 없는 영역(Texture-less region)이나 반복적인 패턴이 있는 곳에서는 SDF가 정확히 수렴하지 못하는 문제가 있었다.</p>
<p>Geo-NeuS 28는 이러한 문제를 해결하기 위해 SFM(Structure from Motion)이나 MVS(Multi-View Stereo) 알고리즘으로 얻은 **희소한 3D 포인트 클라우드(Sparse 3D Point Cloud)**를 명시적인 제약 조건(Explicit Constraint)으로 활용한다.</p>
<ul>
<li><strong>SDF Loss:</strong> 희소 포인트들이 위치한 곳에서 SDF 값이 0이 되도록 강제한다.</li>
<li><strong>Photometric Consistency:</strong> 인접한 뷰 간의 특징점 매칭을 통해 기하학적 일관성을 추가로 검증한다.</li>
<li><strong>효과:</strong> Geo-NeuS는 NeuS가 실패하기 쉬운 흰 벽이나 반사가 심한 표면에서도 매우 안정적이고 정밀한 표면을 복원해냈다. 이는 “Implicit 표현만으로는 부족하며, Explicit 정보의 가이드가 필요하다“는 중요한 교훈을 준다.4</li>
</ul>
<h3>6.2  NeuS2와 Fast Optimization: 속도의 혁신</h3>
<p>VolSDF와 NeuS의 치명적인 단점은 학습 속도였다. 하나의 장면을 학습하는 데 수 시간에서 십수 시간이 소요되기도 했다. 이를 해결하기 위해 <strong>NeuS2</strong> 18와 같은 연구들은 NVIDIA의 <strong>Instant-NGP (Multi-resolution Hash Encoding)</strong> 기술을 SDF 모델링에 도입했다.</p>
<ul>
<li><strong>해시 인코딩:</strong> 공간을 해시 테이블에 매핑하여 학습 가능한 파라미터를 저장함으로써, MLP의 크기를 줄이면서도 고주파 디테일을 표현할 수 있게 되었다.</li>
<li><strong>가속화:</strong> NeuS2는 기존 NeuS 대비 100배 이상 빠른 학습 속도를 달성하면서도 유사하거나 더 나은 품질을 보여주었다. 또한 CUDA 커널 레벨의 최적화를 통해 렌더링 과정을 병렬화했다.30</li>
</ul>
<h3>6.3  NeuralWarp와 Ref-NeuS: 디테일과 반사 재질의 정복</h3>
<ul>
<li><strong>NeuralWarp</strong> 6는 볼륨 렌더링뿐만 아니라 소스 이미지의 패치를 렌더링된 기하학을 통해 타겟 뷰로 워핑(Warping)했을 때의 일관성을 최적화한다. 이는 픽셀 단위의 정밀도를 넘어 서브 픽셀 수준의 매칭을 유도하여 극도로 세밀한 표면을 복원한다.</li>
<li><strong>Ref-NeuS</strong> 32 등은 Lambertian 반사 가정(모든 방향에서 색이 같음)을 깨고, 거칠기(Roughness)와 정반사(Specular) 성분을 분리하여 모델링함으로써 금속이나 유리와 같은 난반사 재질의 표면 왜곡을 줄이는 데 성공했다.</li>
</ul>
<h2>7.  로봇 공학 및 산업 응용: 시뮬레이션에서 현실로</h2>
<p>VolSDF와 NeuS가 제공하는 ‘방수(Watertight)’ 메쉬와 정밀한 SDF 필드는 로봇 공학 분야에서 게임 체인저가 되고 있다.</p>
<h3>7.1  로봇 파지(Robotic Grasping)와 조작(Manipulation)</h3>
<p>로봇이 미지의 물체를 잡기 위해서는 물체의 형상뿐만 아니라, 보이지 않는 뒷면의 형상까지 추론해야 한다.</p>
<ul>
<li><strong>형상 완성(Shape Completion):</strong> NeuS 기반 모델은 학습된 기하학적 사전 지식(Prior)을 통해 부분적으로 관측된(Partially observed) 물체의 전체 형상을 합리적으로 채워 넣을 수 있다.7</li>
<li><strong>충돌 감지(Collision Detection):</strong> SDF는 점과 표면 사이의 거리를 즉시 계산할 수 있으므로, 로봇 팔의 경로 계획(Motion Planning) 알고리즘에서 실시간 충돌 감지에 매우 효율적이다. 로봇은 SDF 값이 양수인 공간(안전 영역)만을 따라 이동 경로를 생성할 수 있다.34</li>
<li><strong>Grasp Quality:</strong> 표면의 법선 벡터(Normal)와 곡률 정보를 SDF에서 해석적으로(Analytically) 미분하여 얻을 수 있으므로, 그리퍼(Gripper)의 접촉 안정성을 수학적으로 계산하기 용이하다.8</li>
</ul>
<h3>7.2  뉴럴 SLAM (Simultaneous Localization and Mapping)</h3>
<p>전통적인 SLAM은 희소한 포인트 클라우드 맵을 생성하는 데 그쳤으나, VolSDF/NeuS를 백엔드(Back-end)로 사용하는 <strong>Neural SLAM</strong> 시스템들은 밀도 높은(Dense) 표면 맵을 실시간으로 생성한다.9</p>
<ul>
<li><strong>메모리 효율:</strong> 복잡한 대형 환경을 수 기가바이트의 포인트 데이터 대신, 수 메가바이트의 신경망 가중치로 압축하여 저장할 수 있다.</li>
<li><strong>Loop Closure:</strong> 기하학적 정밀도가 높기 때문에, 로봇이 이전에 방문한 장소로 돌아왔을 때 지도의 오차를 수정하는 루프 클로징(Loop Closure) 성능이 향상된다.9</li>
<li><strong>실시간 도전:</strong> 25에서 지적하듯, NeuS의 느린 학습 속도는 실시간 SLAM 적용의 걸림돌이었으나, 최근의 FINS 39나 3D Gaussian Splatting과의 결합 연구들이 이를 빠르게 극복하고 있다.</li>
</ul>
<h2>8.  결론</h2>
<p>5.3.2장에서는 뉴럴 렌더링 기술이 단순한 이미지 합성을 넘어 물리적으로 유의미한 3D 표면을 복원하는 단계로 진화했음을 확인했다. <strong>VolSDF</strong>는 라플라스 분포를 이용한 통계적 접근과 오차 제어 샘플링을 통해 안정적인 형상 학습의 기틀을 마련했고, <strong>NeuS</strong>는 볼륨 렌더링의 내재적 편향을 수학적으로 규명하고 ’불투명 밀도’라는 독창적인 해법을 통해 마스크 없이도 고정밀 표면을 추출하는 혁신을 이루었다.</p>
<p>이 두 알고리즘은 상호 경쟁적이라기보다는 보완적인 관계에 있으며, 후속 연구들을 통해 서로의 장점이 결합되고 있다. 이제 연구의 최전선은 정적 객체의 복원을 넘어, 동적 장면(Dynamic Scenes), 대규모 도시 환경, 그리고 로봇과의 실시간 상호작용이 가능한 수준의 초고속, 초정밀 뉴럴 서피스(Neural Surface) 기술로 확장되고 있다. VolSDF와 NeuS가 닦아놓은 이론적 토대는 미래의 AI 기반 3D 비전 시스템, 디지털 트윈, 그리고 자율 로봇의 인지 능력을 지탱하는 핵심 기둥이 될 것이다.</p>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>