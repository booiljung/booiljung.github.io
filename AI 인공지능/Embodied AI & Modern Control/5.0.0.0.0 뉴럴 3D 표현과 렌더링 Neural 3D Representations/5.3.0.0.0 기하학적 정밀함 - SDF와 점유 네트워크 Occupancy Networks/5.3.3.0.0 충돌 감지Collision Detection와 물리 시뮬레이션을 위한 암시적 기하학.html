<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.3.3 충돌 감지(Collision Detection)와 물리 시뮬레이션을 위한 암시적 기하학</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.3.3 충돌 감지(Collision Detection)와 물리 시뮬레이션을 위한 암시적 기하학</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 5. 뉴럴 3D 표현과 렌더링 (Neural 3D Representations)</a> / <a href="index.html">5.3 기하학적 정밀함: SDF와 점유 네트워크 (Occupancy Networks)</a> / <span>5.3.3 충돌 감지(Collision Detection)와 물리 시뮬레이션을 위한 암시적 기하학</span></nav>
                </div>
            </header>
            <article>
                <h1>5.3.3 충돌 감지(Collision Detection)와 물리 시뮬레이션을 위한 암시적 기하학</h1>
<h1>5.3.3 충돌 감지(Collision Detection)와 물리 시뮬레이션을 위한 암시적 기하학</h1>
<h2>1.  서론: 기하학적 표현의 패러다임 전환과 물리적 필연성</h2>
<p>현대 컴퓨터 그래픽스와 로보틱스 시뮬레이션의 역사는 물리적 실재(Physical Reality)를 디지털 공간에 어떻게 효율적이고 정밀하게 투영할 것인가에 대한 투쟁의 기록과도 같다. 오랫동안 이 분야를 지배해 온 패러다임은 명시적(Explicit) 기하학, 그중에서도 폴리곤 메쉬(Polygon Mesh)였다. 정점(Vertex), 엣지(Edge), 페이스(Face)의 위상적 연결로 정의되는 메쉬는 래스터라이제이션(Rasterization) 기반의 렌더링 파이프라인에 최적화되어 있으며, 현대 GPU 하드웨어 가속의 혜택을 직접적으로 누릴 수 있다는 명확한 장점을 가진다. 그러나 시뮬레이션의 목적이 단순한 시각화를 넘어, 객체 간의 역동적인 상호작용, 즉 충돌(Collision), 접촉(Contact), 마찰(Friction), 그리고 변형(Deformation)을 다루는 물리적 영역으로 확장됨에 따라 명시적 표현의 근본적인 한계가 드러나기 시작했다.</p>
<p>가장 결정적인 난관은 위상(Topology)의 불연속성과 충돌 감지 연산의 계산 복잡도에서 발생한다. 고해상도 메쉬 간의 충돌을 정밀하게 감지하는 것은 나이브(Naive)한 접근 방식으로는 <span class="math math-inline">O(N^2)</span>의 계산 복잡도를 가지며, Bounding Volume Hierarchy(BVH)나 Octree와 같은 공간 분할 가속 구조를 도입하더라도 최악의 경우 <span class="math math-inline">O(N \log N)</span> 수준의 연산 비용이 요구된다.1 더욱이, 메쉬 기반 충돌 감지는 표면(Surface) 정보만을 이산적으로 가지고 있기 때문에, 물체가 서로 뚫고 들어갔을 때(Interpenetration) 그 깊이(Penetration Depth)와 탈출 방향(Contact Normal)을 계산하기 위해 복잡하고 수치적으로 불안정한 기하학적 연산을 수행해야 한다. 이는 시뮬레이션의 안정성을 해치고, 특히 딥러닝과 결합된 ‘미분 가능한 물리학(Differentiable Physics)’ 시스템에서 불연속적인 구배(Gradient)를 생성하여 학습을 저해하는 요인이 된다.</p>
<p>이러한 기술적 배경에서 부호화 거리 함수(Signed Distance Function, SDF)로 대표되는 암시적(Implicit) 기하학 표현이 차세대 물리 시뮬레이션의 핵심 엔진으로 급부상하고 있다. 암시적 표현은 공간상의 임의의 점 <span class="math math-inline">\mathbf{x}</span>에 대해 표면까지의 거리와 내/외부 여부를 함수값 <span class="math math-inline">\phi(\mathbf{x})</span>로 즉시 반환할 수 있다. 이는 복잡한 기하학적 형상이라도 충돌 감지 쿼리를 상수 시간 <span class="math math-inline">O(1)</span> 복잡도로 처리할 수 있는 잠재력을 가지며 2, 미분 가능성(Differentiability)을 수학적으로 내재하고 있어 신경망 기반의 학습과 물리 법칙을 결합하는 데 결정적인 이점을 제공한다.</p>
<p>본 장에서는 암시적 기하학이 어떻게 기존 명시적 표현의 난제를 해결하고, 나아가 iSDF와 같은 실시간 로봇 인식 시스템부터 SDF-Sim, PhyRecon과 같은 최신 미분 가능한 시뮬레이터의 아키텍처를 가능하게 하는지 심층적으로 분석한다. 우리는 단순한 알고리즘의 나열을 넘어, 기하학적 표현 방식의 변화가 어떻게 물리 엔진의 수치적 안정성을 높이고, 로봇의 경로 계획 효율성을 혁신하며, 궁극적으로 시뮬레이션과 현실의 간극(Sim-to-Real Gap)을 줄이는지 그 인과관계를 철저히 규명할 것이다.</p>
<h2>2.  암시적 기하학의 수학적 기초와 물리적 함의</h2>
<p>물리 시뮬레이션에서 암시적 기하학을 효과적으로 활용하기 위해서는 SDF의 수학적 정의뿐만 아니라, 그 미분 기하학적 성질이 물리적 상호작용인 접촉력, 반발력, 마찰력과 어떻게 직결되는지 이해해야 한다. SDF는 단순한 거리 정보 이상의 물리적 포텐셜 필드(Potential Field)로서 기능하기 때문이다.</p>
<h3>2.1  부호화 거리 함수(SDF)의 정의 및 아이코날 성질</h3>
<p>부호화 거리 함수 <span class="math math-inline">\phi: \mathbb{R}^3 \rightarrow \mathbb{R}</span>는 3차원 유클리드 공간상의 점 <span class="math math-inline">\mathbf{x}</span>를 입력받아 스칼라 값을 반환하는 함수로, 수학적으로 다음과 같이 엄밀하게 정의된다.2<br />
<span class="math math-display">
\phi(\mathbf{x}) = \begin{cases}  -d(\mathbf{x}, S) &amp; \text{if } \mathbf{x} \in \Omega_{int} \\ 0 &amp; \text{if } \mathbf{x} \in \partial \Omega \\ +d(\mathbf{x}, S) &amp; \text{if } \mathbf{x} \in \Omega_{ext} \end{cases}
</span><br />
여기서 <span class="math math-inline">d(\mathbf{x}, S) = \min_{\mathbf{y} \in S} |\mathbf{x} - \mathbf{y}|</span>는 점 <span class="math math-inline">\mathbf{x}</span>에서 표면 <span class="math math-inline">S(\partial \Omega)</span>까지의 최단 유클리드 거리이다. 내부를 음수, 외부를 양수로 정의하는 것이 일반적이나, 응용 분야에 따라 부호 규약은 반대가 되기도 한다.</p>
<p>물리 시뮬레이션 관점에서 SDF가 갖는 가장 강력한 성질은 **아이코날 방정식(Eikonal Equation)**을 만족한다는 점이다.<br />
<span class="math math-display">
|\nabla \phi(\mathbf{x})| = 1 \quad \text{almost everywhere}
</span><br />
이 수식은 단순해 보이지만 시뮬레이션 알고리즘 설계에 있어 심대한 함의를 갖는다.</p>
<p>첫째, 접촉 법선(Contact Normal)의 즉각적 도출이 가능하다. 표면 근처의 임의의 점 <span class="math math-inline">\mathbf{x}</span>에서 SDF의 구배(Gradient) <span class="math math-inline">\nabla \phi(\mathbf{x})</span>는 표면에서 가장 가까운 점(Closest Point)을 향하는 방향(혹은 그 반대 방향)과 정확히 일치하며, 그 크기는 항상 1로 정규화되어 있다. 따라서, 충돌이 감지되었을 때 물체를 밀어내야 할 방향 <span class="math math-inline">\mathbf{n}</span>은 별도의 복잡한 기하학적 연산(예: 메쉬의 인접 페이스 법선 평균화 등) 없이 <span class="math math-inline">\nabla \phi(\mathbf{x})</span>를 계산하는 것만으로 즉시 얻어진다.4</p>
<p>둘째, **립시츠 연속성(Lipschitz Continuity)**을 보장한다. 함수값의 변화율이 공간상에서 1로 제한되므로, 급격한 값의 변화가 없어 수치 최적화 과정에서 기울기 폭주(Gradient Exploding) 문제를 방지한다. 이는 경사 하강법(Gradient Descent)이나 뉴턴 방법(Newton’s Method)을 사용하는 충돌 해결 알고리즘에서 매우 중요한 안정성을 제공한다.3</p>
<h3>2.2  신경망 암시적 표현(Neural Implicit Representations)으로의 확장</h3>
<p>전통적으로 SDF는 구(Sphere), 박스(Box), 캡슐(Capsule)과 같은 기본 도형(Primitives)에 대한 해석적(Analytic) 수식으로 표현되거나, 복잡한 형상을 표현하기 위해 공간을 이산화한 복셀 그리드(Voxel Grid)에 거리 값을 저장하는 방식을 취했다. 그러나 해석적 방식은 표현력에 한계가 있고, 복셀 방식은 해상도가 증가함에 따라 메모리 사용량이 3제곱으로 증가하는 ‘차원의 저주’ 문제를 안고 있다.</p>
<p>최근의 연구는 이러한 한계를 극복하기 위해 <strong>신경망 암시적 표현(Neural Implicit Representation)</strong>, 또는 <strong>Neural SDF</strong>를 도입하고 있다. 이는 좌표 <span class="math math-inline">\mathbf{x}</span>를 입력으로 받아 SDF 값 <span class="math math-inline">\hat{s}</span>을 출력하는 다층 퍼셉트론(MLP) <span class="math math-inline">f_\theta(\mathbf{x})</span>를 학습시키는 방식이다.5</p>
<ul>
<li><strong>메모리 효율성과 무한한 해상도:</strong> Neural SDF는 형상의 복잡도와 관계없이 네트워크 가중치 <span class="math math-inline">\theta</span>만을 저장하므로 메모리 효율적이며, 연속적인 함수로 정의되므로 이론상 무한한 해상도를 제공한다.</li>
<li><strong>미분 가능성:</strong> 신경망은 본질적으로 미분 가능한 연산(행렬 곱, 활성화 함수)의 합성함수이므로, 자동 미분(Automatic Differentiation) 라이브러리를 통해 입력 좌표에 대한 출력의 구배 <span class="math math-inline">\nabla_\mathbf{x} f_\theta</span>를 손쉽게 구할 수 있다. 이는 물리 엔진이 접촉력을 계산할 때 필수적인 법선 벡터를 제공한다.</li>
<li><strong>하이브리드 표현:</strong> 순수 MLP의 추론 속도 문제를 해결하기 위해, Instant-NGP나 Neural 3D Gaussian Fields와 같이 공간을 해시 그리드(Hash Grid)나 가우시안으로 나누고, 각 영역의 특징 벡터(Feature Vector)를 보간하여 작은 MLP에 통과시키는 하이브리드 방식이 주류로 자리 잡고 있다. 이는 실시간 충돌 감지에 필요한 고속 쿼리를 가능하게 한다.7</li>
</ul>
<h2>3.  SDF 기반 충돌 감지(Collision Detection) 알고리즘의 심층 분석</h2>
<p>충돌 감지는 물리 엔진의 계산 비용 중 가장 큰 비중을 차지하며, 시뮬레이션의 정확도를 결정짓는 병목 구간이다. 암시적 기하학을 활용한 충돌 감지는 대상을 점(Point)으로 보느냐, 메쉬(Mesh)로 보느냐, 아니면 또 다른 SDF로 보느냐에 따라 접근 방식과 수학적 정식화가 달라진다.</p>
<h3>3.1  점-SDF (Point-SDF) 상호작용: 입자 기반 시뮬레이션의 기초</h3>
<p>가장 기본적인 형태는 유체 시뮬레이션의 입자나, 점군(Point Cloud)으로 근사된 물체가 SDF로 표현된 환경과 충돌하는 경우이다. 이 방식은 계산적으로 가장 효율적이며 <span class="math math-inline">O(1)</span> 복잡도를 자랑한다.2</p>
<ul>
<li><strong>알고리즘적 흐름:</strong> 입자 <span class="math math-inline">p</span>의 위치 <span class="math math-inline">\mathbf{x}_p</span>에 대해 <span class="math math-inline">\phi(\mathbf{x}_p)</span>를 계산한다. 만약 <span class="math math-inline">\phi(\mathbf{x}_p) &lt; 0</span>라면 충돌이 발생한 것이다.</li>
<li><strong>물리적 응답(Response):</strong> 이때 침투 깊이 <span class="math math-inline">\delta = -\phi(\mathbf{x}_p)</span>와 접촉 법선 <span class="math math-inline">\mathbf{n} = \nabla \phi(\mathbf{x}*p)</span>는 즉시 가용한 정보가 된다. 이를 이용해 페널티 힘(Penalty Force) <span class="math math-inline">\mathbf{f} = k_s \cdot \delta \cdot \mathbf{n} - k_d \cdot (\mathbf{v} \cdot \mathbf{n}) \cdot \mathbf{n}</span>을 가하거나, 위치 투영(Position Projection)을 통해 입자를 표면 밖 <span class="math math-inline">\mathbf{x}*{new} = \mathbf{x}_p + \delta \cdot \mathbf{n}</span>으로 즉시 이동시킨다.8</li>
<li><strong>한계점:</strong> 물체를 단순한 점들의 집합으로 근사할 경우, 점 사이의 공간이 뚫리는 현상이 발생할 수 있다. 특히 얇은 물체 간의 충돌에서 점들이 표면을 통과해버리는 ‘터널링(Tunneling)’ 현상이 발생하기 쉽다. 이를 방지하기 위해서는 입자의 밀도를 높이거나, 입자 간의 연결성(Connectivity)을 고려하는 추가적인 제약 조건이 필요하다.</li>
</ul>
<h3>3.2  메쉬-SDF (Mesh-SDF) 충돌 감지: 지역적 최적화를 통한 정밀도 향상</h3>
<p>실제 엔지니어링 시뮬레이션이나 고품질 그래픽스에서는 강체나 천(Cloth) 시뮬레이션과 같이 삼각형 메쉬로 표현된 물체와 SDF로 표현된 환경 간의 정밀한 충돌 처리가 필수적이다. NVIDIA의 연구진인 Macklin 등(2020)은 이를 위해 <strong>지역적 최적화(Local Optimization)</strong> 기법을 제안하며 메쉬-SDF 충돌의 새로운 기준을 정립했다.4</p>
<p>기존의 방식이 메쉬의 정점(Vertex)만을 샘플링하여 SDF와 테스트했다면, 이 기법은 메쉬의 삼각형 페이스(Face)나 엣지(Edge) 전체 영역에서 가장 깊이 침투한 지점을 찾는 문제로 접근한다. 이는 다음과 같은 제약 최적화(Constrained Optimization) 문제로 정식화된다.<br />
<span class="math math-display">
\mathbf{u}^* = \operatorname*{argmin}_{\mathbf{u} \in \Omega} \phi(\mathbf{x}(\mathbf{u}))
</span><br />
여기서 <span class="math math-inline">\Omega</span>는 삼각형 페이스의 경우 질량 중심 좌표계(Barycentric Coordinates)로 표현된 영역 <span class="math math-inline">{ (u, v, w) | u+v+w=1, u,v,w \ge 0 }</span>이며, 엣지의 경우 선분 파라미터 $t \in $이다.</p>
<ul>
<li><strong>수치 해석적 접근:</strong> 이 문제는 일반적인 SDF에 대해 비볼록(Non-convex) 최적화 문제이다. 그러나 SDF의 부드러운 구배 성질 덕분에 ‘Frank-Wolfe’ 알고리즘이나 ’Projected Gradient Descent’를 사용하여 매우 적은 횟수의 반복(Iteration)만으로도 수렴시킬 수 있다.4</li>
<li><strong>엣지-엣지(Edge-Edge) 접촉의 해결:</strong> 정점 샘플링만으로는 감지할 수 없는, 두 물체의 모서리가 십자로 교차하는 엣지 대 엣지 충돌이나, 날카로운 모서리(Sharp Feature)와의 충돌을 이 방식은 자연스럽게 찾아낸다. 실험 결과에 따르면, 이 기법은 얇은 천이 SDF로 표현된 복잡한 물체 위를 미끄러질 때 발생하는 미세한 뚫림 현상을 획기적으로 줄여주며, 충돌 감지의 강건성(Robustness)을 크게 향상시켰다.4</li>
</ul>
<h3>3.3  SDF-SDF 충돌 감지: 두 암시적 필드의 상호작용</h3>
<p>두 물체가 모두 SDF로 표현된 경우(예: 두 개의 Neural SDF 캐릭터 간의 충돌, 혹은 SDF 로봇 팔과 SDF 환경 간의 충돌), 충돌 지점을 찾는 것은 두 스칼라 필드의 0-레벨 셋이 교차하는 지점을 탐색하는 문제로 귀결된다. 이는 해석적인 해를 구하기 어렵기 때문에 수치적인 접근이 필요하다.</p>
<ul>
<li><strong>구배 유도 탐색(Gradient-Guided Search):</strong> Liu 등(2023)이 제안한 방식은 SDF의 구배 정보를 활용하여 교차점을 능동적으로 탐색한다. 두 SDF <span class="math math-inline">\phi_A</span>와 <span class="math math-inline">\phi_B</span>가 있을 때, 충돌 영역은 <span class="math math-inline">\phi_A(\mathbf{x}) &lt; 0 \land \phi_B(\mathbf{x}) &lt; 0</span>인 교집합 영역이다. 탐색 점(Probe Point)을 초기화한 후, 두 SDF의 구배를 결합한 방향으로 점을 이동시켜 교차면(Intersection Manifold)으로 수렴시킨다.2</li>
<li><strong>구간 연산(Interval Arithmetic)과 옥트리:</strong> 해석적(Analytic) SDF의 경우, 구간 연산을 통해 특정 공간 영역 내에서 SDF 값의 범위 <span class="math math-inline">[min, max]</span>를 계산할 수 있다. 만약 두 SDF의 구간이 모두 양수라면 해당 영역은 충돌이 발생할 수 없으므로 즉시 배제(Culling)한다. 이 방식은 옥트리(Octree)와 결합되어 빈 공간을 빠르게 건너뛰고 충돌이 의심되는 영역에만 연산을 집중하게 함으로써 실시간 성능을 보장한다.2</li>
<li><strong>SDF 분해(Decomposition):</strong> 복잡한 비볼록(Non-convex) 형상의 SDF를 여러 개의 볼록한(Convex) 하위 SDF나 바운딩 볼륨으로 분해하여 계층적으로 처리하는 방식이다. 먼저 바운딩 볼륨 간의 대략적인 충돌 검사(Broad Phase)를 수행한 후, 충돌이 감지된 부분에 대해서만 원래의 정밀한 SDF를 사용하는 정밀 검사(Narrow Phase)를 수행한다. 이는 지역적 최적해(Local Minima)에 빠지는 것을 방지하고 전체적인 연산 속도를 높이는 데 기여한다.2</li>
</ul>
<h3>3.4  명시적 방식과 암시적 방식의 비교 분석</h3>
<p>다음 표는 명시적 메쉬 기반 방식과 암시적 SDF 기반 방식의 성능 및 특성을 비교 요약한 것이다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>명시적 메쉬 (Explicit Mesh)</strong></th><th><strong>암시적 SDF (Implicit SDF)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>기본 연산</strong></td><td>Ray-Triangle Intersection, Triangle-Triangle Test</td><td>Point Query, Gradient Query</td><td>SDF는 해상도와 무관한 일관된 쿼리 비용 제공</td></tr>
<tr><td><strong>시간 복잡도</strong></td><td><span class="math math-inline">O(N^2)</span> 또는 <span class="math math-inline">O(N \log N)</span> (with BVH)</td><td><span class="math math-inline">O(1)</span> (Point Query), <span class="math math-inline">O(K)</span> (Optimization)</td><td><span class="math math-inline">N</span>: 정점 수, <span class="math math-inline">K</span>: 최적화 스텝 수 2</td></tr>
<tr><td><strong>메모리</strong></td><td>정점 수에 비례 (높음)</td><td>해상도/파라미터 수에 비례 (최적화 가능)</td><td>Neural SDF는 높은 압축률 제공 6</td></tr>
<tr><td><strong>물리적 정보</strong></td><td>표면 위치만 제공 (법선 계산 복잡)</td><td>침투 깊이, 법선, 구배 정보 즉시 제공</td><td>SDF는 물리적 반발력 계산에 최적화됨 4</td></tr>
<tr><td><strong>미분 가능성</strong></td><td>불연속적 (Discontinuous)</td><td>연속적 미분 가능 (Differentiable)</td><td>학습 기반 시뮬레이터에 필수적 특성 9</td></tr>
<tr><td><strong>위상 변화</strong></td><td>처리 어려움 (Remeshing 필요)</td><td>자연스럽게 처리 (Topology change friendly)</td><td>파괴, 융합 시뮬레이션에 유리</td></tr>
</tbody></table>
<h2>4.  미분 가능한 물리 시뮬레이션(Differentiable Physics Simulation)의 아키텍처</h2>
<p>암시적 기하학의 진정한 가치는 단순한 충돌 감지를 넘어, 시뮬레이션 전체 파이프라인을 미분 가능하게(End-to-End Differentiable) 만드는 데 있다. 이는 시뮬레이션의 최종 결과(예: 로봇의 위치, 물체의 변형)로부터 입력 파라미터(예: 제어 신호, 물성치, 초기 조건)에 대한 기울기(Gradient)를 역전파(Backpropagation)할 수 있음을 의미하며, 이는 강화학습, 시스템 식별(System Identification), 궤적 최적화 분야에 혁명을 일으키고 있다.</p>
<h3>4.1  미분 가능성과 연속적 접촉 모델</h3>
<p>전통적인 물리 엔진(Bullet, PhysX 등)은 충돌 처리 시 <code>if (collision) then (apply impulse)</code>와 같은 불연속적인 논리를 사용하거나, 선형 상보성 문제(LCP)를 반복적으로 푸는 방식을 취했다. 이는 구배가 끊기거나 0이 되는 지점을 만들어 딥러닝 모델의 학습을 방해한다.</p>
<p>반면, SDF 기반의 접촉 모델은 침투 깊이에 비례하는 연속적인 포텐셜 에너지를 정의하고, 이에 따른 부드러운 힘을 생성하므로 해석적인 미분 값을 제공한다.8 미분 가능한 시뮬레이터에서 상태 <span class="math math-inline">\mathbf{s}_{t+1}</span>은 이전 상태 <span class="math math-inline">\mathbf{s}_t</span>와 파라미터 <span class="math math-inline">\theta</span>의 함수로 표현되며, 연쇄 법칙(Chain Rule)을 통해 손실 함수 <span class="math math-inline">\mathcal{L}</span>에 대한 파라미터의 영향을 계산할 수 있다.<br />
<span class="math math-display">
\frac{\partial \mathcal{L}}{\partial \theta} = \sum_{t} \frac{\partial \mathcal{L}}{\partial \mathbf{s}_t} \frac{\partial \mathbf{s}_t}{\partial \theta}
</span><br />
SDF를 사용하면 충돌이 발생하는 순간의 야코비안(Jacobian) <span class="math math-inline">\frac{\partial \mathbf{s}_{t+1}}{\partial \mathbf{s}_t}</span>를 SDF의 헤시안(Hessian, 이계도함수)을 포함한 명확한 수식으로 기술할 수 있어, 물리 법칙을 내재한 학습이 가능해진다.11</p>
<h3>4.2  DiffSDFSim: 비볼록 형상과 마찰의 미분 가능한 처리</h3>
<p><strong>DiffSDFSim</strong>은 SDF를 활용하여 임의의 비볼록(Non-convex) 강체 간의 충돌과 마찰을 미분 가능하게 시뮬레이션하는 프레임워크를 제안했다.12</p>
<ul>
<li><strong>접촉 모델링:</strong> 기존의 미분 가능한 시뮬레이터(예: DiffTaichi)가 주로 입자 기반이나 간단한 도형에 국한되거나 임펄스(Impulse) 기반의 딱딱한 제약을 사용했던 것과 달리, DiffSDFSim은 SDF의 접촉면에서 발생하는 힘을 적분하여 비볼록 형상 간의 다점 접촉(Multi-point Contact)을 정교하게 모델링한다.</li>
<li><strong>마찰과 미분:</strong> 마찰력은 접촉 법선 힘에 의존적이므로, SDF를 통해 정확한 법선 벡터와 침투 깊이를 구하는 것이 마찰 시뮬레이션의 정확도와 직결된다. DiffSDFSim은 이러한 물리적 관계를 미분 가능한 연산 그래프로 구성하여, 비디오 데이터로부터 물체의 마찰 계수나 질량을 역추적하는 시스템 식별 작업에서 탁월한 성능을 입증했다.</li>
</ul>
<h3>4.3  SDF-Sim: 대규모 강체 시뮬레이션을 위한 그래프 네트워크 혁신</h3>
<p>Google DeepMind와 MIT 연구진이 발표한 <strong>SDF-Sim</strong>은 그래프 신경망(GNN) 기반의 학습된 시뮬레이터(Learned Simulator)가 직면한 확장성(Scalability) 문제를 암시적 기하학으로 해결한 기념비적인 연구이다.9</p>
<ul>
<li>
<p><strong>기존 메쉬 기반 GNN의 한계:</strong> MeshGraphNets와 같은 기존 모델은 물체 간의 상호작용을 계산하기 위해 메쉬 표면의 노드끼리 엣지를 연결했다. 물체 수가 늘어나면 가능한 엣지의 수가 <span class="math math-inline">O(N^2)</span>로 폭증하여, 메모리 부족으로 인해 대규모 씬을 시뮬레이션할 수 없었다.</p>
</li>
<li>
<p><strong>SDF 기반 엣지 구성(Edge Construction):</strong> SDF-Sim은 물체의 형상을 Neural SDF로 학습하여 내재화한다. 충돌 감지를 위해 수천 개의 표면 노드를 연결하는 대신, 한 물체의 표면 노드와 다른 물체의 중심(혹은 대표 포인트) 간의 관계를 SDF 값으로 직접 계산한다. 이 방식은 충돌 엣지의 수를 선형적인 수준(<span class="math math-inline">O(N)</span>)으로 획기적으로 줄인다.15</p>
</li>
<li>
<p><strong>충돌 특성 벡터(Feature Vector):</strong> 두 물체 <span class="math math-inline">O_i</span>와 <span class="math math-inline">O_j</span> 사이의 상호작용은 다음과 같은 정보를 담은 엣지로 인코딩되어 GNN에 입력된다.17<br />
<span class="math math-display">
e_{ij} = [x_i - c_{ji}, v_i - v_j]
</span><br />
여기서 <span class="math math-inline">c_{ji}</span>는 SDF 구배를 통해 계산된 <span class="math math-inline">O_j</span> 표면상의 최단 거리 점(Closest Point on Surface)이다. 이 정보만으로도 신경망은 두 물체가 얼마나 가까운지, 충돌 시 어느 방향으로 힘이 작용할지를 학습할 수 있다.</p>
</li>
<li>
<p><strong>성과:</strong> 이 아키텍처 덕분에 SDF-Sim은 수백 개의 객체와 110만 개의 노드로 구성된 복잡한 씬을 단일 GPU 상에서 시뮬레이션할 수 있게 되었으며, 이는 기존 메쉬 기반 방식이 메모리 초과로 실패하는 상황을 극복한 것이다.</p>
</li>
</ul>
<h3>4.4  PhyRecon: 렌더링과 물리의 완벽한 결합과 SP-MC 알고리즘</h3>
<p>NeurIPS 2024에서 발표된 <strong>PhyRecon</strong>은 암시적 기하학이 3D 재구성(Reconstruction)과 물리 시뮬레이션을 어떻게 통합하여 ‘물리적으로 타당한(Physically Plausible)’ 가상 세계를 만드는지 보여주는 최신 사례이다.18</p>
<ul>
<li><strong>핵심 아이디어:</strong> 기존의 NeRF나 3D Gaussian Splatting 기반 재구성은 시각적인 외형(Appearance) 복원에만 치중하여, 복원된 물체가 물리적으로 불안정하거나(예: 무게중심이 맞지 않아 넘어짐) 허공에 떠 있는 아티팩트를 생성하곤 했다. PhyRecon은 미분 가능한 물리 시뮬레이터를 학습 루프에 통합하여, 시뮬레이션 결과(예: 물체의 안정성)를 피드백으로 사용하여 형상을 보정한다.</li>
<li><strong>Surface Points Marching Cubes (SP-MC) 알고리즘:</strong> 연속적인 Neural SDF를 이산적인 물리 시뮬레이터(입자 기반)가 이해할 수 있는 표면 점(Surface Points)으로 변환하면서, 동시에 미분 가능성을 유지하는 것이 핵심 기술이다. SP-MC는 다음의 3단계로 구성된다.20</li>
</ul>
<ol>
<li><strong>Cluster (클러스터링):</strong> 전체 SDF 그리드를 탐색하는 대신, 표면이 존재할 확률이 높은 활성 복셀(Active Voxel)들을 식별하고 그룹화하여 연산 효율을 높인다.</li>
<li><strong>Normalize (정규화 및 보정):</strong> Marching Cubes와 유사하게 표면 점을 추출하되, 단순히 선형 보간하는 것에 그치지 않고 SDF 네트워크의 구배 <span class="math math-inline">\nabla f(\mathbf{x})</span>를 사용하여 점의 위치를 표면(<span class="math math-inline">\phi=0</span>) 위로 정밀하게 투영한다.</li>
<li><strong>Activate (활성화 및 미분 전파):</strong> 추출된 표면 점들의 좌표는 SDF 네트워크의 가중치 <span class="math math-inline">\theta</span>에 대해 미분 가능한 함수가 된다. 즉, 시뮬레이터에서 계산된 물리적 손실(예: 물체가 바닥을 뚫고 지나감, 넘어짐)에 대한 구배가 이 표면 점들을 거쳐 SDF 네트워크로 역전파(Backpropagation)될 수 있다.</li>
</ol>
<ul>
<li><strong>불확실성 모델링(Uncertainty Modeling):</strong> 렌더링 불확실성과 물리적 불확실성을 결합하여, 시각적 정보가 부족한 영역(예: 물체의 밑면)을 물리적 안정성 제약 조건으로 보완하는 전략을 취한다.21</li>
</ul>
<h2>5.  로보틱스 응용: 인식에서 제어까지의 연속성</h2>
<p>로봇이 미지의 환경을 탐색하고 상호작용하기 위해서는 실시간으로 환경의 기하학적 정보를 파악(Perception)하고, 이를 기반으로 충돌 없는 최적의 경로를 생성(Planning)해야 한다. SDF는 이 두 과정을 수학적으로 매끄럽게 연결하는 공통 언어(Common Language) 역할을 수행한다.</p>
<h3>5.1  iSDF: 실시간 신경망 SDF 재구성 시스템</h3>
<p>**iSDF (Implicit Signed Distance Fields)**는 로봇에 장착된 RGB-D 카메라로부터 들어오는 데이터 스트림을 이용해, 사전에 학습되지 않은 환경의 SDF를 실시간으로 학습하고 재구성하는 시스템이다.23</p>
<ul>
<li>
<p><strong>연속 학습(Continual Learning):</strong> iSDF는 고정된 모델을 사용하는 것이 아니라, 로봇이 이동함에 따라 랜덤하게 초기화된 MLP를 실시간으로 최적화한다. 이는 새로운 데이터를 지속적으로 반영하면서도 이전 정보를 잊지 않는(Catastrophic Forgetting 방지) 리플레이 버퍼 기술을 활용한다.</p>
</li>
<li>
<p><strong>복합 손실 함수(Composite Loss Function):</strong> iSDF의 학습은 다음 네 가지 손실 함수의 가중 합을 최소화하는 과정이다.25<br />
<span class="math math-display">
\mathcal{L}(\theta) = w_{sdf} \mathcal{L}_{sdf} + w_{grad} \mathcal{L}_{grad} + w_{eik} \mathcal{L}_{eik} + w_{ten} \mathcal{L}_{ten}
</span></p>
</li>
<li>
<p><strong><span class="math math-inline">\mathcal{L}_{sdf}</span> (Reconstruction Loss):</strong> 관측된 표면 점 근처에서 네트워크의 출력이 0(또는 측정된 거리)에 가까워지도록 한다. 가중치 <span class="math math-inline">w_{sdf}=10.0</span>으로 가장 중요하게 다뤄진다.</p>
</li>
<li>
<p><strong><span class="math math-inline">\mathcal{L}_{eik}</span> (Eikonal Loss):</strong> 관측되지 않은 빈 공간(Free space)에서도 거리 필드의 물리적 타당성을 유지하기 위해 <span class="math math-inline">|\nabla \phi| = 1</span> 제약을 부과한다. 이는 경로 계획 시 올바른 구배를 얻는 데 핵심적이다.</p>
</li>
<li>
<p><strong><span class="math math-inline">\mathcal{L}_{grad}</span> &amp; <span class="math math-inline">\mathcal{L}_{ten}</span>:</strong> 표면 법선의 일관성과 평활도(Smoothness)를 유지하여 노이즈를 제거한다.</p>
</li>
<li>
<p><strong>장점:</strong> iSDF는 복셀 기반 방식(Voxblox 등)과 달리 해상도의 제약이 없으며, 관측되지 않은 영역에 대해서도 그럴듯한(Plausible) 거리 값을 추론해낸다. 특히 경로 계획 알고리즘이 국소 최적해(Local Minima)에 빠지지 않도록 돕는 부드럽고 전역적인 구배 정보를 제공한다는 점에서 로봇 내비게이션에 최적화되어 있다.23</p>
</li>
</ul>
<h3>5.2  궤적 최적화(Trajectory Optimization)와 충돌 비용 함수</h3>
<p>로봇 팔이나 드론의 궤적을 생성할 때, SDF는 충돌 회피(Collision Avoidance)를 위한 비용 함수(Cost Function)와 그 구배를 제공하는 핵심 원천이다.</p>
<ul>
<li>
<p><strong>충돌 비용 함수의 정식화:</strong> 로봇의 형상을 <span class="math math-inline">R</span>, 장애물의 SDF를 <span class="math math-inline">\phi_{obs}</span>라고 할 때, 궤적 <span class="math math-inline">\xi</span>에 대한 충돌 비용 <span class="math math-inline">J_{collision}</span>은 다음과 같이 정의된다.26<br />
<span class="math math-display">
J_{collision}(\xi) = \int_{R(\xi)} c(\phi_{obs}(\mathbf{x})) d\mathbf{x}
</span><br />
여기서 비용 커널 <span class="math math-inline">c(d)</span>는 장애물 내부(<span class="math math-inline">d&lt;0</span>)이거나 안전 거리 <span class="math math-inline">\epsilon</span> 이내일 때 높은 비용을 부과하는 함수이다.<br />
<span class="math math-display">
c(d) = \begin{cases} -d + \frac{1}{2}\epsilon &amp; \text{if } d &lt; 0 \\ \frac{1}{2\epsilon}(d-\epsilon)^2 &amp; \text{if } 0 \le d \le \epsilon \\ 0 &amp; \text{otherwise} \end{cases}
</span></p>
</li>
<li>
<p><strong>함수적 구배(Functional Gradient)의 활용:</strong> CHOMP(Covariant Hamiltonian Optimization for Motion Planning)와 같은 최적화 알고리즘은 궤적 전체를 하나의 함수로 보고, 변분법(Calculus of Variations)을 이용해 비용을 낮추는 방향으로 궤적을 변형시킨다. 이때 SDF의 공간적 구배 <span class="math math-inline">\nabla \phi_{obs}</span>는 로봇의 각 링크를 장애물 밖으로 밀어내는 ‘가상의 힘 벡터’ 역할을 한다.26<br />
<span class="math math-display">
\xi_{new} = \xi_{old} - \alpha \mathbf{A}^{-1} \nabla_{\xi} J_{collision}
</span><br />
여기서 <span class="math math-inline">\mathbf{A}^{-1}</span>는 궤적의 평활도(Smoothness)를 유지하며 업데이트를 전파하는 공분산 행렬의 역행렬이다.</p>
</li>
</ul>
<h3>5.3  연속적 암시적 SDF(Continuous Implicit SDF)와 시공간 충돌</h3>
<p>로봇이 고속으로 이동할 때는 이산적인 시간 단계(Time Step) 사이에서 충돌이 발생하는 ‘터널링’ 문제가 궤적 최적화에서도 발생할 수 있다. 이를 해결하기 위해 **스웹트 볼륨(Swept Volume)**에 대한 암시적 표현을 사용하는 연구가 진행되고 있다.28</p>
<ul>
<li><strong>시공간 SDF:</strong> 로봇의 이동 경로가 만드는 4차원 시공간 궤적에 대해 SDF를 정의한다. 즉, 시간 <span class="math math-inline">t</span>를 포함한 함수 <span class="math math-inline">\Phi(\mathbf{x}, t)</span>를 정의하고, 장애물과의 최단 거리를 시공간 전체에서 적분하거나 최소값을 찾는다.</li>
<li><strong>이점:</strong> 이는 로봇이 얇은 장애물을 빠르게 지나갈 때도 충돌을 놓치지 않게 하며, 궤적의 시간적 매개변수화(Time Parameterization)까지 동시에 최적화할 수 있게 해준다.</li>
</ul>
<h3>5.4  복합 신경망 SDF(Composite Neural SDF)와 동적 환경</h3>
<p>동적 환경(Dynamic Environment)에서는 환경의 SDF가 계속 변하므로 매번 전체를 재학습하거나 재계산하는 것은 비효율적이다. 이를 위해 <strong>Differentiable Composite Neural SDF</strong>가 제안되었다.27</p>
<ul>
<li><strong>구성적 접근(Compositional Approach):</strong> 전체 환경을 하나의 거대한 신경망으로 학습하는 대신, 개별 장애물(예: 의자, 테이블, 움직이는 사람)을 각각의 독립적인 소형 Neural SDF로 표현한다. 전체 씬의 SDF 값은 개별 SDF들의 최소값(Min)이나 부드러운 합성(Smooth Minimum) 연산으로 도출된다.</li>
<li><strong>효율성:</strong> 장애물이 이동하면 해당 Neural SDF의 좌표계 변환 행렬만 업데이트하면 되므로, 재학습 없이 실시간으로 변화하는 환경의 충돌 비용과 구배를 정확하게 계산할 수 있다. 이는 제어 장벽 함수(Control Barrier Functions, CBF)와 결합되어 동적 장애물을 회피하는 안전한 제어 입력을 실시간으로 생성하는 데 활용된다.</li>
</ul>
<h2>6.  결론 및 향후 전망: 암시적 기하학이 여는 미래</h2>
<p>본 장에서는 암시적 기하학, 특히 부호화 거리 함수(SDF)가 단순한 정적 형상 표현 도구를 넘어, 충돌 감지, 물리 시뮬레이션, 그리고 로보틱스 제어를 아우르는 핵심적인 수학적 기반으로 자리 잡는 과정을 심도 있게 다루었다.</p>
<p>우리의 분석을 요약하면, 암시적 기하학은 다음과 같은 세 가지 차원에서 패러다임의 전환을 이끌고 있다.</p>
<ol>
<li><strong>이산적 판별에서 연속적 최적화로:</strong> 충돌 여부를 0과 1로 판별하는 이산적 검사(Discrete Check)에서, 침투 깊이와 구배를 통해 ‘얼마나, 어느 방향으로, 얼마나 빠르게’ 충돌했는지를 정량화하는 연속적 최적화(Continuous Optimization) 문제로 시뮬레이션을 재정의했다. 이는 수치적 안정성을 높이고 미분 가능한 파이프라인을 가능하게 했다.</li>
<li><strong>명시적 표현과 암시적 표현의 융합:</strong> PhyRecon과 SP-MC 알고리즘의 사례에서 보듯, 렌더링을 위한 명시적 표현과 물리를 위한 암시적 표현이 상호 배타적인 것이 아니라, 미분 가능한 변환을 통해 서로를 보완하고 강화하는 관계로 발전하고 있다. 이는 ‘Sim-to-Real’ 격차를 줄이는 데 결정적인 역할을 한다.</li>
<li><strong>End-to-End 미분 가능성의 실현:</strong> 로봇의 인지(iSDF)부터 계획(궤적 최적화), 그리고 물리적 상호작용(DiffSDFSim, SDF-Sim)에 이르는 전체 파이프라인이 미분 가능해짐으로써, 데이터 기반의 강화학습이나 시스템 식별의 효율을 극대화할 수 있는 길이 열렸다.</li>
</ol>
<p>향후 연구는 고해상도 Neural SDF의 메모리 효율성을 높이는 압축 기술, 물체가 찢어지거나 합쳐지는 위상 변화(Topological Change)를 다루는 동적 토폴로지 처리 기술, 그리고 수천 개의 객체가 상호작용하는 대규모 환경에서의 실시간 성능을 확보하기 위한 하드웨어 가속 기술에 집중될 것으로 전망된다. 이러한 기술적 진보는 로봇이 미지의 환경에서 인간 수준의 기민함과 안전성을 가지고 움직이고, 가상 시뮬레이션이 현실 세계를 완벽하게 모사하고 예측하는 디지털 트윈(Digital Twin)의 완전한 실현을 앞당길 것이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Continuous signed distance field representation of polygonal meshes - National Centre for Computer Animation - Bournemouth University, https://nccastaff.bournemouth.ac.uk/jmacey/MastersProject/MSc11/Mathieu/msanchez-sdf-thesis.pdf</li>
<li>Real-time Collision Detection between General SDFs, http://www.cad.zju.edu.cn/home/jin/papers/Real_Time_CD_between_SDFs.pdf</li>
<li>Signed Distance Functions (SDFs) - Emergent Mind, https://www.emergentmind.com/topics/signed-distance-functions-sdfs</li>
<li>Local Optimization for Robust Signed Distance Field Collision - Miles Macklin, https://mmacklin.com/sdfcontact.pdf</li>
<li>Differentiable Composite Neural Signed Distance Fields for Robot Navigation in Dynamic Indoor Environments - arXiv, https://arxiv.org/html/2502.02664v1</li>
<li>Neural Signed Distance Field (NSDF) - Emergent Mind, https://www.emergentmind.com/topics/neural-signed-distance-field-nsdf</li>
<li>Differentiable Volumetric Rendering: Learning Implicit 3D Representations Without 3D Supervision | Request PDF - ResearchGate, https://www.researchgate.net/publication/343461230_Differentiable_Volumetric_Rendering_Learning_Implicit_3D_Representations_Without_3D_Supervision</li>
<li>DiffSDFSim: Differentiable Rigid-Body Dynamics With Implicit Shapes - IEEE Xplore, https://ieeexplore.ieee.org/iel7/9665713/9665818/09665839.pdf</li>
<li>Learning rigid-body simulators over implicit shapes for large-scale scenes and vision - arXiv, https://arxiv.org/html/2405.14045v1</li>
<li>Differentiable Simulation - Emergent Mind, https://www.emergentmind.com/topics/differentiable-simulation</li>
<li>(PDF) A Review of Differentiable Simulators - ResearchGate, https://www.researchgate.net/publication/382119336_A_Review_of_Differentiable_Simulators</li>
<li>[PDF] DiffSDFSim: Differentiable Rigid-Body Dynamics With Implicit Shapes - Semantic Scholar API, https://api.semanticscholar.org/arXiv:2111.15318</li>
<li>[2111.15318] DiffSDFSim: Differentiable Rigid-Body Dynamics With Implicit Shapes - arXiv, https://arxiv.org/abs/2111.15318</li>
<li>Publications | Yulia Rubanova, https://yuliarubanova.github.io/publications/</li>
<li>Learning rigid-body simulators over implicit shapes for large-scale scenes and vision, https://www.researchgate.net/publication/380820613_Learning_rigid-body_simulators_over_implicit_shapes_for_large-scale_scenes_and_vision</li>
<li>Learning rigid-body simulators over implicit shapes for large-scale scenes and vision - Liner, https://liner.com/review/learning-rigidbody-simulators-over-implicit-shapes-for-largescale-scenes-and</li>
<li>Learning rigid-body simulators over implicit shapes for large-scale scenes and vision - NeurIPS, https://proceedings.neurips.cc/paper_files/paper/2024/file/e3abc125ecacb71786cefb9f67b08c5d-Paper-Conference.pdf</li>
<li>PhyRecon, https://phyrecon.github.io/</li>
<li>PhyRecon: Physically Plausible Neural Scene Reconstruction - NeurIPS, https://proceedings.neurips.cc/paper_files/paper/2024/hash/2d880acd7b31e25d45097455c8e8257f-Abstract-Conference.html</li>
<li>PhyRecon: Physically Plausible Neural Scene Reconstruction - OpenReview, <a href="https://openreview.net/forum?id=QrE9QPq4ya&amp;referrer=%5Bthe+profile+of+Yixin+Zhu%5D(/profile?id%3D~Yixin_Zhu1)">https://openreview.net/forum?id=QrE9QPq4ya&amp;referrer=%5Bthe%20profile%20of%20Yixin%20Zhu%5D(%2Fprofile%3Fid%3D~Yixin_Zhu1)</a></li>
<li>PHYRECON: Physically Plausible Neural Scene Reconstruction - Yixin Zhu, https://yzhu.io/publication/scenereconstruction2024neurips/paper.pdf</li>
<li>PHYRECON: Physically Plausible Neural Scene Reconstruction - NIPS papers, https://proceedings.neurips.cc/paper_files/paper/2024/file/2d880acd7b31e25d45097455c8e8257f-Paper-Conference.pdf</li>
<li>iSDF: Real-Time Neural Signed Distance Fields for Robot Perception, https://www.roboticsproceedings.org/rss18/p012.pdf</li>
<li>[2204.02296] iSDF: Real-Time Neural Signed Distance Fields for Robot Perception - arXiv, https://arxiv.org/abs/2204.02296</li>
<li>iSDF: Real-Time Neural Signed Distance Fields for Robot Perception - ResearchGate, https://www.researchgate.net/publication/361714160_iSDF_Real-Time_Neural_Signed_Distance_Fields_for_Robot_Perception</li>
<li>CHOMP: Gradient Optimization Techniques for Efficient Motion Planning - Carnegie Mellon University, https://kilthub.cmu.edu/articles/CHOMP_Gradient_Optimization_Techniques_for_Efficient_Motion_Planning/6552254/files/12033554.pdf</li>
<li>Real-Time RGB-D Based Neural Barrier Functions for Safe Robotic Navigation - arXiv, https://arxiv.org/html/2505.02294v2</li>
<li>Continuous Implicit SDF Based Any-shape Robot Trajectory Optimization - arXiv, https://arxiv.org/pdf/2303.01330</li>
<li>Continuous Implicit SDF Based Any-Shape Robot Trajectory Optimization - ResearchGate, https://www.researchgate.net/publication/376511490_Continuous_Implicit_SDF_Based_Any-Shape_Robot_Trajectory_Optimization</li>
<li>Variational Shape Inference for Grasp Diffusion on SE⁢(3) - arXiv, https://arxiv.org/html/2508.17482v1</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>