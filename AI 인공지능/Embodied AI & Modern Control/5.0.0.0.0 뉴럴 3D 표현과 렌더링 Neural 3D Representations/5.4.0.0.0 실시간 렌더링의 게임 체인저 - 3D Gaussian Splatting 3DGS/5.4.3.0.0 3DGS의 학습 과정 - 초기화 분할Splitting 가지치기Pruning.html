<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.4.3 3DGS의 학습 과정: 초기화, 분할(Splitting), 가지치기(Pruning)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.4.3 3DGS의 학습 과정: 초기화, 분할(Splitting), 가지치기(Pruning)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 5. 뉴럴 3D 표현과 렌더링 (Neural 3D Representations)</a> / <a href="index.html">5.4 실시간 렌더링의 게임 체인저: 3D Gaussian Splatting (3DGS)</a> / <span>5.4.3 3DGS의 학습 과정: 초기화, 분할(Splitting), 가지치기(Pruning)</span></nav>
                </div>
            </header>
            <article>
                <h1>5.4.3 3DGS의 학습 과정: 초기화, 분할(Splitting), 가지치기(Pruning)</h1>
<p>3D Gaussian Splatting(이하 3DGS)이 기존의 뉴럴 렌더링(Neural Rendering) 패러다임, 특히 좌표 기반의 뉴럴 네트워크(Coordinate-based Neural Networks)인 NeRF(Neural Radiance Fields)와 가장 극명하게 대비되는 지점은 장면을 표현하는 기저(Basis)의 유동성에 있다. NeRF가 고정된 MLP(Multi-Layer Perceptron)의 가중치(Weight) 공간을 탐색하며 장면의 복사(Radiance)와 밀도(Density)를 암시적(Implicit)으로 최적화한다면, 3DGS는 3차원 공간 상에 실존하는 기하학적 원형(Primitive)인 가우시안(Gaussian)의 개수, 위치, 형태, 그리고 투명도를 학습 과정 전반에 걸쳐 동적으로 변화시키는 구조적 학습(Structural Learning)을 수행한다. 이는 최적화가 진행됨에 따라 모델의 용량(Capacity) 자체가 적응적으로 변화함을 의미하며, 데이터가 풍부한 곳에는 더 많은 자원을, 빈 공간에는 최소한의 자원을 할당하는 효율성의 근간이 된다.</p>
<p>본 절에서는 3DGS의 학습 파이프라인 중 가장 핵심적인 메커니즘인 **적응형 밀도 제어(Adaptive Density Control)**를 중심으로, 가우시안의 생애 주기(Life Cycle)를 심층적으로 분석한다. 초기화(Initialization) 단계에서의 희소 점군(Sparse Point Cloud) 활용 전략부터 시작하여, 학습 중 발생하는 가우시안의 증식(Densification) 메커니즘인 분할(Splitting)과 복제(Cloning), 그리고 불필요한 요소를 제거하여 효율성을 확보하는 가지치기(Pruning)에 이르는 전 과정을 다룬다. 이 과정은 단순한 파라미터 튜닝(Parameter Tuning)의 영역을 넘어, 미분 가능한 래스터라이제이션(Differentiable Rasterization)과 결합하여 장면의 기하학적 구조를 명시적(Explicit)으로 조각해 나가는 과정이라 할 수 있다.</p>
<h2>1.  초기화: 희소 점군에서 체적 표현으로의 전이 (Initialization)</h2>
<p>모든 최적화 문제에서 초기값의 설정은 수렴 속도와 최종 해(Solution)의 품질을 결정짓는 결정적인 요소이다. 특히 비볼록(Non-convex) 최적화 문제를 다루는 3D 비전 태스크에서, 3DGS는 ’무(無)’에서 시작하기보다는 기존의 SfM(Structure-from-Motion) 파이프라인에서 획득한 기하학적 정보를 적극적으로 활용하는 전략을 취한다.</p>
<h3>1.1  SfM 포인트 클라우드의 전략적 활용</h3>
<p>표준적인 3DGS 구현체는 COLMAP과 같은 SfM 라이브러리를 통해 추출된 희소 포인트 클라우드(Sparse Point Cloud)를 초기화의 출발점으로 삼는다.1 NeRF가 광선(Ray) 위의 점들을 무작위 혹은 균일하게 샘플링하여 학습을 시작하는 것과 달리, 3DGS는 SfM 포인트 클라우드의 각 점(Point)을 3D 가우시안의 초기 평균값(Mean, <span class="math math-inline">\mu \in \mathbb{R}^3</span>)으로 변환하여 사용한다.2</p>
<p>이러한 접근 방식은 다음과 같은 중요한 의미를 갖는다.</p>
<ol>
<li><strong>기하학적 사전 정보(Geometric Prior)의 주입:</strong> SfM 포인트는 이미 2D 이미지 간의 특징점 매칭을 통해 3D 공간 상에서 유효한 위치에 존재할 확률이 높은 지점들이다. 이곳에 가우시안을 배치함으로써, 3DGS는 학습 초기부터 장면의 대략적인 구조(Structure)를 확보한 상태로 최적화를 시작할 수 있다. 이는 부유물(Floaters)이라 불리는, 허공에 잘못 생성되는 아티팩트를 억제하는 데 크게 기여한다.</li>
<li><strong>수렴 속도의 가속화:</strong> 빈 공간(Empty Space)에 대한 불필요한 탐색을 줄이고, 물체가 존재하는 표면 근처에서 집중적인 최적화를 수행할 수 있게 함으로써 학습 시간을 획기적으로 단축한다.</li>
<li><strong>명시적 표현의 연속성:</strong> 점(Point)이라는 이산적(Discrete) 데이터를 가우시안이라는 연속적(Continuous)이고 미분 가능한(Differentiable) 볼륨으로 확장하는 초기 단계로서 작용한다.</li>
</ol>
<p>그러나 SfM 포인트 클라우드에 대한 의존성은 동시에 3DGS의 약점이 되기도 한다. 텍스처가 부족한 벽면(Textureless regions)이나 반사가 심한 금속 재질(Specular surfaces) 등에서는 SfM 알고리즘이 특징점을 추출하지 못해 포인트가 매우 희소하거나 아예 없는 경우가 발생한다.4 이러한 ‘콜드 스타트(Cold Start)’ 문제는 초기화 단계에서 해당 영역을 빈 공간으로 간주하게 만들며, 이후 설명할 적응형 밀도 제어 단계에서 이를 복구하기 위해 과도한 반복(Iteration)을 소모하게 하거나, 끝내 복구하지 못하고 구멍(Hole)으로 남기는 원인이 된다. 최근 연구들은 이러한 의존성을 탈피하기 위해 무작위 초기화(Random Initialization) 후 점진적으로 구조를 찾아가거나, 단안 깊이 추정(Monocular Depth Estimation) 모델의 예측값을 초기화에 활용하는 방식을 제안하고 있으나 6, 여전히 표준 파이프라인에서는 SfM 데이터가 가장 신뢰할 수 있는 초기화 표준(Gold Standard)으로 작용한다.</p>
<h3>1.2  공분산(Covariance) 및 속성의 초기화 로직</h3>
<p>SfM 포인트가 가우시안으로 변환되기 위해서는 위치(<span class="math math-inline">\mu</span>) 외에도 3DGS를 구성하는 핵심 파라미터인 공분산 행렬(<span class="math math-inline">\Sigma</span>), 불투명도(<span class="math math-inline">\alpha</span>), 그리고 색상을 나타내는 구면 조화 함수(Spherical Harmonics, SH) 계수가 정의되어야 한다. 이들의 초기화 로직은 물리적으로 타당한 3D 장면을 구성하기 위해 정교하게 설계되어 있다.</p>
<h4>1.2.1  등방성 스케일과 k-최근접 이웃 (k-NN)</h4>
<p>초기 단계에서 3D 가우시안은 방향성이 없는 구(Sphere) 형태, 즉 등방성(Isotropic) 공분산을 갖는 것으로 가정한다.7 이때 각 가우시안의 크기(Scale)를 어떻게 설정하느냐가 중요한데, 너무 작으면 가우시안 사이에 틈이 생겨 배경이 투과되는 현상이 발생하고, 너무 크면 서로 과도하게 겹쳐 초기 렌더링 품질을 저하시킨다.</p>
<p>3DGS는 이를 해결하기 위해 각 포인트와 가장 가까운 3개의 이웃 점(k-Nearest Neighbors, k=3) 사이의 평균 거리를 계산하고, 이를 초기 스케일의 기준으로 삼는다.7<br />
<span class="math math-display">
s_{init} = \log\left(\sqrt{\frac{1}{3} \sum_{k=1}^{3} \| \mu - p_k \|^2}\right)
</span><br />
여기서 <span class="math math-inline">p_k</span>는 가장 가까운 이웃 점들의 위치이다. 로그 스케일을 사용하는 이유는 최적화 과정에서 스케일 벡터 <span class="math math-inline">s</span>가 음수가 되는 것을 방지하기 위해 활성화 함수로 지수 함수(Exponential)를 사용하기 때문이다. 이 방식은 포인트가 밀집된 곳에서는 작은 가우시안을, 포인트가 희소한 곳에서는 큰 가우시안을 배치하여 장면 전체를 빈틈없이 덮는(Covering) 효과를 낳는다.9</p>
<h4>1.2.2  회전과 불투명도의 초기값</h4>
<ul>
<li><strong>회전(Rotation):</strong> 초기에는 모든 가우시안이 회전하지 않은 상태, 즉 월드 좌표축과 정렬된 상태로 가정한다. 따라서 회전을 나타내는 쿼터니언(Quaternion) <span class="math math-inline">q</span>는 단위 쿼터니언 $q_{init} = $으로 초기화된다.10</li>
<li><strong>불투명도(Opacity):</strong> 초기 불투명도 <span class="math math-inline">\alpha</span>는 경험적으로 0.1(시그모이드 통과 전 역함수 값으로는 <span class="math math-inline">logit(0.1) \approx -2.2</span>)로 설정된다.10 이는 가우시안들을 반투명한 상태로 시작하게 함으로써, 초기 최적화 단계에서 광선이 전면의 가우시안을 뚫고 후면의 가우시안까지 도달하여 그래디언트(Gradient)를 전파할 수 있게 하기 위함이다. 만약 초기 불투명도가 너무 높으면(예: 1.0), 뒤쪽의 가우시안들은 그래디언트를 받지 못해 학습되지 않는 ‘가려짐(Occlusion)’ 문제가 발생한다.10</li>
<li><strong>색상(SH Coefficients):</strong> SfM 포인트가 가진 RGB 색상 정보를 바탕으로 0차 SH 계수(DC 성분)를 초기화한다.10 방향에 따른 색상 변화를 나타내는 고차(Higher-order) SH 계수들은 모두 0으로 초기화되어, 학습이 진행됨에 따라 뷰 의존적(View-dependent) 효과를 서서히 학습하도록 유도한다.</li>
</ul>
<h2>2.  최적화 루프와 적응형 밀도 제어 (Adaptive Density Control)</h2>
<p>초기화 이후 3DGS는 렌더링 이미지와 정답 이미지 사이의 손실(Loss)을 최소화하는 방향으로 파라미터를 업데이트한다. 이때 손실 함수는 일반적으로 <span class="math math-inline">L_1</span> 손실과 D-SSIM(Structural Similarity Index Measure) 항의 결합으로 구성된다.7<br />
<span class="math math-display">
\mathcal{L} = (1 - \lambda) \mathcal{L}_1 + \lambda \mathcal{L}_{\text{D-SSIM}}
</span><br />
일반적으로 <span class="math math-inline">\lambda = 0.2</span>가 사용된다.3 그러나 3DGS의 진정한 힘은 고정된 파라미터의 최적화가 아니라, **적응형 밀도 제어(ADC, Adaptive Density Control)**라 불리는 구조적 최적화에 있다. 이는 학습 도중 가우시안을 추가(Densification)하거나 제거(Pruning)하여 장면의 복잡도에 맞게 표현력을 조절하는 과정이다.</p>
<h3>2.1  제어 주기와 웜업(Warm-up)</h3>
<p>밀도 제어는 매 반복(Iteration)마다 수행되지 않는다. 이는 가우시안의 위치와 형태가 어느 정도 안정화될 시간을 주기 위함이다.</p>
<ol>
<li><strong>웜업 단계 (0 ~ 500 Iterations):</strong> 학습 초기 500회 반복까지는 밀도 제어를 수행하지 않는다.1 이 시기에는 초기화된 가우시안들이 기하학적으로 올바른 위치와 방향을 찾아가는 데 집중한다.</li>
<li><strong>제어 빈도:</strong> 500회 이후부터 15,000회 반복(기본 설정)까지, 매 100회(Iteration)마다 밀도 제어 로직이 작동한다.1 이 주기는 가우시안들이 새로 생성된 후 파라미터 공간에서 수렴할 수 있는 최소한의 시간을 보장한다.</li>
</ol>
<h3>2.2  가우시안 증식의 기준: 위치 그래디언트 (Positional Gradient)</h3>
<p>가우시안을 어디에 추가할지 결정하는 핵심 지표는 **‘뷰 공간 위치 그래디언트(View-space Positional Gradient)’**의 평균 크기이다. 렌더링 오차는 역전파(Backpropagation)를 통해 각 가우시안의 2D 화면상 중심 위치(<span class="math math-inline">\mu_{2D}</span>)에 대한 그래디언트 <span class="math math-inline">\nabla_{\mu_{2D}} \mathcal{L}</span>를 생성한다.</p>
<p>3DGS는 최적화 과정에서 이 그래디언트의 누적 평균값을 추적한다. 특정 가우시안이 높은 위치 그래디언트 값을 갖는다는 것은, 해당 가우시안이 위치한 영역이 현재의 표현력으로는 정답 이미지와 큰 차이를 보이고 있다는 강력한 신호이다. 이는 기하학적 위치가 잘못되었거나, 텍스처의 디테일을 충분히 표현하지 못하고 있음을 의미한다(Under-fitting).</p>
<ul>
<li><strong>임계값(<span class="math math-inline">\tau_{pos}</span>):</strong> 기본적으로 위치 그래디언트의 평균 크기가 <span class="math math-inline">\tau_{pos} = 0.0002</span>를 초과하는 가우시안들이 증식(Densification)의 후보가 된다.3 이 임계값은 경험적으로 결정된 값이며, 장면의 스케일에 따라 민감하게 반응할 수 있다.</li>
</ul>
<h3>2.3  증식의 두 가지 경로: 복제(Cloning)와 분할(Splitting)</h3>
<p>높은 그래디언트를 가진 가우시안, 즉 ’재건이 불충분한 영역’에 위치한 가우시안은 그 크기(Scale)에 따라 두 가지 상반된 운명을 맞이한다. 이 이분법적 접근은 3DGS가 빈 공간을 채우면서 동시에 세밀한 디테일을 묘사할 수 있게 하는 핵심 동력이다.14</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>복제 (Cloning / Duplication)</strong></th><th><strong>분할 (Splitting)</strong></th></tr></thead><tbody>
<tr><td><strong>발동 조건</strong></td><td>그래디언트 &gt; <span class="math math-inline">\tau_{pos}</span> <strong>AND</strong> 스케일이 작음 (Small Scale)</td><td>그래디언트 &gt; <span class="math math-inline">\tau_{pos}</span> <strong>AND</strong> 스케일이 큼 (Large Scale)</td></tr>
<tr><td><strong>주요 목적</strong></td><td><strong>과소 재건(Under-reconstruction) 해결:</strong> 빈 공간 채우기 및 커버리지 확대</td><td><strong>과대 재건(Over-reconstruction) 해결:</strong> 해상도 증가 및 아티팩트 제거</td></tr>
<tr><td><strong>동작 방식</strong></td><td>동일한 가우시안을 하나 더 생성하여 복사함</td><td>하나의 큰 가우시안을 제거하고 두 개의 작은 가우시안 생성</td></tr>
<tr><td><strong>크기 변화</strong></td><td>변화 없음 (부모와 동일)</td><td>크기를 <span class="math math-inline">\phi = 1.6</span> 비율로 축소 (<span class="math math-inline">Scale_{new} = Scale_{old} / 1.6</span>)</td></tr>
<tr><td><strong>위치 변화</strong></td><td>부모 위치와 동일 (초기 겹침)</td><td>부모 가우시안을 확률밀도함수(PDF)로 삼아 샘플링된 위치로 이동</td></tr>
<tr><td><strong>물리적 의미</strong></td><td>표면적 증가 (Filling holes)</td><td>정밀도 향상 (Refinement)</td></tr>
</tbody></table>
<h4>2.3.1  복제(Cloning): 빈 곳 채우기</h4>
<p>작은 크기의 가우시안이 높은 그래디언트를 갖는다는 것은, 해당 영역에 기하학적 정보가 존재하지만 현재의 가우시안 밀도로는 그 표면을 완전히 덮지 못했거나(Hole), 텍스처의 급격한 변화를 따라가지 못함을 의미한다.</p>
<p>이 경우 3DGS는 해당 가우시안을 복제(Clone)하여 쌍둥이 가우시안을 생성한다. 생성 직후에는 두 가우시안이 완벽히 겹쳐 있지만, 이어지는 최적화 단계에서 서로 다른 위치로 이동하며 빈 공간을 메우게 된다.17 이는 텍스처가 복잡하거나 초기 포인트 클라우드가 희소했던 영역을 조밀하게(Dense) 채우는 역할을 한다. 특히 3DGS의 래스터라이저가 알파 블렌딩(Alpha Blending)을 사용하므로, 복제된 가우시안들은 합쳐져서 더 높은 불투명도를 형성하거나, 서로 다른 색상을 학습하여 고주파 텍스처를 표현하는 데 기여한다.17</p>
<h4>2.3.2  분할(Splitting): 해상도 높이기</h4>
<p>반대로, 큰 크기의 가우시안이 높은 그래디언트를 갖는 경우는 해당 가우시안이 너무 넓은 영역을 덮고 있어 세밀한 구조를 뭉개고 있거나(Over-reconstruction), 물체의 경계선(Edge)에 걸쳐 있어 큰 렌더링 오차를 유발하는 상황이다.</p>
<p>이때 3DGS는 해당 가우시안을 삭제하고, 대신 크기가 줄어든 두 개의 작은 가우시안으로 대체한다.18 분할 계수 <span class="math math-inline">\phi=1.6</span>을 사용하여 크기를 <span class="math math-inline">1/1.6</span>로 줄이는 것이 표준이다.2 새로운 가우시안들의 위치는 원래 가우시안의 공분산 행렬을 확률밀도함수(PDF)로 사용하여 샘플링함으로써 결정된다. 이 과정은 마치 3D 메쉬의 테셀레이션(Tessellation)을 수행하여 폴리곤 수를 늘리는 것과 유사한 효과를 주며, 장면의 기하학적 정밀도를 높이고 텍스처의 디테일을 표현할 수 있게 한다. 분할은 3DGS가 뭉툭한 초기 형상에서 정교한 구조체로 진화하게 만드는 가장 강력한 연산이다.20</p>
<h3>2.4  분할 계수 <span class="math math-inline">\phi=1.6</span>의 실험적 근거</h3>
<p>원문 논문과 다양한 구현체에서 분할 시 크기를 나누는 계수(Factor)로 <span class="math math-inline">\phi=1.6</span>을 고정적으로 사용한다.2 이는 실험적으로 결정된 값으로, 다음과 같은 트레이드오프(Trade-off)를 고려한 결과이다.</p>
<ul>
<li><strong><span class="math math-inline">\phi</span>가 너무 클 때 (예: 2.0 이상):</strong> 가우시안의 크기가 급격히 줄어들어 가우시안 간의 간격이 벌어지는 앨리어싱(Aliasing)이나 구멍(Hole)이 발생할 수 있다.</li>
<li><strong><span class="math math-inline">\phi</span>가 너무 작을 때 (예: 1.0 근접):</strong> 분할의 효과가 미미하여 해상도 증가의 이점을 얻기 어렵고, 최적화가 정체된다.</li>
</ul>
<p>1.6이라는 수치는 두 개의 자식 가우시안이 부모 가우시안의 영역을 적절히 오버랩(Overlap)하면서 커버하되, 충분히 작아져서 독립적인 디테일을 표현할 수 있는 최적의 균형점(Sweet spot)으로 작용한다.</p>
<h2>3.  가지치기 (Pruning): 효율성과 품질의 균형</h2>
<p>가우시안을 무한정 늘리기만 하면 메모리 사용량이 VRAM의 한계를 초과하고 렌더링 속도가 저하될 뿐만 아니라, 과적합(Overfitting)으로 인해 새로운 뷰에서 아티팩트가 발생한다. 따라서 3DGS는 주기적으로 불필요하거나 문제가 있는 가우시안을 제거하는 가지치기(Pruning) 과정을 수행하여 모델의 경량화(Compactness)를 유지한다.</p>
<h3>3.1  불투명도 기반 가지치기 (Opacity Culling)</h3>
<p>가장 기본적이고 직관적인 가지치기는 불투명도(<span class="math math-inline">\alpha</span>)가 낮은 가우시안을 제거하는 것이다. 학습 과정에서 특정 가우시안의 <span class="math math-inline">\alpha</span> 값이 임계값 이하로 떨어지면, 해당 가우시안은 렌더링 이미지에 유의미한 기여를 하지 않는다고 판단하여 삭제한다.</p>
<ul>
<li><strong>임계값(<span class="math math-inline">\epsilon</span>):</strong> 표준적으로 <span class="math math-inline">\epsilon = 0.005</span>가 사용된다.1</li>
<li><strong>효과:</strong> 최적화 과정에서 수렴하지 못하고 공간상에 희미하게 흩어진 노이즈성 가우시안이나, 잘못된 위치에 생성되어 투명해진 가우시안을 제거한다. 이는 수백만 개의 가우시안 중 수십만 개 이상을 제거할 수 있는 강력한 필터링 역할을 한다.22 최근 연구에서는 이 임계값을 학습 가능한 파라미터로 설정하거나(LP-3DGS), 0.005보다 보수적인 값을 사용하여 초기 가우시안의 생존율을 높이는 전략도 제안되고 있다.24</li>
</ul>
<h3>3.2  화면 공간 크기 기반 가지치기 (Screen-space Sizing)</h3>
<p>카메라 가까이에 위치하거나 스케일이 비정상적으로 커져서 화면의 지나치게 많은 영역을 덮어버리는 가우시안 또한 제거 대상이다.</p>
<ul>
<li><strong>조건:</strong> 뷰 공간(View-space) 또는 화면 공간(Screen-space)에서의 투영된 반지름(Radius)이 특정 픽셀 수(예: 20 픽셀) 이상이거나, 월드 공간(World-space)에서 장면 전체 크기(Scene Extent)의 일정 비율(예: 10% ~ 50%)을 초과하는 경우.3</li>
<li><strong>물리적 의미:</strong> 이러한 거대 가우시안은 주로 배경의 하늘을 억지로 표현하려다 커진 것이거나, 학습이 잘못되어 카메라 바로 앞에 생긴 ‘벽(Wall)’ 같은 아티팩트일 가능성이 높다. 이를 제거하지 않으면 새로운 뷰에서 시야를 가리는 심각한 결함(Floater)이 된다.</li>
<li><strong>주의점:</strong> 야외 장면의 하늘이나 먼 배경과 같이 실제로 거대한 스케일이 필요한 경우에는 이 조건이 오히려 배경을 삭제하여 ’구멍 뚫린 하늘’을 만들 수 있다. 따라서 최근 연구들은 깊이(Depth) 정보를 고려하여 먼 거리에 있는 가우시안에 대해서는 이 제약을 완화하는 방식을 적용하기도 한다.28</li>
</ul>
<h3>3.3  불투명도 재설정 (Opacity Reset): “불사조” 전략</h3>
<p>3DGS 학습 과정에서 가장 독특하면서도 필수적인 테크닉 중 하나는 주기적인 **불투명도 재설정(Opacity Reset)**이다. 이는 시스템에 주기적인 충격(Shock)을 가하여 국소 최적해(Local Optima)를 탈출하는 전략이다.</p>
<ul>
<li><strong>동작:</strong> 매 3,000회 반복(Iteration)마다 모든 가우시안의 불투명도를 강제로 낮은 값(예: 0.01)으로 클램핑(Clamping)하거나 재설정한다.14</li>
<li><strong>원리:</strong> 학습이 진행되면서 일부 가우시안은 실제 기하학적 표면이 아닌 공중에 떠 있는 상태(Floater)로 높은 불투명도를 가진 채 고착될 수 있다. 이들의 불투명도를 강제로 낮추면, 렌더링 오차가 순간적으로 급증한다. 이후 이어지는 최적화 과정에서, 실제로 필요한(유효한 위치에 있는) 가우시안들은 다시 그래디언트를 받아 불투명도가 빠르게 회복되지만, 잘못된 위치에 있던 가우시안들은 그래디언트를 받지 못해 회복되지 못한다.</li>
<li><strong>결과:</strong> 회복되지 못한 가우시안들은 앞서 설명한 3.1절의 불투명도 가지치기(<span class="math math-inline">\alpha &lt; 0.005</span>) 조건에 의해 자연스럽게 소멸된다.31 이 과정은 가우시안의 개수를 일시적으로 줄였다가 다시 필요한 곳에만 늘리는 정화(Purification) 작용을 하며, 부유물 제거와 전체적인 가우시안 분포의 재배치를 유도하여 최종 렌더링 품질을 크게 향상시킨다.</li>
</ul>
<h2>4.  학습 파라미터 및 스케줄링 요약</h2>
<p>3DGS의 학습 과정은 수많은 하이퍼파라미터의 정교한 조율로 이루어진다. 아래 표는 표준적인 3DGS 구현체(Inria) 및 후속 연구들에서 사용되는 주요 학습 및 밀도 제어 파라미터를 정리한 것이다.1</p>
<table><thead><tr><th><strong>파라미터 (Parameter)</strong></th><th><strong>기본값 (Default)</strong></th><th><strong>설명 및 역할</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><code>densify_from_iter</code></td><td>500</td><td>밀도 제어를 시작하는 반복 횟수 (Warm-up 종료 시점)</td><td>초기 수렴 보장</td></tr>
<tr><td><code>densify_until_iter</code></td><td>15,000</td><td>밀도 제어를 종료하는 반복 횟수</td><td>이후로는 미세 조정(Fine-tuning)만 수행</td></tr>
<tr><td><code>densification_interval</code></td><td>100</td><td>밀도 제어(분할/복제/가지치기)를 수행하는 주기</td><td>너무 짧으면 불안정, 길면 수렴 저하</td></tr>
<tr><td><code>densify_grad_threshold</code></td><td>0.0002</td><td>가우시안 증식 여부를 결정하는 위치 그래디언트 임계값 (<span class="math math-inline">\tau_{pos}</span>)</td><td>장면 스케일에 민감함</td></tr>
<tr><td><code>opacity_threshold</code></td><td>0.005</td><td>가지치기(Pruning)를 수행하는 불투명도 하한선</td><td>노이즈 제거의 핵심</td></tr>
<tr><td><code>opacity_reset_interval</code></td><td>3,000</td><td>불투명도 재설정(Reset)을 수행하는 주기</td><td>Floater 제거를 위한 충격 요법</td></tr>
<tr><td><code>reset_opacity_val</code></td><td>0.01</td><td>재설정 시 적용되는 불투명도 목표값</td><td>재학습의 기회 제공</td></tr>
<tr><td><code>percent_dense</code></td><td>0.01</td><td>장면 크기 대비 강제 분할을 수행할 가우시안 크기 비율</td><td>거대 가우시안 억제</td></tr>
</tbody></table>
<h2>5.  분석 및 고찰: 밀도 제어의 한계와 진화</h2>
<p>3DGS의 적응형 밀도 제어는 기존의 고정된 표현 방식보다 월등히 효율적이지만, 완벽하지는 않다. 그래디언트 기반(<span class="math math-inline">\tau_{pos}</span>)의 단순한 휴리스틱은 몇 가지 내재적인 한계를 가지며, 이는 로봇 공학이나 정밀 제어 분야 적용 시 고려해야 할 사항이다.</p>
<ol>
<li><strong>임계값 민감성 (Sensitivity):</strong> 그래디언트 임계값(0.0002)은 경험적인 값으로, 장면의 조명 조건이나 카메라 거리에 따라 최적값이 달라질 수 있다. 임계값이 너무 낮으면 가우시안이 폭발적으로 늘어나 메모리 부족(OOM)을 유발하고, 너무 높으면 디테일이 뭉개진다.22</li>
<li><strong>과소 재건과 과대 재건의 모호성:</strong> 단순히 그래디언트가 크다는 정보만으로는 이것이 텍스처가 복잡해서인지(분할 필요), 아니면 지오메트리가 부족해서인지(복제 필요) 명확히 구별하기 어렵다. 이로 인해 불필요한 분할이 일어나거나 필요한 곳에 복제가 일어나지 않는 경우가 발생한다.20</li>
<li><strong>뷰 의존적 편향 (View-dependent Bias):</strong> 위치 그래디언트는 2D 화면 공간의 오차로부터 역전파되므로, 학습 데이터에 포함된 카메라 뷰의 분포에 따라 가우시안의 성장이 편향될 수 있다. 카메라가 자주 비추는 곳은 과도하게 밀집되고, 그렇지 않은 곳은 희소하게 남을 수 있다.</li>
</ol>
<p>이러한 한계를 극복하기 위해 최근의 연구들은 **픽셀 단위의 오차 맵(Error Map)**을 직접 활용하여 밀도 제어를 수행하거나 32, <strong>깊이(Depth) 정보</strong>를 기하학적 제약조건으로 활용하여 깊이 불연속면(Depth Discontinuity)에서의 아티팩트를 줄이는 방향 34, 혹은 그래디언트가 아닌 <strong>불투명도 그래디언트</strong>를 지표로 삼는 방법 24 등으로 진화하고 있다. 또한, 단순히 크기만으로 분할/복제를 결정하는 것이 아니라, 가우시안의 고유값(Eigenvalue) 비율을 분석하여 길쭉한(Anisotropic) 가우시안을 우선적으로 분할하는 등의 고도화된 전략도 제안되고 있다.17</p>
<p>결론적으로 3DGS의 학습 과정은 **‘초기화 <span class="math math-inline">\rightarrow</span> 렌더링 <span class="math math-inline">\rightarrow</span> 손실 계산 <span class="math math-inline">\rightarrow</span> 역전파 <span class="math math-inline">\rightarrow</span> 적응형 밀도 제어(증식/제거) <span class="math math-inline">\rightarrow</span> 불투명도 리셋’**의 순환 고리를 통해, 장면의 복잡도에 최적화된 비정형(Unstructured) 3D 표현을 스스로 찾아가는 진화적 알고리즘이라 정의할 수 있다. 이 과정은 3DGS가 실시간 렌더링 속도를 유지하면서도 사진과 같은 품질을 달성하게 만드는 근원적인 엔진이며, 향후 로봇이 미지의 환경에서 스스로 맵을 확장하고 정밀화하는 SLAM 기술의 핵심 메커니즘으로 발전할 잠재력을 내포하고 있다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>Enhanced 3D Gaussian Splatting for Real-Scene Reconstruction via Depth Priors, Adaptive Densification, and Denoising - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC12656154/</li>
<li>3D Gaussian Splatting for Real-Time Radiance Field Rendering | Qiang Zhang, https://zhangtemplar.github.io/3d-gaussian-splatting/</li>
<li>Original reference implementation of “3D Gaussian Splatting for Real-Time Radiance Field Rendering” - GitHub, https://github.com/graphdeco-inria/gaussian-splatting</li>
<li>Does Gaussian Splatting need SFM Initialization? - arXiv, https://arxiv.org/html/2404.12547v2</li>
<li>Relaxing Accurate Initialization Constraint for 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2403.09413v1</li>
<li>Liberated-GS: 3D Gaussian Splatting Independent from SfM Point Clouds, https://openaccess.thecvf.com/content/ICCV2025/papers/Pan_Liberated-GS_3D_Gaussian_Splatting_Independent_from_SfM_Point_Clouds_ICCV_2025_paper.pdf</li>
<li>3D Gaussian Splatting for Real-Time Radiance Field … - arXiv, https://arxiv.org/pdf/2308.04079</li>
<li>A Comprehensive Overview of Gaussian Splatting | by Kate Feingold (Yurkova) - Medium, https://medium.com/data-science/a-comprehensive-overview-of-gaussian-splatting-e7d570081362</li>
<li>From NeRF to Gaussian Splatting: The Next Phase in 3D Reconstruction | by Sabri Blm, https://medium.com/@sabriblm/beyond-voxels-and-nerfs-the-gaussian-revolution-in-3d-vision-8fec95f86be1</li>
<li>Gaussian Splatting [Part 2: Representation and Initialization] | by yAIn | Medium, https://medium.com/@yianyao1994/gaussian-splatting-part-2-representation-and-initialization-c0a036adf16e</li>
<li>VoD-3DGS: View-opacity-Dependent 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2501.17978v1</li>
<li>Improving Densification in 3D Gaussian Splatting for High-Fidelity Rendering - arXiv, https://arxiv.org/html/2508.12313v1</li>
<li>SGF-SLAM: Semantic Gaussian Filtering SLAM for Urban Road Environments - MDPI, https://www.mdpi.com/1424-8220/25/12/3602</li>
<li>Improving Adaptive Density Control for 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2503.14274v1</li>
<li>High-Fold 3D Gaussian Splatting Model Pruning Method Assisted by Opacity - MDPI, https://www.mdpi.com/2076-3417/15/3/1535</li>
<li>A Python Engineer’s Introduction to 3D Gaussian Splatting (Part 3) | Towards Data Science, https://towardsdatascience.com/a-python-engineers-introduction-to-3d-gaussian-splatting-part-3-398d36ccdd90/</li>
<li>Efficient Density Control for 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2411.10133v2</li>
<li>3D Gaussian Splatting for Real-Time Radiance Field Rendering - Inria, https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf</li>
<li>Three-Dimensional MRI Reconstruction with 3D Gaussian Representations: Tackling the Undersampling Problem - IEEE Xplore, https://ieeexplore.ieee.org/iel8/42/4359023/11289574.pdf</li>
<li>ResGS: Residual Densification of 3D Gaussian for Efficient Detail Recovery - CVF Open Access, https://openaccess.thecvf.com/content/ICCV2025/papers/Lyu_ResGS_Residual_Densification_of_3D_Gaussian_for_Efficient_Detail_Recovery_ICCV_2025_paper.pdf</li>
<li>SAGS: Structure-Aware 3D Gaussian Splatting Supplementary Material - European Computer Vision Association, https://www.ecva.net/papers/eccv_2024/papers_ECCV/papers/02887-supp.pdf</li>
<li>LP-3DGS: Learning to Prune 3D Gaussian Splatting - NIPS papers, https://proceedings.neurips.cc/paper_files/paper/2024/file/dd51dbce305433cd60910dc5b0147be4-Paper-Conference.pdf</li>
<li>Trimming the Fat: Efficient Compression of 3D Gaussian Splats through Pruning - BMVA Archive, https://bmva-archive.org.uk/bmvc/2024/papers/Paper_358/paper.pdf</li>
<li>Opacity-Gradient Driven Density Control for Compact and Efficient Few-Shot 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2510.10257v1</li>
<li>gaussian-splatting/train.py at main - GitHub, https://github.com/graphdeco-inria/gaussian-splatting/blob/main/train.py</li>
<li>Efficient Perspective-Correct 3D Gaussian Splatting Using Hybrid Transparency - arXiv, https://arxiv.org/html/2410.08129v2</li>
<li>3D Gaussian Splatting for Fine-Detailed Surface Reconstruction in Large-Scale Scene - arXiv, https://arxiv.org/pdf/2506.17636</li>
<li>Two‑Stage Gaussian Splatting Optimization for Outdoor Scene Reconstruction - arXiv, https://arxiv.org/html/2510.09489v1</li>
<li>Efficient Density Control for 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2411.10133v4</li>
<li>Revising Densification in Gaussian Splatting - European Computer Vision Association, https://www.ecva.net/papers/eccv_2024/papers_ECCV/papers/08041.pdf</li>
<li>DECOMPOSING DENSIFICATION IN GAUSSIAN SPLAT- TING FOR FASTER 3D SCENE RECONSTRUCTION - OpenReview, https://openreview.net/pdf/f8b3b0d66d15bbdccd4be165ab7c7ce33632831e.pdf</li>
<li>Revising Densification in Gaussian Splatting - arXiv, https://arxiv.org/html/2404.06109v1</li>
<li>LITEGS: A HIGH-PERFORMANCE FRAMEWORK TO TRAIN 3DGS IN SUBMINUTES VIA SYSTEM AND AL - OpenReview, https://openreview.net/pdf/3bf5bb2542269a29ad0b4ff69448d02261d560ca.pdf</li>
<li>Depth-Supervised and Curvature-Optimized 3D Gaussian Splatting for Scene Reconstruction - IEEE Xplore, https://ieeexplore.ieee.org/document/11036100/</li>
<li>RestorGS: Depth-aware Gaussian Splatting for Efficient 3D Scene Restoration - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2025/papers/Qiao_RestorGS_Depth-aware_Gaussian_Splatting_for_Efficient_3D_Scene_Restoration_CVPR_2025_paper.pdf</li>
<li>Opacity-Gradient Density Control in 3DGS - Emergent Mind, https://www.emergentmind.com/topics/opacity-gradient-driven-density-control</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>