<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.4.1 NeRF를 넘어: 가우시안 타원체를 이용한 명시적 표현</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.4.1 NeRF를 넘어: 가우시안 타원체를 이용한 명시적 표현</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 5. 뉴럴 3D 표현과 렌더링 (Neural 3D Representations)</a> / <a href="index.html">5.4 실시간 렌더링의 게임 체인저: 3D Gaussian Splatting (3DGS)</a> / <span>5.4.1 NeRF를 넘어: 가우시안 타원체를 이용한 명시적 표현</span></nav>
                </div>
            </header>
            <article>
                <h1>5.4.1 NeRF를 넘어: 가우시안 타원체를 이용한 명시적 표현</h1>
<h2>1.  서론: 암시적 블랙박스에서 명시적 기하학으로의 회귀</h2>
<p>지난 수년간 컴퓨터 비전과 로보틱스 학계를 지배해 온 패러다임은 단연코 ’암시적 표현(Implicit Representation)’이었다. 2020년 Neural Radiance Fields(NeRF)의 등장 이후, 3차원 공간을 다층 퍼셉트론(Multi-Layer Perceptron, MLP)의 가중치(Weight) 속에 압축하여 표현하는 방식은 사진과 구별할 수 없는 고해상도 렌더링을 가능하게 하며 ’뉴럴 렌더링(Neural Rendering)’의 황금기를 열었다. 좌표공간 <span class="math math-inline">(x, y, z)</span>와 관측 방향 <span class="math math-inline">(\theta, \phi)</span>를 입력받아 색상 <span class="math math-inline">c</span>와 밀도 <span class="math math-inline">\sigma</span>를 출력하는 연속 함수 <span class="math math-inline">F_\Theta</span>로서 장면을 정의하는 이 방식은, 이산적(Discrete) 데이터가 갖는 해상도 제약과 계단 현상(Aliasing)을 수학적으로 우아하게 해결한 것처럼 보였다.</p>
<p>그러나 로봇 공학(Robotics)과 Embodied AI의 관점에서 NeRF는 치명적인 역설을 안고 있다. 로봇이 물리적 세계와 상호작용하기 위해서는 환경이 시각적으로 아름다운 것을 넘어, 기하학적으로 명확하고 연산 효율적이어야 한다. 하지만 NeRF는 공간의 정보를 신경망이라는 블랙박스 안에 숨겨둔다. 로봇이 전방의 장애물까지의 거리를 알기 위해서는 수백 번의 신경망 추론과 광선 투사(Ray-marching)를 수행해야 하며, 이는 제한된 컴퓨팅 자원을 가진 엣지 디바이스(Edge Device)에서 실시간 처리를 불가능하게 만든다. 또한, 신경망의 가중치 속에 분산되어 저장된 기하학 정보는 특정 물체만을 수정하거나 제거하는 국소적 편집(Local Editing)을 어렵게 만들며, 로봇의 충돌 방지나 경로 계획에 필요한 확정적인 점유(Occupancy) 정보를 제공하는 데 한계를 드러냈다.</p>
<p>이러한 배경에서 2023년 등장한 **3D Gaussian Splatting (3DGS)**은 암시적 표현의 한계를 극복하고 다시금 ’명시적 표현(Explicit Representation)’의 가치를 재조명하는 계기가 되었다.1 3DGS는 장면을 신경망이 아닌, 수백만 개의 **3D 가우시안 타원체(3D Gaussian Ellipsoids)**들의 집합으로 표현한다. 이는 과거 컴퓨터 그래픽스에서 사용되던 점 구름(Point Cloud)이나 서펠(Surfel) 기반 렌더링의 현대적 재해석이자, 미분 가능한 렌더링(Differentiable Rendering) 기술과의 결합을 통해 최적화 가능한 기하학적 원자(Atom)를 제시한 것이다.</p>
<p>본 장에서는 NeRF의 한계를 넘어, 3D 가우시안 타원체를 이용한 명시적 표현이 로보틱스에 갖는 함의와 그 수학적 본질을 심도 있게 분석한다. 특히 가우시안 분포의 통계적 특성이 어떻게 3차원 기하학의 기본 단위가 될 수 있는지, 그리고 이것이 어떻게 로봇의 실시간 지각(Perception) 및 제어(Control)와 연결되는지를 중점적으로 논한다.</p>
<h2>2.  암시적 필드와 명시적 타원체의 구조적 대립</h2>
<p>로봇을 위한 3D 표현은 크게 두 가지 상충하는 요구사항을 만족해야 한다. 첫째는 **표현력(Expressivity)**으로, 복잡한 현실 세계의 미세한 구조와 조명 효과를 누락 없이 담아내야 한다. 둘째는 **효율성(Efficiency)**으로, 로봇의 제어 주기에 맞춰 실시간으로 쿼리(Query)가 가능해야 하며 메모리 사용량이 관리 가능해야 한다.</p>
<h3>2.1  NeRF의 구조적 한계: 연속성의 비용</h3>
<p>NeRF로 대표되는 좌표 기반 뉴럴 네트워크(Coordinate-based Neural Networks)는 ’연속성’을 얻는 대신 ’직접 접근성’을 희생했다. NeRF에서 빈 공간(Empty Space)과 물체가 있는 공간은 동일하게 네트워크의 입력 도메인일 뿐이다. 렌더링을 위해서는 빈 공간일지라도 무수히 많은 샘플링을 수행해야 비로소 그곳이 비어있음을 알 수 있다.1 이는 로봇의 SLAM(Simultaneous Localization and Mapping)이나 내비게이션에 있어 막대한 연산 낭비를 초래한다.</p>
<p>또한, NeRF는 기하학적 표면(Surface)을 명시적으로 정의하지 않는다. 대신 확률적 밀도 함수(Probability Density Function)를 통해 불투명도를 누적할 뿐이다. 로봇 팔이 물체를 잡기(Grasping) 위해서는 물체의 표면 좌표가 명확해야 하는데, NeRF에서 이를 얻기 위해서는 Marching Cubes와 같은 별도의 후처리 알고리즘을 통해 등위면(Iso-surface)을 추출해야 하며, 이 과정에서 품질 저하나 추가적인 지연시간(Latency)이 발생한다.4</p>
<h3>2.2  3DGS의 제안: 최적화 가능한 이산적 원자</h3>
<p>3DGS는 장면을 <span class="math math-inline">N</span>개의 3D 가우시안 <span class="math math-inline">G = {g_1, g_2, \dots, g_N}</span>의 집합으로 정의한다. 여기서 각 가우시안 <span class="math math-inline">g_i</span>는 공간상의 위치뿐만 아니라 크기, 방향, 투명도, 색상 정보를 포함하는 데이터 구조체이다.6 이는 다음과 같은 구조적 이점을 갖는다.</p>
<ol>
<li><strong>공간적 희소성(Spatial Sparsity)의 활용:</strong> 데이터가 없는 빈 공간에는 가우시안이 존재하지 않는다. 따라서 렌더링이나 충돌 계산 시 불필요한 연산을 수행할 필요가 없다. 이는 NeRF가 겪는 ‘빈 공간 샘플링’ 문제를 원천적으로 해결한다.1</li>
<li><strong>직접적인 조작 가능성:</strong> 각 가우시안은 독립적인 메모리 블록에 저장된다. 따라서 특정 영역의 가우시안을 삭제하거나 이동시키는 것만으로도 장면의 편집이 가능하다. 이는 동적 환경(Dynamic Environment)에서 움직이는 물체를 추적하거나 업데이트해야 하는 로봇에게 결정적인 이점이다.8</li>
<li><strong>래스터라이제이션(Rasterization) 친화적:</strong> 가우시안은 GPU의 래스터라이제이션 파이프라인에 태우기에 최적화된 형태다. 3D 공간의 타원체를 2D 화면에 투영(Splatting)하는 과정은 정렬(Sorting)과 알파 블렌딩(Alpha Blending)만으로 이루어지며, 이는 신경망 추론 없이 순수 행렬 연산만으로 처리되기에 압도적인 렌더링 속도(100 FPS 이상)를 보장한다.4</li>
</ol>
<p>아래 표는 로보틱스 관점에서 NeRF와 3DGS의 특성을 비교 분석한 것이다.</p>
<table><thead><tr><th><strong>비교 차원</strong></th><th><strong>NeRF (Implicit Neural Fields)</strong></th><th><strong>3D Gaussian Splatting (Explicit Primitives)</strong></th></tr></thead><tbody>
<tr><td><strong>기본 단위</strong></td><td>다층 퍼셉트론 (MLP) 가중치</td><td>3D 가우시안 타원체 파라미터 <span class="math math-inline">(\mu, \Sigma, \alpha, SH)</span></td></tr>
<tr><td><strong>공간 표현</strong></td><td>연속적 함수 (Continuous Function)</td><td>이산적 군집 (Discrete Cloud)</td></tr>
<tr><td><strong>렌더링 방식</strong></td><td>광선 투사 (Ray-marching)</td><td>래스터라이제이션 (Rasterization)</td></tr>
<tr><td><strong>빈 공간 처리</strong></td><td>샘플링 필요 (비효율적)</td><td>계산 생략 (효율적)</td></tr>
<tr><td><strong>표면 정의</strong></td><td>확률적 밀도 (Iso-surface 추출 필요)</td><td>명시적 타원체 경계 (Implicit Surface 정의 가능)</td></tr>
<tr><td><strong>충돌 감지</strong></td><td>3D 쿼리 필요 (느림)</td><td>타원체-타원체 교차 검사 (빠름, 미분 가능)</td></tr>
<tr><td><strong>메모리</strong></td><td>작음 (네트워크 크기 의존)</td><td>큼 (가우시안 개수 비례, VRAM 소모 높음)</td></tr>
<tr><td><strong>학습/추론</strong></td><td>학습 오래 걸림 / 추론 느림</td><td>학습 빠름 / 추론 실시간</td></tr>
</tbody></table>
<h2>3.  3D 가우시안의 수학적 해부: 기하학의 원자</h2>
<p>3DGS의 핵심은 장면을 구성하는 기본 단위인 ’3D 가우시안’을 어떻게 정의하고 파라미터화하느냐에 있다. 통계학에서 확률 분포를 나타내는 가우시안 함수가 여기서는 물리적인 부피와 형태를 가진 ’타원체(Ellipsoid)’로 재해석된다. 하나의 가우시안 <span class="math math-inline">g_i</span>는 다음과 같은 파라미터 튜플로 구성된다.7<br />
<span class="math math-display">
g_i = \langle \mu_i, \Sigma_i, \alpha_i, \mathbf{c}_i \rangle
</span><br />
여기서 각 요소는 로봇이 환경을 이해하는 데 필요한 위치, 형상, 존재 확률, 재질 정보를 담고 있다.</p>
<h3>3.1  위치 벡터 (Mean, <span class="math math-inline">\mu</span>)와 로봇의 위치 추정</h3>
<p><span class="math math-inline">\mu \in \mathbb{R}^3</span>는 가우시안의 중심좌표 <span class="math math-inline">(x, y, z)</span>를 의미한다. 이는 점 구름(Point Cloud)의 점과 동일한 역할을 하지만, 단순한 점이 아니라 주변으로 퍼져나가는 영향력의 중심이라는 점에서 차이가 있다.</p>
<p>로봇 공학의 관점에서 <span class="math math-inline">\mu</span>는 환경 지도의 랜드마크(Landmark) 역할을 수행한다. SLAM 시스템에서 특징점(Feature Point)을 추출하여 매칭하는 것과 유사하게, 3DGS의 <span class="math math-inline">\mu</span>는 최적화 과정에서 영상의 특징과 일치하도록 끊임없이 이동하며 정렬된다.3 초기화 단계에서는 SfM(Structure from Motion)으로 생성된 희소 점 구름(Sparse Point Cloud)을 <span class="math math-inline">\mu</span>의 초기값으로 사용하는데, 이는 3DGS가 기존의 사진 측량(Photogrammetry) 파이프라인과 매끄럽게 통합될 수 있음을 시사한다.1</p>
<h3>3.2  공분산 행렬 (Covariance, <span class="math math-inline">\Sigma</span>)과 물리적 점유</h3>
<p><span class="math math-inline">\Sigma \in \mathbb{R}^{3 \times 3}</span>는 가우시안의 형상을 결정하는 가장 중요한 파라미터다. 3차원 다변량 정규 분포(Multivariate Normal Distribution)의 확률 밀도 함수는 다음과 같다.12<br />
<span class="math math-display">
G(x) = \exp \left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right)
</span><br />
이 식에서 <span class="math math-inline">\Sigma</span>는 타원체의 찌그러짐 정도와 방향을 결정한다. <span class="math math-inline">\Sigma</span>가 단위 행렬의 상수배라면 가우시안은 구(Sphere) 형태가 되지만, 3DGS는 이를 완전한 <strong>비등방성(Anisotropic)</strong> 행렬로 정의하여 길쭉한 바늘 모양이나 납작한 원반 모양 등 다양한 형상을 표현할 수 있게 한다. 이는 벽면, 얇은 전선, 나뭇잎과 같은 현실 세계의 복잡한 구조를 적은 수의 가우시안으로 효율적으로 근사하기 위해 필수적이다.13</p>
<h4>3.2.1  공분산의 분해: 회전과 크기</h4>
<p>공분산 행렬 <span class="math math-inline">\Sigma</span>는 수학적으로 반드시 <strong>양의 준정부호(Positive Semi-Definite, PSD)</strong> 행렬이어야 한다. 만약 학습 과정에서 경사 하강법(Gradient Descent)을 통해 <span class="math math-inline">\Sigma</span>의 9개 원소를 직접 업데이트한다면, 이 PSD 조건을 만족시키기 매우 어렵다. 유효하지 않은 공분산 행렬은 물리적으로 불가능한 타원체(예: 음수의 부피를 가진 형태)를 의미하며, 렌더링 파이프라인을 붕괴시킨다.7</p>
<p>이를 방지하기 위해 3DGS는 <span class="math math-inline">\Sigma</span>를 직접 최적화하는 대신, 이를 **회전(Rotation, <span class="math math-inline">R</span>)**과 **크기(Scale, <span class="math math-inline">S</span>)**로 분해하여 파라미터화한다.6<br />
<span class="math math-display">
\Sigma = R S S^T R^T
</span></p>
<ul>
<li><strong>스케일링 행렬 (<span class="math math-inline">S</span>):</strong> 3개의 스케일 파라미터 <span class="math math-inline">s \in \mathbb{R}^3</span>를 대각 원소로 갖는 대각 행렬(Diagonal Matrix)이다. <span class="math math-inline">S = \text{diag}(s_x, s_y, s_z)</span>로 표현된다. 각 성분은 타원체의 주축(Principal Axis) 길이를 결정한다. 최적화 시에는 <span class="math math-inline">s</span>가 음수가 되는 것을 막기 위해 지수 함수(Exponential) 등을 활성화 함수로 사용하여 <span class="math math-inline">s = \exp(s_{raw})</span>와 같이 처리한다.7</li>
<li><strong>회전 행렬 (<span class="math math-inline">R</span>):</strong> 타원체의 주축이 공간상에서 어느 방향을 향하는지 나타내는 <span class="math math-inline">3 \times 3</span> 직교 행렬이다. 3DGS는 9개의 원소를 가진 회전 행렬 대신, 4개의 원소로 회전을 짐벌 락(Gimbal Lock) 없이 표현할 수 있는 **사원수(Quaternion, <span class="math math-inline">q \in \mathbb{R}^4</span>)**를 사용한다. 최적화 과정에서 <span class="math math-inline">q</span>는 항상 정규화(Normalize)되어 유효한 회전 행렬 <span class="math math-inline">R</span>로 변환된다.15</li>
</ul>
<p>이러한 분해(<span class="math math-inline">\Sigma = RSS^T R^T</span>)는 기하학적으로 매우 직관적이다. 공분산 행렬의 고유값(Eigenvalue)은 <span class="math math-inline">s</span>의 제곱(<span class="math math-inline">s^2</span>)에 해당하며, 고유벡터(Eigenvector)는 <span class="math math-inline">R</span>의 열벡터(Column Vector)에 해당한다.14 로봇 공학 관점에서 이는 단순히 렌더링을 위한 수식이 아니라, 물체의 <strong>주성분 분석(PCA)</strong> 결과를 실시간으로 가지고 있는 것과 같다. 로봇은 <span class="math math-inline">R</span>과 <span class="math math-inline">S</span>를 통해 장애물의 긴 축 방향이나 표면의 법선 벡터(Normal Vector)를 추정할 수 있으며, 이는 파지(Grasping) 계획이나 충돌 회피 경로 생성에 직접적으로 활용될 수 있다.16</p>
<h3>3.3  불투명도 (Opacity, <span class="math math-inline">\alpha</span>)와 존재 확률</h3>
<p>$\alpha \in $는 해당 가우시안이 광선을 얼마나 차단하는지를 나타낸다. 이는 부드러운 경계(Soft Boundary)를 표현하게 해주어, 머리카락이나 연기 같은 반투명한 물체 혹은 물체 경계의 앤티앨리어싱(Anti-aliasing) 효과를 자연스럽게 처리한다.18 학습 시에는 시그모이드(Sigmoid) 함수를 통해 <span class="math math-inline">0</span>과 <span class="math math-inline">1</span> 사이로 매핑된다.</p>
<p>로봇 내비게이션에서 <span class="math math-inline">\alpha</span>는 ‘점유 확률’ 또는 ’신뢰도’로 해석될 수 있다. <span class="math math-inline">\alpha</span> 값이 매우 낮은 가우시안은 노이즈일 가능성이 높으므로, 로봇은 특정 임계값(예: <span class="math math-inline">\alpha &gt; 0.5</span>) 이상의 가우시안만을 장애물로 간주하는 필터링 전략을 취할 수 있다. 실제로 3DGS의 학습 과정에서도 <span class="math math-inline">\alpha</span>가 특정 임계값 이하로 떨어지는 가우시안을 주기적으로 제거(Pruning)하여 메모리 효율을 높인다.10</p>
<h3>3.4  구면 조화 함수 (Spherical Harmonics, SH)와 시각적 리얼리즘</h3>
<p>현실 세계의 물체는 보는 각도에 따라 색상이 변한다. 이를 <strong>뷰 의존적(View-Dependent)</strong> 효과라고 하며, 금속의 반사광(Specular Highlight)이나 난반사 재질의 명암 변화가 이에 해당한다. 단순히 RGB 값을 고정하면 이러한 효과를 낼 수 없다. NeRF는 이를 위해 보는 방향 <span class="math math-inline">d</span>를 네트워크의 입력으로 넣었지만, 3DGS는 각 가우시안에 **구면 조화 함수(Spherical Harmonics, SH)**의 계수(Coefficients)를 저장하는 방식을 택했다.11</p>
<p>색상 <span class="math math-inline">C(v)</span>는 보는 방향 <span class="math math-inline">v</span>에 대한 함수로 다음과 같이 정의된다.<br />
<span class="math math-display">
C(v) = \sum_{l=0}^{L_{max}} \sum_{m=-l}^{l} k_{lm} Y_{lm}(v)
</span></p>
<ul>
<li><span class="math math-inline">Y_{lm}</span>: 구면 조화 기저 함수(Basis Function). 구 표면에서 정의된 직교 함수들이다.</li>
<li><span class="math math-inline">k_{lm}</span>: 학습되는 계수(Coefficient). 각 가우시안이 이 계수들을 저장한다.</li>
<li><span class="math math-inline">L_{max}</span>: SH의 차수(Degree).</li>
</ul>
<p>일반적으로 3DGS는 3차(<span class="math math-inline">L_{max}=3</span>) SH를 사용한다. 0차(<span class="math math-inline">l=0</span>)는 모든 방향에서 동일한 색(Diffuse)을 나타내며 1개의 계수를 갖는다. 1차는 3개, 2차는 5개, 3차는 7개의 계수를 가져, 총 <span class="math math-inline">1+3+5+7 = 16</span>개의 계수가 필요하다. RGB 3채널이므로 가우시안 하나당 <span class="math math-inline">16 \times 3 = 48</span>개의 부동소수점 숫자를 추가로 저장해야 한다.20</p>
<p>로보틱스를 위한 경량화 이슈:</p>
<p>48개의 추가 파라미터는 메모리 대역폭에 큰 부담을 준다. 로봇의 자율 주행이나 물체 인식과 같은 작업에서는 완벽한 반사광 재현보다는 물체의 고유 색상(Albedo)과 형상이 더 중요할 수 있다. 따라서 로보틱스 응용에서는 SH 차수를 0차(단순 RGB)나 1차로 낮춰 메모리 사용량을 획기적으로 줄이거나(48개 <span class="math math-inline">\to</span> 3개 혹은 12개), SH 대신 다른 경량화된 색상 표현 모델을 사용하는 연구가 활발히 진행되고 있다.20 이는 ‘5.4.4 로봇 탑재를 위한 경량화’ 절에서 더 상세히 다룰 주제와 연결된다.</p>
<h2>4.  3D에서 2D로: 투영 기하학 (Projection Geometry)</h2>
<p>3D 가우시안이 명시적으로 정의되었다 하더라도, 이를 카메라 시점에서 2D 이미지로 렌더링하는 과정이 느리다면 실시간 로봇 제어에 사용할 수 없다. 3DGS의 혁신은 3차원 타원체를 2D 평면에 투영하는 과정을 미분 가능한 닫힌 형태(Closed-form)의 수식으로 유도했다는 점에 있다. 이를 <strong>EWA(Elliptical Weighted Average) Splatting</strong>이라고 한다.1</p>
<h3>4.1  뷰 변환과 투영 (View Transformation and Projection)</h3>
<p>월드 좌표계의 가우시안 중심 <span class="math math-inline">\mu</span>는 뷰 변환 행렬 <span class="math math-inline">W</span> (World-to-Camera)에 의해 카메라 좌표계로 변환된다. 그러나 타원체 전체를 비선형적인 원근 투영(Perspective Projection) 변환에 통과시키면, 그 결과는 더 이상 가우시안 분포(타원 형태)가 아니게 된다. 이는 수학적으로 다루기 매우 복잡하다.</p>
<p>3DGS는 이를 해결하기 위해 투영 변환을 국소적으로 선형화(Linearization)하는 근사법을 사용한다. 즉, 가우시안 중심 <span class="math math-inline">\mu</span> 근처에서의 투영 함수의 **자코비안(Jacobian) 행렬 <span class="math math-inline">J</span>**를 이용하여 3D 공분산 <span class="math math-inline">\Sigma</span>를 2D 이미지 평면의 공분산 <span class="math math-inline">\Sigma&#39;</span>로 변환한다.23<br />
<span class="math math-display">
\Sigma&#39; = J W \Sigma W^T J^T
</span><br />
여기서 <span class="math math-inline">J</span>는 카메라 좌표계의 점 <span class="math math-inline">t = (t_x, t_y, t_z)</span>를 이미지 평면 <span class="math math-inline">(u, v)</span>로 투영하는 함수의 편미분 행렬이다. 초점 거리를 <span class="math math-inline">f_x, f_y</span>라 할 때, <span class="math math-inline">J</span>는 다음과 같은 희소 행렬(Sparse Matrix) 형태를 띤다.23<br />
<span class="math math-display">
J = \begin{bmatrix} \frac{f_x}{t_z} &amp; 0 &amp; -\frac{f_x t_x}{t_z^2} \\ 0 &amp; \frac{f_y}{t_z} &amp; -\frac{f_y t_y}{t_z^2} \end{bmatrix}
</span><br />
이 수식은 물리적으로 매우 중요한 의미를 갖는다.</p>
<ol>
<li><strong>거리 반비례 (<span class="math math-inline">1/t_z</span>):</strong> 물체가 멀어질수록(<span class="math math-inline">t_z</span> 증가), 2D 공분산 <span class="math math-inline">\Sigma&#39;</span>의 크기는 작아진다. 즉, 멀리 있는 가우시안은 화면에서 작게 보인다.</li>
<li><strong>시선 각도 보정:</strong> 행렬의 마지막 열은 가우시안이 카메라 정면이 아닌 가장자리에 있을 때의 시야각 왜곡을 보정해준다.</li>
</ol>
<p>결과적으로 계산된 <span class="math math-inline">\Sigma&#39;</span>는 <span class="math math-inline">2 \times 2</span> 행렬이 되며, 이는 이미지 평면상에서의 타원(Splat)의 모양과 크기를 완벽하게 정의한다. 이 변환 과정은 행렬 곱셈만으로 이루어지므로 GPU에서 극도로 빠르게 처리된다.23</p>
<h3>4.2  자코비안 근사의 로봇 응용적 함의</h3>
<p>이러한 선형 근사(Affine approximation)는 렌더링 속도를 높이는 핵심이지만, 동시에 로봇 센서 모델링에도 적용될 수 있다. 예를 들어, 라이다(LiDAR) 센서의 불확실성 모델링이나 카메라 기반의 시각 서보잉(Visual Servoing) 제어 시, 물체 표면의 불확실성을 이미지 평면에 투영하여 **불확실성 타원(Uncertainty Ellipse)**을 실시간으로 추정하는 데 이 수식을 그대로 활용할 수 있다. 로봇은 <span class="math math-inline">\Sigma&#39;</span>의 고유값(Eigenvalue)을 분석하여 인식된 물체의 위치 불확실성이 어느 방향으로 큰지 파악하고, 이를 줄이기 위해 카메라를 이동시키는 능동적 지각(Active Perception) 전략을 수립할 수 있다.17</p>
<h2>5.  명시적 표현이 여는 로보틱스의 새로운 지평</h2>
<p>가우시안 타원체 기반의 명시적 표현은 단순히 NeRF보다 빠른 렌더러가 아니다. 이는 로봇이 세상을 이해하고 상호작용하는 방식을 근본적으로 바꿀 잠재력을 지니고 있다.</p>
<h3>5.1  충돌 감지와 안전한 경로 계획 (Collision Detection &amp; Safety)</h3>
<p>로봇 주행 및 조작(Manipulation)에서 가장 중요한 것은 충돌 방지다. NeRF와 같은 암시적 표현에서는 충돌을 감지하기 위해 공간상의 모든 점에 대해 밀도를 조회해야 하므로 계산 비용이 너무 높다. 반면 3DGS에서는 환경이 타원체들의 집합으로 표현되므로, 로봇 자체의 형상(역시 타원체로 근사 가능)과 환경 가우시안들 간의 **타원체 교차 검사(Ellipsoid Intersection Test)**를 통해 충돌 여부를 매우 빠르게 판단할 수 있다.26</p>
<p>특히 가우시안의 공분산 <span class="math math-inline">\Sigma</span>는 통계적 신뢰 구간을 의미하므로, 로봇은 <span class="math math-inline">3\sigma</span> (99.7% 신뢰 구간) 타원체를 ’확실한 장애물’로 간주하고, <span class="math math-inline">1\sigma</span> 타원체를 ’주의 영역’으로 설정하는 등 확률적 안전 경로 계획(Probabilistic Path Planning)을 수행할 수 있다. 이는 자율 주행 차량이나 협동 로봇이 불확실한 환경에서 안전을 보장하는 데 핵심적인 기능을 제공한다.25</p>
<h3>5.2  의미론적 정보의 통합과 오픈 보캐블러리 (Semantic Integration)</h3>
<p>명시적 표현의 또 다른 장점은 데이터 구조의 확장성이다. 각 가우시안 <span class="math math-inline">g_i</span>는 독립적인 개체이므로, 여기에 색상 정보 외에 **의미론적 라벨(Semantic Label)**이나 특징 벡터(Feature Vector)를 추가적인 속성으로 부착하기가 매우 쉽다.</p>
<p>예를 들어, ’책상’에 해당하는 가우시안들에게는 class_id = desk를, ’바닥’에는 class_id = floor를 할당할 수 있다. 이렇게 하면 렌더링 과정에서 색상뿐만 아니라 의미론적 분할(Semantic Segmentation) 맵을 실시간으로 생성할 수 있으며, 로봇은 “책상 위의 컵을 가져와“와 같은 언어 명령을 수행할 때 3D 공간상에서 직접 대상 가우시안을 식별하고 조작할 수 있게 된다.10 이는 CLIP이나 DINO와 같은 대형 비전-언어 모델(VLM)의 특징을 가우시안에 증류(Distillation)하여 ’Open-Vocabulary 3D Scene Understanding’을 구현하는 연구로 이어지고 있다.</p>
<h3>5.3  동적 환경의 실시간 업데이트</h3>
<p>마지막으로, 명시적 표현은 동적 환경 적응에 유리하다. 3DGS 기반의 SLAM 시스템은 새로운 관측이 들어올 때마다 기존 가우시안의 위치를 미세 조정하거나, 새로운 가우시안을 추가하고, 오차가 큰 가우시안을 삭제하는 방식으로 지도를 업데이트한다. 이는 전체 네트워크를 재학습해야 하는 NeRF와 달리, 국소적인 업데이트만으로 지도 작성이 가능함을 의미한다. 실제로 최신 연구들은 3DGS를 이용하여 100 FPS 이상의 속도로 밀도 높은 지도를 생성하고 추적하는 SLAM 시스템을 선보이고 있다.5</p>
<h2>6.  결론</h2>
<p>5.4.1절에서는 3D Gaussian Splatting이 제시하는 명시적 표현의 본질을 탐구하였다. 가우시안 타원체는 연속적인 공간의 부드러움을 유지하면서도, 이산적인 데이터 구조가 갖는 조작의 용이성과 연산 효율성을 동시에 달성한, 하이브리드 표현의 정점이라 할 수 있다.</p>
<p>수학적으로 분해된 공분산 행렬 <span class="math math-inline">\Sigma = RSS^T</span>와 자코비안 기반의 투영 기법 <span class="math math-inline">J W \Sigma W^T J^T</span>은 이 복잡한 3차원 데이터를 실시간 래스터라이제이션 파이프라인에 완벽하게 통합시켰다. 로봇 공학자들에게 3DGS는 단순한 시각화 도구가 아니다. 그것은 희소하고(Sparse), 확률적이며(Probabilistic), 미분 가능하고(Differentiable), 의미론적으로 확장 가능한(Semantically Extensible) 차세대 3차원 지도(Map) 형식이다.</p>
<p>이어지는 ’5.4.2 미분 가능한 래스터라이제이션과 초고속 렌더링’에서는 이러한 수학적 모델이 실제 GPU 하드웨어 상에서 어떻게 병렬 처리 알고리즘으로 구현되어 NeRF 대비 수백 배의 속도를 달성하는지, 그 구체적인 알고리즘적 설계를 분석할 것이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>3D Gaussian Splatting for Real-Time Radiance Field Rendering - Inria, https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/</li>
<li>TUM AI Lecture Series - The 3D Gaussian Splatting Adventure: Past, Present, Futur (George Drettakis) - YouTube, https://www.youtube.com/watch?v=DjOqkVIlEGY</li>
<li>Original reference implementation of “3D Gaussian Splatting for Real-Time Radiance Field Rendering” - GitHub, https://github.com/graphdeco-inria/gaussian-splatting</li>
<li>Novel view synthesis, NeRF vs Gaussian splatting : r/computervision - Reddit, https://www.reddit.com/r/computervision/comments/1if2w7f/novel_view_synthesis_nerf_vs_gaussian_splatting/</li>
<li>The Innovative Impact of NeRF and 3D Gaussian Splatting Technologies on SLAM and Robotics - Oreate AI Blog, https://www.oreateai.com/blog/the-innovative-impact-of-nerf-and-3d-gaussian-splatting-technologies-on-slam-and-robotics/5715481554b31f972fdff32bfd96a86a</li>
<li>Gaussian splatting - Wikipedia, https://en.wikipedia.org/wiki/Gaussian_splatting</li>
<li>A Comprehensive Overview of Gaussian Splatting - Towards Data Science, https://towardsdatascience.com/a-comprehensive-overview-of-gaussian-splatting-e7d570081362/</li>
<li>3D Gaussian Splatting vs NeRF: Neural Rendering Methods Compared | THE FUTURE 3D, https://www.thefuture3d.com/equipment/compare/3d-gaussian-splatting-vs-nerf/</li>
<li>dtc111111/awesome-representation-for-robotics - GitHub, https://github.com/dtc111111/awesome-representation-for-robotics</li>
<li>3D Gaussian Splatting in Robotics: A Survey - arXiv, https://arxiv.org/html/2410.12262v2</li>
<li>1월 18, 2026에 액세스, [https://www.mdpi.com/2076-3417/15/3/1535#:<sub>:text=These%20Gaussian%20points%20include%20parameters,fast%20and%20efficient%20scene%20rendering.](https://www.mdpi.com/2076-3417/15/3/1535#:</sub>:text=These Gaussian points include parameters, <a href="https://www.mdpi.com/2076-3417/15/3/1535#:~:text=These%20Gaussian%20points%20include%20parameters,fast%20and%20efficient%20scene%20rendering.">https://www.mdpi.com/2076-3417/15/3/1535#:~:text=These%20Gaussian%20points%20include%20parameters,fast%20and%20efficient%20scene%20rendering.</a></li>
<li>A repository on how to understand the theory of 3D Gaussians Splatting - GitHub, https://github.com/chiehwangs/3d-gaussian-theory</li>
<li>3D Gaussian Splatting for Real-Time Radiance Field Rendering - Inria, https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf</li>
<li>3D Gaussian Splatting - Paper Explained, Training NeRFStudio - Learn OpenCV, https://learnopencv.com/3d-gaussian-splatting/</li>
<li>A Python Engineer’s Introduction to 3D Gaussian Splatting (Part 2) - Medium, https://medium.com/data-science/a-python-engineers-introduction-to-3d-gaussian-splatting-part-2-7e45b270c1df</li>
<li>FeatureGS: Eigenvalue-Feature Optimization in 3D Gaussian Splatting for Geometrically Accurate and Artifact-Reduced Reconstruction - arXiv, https://arxiv.org/html/2501.17655v1</li>
<li>InnerGS: Internal Scenes Rendering via Factorized 3D Gaussian Splatting - arXiv, https://arxiv.org/html/2508.13287v1</li>
<li>Exploring 3D Gaussian Splatting - by Thibaut CHAUFFIER - Medium, https://medium.com/@thibaut.chauffier/exploring-3d-gaussian-splatting-e50b8c9cee93</li>
<li>Explore how Spherical Harmonics enhance Neural Radiance Fields and 3D Gaussian Splatting by optimizing inference speed - Papers in 100 Lines of Code, https://papers-100-lines.medium.com/explore-how-spherical-harmonics-enhance-neural-radiance-fields-and-3d-gaussian-splatting-by-b33fc755bfc5</li>
<li>SG-Splatting: Accelerating 3D Gaussian Splatting with Spherical Gaussians - arXiv, https://arxiv.org/html/2501.00342v1</li>
<li>On the Impacts of Spherical Harmonics and Gaussian Counts in WebGL-Based 3-D Gaussian Splatting - IEEE Computer Society, https://www.computer.org/csdl/magazine/ic/2025/03/11029135/27pwKaa6Mve</li>
<li>Textured-GS: Gaussian Splatting with Spatially Defined Color and Opacity - arXiv, https://arxiv.org/html/2407.09733v1</li>
<li>Rendering in 3D Gaussian Splatting - Scthe’s blog, https://www.sctheblog.com/blog/gaussian-splatting/</li>
<li>Gaussian Splatting: An Introduction, https://www.ipol.im/pub/art/2025/566/article.pdf</li>
<li>Splat-Nav: Safe Real-Time Robot Navigation in Gaussian Splatting Maps - arXiv, https://arxiv.org/html/2403.02751v1</li>
<li>Robotic Learning in your Backyard: A Neural Simulator from Open Source Components, https://ieeexplore.ieee.org/document/10817965/</li>
<li>Let’s Make a Splan: Risk-Aware Trajectory Optimization in a Normalized Gaussian Splat - OpenReview, https://openreview.net/pdf/2fda1de800289f7ea9d00d87c888b1c9a4975530.pdf</li>
<li>12 Predictions for Embodied AI and Robotics in 2026 | Dylan Bourgeois, https://dtsbourg.me/en/articles/predictions-embodied-ai</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>