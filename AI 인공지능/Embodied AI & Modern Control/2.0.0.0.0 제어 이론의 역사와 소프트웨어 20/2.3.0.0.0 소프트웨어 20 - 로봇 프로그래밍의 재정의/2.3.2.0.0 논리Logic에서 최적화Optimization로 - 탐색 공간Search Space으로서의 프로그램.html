<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.3.2 논리(Logic)에서 최적화(Optimization)로: 탐색 공간(Search Space)으로서의 프로그램</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.3.2 논리(Logic)에서 최적화(Optimization)로: 탐색 공간(Search Space)으로서의 프로그램</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.3 소프트웨어 2.0: 로봇 프로그래밍의 재정의</a> / <span>2.3.2 논리(Logic)에서 최적화(Optimization)로: 탐색 공간(Search Space)으로서의 프로그램</span></nav>
                </div>
            </header>
            <article>
                <h1>2.3.2 논리(Logic)에서 최적화(Optimization)로: 탐색 공간(Search Space)으로서의 프로그램</h1>
<h2>1. 서론: 프로그래밍 패러다임의 위상학적 전환</h2>
<p>로봇 공학의 역사, 더 나아가 컴퓨터 과학의 역사 전반에 걸쳐 ’프로그램’이라는 단어는 인간의 지적 노동이 명시적으로 서술된 논리의 집합체를 의미했다. 고전적인 제어 이론에서부터 현대의 소프트웨어 공학에 이르기까지, 엔지니어의 역할은 문제 해결을 위한 알고리즘을 고안하고 이를 프로그래밍 언어라는 도구를 통해 기계가 이해할 수 있는 명령어로 번역하는 것이었다. 이러한 ’Software 1.0’의 세계에서 소스 코드는 프로그래머의 사고 과정을 그대로 반영한 거울이며, 모든 <code>if</code> 문과 <code>for</code> 루프는 개발자가 사전에 예측한 상황에 대한 대응책이다.1 그러나 물리 세계의 복잡성과 불확실성이 증가함에 따라, 이러한 명시적 논리 작성 방식은 ’모델링 병목(Modeling Bottleneck)’이라는 거대한 장벽에 직면하게 되었다. 로봇이 마주하는 환경은 무한히 가변적이며, 이를 유한한 줄의 코드로 모두 예단하여 기술하는 것은 불가능에 가깝다.2</p>
<p>이제 우리는 ’Software 2.0’이라 불리는 새로운 패러다임의 도래를 목격하고 있다. 안드레이 카패시(Andrej Karpathy)가 제창한 이 개념은 프로그램을 인간이 작성하는 논리적 서술(Logic)이 아니라, 거대한 탐색 공간(Search Space) 내에서 발견해야 할 최적의 점(Point)으로 재정의한다.1 이 관점에서 프로그래밍은 코드를 ’작성(Writing)’하는 행위에서, 원하는 프로그램이 존재할 수 있는 공간을 정의하고 그 안에서 최적해를 ’탐색(Searching)’하는 최적화(Optimization) 과정으로 변모한다. 본 절에서는 로봇 제어 시스템이 경직된 논리의 사슬을 끊고, 유연하고 연속적인 최적화의 공간으로 이동하는 과정을 심도 있게 분석한다. 우리는 프로그램이 어떻게 고차원 파라미터 공간상의 위상학적 실체로 변환되는지, 그리고 그 공간을 항해하기 위해 어떤 수학적 도구와 데이터 엔진이 필요한지 고찰할 것이다.</p>
<h2>2.  프로그램 공간(Program Space)의 기하학</h2>
<h3>2.1  이산적 논리에서 연속적 매니폴드(Manifold)로</h3>
<p>전통적인 로봇 제어 코드는 이산적(Discrete)이다. 유한 상태 기계(Finite State Machine, FSM)로 대표되는 고전적 제어 구조는 로봇의 상태를 정의하고, 각 상태 간의 전이(Transition) 조건을 명시적인 논리식으로 기술한다. 예를 들어, 이족 보행 로봇을 제어하기 위해 엔지니어는 ‘왼발 지지’, ‘오른발 스윙’, ’착지 충격 흡수’와 같은 상태를 나누고, 각 단계에서 수행해야 할 관절 궤적을 수동으로 설계했다.4 이러한 방식은 해석 가능성(Interpretability)이 높고 디버깅이 용이하다는 장점이 있지만, 설계자가 예상하지 못한 외란(Disturbance)이나 엣지 케이스(Edge Case)에 극도로 취약하다는 치명적인 단점을 안고 있다. 상태 공간이 커질수록 상태 전이의 규칙은 조합 폭발(Combinatorial Explosion)을 일으키며, 이를 관리하는 코드는 더 이상 인간이 인지할 수 없는 수준의 복잡도로 치닫는다.</p>
<p>Software 2.0은 이 문제를 해결하기 위해 프로그램의 정의 자체를 바꾼다. 여기서 프로그램은 신경망(Neural Network)과 같은 파라미터화된 함수(Parameterized Function)로 표현된다. 만약 어떤 신경망이 <span class="math math-inline">N</span>개의 파라미터(가중치, Weights)를 가진다면, 이 프로그램은 <span class="math math-inline">N</span>차원 유클리드 공간 <span class="math math-inline">\mathbb{R}^N</span> 상의 한 점 <span class="math math-inline">\theta</span>로 존재한다.1 이 공간을 우리는 ‘프로그램 공간(Program Space)’ 혹은 ’가중치 공간(Weight Space)’이라 부를 수 있다.</p>
<p>이 공간 내의 모든 점은 잠재적인 프로그램이다. 어떤 점은 로봇을 앞으로 걷게 하는 프로그램이고, 어떤 점은 로봇을 제자리에서 춤추게 하는 프로그램이며, 대다수의 점들은 로봇을 무작위로 경련하게 만드는 무의미한 프로그램이다. Software 1.0이 텅 빈 텍스트 에디터에서 무(無)로부터 유(有)를 창조하는 것이라면, Software 2.0은 이미 존재하는 무한한 프로그램들의 우주 속에서 우리가 원하는 기능을 수행하는 단 하나의 점 <span class="math math-inline">\theta^*</span>를 찾아내는 과정이다.</p>
<h3>2.2  탐색 공간으로서의 아키텍처와 귀납적 편향</h3>
<p>이 무한한 공간 전체를 탐색하는 것은 비효율적이다. 따라서 우리는 탐색 범위를 합리적으로 제한해야 하는데, 이것이 바로 신경망 아키텍처 설계가 수행하는 역할이다. 특정 아키텍처를 선택한다는 것은 전체 프로그램 공간 중 탐색할 하위 공간(Subspace)을 한정하는 것과 같으며, 이를 ’귀납적 편향(Inductive Bias)’이라 한다.</p>
<p>로보틱스에서 이는 로봇의 신체 구조와 물리적 특성을 반영하는 형태로 나타난다. 예를 들어, 시각 정보를 처리하기 위해 합성곱 신경망(CNN)을 사용하는 것은 이미지의 ’공간적 지역성(Spatial Locality)’과 ’이동 불변성(Translation Invariance)’이라는 제약을 탐색 공간에 부여하는 것이다. 로봇의 관절 연결 구조를 그래프 신경망(GNN)으로 모델링하거나, 시계열적인 센서 데이터 처리를 위해 순환 신경망(RNN)이나 트랜스포머(Transformer)를 사용하는 것 또한 탐색 공간을 유의미한 해(Solution)가 밀집해 있을 만한 영역으로 좁히는 전략적 행위이다.7</p>
<p>안드레이 카패시가 지적했듯이, 신경망은 그 자체로 프로그램의 실행 코드가 아니라, 프로그램이 될 수 있는 가능성의 공간을 정의하는 틀이다.6 우리는 이 틀 안에서 데이터와 최적화 알고리즘을 사용하여 실제 작동하는 소프트웨어를 ’조각’해낸다.</p>
<h2>3.  최적화 엔진: 어둠 속의 항해</h2>
<h3>3.1  손실 지형(Loss Landscape)과 경사 하강법</h3>
<p>원하는 프로그램을 찾기 위한 나침반은 ‘손실 함수(Loss Function)’ 혹은 ‘목적 함수(Objective Function)’ <span class="math math-inline">\mathcal{L}(\theta)</span>이다. 이 함수는 프로그램 공간상의 한 점 <span class="math math-inline">\theta</span>가 주어졌을 때, 해당 프로그램이 얼마나 형편없는지를 수치화한다. 로봇 제어에서 손실 함수는 목표 지점과의 거리, 소모한 에너지, 관절의 급격한 움직임(Jerk) 등에 대한 페널티의 합으로 구성될 수 있다.9</p>
<p>최적화 문제는 다음과 같이 정식화된다:<br />
<span class="math math-display">
\theta^* = \underset{\theta}{\text{argmin}} \ \mathbb{E}_{(s,a) \sim \mathcal{D}} [\mathcal{L}(\pi_\theta(s), a)]
</span><br />
여기서 <span class="math math-inline">\pi_\theta</span>는 파라미터 <span class="math math-inline">\theta</span>로 정의되는 정책(Policy)이며, <span class="math math-inline">\mathcal{D}</span>는 환경과의 상호작용 데이터 분포이다.</p>
<p>이 최적해 <span class="math math-inline">\theta^*</span>를 찾는 과정은 칠흑 같은 어둠 속에서 산을 내려가는 것에 비유될 수 있다. 우리는 산의 전체 형상을 볼 수 없으며, 오직 현재 발을 딛고 있는 지점의 경사(Gradient)만을 감지할 수 있다. 이때 사용되는 도구가 바로 ’경사 하강법(Gradient Descent)’이라는 플래시라이트다.11 이 플래시라이트는 현재 위치에서 손실 함수가 가장 빠르게 감소하는 방향 <span class="math math-inline">-\nabla_\theta \mathcal{L}</span>을 비춰준다.<br />
<span class="math math-display">
\theta_{t+1} \leftarrow \theta_t - \alpha \nabla_\theta \mathcal{L}(\theta_t)
</span><br />
이 단순한 반복적 업데이트 규칙(Iterative Update Rule)이 Software 2.0을 구동하는 핵심 엔진이다. 수백만, 수십억 개의 파라미터가 이 기울기 신호를 따라 조금씩 조정되며, 무작위였던 초기 프로그램은 점차 고도로 숙련된 제어 알고리즘으로 진화한다.13</p>
<h4>3.1.1  로보틱스 최적화의 난제: 거친 지형과 불연속성</h4>
<p>그러나 로보틱스에서의 최적화는 이미지 분류나 언어 번역 모델을 학습시키는 것보다 훨씬 험난하다. 로봇 제어의 손실 지형(Loss Landscape)은 매끄러운 볼록 함수(Convex Function)가 아니라, 수많은 지역 최적해(Local Minima)와 평탄한 고원(Plateau), 그리고 급격한 절벽이 존재하는 비볼록(Non-convex) 지형이다.15</p>
<p>특히 물리적 접촉(Contact)은 최적화의 가장 큰 적이다. 로봇의 발이 지면에 닿는 순간, 혹은 그리퍼가 물체를 잡는 순간, 시스템의 역학은 불연속적으로 변화한다. 이러한 불연속성은 손실 함수에 미분 불가능한 지점을 만들어내며, 경사 하강법의 핵심 전제인 ’매끄러운 기울기’를 파괴한다.16 넘어지는 로봇의 경우, 아주 미세한 제어 입력의 차이가 ’넘어짐’과 ’버팀’이라는 극단적인 결과의 차이를 만들어내므로, 손실 지형은 낭떠러지와 같다.</p>
<p>이러한 문제를 해결하기 위해 강화학습(Reinforcement Learning, RL)에서는 확률적 정책(Stochastic Policy)을 사용하여 그래디언트를 추정하거나(Policy Gradient), 진화 전략(Evolutionary Strategy)과 같은 0차 최적화(Zeroth-order Optimization) 기법을 사용하기도 한다. 그러나 이는 근본적으로 샘플 효율성(Sample Efficiency)이 낮다는 한계를 가진다.18</p>
<h3>3.2  미분 가능한 물리학(Differentiable Physics): 최적화의 고속도로</h3>
<p>Software 2.0의 이상을 로보틱스에서 완전히 실현하기 위해 최근 부상하고 있는 기술이 바로 ’미분 가능한 물리학(Differentiable Physics)’이다.20 기존의 물리 엔진(MuJoCo, Bullet 등)은 시뮬레이션의 결과(State)만을 출력해 줄 뿐, 그 결과가 입력 파라미터에 대해 어떻게 변화하는지에 대한 미분값은 제공하지 못했다(Black-box Simulator).</p>
<p>반면, 미분 가능한 시뮬레이터(Dojo, Brax 등)는 물리 법칙의 연산 과정 전체를 미분 가능한 연산 그래프(Computation Graph)로 구현한다.22 이는 로봇의 행동 결과로부터 제어 입력에 대한 기울기를 역전파(Backpropagation)할 수 있게 해 준다. 즉, 로봇이 넘어졌다면, 단순히 “나쁘다“는 신호만 주는 것이 아니라, “무릎 관절의 토크를 0.5Nm 줄이고 발목 각도를 2도 높였으면 넘어지지 않았을 것“이라는 구체적인 수정 방향(Gradient)을 분석적으로(Analytically) 계산해 낸다.23</p>
<p>이것은 캄캄한 어둠 속에서 손전등 하나에 의지하던 탐색자에게, 산의 지형도를 제공하고 최단 경로를 알려주는 내비게이션을 주는 것과 같다. 미분 가능한 물리학을 통해 로봇 제어 문제는 강화학습의 시행착오(Trial and Error) 방식에서 벗어나, 딥러닝의 지도 학습(Supervised Learning)과 유사한 고효율의 기울기 기반 최적화 문제로 전환된다.25 연구 결과에 따르면, 미분 가능한 시뮬레이터를 활용한 정책 최적화는 기존 강화학습 대비 수십 배에서 수백 배 빠른 수렴 속도를 보여주며, 훨씬 더 정교한 제어 성능을 달성할 수 있다.16</p>
<h3>3.3  데이터 엔진(Data Engine): Software 2.0의 컴파일러</h3>
<h4>3.3.1  데이터가 곧 소스 코드다</h4>
<p>Software 2.0 관점에서 개발자가 관리해야 할 가장 중요한 자산은 더 이상 C++ 코드가 아니라 ’데이터셋’이다. 최적화 알고리즘(Optimizer)이 컴파일러라면, 데이터셋은 소스 코드다.26 컴파일러(최적화기)는 데이터셋을 읽어 들여 실행 가능한 프로그램(신경망 가중치)으로 변환한다. 따라서 프로그램의 버그를 수정하거나 성능을 개선하려면, 가중치를 직접 수정하는 것이 아니라 데이터셋을 수정해야 한다.</p>
<p>로보틱스에서의 데이터셋은 이미지나 텍스트보다 훨씬 다층적이다. 로봇의 관절 상태(Proprioception), 외부 센서 데이터(Exteroception), 제어 입력(Action), 그리고 보상(Reward) 신호가 시계열적으로 얽혀 있다. 테슬라(Tesla)나 웨이모(Waymo) 같은 선도적인 자율주행 및 로봇 기업들은 이러한 데이터를 수집, 정제, 라벨링 하는 거대한 파이프라인, 즉 ’데이터 엔진(Data Engine)’을 구축하는 데 총력을 기울이고 있다.27</p>
<h4>3.3.2  데이터 큐레이션과 엣지 케이스 관리</h4>
<p>Software 1.0 개발자가 <code>if-else</code> 문을 추가하여 예외 상황을 처리하듯, Software 2.0 엔지니어는 데이터셋에 ‘엣지 케이스(Edge Case)’ 데이터를 추가함으로써 모델을 수정한다. 로봇이 특정 조명 환경에서 물체를 인식하지 못한다면, 해당 조명 조건의 이미지를 데이터셋에 추가하고 재학습(Re-compile)시킨다. 이는 “라벨링이 곧 프로그래밍이다(Labeling is Programming)“라는 명제로 이어진다.29</p>
<p>특히 로보틱스에서는 ’플릿 러닝(Fleet Learning)’이 핵심적인 역할을 한다. 수천 대의 로봇이 실제 환경에서 활동하며 겪는 다양한 실패 사례(Failure Cases)들은 자동으로 클라우드로 전송된다. 이 데이터들은 전문가에 의해 분석되고 라벨링 되거나, 시뮬레이션 상에서 재현되어(Digital Twin) 모델의 약점을 보완하는 학습 데이터로 변환된다.27 이 과정은 지속적 통합/배포(CI/CD) 파이프라인과 유사한 ‘MLOps’ 또는 ’RoboOps’라 불리는 새로운 운영 방법론을 탄생시켰다.31</p>
<h4>3.3.3  전문가 시범과 모방 학습</h4>
<p>데이터 엔진의 또 다른 중요한 축은 인간 전문가의 시범(Demonstration)이다. 복잡한 로봇 동작을 수학적 보상 함수로 정의하는 것은 매우 어렵다(Reward Engineering Problem). 대신 인간이 로봇을 원격 조종(Teleoperation)하거나 모션 캡처를 통해 시범을 보이면, 로봇은 이 데이터를 모방 학습(Imitation Learning)하여 전문가의 행동 패턴을 프로그램 공간 내에서 찾아낸다.33 ’DeepMimic’과 같은 연구는 모션 캡처 데이터가 어떻게 로봇의 자연스러운 움직임을 위한 강력한 사전 지식(Prior)으로 작용하여 탐색 공간을 효과적으로 좁혀주는지를 보여준다.35</p>
<h3>3.4  에너지 기반 모델(Energy-Based Models)과 추론으로서의 제어</h3>
<p>얀 르쿤(Yann LeCun)은 Software 2.0과 최적화의 개념을 ’에너지 기반 모델(Energy-Based Models, EBM)’로 확장하여 설명한다.37 EBM에서 프로그램은 변수들 간의 의존성(Dependency)을 에너지 함수 <span class="math math-inline">E(x, y)</span>로 표현한다. 여기서 <span class="math math-inline">x</span>는 입력(센서 데이터), <span class="math math-inline">y</span>는 출력(행동)이다. 학습(Learning)은 정답 데이터 <span class="math math-inline">(x, y)</span>에 대해서는 에너지를 낮추고(Digging holes), 오답에 대해서는 에너지를 높이는(Building hills) 방식으로 에너지 지형(Energy Landscape)을 조각하는 과정이다.38</p>
<p>이 관점에서 로봇의 행동 생성(Inference)은 주어진 상황 <span class="math math-inline">x</span>에 대해 에너지를 최소화하는 <span class="math math-inline">y</span>를 찾는 최적화 과정이 된다:<br />
<span class="math math-display">
y^* = \underset{y}{\text{argmin}} \ E(x, y)
</span><br />
이는 전통적인 모델 예측 제어(Model Predictive Control, MPC)와 딥러닝의 결합을 시사한다. 단순히 입력에 대해 출력을 내뱉는 피드포워드(Feed-forward) 방식(Mode 1)을 넘어, 실행 시간(Run-time)에 에너지 최소화를 수행하는 계획(Planning) 및 추론(Reasoning) 방식(Mode 2)으로 로봇 지능이 진화하고 있음을 의미한다.39</p>
<h3>3.5  결론: 논리적 엔지니어에서 최적화 정원사로</h3>
<p>Software 2.0 패러다임 하에서 로봇 프로그래밍의 본질은 근본적으로 변화했다. 우리는 더 이상 로봇에게 “어떻게(How)” 움직여야 하는지 미시적인 규칙으로 지시하지 않는다. 대신 “무엇(What)“이 좋은 행동인지 손실 함수나 에너지 함수로 정의하고, 로봇이 스스로 최적의 행동 방식을 탐색 공간에서 찾아내도록 유도한다.</p>
<p>이러한 변화는 엔지니어의 역할을 ’코드 작성자’에서 ’데이터 큐레이터’이자 ’최적화 정원사(Gardener)’로 재정의한다. 정원사가 식물이 잘 자랄 수 있도록 토양(데이터)을 비옥하게 하고, 가지(아키텍처)를 치며, 빛(최적화 목표)을 조절하듯이, 로봇 엔지니어는 인공지능 모델이 최적의 제어 정책으로 수렴할 수 있는 환경을 조성하는 데 집중해야 한다.</p>
<p>논리(Logic)는 명확하지만 취약하다. 반면 최적화(Optimization)는 불투명하지만 강력하고 유연하다.41 로봇이 실험실을 벗어나 예측 불가능한 현실 세계(The Wild)로 나아가기 위해서는, 경직된 논리의 껍질을 깨고 최적화라는 거대한 바다로 나아가야 한다. Software 2.0은 단순한 기술적 유행이 아니라, 복잡계를 다루기 위한 인류의 새로운 인지적 도구이자, 로봇 지능을 실현하기 위한 필연적인 진화의 단계이다.</p>
<h3>3.6 요약 및 핵심 비교 (Summary &amp; Key Comparisons)</h3>
<table><thead><tr><th><strong>구분</strong></th><th><strong>Software 1.0 (고전 제어/로직)</strong></th><th><strong>Software 2.0 (딥러닝/최적화)</strong></th></tr></thead><tbody>
<tr><td><strong>프로그램의 정의</strong></td><td>인간이 작성한 논리적 명령 (C++, Python 등)</td><td>파라미터 공간상의 한 점 (Weights)</td></tr>
<tr><td><strong>개발의 본질</strong></td><td>알고리즘 설계 및 명시적 코딩 (Logic Design)</td><td>탐색 공간 정의 및 최적화 (Search &amp; Optimization)</td></tr>
<tr><td><strong>핵심 도구</strong></td><td>컴파일러, 디버거, IDE</td><td>경사 하강법(Gradient Descent), 데이터 엔진, 미분 가능한 시뮬레이터</td></tr>
<tr><td><strong>예외 처리</strong></td><td>수동으로 <code>if-else</code> 분기 추가</td><td>엣지 케이스 데이터 추가 및 재학습 (Re-training)</td></tr>
<tr><td><strong>성능의 원천</strong></td><td>개발자의 알고리즘 작성 능력</td><td>데이터의 양과 질, 컴퓨팅 파워</td></tr>
<tr><td><strong>해석 가능성</strong></td><td>높음 (White Box, 인과관계 명확)</td><td>낮음 (Black Box, 직관적 이해 어려움)</td></tr>
<tr><td><strong>로봇 적용 분야</strong></td><td>정형화된 공장 자동화, 단순 반복 작업</td><td>비정형 환경의 자율주행, 범용 조작(Manipulation), 휴머노이드 보행</td></tr>
</tbody></table>
<p><strong>핵심 통찰 (Key Insights):</strong></p>
<ul>
<li><strong>탐색 공간의 위상학(Topology):</strong> 프로그램 개발은 고차원 매니폴드 상에서 손실 함수의 최저점을 찾아가는 기하학적 문제로 환원된다.</li>
<li><strong>미분 가능성의 혁명:</strong> 물리 엔진의 미분 가능화는 로봇 제어 문제를 강화학습의 영역에서 고효율의 기울기 기반 최적화 영역으로 가져온다.</li>
<li><strong>데이터 엔진의 부상:</strong> 로봇 소프트웨어의 품질은 코드의 품질보다 데이터 큐레이션 및 라벨링 프로세스(MLOps)의 성숙도에 의해 결정된다.</li>
<li><strong>추론의 재정의:</strong> 로봇의 추론과 계획(Planning)은 실행 시간(Run-time)에 수행되는 에너지 함수 최소화 과정으로 통합된다.</li>
</ul>
<h2>4. 참고 자료</h2>
<ol>
<li>Software 2.0. I sometimes see people refer to neural… | by Andrej …, https://karpathy.medium.com/software-2-0-a64152b37c35</li>
<li>Software 20 - Lark, https://www.larksuite.com/en_us/topics/ai-glossary/software-20</li>
<li>AI and Robotics Innovations by Pieter Abbeel | PDF | Artificial Intelligence - Scribd, https://www.scribd.com/document/408122645/2018-12-Abbeel-AI-pdf</li>
<li>Towards the light — Comparing evolved neural network controllers and Finite State Machine controllers - IEEE Xplore, https://ieeexplore.ieee.org/document/6273587/</li>
<li>Comparison between Behavior Trees and Finite State Machines - arXiv, https://arxiv.org/html/2405.16137v1</li>
<li>[N] Software 2.0 - Andrej Karpathy : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/7cdov2/n_software_20_andrej_karpathy/</li>
<li>What Is NVIDIA’s Three-Computer Solution for Robotics?, https://blogs.nvidia.com/blog/three-computers-robotics/</li>
<li>A Comparison Study between Traditional and Deep-Reinforcement-Learning-Based Algorithms for Indoor Autonomous Navigation in Dynamic Scenarios - MDPI, https://www.mdpi.com/1424-8220/23/24/9672</li>
<li>Gradient descent - Wikipedia, https://en.wikipedia.org/wiki/Gradient_descent</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning Based Control for Legged Robot Locomotion in MuJoCo Simulation - arXiv, https://arxiv.org/html/2501.16590v1</li>
<li>What Is Gradient Descent? Algorithms, Types, Advantages &amp; More! - Unstop, https://unstop.com/blog/what-is-gradient-descent</li>
<li>What is Gradient Descent? A short visual guide. [OC] : r/optimization - Reddit, https://www.reddit.com/r/optimization/comments/s28ehs/what_is_gradient_descent_a_short_visual_guide_oc/</li>
<li>Optimization in AI. How Machines Learn Efficiently… | by Muhammad Taha | Medium, https://muhammadtaha01.medium.com/optimization-in-ai-37c6fb0bd32e</li>
<li>A Visual Explanation of Gradient Descent Methods (Momentum, AdaGrad, RMSProp, Adam), https://towardsdatascience.com/a-visual-explanation-of-gradient-descent-methods-momentum-adagrad-rmsprop-adam-f898b102325c/</li>
<li>towards interpretable reinforcement learning interactive visualizations to increase insight, https://www.ri.cmu.edu/app/uploads/2020/12/Magister_Scientiae_Thesis.pdf</li>
<li>Rethinking Optimization with Differentiable Simulation from a Global Perspective - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v205/antonova23a/antonova23a.pdf</li>
<li>Improving Generalization of Differentiable Simulator Policies with Sharpness-Aware Optimization - OpenReview, https://openreview.net/pdf?id=NgtwTM5eSA</li>
<li>Policy Gradient Methods for Robotics - People @EECS, https://people.eecs.berkeley.edu/~pabbeel/cs287-fa09/readings/PetersSchaal-policy-gradient-for-robotics_IROS2006.pdf</li>
<li>Now Publishers - A Survey on Policy Search for Robotics, https://www.nowpublishers.com/article/DownloadSummary/ROB-021</li>
<li>Differentiable Physics-based System Identification for Robotic Manipulation of Elastoplastic Materials - arXiv, https://arxiv.org/html/2411.00554v1</li>
<li>Differentiable Simulation for Search (DSS) - Emergent Mind, https://www.emergentmind.com/topics/differentiable-simulation-for-search-dss</li>
<li>Dojo: A Differentiable Physics Engine for Robotics - arXiv, https://arxiv.org/html/2203.00806v5</li>
<li>Imitation Learning As State Matching via Differentiable Physics - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2023/papers/Chen_Imitation_Learning_As_State_Matching_via_Differentiable_Physics_CVPR_2023_paper.pdf</li>
<li>Back to Newton’s Laws: Learning Vision-based Agile Flight via Differentiable Physics - arXiv, https://arxiv.org/html/2407.10648v1</li>
<li>[D] Views on DIfferentiable Physics : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/1lx0bbf/d_views_on_differentiable_physics/</li>
<li>Wrapping up my journey scaling Software 2.0 development for AV | by Clement Farabet, https://medium.com/@clementfarabet/wrapping-up-my-journey-scaling-software-2-0-development-for-av-69ee99d94f53</li>
<li>What I Learned From Attending TWIMLcon 2021 - James Le, https://jameskle.com/writes/twiml2021</li>
<li>Roboto vs. Vertex AI: Choosing the Right Engine for Your Physical AI Ambitions, https://skywork.ai/skypage/en/Roboto-vs.-Vertex-AI:-Choosing-the-Right-Engine-for-Your-Physical-AI-Ambitions/1976523856775540736</li>
<li>Building the Software 2.0 Stack by Andrej Karpathy [video] - Hacker News, https://news.ycombinator.com/item?id=17280454</li>
<li>Can We Trust Software Stack 2.0? - PickNik Robotics, <a href="https://picknik.ai/ai/chatgpt/deep%20learning/2023/02/15/software-stack-2-0.html">https://picknik.ai/ai/chatgpt/deep%20learning/2023/02/15/software-stack-2-0.html</a></li>
<li>Rapid Sim-to-Real Humanoid Locomotion - Emergent Mind, https://www.emergentmind.com/papers/2512.01996</li>
<li>(PDF) Orchestrating Intelligence: Designing AI-Optimized Workflows and Robotic Systems, https://www.researchgate.net/publication/398270714_Orchestrating_Intelligence_Designing_AI-Optimized_Workflows_and_Robotic_Systems</li>
<li>Learning to Imitate | SAIL Blog - Stanford AI Lab, https://ai.stanford.edu/blog/learning-to-imitate/</li>
<li>Learning for a Robot: Deep Reinforcement Learning, Imitation Learning, Transfer Learning - MDPI, https://www.mdpi.com/1424-8220/21/4/1278</li>
<li>ADD: Physics-Based Motion Imitation with Adversarial Differential Discriminators | alphaXiv, https://www.alphaxiv.org/overview/2505.04961v1</li>
<li>Acquiring Motor Skills Through Motion Imitation and Reinforcement Learning - UC Berkeley EECS, https://www2.eecs.berkeley.edu/Pubs/TechRpts/2021/EECS-2021-267.pdf</li>
<li>Yann LeCun’s Research and Contributions, http://yann.lecun.com/ex/research/index.html</li>
<li>Loss Functions for Discriminative Training of Energy-Based Models., http://www.gatsby.ucl.ac.uk/aistats/fullpapers/207.pdf</li>
<li>A Path Towards Autonomous Machine Intelligence Version 0.9.2, 2022-06-27 - OpenReview, https://openreview.net/pdf?id=BZ5a1r-kVsf</li>
<li>Software 2.0: An Emerging Era of Automatic Code Generation - The Softtek Blog, https://blog.softtek.com/software-2.0-an-emerging-era-of-automatic-code-generation</li>
<li>Software 2.0; or, why did that AI think that muffin was a chihuahua? - AI &amp; Big Data Expo - Conference and Exhibition, https://www.ai-expo.net/software-2-0-or-why-did-that-ai-think-that-muffin-was-a-chihuahua/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>