<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.1.3 최적 제어(Optimal Control)와 MPC: 비용 함수(Cost Function)와 제약 조건(Constraints)의 도입</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.1.3 최적 제어(Optimal Control)와 MPC: 비용 함수(Cost Function)와 제약 조건(Constraints)의 도입</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</a> / <span>2.1.3 최적 제어(Optimal Control)와 MPC: 비용 함수(Cost Function)와 제약 조건(Constraints)의 도입</span></nav>
                </div>
            </header>
            <article>
                <h1>2.1.3 최적 제어(Optimal Control)와 MPC: 비용 함수(Cost Function)와 제약 조건(Constraints)의 도입</h1>
<h2>1.  서론: 제어 패러다임의 진화와 Software 2.0</h2>
<h3>1.1  행동의 코딩에서 목적의 기술로</h3>
<p>현대 로보틱스 소프트웨어 공학은 근본적인 전환점에 서 있다. 과거의 제어기 설계가 시스템의 매 순간 반응을 명시적인 규칙(Rule-based)이나 경험적 게인 튜닝(Heuristic Gain Tuning)으로 결정하는 “Software 1.0“의 영역이었다면, 최적 제어(Optimal Control)의 도입은 엔지니어가 시스템의 ’목적(Objective)’과 ’한계(Constraint)’만을 정의하고, 구체적인 행동(Behavior)은 최적화 알고리즘이 자동으로 생성해내는 “Software 2.0” 시대로의 진입을 의미한다.1</p>
<p>Andrej Karpathy가 주창한 Software 2.0의 개념은 주로 딥러닝과 신경망에 적용되어 왔으나, 로보틱스 제어 관점에서 이 철학을 가장 잘 구현하는 수학적 프레임워크는 단연 모델 예측 제어(Model Predictive Control, MPC)이다.1 MPC는 “어떻게 움직여라(How to move)“를 코딩하는 대신 “무엇이 최선인가(What is optimal)“와 “무엇이 불가능한가(What is forbidden)“를 수학적으로 기술함으로써, 복잡한 다입력 다출력(MIMO) 시스템이 동적인 환경에서 스스로 최적의 해를 찾도록 유도한다. 이는 단순한 제어 기법의 변화를 넘어, 로봇의 지능(Embodied Intelligence)을 구현하는 방법론의 혁신이다.</p>
<h3>1.2  최적 제어의 역사적 맥락과 MPC의 부상</h3>
<p>최적 제어 이론은 1950년대 변분법(Calculus of Variations)과 폰트리아긴의 최소 원리(Pontryagin’s Minimum Principle)를 통해 태동했다.4 초기 이론은 주로 우주선의 궤적 계산과 같이 오프라인에서 미리 경로를 계산하는 문제에 집중되었으나, 1980년대 화학 및 정유 공정(Process Industries)에서 시스템의 느린 동역학을 이용해 실시간 제어에 적용되기 시작했다. 이것이 MPC의 시초이다.</p>
<p>그러나 로보틱스와 같이 밀리초(ms) 단위의 빠른 응답성이 요구되는 분야에서 MPC가 PID 제어를 대체하거나 보완하는 주류 기술로 부상한 것은 최근 10년 사이의 일이다. 이는 컴퓨터 연산 속도의 비약적인 발전, 볼록 최적화(Convex Optimization) 알고리즘의 효율화, 그리고 자동 코드 생성(Code Generation) 도구의 등장이 맞물린 결과이다.6 이제 MPC는 단순한 설정값 추종(Tracking)을 넘어, 드론의 곡예비행, 4족 보행 로봇의 험지 주파, 휴머노이드의 균형 유지 등 고난이도 작업을 가능케 하는 핵심 엔진으로 자리 잡았다.8</p>
<hr />
<h2>2.  최적 제어 문제의 정식화: 비용 함수(Cost Function)</h2>
<p>비용 함수(Cost Function), 혹은 목적 함수(Objective Function)는 시스템의 의도(Intent)를 수학적으로 번역한 것이다. MPC는 매 샘플링 시간마다 이 비용 함수를 최소화하는 제어 입력 시퀀스를 계산한다. 따라서 비용 함수의 설계는 곧 로봇의 ’성격’을 설계하는 것과 같다.</p>
<h3>2.1  이차 비용 함수(Quadratic Cost Function)의 표준형</h3>
<p>로보틱스에서 가장 널리 사용되는 비용 함수는 이차 형식(Quadratic Form)이다. 이는 수학적으로 볼록성(Convexity)을 보장하여 유일한 전역 최적해(Global Optimum)를 효율적으로 찾을 수 있게 해주며, 에너지(전압의 제곱, 속도의 제곱 등)와 오차의 크기를 물리적으로 직관적으로 표현한다.10</p>
<p>이산 시간(Discrete-time) 선형 시스템 <span class="math math-inline">x_{k+1} = A x_k + B u_k</span>에 대한 유한 구간(Finite Horizon) 최적 제어 문제의 비용 함수 <span class="math math-inline">J</span>는 다음과 같이 정의된다:<br />
<span class="math math-display">
J(x_k, \mathbf{U}_k) = \sum_{i=0}^{N-1} \underbrace{\left( \| x_{k+i|k} - x_{ref, k+i} \|_Q^2 + \| u_{k+i|k} \|_R^2 \right)}_{\text{Stage Cost}} + \underbrace{\| x_{k+N|k} - x_{ref, N} \|_P^2}_{\text{Terminal Cost}}
</span><br />
여기서 <span class="math math-inline">\|v\|_W^2</span>는 <span class="math math-inline">v^T W v</span>를 의미하며, 각 항은 다음과 같은 물리적, 제어적 의미를 내포한다.</p>
<h4>2.1.1  상태 가중치 행렬 Q: 성능(Performance)의 정의</h4>
<p>행렬 <span class="math math-inline">Q</span>는 추종 오차(Tracking Error)에 대한 페널티를 정의한다. <span class="math math-inline">Q</span>는 일반적으로 양의 준정부호(Positive Semi-definite, <span class="math math-inline">Q \succeq 0</span>) 대각 행렬로 설정된다.</p>
<ul>
<li><strong>물리적 의미:</strong> <span class="math math-inline">Q</span>의 대각 원소 값은 해당 상태 변수의 중요도를 나타낸다. 예를 들어, 로봇 팔의 끝단(End-effector) 위치 정밀도가 중요한 경우 해당 상태 변수에 큰 가중치를 부여한다. 반면, 중간 관절의 각도는 상대적으로 덜 중요하다면 작은 가중치를 부여할 수 있다.</li>
<li><strong>튜닝 효과:</strong> <span class="math math-inline">Q</span>를 증가시키면 제어기는 오차를 줄이기 위해 더 공격적으로 반응하며, 이는 시스템의 대역폭(Bandwidth)을 높이는 효과를 가져온다.12</li>
</ul>
<h4>2.1.2  제어 가중치 행렬 R: 효율성(Efficiency)과 부드러움</h4>
<p>행렬 <span class="math math-inline">R</span>은 제어 입력의 사용량(Control Effort)에 대한 페널티를 정의하며, 반드시 양의 정부호(Positive Definite, <span class="math math-inline">R \succ 0</span>)여야 한다. 이는 수학적으로 최적화 문제의 해가 유일함을 보장하는 데 필수적이다.</p>
<ul>
<li><strong>에너지 관점:</strong> <span class="math math-inline">u^T R u</span> 항은 전기 모터의 전력 소모나 유압 시스템의 에너지 소비를 최소화하려는 경제적 유인을 제공한다.</li>
<li><strong>기구적 관점:</strong> 급격한 제어 입력의 변화는 기계적 진동이나 마모를 유발한다. <span class="math math-inline">R</span>을 크게 설정하면 제어 입력이 부드러워져(Smooth), 시스템의 내구성을 높이고 고주파 진동을 억제하는 효과가 있다.5</li>
<li><strong>변화율 페널티(<span class="math math-inline">\Delta u</span>):</strong> 때로는 제어 입력 자체(<span class="math math-inline">u</span>)보다 입력의 변화량(<span class="math math-inline">\Delta u = u_k - u_{k-1}</span>)에 페널티를 부과하는 것이 유리하다. 이는 액추에이터의 급격한 가감속을 방지하여 승차감이나 영상 촬영의 안정성을 확보하는 데 필수적이다.14</li>
</ul>
<h3>2.2  예측 구간(Prediction Horizon, N)의 딜레마</h3>
<p>예측 구간 <span class="math math-inline">N</span>은 제어기가 얼마나 먼 미래를 내다볼 것인지를 결정하는 파라미터이다.</p>
<ul>
<li><strong>긴 <span class="math math-inline">N</span>의 장점:</strong> 시스템의 관성과 미래의 궤적 변화를 미리 파악하여 부드럽고 안정적인 제어가 가능하다. 특히 비최소 위상(Non-minimum Phase) 시스템이나 장애물 회피와 같이 선제적 대응이 필요한 경우 긴 <span class="math math-inline">N</span>이 필수적이다.4</li>
<li><strong>짧은 <span class="math math-inline">N</span>의 위험:</strong> <span class="math math-inline">N</span>이 너무 짧으면 눈앞의 이익만을 쫓는 근시안적(Myopic) 제어가 되어, 지역 최적해(Local Minima)에 빠지거나 불안정해질 수 있다.</li>
<li><strong>계산 비용의 트레이드오프:</strong> <span class="math math-inline">N</span>이 증가하면 최적화 변수의 수가 선형적으로 증가하여 계산 시간이 늘어난다. 따라서 제어 주기가 매우 짧은(예: 1kHz) 로봇 시스템에서는 <span class="math math-inline">N</span>을 가능한 짧게 유지하면서도 안정성을 확보하는 것이 중요한 설계 과제이다.16</li>
</ul>
<h3>2.3  종단 비용(Terminal Cost)과 안정성 보장</h3>
<p>유한 구간 <span class="math math-inline">N</span>을 사용할 때 발생하는 안정성 문제를 해결하기 위해 종단 비용 <span class="math math-inline">P</span>가 도입된다. 이는 예측 구간 이후 <span class="math math-inline">N \rightarrow \infty</span>까지의 비용을 근사하는 역할을 한다.</p>
<ul>
<li><strong>Lyapunov 이론:</strong> <span class="math math-inline">P</span> 행렬을 이산 시간 대수 리카티 방정식(Discrete Algebraic Riccati Equation, DARE)의 해로 설정하면, MPC 제어 법칙이 닫힌 루프 시스템의 점근적 안정성(Asymptotic Stability)을 보장한다는 것이 수학적으로 증명되어 있다.3</li>
<li><strong>실제적 적용:</strong> 많은 실용적인 로보틱스 구현에서는 <span class="math math-inline">N</span>을 충분히 길게 설정함으로써 <span class="math math-inline">P</span> 없이도 안정성을 확보하기도 하지만, 이론적 엄밀함과 짧은 <span class="math math-inline">N</span>에서의 성능을 위해서는 <span class="math math-inline">P</span>의 도입이 권장된다.</li>
</ul>
<h2>3.  제약 조건(Constraints): 물리적 현실의 반영</h2>
<p>PID 제어와 MPC를 가르는 가장 결정적인 차이점은 제약 조건의 명시적 처리 능력이다. PID 제어기는 물리적 한계를 고려하지 않고 계산된 제어 입력을 단순히 잘라내거나(Saturation), 적분기 누적 방지(Anti-windup) 기법과 같은 사후적/임시적 처방에 의존한다. 반면, MPC는 설계 단계에서부터 제약 조건을 고려하여, 제약을 위반하지 않으면서도 성능을 극대화하는 최적의 해를 찾아낸다.12</p>
<h3>3.1  제약 조건의 분류와 로보틱스 응용</h3>
<h4>3.1.1  입력 제약 (Input Constraints)</h4>
<p>모든 액추에이터는 물리적 한계를 가진다. 이를 무시하면 시스템은 불안정해지거나 하드웨어가 손상된다.</p>
<ul>
<li>
<p><strong>크기 제한 (Box Constraints):</strong> <span class="math math-inline">u_{min} \leq u_k \leq u_{max}</span>. (예: 드론 모터의 최대 RPM, 서보 모터의 최대 토크)</p>
</li>
<li>
<p>변화율 제한 (Slew Rate Limits): <span class="math math-inline">|\Delta u_k| \leq \Delta u_{max}</span>. (예: 스티어링 휠의 최대 회전 속도)</p>
</li>
</ul>
<p>이러한 제약은 MPC의 최적화 문제에서 선형 부등식 형태로 간단히 포함되며, 2차 계획법(QP) 솔버가 매우 효율적으로 처리할 수 있다.15</p>
<h4>3.1.2  상태 제약 (State Constraints)</h4>
<p>로봇의 상태가 안전한 영역 내에 머물도록 강제한다.</p>
<ul>
<li><strong>작업 공간 제한:</strong> 매니퓰레이터가 특정 영역(예: 인간 작업자와의 공유 공간)을 침범하지 않도록 한다.</li>
<li><strong>속도 제한:</strong> 안전 규정에 따라 로봇의 이동 속도를 제한한다.</li>
<li><strong>자세 제한:</strong> 드론이 뒤집히지 않도록 롤(Roll)과 피치(Pitch) 각도를 제한한다 (<span class="math math-inline">|\phi| \leq \phi_{max}</span>).</li>
</ul>
<h4>3.1.3  혼합 제약 (Mixed Constraints) 및 연성 제약 (Coupled Constraints)</h4>
<p>상태와 입력이 서로 엮여 있는 복잡한 제약 조건이다.</p>
<ul>
<li><strong>마찰 원뿔(Friction Cone):</strong> 4족 보행 로봇이나 휴머노이드에서 발이 미끄러지지 않기 위해서는 지면 반력의 수평 성분이 수직 성분의 마찰 계수 배보다 작아야 한다 (<span class="math math-inline">\sqrt{F_x^2 + F_y^2} \leq \mu F_z</span>). 이는 로봇의 보행 안정성을 결정짓는 핵심 제약 조건이다.17</li>
</ul>
<h3>3.2  경성 제약(Hard Constraints) vs 연성 제약(Soft Constraints)</h3>
<p>제약 조건을 최적화 문제에 어떻게 반영하느냐는 시스템의 생존성(Viability)과 직결된다.</p>
<h4>3.2.1  경성 제약의 위험성</h4>
<p>경성 제약은 “절대 위반 불가“를 의미한다. 만약 외란이나 모델 불확실성, 혹은 너무 과도한 목표 설정으로 인해 모든 제약 조건을 만족하는 해가 존재하지 않는 경우(Infeasibility), 표준적인 QP 솔버는 오류를 반환하고 멈춰버린다. 실시간 제어 중인 로봇에게 이는 치명적인 사고로 이어질 수 있다.18</p>
<h4>3.2.2  연성 제약과 여유 변수(Slack Variables)</h4>
<p>이러한 문제를 방지하기 위해, 물리적으로 절대 어길 수 없는 한계(예: 전압 제한)를 제외한 대부분의 제약(예: 궤적 추종 오차, 안전 거리)은 연성 제약으로 처리한다. 이를 위해 **여유 변수(Slack Variable, <span class="math math-inline">\epsilon</span>)**를 도입한다.<br />
<span class="math math-display">
g(x) \leq 0 \quad \Rightarrow \quad g(x) \leq \epsilon, \quad \epsilon \geq 0
</span><br />
그리고 비용 함수에 이 여유 변수에 대한 막대한 페널티를 추가한다.<br />
<span class="math math-display">
J_{soft} = J + \rho \|\epsilon\|_1 \quad (\text{단, } \rho \gg 1)
</span></p>
<ul>
<li><strong>L1 Penalty의 중요성:</strong> 여유 변수의 페널티로 L2 노름(<span class="math math-inline">\epsilon^2</span>) 대신 L1 노름(<span class="math math-inline">|\epsilon|</span>)을 사용하는 것이 유리하다. 이를 **정확한 페널티 함수(Exact Penalty Function)**라고 하며, 제약 조건을 만족할 수 있는 상황에서는 여유 변수를 정확히 0으로 만들어 경성 제약과 동일한 해를 내도록 유도한다. 반면 L2 페널티는 미세한 위반을 허용하는 경향이 있다.19</li>
<li><strong>실전 적용:</strong> 드론이 강풍에 밀려 위치 제약을 일시적으로 위반하더라도, 연성 제약 설계를 통해 제어기는 멈추지 않고 최선을 다해 복귀하는 동작을 생성할 수 있다.</li>
</ul>
<h3>3.3  제어 장벽 함수(CBF)와의 통합: 안전의 수학적 보장</h3>
<p>최근에는 장애물 회피와 같은 복잡한 비볼록(Non-convex) 제약 조건을 처리하기 위해 MPC와 제어 장벽 함수(Control Barrier Functions, CBF)를 결합하는 연구가 활발하다.</p>
<p>CBF는 상태 공간 내의 안전 집합(Safe Set, <span class="math math-inline">\mathcal{C}</span>)을 정의하고, 시스템 상태 <span class="math math-inline">x</span>가 이 집합의 경계에 다가갈수록 제어 입력에 강한 제약을 걸어 경계를 넘지 못하게 한다.<br />
<span class="math math-display">
\dot{h}(x) + \gamma h(x) \geq 0
</span><br />
이 조건을 MPC의 제약 조건으로 추가하면, 최적화 과정에서 자연스럽게 장애물을 부드럽게 회피하는 경로가 생성된다. 이는 특히 동적인 환경에서 움직이는 장애물을 회피해야 하는 자율주행차나 협동 로봇에 필수적인 기술이다.21</p>
<hr />
<h2>4.  수치 최적화와 실시간 구현 (Software 2.0의 엔진)</h2>
<p>비용 함수와 제약 조건이 아무리 정교하게 설계되어도, 이를 실시간으로 풀어내지 못하면 무용지물이다. 로봇 시스템의 제어 주기(1ms ~ 10ms) 내에 최적화 문제를 해결해야 하는 것은 MPC 구현의 가장 큰 난관이었다.</p>
<h3>4.1  이차 계획법 (Quadratic Programming, QP)</h3>
<p>선형 모델과 이차 비용 함수, 선형 제약 조건을 가진 MPC 문제는 볼록 이차 계획법(Convex QP) 문제로 귀결된다.<br />
<span class="math math-display">
\begin{aligned} \min_{\mathbf{u}} \quad &amp; \frac{1}{2} \mathbf{u}^T H \mathbf{u} + \mathbf{f}^T \mathbf{u} \\ \text{s.t.} \quad &amp; A_{eq} \mathbf{u} = b_{eq} \\ &amp; A_{ineq} \mathbf{u} \leq b_{ineq} \end{aligned}
</span><br />
이 형태는 전역 최적해가 보장되며, 매우 효율적인 알고리즘들이 개발되어 있다.</p>
<h3>4.2  로보틱스를 위한 실시간 솔버 비교</h3>
<p>범용 최적화 솔버(예: MATLAB의 <code>quadprog</code>)는 로봇 제어에 사용하기엔 너무 느리다. 따라서 임베디드 시스템에 최적화된 경량 솔버들이 사용된다. 다음 표는 주요 QP 솔버들의 특성을 비교한다.16</p>
<p><strong>Table 2: 로보틱스 MPC를 위한 주요 실시간 QP 솔버 비교</strong></p>
<table><thead><tr><th><strong>솔버 (Solver)</strong></th><th><strong>알고리즘 유형</strong></th><th><strong>특징 및 장점</strong></th><th><strong>주요 적용 사례</strong></th></tr></thead><tbody>
<tr><td><strong>HPIPM</strong> (High-Performance Interior Point Method)</td><td>Interior Point Method</td><td>리카티 재귀(Riccati Recursion) 구조를 활용하여 선형 복잡도 <span class="math math-inline">O(N)</span> 달성. 상태 변수가 많은 문제에 강력함.</td><td>4족 보행 로봇(Cheetah), 휴머노이드 전신 제어 (Whole-Body Control)</td></tr>
<tr><td><strong>OSQP</strong> (Operator Splitting Quadratic Program)</td><td>ADMM (First-order method)</td><td>코드 크기가 작고 구현이 간단함. 임베디드 MCU에 적합. Warm-start 성능이 우수하나 높은 정밀도에서는 느려질 수 있음.</td><td>소형 드론, 임베디드 제어기</td></tr>
<tr><td><strong>qpOASES</strong></td><td>Active-Set Method</td><td>파라메트릭 QP에 특화됨. 이전 해에서 활성 제약(Active Set)이 크게 바뀌지 않는 경우 매우 빠름.</td><td>로봇 팔의 토크 제어, 연속적인 경로 추종</td></tr>
<tr><td><strong>CVXGEN</strong></td><td>Interior Point Method (Code Gen)</td><td>문제 구조에 특화된 C 코드를 생성하여 오버헤드 제거. 마이크로초 단위의 속도 제공. 문제 크기가 작아야 함.</td><td>고속 드론 제어, 서스펜션 제어</td></tr>
</tbody></table>
<h3>4.3  자동 코드 생성 (Code Generation): Software 2.0의 완성</h3>
<p>과거에는 최적화 알고리즘을 C언어로 직접 구현해야 했으나, 이제는 CVXGEN이나 <strong>Acados</strong>와 같은 도구를 사용하여 고수준 언어(Python/MATLAB)로 문제를 정의하면 최적화된 C 코드가 자동으로 생성된다. 6에 따르면, 이러한 코드 생성 방식은 범용 파서(Parser)를 사용하는 방식 대비 수백 배에서 3500배 이상의 속도 향상을 가져오며, 360마이크로초 내에 문제를 해결할 수 있게 해준다. 이는 엔지니어가 알고리즘의 ’구현’이 아닌 ’설계(비용과 제약)’에 집중할 수 있게 해주는 Software 2.0 패러다임의 핵심이다.</p>
<h2>5.  사례 연구: 로보틱스에서의 MPC 성능과 통찰</h2>
<p>이론적으로 우수한 MPC가 실제 로봇 시스템에서 어떤 차이를 만들어내는지 구체적인 사례를 통해 살펴본다.</p>
<h3>5.1  드론(Quadrotor)의 내풍 성능 비교</h3>
<p>드론은 공기역학적 외란(바람)에 매우 민감하다. PID 제어는 오차가 발생한 <em>후</em>에야 반응하는 반면, MPC는 모델을 통해 외란의 영향을 예측하고 보상한다.</p>
<ul>
<li><strong>실험 데이터:</strong> 26와 27의 연구에 따르면, 강한 바람이나 충격 외란 하에서 PID 제어기는 최대 0.3 rad의 자세 오차를 보이며 궤적을 이탈했으나, MPC는 0.04~0.17 rad 이내의 오차로 훨씬 견고한 성능을 보였다.</li>
<li><strong>원인 분석:</strong> MPC는 모터의 추력 한계(Input Constraint)를 알고 있기 때문에, 오차를 줄이기 위해 모터가 낼 수 있는 최대 힘을 미리 계산하여 최적의 시점에 사용한다. 반면 PID는 오차가 커진 뒤에야 큰 입력을 요구하다가 포화(Saturation)되어 제어 성능이 급격히 저하된다(Wind-up 현상).</li>
<li><strong>가우시안 프로세스(GP)와의 결합:</strong> 단순한 MPC를 넘어, 비선형적인 공기역학 모델을 학습하는 GP-MPC는 모델 불확실성까지 보상하여 더욱 정밀한 궤적 추종을 가능하게 한다.28</li>
</ul>
<h3>5.2  매니퓰레이터의 특이점(Singularity) 회피</h3>
<p>로봇 팔 제어에서 역운동학(IK) 솔루션은 특이점 근처에서 관절 속도가 무한대로 발산하는 문제를 가진다.</p>
<ul>
<li><strong>MPC 접근법:</strong> 비용 함수에 조작도(Manipulability) 지표를 최대화하는 항을 추가하거나, 관절 속도 제약 조건을 연성 제약으로 설정함으로써, 로봇 팔이 자연스럽게 특이점 자세를 피해서 돌아가는 경로를 생성하게 할 수 있다.29 이는 별도의 예외 처리 로직 없이 비용 함수의 설계만으로 복잡한 기구학적 문제를 해결하는 좋은 예시이다.</li>
</ul>
<h3>5.3  4족 보행 로봇의 지면 반력 제어</h3>
<p>4족 보행 로봇(예: MIT Cheetah, ANYmal)은 발이 지면에 닿아 있는 동안에만 힘을 쓸 수 있다.</p>
<ul>
<li><strong>제약의 역할:</strong> 각 발의 지면 반력 <span class="math math-inline">f_i</span>는 마찰 원뿔 제약 <span class="math math-inline">f_i \in \mathcal{FC}</span>을 만족해야 한다. 이를 PID로 제어하기는 매우 어렵지만, MPC는 이를 선형 부등식 제약으로 간단히 포함하여 미끄러짐 없이 가속할 수 있는 최대 힘을 분배한다.9</li>
<li><strong>계층적 제어:</strong> 계산 부하를 줄이기 위해, 긴 구간(1초)을 내다보는 간단한 모델(LIPM 등) 기반의 MPC가 발 놓을 위치(Footstep)를 계획하고, 짧은 구간(0.01초)을 제어하는 전신 제어(WBC)가 관절 토크를 계산하는 계층적 구조가 표준으로 자리 잡았다.7</li>
</ul>
<h2>6.  결론: 차세대 로보틱스를 향한 제언</h2>
<p>본 장에서는 최적 제어와 MPC가 어떻게 로보틱스 제어의 패러다임을 ’반응(Reaction)’에서 ’예측(Prediction)’으로, ’규칙 코딩(Coding Rules)’에서 ’목적 기술(Describing Objectives)’로 변화시켰는지 살펴보았다.</p>
<p>비용 함수와 제약 조건은 단순한 수식이 아니라, 로봇에게 우리의 의도와 안전의 경계를 전달하는 언어이다. 이차 비용 함수를 통한 성능과 에너지의 균형, 연성 제약을 통한 유연성 확보, 그리고 CBF를 통한 수학적 안전 보장은 로봇이 복잡하고 불확실한 현실 세계에서 작동하기 위한 필수적인 요소들이다.</p>
<p>나아가 Software 2.0의 관점에서, 미래의 제어 엔지니어는 <span class="math math-inline">Q, R</span> 행렬을 수동으로 튜닝하는 것을 넘어, 데이터로부터 비용 함수 자체를 학습하는 **미분 가능한 MPC(Differentiable MPC)**와 <strong>Embodied AI</strong> 기술을 적극적으로 수용하게 될 것이다.8 이는 로봇이 스스로 자신의 물리적 특성과 환경을 이해하고, 최적의 행동 전략을 수립하는 진정한 자율성의 시대로 우리를 이끌 것이다.</p>
<p><strong>핵심 요약:</strong></p>
<ol>
<li><strong>철학의 전환:</strong> MPC는 단순 알고리즘이 아니라, 목적 함수와 제약 조건을 통해 행동을 생성하는 Software 2.0 프레임워크이다.</li>
<li><strong>설계의 핵심:</strong> 비용 함수는 로봇의 ‘성능 대 효율성’ 트레이드오프를 결정하고, 제약 조건은 ’물리적 한계와 안전’을 보장한다.</li>
<li><strong>구현의 진화:</strong> 고속 QP 솔버와 코드 생성 기술은 MPC를 이론의 영역에서 실시간 로보틱스의 표준 기술로 끌어올렸다.</li>
<li><strong>확장성:</strong> 드론, 매니퓰레이터, 보행 로봇 등 다양한 플랫폼에서 MPC는 외란 강인성과 안전성을 입증하고 있다.</li>
</ol>
<h2>7. 참고 자료</h2>
<ol>
<li>Software 2.0 - Andrej Karpathy – Medium, https://karpathy.medium.com/software-2-0-a64152b37c35</li>
<li>Software 2.0: An Emerging Era of Automatic Code Generation - The Softtek Blog, https://blog.softtek.com/software-2.0-an-emerging-era-of-automatic-code-generation</li>
<li>Lecture 11 - Optimization and Learning for Robot Control - Model Predictive Control (part 1), https://www.youtube.com/watch?v=CAXRrYZjEi4</li>
<li>Model predictive control - Wikipedia, https://en.wikipedia.org/wiki/Model_predictive_control</li>
<li>Ch. 8 - Linear Quadratic Regulators - Underactuated Robotics - MIT, https://underactuated.mit.edu/lqr.html</li>
<li>Code Generation for Receding Horizon Control - Stanford University, https://stanford.edu/~boyd/papers/pdf/code_gen_rhc_msc.pdf</li>
<li>Full article: Model predictive control of legged and humanoid robots: models and algorithms, https://www.tandfonline.com/doi/full/10.1080/01691864.2023.2168134</li>
<li>Actor-Critic Model Predictive Control: Differentiable Optimization meets Reinforcement Learning - arXiv, https://arxiv.org/html/2306.09852v6</li>
<li>Balanced Standing on One Foot of Biped Robot Based on Three-Particle Model Predictive Control - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC9775477/</li>
<li>Quadratic MPC · DyadControlSystems - JuliaHub, https://help.juliahub.com/dyadcontrol/stable/quadratic_mpc/</li>
<li>What Is Model Predictive Control? - MATLAB &amp; Simulink - MathWorks, https://www.mathworks.com/help/mpc/gs/what-is-mpc.html</li>
<li>Why MPC is better than PI? a general question : r/ControlTheory - Reddit, https://www.reddit.com/r/ControlTheory/comments/1cus43d/why_mpc_is_better_than_pi_a_general_question/</li>
<li>MPC vs PID - A Comprehensive Control Method Comparison - Petrotech, Inc., https://petrotechinc.com/mpc-vs-pid-a-comprehensive-control-method-comparison/</li>
<li>Flexible Model Predictive Control for Bounded Gait Generation in Humanoid Robots - MDPI, https://www.mdpi.com/2313-7673/10/1/30</li>
<li>Model-based Predictive Control (MPC), https://engineering.purdue.edu/~zak/Second_ed/MPC_handout.pdf</li>
<li>Benchmarking Different QP Formulations and Solvers for Dynamic Quadrupedal Walking, <a href="https://www.dfki.de/fileadmin/user_upload/import/15642_2024_icra_mpc_benchmark_master_(13).pdf">https://www.dfki.de/fileadmin/user_upload/import/15642_2024_icra_mpc_benchmark_master_%2813%29.pdf</a></li>
<li>A Hierarchical MPC for End-Effector Tracking Control of Legged Mobile Manipulators - IEEE Xplore, https://ieeexplore.ieee.org/iel8/8856/4358066/10559798.pdf</li>
<li>Choosing robust constraints for MPC by using Lyapunov equation? - Math Stack Exchange, https://math.stackexchange.com/questions/2743489/choosing-robust-constraints-for-mpc-by-using-lyapunov-equation</li>
<li>SOFT CONSTRAINTS AND EXACT PENALTY FUNCTIONS IN MODEL PREDICTIVE CONTROL - Spiral, https://spiral.imperial.ac.uk/bitstream/10044/1/10241/6/cued_control_53.pdf</li>
<li>Learning Soft Constrained MPC Value Functions: Efficient MPC Design and Implementation providing Stability and Safety Guarantees, https://proceedings.mlr.press/v242/chatzikiriakos24a/chatzikiriakos24a.pdf</li>
<li>Predictive control barrier functions: Enhanced safety mechanisms for learning-based control - arXiv, https://arxiv.org/pdf/2105.10241</li>
<li>Safety-Critical Model Predictive Control with Discrete-Time Control Barrier Function - Hybrid Robotics, https://hybrid-robotics.berkeley.edu/publications/ACC2021_MPC_CBF.pdf</li>
<li>Multi-Layered Safety for Legged Robots via Control Barrier Functions and Model Predictive Control - Aaron Ames - Caltech, http://ames.caltech.edu/grandia2021multi.pdf</li>
<li>Real-Time QP Solvers: A Concise Review and Practical Guide Towards Legged Robots, https://arxiv.org/html/2510.21773v1</li>
<li>Real-Time QP Solvers: A Concise Review and Practical Guide Towards Legged Robots, https://arxiv.org/html/2510.21773v2</li>
<li>Design and Experimental Comparison of PID, LQR and MPC Stabilizing Controllers for Parrot Mambo Mini-Drone - MDPI, https://www.mdpi.com/2226-4310/9/6/298</li>
<li>Neural Network Based Model Predictive Control for a Quadrotor UAV - MDPI, https://www.mdpi.com/2226-4310/9/8/460</li>
<li>Trajectory tracking control of quadrotor using MPC and Gaussian process regression compensation - SPIE Digital Library, https://www.spiedigitallibrary.org/conference-proceedings-of-spie/13077/130770Q/Trajectory-tracking-control-of-quadrotor-using-MPC-and-Gaussian-process/10.1117/12.3027184.short</li>
<li>Hierarchical Incremental MPC for Redundant Robots: A Robust and Singularity-Free Approach, https://elib.dlr.de/203423/1/Hierarchical_Incremental_MPC_for_Redundant_Robots_A_Robust_and_Singularity-Free_Approach.pdf</li>
<li>Nonlinear Model Predictive Control in the Application of Constrained Manipulator Control - mediaTUM, https://mediatum.ub.tum.de/doc/1237922/file.pdf</li>
<li>Differentiable MPC for End-to-end Planning and Control - NIPS papers - NeurIPS, https://papers.nips.cc/paper/8050-differentiable-mpc-for-end-to-end-planning-and-control</li>
<li>Actor-Critic Model Predictive Control: Differentiable Optimization meets Reinforcement Learning for Agile Flight - arXiv, https://arxiv.org/html/2306.09852v8</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>