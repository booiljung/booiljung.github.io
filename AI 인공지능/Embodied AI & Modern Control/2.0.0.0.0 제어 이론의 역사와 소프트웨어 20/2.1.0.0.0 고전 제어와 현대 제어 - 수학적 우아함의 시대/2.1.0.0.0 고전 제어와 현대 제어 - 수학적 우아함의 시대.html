<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</a> / <span>2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</span></nav>
                </div>
            </header>
            <article>
                <h1>2.1 고전 제어와 현대 제어: 수학적 우아함의 시대</h1>
<h2>1.  서론: 결정론적 세계관과 제어의 미학</h2>
<p>오늘날 로봇 공학이 마주한 거대한 도전, 즉 비정형 환경에서의 적응과 불확실성 극복이라는 과제를 이해하기 위해서는, 우리가 지나온 지적 여정의 출발점을 명확히 복기해야 한다. 현대의 임바디드 AI(Embodied AI)가 데이터와 신경망이라는 거대한 파도 위에서 확률론적 추론을 수행하는 ’학습자(Learner)’라면, 그 이전 세대의 제어 이론은 물리학과 수학적 모델이라는 견고한 대지 위에서 최적의 해를 계산해내는 ’해결사(Solver)’였다. 이 장에서는 1960년대를 전후로 발생한 제어 이론의 패러다임 전환, 즉 주파수 영역(Frequency Domain)의 직관적 예술에서 시간 영역(Time Domain)의 수학적 정밀함으로의 이행을 심도 있게 다룬다.</p>
<p>우리는 이 시기를 ’수학적 우아함(Mathematical Elegance)의 시대’라고 부른다. 이는 단순히 수식이 복잡해졌다는 의미가 아니다. 시스템의 거동을 선형 대수학(Linear Algebra)과 미분 방정식(Differential Equation)이라는 보편적인 언어로 기술함으로써, 엔지니어들은 물리적 실체를 추상적인 상태 공간(State Space)으로 옮겨와 다룰 수 있게 되었다. 이 과정에서 탄생한 선형 2차 조정기(LQR)와 칼만 필터(Kalman Filter)는 단순한 알고리즘을 넘어, 인간이 복잡한 세계를 이해하고 통제하려는 철학적 시도의 정점이었다.</p>
<p>그러나 이 완벽해 보였던 수학적 성(城)은 역설적으로 ’모델링의 한계’라는 현실의 벽 앞에서 균열을 드러내기 시작했다. 본 절에서는 고전 제어의 직관이 왜 우주 경쟁(Space Race)이라는 시대적 요구 속에서 현대 제어로 대체될 수밖에 없었는지, 그리고 현대 제어가 이룩한 ’최적성(Optimality)’의 신화가 훗날 존 도일(John Doyle)의 반례를 통해 어떻게 해체되었는지를 추적한다. 이러한 역사적, 수리적 배경을 이해하는 것은 왜 오늘날의 로봇 공학이 ‘소프트웨어 2.0’, 즉 딥러닝과 강화학습으로 나아갈 수밖에 없었는지를 설명하는 핵심적인 단서가 된다.</p>
<h2>2.  주파수 영역의 직관: 고전 제어의 유산</h2>
<p>1940년대와 50년대, 제어 공학은 ’고전 제어(Classical Control)’라 불리는 황금기를 구가하고 있었다. 이 시기의 제어 이론은 제임스 와트(James Watt)의 증기 기관 조속기에서 시작된 피드백(Feedback)의 개념을 니콜라스 미노르스키(Nicolas Minorsky), 해리 나이퀴스트(Harry Nyquist), 헨드릭 보드(Hendrik Wade Bode) 등의 선구자들이 체계화한 결과물이었다.1</p>
<h3>2.1 전달 함수와 라플라스 변환의 마법</h3>
<p>고전 제어의 핵심 철학은 시스템을 ’블랙박스(Black Box)’로 간주하는 입출력(Input-Output) 관점에 있다. 엔지니어들은 시스템 내부의 복잡한 물리적 상호작용—기어의 마찰, 전자의 흐름, 유체의 점성 등—을 미시적으로 분석하는 대신, 입력 신호가 출력 신호로 변환되는 거시적인 비율, 즉 **전달 함수(Transfer Function, <span class="math math-inline">G(s)</span>)**에 집중했다.</p>
<p>이 접근법을 가능하게 한 수학적 도구는 라플라스 변환(Laplace Transform)이었다. 시간 <span class="math math-inline">t</span>의 함수로 기술되는 미분 방정식을 복소 변수 <span class="math math-inline">s</span>의 함수로 변환함으로써, 엔지니어들은 미적분 문제를 대수적인 곱셈과 나눗셈 문제로 치환할 수 있었다. 예를 들어, 시간 영역에서의 복잡한 컨볼루션(Convolution) 연산은 <span class="math math-inline">s</span>-영역(주파수 영역)에서 단순한 곱셈 <span class="math math-inline">Y(s) = G(s)U(s)</span>로 표현된다.2</p>
<p>이러한 변환은 엔지니어들에게 강력한 직관을 제공했다. 시스템의 극점(Pole)이 복소 평면(s-plane)의 좌반면에 위치하면 시스템은 안정하고, 허수축에 가까울수록 진동 성분이 강해진다는 사실을 시각적으로 확인할 수 있었다.</p>
<h3>2.2 루프 쉐이핑(Loop Shaping): 공학적 예술</h3>
<p>고전 제어 설계는 엄밀한 최적화 과정이라기보다는 일종의 예술적 기교에 가까웠다. 엔지니어들은 보드 선도(Bode Plot)나 나이퀴스트 선도(Nyquist Plot)와 같은 그래픽 도구를 사용하여 시스템의 주파수 응답을 분석했다. 그들은 이득 여유(Gain Margin)와 위상 여유(Phase Margin)라는 지표를 통해 시스템이 얼마나 안정한지를 판별하고, 제어기(Controller)의 파라미터를 조정하여 원하는 응답 특성을 조각(Shaping)해 나갔다.3</p>
<p>특히 1948년 월터 에반스(Walter Evans)가 제안한 **근궤적법(Root Locus Method)**은 이러한 직관적 설계의 정점이었다. 근궤적법은 제어 이득(Gain) <span class="math math-inline">K</span>가 0에서 무한대로 변할 때, 폐루프 시스템의 극점이 복소 평면 상에서 그리는 궤적을 도식화한 것이다. 엔지니어는 이 궤적을 보며 “이득을 높이면 시스템이 불안정해지겠구나” 혹은 “이득을 이 정도로 설정하면 적절한 감쇠비(Damping Ratio)를 얻을 수 있겠구나“를 직관적으로 판단할 수 있었다.4 앙리 푸앵카레(Henri Poincaré)가 언급했듯, 이러한 “수학적 우아함은 정신의 경제성(Economy of Thought)과 연결되어 있으며, 해결책을 우리 마음의 필요에 적응시키는 과정“이었다.5</p>
<h3>2.3 단일 입출력(SISO)의 한계와 시대적 요구</h3>
<p>그러나 고전 제어는 태생적인 한계를 안고 있었다. 가장 치명적인 제약은 <strong>단일 입력 단일 출력(SISO: Single-Input Single-Output)</strong> 시스템에 최적화되어 있다는 점이었다.2 초기의 산업 공정이나 간단한 서보 기구는 하나의 입력(예: 전압)으로 하나의 출력(예: 속도)을 제어하는 구조였기에 문제가 없었다. 하지만 입력과 출력이 여러 개이고 서로 복잡하게 얽혀 있는 **다변수 시스템(MIMO: Multi-Input Multi-Output)**을 다룰 때, 고전 제어의 주파수 영역 기법은 급격히 복잡해졌다.</p>
<p>MIMO 시스템을 고전 제어로 다루기 위해서는 각 입력-출력 쌍에 대한 전달 함수 행렬을 구하고, 채널 간의 간섭(Coupling)을 제거하기 위한 복잡한 디커플링(Decoupling) 기법을 사용해야 했다. 또한, 전달 함수는 <strong>선형 시불변(LTI: Linear Time-Invariant)</strong> 시스템을 가정하기 때문에, 로켓의 연료 소비로 인한 질량 변화와 같은 시변(Time-Varying) 특성이나 로봇 팔의 동역학에 내재된 비선형성(Nonlinearity)을 다루기에는 근본적인 어려움이 있었다.7</p>
<h2>3.  패러다임의 전환: 스푸트니크 충격과 상태 공간의 등장</h2>
<p>1957년 10월 4일, 소련이 쏘아 올린 인류 최초의 인공위성 스푸트니크 1호는 전 세계, 특히 미국의 공학계에 엄청난 충격을 주었다. 우주 경쟁(Space Race)의 개막은 제어 이론의 역사에서도 결정적인 분기점이 되었다. 우주 발사체와 위성은 고전 제어가 다루던 시스템과는 차원이 다른 복잡성을 요구했다.</p>
<p>우주선은 수많은 센서와 추진기(Actuator)가 유기적으로 연결된 고차원 MIMO 시스템이었으며, 궤도 역학은 본질적으로 비선형적이었고, 임무 수행 중 시스템의 파라미터가 지속적으로 변하는 시변 시스템이었다. 무엇보다 우주 미션은 극한의 정밀도와 효율성을 요구했다. 연료는 제한적이었고, 궤도 오차는 임무 실패로 직결되었다. 단순히 시스템을 “안정하게” 만드는 것만으로는 부족했으며, 연료 소모를 최소화하거나 도달 시간을 단축하는 <strong>“최적(Optimal)”</strong> 제어가 절실했다.7</p>
<p>이러한 시대적 소명에 응답하여 1960년대 초반, 루돌프 칼만(R. E. Kalman) 등을 주축으로 한 <strong>‘현대 제어(Modern Control)’</strong> 이론이 등장했다. 현대 제어는 주파수 영역의 <span class="math math-inline">s</span>-평면을 떠나 다시 19세기의 미분 방정식이 지배하는 **시간 영역(Time Domain)**으로 회귀했다. 그러나 이는 과거로의 단순한 복귀가 아니었다. 현대 제어는 선형 대수학(Linear Algebra)이라는 강력한 무기를 장착하고, 시스템을 **상태 공간(State Space)**이라는 새로운 프레임워크 위에서 재정의했다.3</p>
<h3>3.1 상태(State): 시스템의 모든 기억을 담다</h3>
<p>현대 제어 이론의 가장 위대한 지적 도약은 **‘상태(State)’**라는 개념의 도입이다. 상태 변수(State Variable) <span class="math math-inline">x(t)</span>는 시스템의 과거 이력을 모두 요약하고 있으며, 현재의 입력 <span class="math math-inline">u(t)</span>와 함께 미래의 거동을 완벽하게 결정짓는 최소한의 정보 집합으로 정의된다.10</p>
<p>전달 함수가 시스템을 ’입력에서 출력으로 가는 통로’로 보았다면, 상태 공간 모델은 시스템의 ’내부 상태’가 시간에 따라 어떻게 변화하는지를 직접 기술한다. 선형 시스템에 대한 상태 공간 표현법은 다음과 같은 1계 벡터 미분 방정식으로 기술된다:<br />
<span class="math math-display">
\begin{aligned} \dot{x}(t) &amp;= A x(t) + B u(t) \\ y(t) &amp;= C x(t) + D u(t) \end{aligned}
</span><br />
여기서 각 변수와 행렬은 다음과 같은 물리적 의미를 갖는다:</p>
<ul>
<li><span class="math math-inline">x(t) \in \mathbb{R}^n</span>: <strong>상태 벡터 (State Vector)</strong>. 로봇의 관절 각도, 각속도, 위치, 속도 등 시스템의 현재 상황을 나타내는 <span class="math math-inline">n</span>개의 변수들의 집합이다.</li>
<li><span class="math math-inline">u(t) \in \mathbb{R}^m</span>: <strong>입력 벡터 (Input Vector)</strong>. 모터의 토크, 전압 등 제어기가 시스템에 가하는 <span class="math math-inline">m</span>개의 제어 신호이다.</li>
<li><span class="math math-inline">y(t) \in \mathbb{R}^p</span>: <strong>출력 벡터 (Output Vector)</strong>. 엔코더, IMU 센서 등을 통해 실제로 관측 가능한 <span class="math math-inline">p</span>개의 측정값이다.</li>
<li><span class="math math-inline">A \in \mathbb{R}^{n \times n}</span>: <strong>시스템 행렬 (System Matrix)</strong>. 입력이 없을 때 시스템이 어떻게 변화하는지(동역학)를 나타낸다.</li>
<li><span class="math math-inline">B \in \mathbb{R}^{n \times m}</span>: <strong>입력 행렬 (Input Matrix)</strong>. 제어 입력이 상태 변화에 미치는 영향을 나타낸다.</li>
<li><span class="math math-inline">C \in \mathbb{R}^{p \times n}</span>: <strong>출력 행렬 (Output Matrix)</strong>. 내부 상태가 센서 데이터로 어떻게 관측되는지를 나타낸다.</li>
<li><span class="math math-inline">D \in \mathbb{R}^{p \times m}</span>: <strong>직달 행렬 (Feedthrough Matrix)</strong>. 입력이 출력에 직접적인 영향을 미치는 경로를 나타낸다 (물리 시스템에서는 보통 0인 경우가 많다).</li>
</ul>
<p>이 수식의 진정한 우아함은 그 **보편성(Universality)**에 있다. 1자유도의 간단한 진자 시스템이든, 수십 개의 관절을 가진 휴머노이드 로봇이든, 혹은 거대한 화학 공정 시스템이든, 모든 선형 동적 시스템은 이 <span class="math math-inline">A, B, C, D</span> 행렬로 표현될 수 있다. 차원(<span class="math math-inline">n</span>)의 크기만 달라질 뿐 수학적 구조는 불변이다.11 이는 컴퓨터를 이용한 수치 해석과 시뮬레이션에 최적화된 형태였으며, 로봇 제어가 소프트웨어 알고리즘으로 구현될 수 있는 기반을 마련했다.</p>
<h3>3.2 비교: 고전 제어와 현대 제어의 대조</h3>
<p>다음 표는 고전 제어와 현대 제어의 주요 차이점을 요약한다. 이 비교는 두 접근법이 서로 다른 철학적 기반을 가지고 있음을 보여준다.2</p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>고전 제어 (Classical Control)</strong></th><th><strong>현대 제어 (Modern Control)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 도구</strong></td><td>라플라스 변환, 전달 함수 (<span class="math math-inline">G(s)</span>)</td><td>선형 대수학, 상태 공간 방정식 (<span class="math math-inline">\dot{x}=Ax+Bu</span>)</td></tr>
<tr><td><strong>영역 (Domain)</strong></td><td>주파수 영역 (Frequency Domain, s-plane)</td><td>시간 영역 (Time Domain, t-domain)</td></tr>
<tr><td><strong>적용 대상</strong></td><td>SISO, 선형 시불변(LTI) 시스템 중심</td><td>MIMO, 시변(Time-Varying), 비선형 시스템 확장 가능</td></tr>
<tr><td><strong>설계 목표</strong></td><td>안정성 확보, 과도 응답 특성 (오버슈트, 정착시간)</td><td>최적성 (비용 함수 최소화), 상태 추정</td></tr>
<tr><td><strong>접근 방식</strong></td><td>루프 쉐이핑, 시행착오적 튜닝, 직관적</td><td>모델 기반 해석적 해(Analytical Solution), 체계적</td></tr>
<tr><td><strong>강점</strong></td><td>모델 불확실성에 대한 강건성, 물리적 통찰 제공</td><td>다변수 시스템의 우아한 처리, 최적 제어 구현</td></tr>
<tr><td><strong>약점</strong></td><td>다변수 시스템 설계의 난해함</td><td>정확한 수학적 모델 요구 (Modeling Bottleneck)</td></tr>
</tbody></table>
<h2>4.  최적 제어(Optimal Control): LQR의 수학적 미학</h2>
<p>현대 제어 이론이 고전 제어와 구별되는 가장 큰 특징은 **최적화(Optimization)**의 도입이다. 고전 제어가 “시스템을 안정하게 만들기 위해 이득(Gain)을 어떻게 조절할까?“라는 질문을 던졌다면, 현대 제어는 “무엇이 **최선(Best)**의 제어인가?“라는 근원적인 질문을 수학적으로 정식화했다. 이 질문에 대한 가장 아름답고 강력한 대답이 바로 **LQR (Linear Quadratic Regulator)**이다.</p>
<h4>4.0.1 비용 함수(Cost Function)와 트레이드오프의 수치화</h4>
<p>LQR은 제어 목적을 달성하기 위해 지불해야 하는 ’비용’을 수학적으로 정의한다. 일반적으로 무한 시간(Infinite Horizon)에 대한 2차 비용 함수 <span class="math math-inline">J</span>는 다음과 같이 정의된다.12<br />
<span class="math math-display">
J = \int_{0}^{\infty} \left( x(t)^T Q x(t) + u(t)^T R u(t) \right) dt
</span><br />
이 식은 로봇 공학에서 발생하는 **성능(Performance)**과 <strong>효율(Efficiency)</strong> 사이의 영원한 트레이드오프를 수학적으로 표현한 것이다.</p>
<ul>
<li><strong><span class="math math-inline">x(t)^T Q x(t)</span></strong>: 상태 오차에 대한 페널티이다. 상태 <span class="math math-inline">x(t)</span>가 0(목표 지점)에서 멀어질수록 비용이 증가한다. 행렬 <span class="math math-inline">Q</span>는 어떤 상태 변수의 오차를 더 중요하게 생각할지 결정하는 가중치이다.</li>
<li><strong><span class="math math-inline">u(t)^T R u(t)</span></strong>: 제어 입력(에너지)에 대한 페널티이다. 큰 힘이나 토크를 사용할수록 비용이 증가한다. 행렬 <span class="math math-inline">R</span>은 에너지 소비를 얼마나 억제할지 결정한다.</li>
</ul>
<p>설계자가 <span class="math math-inline">Q</span>의 값을 크게 설정하면, 제어기는 비용을 줄이기 위해 상태 오차를 빠르게 0으로 만들려 할 것이고, 결과적으로 로봇은 빠르고 공격적으로 움직인다. 반면 <span class="math math-inline">R</span>을 크게 설정하면, 제어기는 입력 에너지를 아끼려 할 것이고, 로봇은 느리고 부드럽게 움직일 것이다. LQR은 이 두 가지 상충되는 목표 사이에서, 비용 함수 <span class="math math-inline">J</span>를 최소화하는 유일한(Unique) 최적의 해를 찾아낸다.</p>
<h3>4.1 대수 리카티 방정식과 상태 피드백</h3>
<p>놀랍게도, 변분법(Calculus of Variations)이나 동적 계획법(Dynamic Programming)을 통해 유도된 이 최적화 문제의 해는 매우 단순한 선형 <strong>상태 피드백(State Feedback)</strong> 형태로 나타난다.<br />
<span class="math math-display">
u(t) = -K x(t)
</span><br />
여기서 최적 이득 행렬 <span class="math math-inline">K</span>는 **대수 리카티 방정식(Algebraic Riccati Equation, ARE)**이라는 행렬 방정식을 풀어서 얻어진다.12<br />
<span class="math math-display">
A^T P + P A - P B R^{-1} B^T P + Q = 0
</span></p>
<p><span class="math math-display">
K = R^{-1} B^T P
</span></p>
<p>이 과정은 수학적으로 매우 우아하다. 복잡한 미분 방정식을 푸는 대신, 리카티 방정식이라는 대수적 방정식을 풂으로써 전역적으로 최적(Globally Optimal)인 제어 입력을 얻을 수 있기 때문이다. 해 <span class="math math-inline">P</span>가 양의 정부호(Positive Definite) 행렬로 존재한다면, LQR 제어기가 적용된 폐루프 시스템(<span class="math math-inline">A-BK</span>)은 반드시 안정(Stable)하다는 것이 수학적으로 증명되어 있다.12</p>
<h3>4.2 LQR의 이론적 강건성: 무한대의 여유</h3>
<p>1960-70년대 연구자들을 더욱 매료시킨 것은 LQR이 가진 놀라운 강건성(Robustness) 특성이었다. 이론적으로 LQR 제어기는 다음과 같은 안정성 여유를 보장한다12:</p>
<ol>
<li><strong>무한대의 이득 여유 (Infinite Gain Margin):</strong> 시스템의 이득이 아무리 커져도(모델과 실제 플랜트 사이의 이득 차이), 폐루프 시스템은 불안정해지지 않는다.</li>
<li><strong>최소 60도의 위상 여유 (60<span class="math math-inline">^\circ</span> Phase Margin):</strong> 신호 지연이나 위상 왜곡에 대해 상당한 저항력을 가진다.</li>
<li><strong>이득 감소 여유 (Gain Reduction Margin):</strong> 이득이 절반(<span class="math math-inline">0.5</span>)으로 떨어져도 안정성이 유지된다.</li>
</ol>
<p>이러한 특성은 현대 제어 이론이 완벽에 가깝다는 믿음을 심어주기에 충분했다. 엔지니어들은 정확한 모델만 있다면, LQR을 통해 안정성과 최적성을 동시에 잡을 수 있다고 믿었다. 이는 훗날 로봇의 동작 생성(Motion Generation)과 궤적 최적화(Trajectory Optimization)의 근간이 되었으며, 오늘날의 모델 예측 제어(MPC)나 강화학습의 보상 함수 설계에도 직접적인 영향을 미치고 있다.</p>
<h2>5.  칼만 필터(Kalman Filter): 불확실성 속의 추정</h2>
<p>LQR이 “시스템의 모든 상태 <span class="math math-inline">x</span>를 정확히 알고 있다“고 가정하는 이상적인 상황을 다룬다면, 현실은 훨씬 더 지저분하다. 로봇의 센서는 노이즈가 섞여 있고, 모든 상태를 직접 측정할 수 없는 경우(예: 로봇 팔의 각도는 알지만 각속도는 직접 측정하지 못하는 경우)가 대부분이다. 불확실한 현실에서 숨겨진 상태를 찾아내는 문제, 이것이 **추정(Estimation)**의 영역이며, 그 중심에 **칼만 필터(Kalman Filter)**가 있다.</p>
<p>1960년 루돌프 칼만이 발표한 기념비적인 논문 *“A New Approach to Linear Filtering and Prediction Problems”*는 제어 이론뿐만 아니라 통신, 경제학, 그리고 현대 AI의 확률론적 모델링에 이르기까지 지대한 영향을 미쳤다.16</p>
<h3>5.1 재귀적 추정과 베이지안의 구현</h3>
<p>칼만 필터는 잡음이 섞인 관측 데이터로부터 시스템의 상태를 최적으로 추정하는 알고리즘이다. 그 핵심 원리는 **예측(Prediction)**과 **보정(Correction)**의 끊임없는 순환에 있다. 이는 인지과학에서 말하는 인간의 뇌가 세상을 인식하는 방식—예측 부호화(Predictive Coding)—과도 일맥상통한다.19</p>
<ol>
<li>예측 단계 (Time Update): “로봇이 지난 0.1초 동안 속도 <span class="math math-inline">v</span>로 움직였으니, 현재 위치는 이만큼 변했을 것이다.”</li>
</ol>
<p>시스템 모델(<span class="math math-inline">A, B</span>)을 사용하여 현재 상태를 예측한다. 이때, 시간이 지남에 따라 예측의 불확실성을 나타내는 오차 공분산 행렬 <span class="math math-inline">P</span>는 커진다.<br />
<span class="math math-display">
   \hat{x}_{k|k-1} = A \hat{x}_{k-1|k-1} + B u_{k-1}
</span></p>
<p><span class="math math-display">
   P_{k|k-1} = A P_{k-1|k-1} A^T + Q_{process}
</span></p>
<ol start="2">
<li>보정 단계 (Measurement Update): “하지만 GPS 센서는 위치가 여기라고 말한다. 내 예측과 센서 값 사이의 차이(Residual)를 반영하자.”</li>
</ol>
<p>실제 측정값 <span class="math math-inline">z_k</span>가 들어오면, 예측값과의 차이를 계산하고 이를 바탕으로 예측값을 수정한다. 이때 ’얼마나 수정할 것인가’를 결정하는 가중치가 바로 **칼만 이득(Kalman Gain, <span class="math math-inline">K_k</span>)**이다.<br />
<span class="math math-display">
   K_k = P_{k|k-1} C^T (C P_{k|k-1} C^T + R_{sensor})^{-1}\\
   \hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k (z_k - C \hat{x}_{k|k-1})
</span></p>
<h3>5.2 칼만 이득의 아름다움과 쌍대성</h3>
<p>칼만 필터의 진정한 ’아름다움’은 칼만 이득 <span class="math math-inline">K_k</span>가 상황에 따라 자동적으로, 그리고 최적으로 조절된다는 점에 있다.21</p>
<ul>
<li>만약 센서 노이즈(<span class="math math-inline">R_{sensor}</span>)가 매우 크다면, 식에 의해 <span class="math math-inline">K_k</span>는 작아진다. 즉, 필터는 측정값을 “신뢰하지 않고” 자신의 모델 예측을 더 믿는다.</li>
<li>반대로 모델의 불확실성(<span class="math math-inline">P_{k|k-1}</span>)이 크거나 센서가 정밀하다면, <span class="math math-inline">K_k</span>는 커진다. 필터는 측정값을 적극적으로 반영하여 상태를 보정한다.</li>
</ul>
<p>이러한 메커니즘은 확률론적 로보틱스(Probabilistic Robotics)에서 말하는 **베이지안 필터(Bayesian Filter)**의 가우시안(Gaussian) 구현체이다. 칼만 필터는 모든 오차 분포가 가우시안 분포를 따른다는 가정하에, 평균 제곱 오차(Mean Squared Error)를 최소화하는 최적 추정기(MMSE Estimator)임이 증명되었다.23</p>
<p>더욱 흥미로운 사실은 **LQR 제어기와 칼만 필터의 쌍대성(Duality)**이다. LQR이 비용 함수를 최소화하기 위해 제어 이득을 구하는 수학적 구조와, 칼만 필터가 오차 공분산을 최소화하기 위해 칼만 이득을 구하는 구조는 완전히 동일하다(<span class="math math-inline">A</span> 대신 <span class="math math-inline">A^T</span>, <span class="math math-inline">B</span> 대신 <span class="math math-inline">C^T</span>를 사용하는 대칭성).18 이는 제어(Control)와 추정(Estimation)이 동전의 양면과 같다는 심오한 통찰을 제공하며, 현대 제어 이론의 수학적 완결성을 상징하는 사례로 꼽힌다.</p>
<h2>6.  LQG와 분리 원리: 우아함의 정점과 균열</h2>
<p>LQR 제어기와 칼만 필터 추정기를 결합하면, 센서 노이즈와 프로세스 노이즈가 존재하는 현실적인 상황에서도 최적 제어를 수행할 수 있는 시스템이 완성된다. 이를 <strong>LQG (Linear Quadratic Gaussian)</strong> 제어기라고 부른다.</p>
<p>LQG의 기반에는 **분리 원리(Separation Principle)**라는 강력한 이론이 깔려 있다. 이 원리는 “선형 시스템에서 최적의 제어기를 설계하는 문제와 최적의 추정기를 설계하는 문제는 서로 독립적이며, 각각 최적으로 설계하여 단순히 연결하기만 해도 전체 시스템은 여전히 최적이다“라고 말한다.25</p>
<p>즉, 엔지니어는 제어기를 설계할 때 상태를 어떻게 추정할지 고민할 필요가 없고, 추정기를 설계할 때 제어 목적을 고려할 필요가 없다. 이는 복잡한 시스템 설계를 모듈화할 수 있게 해주는 마법과도 같은 원리였다.</p>
<p>1970년대 중반까지, 제어 이론가들은 선형 시스템의 세계를 정복했다고 믿었다. 수학적으로 완벽한 모델(<span class="math math-inline">Ax+Bu</span>), 모든 목적을 아우르는 최적화(<span class="math math-inline">J</span>), 불확실성을 다루는 필터(Kalman), 그리고 이들을 잇는 우아한 분리 원리까지. 현대 제어 이론은 흠잡을 데 없는 논리적 완결성을 갖춘 듯 보였다.</p>
<h3>6.1 도일의 반례: “보장된 여유는 없다 (There are none)”</h3>
<p>그러나 이 ’수학적 우아함’의 시대는 가장 예상치 못한 곳에서 균열을 맞이하게 된다. 1978년, 존 도일(John Doyle)은 *“Guaranteed Margins for LQG Regulators”*라는 논문에서 단 4페이지의 짧은 반례를 통해 LQG 제어기의 치명적인 약점을 폭로했다.26</p>
<p>앞서 LQR은 무한대의 이득 여유와 60도의 위상 여유를 보장한다고 했다. 하지만 도일은 LQR에 칼만 필터를 결합하여 LQG를 구성하는 순간, 이 보장된 여유가 사라진다는 것을 증명했다. 아주 간단한 2차 시스템에서조차, LQG 제어기는 모델링 오차가 조금만 있어도, 혹은 루프 내에 아주 미세한 지연만 발생해도 안정성 여유가 ’0’으로 수렴할 수 있었다. 논문의 초록(Abstract)은 전설적인 세 단어로 구성되어 있었다:</p>
<blockquote>
<p><strong>“There are none.” (보장된 여유는 없다.)</strong></p>
</blockquote>
<p>이 사건은 현대 제어 이론의 흐름을 다시 한번 뒤바꾸었다. 수학적으로 ’최적(Optimal)’이라는 것이 현실 세계에서 ’강건(Robust)’하다는 것을 의미하지는 않았다. 모델이 현실을 완벽하게 대변하지 못한다면, 모델에 과도하게 최적화된 제어기는 오히려 현실의 작은 불일치에도 쉽게 붕괴될 수 있다는 사실이 밝혀진 것이다. 이 깨달음은 이후 <span class="math math-inline">H_\infty</span> 제어와 같은 <strong>강건 제어(Robust Control)</strong> 이론의 발전을 촉발시켰으며, 더 나아가 모델링 자체가 불가능한 복잡한 환경을 다루기 위해 <strong>데이터 기반(Data-Driven)</strong> 접근법, 즉 우리가 다음 절들에서 다루게 될 소프트웨어 2.0과 딥러닝 기반의 제어로 나아가는 필연적인 계기가 되었다.28</p>
<h2>7.  결론: Solver에서 Learner로의 여정을 위한 초석</h2>
<p>고전 제어와 현대 제어의 역사는 인간이 물리 세계를 제어하기 위해 수학적 모델을 어떻게 발전시켜 왔는지를 보여주는 장대한 서사시이다. 고전 제어가 주파수 영역에서 엔지니어의 직관을 도식화했다면, 현대 제어는 이를 시간 영역의 상태 공간으로 옮겨와 컴퓨터가 풀 수 있는 문제(Solver)로 정형화했다.</p>
<p>LQR과 칼만 필터는 단순한 과거의 유물이 아니다. 이들은 오늘날에도 여전히 로봇 제어의 중추적인 역할을 담당하고 있다. 보스턴 다이내믹스(Boston Dynamics)의 아틀라스(Atlas) 로봇이 보여주는 경이로운 균형 감각 뒤에는 빠른 주기로 리카티 방정식을 풀어대는 LQR 기반의 MPC(Model Predictive Control)가 존재하며, 자율주행 자동차가 GPS 신호가 끊긴 터널 속에서도 위치를 잃지 않는 것은 칼만 필터와 그 변형 알고리즘들 덕분이다.13</p>
<p>그러나 도일의 반례가 시사했듯, 수학적 모델링에만 의존하는 접근법은 명확한 한계(Modeling Bottleneck)를 가진다. 우리가 마주할 ’임바디드 AI’의 세계는 선형화할 수 없는 접촉, 예측 불가능한 상호작용, 그리고 수식으로 표현하기엔 너무나 고차원적인 시각적 입력들로 가득 차 있다.</p>
<p>이제 우리는 수학적으로 우아한 ’해석적 해’를 구하는 시대를 지나, 데이터로부터 스스로 해를 ’학습(Learning)’하는 시대로 진입하고 있다. 하지만 그 새로운 여정에서도 상태(State), 비용(Cost), 최적화(Optimization), 그리고 추정(Estimation)이라는 현대 제어의 유산은 형태만 바꾼 채—강화학습의 가치 함수(Value Function)로, 생성 모델의 잠재 공간(Latent Space)으로—여전히 로봇 지능의 핵심 코어로 작동하고 있음을 기억해야 한다. 이어지는 절에서는 이 완벽해 보였던 제어 이론이 현실의 복잡성 앞에서 어떻게 좌절하고, 그 한계를 넘어서기 위해 어떤 새로운 도구들이 등장했는지 살펴볼 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Control theory - Wikipedia, https://en.wikipedia.org/wiki/Control_theory</li>
<li>Classical vs. Modern Control – Differences and Advantages, https://controlabo.com/en/classic-modern/</li>
<li>What’s the difference between classical and modern control theory and is the former worth learning? : r/ControlTheory - Reddit, https://www.reddit.com/r/ControlTheory/comments/i2rhpf/whats_the_difference_between_classical_and_modern/</li>
<li>Root Locus Method for Control Systems Explained - Turn2Engineering, https://turn2engineering.com/electrical-engineering/control-systems-engineering/root-locus-method</li>
<li>410 quotes on Mathematician Science Quotes - Dictionary of Science Quotations and Scientist Quotes, https://todayinsci.com/QuotationsCategories/M_Cat/Mathematician-Quotations.htm</li>
<li>A comparison of classical and modern controller design : a case study - Pure - Eindhoven University of Technology, https://pure.tue.nl/ws/portalfiles/portal/4279359/9009853.pdf</li>
<li>What is classical control and when is it better than artificial intelligence?, https://journals.co.za/doi/pdf/10.10520/AJA10269185_2</li>
<li>Brief History of Feedback Control - F.L. Lewis, https://lewisgroup.uta.edu/history.htm</li>
<li>Modern Control Theory - A historical perspective -, https://sic.ici.ro/documents/890/Art._6_Issue_1_SIC_2006.pdf</li>
<li>State Space Models. The Linear-Time Alternative to… | by Ravi Sankar Uppala | Nov, 2025 | Medium, https://medium.com/@ravisankarit/state-space-models-a10473c9bd1f</li>
<li>Mathematical Systems Theory I - IEEE Xplore, https://ieeexplore.ieee.org/iel5/9/33927/01618858.pdf</li>
<li>Linear Quadratic Optimal Control - University of Washington, https://faculty.washington.edu/chx/teaching/me547/2_6_CT_LQ_slides.pdf</li>
<li>Extended Kalman Filter based Linear Quadratic Regulator Control for Optical Wireless Communication Alignment - KAUST Repository, https://repository.kaust.edu.sa/bitstreams/337186af-574e-480b-b235-000a625f42d1/download</li>
<li>Introduction to Optimal Control and Estimation - The Open Repository @ Binghamton (The ORB), https://orb.binghamton.edu/cgi/viewcontent.cgi?filename=12&amp;article=1002&amp;context=electrical_fac&amp;type=additional</li>
<li>19 LINEAR QUADRATIC REGULATOR, https://ocw.mit.edu/courses/2-154-maneuvering-and-control-of-surface-and-underwater-vehicles-13-49-fall-2004/2d5318503b8f97d5a5255596fcf2e3f1_lec19.pdf</li>
<li>1960_Kalman - A new approach to linear filtering and prediction problems - Orinal version with comments.pdf, <a href="https://skoge.folk.ntnu.no/puublications_others/1960_Kalman%20-%20A%20new%20approach%20to%20linear%20filtering%20and%20prediction%20problems%20-%20Orinal%20version%20with%20comments.pdf">https://skoge.folk.ntnu.no/puublications_others/1960_Kalman%20-%20A%20new%20approach%20to%20linear%20filtering%20and%20prediction%20problems%20-%20Orinal%20version%20with%20comments.pdf</a></li>
<li>The Seminal Kalman Filter Paper (1960) - UNC Computer Science, https://www.cs.unc.edu/~welch/kalman/kalmanPaper.html</li>
<li>A New Approach to Linear Filtering and Prediction Problems1, https://www.cs.cmu.edu/~motionplanning/papers/sbp_papers/k/Kalman1960.pdf</li>
<li>Kalman filter - Wikipedia, https://en.wikipedia.org/wiki/Kalman_filter</li>
<li>The Mathematics of the Kalman Filter - Alan Zucconi, https://www.alanzucconi.com/2022/07/24/kalman-gain/</li>
<li>In what sense is the Kalman filter optimal? - Signal Processing Stack Exchange, https://dsp.stackexchange.com/questions/78547/in-what-sense-is-the-kalman-filter-optimal</li>
<li>Exposing the Power of the Kalman Filter - Towards Data Science, https://towardsdatascience.com/exposing-the-power-of-the-kalman-filter-1b78621c3f56/</li>
<li>Tutorial: The Kalman Filter - MIT, <a href="https://web.mit.edu/kirtley/kirtley/binlustuff/literature/control/Kalman%20filter.pdf">https://web.mit.edu/kirtley/kirtley/binlustuff/literature/control/Kalman%20filter.pdf</a></li>
<li>The Kalman filter as the optimal linear minimum mean-squared error multiuser CDMA detector - ResearchGate, https://www.researchgate.net/publication/3080224_The_Kalman_filter_as_the_optimal_linear_minimum_mean-squared_error_multiuser_CDMA_detector</li>
<li>Linear–quadratic–Gaussian control - Wikipedia, <a href="https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic%E2%80%93Gaussian_control">https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic%E2%80%93Gaussian_control</a></li>
<li>Guaranteed Margins for LQG Regulators – CONLab - UT Dallas Research Labs, https://labs.utdallas.edu/conlab/guaranteed-margins-for-lqg-regulators/</li>
<li>Guaranteed Margins for LQG Regulators, https://murray.cds.caltech.edu/images/murray.cds/b/b4/Guaranteed_margins_for_LQG_regulators_-_doyle.pdf</li>
<li>A Comprehensive Review of Theories, Methods, and Techniques for Bottleneck Identification and Management in Manufacturing Systems - MDPI, https://www.mdpi.com/2076-3417/14/17/7712</li>
<li>Competence Amelioration of PMBLDC Motor using LQR- PID, Kalman Filter - ResearchGate, https://www.researchgate.net/profile/Ahmad-Ismail-62/publication/359256861_Competence_Amelioration_of_PMBLDC_Motor_using_LQR-PID_Kalman_Filter-PID_and_LQG_Based_on_Kalman_Filter-PID_optimal_Controllers_for_disturbance_attenuation/links/623194d6069a350c8b91299b/Competence-Amelioration-of-PMBLDC-Motor-using-LQR-PID-Kalman-Filter-PID-and-LQG-Based-on-Kalman-Filter-PID-optimal-Controllers-for-disturbance-attenuation.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>