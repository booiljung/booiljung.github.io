<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.4 미분 가능한 프로그래밍 (Differentiable Programming)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.4 미분 가능한 프로그래밍 (Differentiable Programming)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.4 미분 가능한 프로그래밍 (Differentiable Programming)</a> / <span>2.4 미분 가능한 프로그래밍 (Differentiable Programming)</span></nav>
                </div>
            </header>
            <article>
                <h1>2.4 미분 가능한 프로그래밍 (Differentiable Programming)</h1>
<h2>1.  서론: 소프트웨어 2.0과 프로그래밍 패러다임의 대전환</h2>
<p>인공지능과 컴퓨터 과학의 역사가 교차하는 지점에서, 우리는 ’미분 가능한 프로그래밍(Differentiable Programming, ∂P)’이라 불리는 새로운 패러다임의 부상을 목격하고 있다. 이는 단순한 기술적 방법론의 확장을 넘어, 소프트웨어를 구축하고 이해하는 방식에 대한 근본적인 철학적 전환을 내포한다. 전통적인 프로그래밍, 즉 안드레이 카파시(Andrej Karpathy)가 명명한 ’소프트웨어 1.0(Software 1.0)’의 시대에서 프로그래머는 문제를 해결하기 위해 명시적인 규칙을 작성했다. C++, Python, Java와 같은 언어를 사용하여 개발자는 알고리즘의 모든 분기, 루프, 예외 처리를 직접 설계하고 코딩해야 했다. 이 방식은 인간이 논리적으로 설명할 수 있는 문제들—예를 들어 웹 서버의 라우팅이나 데이터베이스 트랜잭션 처리—에는 탁월한 효율성을 발휘했지만, 이미지 인식이나 복잡한 로봇 제어와 같이 명시적인 규칙으로 기술하기 어려운 문제들 앞에서는 한계에 봉착했다.1</p>
<p>이에 반해 ’소프트웨어 2.0(Software 2.0)’은 인간이 코드를 작성하는 대신, 시스템이 달성해야 할 목표(Objective)와 제약 조건(Constraints)을 정의하고, 유연한 구조(Structure)인 신경망이나 파라미터화된 함수 블록을 제공하면, 최적화 알고리즘이 데이터를 통해 프로그램의 세부 동작을 스스로 결정하는 방식을 취한다. 얀 르쿤(Yann LeCun)은 딥러닝이 미분 가능한 프로그래밍의 특수한 형태에 불과하다고 주장하며, 이 새로운 패러다임이 가져올 파급력을 강조했다.1 딥러닝이 고정된 계층(Layer) 구조를 가진 신경망에 국한되었다면, 미분 가능한 프로그래밍은 기존 소프트웨어의 모든 구성 요소—루프, 재귀, 분기, 물리 엔진, 렌더러 등—를 미분 가능한 블록으로 재구성하여, 전체 시스템을 경사 하강법(Gradient Descent) 기반으로 최적화할 수 있게 만든다.</p>
<p>이러한 접근법은 복잡성 관리 측면에서 혁명적이다. 자율 주행 시스템을 예로 들면, 소프트웨어 1.0 방식에서는 차선 인식, 보행자 예측, 경로 계획, 제어 알고리즘을 각각 별도의 모듈로 개발하고 수동으로 튜닝해야 했다. 모듈 간의 상호작용은 예측 불가능하며, 하나의 모듈을 수정하면 전체 시스템에 예기치 않은 부작용을 초래할 수 있다. 그러나 미분 가능한 프로그래밍 환경에서는 인지부터 제어까지의 전 과정을 하나의 거대한 계산 그래프(Computational Graph)로 연결하고, 최종 주행 성능이라는 단일한 목표 함수를 최적화하는 방향으로 모든 모듈의 파라미터를 동시에 업데이트한다.4 이는 프로그램의 ‘작성’ 주체를 인간에서 최적화 알고리즘으로 이동시키며, 인간은 데이터 큐레이션과 아키텍처 설계라는 더 높은 차원의 ‘메타 프로그래밍’ 역할을 수행하게 됨을 의미한다.6</p>
<p>미분 가능한 프로그래밍의 핵심 전제는 “프로그램의 실행 과정이 매개변수에 대해 미분 가능하다면, 결과의 오류를 역전파(Backpropagation)하여 원인을 수정할 수 있다“는 것이다. 이는 기존에 블랙박스로 취급되던 시뮬레이터나 물리 엔진을 ’화이트박스’로 전환시키며, 로보틱스, 과학적 시뮬레이션, 제어 이론 등 다양한 분야에서 기존의 한계를 뛰어넘는 성과를 창출하고 있다.4</p>
<h2>2.  이론적 및 수학적 기초: 자동 미분(Automatic Differentiation)의 심층 분석</h2>
<p>미분 가능한 프로그래밍을 지탱하는 기술적 엔진은 자동 미분(Automatic Differentiation, AD)이다. 많은 입문자들이 AD를 딥러닝의 역전파 알고리즘과 동일시하거나, 단순히 미분을 계산하는 도구 정도로 이해하지만, AD는 수치 해석학에서 독자적이고 깊은 역사를 가진 기술군이다. AD는 컴퓨터 프로그램으로 표현된 함수의 도함수를 기계적인 정밀도로, 그리고 효율적으로 계산하는 방법론을 총칭한다.8</p>
<h3>2.1  미분 계산 방법론의 비교: 수치 미분, 기호 미분, 그리고 자동 미분</h3>
<p>컴퓨터상에서 미분을 수행하는 방법은 크게 세 가지로 분류할 수 있으며, 각 방식의 장단점을 이해하는 것은 AD의 중요성을 파악하는 데 필수적이다.</p>
<ol>
<li>수치 미분 (Numerical Differentiation):</li>
</ol>
<p>가장 직관적인 방법으로, 유한 차분법(Finite Difference)을 사용한다. 함수 <span class="math math-inline">f(x)</span>의 도함수를 <span class="math math-inline">f&#39;(x) \approx \frac{f(x+h) - f(x)}{h}</span>로 근사한다. 구현이 매우 간단하고 블랙박스 함수에도 적용 가능하다는 장점이 있지만, 치명적인 단점이 존재한다. <span class="math math-inline">h</span>가 너무 크면 절단 오차(Truncation Error)가 커지고, 너무 작으면 부동소수점 연산의 반올림 오차(Round-off Error)가 발생하여 정확한 값을 얻기 어렵다. 또한, 입력 변수가 <span class="math math-inline">N</span>개일 때 그라디언트를 구하기 위해서는 함수를 최소 <span class="math math-inline">N+1</span>번 평가해야 하므로, 수백만 개의 파라미터를 가진 신경망에는 적용이 불가능하다.7</p>
<ol start="2">
<li>기호 미분 (Symbolic Differentiation):</li>
</ol>
<p>Mathematica나 Maple과 같은 컴퓨터 대수 시스템(CAS)에서 사용하는 방식이다. 입력 수식을 수학적 규칙에 따라 기호적으로 변형하여 도함수 수식을 도출한다. 이는 해석적인 정확해를 제공하지만, ‘수식 팽창(Expression Swell)’ 문제를 겪는다. 복잡한 프로그램이나 반복문이 포함된 함수의 경우, 미분 결과 수식이 원본 수식보다 기하급수적으로 길어져 메모리를 감당할 수 없게 되며, 제어 흐름(Control Flow)이 포함된 알고리즘을 처리하는 데 한계가 있다.</p>
<ol start="3">
<li>자동 미분 (Automatic Differentiation):</li>
</ol>
<p>AD는 위 두 방식의 한계를 극복한다. AD는 소스 코드를 기호적으로 미분하는 것이 아니라, 프로그램의 실행 과정을 구성하는 기본 연산(덧셈, 곱셈, sin, exp 등)들의 순차적인 적용으로 분해하고, 각 단계에서 연쇄 법칙(Chain Rule)을 적용하여 미분값을 누적한다. 이 방식은 수치 미분과 달리 오차가 없으며(기계 정밀도 수준), 기호 미분과 달리 수식 팽창 문제가 발생하지 않는다. 무엇보다 if, while, for와 같은 제어 흐름이 포함된 임의의 복잡한 함수에 대해서도 정확한 미분값을 계산할 수 있다.8</p>
<h3>2.2  전진 모드(Forward Mode)와 후진 모드(Reverse Mode)</h3>
<p>자동 미분은 미분값을 누적하는 방향에 따라 전진 모드와 후진 모드로 나뉘며, 이는 계산 효율성에 결정적인 영향을 미친다.</p>
<ul>
<li>전진 모드 (Forward Mode):</li>
</ul>
<p>입력 변수에서 출력 변수 방향으로 미분을 수행한다. 입력 변수 <span class="math math-inline">x</span>에 대한 중간 변수 <span class="math math-inline">v_i</span>의 변화율 <span class="math math-inline">\dot{v}_i = \frac{\partial v_i}{\partial x}</span>를 계산하며 전진한다. 이원수(Dual Number) <span class="math math-inline">v + \dot{v}\epsilon</span> (단, <span class="math math-inline">\epsilon^2 = 0</span>) 대수를 사용하여 구현하기 쉽다. 전진 모드는 한 번의 패스로 하나의 입력에 대한 모든 출력의 미분을 구할 수 있다. 따라서 입력 차원(<span class="math math-inline">N</span>)이 작고 출력 차원(<span class="math math-inline">M</span>)이 큰 함수(<span class="math math-inline">N \ll M</span>)에 유리하다. 그러나 딥러닝과 같이 입력 파라미터가 수백만 개이고 출력(Loss)이 스칼라인 경우에는, 각 파라미터마다 전진 패스를 수행해야 하므로 비효율적이다.</p>
<ul>
<li>후진 모드 (Reverse Mode):</li>
</ul>
<p>프로그램의 출력을 계산하는 전진 패스(Forward Pass)를 먼저 수행하여 중간 값들을 저장한 후, 출력에서 입력 방향으로 거꾸로 미분값(Adjoint)을 전파한다. 중간 변수 <span class="math math-inline">v_i</span>에 대한 출력 <span class="math math-inline">y</span>의 변화율 <span class="math math-inline">\bar{v}_i = \frac{\partial y}{\partial v_i}</span>를 계산한다. 이는 딥러닝의 역전파(Backpropagation) 알고리즘을 일반화한 것으로, 한 번의 전진 패스와 한 번의 후진 패스로 모든 입력 파라미터에 대한 스칼라 출력의 그라디언트를 계산할 수 있다. 따라서 입력 차원이 크고 출력 차원이 작은 경우(<span class="math math-inline">N \gg M</span>)에 압도적으로 효율적이며, 이것이 현대 딥러닝과 미분 가능한 프로그래밍의 근간이 되었다.9</p>
<p><strong>표 2.4.1: 자동 미분 모드 비교</strong></p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>전진 모드 (Forward Mode)</strong></th><th><strong>후진 모드 (Reverse Mode)</strong></th></tr></thead><tbody>
<tr><td><strong>계산 방향</strong></td><td>입력 <span class="math math-inline">\rightarrow</span> 출력</td><td>출력 <span class="math math-inline">\rightarrow</span> 입력</td></tr>
<tr><td><strong>주요 응용</strong></td><td>야코비안-벡터 곱 (JVP), 민감도 분석</td><td>벡터-야코비안 곱 (VJP), 그라디언트 계산</td></tr>
<tr><td><strong>효율성 (입력 <span class="math math-inline">N</span>, 출력 <span class="math math-inline">M</span>)</strong></td><td><span class="math math-inline">N \ll M</span> 일 때 유리</td><td><span class="math math-inline">N \gg M</span> 일 때 유리 (대부분의 ML/최적화)</td></tr>
<tr><td><strong>메모리 사용</strong></td><td>낮음 (중간 값 저장 불필요)</td><td>높음 (전진 패스의 중간 값 저장 필요)</td></tr>
<tr><td><strong>딥러닝 관련성</strong></td><td>제한적 (소규모 네트워크나 특정 미분)</td><td>핵심 (역전파 알고리즘의 기반)</td></tr>
</tbody></table>
<h3>2.3  계산 그래프와 동적성 (Dynamic Computational Graphs)</h3>
<p>미분 가능한 프로그래밍의 구현체들은 계산 그래프(Computational Graph)라는 추상화를 사용한다. 초기 프레임워크인 TensorFlow 1.x나 Theano는 ‘정적 그래프(Static Graph)’ 방식을 채택했다. 이는 그래프를 정의하는 단계와 실행하는 단계가 분리되어 있어, 컴파일러 최적화에는 유리했지만 루프나 재귀와 같은 동적인 제어 흐름을 표현하기 어려웠다.</p>
<p>반면, PyTorch, JAX 등이 채택한 ‘동적 그래프(Dynamic Graph)’ 또는 “Define-by-Run” 방식은 프로그램이 실행되는 시점에 즉석에서 그래프를 생성한다.2 이는 미분 가능한 프로그래밍의 범용성을 획기적으로 확장했다. 예를 들어, 데이터의 값에 따라 반복 횟수가 달라지는 물리 시뮬레이션이나, 트리 구조를 가진 데이터를 처리하는 재귀 신경망(Recursive Neural Networks)을 자연스럽게 코드로 작성하고 미분할 수 있게 되었다. 동적 그래프는 프로그래머가 Python의 기본 제어문(<code>if</code>, <code>while</code>)을 자유롭게 사용하면서도 미분 가능성을 유지할 수 있게 해주어, ’코드로서의 모델(Model as Code)’이라는 소프트웨어 2.0의 비전을 실현하는 데 핵심적인 역할을 한다.</p>
<h2>3.  미분 가능한 물리 시뮬레이션 (Differentiable Physics)</h2>
<p>미분 가능한 프로그래밍이 가장 파괴적인 혁신을 일으키고 있는 도메인은 바로 물리 시뮬레이션이다. 로보틱스나 컴퓨터 그래픽스에서 사용되는 전통적인 물리 엔진(ODE, Bullet, PhysX 등)은 시뮬레이션의 ’결과’를 빠르게 얻는 것에 최적화되어 있었지, 그 과정을 미분하는 것은 고려하지 않았다. 그러나 로봇 제어 정책을 학습하거나 물리적 현상을 역설계(Inverse Design)하기 위해서는 물리 엔진 자체가 미분 가능해야 한다는 요구가 강력하게 대두되었다.</p>
<h3>3.1  접촉 불연속성(Contact Discontinuity)과 그라디언트의 단절</h3>
<p>물리 시뮬레이션을 미분 가능하게 만드는 데 있어 가장 큰 난관은 ’접촉(Contact)’과 ‘충돌(Collision)’ 현상이다. 강체 역학(Rigid Body Dynamics)에서 물체가 바닥에 닿는 순간, 속도는 불연속적으로 변하고 접촉력은 임펄스(Impulse) 형태로 나타난다. 이러한 불연속점에서는 미분값이 정의되지 않거나, 정보가 소실되어 그라디언트가 0이 되는 문제가 발생한다.7 예를 들어, 로봇 팔이 물체를 잡으려다 실패하여 허공을 휘두르는 경우, 전통적인 시뮬레이터에서는 접촉이 발생하지 않았으므로 물체에 전달된 힘이 0이고, 따라서 “어떻게 움직였어야 물체를 잡을 수 있었는지“에 대한 그라디언트 정보도 0이 된다. 이는 최적화 알고리즘이 학습 방향을 찾지 못하게 만든다.</p>
<h3>3.2  미분 가능한 물리 엔진의 기술적 접근</h3>
<p>이 문제를 해결하기 위해 연구자들은 물리를 ‘부드럽게(Softening)’ 만들거나, 정교한 수학적 기법을 도입하여 미분 가능한 물리 엔진을 개발했다.</p>
<ol>
<li>해석적 미분과 LCP (Linear Complementarity Problem):</li>
</ol>
<p>강체 역학의 접촉 문제는 수학적으로 선형 상보성 문제(LCP)로 모델링된다. 최신의 미분 가능한 엔진들은 LCP의 해를 구한 후, 암시적 함수 정리(Implicit Function Theorem)를 적용하여 파라미터에 대한 해의 미분값을 해석적으로 계산한다. 이 방법은 물리 법칙을 엄밀하게 유지하면서도 정확한 그라디언트를 얻을 수 있다는 장점이 있다.7</p>
<ol start="2">
<li>임펄스 기반 방법의 완화 (Relaxation of Impulse-based Methods):</li>
</ol>
<p>Google의 Brax나 MJX(MuJoCo JAX)와 같은 엔진들은 강체 간의 상호작용을 미분 가능한 연산으로 근사한다. 딱딱한 충돌(Hard Contact)을 매우 강한 스프링-댐퍼 시스템(Spring-Damper System)과 같은 연성 접촉(Soft Contact) 모델로 근사하거나, 충돌 해결 과정의 반복 연산(Iterative Solver) 자체를 계산 그래프로 전개(Unroll)하여 미분한다.7 특히 JAX 기반의 엔진들은 GPU/TPU 가속을 통해 수천 개의 시뮬레이션을 병렬로 처리하면서도 미분 가능성을 유지한다.</p>
<ol start="3">
<li>연속 충돌 감지 (Continuous Collision Detection, CCD):</li>
</ol>
<p>이산적인 타임스텝 사이에서 발생하는 충돌 시점을 보간(Interpolation)하여 계산함으로써, 충돌 시점 자체를 미분 가능한 변수로 만든다. 이는 궤적 최적화(Trajectory Optimization)에서 매우 중요한 요소다.</p>
<h3>3.3  Sim-to-Real과 시스템 식별 (System Identification)</h3>
<p>미분 가능한 시뮬레이터의 등장은 ’시뮬레이션 자체를 학습의 일부’로 통합시켰다. 이를 통해 현실 세계의 데이터와 시뮬레이션 결과의 차이(Loss)를 줄이는 방향으로 시뮬레이터의 물리 파라미터(마찰 계수, 질량 중심, 관성 모멘트 등)를 역전파로 업데이트하는 ’시스템 식별(System Identification)’이 가능해졌다. 이렇게 보정된 시뮬레이터는 현실 세계를 매우 정밀하게 모사하게 되며, 여기서 학습된 제어 정책은 현실 로봇에 적용했을 때(Sim-to-Real) 훨씬 높은 성공률을 보인다.4 기존의 강화학습이 시뮬레이터를 수정 불가능한 환경(Environment)으로 취급했다면, 미분 가능한 프로그래밍은 시뮬레이터조차 최적화 가능한 모델의 일부로 간주한다.</p>
<h2>4.  제어 이론의 융합: 미분 가능한 제어 (Differentiable Control)</h2>
<p>미분 가능한 프로그래밍은 전통적인 제어 이론(Control Theory)과 현대적인 딥러닝의 경계를 허물고 있다. 제어 이론은 모델에 기반한 수학적 안정성을 보장하지만 비정형 환경에 취약하고, 딥러닝은 환경 적응력은 뛰어나지만 데이터 효율성이 낮고 해석이 불가능하다. 미분 가능한 제어는 이 두 분야의 장점을 결합하여, 제어 알고리즘 자체를 신경망 안에 미분 가능한 계층(Layer)으로 내장하는 방식을 취한다.</p>
<h3>4.1  미분 가능한 모델 예측 제어 (Differentiable MPC)</h3>
<p>모델 예측 제어(MPC)는 현재 상태에서 미래의 일정 구간(Horizon) 동안 시스템의 동작을 예측하고 최적의 제어 입력을 계산하는 강력한 기법이다. Amos 등의 선구적인 연구 14는 MPC의 최적화 과정(주로 2차 계획법, QP)을 미분 가능하게 만들어 딥러닝 파이프라인에 통합했다.</p>
<p>Differentiable MPC를 구현하는 데에는 두 가지 주요한 기술적 접근이 존재한다:</p>
<ol>
<li>언롤링 (Unrolling):</li>
</ol>
<p>최적화 솔버의 반복 단계(예: 경사 하강법이나 뉴턴 방법의 스텝들)를 계산 그래프상에 모두 기록하고, 이를 통해 역전파를 수행한다. 구현이 직관적이고 모든 종류의 솔버에 적용 가능하지만, 반복 횟수가 많아질수록 계산 그래프가 깊어져 메모리 소모가 크고(“Vanishing Gradient” 문제 발생 가능), 계산 비용이 높다는 단점이 있다.14</p>
<ol start="2">
<li>암시적 미분 (Implicit Differentiation):</li>
</ol>
<p>최적화 문제의 해가 수렴했을 때 만족해야 하는 KKT(Karush-Kuhn-Tucker) 조건을 이용한다. 솔버가 내부적으로 어떤 과정을 거쳤는지는 무시하고, 최종 수렴 지점에서의 KKT 조건식에 암시적 함수 정리를 적용하여 파라미터에 대한 해의 미분값(Jacobian)을 해석적으로 계산한다. 이 방식은 솔버의 내부 스텝을 저장할 필요가 없어 메모리 효율적(<span class="math math-inline">O(1)</span>)이며, 순전파(Forward Pass)에서 구한 행렬 분해 결과를 재사용할 수 있어 역전파 속도가 매우 빠르다. Amos의 OptNet이나 이후의 연구들은 이 방식을 통해 MPC 제어기를 신경망의 마지막 층으로 사용하여 종단간 학습(End-to-End Learning)을 구현했다.19</p>
<p>이러한 기술을 통해, 로봇이 복잡한 환경에서 주행할 때 필요한 ’비용 함수(Cost Function)’나 ’동역학 모델(Dynamics Model)’을 사람이 직접 튜닝하는 대신, 전문가의 시범 데이터(Demonstration)로부터 학습할 수 있게 되었다. 예를 들어, 보행자 사이를 지나가는 로봇의 사회적 비용 함수를 정의하기는 어렵지만, 미분 가능한 MPC를 사용하면 사람의 주행 궤적을 모방하도록 MPC 내부의 가중치 행렬을 역전파로 학습시킬 수 있다.23</p>
<h3>4.2  신경 상미분 방정식 (Neural ODEs)</h3>
<p>Chen 등이 제안한 신경 상미분 방정식(Neural Ordinary Differential Equations, Neural ODEs)은 딥러닝 모델을 이산적인 층의 적층이 아닌, 연속적인 시간 흐름에 따른 미분 방정식 <span class="math math-inline">\frac{dz}{dt} = f(z(t), t, \theta)</span>으로 정의한다.[25, 26, 27] 이는 ResNet과 같은 잔차 연결 신경망의 극한 형태(<span class="math math-inline">\Delta t \to 0</span>)로 해석될 수 있으며, 물리 현상이나 시계열 데이터와 같이 연속적인 동역학을 가진 시스템을 모델링하는 데 이상적이다.</p>
<p>제어 분야에서 Neural ODE는 시스템의 알려지지 않은 동역학 <span class="math math-inline">f</span>를 신경망으로 근사하고, 이를 ODE 솔버를 통해 적분하여 미래 상태를 예측하는 데 사용된다. Neural ODE의 가장 큰 기여는 **수반법(Adjoint Sensitivity Method)**의 도입이다. 일반적인 역전파가 시뮬레이션의 모든 중간 단계를 저장해야 하는 것과 달리, 수반법은 또 다른 ODE(Adjoint ODE)를 정의하여 시간을 거꾸로 흐르게 하면서 그라디언트를 계산한다. 이 방식은 시뮬레이션 시간이나 스텝 수와 무관하게 일정한 메모리(<span class="math math-inline">O(1)</span>)만을 사용하므로, 매우 긴 시간 동안의 제어 시퀀스나 정밀한 물리 시뮬레이션을 학습하는 것을 가능하게 한다.28</p>
<h2>5.  구현 도구와 생태계: JAX의 부상과 가속화</h2>
<p>미분 가능한 프로그래밍의 이론적 발전은 이를 뒷받침하는 강력한 소프트웨어 도구, 특히 Google의 JAX의 등장으로 가속화되었다. JAX는 단순한 딥러닝 라이브러리가 아니라, 수치 연산 및 과학 계산을 위한 차세대 미분 가능한 프로그래밍 프레임워크로 자리 잡았다.7</p>
<h3>5.1  JAX: 구성 가능한 함수 변환 (Composable Function Transformations)</h3>
<p>JAX는 Python과 NumPy의 문법을 그대로 사용하면서도, 코드를 가속기(GPU/TPU)에서 실행 가능한 기계어로 컴파일하고 미분할 수 있는 능력을 부여한다. JAX의 설계 철학은 ’함수형 프로그래밍(Functional Programming)’에 기반하며, 다음과 같은 핵심적인 함수 변환 API를 제공한다:</p>
<ul>
<li><strong><code>grad</code>:</strong> 임의의 순수 Python 함수에 대한 자동 미분을 수행한다. 1계 미분뿐만 아니라 <code>grad(grad(grad(...)))</code>와 같이 고계 미분도 손쉽게 처리할 수 있어, 물리 시뮬레이션이나 메타 러닝(Meta-Learning)에서 요구되는 헤시안(Hessian) 계산에 탁월하다.</li>
<li><strong><code>jit</code> (Just-In-Time Compilation):</strong> XLA(Accelerated Linear Algebra) 컴파일러를 사용하여 Python 함수를 최적화된 커널로 컴파일한다. 이는 루프가 많은 물리 시뮬레이션이나 복잡한 제어 알고리즘의 실행 속도를 수십 배에서 수백 배까지 향상시킨다.32</li>
<li><strong><code>vmap</code> (Vectorizing Map):</strong> 단일 데이터(예: 하나의 로봇)에 대해 작성된 코드를 수정 없이 배치(Batch) 처리가 가능하도록 자동 벡터화한다. 이는 수천 개의 로봇 에이전트를 병렬로 시뮬레이션해야 하는 강화학습이나 진화 알고리즘(Evolutionary Strategies)에서 코드의 복잡성을 획기적으로 낮추고 하드웨어 효율을 극대화한다.31</li>
</ul>
<h3>5.2  Brax와 MJX: 차세대 미분 가능한 물리 엔진</h3>
<p>JAX 생태계 위에서 구축된 Brax와 MJX는 로보틱스 연구의 풍경을 바꾸고 있다.</p>
<ul>
<li><strong>Brax:</strong> 대규모 병렬 강체 시뮬레이션에 특화된 엔진으로, 단일 GPU에서 수만 개의 물리 환경(Environment)을 동시에 시뮬레이션할 수 있다. Brax는 물리 엔진 자체가 JAX로 작성되어 있어 전체 파이프라인이 미분 가능하다. 이를 통해 PPO와 같은 강화학습 알고리즘을 사용할 때, 기존 CPU 기반 시뮬레이터(OpenAI Gym 등) 대비 수천 배 빠른 학습 속도를 보여준다. 예를 들어, 표준적인 개미(Ant) 로봇 보행 학습을 몇 분 안에 완료할 수 있다.16</li>
<li><strong>MJX (MuJoCo XLA):</strong> 로보틱스 분야의 골드 스탠다드인 MuJoCo 물리 엔진을 JAX로 재구현한 것이다. MJX는 MuJoCo의 정밀한 접촉 모델과 동역학을 그대로 유지하면서도, JAX의 미분 가능성과 하드웨어 가속 이점을 결합했다. 이는 기존에 축적된 MuJoCo 기반의 연구 자산을 미분 가능한 프로그래밍의 영역으로 끌어들이는 중요한 다리 역할을 한다.15</li>
</ul>
<p>이러한 도구들은 로봇 제어 정책을 학습할 때, 시뮬레이터를 블랙박스로 두고 시행착오를 겪는 모델 프리(Model-Free) 방식에서 벗어나, 물리 엔진을 통과하는 해석적 그라디언트(Analytic Policy Gradient)를 직접 계산하여 정책을 업데이트하는 효율적인 학습을 가능하게 한다.16</p>
<p><strong>표 2.4.2: 주요 미분 가능한 물리 엔진 및 도구 비교</strong></p>
<table><thead><tr><th><strong>도구</strong></th><th><strong>기반 프레임워크</strong></th><th><strong>특징 및 주요 기술</strong></th><th><strong>장점</strong></th><th><strong>주요 용도</strong></th></tr></thead><tbody>
<tr><td><strong>Brax</strong></td><td>JAX</td><td>Impulse-based, PBD(Position Based Dynamics) 지원</td><td>초고속 병렬 시뮬레이션, 완전 미분 가능</td><td>대규모 강화학습, 진화 전략, 로봇 보행</td></tr>
<tr><td><strong>MJX</strong></td><td>JAX</td><td>MuJoCo의 볼록 최적화 기반 접촉 모델</td><td>높은 물리 정확도, 기존 MuJoCo 모델 호환</td><td>정밀 로봇 제어, Sim-to-Real</td></tr>
<tr><td><strong>DiffTaichi</strong></td><td>Taichi</td><td>자체 컴파일러, 소스 코드 변환 방식</td><td>고성능 유체, 탄성체 시뮬레이션</td><td>컴퓨터 그래픽스, 연체 로봇(Soft Robotics)</td></tr>
<tr><td><strong>Nvidia Warp</strong></td><td>CUDA/Python</td><td>커널 기반 시뮬레이션</td><td>GPU 최적화, 빠른 속도</td><td>그래픽스, 비전, 로보틱스 통합</td></tr>
</tbody></table>
<h2>6.  사례 연구: 미분 가능한 프로그래밍의 실제 적용</h2>
<h3>6.1  Google Performer-MPC: 하이브리드 제어 아키텍처</h3>
<p>Google Research팀이 개발한 Performer-MPC는 미분 가능한 프로그래밍이 실제 복잡한 로봇 문제에 어떻게 적용될 수 있는지를 보여주는 대표적인 사례다. 연구진은 로봇이 복잡한 실내 환경에서 사람을 피해 안전하고 자연스럽게 주행하는 난제를 해결하고자 했다. 이를 위해 시각 정보를 처리하는 트랜스포머(Transformer) 모델과 로봇의 동역학을 고려하는 MPC 제어기를 결합했다.</p>
<p>핵심 아이디어는 트랜스포머가 카메라 이미지와 라이다(LiDAR) 데이터를 입력받아, MPC가 사용할 ’비용 함수(Cost Function)’의 파라미터(가중치)를 실시간으로 생성하도록 만든 것이다. 예를 들어, 로봇 앞에 사람이 나타나면 트랜스포머는 장애물 회피 항의 가중치를 높여 MPC가 안전한 경로를 생성하도록 유도한다. 중요한 점은 <strong>MPC 자체가 미분 가능한 모듈로 구현</strong>되어 있다는 것이다. 따라서 연구진은 사람의 주행 시범 데이터(Expert Demonstration)와 로봇의 실제 주행 경로 간의 차이를 손실 함수로 정의하고, 이 손실을 MPC를 통과하여 역전파함으로써 트랜스포머가 “어떤 상황에서 어떤 비용 함수를 생성해야 하는지“를 종단간(End-to-End)으로 학습시켰다. 그 결과, Performer-MPC는 기존 MPC 대비 40% 이상의 목적지 도달률 향상을 보였으며, 사람이 보기에 훨씬 자연스럽고 사회적으로 적절한 주행 능력을 달성했다.23</p>
<h3>6.2  로봇 설계와 제어의 동시 최적화 (Co-Design)</h3>
<p>MIT의 연구진은 미분 가능한 프로그래밍을 사용하여 로봇의 하드웨어 설계와 제어 알고리즘을 동시에 최적화하는 성과를 거두었다. 전통적으로는 하드웨어 엔지니어가 로봇을 설계하면 제어 엔지니어가 그에 맞는 소프트웨어를 개발하는 순차적인 프로세스였다. 그러나 연구진은 로봇의 센서 배치, 링크 길이, 모터 사양 등 하드웨어 파라미터와 제어 정책의 파라미터를 모두 미분 가능한 변수로 설정하고, 시뮬레이션을 통해 전체 시스템의 성능(예: 탐색 효율성, 에너지 소모)을 최대화하는 방향으로 그라디언트를 계산했다.</p>
<p>이 접근법을 통해 센서의 위치와 제어기를 동시에 최적화한 결과, 초기 설계 대비 탐색 성능을 8.4배 향상시킬 수 있었다.35 또한, 다중 에이전트 협업 작업에서도 454개의 파라미터를 1시간 이내에 최적화하여 44%의 성능 향상을 이루어냈다. 이는 미분 가능한 프로그래밍이 소프트웨어의 영역을 넘어 하드웨어 설계의 영역까지 확장될 수 있음을 시사한다.</p>
<h2>7.  한계와 미래 전망: 혼돈을 넘어</h2>
<p>미분 가능한 프로그래밍이 보여주는 잠재력은 막대하지만, 여전히 해결해야 할 근본적인 난제들이 존재한다.</p>
<ol>
<li>혼돈(Chaos)과 그라디언트 폭발/소실:</li>
</ol>
<p>물리 시스템, 특히 유체 역학이나 충돌이 잦은 다물체 시스템은 초기 조건에 민감한 혼돈 특성을 보인다. 시뮬레이션 시간이 길어질수록(Long Horizon), 아주 미세한 입력의 변화가 출력에 거대한 변화를 일으키거나(그라디언트 폭발), 반대로 영향력이 사라지는(그라디언트 소실) 현상이 발생한다. 이는 ’나비 효과’로 인해 최적화 지형(Loss Landscape)이 극도로 울퉁불퉁해져서 경사 하강법이 수렴하지 못하게 만든다.7 이를 해결하기 위해 그라디언트 클리핑이나, 더 안정적인 손실 함수 설계, 혹은 확률론적 스무딩(Probabilistic Smoothing) 기법들이 연구되고 있다.</p>
<ol start="2">
<li>이산적 논리와의 결합:</li>
</ol>
<p>현실의 소프트웨어는 여전히 미분 불가능한 이산적 논리(데이터베이스 조회, 보안 인증, 엄격한 if-else 분기)를 포함하고 있다. 완전한 소프트웨어 2.0을 위해서는 이러한 이산적 요소들을 어떻게 부드럽게 근사(Relaxation)하거나, REINFORCE와 같은 그라디언트 추정 기법과 결합할지에 대한 연구가 필요하다.1</p>
<ol start="3">
<li>결론: 범용 인공지능을 향한 도구:</li>
</ol>
<p>이러한 한계에도 불구하고, 미분 가능한 프로그래밍은 AI와 전통적 공학을 통합하는 가장 유력한 방법론이다. 이는 기계 학습 모델이 단순히 데이터를 패턴 매칭하는 블랙박스를 넘어, 물리 법칙과 논리적 인과관계를 내재화한 ’이해 가능한 모델’로 진화하는 가교 역할을 한다. 향후 이 기술은 로보틱스를 넘어 신약 개발(분자 시뮬레이션의 미분), 기후 모델링, 금융 공학 등 복잡계 시스템을 다루는 모든 분야에서 인간의 직관을 뛰어넘는 해법을 제시하는 핵심 도구가 될 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Deep learning from a programmer’s perspective (aka Differentiable Programming) - Medium, https://medium.com/data-science/deep-learning-from-a-programmers-perspective-aka-differentiable-programming-ec6e8d1b7c60</li>
<li>Understand Differentiable Programming | Towards Data Science, https://towardsdatascience.com/understand-differentiable-programming-54f11bfb574/</li>
<li>A Beginner’s Guide to Differentiable Programming | Pathmind, https://wiki.pathmind.com/differentiableprogramming</li>
<li>Differentiable Programming: The Future of Machine Learning? | by Amit Yadav | Biased-Algorithms | Medium, https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85</li>
<li>1월 3, 2026에 액세스, [https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85#:<sub>:text=In%20a%20traditional%20setting%2C%20you,and%20the%20control%20model%20together.](https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85#:</sub>:text=In a traditional setting%2C you, <a href="https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85#:~:text=In%20a%20traditional%20setting%2C%20you,and%20the%20control%20model%20together.">https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85#:~:text=In%20a%20traditional%20setting%2C%20you,and%20the%20control%20model%20together.</a></li>
<li>The Elements of Differentiable Programming arXiv:2403.14606v2 [cs.LG] 24 Jul 2024, <a href="https://arxiv.org/pdf/2403.14606">https://arxiv.org/pdf/2403.14606?</a></li>
<li>End-to-End and Highly-Efficient Differentiable Simulation for Robotics - arXiv, https://arxiv.org/html/2409.07107v1</li>
<li>Automatic differentiation - Wikipedia, https://en.wikipedia.org/wiki/Automatic_differentiation</li>
<li>Automatic Differentiation in Machine Learning: a Survey, https://www.jmlr.org/papers/volume18/17-468/17-468.pdf</li>
<li>Optimizing Automatic Differentiation with Deep Reinforcement Learning - arXiv, https://arxiv.org/html/2406.05027v2</li>
<li>Differentiable programming - Wikipedia, https://en.wikipedia.org/wiki/Differentiable_programming</li>
<li>Understanding Automatic Differentiation Through Computational Graphs | by Roy Wong, https://medium.com/@Roy.Wong/understanding-automatic-differentiation-through-computational-graphs-82eae9c7ab4f</li>
<li>A Chain Rule-Based Generalized Framework for Efficient Dynamic Analysis of Complex Robotic Systems - MDPI, https://www.mdpi.com/2218-6581/14/9/115</li>
<li>DiffOP: Reinforcement Learning of Optimization-Based Control Policies via Implicit Policy Gradients - arXiv, https://arxiv.org/html/2411.07484v4</li>
<li>MuJoCo XLA (MJX), https://mujoco.readthedocs.io/en/stable/mjx.html</li>
<li>google/brax: Massively parallel rigidbody physics simulation on accelerator hardware. - GitHub, https://github.com/google/brax</li>
<li>Why are model-based methods more sample efficient than model-free methods? - AI Stack Exchange, https://ai.stackexchange.com/questions/14175/why-are-model-based-methods-more-sample-efficient-than-model-free-methods</li>
<li>Differentiable MPC for End-to-end Planning and Control, https://homes.cs.washington.edu/~bboots/files/DMPC.pdf</li>
<li>Differentiable Optimization-Based Modeling for Machine Learning - SCS TECHNICAL REPORT COLLECTION, http://reports-archive.adm.cs.cmu.edu/anon/2019/CMU-CS-19-109.pdf</li>
<li>[1810.13400] Differentiable MPC for End-to-end Planning and Control - arXiv, https://arxiv.org/abs/1810.13400</li>
<li>[Quick Review] Differentiable MPC for End-to-end Planning and Control - Liner, https://liner.com/review/differentiable-mpc-for-endtoend-planning-and-control</li>
<li>Differentiable Robust Model Predictive Control - Robotics, https://roboticsproceedings.org/rss20/p003.pdf</li>
<li>Performer-MPC: Navigation via real-time, on-robot transformers - Google Research, https://research.google/blog/performer-mpc-navigation-via-real-time-on-robot-transformers/</li>
<li>Learning Model Predictive Controllers with Real-Time Attention for Real-World Navigation, https://research.google/pubs/learning-model-predictive-controllers-with-real-time-attention-for-real-world-navigation/</li>
<li>``Hey, that’s not an ODE’’: Faster ODE Adjoints via Seminorms - University of Oxford, <a href="https://www.maths.ox.ac.uk/system/files/attachments/2021-06%20%E2%80%9CHey%2C%20that%E2%80%99s%20not%20an%20ODE%E2%80%9D%20Faster%20ODE%20Adjoints%20via%20Seminorms%20by%20Patrick%20Kidger%2C%20Ricky%20T.%20Q.%20Chen%20%26%20Terry%20Lyons.pdf">https://www.maths.ox.ac.uk/system/files/attachments/2021-06%20%E2%80%9CHey%2C%20that%E2%80%99s%20not%20an%20ODE%E2%80%9D%20Faster%20ODE%20Adjoints%20via%20Seminorms%20by%20Patrick%20Kidger%2C%20Ricky%20T.%20Q.%20Chen%20%26%20Terry%20Lyons.pdf</a></li>
<li>Adjoint State Method, Backpropagation and Neural ODEs | Ilya Schurov, https://ilya.schurov.com/post/adjoint-method/</li>
<li>Deriving the Adjoint Equation for Neural ODEs using Lagrange Multipliers | Vaibhav Patel, https://vaipatel.com/posts/deriving-the-adjoint-equation-for-neural-odes-using-lagrange-multipliers/</li>
<li>A roboticist’s journey with JAX: Finding efficiency in optimal control and simulation, https://developers.googleblog.com/en/a-roboticists-journey-with-jax/</li>
<li>Speeding up simulations - Jaxley! - Read the Docs, https://jaxley.readthedocs.io/en/latest/tutorials/04_jit_and_vmap.html</li>
<li>Brax - A Differentiable Physics Engine for Large Scale Rigid Body Simulation - arXiv, https://arxiv.org/pdf/2106.13281</li>
<li>gbionics/jaxsim: A differentiable physics engine and multibody dynamics library for control and robot learning. - GitHub, https://github.com/gbionics/jaxsim</li>
<li>Certifiable Robot Design Optimization using Differentiable Programming, https://www.roboticsproceedings.org/rss18/p037.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>