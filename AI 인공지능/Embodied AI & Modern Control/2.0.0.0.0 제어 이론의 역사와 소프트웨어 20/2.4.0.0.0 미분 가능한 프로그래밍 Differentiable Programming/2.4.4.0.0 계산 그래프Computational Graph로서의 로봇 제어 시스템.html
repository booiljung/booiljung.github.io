<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.4.4 계산 그래프(Computational Graph)로서의 로봇 제어 시스템</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.4.4 계산 그래프(Computational Graph)로서의 로봇 제어 시스템</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.4 미분 가능한 프로그래밍 (Differentiable Programming)</a> / <span>2.4.4 계산 그래프(Computational Graph)로서의 로봇 제어 시스템</span></nav>
                </div>
            </header>
            <article>
                <h1>2.4.4 계산 그래프(Computational Graph)로서의 로봇 제어 시스템</h1>
<h2>1.  서론: 제어 시스템의 그래프적 재해석</h2>
<p>현대 로봇 공학은 전통적인 제어 이론의 정밀함과 딥러닝(Deep Learning)의 유연함이 충돌하고 융합하는 거대한 기술적 변곡점에 서 있다. 과거 반세기 동안 로봇 제어 시스템을 지배해 온 패러다임은 전달 함수(Transfer Function)와 상태 공간 방정식(State-Space Equation)으로 대변되는 ’블록 다이어그램(Block Diagram)’이었다. 엔지니어들은 MATLAB/Simulink와 같은 도구를 사용하여 센서 처리, 상태 추정, 경로 계획, 제어기라는 명확히 구분된 모듈을 설계하고, 각 블록 간의 신호 흐름을 수학적으로 정의했다.1 이러한 접근 방식은 시스템의 안정성(Stability)을 증명하고 동작을 예측하는 데 탁월했으나, 로봇이 마주하는 환경이 실험실을 벗어나 비정형화된 현실 세계로 확장됨에 따라 그 한계를 드러내기 시작했다. 복잡한 물리적 상호작용, 불확실한 센서 데이터, 그리고 고차원의 상태 공간을 모두 수동으로 모델링하고 튜닝하는 것은 인간 엔지니어의 인지적 한계를 넘어선 작업이 되었다.5</p>
<p>이러한 배경에서 부상한 것이 바로 ‘계산 그래프(Computational Graph)’ 기반의 제어 시스템 설계, 즉 <strong>미분 가능한 프로그래밍(Differentiable Programming)</strong> 패러다임이다.5 이 새로운 관점에서 로봇 제어 시스템은 더 이상 독립된 블랙박스 모듈의 집합이 아니다. 대신, 시스템 전체—인지(Perception), 상태 추정(State Estimation), 계획(Planning), 제어(Control), 그리고 심지어 로봇이 상호작용하는 물리적 환경(Physics/Plant)까지—가 하나의 거대한 수학적 그래프로 재정의된다. 이 그래프의 노드(Node)는 다차원 배열인 텐서(Tensor) 형태의 데이터를 담고 있으며, 엣지(Edge)는 입력과 출력 간의 미분 가능한 연산(Operation)을 나타낸다.9</p>
<p>이러한 재해석이 갖는 가장 강력한 함의는 ’최적화(Optimization)’의 범위 확장에 있다. 기존에는 각 모듈을 개별적으로 튜닝하거나 제한적인 범위 내에서만 최적화를 수행했다면, 계산 그래프 기반 시스템에서는 최종 작업의 성과(Objective/Loss)에 대한 미분값(Gradient)을 계산하여, 제어 명령부터 인지 파라미터까지 시스템의 모든 요소를 종단간(End-to-End)으로 학습하고 최적화할 수 있다.11 본 장에서는 로봇 제어 시스템을 계산 그래프로 전환하는 것이 왜 로봇 소프트웨어 2.0 시대를 여는 핵심인지, 그리고 이를 구현하기 위한 미분 가능한 물리 엔진, 암시적 미분(Implicit Differentiation), 최적화 계층(Optimization Layers) 등의 기술적 요소들이 어떻게 유기적으로 결합되는지 심층적으로 분석한다.</p>
<hr />
<h2>2.  전통적 블록 다이어그램과 계산 그래프의 구조적 대조</h2>
<p>로봇 제어 시스템을 계산 그래프로 이해하기 위해서는 먼저 기존의 블록 다이어그램 방식과의 근본적인 차이를 이해해야 한다. 두 접근 방식 모두 시스템을 하위 구성 요소의 연결로 표현한다는 점에서는 유사해 보이지만, 데이터의 흐름과 파라미터 갱신 메커니즘, 그리고 시스템을 바라보는 철학에서 결정적인 차이를 보인다.</p>
<h3>2.1 ) 신호(Signal) 처리에서 텐서(Tensor) 연산으로</h3>
<p>전통적인 제어 공학에서 블록 다이어그램은 주로 시간에 따른 스칼라 또는 벡터 신호의 흐름을 나타낸다. 예를 들어, PID 제어기의 블록 다이어그램은 오차 신호 <span class="math math-inline">e(t)</span>를 입력받아 비례, 적분, 미분 연산을 거쳐 제어 입력 <span class="math math-inline">u(t)</span>를 출력하는 구조를 가진다.3 이때 각 블록은 명시적인 수식(예: 라플라스 변환, 차분 방정식)으로 정의되며, 엔지니어는 시스템의 물리적 의미를 직관적으로 파악할 수 있다.1 Simulink와 같은 도구는 이러한 블록들의 실행 순서와 데이터 타입을 엄격하게 관리하며, 주로 실시간성(Real-time)과 코드 생성(Code Generation)에 최적화되어 있다.14</p>
<p>반면, 계산 그래프 아키텍처(예: PyTorch, JAX, TensorFlow)에서 데이터의 기본 단위는 고차원 텐서이다.10 로봇의 상태는 단순한 위치/속도 벡터뿐만 아니라, 카메라 이미지, 라이다 포인트 클라우드, 혹은 신경망이 추출한 잠재 벡터(Latent Vector)까지 포괄한다. 계산 그래프의 각 노드는 이러한 텐서를 입력받아 행렬 곱, 합성곱(Convolution), 비선형 활성화 함수 등의 연산을 수행한다. 이는 로봇 제어 시스템이 단순한 수치 연산을 넘어, 고차원의 인지 정보와 저차원의 제어 신호를 유기적으로 결합할 수 있는 토대를 제공한다. 예를 들어, 시각 기반 자율 주행 시스템에서 입력 이미지는 수백만 개의 픽셀 값을 가진 텐서이며, 이는 합성곱 신경망(CNN) 레이어를 거쳐 특징 맵으로 변환되고, 최종적으로 조향각이라는 제어 텐서로 압축된다.7</p>
<h3>2.2 ) 전방 패스(Forward Pass)와 후방 패스(Backward Pass)의 이중 구조</h3>
<p>계산 그래프가 블록 다이어그램과 가장 차별화되는 지점은 **자동 미분(Automatic Differentiation, AD)**을 통한 양방향 정보 흐름에 있다.8</p>
<ul>
<li><strong>전방 패스(Forward Pass):</strong> 이는 전통적인 제어 루프의 실행과 유사하다. 센서 데이터가 입력되고, 상태 추정기를 거쳐 현재 상태가 파악되며, 계획 알고리즘이 목표 궤적을 생성하고, 제어기가 액추에이터 명령을 내린다. 최종적으로 로봇이 환경과 상호작용하여 결과가 산출된다. 블록 다이어그램은 오직 이 전방 패스의 실행과 검증에 초점을 맞춘다.</li>
<li><strong>후방 패스(Backward Pass):</strong> 계산 그래프의 진정한 가치는 여기에 있다. 최종 단계에서 발생한 작업 오차(Loss)—예를 들어, 목표 위치와의 거리나 에너지 소모량—에 대한 그라디언트가 그래프를 거슬러 올라가며 전파된다. 이 그라디언트 정보(<span class="math math-inline">\nabla_\theta \mathcal{L}</span>)는 제어기의 게인, 경로 계획기의 비용 함수 가중치, 상태 추정기의 노이즈 공분산 행렬, 심지어는 인지 모델의 신경망 가중치까지 시스템의 모든 학습 가능한 파라미터를 수학적으로 최적화하는 데 사용된다.5</li>
</ul>
<p>이러한 이중 구조는 ’설계(Design)’와 ’실행(Runtime)’의 경계를 허문다. 전통적 방식에서는 엔지니어가 시스템을 설계하고 파라미터를 튜닝한 후 실행했다면, 계산 그래프 기반 시스템에서는 실행 결과가 다시 설계 파라미터를 수정하는 폐루프(Closed-loop) 최적화 과정이 시스템 내재적으로, 혹은 학습 단계에서 자동적으로 수행된다.6</p>
<h3>2.3 ) 정적 그래프(Static Graph)와 동적 그래프(Dynamic Graph)의 딜레마</h3>
<p>로봇 제어 시스템을 계산 그래프로 구현할 때, 엔지니어는 그래프의 구성 방식에 대해 중요한 선택을 해야 한다. 이는 프레임워크의 특성과도 직결된다.8</p>
<ul>
<li><strong>정적 그래프 (Static Computational Graph):</strong> TensorFlow v1이나 일부 컴파일러 기반 접근법에서 사용된다. 그래프의 구조(노드의 연결성)를 컴파일 타임에 미리 정의하고 고정한다. 이 방식은 그래프 전체 구조를 미리 알 수 있으므로 메모리 최적화와 연산 병렬화에 매우 유리하며, 대규모 시스템 배포 시 높은 성능을 보장한다. 그러나 로봇과 같이 상황에 따라 제어 로직이 바뀌거나(예: 장애물 발견 시 회피 모드로 분기), 가변 길이의 센서 데이터를 처리해야 하는 경우 유연성이 떨어진다는 단점이 있다.</li>
<li><strong>동적 그래프 (Dynamic Computational Graph):</strong> PyTorch나 Python의 기본 제어 흐름을 활용하는 방식(Define-by-Run)이다. 프로그램이 실행되는 시점에 그래프가 즉석에서 생성된다. 이는 <code>if-else</code> 분기문이나 <code>while</code> 루프와 같은 로봇의 복잡한 의사결정 로직을 매우 직관적으로 구현할 수 있게 해준다. 디버깅이 용이하고 유연성이 뛰어나 연구 및 프로토타이핑 단계에서 선호된다. 최근에는 <strong>JAX</strong>와 같이 동적 프로그래밍의 유연성을 유지하면서도, JIT(Just-In-Time) 컴파일을 통해 정적 그래프 수준의 최적화 성능을 제공하는 하이브리드 접근법이 로봇 제어 분야의 새로운 표준으로 부상하고 있다.18</li>
</ul>
<p>이러한 구조적 변화는 단순히 도구의 변화를 넘어, 로봇 시스템을 ’설계하는 대상’에서 ’학습하고 진화하는 대상’으로 바라보게 하는 인식의 전환을 의미한다.</p>
<h2>3.  미분 가능한 물리 엔진 (Differentiable Physics Engine)</h2>
<p>로봇 제어 시스템을 온전한 계산 그래프로 구성하기 위한 가장 큰 걸림돌은 역설적이게도 ‘물리적 세계’ 그 자체였다. 로봇은 가상의 데이터 공간이 아닌 물리 법칙이 지배하는 현실 세계에서 작동한다. 전통적인 물리 엔진(ODE, Bullet, PhysX, Dart 등)은 시뮬레이션의 시각적 그럴싸함이나 실시간 실행 속도에 초점을 맞추었지, 시뮬레이션 과정 자체를 미분 가능하게 만드는 것은 고려하지 않았다. 계산 그래프로서의 제어 시스템이 완성되려면, 로봇이 상호작용하는 물리 환경(Plant) 또한 미분 가능한 연산 노드로 그래프에 포함되어야 한다.21</p>
<h3>3.1 ) 물리 시뮬레이션의 그래프화와 그래디언트의 흐름</h3>
<p>미분 가능한 물리 엔진(Differentiable Physics Engine)은 뉴턴-오일러 방정식(Newton-Euler Equations)이나 라그랑주 역학(Lagrangian Dynamics)과 같은 물리 법칙을 계산 그래프의 연산 노드로 구현한다. 즉, 시뮬레이터가 블랙박스가 아니라, 입력 상태 <span class="math math-inline">s_t</span>와 제어 입력 <span class="math math-inline">u_t</span>를 받아 다음 상태 <span class="math math-inline">s_{t+1}</span>를 출력하는 미분 가능한 함수 <span class="math math-inline">f(s_t, u_t; \theta)</span>로 정의된다.23</p>
<p>여기서 핵심은 시뮬레이션 결과인 다음 상태 <span class="math math-inline">s_{t+1}</span>를 입력 변수들에 대해 미분할 수 있다는 점이다. 구체적으로는 다음과 같은 야코비안(Jacobian) 행렬을 계산할 수 있다:</p>
<ul>
<li><span class="math math-inline">\frac{\partial s_{t+1}}{\partial u_t}</span>: 제어 입력의 변화가 다음 상태에 미치는 영향. 이는 모델 예측 제어(MPC)나 궤적 최적화에서 제어 입력을 갱신하는 방향을 제시한다.</li>
<li><span class="math math-inline">\frac{\partial s_{t+1}}{\partial s_t}</span>: 현재 상태의 변화가 미래 상태에 미치는 영향. 시스템의 안정성 분석이나 민감도 분석에 활용된다.</li>
<li><span class="math math-inline">\frac{\partial s_{t+1}}{\partial \theta}</span>: 물리 파라미터(질량, 마찰 계수, 링크 길이 등)의 변화가 상태에 미치는 영향. 이는 시스템 식별(System Identification)이나 로봇 설계 최적화(Co-design)에 필수적이다.6</li>
</ul>
<p>이러한 미분 정보는 수치적 미분(Finite Difference) 방식보다 훨씬 정확하고 계산 효율적이다. 수치적 미분은 파라미터 개수만큼 시뮬레이션을 반복 실행해야 하지만, 미분 가능한 엔진은 한 번의 후방 패스(Backward Pass)만으로 모든 파라미터에 대한 그라디언트를 얻을 수 있기 때문이다.23</p>
<h3>3.2 ) 접촉(Contact)과 불연속성의 난제</h3>
<p>물리 엔진을 미분 가능하게 만드는 데 있어 가장 큰 기술적 장벽은 **접촉(Contact)**과 **충돌(Collision)**이다. 물리적으로 접촉은 매우 짧은 순간에 발생하는 충격(Impulse)과 속도의 급격한 변화를 수반하는 불연속적인 현상이다. 수학적으로 불연속점에서는 미분이 정의되지 않거나, 그라디언트가 0 또는 무한대가 되는 문제가 발생한다. 이는 경사 하강법 기반의 최적화 알고리즘이 접촉이 발생하는 상황을 학습하지 못하게 만드는 원인이 된다.22</p>
<p>이를 해결하기 위해 연구자들은 계산 그래프 내에서 접촉을 처리하는 다양한 기법을 고안해냈다:</p>
<ul>
<li><strong>Soft Contact (Penalty Method):</strong> 접촉을 딱딱한 제약 조건(Hard Constraint)이 아닌, 강성이 매우 높은 스프링-댐퍼 시스템으로 모델링한다. 물체가 서로 뚫고 들어가는 것을 허용하되, 침투 깊이에 비례하는 반발력을 발생시키는 방식이다. 이 방식은 불연속적인 충돌을 연속적인 힘의 변화로 근사하므로, 미분 가능성을 확보하기 용이하다. <strong>MuJoCo</strong>와 <strong>Brax</strong>가 이 방식을 차용하거나 지원하며, 이는 그라디언트가 끊기지 않고 부드럽게 흐르도록 돕는다. 그러나 강성(Stiffness) 계수를 너무 높이면 미분 방정식이 ’Stiff’해져서 수치적 불안정성을 야기할 수 있고, 너무 낮으면 물리적 현실성(Sim-to-Real Gap)이 떨어지는 트레이드오프가 존재한다.25</li>
<li><strong>LCP의 미분 (Differentiating through LCP):</strong> 강체 동역학에서 접촉 문제는 종종 선형 상보성 문제(LCP, Linear Complementarity Problem)로 정식화된다(예: 접촉력 <span class="math math-inline">\ge 0</span>, 상대 속도 <span class="math math-inline">\ge 0</span>, 둘 중 하나는 0). <strong>Nimble</strong>과 같은 엔진은 LCP를 푸는 과정 자체를 미분하거나, LCP의 해(Solution)에 대해 **암시적 함수 정리(Implicit Function Theorem)**를 적용하여 접촉력의 그라디언트를 해석적으로 계산한다. 이 방식은 물리적 정확도(Hard Contact)를 유지하면서도 미분 가능성을 확보할 수 있어, 정밀한 조작 작업 시뮬레이션에 유리하다.21</li>
<li><strong>시간 적분기(Integrator)의 미분:</strong> 물리 엔진은 미분 방정식을 시간 순으로 적분하는 수치 해석기(Integrator)를 포함한다. 오일러(Euler) 방법이나 룬게-쿠타(Runge-Kutta) 방법과 같은 적분 과정 자체를 계산 그래프 상의 연산 노드로 펼쳐(Unrolling) 역전파를 수행한다. 이 경우 시간 스텝(<span class="math math-inline">\Delta t</span>)이 하이퍼파라미터가 되며, 적분 과정에서의 오차 또한 학습의 대상이 될 수 있다.21</li>
</ul>
<h3>3.3 ) 주요 라이브러리 및 도구의 생태계</h3>
<p>미분 가능한 물리 엔진은 최근 딥러닝 프레임워크와의 결합을 통해 폭발적으로 성장하고 있다.</p>
<table><thead><tr><th><strong>엔진 명</strong></th><th><strong>기반 프레임워크</strong></th><th><strong>접촉 처리 방식</strong></th><th><strong>주요 특징 및 활용 분야</strong></th></tr></thead><tbody>
<tr><td><strong>MuJoCo XLA (MJX)</strong></td><td>JAX</td><td>Soft/Convex</td><td>구글 딥마인드 개발. 기존 MuJoCo의 정밀함을 유지하며 JAX를 통해 GPU/TPU 가속 지원. 수천 개의 병렬 시뮬레이션을 통한 강화학습(RL)에 최적화됨.24</td></tr>
<tr><td><strong>Brax</strong></td><td>JAX</td><td>Impulse/Spring</td><td>구글 개발. 물리 엔진 전체가 JAX로 작성되어 완전한 미분 가능성 및 벡터화(Vectorization) 지원. 수백만 프레임/초의 속도로 진화 연산 및 RL 수행 가능.23</td></tr>
<tr><td><strong>Nimble</strong></td><td>C++/PyTorch</td><td>LCP Analytic</td><td>DART 엔진 기반. 관절형 로봇(Articulated Robot)의 동역학에 강점. LCP 해에 대한 분석적 그라디언트를 제공하여 접촉이 많은 조작 작업 제어에 적합.21</td></tr>
<tr><td><strong>DiffTaichi</strong></td><td>Taichi</td><td>Hybrid</td><td>Taichi 언어의 소스 코드 변환(Source Transformation) 기능을 이용해 물리 코드 자체를 미분 가능하게 컴파일. 유체, 연성 물체(Soft Body) 시뮬레이션에 강점.24</td></tr>
<tr><td><strong>DiffMJX</strong></td><td>JAX</td><td>Adaptive</td><td>MuJoCo 기반의 미분 가능 시뮬레이터로, 적응형 시간 적분(Adaptive Integration)과 결합하여 Hard Contact 상황에서도 정확한 그라디언트를 계산하도록 개선됨.25</td></tr>
</tbody></table>
<p>이러한 도구들은 로봇 제어 시스템 설계자가 물리 환경을 ’주어진 조건’이 아닌 ‘최적화 가능한 변수’ 혹은 ’학습을 가이드하는 미분 가능한 감독자’로 활용할 수 있게 해준다. 예를 들어, 로봇의 링크 길이나 센서 위치를 파라미터화하여, 시뮬레이션 내에서 수행 능력(Performance)을 최대화하는 하드웨어 설계를 자동으로 찾아내는 <strong>Co-design</strong>이 가능해진다.6</p>
<hr />
<h2>4.  상태 추정의 그래프화: 필터에서 신경망까지 (Differentiable State Estimation)</h2>
<p>로봇이 센서 데이터로부터 자신의 상태(위치, 속도, 자세 등)를 파악하는 상태 추정(State Estimation) 과정 또한 계산 그래프의 일부로 편입되고 있다. 전통적인 칼만 필터(Kalman Filter)나 입자 필터(Particle Filter)가 수작업으로 설계된 알고리즘이었다면, 미분 가능한 상태 추정기는 데이터로부터 파라미터를 학습하거나, 필터의 구조적 이점과 신경망의 표현력을 결합하는 방향으로 진화하고 있다.31</p>
<h3>4.1 ) 미분 가능한 칼만 필터 (Differentiable Kalman Filters)</h3>
<p>칼만 필터는 예측(Predict)과 업데이트(Update)라는 두 단계의 선형 대수 연산으로 구성된다. 이는 계산 그래프 관점에서 보면 행렬 곱셈과 역행렬 연산의 연속일 뿐이므로, 그 자체로 완벽하게 미분 가능한 노드가 될 수 있다.</p>
<ul>
<li><strong>파라미터 학습:</strong> 전통적 칼만 필터에서는 프로세스 노이즈 공분산 행렬(<span class="math math-inline">Q</span>)과 측정 노이즈 공분산 행렬(<span class="math math-inline">R</span>)을 엔지니어가 튜닝해야 했다. 하지만 미분 가능한 칼만 필터에서는 실제 궤적 데이터(Ground Truth)와의 오차를 역전파하여, 이 공분산 행렬들을 데이터에 최적화된 값으로 자동 학습시킨다. 이는 센서의 특성이 변하거나 동역학 모델이 부정확한 상황에서도 필터의 성능을 유지하게 해준다.32</li>
<li><strong>비선형 모델의 신경망 대체:</strong> 확장 칼만 필터(EKF)에서 사용되는 비선형 상태 전이 함수(Transition Function)나 관측 함수(Observation Function)를 테일러 급수로 근사하는 대신, 신경망(Neural Network)으로 대체한다. 이렇게 구성된 필터는 ’순환 신경망(RNN)’과 유사한 구조를 가지지만, 칼만 필터의 베이지안 업데이트 구조(Bayesian Update Structure)를 유지하므로 순수 LSTM보다 훨씬 적은 데이터로도 강인한 추정 성능을 보여준다.34</li>
</ul>
<h3>4.2 ) 미분 가능한 입자 필터 (Differentiable Particle Filters, DPF)</h3>
<p>입자 필터(Particle Filter)는 비선형, 비가우시안 분포를 다룰 수 있어 로봇 위치 추정(Localization)에 널리 쓰이지만, ‘리샘플링(Resampling)’ 단계가 미분 불가능하다는 치명적인 단점이 있었다. 리샘플링은 가중치가 낮은 입자를 버리고 높은 입자를 복제하는 이산적(Discrete) 선택 과정이기 때문이다.</p>
<ul>
<li><strong>소프트 리샘플링(Soft Resampling):</strong> DPF 연구들은 리샘플링 과정을 미분 가능한 연산으로 근사화한다. 예를 들어, 입자들을 이산적으로 복제하는 대신 가중치를 부드럽게 재분배하거나, 트랜스포머(Transformer)의 어텐션(Attention) 메커니즘을 사용하여 입자 간의 정보를 교환하는 방식으로 대체한다. 이를 통해 입자 필터 전체를 종단간(End-to-End) 학습할 수 있게 되며, 시각 정보와 지도 정보를 결합하는 복잡한 위치 추정 문제를 딥러닝 파이프라인 내에서 해결할 수 있다.36</li>
<li><strong>알고리즘적 사전 지식(Algorithmic Prior):</strong> DPF는 일반적인 RNN이나 LSTM보다 높은 데이터 효율성과 일반화 성능을 보인다. 이는 입자 필터라는 알고리즘 구조 자체가 상태 추정 문제에 적합한 ’귀납적 편향(Inductive Bias)’을 제공하기 때문이다. 즉, 계산 그래프를 무작위로 연결하는 것이 아니라, 검증된 확률적 추론 알고리즘의 구조를 뼈대로 삼고 그 내부의 함수들만 신경망으로 학습시키는 접근법이다.37</li>
</ul>
<h3>4.3 ) 그래프 신경망(GNN) 기반 상태 추정</h3>
<p>최근에는 전력망이나 다중 로봇 시스템과 같이 상호 연결된 시스템의 상태를 추정하기 위해 그래프 신경망(GNN)이 활용되고 있다. 각 로봇이나 센서를 그래프의 노드로, 그들 간의 상호작용이나 통신을 엣지로 모델링한다. GNN은 이 그래프 구조 위에서 메시지 패싱(Message Passing)을 수행하여, 국소적인 정보만으로도 시스템 전체의 상태를 효율적으로 추정해낸다. 이 또한 미분 가능한 구조이므로, 센서 배치 최적화나 통신 토폴로지 학습과 결합될 수 있다.9</p>
<h2>5.  최적화 계층과 암시적 미분 (Planning and Control as Layers)</h2>
<p>로봇 제어 시스템을 계산 그래프로 재해석하는 과정에서 가장 혁신적인 개념 중 하나는 **‘최적화 문제 그 자체를 하나의 신경망 계층(Layer)으로 간주한다’**는 것이다. 전통적으로 모델 예측 제어(MPC), 2차 계획법(QP), LQR과 같은 최적 제어 알고리즘은 제어 루프 내에서 매 시간 스텝마다 실행되어 최적의 제어 입력을 산출하는 독립적인 솔버(Solver)였다. 하지만 최신 연구들은 이 솔버의 입출력 관계를 미분 가능한 함수로 정의함으로써, 최적화 과정을 딥러닝 네트워크의 일부로 통합하고 있다.41</p>
<h3>5.1 ) 최적화 계층 (Optimization Layers)의 개념</h3>
<p>최적화 계층은 다음과 같은 형태의 최적화 문제를 푼다:</p>
<p><span class="math math-display">z^* = \text{argmin}_z f(z, x; \theta) \quad \text{subject to} \quad z \in \mathcal{C}(x)</span></p>
<p>여기서 <span class="math math-inline">x</span>는 입력(예: 로봇의 현재 상태, 센서 데이터), <span class="math math-inline">z</span>는 최적화 변수(예: 제어 입력, 계획된 경로), <span class="math math-inline">\theta</span>는 파라미터(예: 비용 함수의 가중치, 모델 파라미터), 그리고 <span class="math math-inline">\mathcal{C}</span>는 제약 조건이다.</p>
<p>이 계층의 출력은 최적해 <span class="math math-inline">z^*</span>이다. 중요한 것은 이 출력 <span class="math math-inline">z^*</span>가 입력 <span class="math math-inline">x</span>나 파라미터 <span class="math math-inline">\theta</span>에 대해 어떻게 변화하는지, 즉 야코비안 <span class="math math-inline">\frac{\partial z^*}{\partial x}, \frac{\partial z^*}{\partial \theta}</span>를 계산할 수 있다는 점이다. 이를 통해 우리는 “어떤 비용 함수(Cost Function)를 최소화해야 로봇이 우리가 원하는 대로(예: 사람처럼 자연스럽게, 혹은 에너지를 적게 쓰며) 움직이는가?“라는 역 최적 제어(Inverse Optimal Control) 문제를 경사 하강법으로 풀 수 있게 된다.42</p>
<h3>2) 암시적 미분 (Implicit Differentiation) vs 언롤링 (Unrolling)</h3>
<p>최적화 계층에서 미분값을 계산하는 데에는 크게 두 가지 기술적 접근이 존재하며, 이는 시스템의 효율성과 정확도를 결정하는 중요한 요소이다.</p>
<ul>
<li>
<p><strong>언롤링 (Unrolling):</strong> 경사 하강법이나 뉴턴 방법과 같은 최적화 알고리즘의 반복 단계(Iteration)를 계산 그래프 상에 모두 펼쳐놓는 방식이다. 마치 순환 신경망(RNN)을 시간 축으로 펼치듯이, <span class="math math-inline">k</span>번의 반복을 거쳐 해를 구했다면 그 <span class="math math-inline">k</span> 단계 전체를 역전파한다. 구현이 직관적이고 PyTorch와 같은 프레임워크에서 쉽게 적용할 수 있다. 하지만 반복 횟수가 많아질수록 계산 그래프가 깊어져 메모리 사용량이 선형적으로 증가하고, 그라디언트 소실(Vanishing Gradient)이나 폭주 문제가 발생할 수 있다.42</p>
</li>
<li>
<p>암시적 미분 (Implicit Differentiation): 이 방식은 최적화 알고리즘이 내부적으로 몇 번 반복했는지와 무관하게, 최종적으로 얻어진 최적해(Optimal Solution)의 조건(예: KKT 조건, <span class="math math-inline">g(z^*, \theta) = 0</span>)만을 이용한다. **암시적 함수 정리(Implicit Function Theorem)**에 따르면, 평형점에서의 그라디언트는 최적성 조건의 편미분 만으로 계산할 수 있다.<br />
<span class="math math-display">
\frac{\partial z^*}{\partial \theta} = - \left( \frac{\partial g}{\partial z^*} \right)^{-1} \frac{\partial g}{\partial \theta}
</span><br />
이 방식은 역전파 시 메모리 사용량이 반복 횟수와 무관하게 일정(Constant)하며, 언롤링 방식보다 더 정확한 그라디언트를 제공한다. 최근 공개된 Meta Theseus나 JAXOpt 같은 라이브러리들은 이 암시적 미분 기능을 탑재하여, 수천 변수를 가진 MPC 문제나 SLAM 문제를 신경망 학습 루프 안에 효율적으로 통합할 수 있게 해준다.18</p>
</li>
</ul>
<h3>3) 미분 가능한 MPC와 LQR (DiffMPC, Differentiable LQR)</h3>
<p>이러한 기술을 바탕으로 MPC와 LQR 제어기가 미분 가능한 모듈로 재탄생하고 있다.</p>
<ul>
<li><strong>DiffMPC:</strong> JAX 기반의 <strong>DiffMPC</strong>는 GPU 가속을 활용하여 수 밀리초(ms) 안에 비선형 MPC 문제를 해결하고 미분할 수 있다. 이는 자율주행 차량이 물웅덩이와 같은 미끄러운 노면에서 드리프트(Drift) 주행을 할 때, 차량의 동역학 모델과 타이어 마찰 모델의 오차를 실시간 데이터로부터 역전파하여 보정하는 데 성공적으로 적용되었다.12</li>
<li><strong>Differentiable LQR:</strong> LQR 문제의 해인 리카티 방정식(Riccati Equation)의 해를 미분 가능하게 만듦으로써, 로봇의 제어 이득(Gain)을 사람이 튜닝하는 것이 아니라, 시뮬레이션이나 실제 주행 데이터를 통해 최적의 퍼포먼스를 내도록 학습시킬 수 있다. 특히 <strong>Theseus</strong> 라이브러리는 희소 선형 솔버(Sparse Linear Solver)를 내장하여 로봇 공학에서 흔히 발생하는 희소 행렬 구조(Sparsity Pattern)를 효율적으로 처리한다.41</li>
</ul>
<hr />
<h2>2.4.4.6 프레임워크 생태계: JAX와 PyTorch의 로보틱스 대전</h2>
<p>미분 가능한 로봇 제어 시스템의 구현은 강력한 소프트웨어 프레임워크에 의존한다. 현재 이 분야는 크게 PyTorch 진영과 JAX 진영으로 나뉘어 발전하고 있다.</p>
<h3>1) Meta의 Theseus와 PyTorch 생태계</h3>
<p>Meta AI가 공개한 <strong>Theseus</strong>는 PyTorch 사용자를 위한 ‘미분 가능한 비선형 최적화’ 라이브러리이다.49 Theseus는 로봇 공학자들이 익숙한 문제들—SLAM, 번들 조정(Bundle Adjustment), 모션 플래닝—을 딥러닝 모델의 일부(Layer)로 쉽게 가져올 수 있도록 설계되었다.</p>
<ul>
<li><strong>특징:</strong> 어플리케이션 불가지론적(Application-agnostic) 설계로, 특정 로봇에 국한되지 않고 범용적으로 사용 가능하다.</li>
<li><strong>기술:</strong> 희소 선형 솔버(Sparse Solver) 지원, GPU 가속, 그리고 앞서 언급한 암시적 미분(Implicit Differentiation) 모드를 지원하여 대규모 최적화 문제의 역전파 효율을 극대화한다.43</li>
<li><strong>활용:</strong> 로봇의 촉각 센서 데이터로부터 상태를 추정하거나, 시각 정보 기반의 경로 계획 문제를 종단간 학습하는 데 활용된다.43</li>
</ul>
<h3>2) Google의 JAX와 로보틱스 가속화</h3>
<p>Google과 DeepMind가 주도하는 <strong>JAX</strong> 생태계는 최근 로봇 제어 연구에서 폭발적인 인기를 얻고 있다. JAX는 Python의 NumPy와 유사한 문법을 가지지만, 자동 미분(Autograd)과 XLA(Accelerated Linear Algebra) 컴파일러를 결합하여 압도적인 연산 속도를 제공한다.19</p>
<ul>
<li><strong>Vectorization (vmap):</strong> <code>vmap</code> 기능은 별도의 코드 수정 없이 단일 로봇 시뮬레이션 코드를 수천, 수만 대의 로봇 병렬 시뮬레이션으로 자동 변환해준다. 이는 강화학습의 데이터 수집 속도를 수천 배 가속화했다.</li>
<li><strong>Ecosystem:</strong> <strong>MuJoCo MJX</strong>(물리 엔진), <strong>Brax</strong>(대규모 병렬 시뮬레이터), <strong>DiffMPC</strong>(제어기), <strong>TorchOpt</strong>(최적화) 등 JAX 기반의 강력한 라이브러리들이 유기적으로 연결되어, 물리 엔진부터 제어기까지 전체 파이프라인이 하나의 고속 컴파일된 그래프로 실행된다.24</li>
</ul>
<h3>표 2.4.4.1 주요 미분 가능한 제어 및 시뮬레이션 라이브러리 비교</h3>
<table><thead><tr><th><strong>라이브러리</strong></th><th><strong>개발 주체</strong></th><th><strong>기반 프레임워크</strong></th><th><strong>주요 특징 및 용도</strong></th><th><strong>미분 방식</strong></th></tr></thead><tbody>
<tr><td><strong>Theseus</strong></td><td>Meta AI</td><td>PyTorch</td><td>비선형 최소제곱 최적화, SLAM, 모션 플래닝 레이어 통합</td><td>Implicit, Unrolling, DLM 49</td></tr>
<tr><td><strong>MuJoCo XLA (MJX)</strong></td><td>DeepMind</td><td>JAX</td><td>고속 물리 시뮬레이션, 강화학습, 제어. 기존 MuJoCo 모델 호환</td><td>Auto-diff via JAX (Soft contact) 24</td></tr>
<tr><td><strong>Brax</strong></td><td>Google</td><td>JAX</td><td>대규모 병렬 시뮬레이션, 진화 전략 및 RL. 순수 JAX 구현</td><td>Auto-diff via JAX 28</td></tr>
<tr><td><strong>DiffMPC</strong></td><td>-</td><td>JAX</td><td>GPU 가속 모델 예측 제어(MPC), 실시간 최적 제어</td><td>Implicit Differentiation, SQP 18</td></tr>
<tr><td><strong>Nimble</strong></td><td>-</td><td>C++/PyTorch</td><td>관절형 로봇 정밀 동역학, LCP 기반 접촉 처리</td><td>Analytical Gradients via LCP 21</td></tr>
<tr><td><strong>TorchOpt</strong></td><td>-</td><td>PyTorch</td><td>메타 러닝, 미분 가능한 최적화, 함수형 옵티마이저</td><td>Explicit/Implicit Differentiation 52</td></tr>
</tbody></table>
<h2>2.4.4.7 결론: 로봇 소프트웨어 2.0을 향하여</h2>
<p>로봇 제어 시스템을 **계산 그래프(Computational Graph)**로 바라보는 관점은 단순한 구현 도구의 변화를 넘어선다. 이는 테슬라의 안드레아 카르파시(Andrej Karpathy)가 주창한 ’소프트웨어 2.0’의 로봇 공학 버전이라 할 수 있다.</p>
<ol>
<li><strong>통합 최적화 (End-to-End Optimization):</strong> 인지, 판단, 제어의 각 모듈을 개별적으로 개발하고 튜닝하던 파편화된 방식에서, 전체 시스템을 하나의 손실 함수(Loss Function) 아래 통합하여 최적화하는 방식으로 진화했다. 이는 모듈 간의 경계에서 발생하는 비효율과 정보 손실을 최소화한다.5</li>
<li><strong>데이터와 물리의 공생:</strong> 미분 가능한 물리 엔진과 상태 추정기를 통해, 데이터(센서 입력)가 물리 모델을 보정하고, 역으로 물리 법칙(동역학)이 데이터 학습을 가이드하는 상호보완적 구조가 완성되었다. 이는 딥러닝의 ‘블랙박스’ 문제를 완화하고, 제어 이론의 ‘모델링 오차’ 문제를 해결하는 열쇠가 된다.11</li>
<li><strong>하드웨어 가속의 극대화:</strong> JAX, Theseus와 같은 도구들은 GPU/TPU의 대규모 병렬 처리 능력을 딥러닝뿐만 아니라 제어 알고리즘(MPC, LQR)과 시뮬레이션에 직접 활용하게 함으로써, 기존 CPU 기반 제어의 속도와 확장성 한계를 극복하고 있다.18</li>
</ol>
<p>결과적으로, 미래의 로봇 제어 엔지니어는 블록 다이어그램을 그리는 것을 넘어, 신경망과 물리 모델, 그리고 최적화 솔버가 얽힌 거대한 계산 그래프를 설계하고 학습시키는 **‘아키텍트(Architect)’**로서의 역량을 요구받게 될 것이다. 이러한 변화는 더 적응력 높고(Adaptive), 강인하며(Robust), 지능적인(Intelligent) 로봇 시스템의 등장을 가속화할 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>Block-based or graph-based? Why not both? Designing a hybrid programming environment for end-users | Interacting with Computers | Oxford Academic, 1월 4, 2026에 액세스, https://academic.oup.com/iwc/article/38/1/40/8151473</li>
<li>A comparison of robot control schemes. Traditional robot… - ResearchGate, 1월 4, 2026에 액세스, https://www.researchgate.net/figure/A-comparison-of-robot-control-schemes-Traditional-robot-control-approach-using-a_fig2_220061119</li>
<li>Control theory - Wikipedia, 1월 4, 2026에 액세스, https://en.wikipedia.org/wiki/Control_theory</li>
<li>Predict Responses Using PyTorch Model Predict Block - MATLAB &amp; Simulink - MathWorks, 1월 4, 2026에 액세스, https://www.mathworks.com/help/deeplearning/ug/predict-responses-using-pytorch-model-predict-block.html</li>
<li>Differentiable Programming: The Future of Machine Learning? | by Amit Yadav | Biased-Algorithms | Medium, 1월 4, 2026에 액세스, https://medium.com/biased-algorithms/differentiable-programming-the-future-of-machine-learning-8ab3214a8b85</li>
<li>Towards Computational Design of Shape and Control for Rigid Robots Jie Xu - People, 1월 4, 2026에 액세스, https://people.csail.mit.edu/jiex/thesis/phd_thesis.pdf</li>
<li>Actor-Critic Model Predictive Control: Differentiable Optimization meets Reinforcement Learning - Robotics and Perception Group, 1월 4, 2026에 액세스, https://rpg.ifi.uzh.ch/research_learning.html</li>
<li>Differentiable programming - Wikipedia, 1월 4, 2026에 액세스, https://en.wikipedia.org/wiki/Differentiable_programming</li>
<li>Physics-Informed Deep Learning for Traffic State Estimation: A Survey and the Outlook, 1월 4, 2026에 액세스, https://www.mdpi.com/1999-4893/16/6/305</li>
<li>Dynamic vs Static Computational Graphs - PyTorch and TensorFlow - GeeksforGeeks, 1월 4, 2026에 액세스, https://www.geeksforgeeks.org/deep-learning/dynamic-vs-static-computational-graphs-pytorch-and-tensorflow/</li>
<li>Certifiable Robot Design Optimization using Differentiable Programming, 1월 4, 2026에 액세스, https://www.roboticsproceedings.org/rss18/p037.pdf</li>
<li>Imperative MPC: An End-to-End Self-Supervised Learning with Differentiable MPC for UAV Attitude Control - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2504.13088v1</li>
<li>Interpretable PID parameter tuning for control engineering using general dynamic neural networks: An extensive comparison | PLOS One - Research journals, 1월 4, 2026에 액세스, https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0243320</li>
<li>Simulate PyTorch and Other Python-Based Models with Simulink Co-Execution Blocks, 1월 4, 2026에 액세스, https://blogs.mathworks.com/deep-learning/2024/08/20/simulate-pytorch-and-other-python-based-models-with-simulink-co-execution-blocks/</li>
<li>pytorch/pytorch: Tensors and Dynamic neural networks in Python with strong GPU acceleration - GitHub, 1월 4, 2026에 액세스, https://github.com/pytorch/pytorch</li>
<li>A State-of-the-Art Survey on Deep Learning Theory and Architectures - MDPI, 1월 4, 2026에 액세스, https://www.mdpi.com/2079-9292/8/3/292</li>
<li>How Computational Graphs are Constructed in PyTorch, 1월 4, 2026에 액세스, https://pytorch.org/blog/computational-graphs-constructed-in-pytorch/</li>
<li>Differentiable Model Predictive Control on the GPU - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2510.06179v1</li>
<li>A roboticist’s journey with JAX: Finding efficiency in optimal control and simulation, 1월 4, 2026에 액세스, https://developers.googleblog.com/en/a-roboticists-journey-with-jax/</li>
<li>Using JAX to accelerate our research - Google DeepMind, 1월 4, 2026에 액세스, https://deepmind.google/blog/using-jax-to-accelerate-our-research/</li>
<li>Fast and Feature-Complete Differentiable Physics for Articulated Rigid Bodies with Contact - Robotics, 1월 4, 2026에 액세스, https://www.roboticsproceedings.org/rss17/p034.pdf</li>
<li>Differentiable Physics Engine Overview - Emergent Mind, 1월 4, 2026에 액세스, https://www.emergentmind.com/topics/differentiable-physics-engine</li>
<li>Dojo: A Differentiable Physics Engine for Robotics - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2203.00806v5</li>
<li>Hard Contacts with Soft Gradients: Refining Differentiable Simulators for Learning and Control - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2506.14186v1</li>
<li>[2506.14186] Hard Contacts with Soft Gradients: Refining Differentiable Simulators for Learning and Control - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/abs/2506.14186</li>
<li>End-to-End and Highly-Efficient Differentiable Simulation for Robotics - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2409.07107v1</li>
<li>Differentiable Simulation of Hard Contacts with Soft Gradients for Learning and Control, 1월 4, 2026에 액세스, https://openreview.net/forum?id=2EGtfFwxx8</li>
<li>google/brax: Massively parallel rigidbody physics simulation on accelerator hardware. - GitHub, 1월 4, 2026에 액세스, https://github.com/google/brax</li>
<li>MuJoCo XLA (MJX), 1월 4, 2026에 액세스, https://mujoco.readthedocs.io/en/stable/mjx.html</li>
<li>A Review of Differentiable Simulators - IEEE Xplore, 1월 4, 2026에 액세스, https://ieeexplore.ieee.org/iel8/6287639/10380310/10589638.pdf</li>
<li>Continuous-Time State Estimation Methods in Robotics: A Survey, 1월 4, 2026에 액세스, https://www.research-collection.ethz.ch/server/api/core/bitstreams/c77e42e8-e9d2-4695-87ff-2dae1d785e8f/content</li>
<li>Autodifferentiable Ensemble Kalman Filters | SIAM Journal on Mathematics of Data Science, 1월 4, 2026에 액세스, https://epubs.siam.org/doi/10.1137/21M1434477</li>
<li>differentiable kalman filters in jax - brain of mat kelcey, 1월 4, 2026에 액세스, https://matpalm.com/blog/differentiable_kalman_filters_in_jax/</li>
<li>stanford-iprl-lab/torchfilter: Bayesian filters in PyTorch - GitHub, 1월 4, 2026에 액세스, https://github.com/stanford-iprl-lab/torchfilter</li>
<li>Deep implicit layers and applications - Research webpage of Matthieu Blanke, 1월 4, 2026에 액세스, https://mb-29.github.io/assets/pdf/thesis.pdf</li>
<li>Revisiting semi-supervised training objectives for differentiable particle filters - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2405.01251v1</li>
<li>Differentiable Particle Filters: End-to-End Learning with Algorithmic Priors - Robotics, 1월 4, 2026에 액세스, https://roboticsproceedings.org/rss14/p01.pdf</li>
<li>CS391R Robot Learning - Differentiable Particle Filters, 1월 4, 2026에 액세스, https://www.cs.utexas.edu/~yukez/cs391r_fall2021/slides/pre_09-28_Gerardo.pdf</li>
<li>EleGNN: Electrical-Model-Guided Graph Neural Networks for Power Distribution System State Estimation - The University of Rhode Island, 1월 4, 2026에 액세스, https://web.uri.edu/decps/wp-content/uploads/sites/1880/2022_Globecom_EleGNN_Electrical-Model-Guided_Graph_Neural_Networks_for_Power_Distribution_System_State_Estimation.pdf</li>
<li>Physics-informed Graphical Neural Network for Power System State Estimation - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2312.17738v1</li>
<li>Differentiable MPC for End-to-end Planning and Control, 1월 4, 2026에 액세스, https://homes.cs.washington.edu/~bboots/files/DMPC.pdf</li>
<li>Chapter 5: Differentiable optimization - Deep Implicit Layers, 1월 4, 2026에 액세스, http://implicit-layers-tutorial.org/differentiable_optimization/</li>
<li>Theseus: A Library for Differentiable Nonlinear Optimization - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/pdf/2207.09442</li>
<li>[Quick Review] Theseus: A Library for Differentiable Nonlinear Optimization - Liner, 1월 4, 2026에 액세스, https://liner.com/review/theseus-a-library-for-differentiable-nonlinear-optimization</li>
<li>Efficient and Modular Implicit Differentiation - NIPS papers - NeurIPS, 1월 4, 2026에 액세스, https://proceedings.neurips.cc/paper_files/paper/2022/file/228b9279ecf9bbafe582406850c57115-Paper-Conference.pdf</li>
<li>DiLQR: Differentiable Iterative Linear Quadratic Regulator via Implicit Differentiation - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/html/2506.17473v1</li>
<li>Differentiable Model Predictive Control on the GPU - OpenReview, 1월 4, 2026에 액세스, https://openreview.net/forum?id=bFYfV6c9zu</li>
<li>(PDF) Differentiable Robust LQR Layers - ResearchGate, 1월 4, 2026에 액세스, https://www.researchgate.net/publication/352308956_Differentiable_Robust_LQR_Layers</li>
<li>Theseus: A Library for Differentiable Nonlinear Optimization - Meta Research - Facebook, 1월 4, 2026에 액세스, https://research.facebook.com/publications/theseus-a-library-for-differentiable-nonlinear-optimization/</li>
<li>facebookresearch/theseus: A library for differentiable nonlinear optimization - GitHub, 1월 4, 2026에 액세스, https://github.com/facebookresearch/theseus</li>
<li>Theseus: A Library for Differentiable Nonlinear Optimization - NeurIPS, 1월 4, 2026에 액세스, https://proceedings.neurips.cc/paper_files/paper/2022/file/185969291540b3cd86e70c51e8af5d08-Paper-Conference.pdf</li>
<li>TorchOpt is an efficient library for differentiable optimization built upon PyTorch. - GitHub, 1월 4, 2026에 액세스, https://github.com/metaopt/torchopt</li>
<li>Comparison of Deep Learning and Deterministic Algorithms for Control Modeling - PMC, 1월 4, 2026에 액세스, https://pmc.ncbi.nlm.nih.gov/articles/PMC9459824/</li>
<li>[2206.08831] Comparison of Deep Learning and Deterministic Algorithms for Control Modeling - arXiv, 1월 4, 2026에 액세스, https://arxiv.org/abs/2206.08831</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>