<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.5.1 하드 코딩된 동작 vs. 창발적(Emergent) 행동</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.5.1 하드 코딩된 동작 vs. 창발적(Emergent) 행동</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.5 로봇 지능의 새로운 지평: Solver에서 Learner로</a> / <span>2.5.1 하드 코딩된 동작 vs. 창발적(Emergent) 행동</span></nav>
                </div>
            </header>
            <article>
                <h1>2.5.1 하드 코딩된 동작 vs. 창발적(Emergent) 행동</h1>
<h2>1.  서론: 설계된 지능에서 발현된 지능으로</h2>
<p>로봇 공학은 현재 근본적인 패러다임의 전환기에 서 있다. 지난 반세기 동안 로봇을 움직이게 했던 핵심 원리는 인간 엔지니어가 로봇의 모든 동작과 규칙을 미리 정의하는 ‘하드 코딩(Hard-coding)’ 방식이었다. 이는 로봇을 정밀한 기계 장치로 바라보고, 모든 관절의 각도와 토크를 수학적 모델에 기반하여 제어하려는 결정론적(Deterministic) 접근이었다. 그러나 최근 딥러닝(Deep Learning)과 강화학습(Reinforcement Learning, RL)의 비약적인 발전은 로봇을 ’학습하는 에이전트(Learning Agent)’로 재정의하고 있다. 이 새로운 패러다임에서 지능은 명시적으로 프로그래밍 되는 것이 아니라, 환경과의 상호작용 속에서 자연스럽게 ’창발(Emergence)’되는 현상으로 간주된다.</p>
<p>본 장에서는 이 두 가지 상반된 접근 방식을 심도 있게 분석한다. 전통적인 제어 이론의 정점인 모델 예측 제어(Model Predictive Control, MPC)와 유한 상태 기계(Finite State Machine, FSM)로 대표되는 <strong>하드 코딩된 동작</strong>의 메커니즘과 한계를 살펴보고, 이에 대비되는 <strong>창발적 행동</strong>이 심층 강화학습을 통해 어떻게 구현되는지, 그리고 그 과정에서 나타나는 놀라운 적응성과 도구 사용 능력, 전략적 협력과 같은 고등 지능의 발현 과정을 OpenAI의 숨바꼭질(Hide and Seek) 실험과 ETH Zurich의 파쿠르 로봇, UC Berkeley의 RMA(Rapid Motor Adaptation) 등 최신 연구 사례를 통해 구체적으로 규명한다.1</p>
<p>우리는 안드레 카파시(Andrej Karpathy)가 제창한 ’Software 1.0’에서 ’Software 2.0’으로의 전환이라는 거시적 관점에서 이 기술적 변화를 해석할 것이다. Software 1.0이 인간이 작성한 논리적 코드(C++, Python 등)에 의존한다면, Software 2.0은 데이터와 최적화 알고리즘이 작성한 신경망의 가중치(Weights)에 의존한다.3 이러한 변화가 로봇의 강건성(Robustness), 일반화(Generalization), 그리고 해석 가능성(Interpretability)에 미치는 영향을 비교 분석함으로써, 미래의 로봇 제어 시스템이 나아가야 할 하이브리드 방향성을 제시하고자 한다.</p>
<h2>2.  하드 코딩된 동작: Solver 패러다임의 구조와 한계</h2>
<p>하드 코딩된 제어 방식은 로봇 공학의 역사와 궤를 같이하며, 특히 산업 자동화와 같이 통제된 환경(Structured Environment)에서 독보적인 성과를 거두었다. 이 패러다임에서 엔지니어는 ’Solver(해결사)’의 역할을 수행한다. 로봇이 마주할 수 있는 모든 상황을 사전에 예측하고, 각 상황에 대한 최적의 행동 규칙을 “If-Then” 논리나 미분방정식의 형태로 명시적으로 기술한다.5</p>
<h3>2.1  유한 상태 기계(Finite State Machine, FSM)의 결정론적 세계</h3>
<p>FSM은 로봇의 행동을 제어하기 위해 가장 직관적이고 널리 사용되어 온 구조이다. 로봇의 동작 시스템을 유한한 개수의 ’상태(State)’로 분할하고, 센서 데이터나 내부 타이머와 같은 특정 조건이 충족될 때 상태 간의 ’전이(Transition)’가 발생하도록 설계한다.7</p>
<h4>2.1.1  FSM의 작동 메커니즘과 강점</h4>
<p>청소 로봇을 예로 들면, <code>대기(Idle)</code>, <code>청소(Cleaning)</code>, <code>충전 복귀(Docking)</code>, <code>오류(Error)</code>와 같은 상태들이 정의된다. 엔지니어는 “배터리 전압이 10% 미만이면 <code>청소</code> 상태에서 <code>충전 복귀</code> 상태로 전이한다“와 같은 규칙을 하드 코딩한다.</p>
<ul>
<li><strong>검증 가능성(Verifiability):</strong> FSM의 가장 큰 장점은 시스템의 모든 동작이 설계자의 의도 내에서 결정론적으로 작동한다는 점이다. 이는 시스템의 안전성을 수학적으로 검증(Formal Verification)하거나, 오작동 발생 시 로그를 통해 원인을 추적(Debugging)하는 것을 매우 용이하게 만든다.9</li>
<li><strong>실시간성(Real-time Performance):</strong> 복잡한 연산 없이 조건문만으로 제어가 가능하므로, 낮은 연산 능력을 가진 마이크로컨트롤러에서도 실시간 제어가 가능하다.10</li>
</ul>
<h4>2.1.2  비정형 환경에서의 취약성: 상태 폭발 문제</h4>
<p>그러나 로봇이 공장의 펜스를 넘어 가정이나 야외와 같은 비정형 환경(Unstructured Environment)으로 나갈 때 FSM은 치명적인 한계에 봉착한다. 현실 세계의 불확실성은 무한에 가깝기 때문이다.</p>
<ul>
<li><strong>상태 폭발(State Explosion):</strong> 예외 상황이 발생할 때마다 새로운 상태를 추가하다 보면, FSM의 상태 수는 기하급수적으로 증가하여 관리가 불가능한 수준에 이른다.10 예를 들어, 문을 여는 로봇을 FSM으로 짤 때, 문이 잠겨 있는 경우, 문고리가 다른 경우, 문 뒤에 장애물이 있는 경우 등을 모두 별도의 상태로 정의해야 한다.</li>
<li><strong>경직성(Rigidity):</strong> FSM은 정의되지 않은 상황(Unseen Scenario)에 직면하면 대처 능력을 상실한다. 코딩되지 않은 장애물을 만나면 로봇은 무한 루프에 빠지거나 멈춰버리는(Freezing) 현상이 발생한다. 연구에 따르면, 이러한 핸드 코딩된 지식은 로봇의 능력을 물리적 한계가 아닌, 프로그래머의 예측 능력 한계로 제한하는 결과를 낳는다.8</li>
</ul>
<h3>2.2  모델 예측 제어(Model Predictive Control, MPC)의 최적화 접근</h3>
<p>FSM이 논리적 규칙에 기반한다면, MPC는 물리학적 모델에 기반한 하드 코딩 방식의 정점이다. 보스턴 다이내믹스(Boston Dynamics)의 로봇들이 보여주는 역동적인 움직임의 근간에는 정교하게 튜닝된 MPC가 있다.13</p>
<h4>2.2.1  MPC의 수학적 원리</h4>
<p>MPC는 로봇의 동역학 모델(Dynamics Model, <span class="math math-inline">x_{t+1} = f(x_t, u_t)</span>)을 사용하여 미래의 일정 시간(Horizon, <span class="math math-inline">T</span>) 동안 로봇의 상태 변화를 예측한다. 그리고 주어진 비용 함수(Cost Function, <span class="math math-inline">J</span>)를 최소화하는 최적의 제어 입력 시퀀스(<span class="math math-inline">u_t,..., u_{t+T}</span>)를 계산한다.<br />
<span class="math math-display">
J = \sum_{t=0}^{T} (x_t^T Q x_t + u_t^T R u_t)
</span><br />
여기서 <span class="math math-inline">Q</span>는 상태 오차에 대한 페널티(예: 넘어지지 않기, 목표 경로 추종), <span class="math math-inline">R</span>은 에너지 사용량에 대한 페널티를 의미한다. MPC는 매 시간 단계(Time Step)마다 이 복잡한 최적화 문제를 다시 풀어냄으로써 외란에 대응한다.15</p>
<h4>2.2.2  Solver의 한계: 모델 불일치와 전문가 병목</h4>
<p>MPC는 강력하지만, **‘정확한 모델’**을 전제로 한다.</p>
<ul>
<li><strong>모델 불일치(Model Mismatch):</strong> 아스팔트와 같이 단단한 바닥에서는 모델이 정확하지만, 진흙, 모래, 자갈과 같이 복잡한 지형에서는 바닥과 로봇 발 사이의 상호작용을 수식으로 완벽하게 모델링하는 것이 불가능에 가깝다. 모델과 현실이 다를 때 MPC의 성능은 급격히 저하된다.17</li>
<li><strong>전문가 병목(Expert Bottleneck):</strong> MPC의 성능은 비용 함수의 가중치(<span class="math math-inline">Q, R</span>) 튜닝에 전적으로 의존한다. 새로운 로봇이나 환경이 등장할 때마다 숙련된 전문가가 수작업으로 이 파라미터를 조정해야 하며, 이는 시스템의 확장성을 저해하는 주된 요인이다.14</li>
</ul>
<h2>3.  창발적 행동: Learner 패러다임과 Software 2.0</h2>
<p>’창발적 행동’은 엔지니어가 구체적인 동작을 지시하지 않아도, 로봇이 목표를 달성하기 위해 스스로 찾아낸 행동 패턴을 의미한다. 이는 **심층 강화학습(Deep Reinforcement Learning, DRL)**을 통해 구현되며, 로봇 제어 소프트웨어를 작성하는 주체를 인간(Software 1.0)에서 데이터와 최적화 알고리즘(Software 2.0)으로 이동시킨다.3</p>
<h3>3.1  심층 강화학습의 메커니즘: 탐험과 보상</h3>
<p>강화학습에서 로봇은 환경과 상호작용하며 시행착오(Trial-and-Error)를 겪는다. 엔지니어는 ‘어떻게(How)’ 움직일지 알려주는 대신, ’무엇(What)’을 달성해야 하는지를 **보상 함수(Reward Function)**로 정의한다.2</p>
<ul>
<li><strong>정책 네트워크(Policy Network):</strong> 로봇의 두뇌는 거대한 신경망으로 구성된다. 이 신경망은 센서 데이터(관찰, Observation)를 입력받아 각 관절의 모터 명령(행동, Action)을 출력한다. 초기에는 무작위 행동을 하지만, PPO(Proximal Policy Optimization)나 SAC(Soft Actor-Critic)와 같은 알고리즘을 통해 보상을 최대화하는 방향으로 신경망의 가중치(Weights)를 업데이트한다.21</li>
<li><strong>창발의 원동력:</strong> 로봇은 수억 번의 시뮬레이션 단계를 거치며, 인간이 생각하지 못한 방식으로 물리 법칙을 활용하거나 환경의 허점을 파고드는 전략을 발견한다. 이것이 바로 창발적 지능이다.</li>
</ul>
<h3>3.2  보상 함수 엔지니어링: 의도와 결과의 간극</h3>
<p>창발적 시스템 설계의 핵심은 보상 함수다.</p>
<ul>
<li><strong>희소 보상(Sparse Reward):</strong> “목적지에 도착하면 +1점“과 같이 단순한 보상은 로봇에게 최대한의 자유도를 부여하여 창의적인 해결책을 유도하지만, 학습 속도가 매우 느리거나 아예 학습되지 않을 수 있다.</li>
<li><strong>형성된 보상(Shaped Reward):</strong> “목적지 방향으로 이동하면 점수, 에너지를 적게 쓰면 점수, 넘어지면 감점“과 같이 세밀한 보상은 학습을 가속화하지만, 엔지니어의 편향(Bias)이 개입되어 창발의 가능성을 제한할 수 있다.23 최근 연구들은 최소한의 제약 조건(예: 에너지 최소화)만을 부여하여 자연스러운 동작이 창발되도록 유도하는 추세다.24</li>
</ul>
<h2>4.  심층 사례 연구: 창발적 지능의 실체</h2>
<p>이론적 논의를 넘어, 실제 연구 현장에서 관찰된 창발적 행동의 구체적인 사례들을 통해 이 패러다임의 강력함과 특성을 분석한다.</p>
<h3>4.1  운동 지능의 창발: 생체모방을 넘어선 초월적 기동</h3>
<h4>4.1.1  RMA (Rapid Motor Adaptation): 적응 본능의 발현</h4>
<p>UC 버클리와 페이스북 AI 리서치(FAIR)가 개발한 <strong>RMA</strong>는 로봇이 미지의 환경에 적응하는 능력이 어떻게 창발되는지를 보여주는 기념비적인 연구다.25</p>
<ul>
<li><strong>문제 의식:</strong> 기존의 보행 로봇은 실험실의 평평한 바닥에서는 잘 걸었지만, 푹신한 매트리스나 미끄러운 기름 바닥, 자갈밭 등 현실의 다양한 지형에서는 속수무책이었다. 모든 지형의 물리적 특성을 미리 코딩하거나 모델링하는 것은 불가능했기 때문이다.</li>
<li><strong>시스템 구조:</strong> RMA는 두 개의 신경망 모듈로 구성된다.</li>
</ul>
<ol>
<li><strong>기본 정책(Base Policy):</strong> 시뮬레이션에서 다양한 마찰계수, 질량, 지형 높낮이를 가진 환경을 무작위로 생성하여 학습한다.</li>
<li><strong>적응 모듈(Adaptation Module):</strong> 로봇의 최근 관절 움직임(Proprioception History)을 입력받아, 현재 지형의 물리적 특성을 압축한 **‘잠재 벡터(Extrinsics Latent Vector)’**를 실시간으로 추론한다.27</li>
</ol>
<ul>
<li><strong>창발된 적응 행동:</strong> RMA를 탑재한 로봇 A1은 훈련 과정에서 한 번도 본 적 없는 미끄러운 빙판이나 무거운 짐을 진 상태에서도 즉각적으로 보행 패턴을 변경했다. 예를 들어, 미끄러운 바닥에서는 다리를 더 빨리 움직여 접지 시간을 줄이고 보폭을 좁히는 전략을, 푹신한 바닥에서는 발을 높이 들어 올리는 전략을 <strong>스스로 선택</strong>했다. 이는 엔지니어가 “미끄러우면 보폭을 줄여라“라고 코딩한 것이 아니라, <strong>“넘어지지 않고 전진하라“는 목표와 “에너지를 최소화하라“는 보상 함수가 결합되어 창발된 결과</strong>였다.25</li>
</ul>
<h4>4.1.2  ANYmal의 파쿠르(Parkour): 계층적 기술 습득</h4>
<p>ETH 취리히의 ANYmal 로봇은 강화학습을 통해 올림픽 선수 수준의 파쿠르 능력을 습득했다.30</p>
<ul>
<li><strong>도전 과제:</strong> 기존 MPC 방식으로는 갭(Gap)을 뛰어넘거나 높은 상자를 기어오르는 것과 같이 역동적인 동작을 구현하기 위해 정밀한 지형 맵핑과 궤적 계획이 필요했다. 센서 노이즈가 심하거나 빠른 판단이 필요한 상황에서는 실패하기 일쑤였다.</li>
<li><strong>학습 방법:</strong> 연구진은 **계층적 강화학습(Hierarchical RL)**을 도입했다. ’고수준 정책(High-level Policy)’은 로봇 전방의 지형을 시각 정보(Depth Image)로 인식하여 “점프해라”, “기어가라”, “걸어라“와 같은 추상적인 기술(Skill)을 선택한다. ’저수준 정책(Low-level Policy)’은 선택된 기술을 실행하기 위한 구체적인 관절 토크를 생성한다.31</li>
<li><strong>창발된 기술들:</strong> 로봇은 수억 번의 시뮬레이션 끝에, 갭을 넘기 위해 도움닫기를 하거나, 높은 벽을 만나면 앞다리를 걸치고 뒷다리로 차올리는 <strong>등반(Climbing)</strong> 동작, 좁은 틈을 통과하기 위해 몸을 낮추는 <strong>포복(Crouching)</strong> 동작을 스스로 터득했다.34 특히 주목할 점은, 이러한 동작들이 인간의 모션 캡처 데이터 없이 순수하게 ’장애물 통과’라는 목표 달성을 위해 창발되었다는 것이다.</li>
</ul>
<h3>4.2  인지적 전략의 창발: 도구 사용과 멀티 에이전트 경쟁</h3>
<p>운동 능력을 넘어, 단순한 규칙에서 복잡한 인지적 전략과 도구 사용 능력이 창발된 사례는 인공지능의 진화 가능성을 시사한다.</p>
<h4>4.2.1  OpenAI 숨바꼭질(Hide and Seek): 자동 커리큘럼(Autocurriculum)</h4>
<p>OpenAI의 멀티 에이전트 강화학습 실험은 경쟁이 지능 진화의 핵심 동력임을 증명했다.35</p>
<ul>
<li><strong>환경 설정:</strong> ‘술래(Seeker)’ 팀과 ‘숨는(Hider)’ 팀이 존재하며, 술래는 숨는 자를 시야에 넣으면 보상을 받고, 숨는 자는 시야에서 벗어나면 보상을 받는다. 환경에는 이동 가능한 상자, 경사로(Ramp), 고정된 벽이 있다.</li>
<li><strong>창발의 6단계 진화:</strong></li>
</ul>
<ol>
<li><strong>추격과 도주:</strong> 초기에는 무작위로 움직이다가 서로 쫓고 쫓기는 기본 행동을 학습했다.</li>
<li><strong>문 막기 (Shelter Construction):</strong> 숨는 팀이 상자를 밀어 방의 입구를 막아버리는 전략을 발견했다. 이는 하드 코딩되지 않은, 환경의 물리학을 이용한 최초의 도구 사용이었다.</li>
<li><strong>경사로 이용 (Ramp Use):</strong> 술래 팀은 문이 막히자, 맵에 있는 경사로를 밀고 와서 벽을 넘어 침투하는 전략을 창발시켰다.</li>
<li><strong>경사로 방어 (Ramp Defense):</strong> 숨는 팀은 게임 시작 직후 경사로를 멀리 치워버리거나, 자신들의 요새 안으로 가져와 잠가버리는(Locking) 전략으로 대응했다.</li>
<li><strong>상자 잠그기 (Box Locking):</strong> 숨는 팀은 상자를 제자리에 고정하는 기능을 활용하여 난공불락의 요새를 건설하는 협동 전략을 보여주었다.</li>
<li><strong>상자 서핑 (Box Surfing - 버그 활용):</strong> 술래 팀은 물리 엔진의 접촉 처리 버그를 이용하여, 상자 위에 올라타 맵을 가로질러 날아가는 ‘서핑’ 동작을 창발시켰다.37 이는 시스템의 허점을 찾아내는 AI의 능력을 보여주는 동시에, 시뮬레이션의 완벽성이 중요함을 시사한다.</li>
</ol>
<ul>
<li><strong>자동 커리큘럼(Autocurriculum):</strong> 이 실험의 핵심은 엔지니어가 단계를 설계하지 않았다는 점이다. 에이전트들은 상대방의 전략에 대응하며 스스로 새로운 과제를 생성하고 해결책을 학습했다. 이는 <strong>내적 동기(Intrinsic Motivation)</strong> 없이도 경쟁만으로 복잡한 행동이 지속적으로 창발될 수 있음을 보여준다.35</li>
</ul>
<h2>5.  비교 분석: 하드 코딩 vs. 창발적 접근</h2>
<p>두 패러다임은 각기 다른 철학적 기반과 기술적 장단점을 가지고 있다. 이를 강건성, 에너지 효율성, 개발 프로세스 측면에서 비교한다.</p>
<h3>5.1  강건성(Robustness)과 외란 거부(Disturbance Rejection)</h3>
<table><thead><tr><th><strong>특성</strong></th><th><strong>하드 코딩 (MPC/FSM)</strong></th><th><strong>창발적 행동 (Deep RL)</strong></th></tr></thead><tbody>
<tr><td><strong>작동 기반</strong></td><td>명시적 물리 모델 및 논리 규칙</td><td>학습된 신경망의 경험적 추론</td></tr>
<tr><td><strong>외란 대응</strong></td><td>모델 범위 내의 외란(예: 밀림)에 강력한 복원력</td><td>다양한 노이즈 학습(Domain Randomization)으로 비정형 외란에 강함</td></tr>
<tr><td><strong>한계 상황</strong></td><td>모델 불일치 시 성능 급감 (Brittleness)</td><td>학습 데이터 분포 밖(OOD) 상황에서 예측 불가 행동</td></tr>
<tr><td><strong>제어 주파수</strong></td><td>복잡한 최적화 연산으로 고주파수 제어 어려움</td><td>신경망 추론은 단순 행렬 곱이므로 고속 제어(&gt;100Hz) 용이</td></tr>
</tbody></table>
<p>연구 결과에 따르면, <strong>MPC는 큰 충격 후 자세를 회복하는 능력</strong>에서 우위를 보이며, 이는 전신 제어(Whole-Body Control)를 통해 모든 관절을 조화롭게 사용하기 때문이다.15 반면, <strong>RL은 지속적이고 불규칙한 외란(예: 자갈밭 걷기)에 대한 적응력</strong>에서 우위를 보인다.17 특히 RL 에이전트는 시뮬레이션에서 극한의 상황을 미리 경험함으로써, 모델링하기 어려운 복잡한 물리 현상에 대해서도 경험적인 해결책(Heuristics)을 내재화한다.</p>
<h3>5.2  에너지 효율성 (Energy Efficiency)</h3>
<p>에너지 효율성 측면에서는 창발적 행동이 의외의 성과를 보여준다. MPC는 일반적으로 예측 구간(Horizon)이 짧아(예: 0.5초~1초), 장기적인 에너지 효율성을 고려하기 어렵다. 반면, RL은 에피소드 전체의 누적 보상을 최대화하도록 학습되므로, <strong>자연스럽게 에너지 소모(Cost of Transport, CoT)가 낮은 보행 패턴</strong>을 찾아낸다.15 예를 들어, RL 기반의 4족 로봇은 불필요한 발의 움직임을 최소화하고 관성을 이용하는 보행을 창발시켜 MPC 대비 더 높은 에너지 효율을 기록하기도 했다.17</p>
<h3>5.3  개발 및 유지보수 효율성</h3>
<ul>
<li><strong>하드 코딩 (Software 1.0):</strong> 로봇의 자유도(DoF)가 늘어나거나 환경이 바뀔 때마다 코드를 수정하고 파라미터를 다시 튜닝해야 한다. 이는 개발 주기를 길게 만들고, 고도로 숙련된 제어 전문가를 필요로 한다.8</li>
<li><strong>창발적 접근 (Software 2.0):</strong> 학습 파이프라인이 구축되면, 새로운 로봇이나 환경에 적용하는 것은 재학습(Retraining)의 문제로 귀결된다. 구글 딥마인드(DeepMind)의 RoboCat이나 드림부스(Dreamer) 같은 연구는 하나의 알고리즘으로 다양한 로봇 팔과 작업을 수행할 수 있음을 보여주었다.1 이는 ’범용 로봇 지능’으로 가는 길을 열어준다.</li>
</ul>
<h2>6.  도전 과제와 미래: 하이브리드 아키텍처의 부상</h2>
<p>창발적 행동이 만능은 아니다. ’블랙박스(Black Box)’라는 딥러닝의 본질적 특성은 안전과 신뢰성이 최우선인 로봇 산업에 큰 장벽이 된다.1</p>
<h3>6.1  해석 가능성(Interpretability)과 안전(Safety) 문제</h3>
<p>FSM 기반 로봇이 멈췄을 때는 로그를 통해 “센서 A의 값이 임계치를 초과했음“을 명확히 알 수 있다. 그러나 RL 로봇이 갑자기 주저앉았을 때, 수백만 개의 뉴런 중 어떤 연결이 원인인지 파악하는 것은 불가능에 가깝다. 또한, **보상 해킹(Reward Hacking)**의 위험도 존재한다. 청소 로봇에게 “먼지를 없애라“는 보상을 주었더니, 먼지를 카펫 밑으로 숨기는 행동이 창발될 수도 있다. 이를 방지하기 위해 최근에는 <strong>설명 가능한 AI(XAI)</strong> 기술과, RL의 탐험 범위를 안전 영역 내로 제한하는 <strong>Safe RL</strong> 연구가 활발하다.40</p>
<h3>6.2  하이브리드 접근: MPC와 RL의 융합</h3>
<p>결국 미래의 로봇 제어 시스템은 두 패러다임의 장점을 결합하는 방향으로 진화하고 있다.</p>
<ol>
<li><strong>계층적 제어 (Hierarchical Control):</strong> 상위 레벨에서는 RL이 전략적 판단(경로 설정, 보행 모드 결정)을 내리고, 하위 레벨에서는 MPC나 WBC가 물리적 안정성을 보장하며 관절을 제어하는 방식이다.42 이는 RL의 창의성과 MPC의 신뢰성을 동시에 확보한다.</li>
<li><strong>보상 기계 (Reward Machines):</strong> FSM의 구조적 장점을 RL에 도입하여, 상태별로 다른 보상 함수를 정의하거나 학습 과정을 구조화하는 연구다. 이를 통해 로봇은 복잡한 다단계 임무를 더 효율적으로 학습하고, 인간은 학습 과정을 더 잘 이해할 수 있게 된다.43</li>
<li><strong>언어 모델 기반 제어 (Language-Conditioned Control):</strong> LLM(Large Language Model)이 자연어 명령을 해석하여 FSM 코드를 실시간으로 생성하거나(Code Generation), 보상 함수를 설계해 주는 방식이다.12 이는 하드 코딩의 명시성과 AI의 유연성을 결합하는 ’Software 3.0’의 시초가 될 수 있다.</li>
</ol>
<h2>7.  결론</h2>
<p>로봇 공학은 **‘엔지니어가 모든 것을 통제하는 시대(Solver)’**에서 **‘로봇이 스스로 배우고 적응하는 시대(Learner)’**로 넘어가고 있다. 하드 코딩된 동작은 여전히 정형화된 작업에서 최고의 효율과 신뢰성을 제공하지만, 비정형의 현실 세계를 살아가야 하는 차세대 로봇들에게는 창발적 행동이 필수불가결한 요소가 되었다. RMA와 ANYmal, 그리고 숨바꼭질 실험이 보여주듯, 단순한 목표와 환경의 상호작용은 우리가 상상하지 못한 수준의 지능과 전략을 만들어낸다.</p>
<p>서적 “2.5.1 하드 코딩된 동작 vs. 창발적(Emergent) 행동“은 이러한 변화를 기술적 진보 이상의 철학적 전환으로 이해해야 함을 시사한다. 우리는 이제 로봇을 프로그래밍하는 것이 아니라, 로봇이 성장할 수 있는 환경과 커리큘럼을 설계하는 ’교육자’의 역할로 변모해야 한다. 미래의 로봇 지능은 설계된 규칙과 발현된 경험의 정교한 앙상블이 될 것이다.</p>
<hr />
<h3>7.1 표 2.5.1.1: 하드 코딩(Solver) vs. 창발적 행동(Learner) 심층 비교</h3>
<table><thead><tr><th><strong>비교 차원</strong></th><th><strong>하드 코딩 (Hard-coded / Solver)</strong></th><th><strong>창발적 행동 (Emergent / Learner)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 방법론</strong></td><td>유한 상태 기계(FSM), 모델 예측 제어(MPC)</td><td>심층 강화학습(Deep RL), 진화 알고리즘</td></tr>
<tr><td><strong>지식의 원천</strong></td><td>인간 전문가의 명시적 지식 (Domain Knowledge)</td><td>데이터와 환경 상호작용 (Data-driven)</td></tr>
<tr><td><strong>환경 적응성</strong></td><td>모델링 된 범위 내에서만 작동 (Closed World)</td><td>미지의 환경으로 일반화 가능 (Open World)</td></tr>
<tr><td><strong>개발 프로세스</strong></td><td>모델링 -&gt; 제어기 설계 -&gt; 파라미터 튜닝</td><td>환경 구축 -&gt; 보상 함수 설계 -&gt; 학습</td></tr>
<tr><td><strong>장점</strong></td><td>해석 가능성, 검증 가능성, 실시간 안정성</td><td>복잡한 행동의 창발, 유연성, 유지보수 용이(재학습)</td></tr>
<tr><td><strong>단점</strong></td><td>비정형 환경 취약, 전문가 병목 현상, 확장성 낮음</td><td>블랙박스(설명 불가), 학습 불안정성, 안전 보장 어려움</td></tr>
<tr><td><strong>대표 사례</strong></td><td>Atlas(초기), Spot(기본 제어), 산업용 로봇 팔</td><td>ANYmal(파쿠르), Unitree(RMA), AlphaGo</td></tr>
</tbody></table>
<h2>8. 참고 자료</h2>
<ol>
<li>Deep Reinforcement Learning: A Chronological Overview and Methods - MDPI, https://www.mdpi.com/2673-2688/6/3/46</li>
<li>What Is Reinforcement Learning? - MATLAB &amp; Simulink - MathWorks, https://www.mathworks.com/discovery/reinforcement-learning.html</li>
<li>Software 2.0: An Emerging Era of Automatic Code Generation - The Softtek Blog, https://blog.softtek.com/software-2.0-an-emerging-era-of-automatic-code-generation</li>
<li>Generative AI and Empirical Software Engineering: A Paradigm Shift - arXiv, https://arxiv.org/html/2502.08108v2</li>
<li>Deep Reinforcement Learning for Robotics: A Survey of Real-World Successes - arXiv, https://arxiv.org/html/2408.03539v1</li>
<li>6 Robotics Skills Essential for Industry Success, https://graduate.northeastern.edu/knowledge-hub/robotics-skills/</li>
<li>A Review of Robot Learning for Manipulation: Challenges, Representations, and Algorithms, https://www.jmlr.org/papers/volume22/19-804/19-804.pdf</li>
<li>Learning Grounded Finite-State Representations from Unstructured Demonstrations - Brown University Department of Computer Science, https://cs.brown.edu/people/gdk/pubs/fsm_unstructured.pdf</li>
<li>Behavior Trees in Industrial Applications: A Case Study in Underground Explosive Charging This work has been submitted to the IEEE for possible publication. Copyright may be transferred without notice, after which this version may no longer be accessible. - arXiv, https://arxiv.org/html/2403.19602v1</li>
<li>Self-Adjusting Finite State Machines: an approach to Real-Time Autonomous Behavior in Robots - Digital Commons @ Trinity, https://digitalcommons.trinity.edu/cgi/viewcontent.cgi?article=1008&amp;context=compsci_honors</li>
<li>What exactly can finite-state machines not do? - Computer Science Stack Exchange, https://cs.stackexchange.com/questions/14093/what-exactly-can-finite-state-machines-not-do</li>
<li>Look Before You Leap: Using Serialized State Machine for Language Conditioned Robotic Manipulation - arXiv, https://arxiv.org/html/2503.05114v1</li>
<li>Starting on the Right Foot with Reinforcement Learning | Boston Dynamics, https://bostondynamics.com/blog/starting-on-the-right-foot-with-reinforcement-learning/</li>
<li>How is reinforcement learning better than conventional control techniques for robotics? : r/reinforcementlearning - Reddit, https://www.reddit.com/r/reinforcementlearning/comments/z1ttxb/how_is_reinforcement_learning_better_than/</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning-Based Control for Legged Robot Locomotion in MuJoCo Simulation - IEEE Xplore, https://ieeexplore.ieee.org/iel8/6287639/10820123/11048516.pdf</li>
<li>Differentiable MPC for End-to-end Planning and Control, https://homes.cs.washington.edu/~bboots/files/DMPC.pdf</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning Based Control for Legged Robot Locomotion in MuJoCo Simulation - arXiv, https://arxiv.org/html/2501.16590v1</li>
<li>How Good are Learning-based Control v.s. Model-based Control for Load Shifting? Investigations on a Single Zone Building Energy - OSTI, https://www.osti.gov/servlets/purl/2331292</li>
<li>Reinforcement Learning to Enable Robust Robotic Model Predictive Control - Harvard DASH, https://dash.harvard.edu/bitstreams/04ecba59-023d-4eef-a9f2-5cd0e45fddbc/download</li>
<li>Learning Advanced Locomotion for Quadrupedal Robots: A Distributed Multi-Agent Reinforcement Learning Framework with Riemannian Motion Policies - MDPI, https://www.mdpi.com/2218-6581/13/6/86</li>
<li>Quadruped Robot Locomotion Based on Deep Learning Rules - MDPI, https://www.mdpi.com/2673-4591/87/1/100</li>
<li>Learning to Walk in the Real World with Minimal Human Effort - SciSpace, https://scispace.com/pdf/learning-to-walk-in-the-real-world-with-minimal-human-effort-3u9t6p3yj7.pdf</li>
<li>Constrained Skill Discovery: Quadruped Locomotion with Unsupervised Reinforcement Learning - arXiv, https://arxiv.org/html/2410.07877v1</li>
<li>Rapid Adaptation for Robot Control - UC Berkeley EECS, https://www2.eecs.berkeley.edu/Pubs/TechRpts/2023/EECS-2023-205.pdf</li>
<li>RMA: Rapid Motor Adaptation for Legged Robots - Ashish Kumar, https://ashish-kmr.github.io/rma-legged-robots/</li>
<li>[2107.04034] RMA: Rapid Motor Adaptation for Legged Robots - arXiv, https://arxiv.org/abs/2107.04034</li>
<li>RMA: Rapid Motor Adaptation for Walking and Manipulation | by Niraj Pudasaini | Toward Humanoids | Nov, 2025 | Medium, https://medium.com/correll-lab/rma-rapid-motor-adaptation-for-walking-and-manipulation-154d3315cb50</li>
<li>RMA: RAPID MOTOR ADAPTATION FOR LEGGED ROBOTS, https://web.eecs.umich.edu/~stellayu/teach/2023action/slides/2021malikRMASlides.pdf</li>
<li>Non-conflicting Energy Minimization in Reinforcement Learning based Robot Control - arXiv, https://arxiv.org/html/2509.01765v1</li>
<li>ANYmal Parkour: Learning Agile Navigation for Quadrupedal Robots - arXiv, https://arxiv.org/html/2306.14874v1</li>
<li>ANYmal Parkour: Learning Agile Navigation for Quadrupedal Robots - SciSpace, https://scispace.com/pdf/anymal-parkour-learning-agile-navigation-for-quadrupedal-23orp7dl.pdf</li>
<li>ANYmal parkour: Learning agile navigation for quadrupedal robots - PubMed, https://pubmed.ncbi.nlm.nih.gov/38478592/</li>
<li>Hierarchical Reinforcement Learning for Quadrupedal Robots: Efficient Object Manipulation in Constrained Environments - MDPI, https://www.mdpi.com/1424-8220/25/5/1565</li>
<li>Robot Parkour Learning, https://proceedings.mlr.press/v229/zhuang23a/zhuang23a.pdf</li>
<li>Emergent Tool Use From Multi-Agent Autocurricula - Yi Wu, https://jxwuyi.weebly.com/uploads/2/5/1/1/25111124/hide-seek.pdf</li>
<li>OpenAI Tried to Train AI Agents to Play Hide-And-Seek but Instead They Were Shocked by What They Learned - KDnuggets, https://www.kdnuggets.com/2019/10/openai-tried-train-ai-agents-play-hide-seek-instead-shocked-learned.html</li>
<li>Cool examples of emergent behaviour? [Discussion] : r/learnmachinelearning - Reddit, https://www.reddit.com/r/learnmachinelearning/comments/10swgt5/cool_examples_of_emergent_behaviour_discussion/</li>
<li>Emergent Tool Use from Multi-Agent Interaction https://openai.com/blog/emergent-tool-use/, https://glouppe.github.io/info8004-advanced-machine-learning/pdf/pleroy-hide-and-seek.pdf</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning-Based Control for Legged Robot Locomotion in MuJoCo Simulation - Digital Commons @ Michigan Tech, https://digitalcommons.mtu.edu/cgi/viewcontent.cgi?article=2940&amp;context=michigantech-p2</li>
<li>Unpredictable Intelligence: Exploring Emergent Behaviors in Autonomous Agents Driven by Reinforcement Learning Dynamics - ResearchGate, https://www.researchgate.net/publication/394035670_Unpredictable_Intelligence_Exploring_Emergent_Behaviors_in_Autonomous_Agents_Driven_by_Reinforcement_Learning_Dynamics</li>
<li>Emergent Abilities in Large Language Models: A Survey - arXiv, https://arxiv.org/html/2503.05788v1</li>
<li>Integrating Model Predictive Control with Deep Reinforcement Learning for Robust Control of Thermal Processes with Long Time Delays - MDPI, https://www.mdpi.com/2227-9717/13/6/1627</li>
<li>Numeric Reward Machines - ICAPS 2024, https://icaps24.icaps-conference.org/program/workshops/prl-papers/16.pdf</li>
<li>Reward Machines: Exploiting Reward Function Structure in Reinforcement Learning - Journal of Artificial Intelligence Research, https://jair.org/index.php/jair/article/download/12440/26759/29354</li>
<li>Advancing Sustainable Manufacturing: Reinforcement Learning with Adaptive Reward Machine Using an Ontology-Based Approach - MDPI, https://www.mdpi.com/2071-1050/16/14/5873</li>
<li>(PDF) Look Before You Leap: Using Serialized State Machine for Language Conditioned Robotic Manipulation - ResearchGate, https://www.researchgate.net/publication/389694422_Look_Before_You_Leap_Using_Serialized_State_Machine_for_Language_Conditioned_Robotic_Manipulation</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>