<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.2.4 적응 제어(Adaptive Control)에서 학습(Learning)으로의 필연적 이동</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.2.4 적응 제어(Adaptive Control)에서 학습(Learning)으로의 필연적 이동</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</a> / <span>2.2.4 적응 제어(Adaptive Control)에서 학습(Learning)으로의 필연적 이동</span></nav>
                </div>
            </header>
            <article>
                <h1>2.2.4 적응 제어(Adaptive Control)에서 학습(Learning)으로의 필연적 이동</h1>
<h2>1.  서론: 결정론적 세계관의 종언과 데이터 기반 패러다임의 태동</h2>
<p>20세기 중반, 제어 공학의 역사는 시스템의 불확실성(Uncertainty)을 정복하기 위한 치열한 투쟁의 기록이었다. 1950년대 고성능 항공기의 오토파일럿 설계를 위해 태동한 적응 제어(Adaptive Control)는 시스템의 수학적 모델이 불완전하거나 시간이 지남에 따라 변할 때, 제어기 스스로 파라미터를 조정하여 성능을 유지한다는 혁신적인 아이디어를 제시했다.1 초기 모델 참조 적응 제어(Model Reference Adaptive Control, MRAC)와 자가 동조 조절기(Self-Tuning Regulator, STR)의 성공은 엔지니어들에게 “적절한 구조의 모델만 있다면, 어떤 시스템도 수학적으로 완벽하게 제어할 수 있다“는 결정론적 믿음을 심어주기에 충분했다.2</p>
<p>그러나 21세기에 접어들어 로봇 공학이 정형화된 공장 자동화 라인을 벗어나 비정형 환경(Unstructured Environment)—재난 현장의 잔해 속, 예측 불가능한 가정 환경, 혹은 미지의 우주 행성 표면—으로 진출함에 따라, 이러한 믿음은 근본적인 도전에 직면하게 되었다.4 고전적 적응 제어가 전제로 하는 ‘선형 파라미터화(Linear-in-Parameters)’ 가정과 ‘지속적 가진(Persistent Excitation)’ 조건은 복잡한 접촉 역학(Contact Dynamics), 고차원 비선형성, 그리고 모델링 자체가 불가능한 구조적 불확실성(Structural Uncertainty) 앞에서 더 이상 유효하지 않음이 드러났다.</p>
<p>본 장에서는 적응 제어의 수학적 전제들이 실제 물리 세계의 복잡성과 충돌하며 발생하는 구조적 한계를 심층적으로 분석한다. 우리는 왜 파라미터 추정(Parameter Estimation)이라는 좁은 틀을 벗어나 함수 근사(Function Approximation)와 표현 학습(Representation Learning)으로 나아가야만 하는지, 그리고 이러한 기술적 압력이 어떻게 신경망(Neural Networks)과 강화 학습(Reinforcement Learning)을 포함한 ’학습 기반 제어(Learning-based Control)’로의 필연적 이동을 이끌어내고 있는지 논증할 것이다. 이것은 단순한 알고리즘의 교체가 아니라, 물리적 세계를 기술하는 언어가 ’미분 방정식’에서 ’데이터’로 전환되는 거대한 패러다임의 변화이다.</p>
<h2>2.  고전적 적응 제어의 이론적 토대와 ’선형성’의 구속</h2>
<p>적응 제어의 핵심은 시스템의 동역학이 알려진 구조(Structure)를 가지고 있으나, 그 구조를 구성하는 계수(Coefficient), 즉 파라미터(Parameter)를 모른다는 가정에서 출발한다. 이 섹션에서는 MRAC와 STR로 대표되는 고전적 방법론이 어떻게 설계되었으며, 그 기저에 깔린 ’선형성의 족쇄’가 무엇인지 파헤친다.</p>
<h3>2.1  모델 참조 적응 제어(MRAC)와 자가 동조 조절기(STR)의 구조적 본질</h3>
<p>적응 제어 전략은 크게 두 가지, MRAC와 STR로 분류된다. 이 두 방식은 접근법은 다르지만 본질적으로 시스템의 파라미터를 실시간으로 추정하고 보정한다는 동일한 목표를 공유한다.2</p>
<p>**모델 참조 적응 제어(MRAC)**는 시스템(Plant)의 출력이 미리 정의된 이상적인 ’참조 모델(Reference Model)’의 출력을 따라가도록 강제하는 방식이다. 제어기의 파라미터는 출력 오차(Output Error)와 참조 모델의 상태 간의 상관관계에 기반하여 실시간으로 업데이트된다. 이는 주로 리아프노프 안정성 이론(Lyapunov Stability Theory)이나 포포프의 초안정성 정리(Popov’s Hyperstability Theorem)를 사용하여 설계되므로, 수학적으로 엄밀한 안정성 보장을 제공한다는 장점이 있다.6</p>
<p>반면, **자가 동조 조절기(STR)**는 시스템의 파라미터를 먼저 추정(Estimation)한 뒤, 그 추정된 파라미터를 바탕으로 제어기를 설계(Design)하는 분리된 두 단계를 거친다. 이는 ‘확실성 등가 원칙(Certainty Equivalence Principle)’—추정된 파라미터를 마치 참값인 것처럼 간주하고 제어기를 설계해도 된다는 원칙—에 기반한다.1 STR은 재귀적 최소 자승법(Recursive Least Squares, RLS)과 같은 강력한 추정 알고리즘을 사용할 수 있어 확률적 외란에 강한 면모를 보인다.</p>
<p>그러나 이 두 방식 모두 시스템의 동역학 모델이 제어 입력과 파라미터에 대해 선형적인 관계, 혹은 선형화 가능한 관계를 맺고 있다는 강력한 가정을 필요로 한다. [표 2-1]은 두 제어 방식의 특징과 구조적 가정을 비교 요약한 것이다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>모델 참조 적응 제어 (MRAC)</strong></th><th><strong>자가 동조 조절기 (STR)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 목표</strong></td><td>참조 모델의 출력 추적 (Tracking)</td><td>파라미터 추정 및 최적 제어기 설계 (Regulation/Tracking)</td></tr>
<tr><td><strong>적응 메커니즘</strong></td><td>리아프노프/초안정성 기반 직접 적응 (Direct Adaptation)</td><td>파라미터 추정 후 제어기 계산 (Indirect Adaptation)</td></tr>
<tr><td><strong>주요 가정</strong></td><td>모델 구조가 완벽히 알려져 있음 (Linear-in-Parameters)</td><td>확실성 등가 원칙 (Certainty Equivalence) 성립</td></tr>
<tr><td><strong>안정성 보장</strong></td><td>이론적으로 강력함 (설계 시 보장)</td><td>추정 수렴성에 의존 (보장 까다로움)</td></tr>
<tr><td><strong>한계점</strong></td><td>구조적 불확실성 및 비모델링 동역학에 취약</td><td>계산 복잡도 및 과도 응답 제어의 어려움</td></tr>
</tbody></table>
<h3>2.2  파라미터 선형성(Linear-in-Parameters) 가정이 내포한 물리적 모순</h3>
<p>로봇 매니퓰레이터 제어에서 가장 널리 사용되는 적응 제어 기법은 슬롯-리(Slotine-Li) 알고리즘으로 대표되는 <strong>파라미터 선형성(Linear-in-Parameters, LIP)</strong> 기반 접근법이다.8 이 이론은 로봇의 복잡한 비선형 동역학 식을 다음과 같은 형태로 재작성할 수 있다고 가정한다:<br />
<span class="math math-display">
\tau = M(q)\ddot{q} + C(q, \dot{q})\dot{q} + G(q) = Y(q, \dot{q}, \ddot{q})\theta
</span><br />
여기서 <span class="math math-inline">\tau</span>는 관절 토크 벡터, <span class="math math-inline">q, \dot{q}, \ddot{q}</span>는 각각 관절의 위치, 속도, 가속도 벡터이다. 우변의 <span class="math math-inline">Y(q, \dot{q}, \ddot{q})</span>는 **회귀 행렬(Regressor Matrix)**이라 불리는, 로봇의 기구학적 정보와 측정된 상태만으로 구성된 행렬이며, <span class="math math-inline">\theta</span>는 질량, 관성 모멘트, 링크의 무게중심 등 미지의 물리량을 포함하는 파라미터 벡터이다.</p>
<p>이 식의 핵심은, 비록 동역학 자체는 상태 변수 <span class="math math-inline">q</span>에 대해 고도의 비선형성을 띠지만, 우리가 모르는 파라미터 <span class="math math-inline">\theta</span>에 대해서는 ‘선형 결합’ 형태를 띤다는 점이다. 이 LIP 구조 덕분에 우리는 볼록 최적화(Convex Optimization) 기법이나 단순한 경사 하강법(Gradient Descent) 형태의 업데이트 법칙을 사용하여 <span class="math math-inline">\theta</span>를 추정할 수 있다.10<br />
<span class="math math-display">
\dot{\hat{\theta}} = -\Gamma^{-1} Y^T e
</span><br />
하지만 실제 물리 세계는 이러한 LIP 가정을 비웃듯 다양한 반례를 제시한다. 가장 대표적인 문제는 파라미터가 상수가 아니거나, 파라미터 자체가 상태 변수의 복잡한 비선형 함수로 나타나는 경우이다. 이는 단순한 수학적 테크닉으로 해결할 수 없는 근본적인 모델링의 한계이다.</p>
<h3>2.3  마찰 및 유체 역학적 비선형성에서의 모델 붕괴 현상</h3>
<p>LIP 가정의 붕괴를 가장 극명하게 보여주는 사례는 **마찰(Friction)**과 **유체 역학(Hydrodynamics/Aerodynamics)**이다.</p>
<p>마찰 모델의 비선형성:</p>
<p>교과서적인 쿨롱 마찰(Coulomb Friction)이나 점성 마찰(Viscous Friction) 모델은 <span class="math math-inline">F_{fric} = F_c \text{sgn}(\dot{q}) + F_v \dot{q}</span> 형태로 표현되어 파라미터 <span class="math math-inline">F_c, F_v</span>에 대해 선형적이므로 적응 제어가 가능하다. 그러나 실제 고정밀 로봇이나 저속 구동 시스템에서 나타나는 마찰 현상은 훨씬 복잡하다.</p>
<p>스트라이벡(Stribeck) 효과, 정지 마찰에서 운동 마찰로 넘어갈 때의 히스테리시스(Hysteresis), 그리고 루그레(LuGre) 모델과 같은 동적 마찰 모델은 내부 상태 변수(bristle deflection 등)를 가지며, 이는 LIP 형태인 <span class="math math-inline">Y\theta</span>로 표현될 수 없다.12 특히 루그레 모델의 경우 미분 방정식 형태로 표현되는 내부 상태가 존재하여, 이를 단순 파라미터 추정으로 다루려 할 경우 제어기는 진동하거나(Limit Cycle), 부정확한 위치 결정(Stick-slip motion)을 초래한다.</p>
<p>유체 역학적 항력의 복잡성:</p>
<p>수중 로봇(AUV)이나 드론과 같은 시스템에서 항력(Drag)은 속도의 제곱에 비례하는 항(<span class="math math-inline">D \propto v^2</span>)으로 모델링되곤 한다. 그러나 이는 난류(Turbulence)가 발달한 특정 영역에서만 유효한 근사일 뿐이다. 실제 유체 역학적 계수는 레이놀즈 수(Reynolds Number), 받음각(Angle of Attack), 그리고 표면 거칠기 등의 복잡한 함수이다. 이러한 계수들은 상수가 아니며(Non-constant parameters), 시스템의 상태에 따라 실시간으로 변동하는 비선형 함수 <span class="math math-inline">C_d(Re, \alpha)</span>이다.14 이를 고정된 파라미터 <span class="math math-inline">\theta</span>로 가정하고 적응 제어를 수행하면, 제어기는 끊임없이 변하는 ’가짜 파라미터’를 쫓아가느라(Chasing a moving target) 과도한 제어 입력을 생성하거나 불안정해진다.</p>
<p>이처럼 LIP 가정은 물리 현상을 지나치게 단순화함으로써, 정밀 제어가 요구되는 극한 환경이나 비선형성이 지배적인 시스템에서는 오히려 제어 성능을 저해하는 요인이 된다. 이것이 적응 제어가 ’학습’으로 진화해야 하는 첫 번째 물리적 동기이다.</p>
<h2>3.  정보론적 병목: 회귀 행렬(Regressor Matrix)의 불능성</h2>
<p>설령 시스템이 완벽하게 LIP 조건을 만족한다고 가정하더라도, 적응 제어를 구현하기 위해서는 또 하나의 거대한 장벽을 넘어야 한다. 바로 <strong>회귀 행렬 <span class="math math-inline">Y</span>를 정확하게 계산해낼 수 있는가</strong>의 문제이다. 이 섹션에서는 비정형 환경에서의 로봇 공학, 특히 접촉이 수반되는 작업에서 회귀 행렬의 구성이 왜 정보론적으로 불가능에 가까운지 분석한다.</p>
<h3>3.1  회귀 행렬 구성의 기하학적 전제 조건</h3>
<p>회귀 행렬 <span class="math math-inline">Y(q, \dot{q}, \ddot{q})</span>는 로봇의 기구학(Kinematics) 모델에 전적으로 의존한다. 링크의 길이, 관절의 축 방향, 그리고 힘이 작용하는 작용점(Point of Application)의 위치를 정확히 알아야만 <span class="math math-inline">Y</span>를 구성할 수 있다.15 공장에서 고정된 궤적을 도는 용접 로봇이라면 이는 문제가 되지 않는다. 하지만 미지의 환경과 상호작용하는 로봇에게 ’정확한 기구학적 정보’는 사치에 가깝다.</p>
<p>특히 외부 힘 <span class="math math-inline">F_{ext}</span>가 작용하는 경우, 동역학 식은 다음과 같이 확장된다:<br />
<span class="math math-display">
M(q)\ddot{q} + C(q, \dot{q})\dot{q} + G(q) = \tau + J^T(q)F_{ext}
</span><br />
여기서 <span class="math math-inline">J^T(q)</span>는 접촉점에 대한 야코비안 전치 행렬이다. 이 식을 LIP 형태로 변환하여 적응 제어를 수행하려면, 외부 힘과 관련된 항들도 모두 회귀 행렬 <span class="math math-inline">Y</span> 안에 포함시켜야 한다. 즉, <span class="math math-inline">Y_{ext}\theta_{env} = J^T(q)F_{ext}</span> 형태가 되어야 하는데, 이를 위해서는 접촉점의 정확한 위치 정보가 필수적이다.16</p>
<h3>3.2  랭크 결핍(Rank Deficiency)과 기저 파라미터 식별의 한계</h3>
<p>회귀 행렬 <span class="math math-inline">Y</span>가 성공적으로 구성되었다 하더라도, 파라미터 추정값 <span class="math math-inline">\hat{\theta}</span>가 실제 물리적 참값 <span class="math math-inline">\theta</span>로 수렴하기 위해서는 <span class="math math-inline">Y</span> 행렬이 **풀 랭크(Full Rank)**여야 한다. 즉, <span class="math math-inline">Y^T Y</span>가 역행렬을 가져야 한다. 그러나 많은 로봇 시스템에서 회귀 행렬은 구조적으로 <strong>랭크 결핍(Rank Deficient)</strong> 상태에 빠진다.17</p>
<p>구조적 종속성:</p>
<p>로봇의 일부 파라미터들은 동역학 방정식 내에서 서로 결합되어 나타나며, 개별적으로 분리해낼 수 없다. 예를 들어, 모터의 로터 관성(Rotor Inertia)과 링크의 관성(Link Inertia)은 종종 하나의 항으로 합쳐져 나타난다. 또한, 평면 운동을 하는 로봇의 경우 중력 방향과 수직인 축에 대한 관성 모멘트는 식별할 수 없다.20 이러한 경우, 적응 제어기는 개별 파라미터를 식별하는 대신, 이들의 선형 결합인 **기저 파라미터(Base Parameters)**만을 식별할 수 있다.21</p>
<p>문제는 이 기저 파라미터조차 시스템의 상태나 구속 조건에 따라 변한다는 점이다. 특히 다리 로봇이나 휴머노이드 로봇이 지면과 접촉하여 닫힌 운동학적 사슬(Closed Kinematic Chain)을 형성하는 지지 구간(Stance Phase)에서는, 닫힌 루프 구속 조건(Loop Closure Constraints)으로 인해 자유도가 감소하면서 회귀 행렬의 랭크가 급격히 떨어진다.22 이때 적응 제어 알고리즘은 파라미터 공간의 영공간(Null Space)에서 표류(Drift)하게 되며, 이는 제어기의 강건성을 심각하게 훼손시킨다. 파라미터가 발산하지 않더라도, 엉뚱한 값으로 수렴한 파라미터는 로봇이 예상치 못한 동작(예: 접촉 소실 시 급격한 가속)을 할 때 치명적인 결과를 초래할 수 있다.24</p>
<h3>3.3  미지 접촉점(Unknown Contact Point) 문제와 야코비안의 불확정성</h3>
<p>비정형 환경에서 로봇이 직면하는 가장 난해한 문제는 **접촉점의 위치를 모른다(Unknown Contact Point)**는 것이다. 재난 구조 로봇이 무너진 벽을 밀거나, 가정용 로봇이 복잡한 형태의 물체를 조작할 때, 접촉은 점(Point), 선(Line), 혹은 면(Surface)의 형태로 불확실하게 발생한다.25</p>
<p>접촉점의 위치 <span class="math math-inline">r_c</span>를 모른다는 것은 야코비안 <span class="math math-inline">J(q, r_c)</span>를 정의할 수 없다는 것을 의미한다. 야코비안이 정의되지 않으면, 외부 힘 <span class="math math-inline">F_{ext}</span>를 관절 토크 공간으로 매핑할 수 없으며, 결과적으로 회귀 행렬 <span class="math math-inline">Y</span> 자체를 구성하는 것이 수학적으로 불가능해진다.26<br />
<span class="math math-display">
\tau_{ext} = J^T(q, \text{unknown}) F_{ext} \quad \Rightarrow \quad Y(\dots) \text{ is undefined.}
</span><br />
이 상황에서 기존의 적응 제어론을 억지로 적용하려 하면, 접촉 위치를 또 하나의 추정해야 할 파라미터로 설정해야 한다. 하지만 접촉 위치와 접촉 힘은 동역학 식에서 곱의 형태(<span class="math math-inline">r_c \times F</span>)로 나타나므로, 이는 <strong>비선형 파라미터화(Nonlinear Parameterization)</strong> 문제를 야기한다. 즉, LIP 가정이 다시 한번 깨지게 된다.28 연구자들은 이를 해결하기 위해 추정된 접촉점을 기반으로 회귀 행렬을 반복적으로 갱신하는 방법을 제안했지만, 이는 계산 비용이 매우 높고 수렴성을 보장하기 어렵다.16 결국, 미지 접촉점 문제는 모델 기반 적응 제어의 범위를 넘어서는, **인식(Perception)과 제어(Control)가 결합된 학습(Learning)**으로의 전환을 강력하게 요구하는 지점이다.</p>
<h3>3.4  지속적 가진(Persistent Excitation)의 역설: 제어와 학습의 상충</h3>
<p>적응 제어 이론에서 파라미터 수렴을 위한 성배(Holy Grail)는 <strong>지속적 가진(Persistent Excitation, PE)</strong> 조건이다. 수학적으로 이는 회귀 행렬 <span class="math math-inline">Y</span>가 시간 구간 <span class="math math-inline">T</span> 동안 충분한 에너지를 가져야 함을 의미한다.20<br />
<span class="math math-display">
\int_{t}^{t+T} Y^T(\tau) Y(\tau) d\tau \ge \alpha I &gt; 0
</span><br />
이 조건이 만족되어야만 파라미터 오차 <span class="math math-inline">\tilde{\theta}</span>가 0으로 수렴한다. 그러나 로봇 공학의 실용적 관점에서 PE 조건은 치명적인 역설(Paradox)을 안고 있다.</p>
<ol>
<li><strong>제어와 학습의 목표 상충:</strong> 제어의 목표는 트래킹 오차 <span class="math math-inline">e</span>를 0으로 만드는 것이다. 이상적으로 제어가 잘 되어 로봇이 참조 궤적을 완벽하게 따라가거나 목표 지점에 정지해 있다면(Regulation), 시스템의 움직임은 줄어들고 <span class="math math-inline">Y</span> 행렬의 성분들은 0에 가까워진다. 즉, <strong>“제어가 성공할수록 학습(파라미터 추정)을 위한 정보는 사라진다”</strong>. 학습을 위해 로봇을 계속 흔들어대면(Dithering) 제어 성능과 에너지 효율이 떨어지고, 제어 성능을 높이면 학습이 멈추는 딜레마에 빠진다.29</li>
<li><strong>버스팅(Bursting) 현상:</strong> PE 조건이 만족되지 않는 상태(예: 로봇이 정지해 있을 때)에서 작은 외란이나 잡음이 들어오면, 적응 알고리즘은 이 잡음을 보상하기 위해 파라미터를 엉뚱한 방향으로 급격하게 키우기 시작한다. 이를 ‘파라미터 드리프트(Parameter Drift)’ 또는 ’버스팅(Bursting)’이라 한다. 파라미터가 비정상적으로 커진 상태에서 갑자기 새로운 명령이 들어오면, 시스템은 불안정하게 발산할 수 있다.29</li>
<li><strong>안전성 문제:</strong> 정밀 수술 로봇이나 인간과 협업하는 로봇에게 PE 조건을 만족시키기 위해 “충분히 풍부한 진동 신호“를 주입하는 것은 안전상 허용될 수 없다.31</li>
</ol>
<p>최근 연구들은 ’동시 학습(Concurrent Learning)’이나 ’저장된 데이터(Experience Replay)’를 활용하여 PE 조건을 완화하려 시도하고 있다.31 이는 과거의 데이터를 버리지 않고 축적하여 활용한다는 점에서, 이미 순수 적응 제어를 넘어 **데이터 기반 학습(Data-Driven Learning)**의 영역으로 진입하고 있음을 시사한다.</p>
<h2>4.  구조적 불확실성(Structural Uncertainty)과 하이브리드 동역학의 도전</h2>
<p>앞서 논의한 파라미터 불확실성(Parametric Uncertainty)은 모델의 뼈대는 알고 있다는 비교적 양호한 상황을 가정한 것이다. 하지만 실제 세계는 모델의 구조 자체가 불명확하거나 시간에 따라 급변하는 **구조적 불확실성(Structural Uncertainty)**으로 가득 차 있다. 데이비스(Davis)는 이를 “현상에 대한 이해 부족에서 기인하며, 파라미터 튜닝만으로는 해결할 수 없는 근본적인 불확실성“으로 정의했다.33</p>
<h3>4.1  파라미터 불확실성과 구조적 불확실성의 인식론적 차이</h3>
<p>파라미터 불확실성이 “우리가 가진 지도의 축척이 틀린 것“이라면, 구조적 불확실성은 “지도가 묘사하는 지형 자체가 실제와 다른 것“에 비유할 수 있다. 예를 들어, 기후 모델에서 대기 중 <span class="math math-inline">CO_2</span> 농도에 따른 온도 상승 계수를 모르는 것은 파라미터 불확실성이지만, 구름의 형성 과정이나 해류의 순환 메커니즘 자체를 잘못 모델링한 것은 구조적 불확실성이다.36</p>
<p>로봇 제어에서 구조적 불확실성은 주로 모델링 과정에서 생략된 물리 현상이나, 수학적으로 기술하기 힘든 상호작용에서 발생한다. 적응 제어기는 “모델 구조가 옳다“는 전제하에 작동하므로, 구조적 오차를 파라미터 오차로 잘못 해석하여 엉뚱한 적응을 수행하게 된다. 이는 단순한 성능 저하가 아니라 제어 시스템의 논리적 파탄을 의미한다.</p>
<h3>4.2  하이브리드 시스템에서의 모드 전환과 적응 이득의 폭주</h3>
<p>로봇이 걷거나 물체를 잡는 순간, 시스템은 자유 운동(Free Motion)에서 구속 운동(Constrained Motion)으로, 혹은 미끄러짐(Slip)에서 고착(Stick)으로 상태가 급변한다. 이러한 시스템을 **하이브리드 동역학 시스템(Hybrid Dynamical System)**이라 한다.38</p>
<p>하이브리드 시스템의 핵심 특징은 상태 공간의 **비연속성(Discontinuity)**과 **모드 전환(Mode Switching)**이다.</p>
<ul>
<li><strong>충격(Impact):</strong> 로봇 발이 지면에 닿는 순간, 속도는 불연속적으로 변하며 이론적으로 무한대의 힘(Impulse)이 발생한다.</li>
<li><strong>차원 변화:</strong> 공중에 뜬 로봇 팔은 6자유도지만, 벽을 짚는 순간 구속 조건에 의해 유효 자유도가 감소한다.</li>
</ul>
<p>연속 시간을 가정하는 MRAC와 같은 적응 제어기는 이러한 불연속적인 이벤트를 처리하는 데 취약하다. 충격 순간 발생하는 거대한 트래킹 오차 <span class="math math-inline">e</span>는 적응 법칙 <span class="math math-inline">\dot{\hat{\theta}} = -\Gamma^{-1} Y^T e</span>에 의해 파라미터 추정값을 순식간에 폭주(Wind-up)시킨다.40 이로 인해 로봇은 접촉 직후 과도한 토크를 출력하여 튕겨 나가거나 진동하게 된다. 하이브리드 적응 제어(Hybrid MRAC) 연구가 진행되고 있으나, 모든 가능한 모드 전환 시나리오(Guard Conditions)를 미리 정의해야 한다는 점에서, 미지의 환경에 대한 범용성을 확보하는 데는 한계가 있다.39</p>
<h3>4.3  비모델링 동역학(Unmodeled Dynamics)과 연성 로봇의 무한 자유도</h3>
<p>구조적 불확실성의 또 다른 주요 원인은 **비모델링 동역학(Unmodeled Dynamics)**이다. 모든 물리적 시스템은 무한한 자유도를 가지지만, 제어 모델은 이를 유한 차원의 상미분 방정식(ODE)으로 근사한다. 이 과정에서 고주파 진동 모드(Structural flexibility), 액추에이터의 동특성, 센서의 노이즈 필터링 효과 등이 무시된다.7</p>
<p>로봇 제어 역사에서 유명한 **“로어스의 반례(Rohrs’ Counterexample)”**는 완벽하게 설계된 적응 제어기가 아주 미세한 비모델링 고주파 동역학이나 외란에 의해 어떻게 발산할 수 있는지를 보여준 충격적인 사례였다. 적응 제어기의 고이득(High Gain) 특성은 무시되었던 고주파수 영역의 동역학을 자극(Excite)하여 전체 시스템을 불안정하게 만들 수 있다.</p>
<p>특히 최근 각광받는 **연성 로봇(Soft Robotics)**이나 연속체 로봇(Continuum Robots)의 경우, 이러한 문제는 극대화된다. 문어 팔이나 코끼리 코를 모사한 이 로봇들은 뼈대가 없으며, 본질적으로 무한 자유도의 연속체 역학(Continuum Mechanics)을 따른다.42 이를 <span class="math math-inline">Y\theta</span> 형태의 유한 차원 파라미터 모델로 표현하는 것은 불가능에 가깝다. 이러한 시스템에서는 모델의 구조를 사전에 정의하는 것이 아니라, 데이터를 통해 시스템의 거동 자체를 학습하는 접근법이 유일한 대안이 된다.</p>
<h2>5.  과도기적 해법: 신경 적응 제어(Neuro-Adaptive Control)의 등장이 갖는 의미</h2>
<p>고전적 적응 제어의 한계—LIP 가정의 붕괴, 구조적 불확실성—를 극복하기 위해 제어 이론가들은 1990년대부터 신경망(Neural Networks)을 제어 루프에 도입하기 시작했다. 이것이 바로 **신경 적응 제어(Neuro-Adaptive Control, NAC)**이다. NAC는 적응 제어의 구조적 틀을 유지하면서, 미지의 비선형 함수를 근사하기 위해 신경망을 ’조정 가능한 비선형 블록’으로 활용하는 전략이다.44</p>
<h3>5.1  보편 근사 정리(Universal Approximation Theorem)와 제어 법칙의 융합</h3>
<p>NAC의 이론적 기반은 **보편 근사 정리(Universal Approximation Theorem, UAT)**이다. UAT는 “충분한 수의 뉴런을 가진 단일 은닉층 신경망은 콤팩트 집합(Compact Set) 위에서 임의의 연속 함수를 원하는 오차 <span class="math math-inline">\epsilon</span> 이내로 근사할 수 있다“는 강력한 정리이다.46</p>
<p>이를 제어에 적용하면, 로봇의 미지 동역학 <span class="math math-inline">f(x)</span>를 더 이상 물리적 파라미터의 조합 <span class="math math-inline">Y\theta</span>로 억지로 끼워 맞출 필요가 없어진다. 대신 다음과 같이 신경망 모델로 대체한다:<br />
<span class="math math-display">
\tau = M(q)\ddot{q} + f(q, \dot{q}) \quad \Rightarrow \quad f(x) = W^{*T}\phi(x) + \epsilon(x)
</span><br />
여기서 <span class="math math-inline">W^*</span>는 이상적인 신경망 가중치(Ideal Weights), <span class="math math-inline">\phi(x)</span>는 기저 함수 벡터(예: RBF, Sigmoid), <span class="math math-inline">\epsilon(x)</span>는 근사 오차(Reconstruction Error)이다. 이제 적응 제어의 목표는 물리적 파라미터 <span class="math math-inline">\theta</span>를 찾는 것이 아니라, 함수 <span class="math math-inline">f(x)</span>를 가장 잘 표현하는 가중치 <span class="math math-inline">W</span>를 찾는 것으로 바뀐다.48 이는 LIP 가정을 우회하여 마찰, 공력, 유연성 등 모델링하기 힘든 비선형성을 처리할 수 있는 길을 열어주었다.</p>
<h3>5.2  리아프노프 안정성 기반의 가중치 업데이트 법칙 유도</h3>
<p>NAC의 가장 큰 공헌은 신경망 학습을 제어 이론의 틀 안으로 가져와 <strong>안정성을 증명</strong>했다는 점이다. 일반적인 딥 러닝이 역전파(Backpropagation)를 통해 손실 함수를 최소화하는 것과 달리, NAC는 리아프노프 안정성 분석을 통해 가중치 업데이트 법칙을 유도한다.50</p>
<p>시스템의 트래킹 오차 <span class="math math-inline">e</span>와 가중치 오차 <span class="math math-inline">\tilde{W} = W - W^*</span>를 포함하는 리아프노프 후보 함수 <span class="math math-inline">V(e, \tilde{W})</span>를 정의하면:<br />
<span class="math math-display">
V(e, \tilde{W}) = \frac{1}{2} e^T P e + \frac{1}{2} \text{tr}(\tilde{W}^T \Gamma^{-1} \tilde{W})
</span><br />
이 함수를 시간 미분하여 <span class="math math-inline">\dot{V} \le 0</span>이 되도록 하는 업데이트 법칙은 다음과 같이 유도된다:<br />
<span class="math math-display">
\dot{\hat{W}} = \Gamma \phi(x) e^T P B
</span><br />
이 식은 신경망의 가중치가 트래킹 오차를 줄이는 방향으로 실시간 조정됨을 수학적으로 보장한다. 이로써 신경망이라는 ’블랙박스’를 제어 루프 안에 넣으면서도 전체 시스템의 안정성(Boundedness of signals)을 확보할 수 있게 되었다.49</p>
<h3>5.3  투영 연산자(Projection Operator)와 강건성 확보 전략</h3>
<p>NAC에서도 UAT의 근사 오차 <span class="math math-inline">\epsilon(x)</span>나 외부 외란은 여전히 존재한다. 이 작은 오차들이 적응 루프 내에서 누적되어 가중치 <span class="math math-inline">W</span>가 무한히 커지는 ‘파라미터 드리프트’ 현상을 막기 위해, NAC는 **투영 연산자(Projection Operator)**를 필수적으로 사용한다.52</p>
<p>투영 연산자는 학습되는 가중치 <span class="math math-inline">\hat{W}</span>가 미리 정의된 안전 영역(Convex Set) <span class="math math-inline">\Omega</span>를 벗어나지 않도록 강제한다. 가중치가 경계에 도달하고 업데이트 방향이 밖을 향하면, 그 성분을 투영하여 제거함으로써 가중치를 경계 내에 묶어둔다.<br />
<span class="math math-display">
\dot{\hat{W}} = \text{Proj}(\hat{W}, \dots)
</span><br />
이 기법은 딥 러닝에서의 ’Gradient Clipping’이나 ’Weight Decay’와 유사한 역할을 하지만, 제어 이론적으로 리아프노프 안정성을 깨뜨리지 않도록 정교하게 설계된다. 이는 학습 기반 제어가 실제 시스템에 적용될 때 폭주하지 않고 안전하게 작동하도록 하는 중요한 안전 장치(Safety Mechanism) 역할을 한다.54</p>
<h3>5.4  ’학습’이 아닌 ‘적응’: 신경 적응 제어의 국소적 한계</h3>
<p>NAC는 비선형성을 다루는 데 큰 진전을 이루었지만, 엄밀한 의미에서 ’학습(Learning)’이라기보다는 고도로 유연한 ’적응(Adaptation)’에 가깝다.</p>
<ol>
<li><strong>기억의 부재:</strong> NAC의 가중치 <span class="math math-inline">W</span>는 현재의 트래킹 오차 <span class="math math-inline">e(t)</span>에 반응하여 끊임없이 변한다. 로봇이 영역 A에서 학습한 내용을 가지고 영역 B로 갔다가 다시 A로 돌아오면, 영역 B에 적응하느라 <span class="math math-inline">W</span>가 변해버려 A에서의 기억은 사라진다. 이를 **“파국적 망각(Catastrophic Forgetting)”**이라 하며, NAC는 경험을 축적하여 지능을 높이는 것이 아니라 순간순간의 생존에 급급한 시스템이다.56</li>
<li><strong>국소적 근사:</strong> RBF 네트워크와 같은 기저 함수는 상태 공간의 국소적 영역(Local Receptive Field)에서만 활성화된다. 고차원 시스템에서는 상태 공간을 커버하기 위해 기하급수적으로 많은 뉴런이 필요하게 되며(Curse of Dimensionality), 이는 실시간 제어에 부담이 된다.8</li>
<li><strong>특징 추출의 부재:</strong> NAC는 여전히 입력으로 <span class="math math-inline">x</span> (위치, 속도 등)를 그대로 사용한다. 이미지나 촉각 센서와 같은 고차원 로우 데이터(Raw Data)로부터 유의미한 상태를 스스로 추출하는 능력은 없다.</li>
</ol>
<p>결국 NAC는 적응 제어에서 학습 제어로 넘어가는 징검다리 역할을 수행했으나, 진정한 의미의 ’지능형 제어’를 위해서는 데이터로부터 표현(Representation)을 배우고 기억을 축적하는 새로운 패러다임이 필요했다.</p>
<h2>6.  학습 기반 제어(Learning-Based Control)로의 필연적 전이</h2>
<p>적응 제어와 NAC가 직면한 “모델 구조의 가정”, “정보의 휘발성”, “고차원 데이터 처리의 한계“를 근본적으로 해결하기 위해, 현대 제어 시스템은 <strong>학습 기반 제어(Learning-Based Control)</strong>, 특히 딥 러닝(Deep Learning)과 강화 학습(Reinforcement Learning, RL)으로 급격히 이동하고 있다.</p>
<h3>6.1  함수 근사를 넘어선 표현 학습(Representation Learning)의 필요성</h3>
<p>전통적 제어와 NAC는 “입력 <span class="math math-inline">x</span>가 주어졌을 때 <span class="math math-inline">f(x)</span>를 근사“하는 **함수 근사(Function Approximation)**에 집중했다. 그러나 비정형 환경의 로봇(예: 자율 주행차, 가사 도우미 로봇)은 명확한 상태 변수 <span class="math math-inline">x</span>(위치, 속도) 대신 카메라 이미지, 라이다 포인트 클라우드, 촉각 센서 배열 등 수백만 차원의 로우 데이터(Raw Data)를 입력으로 받는다.</p>
<p>이러한 고차원 데이터에서 제어에 필요한 정보(장애물까지의 거리, 물체의 마찰 계수 등)를 사람이 일일이 수식으로 정의하여 추출하는 것은 불가능하다. 여기서 딥 러닝의 핵심 역량인 **표현 학습(Representation Learning)**이 등장한다.58</p>
<p>표현 학습은 데이터로부터 과업(Task) 수행에 가장 적합한 **잠재 상태(Latent State)**를 스스로 추출한다.</p>
<ul>
<li><strong>특징 추출의 자동화:</strong> CNN(Convolutional Neural Network)은 이미지에서 엣지, 텍스처, 물체 형태를 계층적으로 학습하여, 픽셀 덩어리를 ’장애물’이라는 의미론적 정보로 압축한다.</li>
<li><strong>구조의 발견:</strong> 오토인코더(Autoencoder)나 변분 오토인코더(VAE)는 고차원 데이터의 숨겨진 저차원 매니폴드(Manifold)를 찾아낸다. 이는 우리가 알지 못했던 시스템의 ’진짜 상태 변수’를 기계가 스스로 정의하는 과정이다.60</li>
</ul>
<p>제어 관점에서 표현 학습은 “알 수 없는 회귀 행렬 <span class="math math-inline">Y(q)</span>“를 사람이 손으로 유도하는 대신, 신경망이 데이터 공간의 기하학적 구조를 분석하여 <span class="math math-inline">Y(q)</span>에 해당하는 특징 맵(Feature Map)을 스스로 구축하는 것과 같다. 이는 제어의 대상을 ’물리적 파라미터’에서 ’정보적 표현’으로 확장시킨다.</p>
<h3>6.2  모델 없는(Model-Free) 강화 학습과 구조적 불확실성의 해결</h3>
<p>강화 학습(RL)은 모델의 형태를 가정하지 않고(Model-Free), 에이전트가 환경과 상호작용하며 얻은 보상(Reward)을 최대화하는 정책(Policy)을 학습함으로써 구조적 불확실성 문제에 대한 강력한 해법을 제시한다.42</p>
<p>아래 [표 6-1]은 적응 제어, 강건 제어, 그리고 강화 학습의 특성을 비교한 것이다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>적응 제어 (Adaptive Control)</strong></th><th><strong>강건 제어 (Robust Control)</strong></th><th><strong>강화 학습 (Reinforcement Learning)</strong></th></tr></thead><tbody>
<tr><td><strong>모델 의존성</strong></td><td>모델 구조(<span class="math math-inline">Y\theta</span>) 명확히 필요</td><td>불확실성의 상한(Bound) 필요</td><td>모델 불필요 (Black-box 환경 가능)</td></tr>
<tr><td><strong>목표</strong></td><td>트래킹 오차 <span class="math math-inline">e(t) \to 0</span> (즉각적)</td><td>최악의 상황에서도 안정성 유지</td><td>누적 보상 <span class="math math-inline">\sum R_t</span> 최대화 (장기적)</td></tr>
<tr><td><strong>불확실성 처리</strong></td><td>파라미터 추정으로 제거</td><td>고이득(High Gain)으로 억누름</td><td>탐색(Exploration)을 통해 적응</td></tr>
<tr><td><strong>비정형 환경</strong></td><td>취약함 (구조적 불확실성에 붕괴)</td><td>보수적임 (성능 저하)</td><td>강건함 (데이터로 극복)</td></tr>
<tr><td><strong>접촉/충격</strong></td><td>불안정성 위험 (이득 폭주)</td><td>채터링(Chattering) 발생 가능</td><td>샘플링 기반으로 자연스럽게 학습</td></tr>
</tbody></table>
<p><strong>강화 학습의 구조적 우위:</strong></p>
<ol>
<li><strong>접촉 및 하이브리드 동역학의 내재화:</strong> RL은 미분 방정식이 아닌 마르코프 결정 과정(MDP)을 기반으로 한다. 걷다가 넘어지거나 벽에 부딪히는 불연속적인 사건들도 MDP 내에서는 하나의 상태 전이(State Transition)일 뿐이다. RL 에이전트는 수많은 시행착오를 통해 접촉 시의 반발력을 예측하고 이를 이용하여 걷거나 물체를 조작하는 법을 배운다. 미분 불가능한 충격 모델을 다룰 필요가 없어진다.38</li>
<li><strong>탐색(Exploration)과 지속적 가진의 승화:</strong> 적응 제어에서 ’성가신 조건’이었던 PE는 RL에서 <strong>탐색과 활용(Exploration-Exploitation)의 트레이드오프</strong>라는 핵심 메커니즘으로 승화된다. RL 에이전트는 더 높은 보상을 얻기 위해 스스로 불확실한 영역을 탐색하며, 이 과정에서 자연스럽게 시스템에 대한 정보를 수집한다.63 “제어가 잘 될수록 학습이 멈춘다“는 적응 제어의 역설은, “더 잘 제어하기 위해 끊임없이 새로운 시도를 한다“는 RL의 철학으로 극복된다.</li>
<li><strong>도메인 무작위화(Domain Randomization):</strong> 시뮬레이션에서 마찰, 질량, 센서 노이즈 등 물리 파라미터를 무작위로 변동시키며 RL 에이전트를 학습시키는 기법이다. 이를 통해 에이전트는 특정 파라미터 값에 과적합(Overfitting)되지 않고, 다양한 구조적 불확실성을 포용하는 **강건한 정책(Robust Policy)**을 학습하게 된다. 이는 구조적 불확실성을 ’데이터의 다양성’으로 치환하여 해결하는 혁신적인 접근이다.61</li>
</ol>
<h3>6.3  딥 러닝과 제어 이론의 융합: 안정성과 유연성의 공존</h3>
<p>순수 딥 러닝/RL의 ‘블랙박스’ 성격과 예측 불가능성은 안전이 중요한 로봇 시스템에 적용하는 데 걸림돌이 된다. 이에 최근 연구는 적응 제어의 **‘수학적 안정성 보장’**과 딥 러닝의 **‘데이터 기반 유연성’**을 융합하는 방향으로 나아가고 있다.64</p>
<ol>
<li><strong>심층 모델 참조 적응 제어 (Deep MRAC):</strong> 기존 MRAC 구조에 딥 뉴럴 네트워크(DNN)를 추가하여 모델링 오차를 보상하되, 최외곽 루프는 리아프노프 기반의 적응 법칙으로 감싸서 전체 시스템의 안정성을 보장한다. 스펙트럼 정규화(Spectral Normalization) 등을 통해 DNN의 립시츠 상수(Lipschitz Constant)를 제한함으로써 제어 이론적 분석이 가능하게 만든다.44</li>
<li><strong>안전 강화 학습 (Safe RL):</strong> RL의 탐색 과정에서 제어 장벽 함수(Control Barrier Function, CBF)나 적응형 안전 필터(Adaptive Safety Filter)를 도입하여, 에이전트가 위험한 상태(예: 충돌, 전복)로 진입하는 것을 원천적으로 차단한다. 이는 학습의 자유도를 허용하되, 물리적 한계선은 넘지 못하게 하는 ‘가드레일’ 역할을 한다.67</li>
<li><strong>메타 적응 제어 (Meta-Adaptive Control):</strong> 메타 학습(Meta-Learning)을 이용해 다양한 환경에서 빠르게 적응할 수 있는 ’초기 파라미터’나 ‘적응 규칙’ 자체를 학습한다. 이는 적응 제어의 수렴 속도 문제를 해결하고, 새로운 환경에서도 몇 번의 데이터(Few-shot)만으로 최적의 제어 성능을 내도록 돕는다.69</li>
</ol>
<h3>6.4  데이터 효율성과 안전성: 새로운 도전 과제들</h3>
<p>학습 기반 제어로의 이동은 필연적이지만, 여전히 해결해야 할 난제들이 남아있다.</p>
<ul>
<li><strong>데이터 효율성(Sample Efficiency):</strong> 물리 로봇으로 수백만 번의 시행착오를 겪는 것은 불가능하다. 시뮬레이션에서 학습한 후 실제 환경으로 전이하는 <strong>Sim-to-Real</strong> 기술과, 적은 데이터로도 학습 가능한 모델 기반 RL(Model-Based RL)이 중요해진다.67</li>
<li><strong>해석 가능성(Interpretability):</strong> 딥 러닝 제어기가 왜 그런 행동을 했는지 설명할 수 없다면, 사고 발생 시 원인 규명이 어렵다. 설명 가능한 AI(XAI) 기술이 제어 분야에도 도입되어야 한다.</li>
</ul>
<h2>7.  결론: 적응형 기계에서 지능형 에이전트로</h2>
<p>제어 공학의 역사는 “시스템을 어떻게 기술할 것인가?“에 대한 대답의 변천사이다. 고전 제어는 이를 고정된 미분 방정식으로 기술했고, 적응 제어는 파라미터가 변하는 미분 방정식으로 기술했다. 이제 우리는 <strong>“시스템을 데이터와 상호작용의 기록으로 기술하는”</strong> 새로운 시대에 진입했다.</p>
<p>본 장에서 살펴본 바와 같이, 적응 제어에서 학습으로의 이동은 단순한 유행이 아니다. 그것은 <strong>LIP 가정의 물리적 붕괴</strong>, <strong>회귀 행렬의 정보론적 불능성</strong>, <strong>구조적 불확실성의 난공불락</strong>이라는 세 가지 근본적인 한계에 대한 공학적 응답이다.</p>
<ul>
<li>물리 세계의 복잡한 비선형성(마찰, 유체 역학)은 <strong>선형 파라미터 모델</strong>을 무력화시켰다.</li>
<li>비정형 환경의 미지 접촉과 상호작용은 <strong>회귀 행렬</strong>을 정의조차 할 수 없게 만들었다.</li>
<li>예측 불가능한 구조적 변화와 하이브리드 동역학은 <strong>결정론적 모델링</strong>의 한계를 드러냈다.</li>
</ul>
<p>이에 대한 해법으로 등장한 신경 적응 제어와 강화 학습은 제어기에게 **‘유연성(Plasticity)’**과 **‘표현력(Representation)’**을 부여했다. 이제 제어 시스템은 주어진 모델의 계수를 맞추는 수동적 **적응자(Adapter)**가 아니라, 환경과의 상호작용을 통해 스스로 모델을 구축하고(Representation Learning), 불확실성 속에서도 최적의 전략을 탐색하는(Exploration) 능동적 <strong>학습자(Learner)</strong>, 즉 **지능형 에이전트(Intelligent Agent)**로 진화하고 있다.</p>
<p>미래의 제어 기술은 적응 제어가 쌓아올린 **‘수학적 엄밀함과 안정성’**의 토대 위에, 학습 기반 제어의 **‘데이터 처리 능력과 적응력’**을 융합하는 **‘안전하고 강건한 지능형 제어(Safe and Robust Intelligent Control)’**의 형태로 완성될 것이다. 이것이 바로 로봇이 연구실을 걸어 나와 우리의 일상 속으로 들어오기 위해 반드시 건너야 할 기술적 루비콘 강이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Adaptive Control, <a href="https://uotechnology.edu.iq/dep-cse/lectures%202017/control/st4/Adaptive%20Control_5.pdf">https://uotechnology.edu.iq/dep-cse/lectures%202017/control/st4/Adaptive%20Control_5.pdf</a></li>
<li>DUBLIN CITY UNIVERSITY - DORAS | DCU Research Repository, https://doras.dcu.ie/19548/1/Mark_A_McDonnell_20130613152257.pdf</li>
<li>UNIT – I - Adaptive Control System – SIC1612 - Sathyabama, https://sist.sathyabama.ac.in/sist_coursematerial/uploads/SIC1612.pdf</li>
<li>Adaptive Control Systems in Robotics for Unstructured Environments - ResearchGate, https://www.researchgate.net/publication/391305218_Adaptive_Control_Systems_in_Robotics_for_Unstructured_Environments</li>
<li>The Application of Adaptive Control in Autonomous Robotics - Austra &amp; Lian, https://www.australiansciencejournals.com/ice/article/download/2805/3118</li>
<li>ADAPTIVE CONTROL - Stability, Convergence, and Robustness - University of Utah ECE, https://my.ece.utah.edu/~bodson/acscr/acscr.pdf</li>
<li>Dynamic Visual Servo Control of Robots: An Adaptive Image-Based Approach. - DTIC, https://apps.dtic.mil/sti/tr/pdf/ADA150057.pdf</li>
<li>Adaptive-Robust Controller for Smart Exoskeleton Robot - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC10818759/</li>
<li>Robust Robot Control Based on Simplified Dynamic Model - Purdue e-Pubs, https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1296&amp;context=ecetr</li>
<li>Dynamic Visual Servo Control of Robots, http://shelf2.library.cmu.edu/Tech/11868369.pdf</li>
<li>Model-Free Robust-Adaptive Controller Design and Identification for Robot Manipulators - mediaTUM, https://mediatum.ub.tum.de/doc/1471264/681307.pdf</li>
<li>Friction Problems in Servomechanisms: Modeling and Compensation Techniques - Tommy Gravdahl, https://tomgra.folk.ntnu.no/papers/friction.pdf</li>
<li>Practical Aspects of Model-Based Collision Detection - PMC - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC7805958/</li>
<li>Simple Robust Control Laws for Robot Part 11: Adaptive Case Manipulators,, https://ntrs.nasa.gov/api/citations/19890017192/downloads/19890017192.pdf</li>
<li>Dynamic model using identification for control - Robotics Stack Exchange, https://robotics.stackexchange.com/questions/15657/dynamic-model-using-identification-for-control</li>
<li>On Robust Control With Uncertainties in the Regressor Matrix and Parameter Vector, https://www.researchgate.net/publication/369766555_On_Robust_Control_with_Uncertainties_in_the_Regressor_Matrix_and_Parameter_Vector</li>
<li>Research on Identification of Minimum Parameter Set in Robot Dynamics and Excitation Strategy - MDPI, https://www.mdpi.com/1424-8220/25/18/5749</li>
<li>Parameter and contact force estimation of planar rigid-bodies undergoing frictional contact - DSpace@MIT, https://dspace.mit.edu/bitstream/handle/1721.1/125132/nf-ijrr17-RigidContact-final-prePrint.pdf?sequence=2&amp;isAllowed=y</li>
<li>A Geometric Method for Base Parameter Analysis in Robot Inertia Identification Based on Projective Geometric Algebra - arXiv, https://arxiv.org/html/2509.02071</li>
<li>Parameter and contact force estimation of planar rigid-bodies undergoing frictional contact - Research, https://groups.csail.mit.edu/robotics-center/public_papers/Fazeli17a.pdf</li>
<li>A review of dynamic parameters identification for manipulator control - Cobot, https://collaborative-robot.org/articles/1-5/pdf</li>
<li>Dynamic Identification of the Franka Emika Panda Robot With Retrieval of Feasible Parameters Using Penalty-Based Optimization - - MURAL - Maynooth University Research Archive Library, https://mural.maynoothuniversity.ie/id/eprint/15321/1/MC_dynamic.pdf</li>
<li>Physically-Consistent Parameter Identification of Robots in Contact - arXiv, https://arxiv.org/html/2409.09850v2</li>
<li>Physics-Constrained Data-Driven Dynamic Modeling of Underactuated Robotic Systems, https://ieeexplore.ieee.org/document/10753148/</li>
<li>MOB-Net: Limb-modularized Uncertainty Torque Learning of Humanoids for Sensorless External Torque Estimation - arXiv, https://arxiv.org/html/2402.11221v2</li>
<li>Design of a Fat-Based Adaptive Visual Servoing for Robots with Time Varying Uncertainties, https://www.tandfonline.com/doi/full/10.1080/15599612.2010.484524</li>
<li>Online Inertia Parameter Estimation for Unknown Objects Grasped by a Manipulator Towards Space Applications - arXiv, https://arxiv.org/html/2512.21886v1</li>
<li>Simultaneous Tactile Estimation and Control of Extrinsic Contact - IEEE Xplore, https://ieeexplore.ieee.org/iel7/10160211/10160212/10161158.pdf</li>
<li>Convergence Properties of Adaptive Systems and the Definition of Exponential Stability | SIAM Journal on Control and Optimizatio, https://liberzon.csl.illinois.edu/teaching/persistent-excitation.pdf</li>
<li>Connections Between Adaptive Control and Optimization in Machine Learning, http://maxim.ece.illinois.edu/teaching/fall20/final/Gaudio19.pdf</li>
<li>Adaptive Neural Optimal Backstepping Control for Heterogeneous Multiagent Systems With Noncooperative Target via Identifier–Critic–Actor Algorithm - IEEE Xplore, https://ieeexplore.ieee.org/document/11123502/</li>
<li>Relaxing Persistence of Excitation for Parameter Convergence in Adaptive Control: An Initial Excitation Based Approach - IIT Delhi, https://web.iitd.ac.in/~sbhasin/docs/final-thesis_Sayan.pdf</li>
<li>Simulation-Based Optimization: Implications of Complex Adaptive Systems and Deep Uncertainty - ODU Digital Commons, https://digitalcommons.odu.edu/cgi/viewcontent.cgi?article=1092&amp;context=vmasc_pubs</li>
<li>Simulation-Based Optimization: Implications of Complex Adaptive Systems and Deep Uncertainty - MDPI, https://www.mdpi.com/2078-2489/13/10/469</li>
<li>Quanitfying the Uncertainty in Climate Predictions - MIT, http://www.web.mit.edu/globalchange/www/MITJPSPGC_Rpt37.pdf</li>
<li>A machine learning approach to emulation and biophysical parameter estimation with the Community Land Model, version 5 - ASCMO, https://ascmo.copernicus.org/articles/6/223/2020/ascmo-6-223-2020.pdf</li>
<li>Modeling Uncertainty in Integrated Assessment of Climate Change: A Multi-Model Comparison - Yale University, https://resources.environment.yale.edu/gillingham/Gillinghametal_18_ModelingUncertainty.pdf</li>
<li>An Adaptive Framework for Changing-Contact Robot Manipulation - University of Birmingham, https://etheses.bham.ac.uk/id/eprint/12673/7/Sidhik2022PhD.pdf</li>
<li>Adaptive control for hybrid dynamical systems with user-defined rate of convergence - Dr. Andrea L’Afflitto Website, https://lafflitto.com/Documents/LAfflitto_Two_Layer_Hybrid_MRAC.pdf</li>
<li>Application of Adaptive and Switching Control for Contact Maintenance of a Robotic Vehicle-Manipulator System for Underwater Asset Inspection - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC8356049/</li>
<li>Solving Optimal Control Problems of Rigid-Body Dynamics with Collisions Using the Hybrid Minimum Principle - arXiv, https://arxiv.org/html/2205.08622v3</li>
<li>A Survey for Machine Learning-Based Control of Continuum Robots - Frontiers, https://www.frontiersin.org/journals/robotics-and-ai/articles/10.3389/frobt.2021.730330/full</li>
<li>A Survey for Machine Learning-Based Control of Continuum Robots - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC8527450/</li>
<li>A Neuroadaptive Architecture for Model Reference Control of Uncertain Dynamical Systems with Performance Guarantees | Request PDF - ResearchGate, https://www.researchgate.net/publication/331284911_A_Neuroadaptive_Architecture_for_Model_Reference_Control_of_Uncertain_Dynamical_Systems_with_Performance_Guarantees</li>
<li>Deep Neuro-Adaptive Sliding Mode Controller for Higher-Order Heterogeneous Nonlinear Multi-Agent Teams with Leader - arXiv, https://arxiv.org/html/2507.21667v1</li>
<li>Universal Approximation Theorem (UAT) - Emergent Mind, https://www.emergentmind.com/topics/universal-approximation-theorem-uat</li>
<li>Universal Approximation of Functions on Sets - Journal of Machine Learning Research, https://www.jmlr.org/papers/volume23/21-0730/21-0730.pdf</li>
<li>Missile Longitudinal Autopilot Design Using a New Model Following, https://arc.aiaa.org/doi/pdfplus/10.2514/6.2004-5327</li>
<li>Two-Tier Filter-based Experience Replay for Neuro-Adaptive Control with Inherent Robustness - IIT Delhi, https://web.iitd.ac.in/~sbhasin/docs/IE_based_Nero_Adaptive_Control.pdf</li>
<li>Modelling and Neuro-Adaptive Robust Control Algorithms for Solid Fuel Rockets - SciELO, https://www.scielo.br/j/jatm/a/DSTqCQRg6dWvmKwXvSZvRsC/?lang=en</li>
<li>Neural Network Adaptive Control for Nonlinear Nonnegative Dynamical Systems - Dr. Wassim M. Haddad, https://haddad.gatech.edu/journal/01402501.pdf</li>
<li>AIAA Guidance, Navigation, and Control Conference : Model, https://arc.aiaa.org/doi/pdf/10.2514/6.2017-1714?download=true</li>
<li>Projection Operator in Adaptive Systems - arXiv, https://arxiv.org/pdf/1112.4232</li>
<li>Adaptive Artificial Neural Network-Based Control Through Attracting-Manifold Design and Lipschitz Constant Projection1 - ASME Digital Collection, https://asmedigitalcollection.asme.org/lettersdynsys/article/3/2/021006/1166899/Adaptive-Artificial-Neural-Network-Based-Control</li>
<li>Lyapunov-Derived Control and Adaptive Update Laws for Inner and Outer Layer Weights of a Deep Neural Network, https://ncr.mae.ufl.edu/papers/csl22_2.pdf</li>
<li>Deep Model Reference Adaptive Control - arXiv, https://arxiv.org/pdf/1909.08602</li>
<li>Experience Replay Enhances Excitation Condition of Neural-Network Adaptive Control Learning - Aerospace Research Central, https://arc.aiaa.org/doi/10.2514/1.G008162</li>
<li>Learning Representation and Control in Markov Decision Processes: New Frontiers Contents, https://all.cs.umass.edu/pubs/2009/mahadevan_09.pdf</li>
<li>The Value-Improvement Path: Towards Better Representations for Reinforcement Learning, https://ojs.aaai.org/index.php/AAAI/article/view/16880/16687</li>
<li>Stackelberg Coupling of Online Representation Learning and Reinforcement Learning - arXiv, https://arxiv.org/html/2508.07452v2</li>
<li>Skill Transfer and Discovery for Sim-to-Real Learning: A Representation-Based Viewpoint - Scholars at Harvard, https://scholar.harvard.edu/sites/scholar.harvard.edu/files/haitongma/files/transfer_learning_online_report.pdf</li>
<li>Adaptive control vs reinforcement learning. : r/ControlTheory - Reddit, https://www.reddit.com/r/ControlTheory/comments/x6owe5/adaptive_control_vs_reinforcement_learning/</li>
<li>Reinforcement Learning from Probabilistic Forecasts for Safe Decision-Making via Conditional Value-at-Risk Planning - arXiv, https://arxiv.org/html/2510.08226v1</li>
<li>Deep Learning and Adaptive Control, 3rd Edition - Mathematics - MDPI, https://www.mdpi.com/journal/mathematics/special_issues/02ZX3E1FL6</li>
<li>Are there any fields of research or industry that combine both Control Theory and Machine learning? : r/ControlTheory - Reddit, https://www.reddit.com/r/ControlTheory/comments/1kkpkg1/are_there_any_fields_of_research_or_industry_that/</li>
<li>Asynchronous Deep Model Reference Adaptive Control - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v155/joshi21a/joshi21a.pdf</li>
<li>Adaptive Control and Intersections with Reinforcement Learning | Annual Reviews, https://www.annualreviews.org/content/journals/10.1146/annurev-control-062922-090153?TRACK=RSS</li>
<li>Performance Improvement of Active Suspension Constrained System via Neural Network Identification - IEEE Xplore, https://ieeexplore.ieee.org/document/9677461/</li>
<li>Adapt-to-learn policy transfer in reinforcement learning and deep model reference adaptive control | IDEALS, https://www.ideals.illinois.edu/items/116089</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>