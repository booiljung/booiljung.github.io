<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 2. 제어 이론의 역사와 소프트웨어 2.0</a> / <a href="index.html">2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</a> / <span>2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</span></nav>
                </div>
            </header>
            <article>
                <h1>2.2 모델링의 한계와 불확실성의 장벽 (The Modeling Bottleneck)</h1>
<h2>1.  서론: 결정론적 세계관의 붕괴와 모델링의 딜레마</h2>
<p>로봇 공학의 학문적 여정은 물리적 실재(Physical Reality)를 수학적 추상(Mathematical Abstraction)으로 포착하려는 끊임없는 시도였다. 고전 역학의 황금기 이래, 우리는 <span class="math math-inline">F=ma</span>라는 뉴턴의 제2법칙과 라그랑주 역학(Lagrangian Mechanics)의 우아한 형식주의 위에서 기계 시스템을 설계하고 제어해 왔다. 전통적인 제어 이론, 특히 모델 기반 제어(Model-Based Control)는 우리가 시스템의 운동 방정식(Equation of Motion)을 완벽하게 기술할 수 있다는 강력한 가정, 즉 ’결정론적 세계관’에 뿌리를 두고 있다. 공장 자동화의 초기 단계에서 이 가정은 유효했다. 바닥에 단단히 고정된 매니퓰레이터(Fixed-base Manipulator), 균질한 금속 소재, 통제된 조명과 환경 속에서 로봇은 수학적 모델이 예측한 대로 정밀하게 움직였다. 이때의 오차는 단지 센서의 잡음이나 가공 공차 수준에 머물렀다.</p>
<p>그러나 로봇이 정형화된 공장을 벗어나 비정형 환경(Unstructured Environment)으로 진출하면서, 그리고 강체(Rigid Body)라는 이상적인 물성에서 벗어나 부드럽고 변형 가능한 소재를 다루기 시작하면서, 우리는 ’모델링 병목현상(Modeling Bottleneck)’이라는 거대한 인식론적 장벽에 부딪혔다.1 모델링 병목현상이란 시스템의 복잡도가 증가함에 따라 이를 수학적으로 기술하는 데 드는 비용과 난이도가 기하급수적으로 상승하여, 더 이상 유효한 해석적 모델(Analytical Model)을 수립할 수 없거나, 수립된 모델이 실시간 제어에 사용하기에는 계산적으로 불가능해지는 임계점을 의미한다. 이는 단순한 기술적 난관이 아니라, 연속적이고 무한한 자유도를 가진 물리 세계를 유한한 차원의 기호와 수식으로 환원하려는 시도 자체가 갖는 본질적인 한계이다.</p>
<p>이 장에서는 모델 기반 접근법이 직면한 한계를 다각도로 해부한다. 우리는 로봇 제어의 근간을 흔드는 네 가지의 주요한 물리적, 정보적 장벽—접촉과 마찰의 불연속성, 변형체의 무한 차원성, 불확실성의 구조적 난해함, 그리고 시뮬레이션과 현실의 괴리—를 심층적으로 분석할 것이다. 통계학자 조지 박스(George Box)는 “모든 모델은 틀렸다, 하지만 일부는 유용하다(All models are wrong, but some are useful)“라고 말했다. 로봇 공학에서 이 명제는 더욱 가혹한 형태로 나타난다. “모든 모델은 틀렸으며, 틀린 모델에 기반한 제어는 로봇을 파괴하거나 위험하게 만든다.”</p>
<h3>1.1 계획(Planning)과 제어(Control)에서의 모델 의존성</h3>
<p>자동화된 계획(Automated Planning)은 지능형 시스템의 자율성을 위한 핵심 역량이다.2 계획은 시스템을 초기 상태에서 목표 상태로 전이시키는 행동 시퀀스(action-sequence)를 생성하는 과정으로 정의된다. 로봇 공학이나 산업 자동화와 같은 실제 도메인에서 이는 기호적(symbolic) 상태와 연속적(continuous) 상태가 혼재된 하이브리드 상태 공간(hybrid state space)에 대한 추론을 요구한다. 전통적인 접근법은 행동의 전제 조건(preconditions), 효과(effects), 인과 관계를 정의하는 도메인 모델(domain models)을 수동으로 명시하는 것에 의존해 왔다.2</p>
<p>하지만 복잡하고 동적인 환경에서 이러한 모델을 구축하는 것은 오류가 발생하기 쉽고 시간이 많이 소요되는 작업이다. 예를 들어, 다중 에이전트 강화학습(MARL) 분야에서도 전통적인 알고리즘은 모든 행동을 단일한 정책 네트워크로 통합하여 처리함으로써 행동 간의 의미적 이질성(semantic heterogeneity)을 무시하는 경향이 있다. 이는 복잡한 협업 시나리오에서 에이전트가 정교한 전략을 구사하는 것을 방해하는 ’행동 모델링 병목(Action Modeling Bottleneck)’으로 이어진다.3 모델이 현실의 복잡성을 담아내지 못할 때, 로봇은 단순한 작업조차 수행하지 못하고 교착 상태에 빠지거나, 물리 법칙을 위반하는 환상 속의 계획을 수립하게 된다.</p>
<h2>2.  물리적 상호작용의 심연: 접촉(Contact)과 마찰(Friction)의 난제</h2>
<p>모델링을 가장 어렵게 만드는, 그리고 로봇 공학자들이 가장 고통스러워하는 물리적 현상은 바로 ’접촉’과 ’마찰’이다. 로봇이 허공에서 팔을 휘두를 때는 코리올리 힘이나 원심력 같은 비선형 항들이 존재하더라도, 이는 매끄러운(smooth) 미분 가능한 함수(<span class="math math-inline">C^\infty</span> 또는 최소한 <span class="math math-inline">C^2</span>)로 표현된다. 그러나 로봇이 물체를 잡거나 지면을 딛는 순간, 시스템의 동역학은 근본적으로 변화한다. 힘과 속도 사이에 불연속적인 점프가 발생하며, 시스템은 하이브리드 오토마타(Hybrid Automata)의 성격을 띠게 된다.1</p>
<h3>2.1 제 1원리(First Principles) 모델링의 붕괴</h3>
<p>물리학의 제 1원리에 기반하여 마찰을 완벽하게 모델링하는 것은 현재의 과학 수준에서 사실상 불가능하다.4 우리가 흔히 사용하는 쿨롱 마찰 모델(Coulomb Friction Model)은 거시적인 근사일 뿐, 실제 접촉면에서 일어나는 복잡한 현상을 설명하지 못한다.</p>
<ul>
<li><strong>미시적 상호작용의 복잡성:</strong> 모든 표면은 미시적으로 볼 때 수많은 돌기(asperity)로 이루어져 있다. 두 표면이 접촉할 때, 이 돌기들이 서로 맞물리며 탄성 변형을 일으키다가, 가해지는 전단 압력(shear pressure)이 한계를 넘어서면 소성 변형과 함께 미끄러짐이 발생한다.5 이 과정은 습도, 온도, 표면의 오염 정도, 마모 상태, 윤활유의 유무 등 수많은 변수에 의해 좌우된다. 이러한 변수들을 모두 실시간으로 측정하고 수식에 반영하는 것은 불가능하다.</li>
<li><strong>히스테리시스와 경로 의존성:</strong> 케이블 구동 로봇이나 기어 시스템에서 발생하는 백래시(backlash)와 히스테리시스(hysteresis)는 시스템의 입출력 관계를 경로 의존적(path-dependent)으로 만든다.6 즉, 현재의 힘은 현재의 위치뿐만 아니라 과거의 변형 이력(history)에 의해 결정된다. 이를 상태 공간 모델(State-Space Model)로 완벽히 기술하려면 무한한 차원의 상태 변수가 필요하거나, 매우 복잡한 현상학적 모델을 도입해야 한다.</li>
<li><strong>정적/동적 마찰의 불확실성:</strong> 정지 마찰 토크(Static Friction Torque)의 추정치는 일반적으로 오프라인 테스트 사이클을 통해 얻어지며, 이는 로봇의 가용성을 떨어뜨릴 뿐만 아니라, 시간에 따라 변하는 마찰 특성을 반영하지 못한다.4 로봇이 동작하는 도중에 마찰 계수가 변하면, 모델 기반 제어기는 예측 오차를 줄이지 못하고 진동하거나 발산하게 된다.</li>
</ul>
<h3>2.2 접촉 동역학 시뮬레이션의 계산 복잡도: NP-Hard의 벽</h3>
<p>강체 동역학 시뮬레이션에서 다중 접촉(Multi-contact) 상황을 계산하는 문제는 수학적으로 **선형 상보성 문제(Linear Complementarity Problem, LCP)**로 정식화된다.7 LCP는 접촉 지점에서의 침투 불가 조건(non-penetration constraints)과 힘의 비음수 조건, 그리고 이 둘 중 하나는 반드시 0이어야 한다는 상보성 조건을 동시에 만족하는 해를 찾는 문제이다.</p>
<p>문제는 마찰이 포함된 LCP 모델이 일반적으로 <strong>NP-hard</strong> 문제에 해당한다는 점이다.8 Baraff의 연구에 따르면, 마찰이 존재하는 상황에서 충격력(impulsive force)을 계산하는 것은 지수적 시간(exponential time)을 요구할 가능성이 높다.9</p>
<ul>
<li><strong>조합론적 폭발:</strong> 접촉 점의 개수가 늘어날수록 각 접촉점에서 발생할 수 있는 상태(붙음(sticking), 미끄러짐(sliding), 떨어짐(separation))의 조합은 기하급수적으로 증가한다. 로봇 손이 물체를 잡는 덱스터러스 조작(Dexterous Manipulation)이나, 4족 보행 로봇이 자갈밭을 걷는 상황에서는 수십 개의 접촉점이 동시에 발생하므로, 이를 실시간 제어 주기(예: 1ms) 내에 정확히 계산하는 것은 슈퍼컴퓨터를 사용하더라도 어렵다.</li>
<li><strong>미분 불가능성과 최적화의 어려움:</strong> 접촉으로 인한 속도의 급격한 변화는 동역학 함수를 미분 불가능하게 만든다. 이는 경사 하강법(Gradient Descent) 기반의 딥러닝이나 최적 제어(Optimal Control) 알고리즘을 적용하는 데 치명적인 장애물이 된다.10 MuJoCo와 같은 최신 시뮬레이터들은 ‘부드러운 접촉(Soft Contact)’ 모델을 도입하여 접촉력을 평활화(smoothing)함으로써 그라디언트 계산을 가능하게 하지만, 이는 실제 세계의 ’딱딱한 접촉(Hard Contact)’과는 다른 물리적 거동을 유발하여 시뮬레이션과 현실 간의 격차(Reality Gap)를 심화시킨다.7</li>
</ul>
<h3>2.3 표 2.2.1: 접촉 모델링의 주요 난제 및 계산적 한계</h3>
<p>7</p>
<table><thead><tr><th><strong>모델링 요소</strong></th><th><strong>물리적 특성</strong></th><th><strong>수학적/계산적 난제</strong></th><th><strong>제어 시스템에 미치는 영향</strong></th></tr></thead><tbody>
<tr><td><strong>쿨롱 마찰</strong></td><td>거시적 근사, 정지/동 마찰의 불연속성</td><td>상태 의존적 스위칭, 미분 불가능점 존재</td><td>저속 구간에서의 stick-slip 진동, 정밀 위치 제어 실패</td></tr>
<tr><td><strong>다중 접촉 (LCP)</strong></td><td>침투 불가, 접촉력의 일방향성</td><td><strong>NP-Hard (마찰 존재 시)</strong>, 해의 유일성 보장 안 됨</td><td>실시간 시뮬레이션 불가능, 최적 제어 해의 수렴 실패</td></tr>
<tr><td><strong>변형/유연성</strong></td><td>미소 변형, 에너지 소산</td><td>비선형 스프링-댐퍼 모델, 파라미터 튜닝의 난해함</td><td>접촉 시 힘 오버슈트, 시스템의 강성(Stiffness) 저하</td></tr>
<tr><td><strong>충격 (Impact)</strong></td><td>순간적인 운동량 변화, 무한대 힘</td><td>디랙 델타 함수(Dirac Delta), 시간의 불연속적 점프</td><td>수치 적분(Integration)의 불안정성, 에너지 보존 법칙 위배 가능성</td></tr>
</tbody></table>
<h2>3.  강체를 넘어: 변형체(Deformable Objects)와 무한 차원의 저주</h2>
<p>강체(Rigid Body) 가정은 로봇 공학의 오랜 안식처였다. 강체는 단 6개의 자유도(위치 3, 자세 3)만으로 그 상태를 완벽하게 기술할 수 있기 때문이다. 그러나 로봇이 천, 케이블, 유체, 식품, 그리고 생체 조직과 같은 변형체(Deformable Object)를 다루거나, 소프트 로봇(Soft Robot)과 같이 몸체 자체가 유연한 경우, 모델링의 난이도는 유한 차원에서 무한 차원(Infinite Degrees of Freedom)으로 비약한다. 이를 유한한 차원의 모델로 근사하는 과정에서 필연적으로 정보의 손실과 치명적인 오차가 발생한다.11</p>
<h3>3.1 변형체 조작(DOM)의 모델링 딜레마</h3>
<p>변형체 조작(Deformable Object Manipulation, DOM)은 로봇 공학의 미개척지이자 가장 어려운 도전 과제 중 하나이다.13 변형체는 형상이 고정되어 있지 않고 외력에 의해 끊임없이 변화하므로, 이를 모델링하기 위해서는 연속체 역학(Continuum Mechanics)을 도입해야 한다.</p>
<h4>3.1.1  해석적 모델(Analytical Models)과 실시간성의 상충</h4>
<p>변형체를 모델링하는 대표적인 방법으로는 유한요소법(Finite Element Method, FEM)과 질량-스프링 모델(Mass-Spring Model)이 있다.6</p>
<ul>
<li><strong>유한요소법(FEM):</strong> FEM은 물체를 수천, 수만 개의 사면체나 육면체 요소로 분할하여 편미분 방정식(PDE)을 푼다. 이는 물리적 정확도가 가장 높고 비선형 구성 방정식(constitutive laws)을 반영할 수 있다는 장점이 있다. 그러나 계산 비용이 극도로 높아 실시간 제어 루프(Real-time Control Loop) 내에서 사용하는 것이 거의 불가능하다.6 오프라인 시뮬레이션이나 구조 해석에는 적합할지 몰라도, 1ms마다 제어 입력을 갱신해야 하는 로봇에게 FEM은 너무 느린 도구이다.</li>
<li><strong>질량-스프링 모델(Mass-Spring Model):</strong> 계산 속도를 높이기 위해 물체를 질량 점(mass point)들과 이들을 연결하는 스프링(spring)으로 단순화한 모델이다. 이는 빠른 시뮬레이션을 가능하게 하지만, 물리적 충실도(fidelity)가 떨어진다. 특히 비등방성(anisotropy)을 가진 재료나 복잡한 점탄성(viscoelasticity) 거동을 정확히 표현하기 어렵고, 모델의 파라미터(스프링 상수 등)를 실제 물체의 물성과 매칭시키는 것이 직관적이지 않다.6</li>
</ul>
<h4>3.1.2  형상 표현과 상태 추정의 모호성</h4>
<p>강체는 무게중심의 위치와 자세만 알면 되지만, 변형체는 ’상태(State)’를 정의하는 것조차 어렵다.</p>
<ul>
<li><strong>입자 기반 시스템(Particle Systems):</strong> 유체나 모래와 같은 대상을 모델링할 때 사용되지만, 표면이 명시적으로 정의되지 않아 변형 후 원래 형상으로 복원되는 과정을 추적하거나, 로봇이 물체를 쥐었을 때의 접촉 면적을 계산하기 어렵다.17</li>
<li><strong>센싱의 한계:</strong> Soft-bubble과 같은 유연한 촉각 센서는 접촉 시 멤브레인 전체가 변형된다. 이때 공기 압력과 막의 탄성이 복합적으로 작용하여, 깊이 이미지(depth image)로부터 순수한 접촉 형상만을 분리해내는 역문제(Inverse Problem)는 매우 까다롭다. 이는 기존의 ICP(Iterative Closest Point)와 같은 강체 기반 형상 매칭 알고리즘을 무력화시킨다.18</li>
</ul>
<h3>3.2 소프트 로봇의 비선형 동역학</h3>
<p>소프트 로봇은 관절(joint)이 없는 연속적인 몸체를 가지므로, 기존의 링크-관절 기반 기구학(Rigid-link Kinematics)을 적용할 수 없다. 예를 들어, 트위스트 코일 구동기(Twisted-and-Coiled Actuators, TCA)와 같은 인공 근육이 내장된 소프트 로봇은 구동기와 본체 사이의 복잡한 커플링 효과, 대변형(large deformation)에 따른 기하학적 비선형성으로 인해 모델링이 극도로 어렵다.12</p>
<ul>
<li><strong>연속체 기구학의 한계:</strong> 일정한 곡률(Constant Curvature) 가정 등 단순화된 모델을 사용하기도 하지만, 이는 외부 하중이 작용하거나 로봇이 장애물과 접촉하여 복잡하게 휘어질 때는 유효하지 않다.</li>
<li><strong>미분 가능한 시뮬레이션의 도전:</strong> 최근에는 경사 기반 학습(Gradient-based Learning)을 가능하게 하기 위해 미분 가능한 물리 엔진(Differentiable Physics Engine)이 개발되고 있다.19 그러나 마찰, 자가 충돌(Self-collision), 히스테리시스를 포함한 소프트 바디의 전체 동역학을 미분 가능한 형태로 구현하는 것은 여전히 난제이며, 시뮬레이션의 안정성을 확보하기도 어렵다.</li>
</ul>
<p>결국, 변형체를 다루는 로봇 제어에서 모델 기반 접근법은 ’정확도’와 ’속도’라는 양립 불가능한 두 마리 토끼를 쫓다가 실패하는 경우가 많다. 모델이 너무 단순하면 제어가 부정확해져 물체를 망가뜨리고(fragile object damage), 모델이 너무 정교하면 계산 시간이 길어져 실시간 대응에 실패한다.6</p>
<h2>4.  불확실성의 분류학: 매개변수와 구조적 오차</h2>
<p>모델링 병목현상을 심화시키는 또 다른 차원은 ’불확실성(Uncertainty)’이다. 아무리 정교한 수식과 슈퍼컴퓨터를 동원하여 모델을 세우더라도, 실제 물리 시스템과 수학적 모델 사이에는 항상 좁혀지지 않는 간극(Gap)이 존재한다. 제어 이론에서는 이 간극을 크게 두 가지 범주, 즉 **매개변수적 불확실성(Parametric Uncertainty)**과 **구조적 불확실성(Structural Uncertainty)**으로 분류한다.20</p>
<h3>4.1 매개변수적 불확실성 (Parametric Uncertainty)</h3>
<p>매개변수적 불확실성은 모델의 수식 형태(Structure)는 물리 현상을 올바르게 기술하고 있으나, 그 안에 포함된 계수(Parameter)들의 정확한 값을 알 수 없는 경우를 말한다.20</p>
<ul>
<li><strong>예시:</strong> 로봇 팔의 링크 질량(<span class="math math-inline">m</span>), 관성 모멘트(<span class="math math-inline">I</span>), 마찰 계수(<span class="math math-inline">\mu</span>), 모터의 토크 상수(<span class="math math-inline">K_t</span>) 등.</li>
<li><strong>원인:</strong> 제조 공차, 측정 장비의 오차, 또는 로봇이 물체를 잡았을 때 발생하는 부하(Payload)의 변화 등이 원인이 된다.</li>
<li><strong>영향:</strong> 매개변수 오차는 제어기의 추종 성능(Tracking Performance)을 저하시킨다. 예를 들어, 로봇 팔의 질량을 실제보다 가볍게 추정했다면, 제어기는 필요한 토크보다 적은 토크를 출력하여 목표 지점에 도달하지 못하는 오차(Undershoot)를 발생시킨다. 반대로 무겁게 추정했다면 과도한 토크로 인해 목표 지점을 지나치거나 진동(Overshoot)하게 된다.</li>
<li><strong>대응 및 한계:</strong> 적응 제어(Adaptive Control)나 강건 제어(Robust Control)는 이러한 매개변수 오차를 실시간으로 추정하거나 오차의 범위를 고려하여 제어 입력을 조절한다. 그러나 급격한 파라미터 변화나 센서 노이즈가 심한 환경에서는 적응 법칙(Adaptive Law)이 발산할 위험이 있다.24</li>
</ul>
<h3>4.2 구조적 불확실성 (Structural Uncertainty)</h3>
<p>구조적 불확실성은 모델의 수식 형태 자체가 실제 물리 현상을 표현하기에 부족하거나 틀린 경우를 의미한다. 이는 ’모델 불일치(Model Mismatch)’라고도 불리며, 모델링 병목의 가장 치명적이고 해결하기 어려운 형태이다.20</p>
<ul>
<li><strong>예시:</strong></li>
<li><strong>유연성 무시:</strong> 로봇 팔을 강체로 모델링했으나, 실제로는 고속 기동 시 링크가 휘어지며 탄성 진동(Flexibility)을 일으키는 경우.</li>
<li><strong>동역학 차수 축소:</strong> 모터의 전기적 동역학(Inductance 등)을 무시하고 단순히 토크 소스로 모델링했으나, 실제로는 고주파 대역에서 위상 지연이 발생하는 경우.</li>
<li><strong>미모델링된 외란:</strong> 바람, 돌풍, 지면의 꺼짐, 케이블의 장력 등 모델 방정식에 아예 포함되지 않은 외부 요인들.22</li>
<li><strong>영향:</strong> 구조적 불확실성은 제어기의 안정성(Stability)을 근본적으로 위협한다. 모델이 예측하지 못한 주파수 대역의 공진(Resonance)이 발생하거나(Spillover effect), 제어 입력이 시스템을 오히려 불안정하게 만들어 발산시킬 수 있다.</li>
<li><strong>탐지의 어려움:</strong> 매개변수 튜닝으로는 구조적 결함을 해결할 수 없다. <span class="math math-inline">F=ma</span> 식에서 질량 <span class="math math-inline">m</span>을 아무리 조절해도, 공기 저항이나 탄성력을 표현할 수는 없는 것과 같다. 이를 해결하기 위해 여러 모델의 앙상블(Multi-model Ensemble)을 사용하거나, 구조적 오차 항(Residual Term) 자체를 데이터로 학습하는 접근이 필요하지만, 이는 시스템의 복잡도와 계산 비용을 크게 증가시킨다.21</li>
</ul>
<h2>5.  사례 연구 1: 보행 로봇과 비정형 지형의 리얼리티 갭</h2>
<p>모델링 병목현상이 가장 극명하게 드러나는 현장 중 하나는 4족 보행 로봇이 산악 지형이나 재난 현장과 같은 비정형 지형(Unstructured Terrain)을 이동할 때이다. 여기서 우리는 ’시각적 인식의 모델링’과 ’지면 상호작용의 모델링’이라는 이중의 난관에 봉착한다.</p>
<h3>5.1 지형 인식의 불확실성과 모델 불일치</h3>
<p>전통적인 보행 제어는 라이다(LiDAR)나 깊이 카메라(Depth Camera)를 통해 주변 환경의 고도 지도(Elevation Map)를 작성하고, 이를 바탕으로 발을 디딜 안전한 위치를 계획(Planning)한다. 그러나 실제 환경에서 이 과정은 수많은 오류를 내포한다.</p>
<ul>
<li><strong>센서 노이즈와 오차:</strong> 로봇의 격렬한 움직임은 카메라의 모션 블러(Motion Blur)를 유발하며, 센서 자체의 노이즈와 위치 추정(Odometry)의 드리프트(Drift)가 결합되어 고도 지도는 항상 왜곡되어 있다.26 이 왜곡된 지도를 ’참(Ground Truth)’이라고 믿고 계획된 발걸음은 헛디딤이나 충돌로 이어진다.</li>
<li><strong>물성의 비가시성:</strong> 카메라는 지형의 기하학적 형상만 볼 수 있을 뿐, 그 지면이 단단한 바위인지, 푹 꺼지는 눈밭인지, 미끄러운 얼음인지 알 수 없다. 기존의 모델 기반 제어(MPC)는 지면을 마찰 계수가 일정한 단단한 평면으로 단순화하여 모델링하므로, 실제 지면의 복잡한 물성(Soft soil, Slippery mud)과 상호작용할 때 심각한 모델 불일치를 겪는다.25 이는 로봇이 균형을 잃고 넘어지는 주된 원인이다.</li>
</ul>
<h3>5.2 “Learning to Walk”: 모델을 버리고 감각을 믿다</h3>
<p>ETH Zurich의 ANYmal 로봇 연구팀은 이러한 모델링의 한계를 극복하기 위해 과감한 접근을 시도했다. 그들은 복잡하고 부정확한 지형 모델을 구축하는 대신, 강화학습(Reinforcement Learning)을 통해 로봇이 자신의 신체 감각(Proprioception)만으로 걷는 법을 배우게 했다.28</p>
<ul>
<li><strong>Blind Locomotion의 성공:</strong> 연구팀은 시각 정보를 배제하고, 관절의 각도, 속도, 발바닥의 접촉력 등 내부 센서 정보만을 입력으로 사용하는 정책(Policy)을 훈련시켰다. 놀랍게도 이 ‘눈먼(Blind)’ 정책이 시각 정보를 사용하여 지형을 모델링하려 했던 기존의 제어기보다 험지에서 훨씬 더 강건한 성능을 보였다.</li>
<li><strong>대규모 병렬 시뮬레이션:</strong> 이를 가능하게 한 것은 수천 개의 로봇을 시뮬레이션 상에서 동시에 훈련시키는 대규모 병렬 학습 기술이었다.28 그들은 시뮬레이션에서 지형의 마찰, 강성, 높낮이를 무작위로 변동시키며 로봇을 극한의 불확실성에 노출시켰다.</li>
<li><strong>시사점:</strong> 이 사례는 “불완전한 외부 모델“보다 “최적화된 내부 반응 루프“가 불확실한 환경에서 더 유리할 수 있음을 시사한다. 모델링 병목은 외부 세계를 완벽하게 재현하려는 욕심에서 비롯된 것일지도 모른다.</li>
</ul>
<h2>6.  사례 연구 2: 덱스터러스 조작과 OpenAI의 루빅스 큐브</h2>
<p>모델링 병목과 리얼리티 갭의 문제는 로봇 손(Robotic Hand)을 이용한 조작 작업에서 더욱 심화된다. OpenAI가 수행한 로봇 손으로 루빅스 큐브를 맞추는 연구는 이 문제를 정면으로 다룬 기념비적인 사례이다.31</p>
<h3>6.1 시뮬레이션 불가능성(Unsimulatable Physics)</h3>
<p>루빅스 큐브와 Shadow Hand(인간과 유사한 로봇 손)의 상호작용은 모델링의 악몽과도 같다.</p>
<ul>
<li><strong>복합적 동역학:</strong> 24개의 관절을 가진 로봇 손, 큐브의 회전축, 손가락 끝의 고무 패드, 큐브 표면의 마찰, 큐브 조각들 간의 유격(Play) 등이 복합적으로 작용한다. 큐브가 손 안에서 미끄러지거나 걸리는 현상은 매우 미세한 힘의 차이에 의해 결정되며, 이를 정확히 측정하거나 모델링하는 것은 불가능에 가깝다.32</li>
<li><strong>Sim-to-Real Gap:</strong> 초기에는 시뮬레이션에서 완벽하게 큐브를 돌리던 인공지능이 실제 로봇에 이식되자마자 큐브를 떨어뜨리거나 짓이겨 버렸다. 시뮬레이터(MuJoCo)가 현실의 마찰과 접촉을 충분히 정교하게 모사하지 못했기 때문이다.</li>
</ul>
<h3>6.2 도메인 무작위화(Domain Randomization)와 ADR</h3>
<p>OpenAI 팀은 “정확한 모델“을 만드는 것이 불가능함을 인정하고, 대신 **자동 도메인 무작위화(Automatic Domain Randomization, ADR)**라는 기법을 도입했다.32</p>
<ul>
<li><strong>원리:</strong> 시뮬레이션 환경의 물리 파라미터(마찰 계수, 큐브의 크기, 로봇 팔의 질량, 중력 가속도, 시각적 조명 등)를 매 에피소드마다 무작위로 변화시킨다. 처음에는 작은 범위에서 시작하여, 에이전트의 성능이 좋아질수록 무작위화의 범위를 자동으로 확장한다.</li>
<li><strong>효과:</strong> 인공지능은 특정 물리 모델 하나에 최적화(Overfitting)되는 대신, 다양한 물리 법칙이 지배하는 수만 개의 평행 우주(Parallel Universes)에서 생존하는 법을 배운다. 그 결과, 학습된 정책은 현실 세계라는 “또 하나의 변종 시뮬레이션“에서도 강건하게 동작할 수 있었다.</li>
<li><strong>한계:</strong> 이 방식은 모델링 병목을 우회하는 강력한 방법이지만, 막대한 계산 자원(수만 개의 CPU/GPU 코어)과 시간(수개월의 시뮬레이션 시간)을 요구한다. 이는 “모델링 비용“을 “계산 비용“으로 치환한 것에 불과할 수 있다는 비판도 존재한다.33</li>
</ul>
<h2>7.  모델링 병목의 극복: 데이터와 하이브리드 접근</h2>
<p>2.2절 전체를 통해 우리는 순수한 모델 기반 접근법(First-principles Modeling)이 비정형 환경과 복잡한 시스템 앞에서 한계에 봉착했음을 확인했다. 그러나 이것이 모델의 폐기를 의미하지는 않는다. 로봇 공학자들은 이제 분석적 모델의 명료함과 데이터 기반 학습의 유연성을 결합한 **하이브리드 접근(Hybrid Approach)**을 통해 병목을 돌파하려 하고 있다.27</p>
<h3>7.1  시스템 식별(System Identification)의 진화: Offline to Online</h3>
<p>전통적인 시스템 식별은 로봇을 멈추고 데이터를 수집하여 오프라인에서 모델 파라미터를 찾는 방식이었다. 이제는 로봇이 임무를 수행하는 도중에 실시간으로 모델을 수정하는 기술이 주목받고 있다.35</p>
<ul>
<li><strong>UP-OSI (Universal Policy with Online System Identification):</strong> 구글 딥마인드 등의 연구에서 제안된 이 구조는 두 개의 네트워크로 구성된다. 하나는 범용 정책(UP)이고, 다른 하나는 최근의 관측 데이터(History)를 바탕으로 현재 환경의 동역학 파라미터(마찰, 질량 등)를 실시간으로 추정하는 식별기(OSI)이다.35 OSI가 “지금 바닥이 미끄럽다“는 정보를 주면, UP는 즉시 보행 전략을 수정한다.</li>
<li><strong>암시적 모터 적응 (Implicit Motor Adaptation):</strong> 명시적으로 물리 파라미터(예: 마찰계수 0.5)를 추정하는 것은 여전히 어렵다. 따라서 최신 연구들은 파라미터를 직접 추정하는 대신, 과거의 감각 정보 시계열 데이터를 잠재 벡터(Latent Vector)로 압축하여 정책 네트워크에 주입한다. 이를 통해 로봇은 환경의 변화를 “느낌“으로 감지하고 암묵적으로 적응한다.37</li>
</ul>
<h3>7.2  모델 기반 강화학습 (Model-Based RL)과 미분 가능한 물리학</h3>
<p>데이터 효율성(Data Efficiency)을 높이기 위해, 로봇이 스스로 동역학 모델을 학습하고 이를 활용하여 계획을 수립하는 접근법이다.38</p>
<ul>
<li><strong>Normalizing Flows:</strong> 가우시안 분포의 한계를 넘어 복잡한 확률 분포를 모델링함으로써, 불확실성이 높은 환경에서의 동역학을 더 정교하게 표현한다.</li>
<li><strong>Differentiable Physics:</strong> 시뮬레이터 자체를 미분 가능하게 구현하여, 제어기(정책)와 시뮬레이터(모델)를 하나의 파이프라인으로 연결하고 역전파(Backpropagation)를 통해 전체를 최적화한다.19 이는 모델의 파라미터 튜닝과 제어 정책의 학습을 동시에 수행할 수 있게 해 준다.</li>
</ul>
<h3>7.3  MPC와 RL의 전략적 결합</h3>
<p>모델 예측 제어(MPC)의 안정성과 강화학습(RL)의 적응력을 결합하는 연구가 활발하다.34</p>
<ul>
<li><strong>계층적 제어 (Hierarchical Control):</strong> 상위 레벨에서는 RL 에이전트가 환경을 인식하고 대략적인 목표(Goal)나 참조 경로(Reference Trajectory)를 생성한다. 하위 레벨에서는 MPC가 정밀한 동역학 모델을 바탕으로 이 경로를 추종하며 안정성을 확보하는 토크를 계산한다.</li>
<li><strong>잔차 학습 (Residual Learning):</strong> 기본적인 동작은 MPC로 제어하고, MPC가 해결하지 못하는 모델 불일치(Model Mismatch)나 외란 성분만을 RL이 학습하여 보상 토크(Residual Torque)를 더해주는 방식이다.27 이는 학습의 부담을 줄이면서도 시스템의 성능을 비약적으로 높일 수 있다.</li>
</ul>
<h2>8.  결론: 불확실성과의 공존</h2>
<p>“모델링 병목“은 로봇 공학이 해결해야 할 가장 본질적이고 끈질긴 난제이다. 우리는 물리 세계의 무한한 복잡성을 유한한 수식으로 가두려는 시도가 필연적으로 오차를 낳는다는 것을 인정해야 한다. 접촉의 불연속성, 변형체의 난해함, 환경의 불확실성은 기존의 결정론적 제어 프레임워크를 무력화시킨다.</p>
<p>그러나 이러한 한계의 인식은 패배가 아닌 새로운 패러다임의 시작이다. 로봇 공학은 이제 “완벽한 모델“이라는 허상을 쫓는 대신, **“불완전한 모델을 가지고도 강건하게 생존할 수 있는 지능”**을 만드는 데 집중하고 있다. 데이터 기반 학습, 실시간 적응, 그리고 시뮬레이션과 현실을 오가는 하이브리드 아키텍처는 모델링 병목을 부수는 망치가 아니라, 그 병목을 우회하여 더 넓은 세상으로 나아가는 열쇠가 되고 있다.</p>
<h3>8.1 표 2.2.2: 모델 기반 제어와 학습 기반 제어의 비교 및 병목 극복 전략</h3>
<p>14</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>모델 기반 제어 (Model-Based, e.g., MPC)</strong></th><th><strong>학습 기반 제어 (Learning-Based, e.g., RL)</strong></th><th><strong>하이브리드 접근 (Hybrid / Adaptive)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 원리</strong></td><td>물리 법칙(제 1원리)에 기반한 미래 상태 예측 및 최적화</td><td>데이터와 경험을 통한 시행착오(Trial &amp; Error) 및 정책 최적화</td><td>물리학적 모델(Prior)과 데이터 학습(Experience)의 결합</td></tr>
<tr><td><strong>모델링 병목</strong></td><td><strong>치명적 (Critical).</strong> 모델 오차에 매우 민감하며, 복잡한 동역학(접촉, 변형) 표현 불가 시 성능 급락</td><td><strong>회피 가능 (Avoidable).</strong> 명시적 모델 없이도 학습 가능하나, 학습 환경(Sim)의 정확도에 의존</td><td>모델이 설명 가능한 부분은 MPC가, 설명 불가능한 잔차(Residual)는 RL이 담당</td></tr>
<tr><td><strong>장점</strong></td><td>이론적 안정성 보증, 해석 가능성(White-box), 데이터 효율성 높음(Zero-shot 가능)</td><td>비선형성, 고차원 문제, 미지의 환경에 대한 탁월한 적응력</td><td>강건성(Robustness)과 적응성(Adaptability)의 균형, Sim-to-Real 격차 최소화</td></tr>
<tr><td><strong>단점</strong></td><td>계산 비용 높음(실시간성 저하), 부정확한 모델에서의 취약성</td><td>샘플 효율성 낮음(수백만 번의 시도 필요), 설명 불가능성(Black-box), 학습 불안정성</td><td>설계 복잡성 증가, 하이퍼파라미터 튜닝의 어려움</td></tr>
<tr><td><strong>주요 적용</strong></td><td>보행 로봇의 전신 제어, 강체 매니퓰레이터의 궤적 계획</td><td>덱스터러스 조작(Rubik’s Cube), 비정형 지형의 고속 보행</td><td>고성능 동적 보행, 적응형 비행 제어, 힘/위치 복합 제어</td></tr>
</tbody></table>
<h2>9. 참고 자료</h2>
<ol>
<li>Fighting the Modeling Bottleneck – Learning Models for Production Plants - ResearchGate, https://www.researchgate.net/publication/257365002_Fighting_the_Modeling_Bottleneck_-_Learning_Models_for_Production_Plants</li>
<li>Learning Sound and Complete Preconditions in Complex Real-World Domains - CEUR-WS.org, https://ceur-ws.org/Vol-4103/paper6.pdf</li>
<li>DDWCN: A Dual-Stream Dynamic Strategy Modeling Network for Multi-Agent Elastic Collaboration - MDPI, https://www.mdpi.com/2076-3417/15/16/9164</li>
<li>On Modeling and Diagnosis of Friction and Wear in Industrial Robots - DiVA portal, https://www.diva-portal.org/smash/get/diva2:464280/FULLTEXT02.pdf</li>
<li>Chapter 8. Models of Friction - BME MOGI, https://www.mogi.bme.hu/TAMOP/robot_applications/ch07.html</li>
<li>Deformable and Fragile Object Manipulation: A Review and …, https://pmc.ncbi.nlm.nih.gov/articles/PMC12430959/</li>
<li>Computation - MuJoCo Documentation, https://mujoco.readthedocs.io/en/2.3.6/computation.html</li>
<li>Fast Contact Force Computation for Nonpenetrating Rigid Bodies, https://www.cs.cmu.edu/~baraff/papers/sig94.pdf</li>
<li>Coping with Friction for Non-penetrating Rigid Body Simulation - Stanford Computer Graphics Laboratory, https://graphics.stanford.edu/courses/cs448-01-spring/papers/baraff.pdf</li>
<li>Hard Contacts with Soft Gradients: Refining Differentiable Simulators for Learning and Control - arXiv, https://arxiv.org/html/2506.14186v1</li>
<li>Interactive Robotic Manipulation of Elastic Objects, https://crl.ethz.ch/papers/iros18_bender.pdf</li>
<li>Modeling and Simulation of Soft Robots Driven by Embedded Artificial Muscles: an Example using Twisted-and-Coiled Actuators - IEEE Xplore, https://ieeexplore.ieee.org/document/9867442/</li>
<li>Challenges and Outlook in Robotic Manipulation of Deformable Objects, https://arm.robotics.umich.edu/download.php?p=103</li>
<li>Deformable and Fragile Object Manipulation: A Review and Prospects - MDPI, https://www.mdpi.com/1424-8220/25/17/5430</li>
<li>An Overview of Material Study in Robotic Hand using Finite Element Approach - IEEE Xplore, https://ieeexplore.ieee.org/document/10117855/</li>
<li>Survey of Finite Element Method-Based Real-Time Simulations - MDPI, https://www.mdpi.com/2076-3417/9/14/2775</li>
<li>Modeling of Deformable Objects for Robotic Manipulation: A Tutorial and Review - Frontiers, https://www.frontiersin.org/journals/robotics-and-ai/articles/10.3389/frobt.2020.00082/full</li>
<li>Fast model-based contact patch and pose estimation for highly deformable dense-geometry tactile sensors - DSpace@MIT, https://dspace.mit.edu/bitstream/handle/1721.1/135205/08936859.pdf?sequence=2&amp;isAllowed=y</li>
<li>Differentiable Simulation of Soft Multi-body Systems, https://proceedings.neurips.cc/paper/2021/file/8e296a067a37563370ded05f5a3bf3ec-Paper.pdf</li>
<li>Quantifying Uncertainty in the Modelling Process; Future Extreme Flood Event Projections Across the UK - MDPI, https://www.mdpi.com/2076-3263/11/1/33</li>
<li>Understanding Uncertainty in Self-adaptive Systems - KU Leuven, https://people.cs.kuleuven.be/~danny.weyns/papers/2020ACSOSa.pdf</li>
<li>Particle MPC for Uncertain and Learning-Based Control - arXiv, https://arxiv.org/pdf/2104.02213</li>
<li>adaptiveandrobustfollowingof3d, https://yadda.icm.edu.pl/baztech/element/bwmeta1.element.baztech-0cd84211-4918-4564-b01e-e05ee1117867/c/mazur_adaptive.pdf</li>
<li>RL2AC: Reinforcement Learning-based Rapid Online Adaptive Control for Legged Robot Robust Locomotion, https://www.roboticsproceedings.org/rss20/p060.pdf</li>
<li>Reinforcement Learning for Robust and Adaptive Quadruped Locomotion by Ashutosh Gupta A PROJECT submitted to Oregon State Univer, https://ir.library.oregonstate.edu/downloads/bv73c850z</li>
<li>Legged Locomotion in Challenging Terrains using Egocentric Vision - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v205/agarwal23a/agarwal23a.pdf</li>
<li>RLOC: Terrain-Aware Legged Locomotion Using Reinforcement Learning and Optimal Control | Request PDF - ResearchGate, https://www.researchgate.net/publication/360834470_RLOC_Terrain-Aware_Legged_Locomotion_Using_Reinforcement_Learning_and_Optimal_Control</li>
<li>Learning to Walk in Minutes Using Massively Parallel Deep Reinforcement Learning - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v164/rudin22a/rudin22a.pdf</li>
<li>Learning to Walk in Minutes Using Massively Parallel Deep Reinforcement Learning | Request PDF - ResearchGate, https://www.researchgate.net/publication/354858981_Learning_to_Walk_in_Minutes_Using_Massively_Parallel_Deep_Reinforcement_Learning</li>
<li>Learning to Walk in Minutes Using Massively Parallel Deep Reinforcement Learning - ar5iv, https://ar5iv.labs.arxiv.org/html/2109.11978</li>
<li>SOLVING RUBIK’S CUBE WITH A ROBOT HAND - Matthias Plappert, https://matthiasplappert.com/publications/2019_OpenAI_Rubiks-Cube.pdf</li>
<li>Solving Rubik’s Cube with a robot hand | OpenAI, https://openai.com/index/solving-rubiks-cube/</li>
<li>A Machine Learning Approach That Beats Large Rubik’s Cubes The CayleyPy Project, https://arxiv.org/html/2502.13266v1</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning-Based Control for Legged Robot Locomotion in MuJoCo Simulation - IEEE Xplore, https://ieeexplore.ieee.org/iel8/6287639/10820123/11048516.pdf</li>
<li>Preparing for the Unknown: Learning a Universal Policy with Online System Identification - Robotics, https://www.roboticsproceedings.org/rss13/p48.pdf</li>
<li>Robust Contact-rich Manipulation through Implicit Motor Adaptation - Idiap Publications, https://publications.idiap.ch/attachments/papers/2025/Xue_IJRR_2025.pdf</li>
<li>Robust Contact-rich Manipulation through Implicit Motor Adaptation - arXiv, https://arxiv.org/html/2412.11829v1</li>
<li>Improving Exploration in Soft-Actor-Critic with Normalizing Flows Policies - arXiv, https://arxiv.org/pdf/1906.02771</li>
<li>Benchmarking Model Predictive Control and Reinforcement Learning Based Control for Legged Robot Locomotion in MuJoCo Simulation - arXiv, https://arxiv.org/html/2501.16590v1</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>