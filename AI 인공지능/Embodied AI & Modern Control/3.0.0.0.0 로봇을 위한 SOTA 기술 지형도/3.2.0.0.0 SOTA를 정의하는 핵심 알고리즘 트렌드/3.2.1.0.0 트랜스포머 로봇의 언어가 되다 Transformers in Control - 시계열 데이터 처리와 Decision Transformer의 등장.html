<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.2.1 트랜스포머, 로봇의 언어가 되다 (Transformers in Control): 시계열 데이터 처리와 Decision Transformer의 등장</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.2.1 트랜스포머, 로봇의 언어가 되다 (Transformers in Control): 시계열 데이터 처리와 Decision Transformer의 등장</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 3. 로봇을 위한 SOTA 기술 지형도</a> / <a href="index.html">3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</a> / <span>3.2.1 트랜스포머, 로봇의 언어가 되다 (Transformers in Control): 시계열 데이터 처리와 Decision Transformer의 등장</span></nav>
                </div>
            </header>
            <article>
                <h1>3.2.1 트랜스포머, 로봇의 언어가 되다 (Transformers in Control): 시계열 데이터 처리와 Decision Transformer의 등장</h1>
<h2>1.  서론: 제어 이론의 언어적 전환 (The Linguistic Turn in Control)</h2>
<p>인공지능과 로봇 공학의 융합 과정에서 발생한 가장 급진적인 변화는 ’행동(Action)’을 ’언어(Language)’와 동일한 위상에 놓고 해석하려는 시도이다. 2010년대 중반까지 로봇 제어, 특히 강화학습(Reinforcement Learning, RL)은 마르코프 결정 과정(Markov Decision Process, MDP)이라는 견고한 수학적 토대 위에서 발전해 왔다. 이 패러다임에서 로봇의 학습은 상태(State), 행동(Action), 보상(Reward), 그리고 다음 상태(Next State)로 이어지는 순환 고리 안에서, 미래 보상의 총합을 최대화하는 정책(Policy) 함수를 찾아내는 최적화 문제로 정의되었다. 벨만 방정식(Bellman Equation)에 기반한 동적 프로그래밍(Dynamic Programming)과 시간차 학습(Temporal Difference, TD)은 이 문제를 해결하는 황금률(Golden Rule)이었다.</p>
<p>그러나 자연어 처리(NLP) 분야에서 등장한 트랜스포머(Transformer) 아키텍처는 이러한 전통적 접근법에 근본적인 의문을 제기했다. 언어가 단어(Token)들의 순차적 배열을 통해 문맥(Context)과 의미(Meaning)를 형성하듯, 로봇의 움직임 또한 상태와 행동이라는 토큰의 연속적인 배열을 통해 목적(Goal)과 궤적(Trajectory)을 형성한다는 관점이 대두된 것이다. 이는 로봇 제어 문제를 가치 함수(Value Function)를 근사(Approximation)하는 복잡한 수치 최적화 문제에서, 주어진 문맥 안에서 가장 그럴듯한 다음 토큰을 예측하는 ‘시퀀스 모델링(Sequence Modeling)’ 문제로 치환하는 패러다임의 전환을 의미한다.1</p>
<p>본 장에서는 트랜스포머 아키텍처가 로봇 제어의 새로운 언어로 자리 잡게 된 배경과 이론적 필연성을 심층적으로 분석한다. 특히, 오프라인 강화학습(Offline RL)의 고질적인 난제였던 ’죽음의 삼중주(Deadly Triad)’를 시퀀스 모델링이 어떻게 우회하는지, 그리고 이 분야의 기념비적인 연구인 **Decision Transformer (DT)**와 **Trajectory Transformer (TT)**의 작동 원리를 해부한다. 나아가 확률적 환경(Stochastic Environment)에서 발생하는 시퀀스 모델링의 한계와 이를 극복하기 위한 <strong>Q-Transformer</strong>, 그리고 일반 범용 로봇(Generalist Robot)을 향한 <strong>Gato</strong>와 같은 최신 연구 동향까지 포괄적으로 다룬다.</p>
<h2>2.  강화학습의 시퀀스 모델링화: 이론적 배경과 필연성</h2>
<h3>2.1  오프라인 강화학습과 죽음의 삼중주 (The Deadly Triad)</h3>
<p>로봇이 현실 세계에서 데이터를 수집하며 학습하는 온라인 강화학습(Online RL)은 막대한 비용과 안전 문제를 수반한다. 따라서 미리 수집된 데이터셋만을 이용하여 정책을 학습하는 오프라인 강화학습(Offline RL)은 로봇 공학의 필수적인 연구 주제이다. 그러나 오프라인 RL은 전통적으로 ’죽음의 삼중주(Deadly Triad)’라 불리는 세 가지 요소가 결합될 때 발생하는 학습 불안정성에 시달려 왔다.3</p>
<ol>
<li><strong>함수 근사(Function Approximation):</strong> 신경망과 같은 비선형 함수 근사기를 사용할 때 발생한다.</li>
<li><strong>부트스트래핑(Bootstrapping):</strong> 실제 완료된 보상이 아닌, 추정된 가치 함수를 기반으로 현재 값을 업데이트하는 방식이다 (예: Q-Learning).</li>
<li><strong>오프 폴리시(Off-Policy) 학습:</strong> 데이터를 수집한 행동 정책(Behavior Policy)과 현재 학습 중인 목표 정책(Target Policy)의 분포가 다를 때 발생한다.</li>
</ol>
<p>이 세 가지가 결합되면 가치 함수가 발산하거나 과대평가(Overestimation)되는 현상이 발생한다. CQL(Conservative Q-Learning)이나 IQL(Implicit Q-Learning)과 같은 알고리즘들은 가치 추정에 제약을 가하거나 보수적인 하한선을 두는 방식으로 이를 해결하려 했으나, 이는 여전히 가치 함수의 재귀적 연산에 의존한다는 근본적인 한계를 가진다. 특히 장기적인 수평선(Long-horizon)을 가진 작업에서 초기 행동에 대한 신용 할당(Credit Assignment)이 희석되는 문제는 기존 TD 기반 방법론의 아킬레스건이었다.5</p>
<h3>2.2  패러다임의 전환: 지도 학습으로서의 RL (RvS)</h3>
<p>’시퀀스 모델링으로서의 강화학습(Reinforcement Learning via Sequence Modeling, RvS)’은 이 문제를 완전히 다른 각도에서 접근한다. 에이전트가 최적의 가치 함수를 찾아 헤매는 대신, “높은 보상을 얻었던 궤적의 패턴을 그대로 생성해내라“는 조건부 생성(Conditional Generation) 문제로 재정의하는 것이다.</p>
<p>이 접근법에서 궤적 <span class="math math-inline">\tau</span>는 상태, 행동, 보상의 결합 확률 분포 <span class="math math-inline">P(\tau)</span>로 모델링된다. 최적의 행동 <span class="math math-inline">a_t</span>를 결정하는 것은 정책 <span class="math math-inline">\pi(a_t|s_t)</span>를 최적화하는 것이 아니라, 원하는 목표 보상 <span class="math math-inline">\hat{R}</span>이 주어졌을 때 조건부 확률 <span class="math math-inline">P(a_t | s_t, s_{t-1}, a_{t-1}, \dots, \hat{R})</span>을 최대화하는 토큰을 샘플링하는 과정이 된다.1 이는 TD 학습이 가지는 부트스트래핑의 불안정성을 제거하고, 안정적인 지도 학습(Supervised Learning) 프레임워크 안에서 RL 문제를 해결할 수 있게 해준다.</p>
<h3>2.3  트랜스포머의 역할: 장기 의존성과 어텐션</h3>
<p>RNN이나 LSTM과 같은 순환 신경망(Recurrent Neural Network)이 아닌 트랜스포머가 이 변화의 중심에 선 이유는 ‘셀프 어텐션(Self-Attention)’ 메커니즘 때문이다. 순환 신경망은 정보를 순차적으로 압축하여 은닉 상태(Hidden State)에 저장하므로, 시퀀스가 길어질수록 초기의 정보가 소실되는 ‘기울기 소실(Vanishing Gradient)’ 문제에서 자유롭지 못하다. 반면, 트랜스포머는 전체 시퀀스를 한 번에 입력받아 모든 토큰 간의 관계를 병렬적으로 계산한다.</p>
<p>로봇 제어에서 이는 혁명적인 변화를 가져왔다. 로봇이 현재 수행해야 할 행동이 수천 스텝 전의 특정 상태나 초기 조건에 결정적인 영향을 받는 경우(예: 미로 찾기, 도구 가져오기 등), 트랜스포머는 과거의 그 시점에 직접적으로(Directly) ’어텐션(Attention)’을 가하여 정보를 참조할 수 있다. 이는 로봇 제어의 난제인 ‘장기 신용 할당(Long-term Credit Assignment)’ 문제를 획기적으로 개선하며, 복잡한 인과관계를 가진 작업에서도 에이전트가 일관성 있는 행동을 유지하게 만든다.3</p>
<h2>3.  Decision Transformer (DT): 보상 기반 조건부 생성의 미학</h2>
<p>2021년 Chen 등에 의해 제안된 **Decision Transformer(DT)**는 RL 문제를 자기회귀(Autoregressive) 모델링으로 단순화시킨 가장 대표적인 연구이다.1 DT는 OpenAI의 GPT 아키텍처를 거의 수정 없이 차용하여, 로봇 제어 데이터셋인 D4RL 등에서 기존의 특화된 오프라인 RL 알고리즘들을 능가하거나 대등한 성능을 보여주었다.</p>
<h3>3.1  궤적의 재구성과 입력 표현 (Trajectory Representation)</h3>
<p>DT의 가장 직관적이면서도 강력한 아이디어는 궤적을 표현하는 방식에 있다. 일반적인 강화학습이 <span class="math math-inline">(s, a, r, s&#39;)</span>의 튜플을 다루는 것과 달리, DT는 궤적을 인과관계가 명확한 토큰들의 시퀀스로 재배열한다. 특히, ‘보상(Reward)’ 대신 <strong>Return-to-go (RTG)</strong> 라는 개념을 도입하여 모델의 조건을 형성한다.</p>
<h4>3.1.1 Return-to-go (RTG)</h4>
<p>RTG <span class="math math-inline">\hat{R}_t</span>는 현재 시점 <span class="math math-inline">t</span>에서 에피소드가 끝날 때까지 얻을 수 있는 미래 보상의 총합으로 정의된다.<br />
<span class="math math-display">
\hat{R}_t = \sum_{t&#39;=t}^{T} r_{t&#39;}
</span><br />
이는 모델에게 “앞으로 이만큼의 보상을 얻으려면 어떤 행동을 해야 하는가?“라는 명시적인 목표(Target)를 제시하는 역할을 한다.4</p>
<h4>3.1.2 토큰화 및 임베딩 구조 (Tokenization &amp; Embeddings)</h4>
<p>DT의 입력 시퀀스는 다음과 같은 형태를 가진다.<br />
<span class="math math-display">
\tau = (\hat{R}_1, s_1, a_1, \hat{R}_2, s_2, a_2, \dots, \hat{R}_T, s_T, a_T)
</span><br />
각 요소는 모달리티별로 특화된 임베딩 레이어를 거쳐 트랜스포머가 처리할 수 있는 동일한 차원의 벡터로 변환된다.</p>
<ol>
<li><strong>상태(State):</strong> 고차원 이미지 입력의 경우 합성곱 신경망(CNN) 인코더를 통과하여 특징 벡터로 압축되고, 저차원 센서 데이터(예: 관절 각도, 속도)의 경우 선형 레이어(Linear Layer)를 통해 임베딩된다.</li>
<li><strong>행동(Action):</strong> 연속 공간(Continuous Space)이든 이산 공간(Discrete Space)이든 각각의 임베딩을 거친다.</li>
<li><strong>RTG:</strong> 스칼라 값인 RTG 역시 선형 변환을 통해 벡터화된다.</li>
<li><strong>타임스텝(Timestep):</strong> 절대적인 시간 정보를 제공하기 위해 위치 인코딩(Positional Encoding)이 각 토큰에 더해진다.</li>
</ol>
<p>이때, 하나의 타임스텝 <span class="math math-inline">t</span>는 3개의 토큰 <span class="math math-inline">(\hat{R}_t, s_t, a_t)</span>으로 구성되며, 트랜스포머는 이들을 순차적으로 처리한다.1</p>
<h3>3.2  아키텍처와 학습 메커니즘 (Architecture &amp; Training)</h3>
<p>DT는 GPT 시리즈와 유사한 ‘디코더 전용(Decoder-only)’ 트랜스포머를 사용한다. 핵심은 **인과적 마스킹(Causal Masking)**이 적용된 멀티 헤드 셀프 어텐션(Multi-head Self-Attention)이다. 이는 현재 시점 <span class="math math-inline">t</span>의 예측을 수행할 때, 미래 시점 <span class="math math-inline">t+1</span> 이후의 정보가 유출(Leakage)되는 것을 원천적으로 차단한다. 로봇 제어에서 인과성은 물리 법칙과 직결되므로, 미래의 정보를 참조하여 현재를 결정하는 것은 불가능하기 때문이다.10</p>
<h4>3.2.1 학습 목표함수 (Loss Function)</h4>
<p>DT의 학습은 다음 토큰, 특히 행동 <span class="math math-inline">a_t</span>를 정확하게 예측하는 지도 학습으로 귀결된다.</p>
<ul>
<li>
<p>연속 행동 공간: 실제 행동값과 예측값 사이의 평균 제곱 오차(Mean Squared Error, MSE)를 최소화한다.<br />
<span class="math math-display">
\mathcal{L}_{\text{MSE}} = \frac{1}{K} \sum_{t=1}^{K} \| a_t - \pi_\theta(\tau_{t}) \|^2
</span></p>
</li>
<li>
<p><strong>이산 행동 공간:</strong> 행동 클래스에 대한 교차 엔트로피(Cross-Entropy) 손실을 사용한다.4</p>
</li>
</ul>
<p>흥미로운 점은 DT 아키텍처가 이론적으로는 상태나 RTG도 예측할 수 있지만, 실험적으로는 행동 <span class="math math-inline">a_t</span>만을 예측 대상으로 삼을 때 가장 효율적이었다는 것이다. 이는 모델의 용량을 행동 생성이라는 핵심 작업에 집중시키는 효과를 낳는다.</p>
<h3>3.3  추론 과정과 제어 루프 (Inference &amp; Control Loop)</h3>
<p>학습된 DT를 실제 로봇 제어에 사용하는 과정은 LLM이 프롬프트를 받아 텍스트를 생성하는 과정과 매우 유사하다.</p>
<ol>
<li><strong>초기화 (Initialization):</strong> 사용자는 달성하고자 하는 목표 보상 <span class="math math-inline">\hat{R}*{target}</span>과 환경의 초기 상태 <span class="math math-inline">s_1</span>을 모델에 입력한다. 이때 <span class="math math-inline">\hat{R}*{target}</span>은 일반적으로 학습 데이터셋 내의 전문가 궤적이 달성한 최고 점수 혹은 그 이상의 값으로 설정된다.</li>
<li><strong>행동 생성 (Generation):</strong> 모델은 입력된 컨텍스트 <span class="math math-inline">(\hat{R}_1, s_1)</span>를 바탕으로 다음 행동 <span class="math math-inline">a_1</span>을 예측한다.</li>
<li><strong>실행 및 관측 (Execution):</strong> 예측된 <span class="math math-inline">a_1</span>을 로봇이 실행하고, 환경은 새로운 상태 <span class="math math-inline">s_2</span>와 보상 <span class="math math-inline">r_1</span>을 반환한다.</li>
<li><strong>목표 업데이트 (Target Update):</strong> 다음 스텝의 목표 보상은 현재 얻은 보상만큼 차감된다. 즉, <span class="math math-inline">\hat{R}_2 = \hat{R}_1 - r_1</span>. 이는 “남은 보상“을 지속적으로 추적하며 목표를 달성하도록 유도한다.</li>
<li><strong>컨텍스트 확장 (Append):</strong> <span class="math math-inline">(\hat{R}_2, s_2)</span>를 기존 시퀀스에 추가하고, 문맥 윈도우(Context Window) 크기를 유지하며 과정을 반복한다.</li>
</ol>
<h3>3.4  DT의 결정적 강점: 궤적 스티칭 (Trajectory Stitching)</h3>
<p>Decision Transformer가 기존 오프라인 RL 방법론과 구별되는 가장 강력한 특징은 ‘스티칭(Stitching)’ 능력이다. 이는 최적의 경로 전체가 포함되지 않은 데이터셋에서도 최적의 경로를 합성해내는 능력을 의미한다.</p>
<p>예를 들어, A지점에서 B지점까지 가는 경로와 B지점에서 C지점까지 가는 경로만이 데이터셋에 존재하고, A에서 C로 가는 직접적인 경로는 없다고 가정하자. 기존의 모방 학습(Behavior Cloning)은 A에서 C로 가는 방법을 배우지 못한다. 그러나 DT는 높은 RTG를 조건으로 주었을 때, A-&gt;B의 시퀀스와 B-&gt;C의 시퀀스 정보를 결합(Stitch)하여 A-&gt;C라는 최적 궤적을 생성해낼 수 있다.</p>
<p>연구 결과에 따르면, DT는 무작위 탐색(Random Walk) 데이터만으로 학습했을 때도, 테스트 시에 높은 목표 보상을 제시하면 데이터셋 내의 어떤 단일 궤적보다 더 효율적인 경로를 생성해내는 창발적(Emergent) 능력을 보여주었다.1 이는 별도의 가치 함수 전파(Value Propagation) 없이 시퀀스 모델의 패턴 매칭 능력만으로 달성된 것으로, 제어 이론에서 트랜스포머의 잠재력을 증명한 결정적 사례이다.</p>
<h2>4.  Trajectory Transformer (TT): 고정밀 분포 모델링과 빔 서치</h2>
<p>Decision Transformer가 조건부 기댓값을 학습하는 데 집중했다면, Janner et al. (2021)이 제안한 **Trajectory Transformer (TT)**는 궤적 전체의 결합 확률 분포(Joint Probability Distribution)를 정밀하게 모델링하는 데 초점을 맞춘다.12 이는 모델 프리(Model-free) 접근인 DT와 달리, 환경의 동역학(Dynamics)까지 학습하는 모델 기반(Model-based) 접근에 가깝다.</p>
<h3>4.1  연속 공간의 이산화 (Discretization)</h3>
<p>TT의 가장 큰 기술적 특징은 연속적인 상태와 행동 공간을 미세하게 이산화(Discretization)하여 처리한다는 점이다. 기존의 딥러닝 기반 동역학 모델들이 주로 가우시안 분포(Gaussian Distribution)를 가정하고 평균과 분산을 회귀(Regression)했던 것과 달리, TT는 각 차원을 독립적인 토큰으로 나누어 분류(Classification) 문제로 접근한다.</p>
<h4>4.1.1 분위수 이산화 (Quantile Discretization)</h4>
<p>단순히 값을 균등하게 나누는 균등 이산화(Uniform Discretization)는 데이터가 희소한 영역에서 비효율적이다. TT는 이를 개선하기 위해 분위수 이산화를 채택했다. 이는 학습 데이터의 경험적 분포(Empirical Distribution)에 기반하여, 각 빈(Bin)에 동일한 양의 데이터가 할당되도록 구간을 나누는 방식이다.</p>
<p>이 방식은 로봇 데이터가 가지는 복잡한 다봉(Multi-modal) 분포를 매우 정밀하게 표현할 수 있게 해준다. 예를 들어, 로봇이 갈림길 앞에 섰을 때 가우시안 모델은 두 경로의 평균인 ’벽’을 향해 가라고 예측할 위험이 있지만, 이산화된 TT는 왼쪽 또는 오른쪽이라는 두 가지 뚜렷한 모드(Mode)를 정확히 확률적으로 표현할 수 있다.13</p>
<h4>4.1.2 시퀀스 구조의 확장</h4>
<p><span class="math math-inline">N</span>차원 상태와 <span class="math math-inline">M</span>차원 행동을 가진 시스템에서, TT는 한 타임스텝의 데이터를 <span class="math math-inline">N+M+1</span>개의 토큰(보상 포함)으로 분해한다. 따라서 시퀀스의 길이는 DT에 비해 <span class="math math-inline">N+M+1</span>배 늘어나게 된다 (<span class="math math-inline">T \times (N+M+1)</span>). 이는 연산량을 증가시키지만, 상태 전이의 미세한 변화를 포착하는 데 탁월한 성능을 발휘한다.13</p>
<h3>4.2  빔 서치(Beam Search)를 이용한 계획 (Planning)</h3>
<p>TT는 추론 단계에서 단순한 샘플링 대신 <strong>빔 서치(Beam Search)</strong> 알고리즘을 사용하여 최적의 궤적을 능동적으로 계획(Planning)한다. 이는 NLP에서 고품질 번역문을 생성하기 위해 사용되는 기법을 제어 영역으로 가져온 것이다.13</p>
<ol>
<li><strong>후보 확장:</strong> 현재 상태에서 가능한 미래의 토큰들을 여러 개(Beam Width 만큼) 동시에 생성하며 확장한다.</li>
<li><strong>가지치기 (Pruning):</strong> 각 단계에서 누적 확률(Log-likelihood)이나 누적 보상 기대치가 낮은 궤적들은 버리고, 상위 <span class="math math-inline">K</span>개의 유망한 궤적만을 유지한다.</li>
<li><strong>실행 (Receding Horizon Control):</strong> 빔 서치를 통해 미래 수십 스텝까지의 최적 궤적을 생성한 후, 그중 첫 번째 행동 <span class="math math-inline">a_t</span>만을 실제로 실행한다. 그리고 다음 스텝에서 다시 계획을 수립하는 MPC(Model Predictive Control) 방식을 따른다.</li>
</ol>
<p>이러한 방식은 DT와 같은 ‘탐욕적(Greedy)’ 생성 모델보다 훨씬 더 물리적으로 정합성 높고 장기적으로 안정적인 제어를 가능하게 한다. 특히 HalfCheetah, Hopper와 같은 MuJoCo 벤치마크에서 TT는 기존의 모델 기반 RL 방법론(PETS 등)을 압도하는 성능을 기록했다.12</p>
<h3>4.3  DT와 TT의 비교 분석</h3>
<p>아래 표는 두 모델의 핵심적인 차이를 요약한 것이다.</p>
<p><strong>표 3.2.1-1: Decision Transformer와 Trajectory Transformer 비교</strong></p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>Decision Transformer (DT)</strong></th><th><strong>Trajectory Transformer (TT)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 접근</strong></td><td>조건부 정책 학습 (Model-free / RvS)</td><td>궤적 분포 모델링 (Model-based)</td></tr>
<tr><td><strong>입력 토큰</strong></td><td><span class="math math-inline">(R, S, A)</span> 단위 임베딩</td><td>차원별 이산화된 토큰 시퀀스</td></tr>
<tr><td><strong>출력</strong></td><td>다음 행동 (결정론적/확률적)</td><td>상태, 행동, 보상의 전체 분포</td></tr>
<tr><td><strong>추론 방식</strong></td><td>자기회귀 생성 (Greedy/Sampling)</td><td>빔 서치 (Beam Search)를 통한 계획</td></tr>
<tr><td><strong>장점</strong></td><td>단순성, 빠른 추론 속도, 스티칭 능력</td><td>높은 정밀도, 물리적 정합성, 장기 예측</td></tr>
<tr><td><strong>단점</strong></td><td>확률적 환경에서 성능 저하 (Luck)</td><td>긴 시퀀스 길이로 인한 연산 비용, 느린 속도</td></tr>
<tr><td><strong>데이터 표현</strong></td><td>연속값의 직접 임베딩 (Linear)</td><td>분위수 기반 이산화 (Quantile Discretization)</td></tr>
</tbody></table>
<p>데이터 출처: 13 내용을 종합하여 재구성.</p>
<h2>5.  확률적 환경의 딜레마: 운(Luck)과 실력의 혼동</h2>
<h3>5.1  RvS의 내재적 한계 (The Stochasticity Trap)</h3>
<p>Decision Transformer와 같은 RvS(Reinforcement Learning via Sequence Modeling) 방법론은 결정론적(Deterministic) 환경에서는 강력하지만, 확률적(Stochastic) 환경에서는 치명적인 약점을 노출한다. 이를 학계에서는 ‘확률적 환경의 함정’ 또는 ‘도박꾼의 파산(Gambler’s Ruin)’ 문제와 유사하게 본다.18</p>
<p>DT는 기본적으로 “높은 보상을 받은 궤적의 행동을 모방“하도록 학습된다. 그러나 확률적 환경에서는 다음과 같은 상황이 발생할 수 있다:</p>
<ol>
<li><strong>운 좋은 바보:</strong> 에이전트가 최적의 행동을 하지 않았음에도(Bad Action), 환경의 무작위적 호의로 인해 높은 보상을 받는 경우.</li>
<li><strong>불운한 천재:</strong> 에이전트가 최적의 행동을 했음에도(Optimal Action), 불운으로 인해 낮은 보상을 받는 경우.</li>
</ol>
<p>DT는 결과론적인 보상값 <span class="math math-inline">\hat{R}</span>에만 조건부화되므로, 인과관계를 구분하지 못하고 “운 좋게 성공한 나쁜 행동“을 학습할 위험이 크다. 예를 들어, ‘2048’ 게임이나 ’Connect Four’와 같이 무작위성이 강하게 개입되는 환경에서, DT에게 높은 목표 보상을 설정해주어도 실제 성능은 그에 미치지 못하는 현상이 관찰된다. 이는 모델이 환경의 확률적 전이(Stochastic Transition)와 에이전트의 행동이 결과에 미치는 통제 가능한 영향을 분리해내지 못하기 때문이다.19</p>
<h3>5.2  극복을 위한 시도: ESPER</h3>
<p>이 문제를 해결하기 위해 제안된 **ESPER (Environment-Stochasticity-Independent Representations)**는 클러스터링 기반의 접근을 취한다. ESPER는 궤적을 결과(Return)에 따라 직접 매핑하는 대신, 적대적 학습(Adversarial Learning)을 통해 환경의 무작위성과 무관한 클러스터를 학습하고 이를 조건부 토큰으로 사용한다. 즉, 단순히 “높은 점수“가 아니라 “실력으로 얻은 높은 점수“를 구별해내는 메커니즘을 트랜스포머에 통합함으로써, 확률적 환경에서도 강건한(Robust) 성능을 확보하려는 시도이다.20</p>
<h2>6.  차세대 아키텍처: Q-Transformer와 가치 함수의 귀환</h2>
<p>Decision Transformer가 가치 함수를 버리고 시퀀스 모델링의 길을 택했다면, <strong>Q-Transformer</strong>는 트랜스포머의 강력한 표현력을 이용해 가치 함수(Q-Function)를 더 잘 학습하려는 정반합(Synthesis)의 시도이다.22 Google DeepMind에서 제안한 이 모델은 오프라인 RL의 이론적 토대인 벨만 백업(Bellman Backup)을 트랜스포머 아키텍처 위에서 구현했다.</p>
<h3>6.1  이산화된 자동회귀 Q-함수</h3>
<p>Q-Transformer는 행동 공간을 각 차원별로 이산화하고, 이를 트랜스포머의 토큰으로 처리한다는 점에서 TT와 유사하다. 그러나 결정적인 차이는 학습 목표에 있다. Q-Transformer는 몬테카를로 리턴(Monte Carlo Return)뿐만 아니라, TD 학습을 위한 벨만 오차(Bellman Error)를 최소화하도록 학습된다.<br />
<span class="math math-display">
Q(s, a) \leftarrow r + \gamma \max_{a&#39;} Q(s&#39;, a&#39;)
</span><br />
이때, 모든 행동 차원에 대해 개별적으로 최대화(Maximization)를 수행할 수 있도록 설계되어, 고차원 행동 공간에서도 효율적인 Q값 추정이 가능하다.23</p>
<h3>6.2  보수적 정칙화 (Conservative Regularization)</h3>
<p>오프라인 RL의 핵심인 ’분포 밖 행동(Out-of-Distribution Actions)’에 대한 과대평가를 막기 위해, Q-Transformer는 보수적 정칙화 항을 손실 함수에 추가한다.<br />
<span class="math math-display">
\mathcal{L}_{total} = \mathcal{L}_{TD} + \alpha \mathcal{L}_{Conservative}
</span><br />
이는 학습 데이터셋에 없는 행동에 대해서는 Q값을 낮추도록 강제하여, 에이전트가 확실하지 않은 상황에서는 위험한 행동을 하지 않도록 유도한다. Q-Transformer는 대규모 로봇 조작(Manipulation) 데이터셋에서 DT나 픽셀 기반의 기존 RL 알고리즘(IQL 등)을 능가하는 성능을 보여주었으며, 특히 사람의 데모 데이터와 자율 수집 데이터가 혼재된 상황에서 탁월한 학습 능력을 입증했다.22</p>
<h2>7.  일반 범용 로봇을 향한 여정: Gato</h2>
<p>DeepMind의 <strong>Gato</strong>는 트랜스포머 기반 로봇 제어의 확장성(Scalability)을 극단적으로 보여주는 사례이다. Gato는 “하나의 모델로 모든 것을 수행한다“는 비전 아래, 아타리 게임, 이미지 캡셔닝, 채팅, 그리고 실제 로봇 팔 제어(Real-world Robot Control)를 단일 트랜스포머 네트워크로 통합했다.25</p>
<h3>7.1  멀티모달 토큰화와 단일 가중치 (Single Weights)</h3>
<p>Gato의 핵심은 서로 다른 모달리티(Modality)를 동일한 벡터 공간의 토큰으로 변환하는 통합 토큰화(Unified Tokenization) 기술이다.</p>
<ul>
<li><strong>텍스트:</strong> SentencePiece를 이용해 토큰화.</li>
<li><strong>이미지:</strong> ViT(Vision Transformer)처럼 패치 단위로 나누어 임베딩.</li>
<li><strong>로봇 제어:</strong> 관절의 토크(Torque), 위치, 버튼 입력 등을 이산화하여 토큰화.</li>
</ul>
<p>이 모든 토큰들은 구별 없이 하나의 시퀀스로 나열되어 트랜스포머에 입력된다. 놀라운 점은 Gato가 600개 이상의 서로 다른 작업을 수행하면서도 모델의 가중치(Weights)를 공유한다는 것이다. 이는 로봇 제어 데이터가 부족한 상황에서, 텍스트나 비디오 등 풍부한 인터넷 데이터를 통해 학습된 일반적인 시퀀스 패턴 지능이 로봇 제어로 전이(Transfer)될 수 있음을 시사한다.27</p>
<h2>8.  기술적 과제와 미래 전망</h2>
<h3>8.1  추론 속도와 실시간 제어의 장벽 (Latency Constraints)</h3>
<p>트랜스포머 기반 제어기가 실험실을 넘어 실제 산업 현장에 적용되기 위해 넘어야 할 가장 큰 산은 ’추론 속도(Inference Speed)’이다. DT나 TT는 거대한 모델 크기와 어텐션 연산의 <span class="math math-inline">O(N^2)</span> 복잡도로 인해, 수십 Hz 이상의 빠른 제어 주기를 요구하는 동적 로봇(예: 사족 보행 로봇, 드론)에 적용하기에는 레이턴시(Latency) 문제가 발생한다.</p>
<ul>
<li><strong>KV 캐싱(KV Caching):</strong> 어텐션 연산 시 이전 스텝의 Key-Value 쌍을 캐싱하여 중복 연산을 줄이는 기법이 필수적으로 사용된다.29</li>
<li><strong>하이브리드 계획:</strong> <strong>QT-TDM</strong>과 같은 연구는 짧은 구간만 트랜스포머로 계획(Planning)하고, 먼 미래는 가치 함수로 추정하는 방식을 통해 속도와 성능의 균형을 맞춘다.17</li>
</ul>
<h3>8.2  결론: 행동 생성의 파운데이션 모델</h3>
<p>트랜스포머는 로봇의 제어 데이터를 텍스트와 같은 시퀀스로 처리함으로써, 자연어 처리 분야의 눈부신 발전(대규모 모델, 사전 학습, 파인 튜닝)을 로봇 공학으로 직수입할 수 있는 고속도로를 개통했다. Decision Transformer와 Trajectory Transformer는 그 시작점이며, 이제 로봇 공학은 거대 언어 모델(LLM)이 보여준 ’창발적 능력(Emergent Abilities)’이 신체(Body)를 가진 에이전트에서도 발현될 수 있는지 검증하는 단계로 진입하고 있다.</p>
<p>앞으로의 연구는 단순한 알고리즘의 개선을 넘어, 인터넷 규모의 비디오와 텍스트 데이터를 로봇의 행동 지능으로 변환하는 <strong>비전-언어-행동(VLA)</strong> 모델로 진화할 것이다. 이는 챕터 17에서 더 자세히 다루겠지만, 트랜스포머가 로봇의 언어가 되었다는 사실은 이제 되돌릴 수 없는 기술적 흐름이 되었다. 데이터 중심(Data-Centric) AI와 로봇 공학의 결합은 로봇이 닫힌 실험실을 벗어나 예측 불가능한 현실 세계로 나아가는 데 필요한 일반화 능력의 열쇠가 될 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Decision Transformer: Reinforcement Learning via Sequence Modeling - Google Sites, https://sites.google.com/berkeley.edu/decision-transformer</li>
<li>Reinforcement Learning as One Big Sequence Modeling Problem - Semantic Scholar, https://www.semanticscholar.org/paper/Reinforcement-Learning-as-One-Big-Sequence-Modeling-Janner-Li/2068b4d5c95ea5c66c8a81e73337fc52466b8b18</li>
<li>Decision Transformer: Reinforcement Learning via Sequence Modeling - OpenReview, https://openreview.net/forum?id=a7APmM4B9d</li>
<li>Decision Transformer: Reinforcement Learning via Sequence Modeling - arXiv, https://arxiv.org/pdf/2106.01345</li>
<li>Decision Transformer: Reinforcement Learning via Sequence Modeling - OpenReview, https://openreview.net/pdf?id=a7APmM4B9d</li>
<li>The Tournament of Reinforcement Learning: DDPG, SAC, PPO, I2A, Decision Transformer | by Anand Majmudar | TDS Archive | Medium, https://medium.com/data-science/the-tournament-of-reinforcement-learning-ddpg-sac-ppo-i2a-decision-transformer-6c1e42f394f0</li>
<li>Deep reinforcement learning navigation via decision transformer in autonomous driving - PMC - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC10985319/</li>
<li>Reframing Reinforcement Learning as Sequence Modeling with Transformers?, https://danieltakeshi.github.io/2021/06/24/transformers-for-rl/</li>
<li>Decision Transformer Model: Architecture, Use Cases, Applications and Advancements, https://www.leewayhertz.com/decision-transformer/</li>
<li>In-Context Decision Transformer: Reinforcement Learning via Hierarchical Chain-of-Thought - arXiv, https://arxiv.org/html/2405.20692v1</li>
<li>Transformer (deep learning) - Wikipedia, https://en.wikipedia.org/wiki/Transformer_(deep_learning)</li>
<li>Deep Generative Models for Decision-Making and Control - arXiv, https://arxiv.org/html/2306.08810</li>
<li>Offline Reinforcement Learning as One Big Sequence Modeling Problem - Trajectory Transformer, https://trajectory-transformer.github.io/trajectory-transformer-neurips-2021.pdf</li>
<li>Deep Generative Models for Decision-Making and Control - UC Berkeley EECS, https://www2.eecs.berkeley.edu/Pubs/TechRpts/2023/EECS-2023-190.pdf</li>
<li>Advances in Transformers for Robotic Applications: A Review - arXiv, https://arxiv.org/html/2412.10599v1</li>
<li>Elastic Decision Transformer - NeurIPS, https://proceedings.neurips.cc/paper_files/paper/2023/file/3b3889d313ba9476c12c2d77ea66b24f-Paper-Conference.pdf</li>
<li>QT-TDM: Planning with Transformer Dynamics Model and Autoregressive Q-Learning, https://arxiv.org/html/2407.18841v1</li>
<li>Critic-Guided Decision Transformer for Offline Reinforcement Learning, https://ojs.aaai.org/index.php/AAAI/article/view/29499/30825</li>
<li>Why Decision Transformers and RvS Fail in Stochastic Environments - arXiv, https://arxiv.org/pdf/2205.15967</li>
<li>[2205.15967] You Can’t Count on Luck: Why Decision Transformers and RvS Fail in Stochastic Environments - arXiv, https://arxiv.org/abs/2205.15967</li>
<li>You Can’t Count on Luck: Why Decision Transformers and RvS Fail in Stochastic Environments | OpenReview, https://openreview.net/forum?id=atb3yifRtX</li>
<li>Scalable Offline Reinforcement Learning via Autoregressive Q-Functions - Q-Transformer, https://qtransformer.github.io/assets/qtransformer.pdf</li>
<li>(PDF) QT-TDM: Planning With Transformer Dynamics Model and Autoregressive Q-Learning, https://www.researchgate.net/publication/386029334_QT-TDM_Planning_With_Transformer_Dynamics_Model_and_Autoregressive_Q-Learning</li>
<li>Q-Transformer: Scalable Offline Reinforcement Learning via Autoregressive Q-Functions, https://arxiv.org/html/2309.10150</li>
<li>DeepMind’s Gato: A General Intelligence Model Able To Perform Over 600 Tasks - Wandb, https://wandb.ai/telidavies/ml-news/reports/DeepMind-s-Gato-A-General-Intelligence-Model-Able-To-Perform-Over-600-Tasks–VmlldzoyMDAzOTgx</li>
<li>Deepmind’s new model Gato is amazing! - Louis-François Bouchard, aka What’s AI, https://www.louisbouchard.ai/deepmind-gato/</li>
<li>arXiv:2205.06175v3 [cs.AI] 11 Nov 2022, https://arxiv.org/pdf/2205.06175</li>
<li>Introducing Gato - a generalist agent from DeepMind : r/artificial - Reddit, https://www.reddit.com/r/artificial/comments/uo47mu/introducing_gato_a_generalist_agent_from_deepmind/</li>
<li>Howuhh/faster-trajectory-transformer - GitHub, https://github.com/Howuhh/faster-trajectory-transformer</li>
<li>QT-TDM: Planning With Transformer Dynamics Model and Autoregressive Q-Learning - IEEE Xplore, https://ieeexplore.ieee.org/iel8/7083369/7339444/10759753.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>