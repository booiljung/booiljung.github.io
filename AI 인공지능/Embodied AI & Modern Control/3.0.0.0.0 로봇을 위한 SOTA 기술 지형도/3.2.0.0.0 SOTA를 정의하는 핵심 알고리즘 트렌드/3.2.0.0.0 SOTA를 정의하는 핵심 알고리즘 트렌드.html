<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 3. 로봇을 위한 SOTA 기술 지형도</a> / <a href="index.html">3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</a> / <span>3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</span></nav>
                </div>
            </header>
            <article>
                <h1>3.2 SOTA를 정의하는 핵심 알고리즘 트렌드</h1>
<p>2020년대 중반을 관통하는 로봇 공학의 소프트웨어 지형도는 ’결정론적 제어(Deterministic Control)’에서 ’생성형 정책(Generative Policy)’으로, 그리고 ’단기 반응형 모델(Reactive Model)’에서 ’장기 시퀀스 모델(Long-horizon Sequence Model)’로의 거대한 패러다임 전환을 겪고 있다. 과거 로봇 제어 기술이 명시적인 모델링과 최적 제어 이론에 기반하여 환경의 불확실성을 수학적으로 소거하려 시도했다면, 현재의 State-of-the-Art(SOTA) 알고리즘들은 불확실성을 정책의 본질적 요소로 수용하고 확률 분포 그 자체를 학습하는 방향으로 진화했다. 특히 2024년과 2025년은 로봇 학습(Robot Learning) 분야의 ’캄브리아기 대폭발’이라 불릴 만큼 다양한 생성형 모델과 시퀀스 아키텍처가 등장하여 기존의 한계를 돌파하고 있다.1</p>
<p>본 절에서는 현재 로봇 제어의 최전선을 형성하고 있는 핵심 알고리즘 트렌드를 심층적으로 분석한다. 우리는 먼저 로봇 데이터의 본질적인 멀티모달리티(Multimodality) 문제를 해결하기 위해 등장한 **확산 정책(Diffusion Policy)**의 성숙과 그 한계를 극복하기 위해 부상한 <strong>플로우 매칭(Flow Matching)</strong> 기술을 다룬다. 이어 시계열 데이터의 시간적 일관성을 보장하기 위한 **액션 청킹(Action Chunking)**과 **트랜스포머(Transformer)**의 결합, 그리고 연산 효율성의 한계를 극복하기 위해 등장한 <strong>상태 공간 모델(State Space Models, SSMs)</strong> 기반의 Mamba 아키텍처 도입을 논의한다. 마지막으로, 이산적(Discrete) 행동 공간과 연속적(Continuous) 행동 공간 사이의 논쟁과 계층적(Hierarchical) 제어의 새로운 흐름을 조망함으로써, 차세대 로봇 지능이 나아가야 할 기술적 방향성을 제시한다.</p>
<h2>1.  멀티모달리티의 정복: 명시적 정책에서 생성형 모델로</h2>
<p>로봇 학습, 특히 모방 학습(Imitation Learning)에서 가장 치명적인 난제는 데이터의 ’멀티모달리티(Multimodality)’이다. 인간 전문가는 동일한 작업 환경에서도 상황에 따라, 혹은 개인의 습관에 따라 서로 다른 행동 궤적을 생성한다. 예를 들어, 장애물을 피할 때 왼쪽으로 우회할 수도 있고 오른쪽으로 우회할 수도 있다. 전통적인 회귀(Regression) 기반의 행동 복제(Behavior Cloning, BC) 모델은 이러한 데이터 분포의 평균(Mean)을 학습하는 경향이 있다. 왼쪽과 오른쪽 경로의 평균은 장애물 정중앙으로의 충돌을 의미하며, 이는 로봇 제어에서 용납될 수 없는 실패 모드이다.4</p>
<h3>1.1 결정론적 한계와 초기 시도들</h3>
<p>초기 연구들은 이 문제를 해결하기 위해 혼합 가우시안 모델(Gaussian Mixture Models, GMM)이나 MDN(Mixture Density Networks)을 도입하여 행동 분포를 여러 개의 가우시안 분포의 합으로 근사하려 했다. 그러나 GMM은 모드(Mode)의 개수를 사전에 지정해야 한다는 하이퍼파라미터 튜닝의 난제가 있었으며, 고차원 행동 공간(High-dimensional action space)에서 학습이 불안정하다는 단점이 있었다.7 이후 등장한 에너지 기반 모델(Energy-Based Models, EBM)을 활용한 *Implicit Behavioral Cloning (IBC)*은 행동과 관측 쌍에 에너지 값을 할당하고, 추론 시 에너지가 최소화되는 행동을 최적화 기법으로 탐색하는 방식을 제안했다. IBC는 명시적인 밀도 함수 없이도 복잡한 분포를 표현할 수 있었으나, 실시간 추론 과정에서 반복적인 그라디언트 계산이 필요하여 고빈도(High-frequency) 제어가 필요한 로봇 시스템에 병목을 유발했다.4</p>
<h3>1.2 확산 정책(Diffusion Policy)의 표준화</h3>
<p>2023년과 2024년을 거치며 로봇 학습의 사실상 표준(De facto Standard)으로 자리 잡은 기술은 단연 **확산 정책(Diffusion Policy)**이다. 확산 정책은 로봇의 행동 생성을 조건부 디노이징 확산 과정(Conditional Denoising Diffusion Process)으로 재정의한다. 이는 데이터에 노이즈를 점진적으로 주입하여 완전한 가우시안 노이즈로 만드는 전방 과정(Forward Process)을 역으로 학습하여, 노이즈로부터 유의미한 행동 궤적을 복원하는 방식이다.7</p>
<p>확산 정책이 SOTA의 지위를 획득하게 된 핵심 이유는 다음과 같다:</p>
<ol>
<li><strong>분포 표현의 유연성:</strong> 확산 모델은 GMM처럼 모드의 개수를 지정할 필요가 없으며, IBC처럼 추론 시 불안정한 최적화 과정을 거치지 않는다. 대신 학습된 스코어 함수(Score Function, <span class="math math-inline">\nabla_x \log p(x)</span>)를 따라 반복적으로 노이즈를 제거함으로써, 복잡하고 비연속적인 멀티모달 분포를 자연스럽게 모델링한다.</li>
<li><strong>안정적인 학습:</strong> GAN(Generative Adversarial Networks)과 달리 모드 붕괴(Mode Collapse) 현상이 없으며, 최대 우도(Maximum Likelihood) 기반 학습에 비해 훈련 안정성이 뛰어나다.</li>
<li><strong>고차원 공간 적응성:</strong> 이미지 생성 분야에서 검증된 U-Net이나 Transformer 아키텍처를 그대로 차용하여, 로봇의 고차원 관절 공간(Joint Space)이나 픽셀 공간(Pixel Space)에서도 효과적으로 작동한다.</li>
</ol>
<p><em>Diffusion Policy: Visuomotor Policy Learning via Action Diffusion</em> 연구에 따르면, 확산 정책은 기존의 LSTM-GMM이나 IBC 대비 조작 작업 성공률을 평균 46.9% 향상시켰다. 특히 시각 정보(Visual Observation)를 조건으로 받아 미래의 행동 시퀀스를 한 번에 생성하는 능력은 로봇이 매 순간의 불확실성을 견디며 장기적인 목표를 달성하는 데 결정적인 기여를 했다.7</p>
<h3>1.3 표 3.2.1 정책 표현 방식에 따른 특성 비교</h3>
<table><thead><tr><th style="text-align: left">정책 유형</th><th style="text-align: left">대표 알고리즘</th><th style="text-align: left">작동 원리</th><th style="text-align: left">멀티모달리티 처리</th><th style="text-align: left">학습 안정성</th><th style="text-align: left">추론 속도</th></tr></thead><tbody>
<tr><td style="text-align: left">명시적 (Explicit)</td><td style="text-align: left">MSE-BC, GMM</td><td style="text-align: left"><span class="math math-inline">s \rightarrow a</span> 매핑 또는 분포 파라미터 추정</td><td style="text-align: left">낮음 (평균화 문제) 또는 제한적</td><td style="text-align: left">높음</td><td style="text-align: left">매우 빠름</td></tr>
<tr><td style="text-align: left">암시적 (Implicit)</td><td style="text-align: left">IBC (Implicit BC)</td><td style="text-align: left">에너지 함수 <span class="math math-inline">E(s, a)</span> 최소화</td><td style="text-align: left">높음 (Energy Landscape)</td><td style="text-align: left">중간 (불안정 가능)</td><td style="text-align: left">느림 (Iterative Opt.)</td></tr>
<tr><td style="text-align: left">확산 (Diffusion)</td><td style="text-align: left">Diffusion Policy</td><td style="text-align: left">노이즈로부터 <span class="math math-inline">K</span>단계 디노이징</td><td style="text-align: left">매우 높음 (Score Matching)</td><td style="text-align: left">높음</td><td style="text-align: left">느림 (Iterative Denoising)</td></tr>
<tr><td style="text-align: left">플로우 (Flow)</td><td style="text-align: left">ManiFlow, FlowPolicy</td><td style="text-align: left">벡터 필드(ODE) 적분</td><td style="text-align: left">매우 높음 (Probability Path)</td><td style="text-align: left">높음</td><td style="text-align: left">빠름 (Few-step)</td></tr>
</tbody></table>
<h2>2.  속도와 품질의 딜레마: 확산에서 플로우 매칭(Flow Matching)으로</h2>
<p>확산 정책의 압도적인 성능에도 불구하고, 실시간 로봇 제어 시스템에는 치명적인 약점이 존재했다. 바로 **추론 속도(Inference Speed)**이다. 확산 모델은 본질적으로 수십에서 수백 단계의 디노이징 스텝(Denoising Steps)을 거쳐야만 고품질의 샘플을 얻을 수 있다. 로봇의 제어 주기가 보통 10Hz에서 100Hz(10ms ~ 100ms)임을 고려할 때, 한 번의 행동 생성에 수백 밀리초가 소요되는 것은 실시간성을 심각하게 저해한다. DDIM(Denoising Diffusion Implicit Models)과 같은 고속 샘플링 기법이 도입되었으나, 스텝 수를 줄일수록 행동의 정밀도가 급격히 하락하는 트레이드오프가 발생했다.10</p>
<p>2025년, 이 딜레마를 해결하기 위해 등장한 패러다임이 바로 **플로우 매칭(Flow Matching)**이다. 플로우 매칭은 확산 모델을 포함하는 더 일반화된 수학적 프레임워크인 ’연속 정규화 흐름(Continuous Normalizing Flows, CNF)’에 기반을 둔다.</p>
<h3>2.1 Flow Matching의 이론적 우위: SDE에서 ODE로</h3>
<p>확산 모델이 확률적 미분 방정식(Stochastic Differential Equations, SDE)을 통해 데이터 분포를 노이즈로 확산시킨다면, 플로우 매칭은 소스 분포(노이즈)와 타겟 분포(데이터)를 연결하는 **확률 경로(Probability Path)**를 정의하고, 이 경로를 생성하는 **벡터 필드(Vector Field, 속도장)**를 학습한다.12</p>
<p>플로우 매칭이 로봇 제어에서 갖는 핵심적인 이점은 **‘직선 경로(Straight-Line Path)’**를 학습할 수 있다는 점이다. <em>Optimal Transport</em> 이론을 적용한 *Conditional Flow Matching (CFM)*은 노이즈 상태에서 목표 행동 상태로 가는 경로를 기하학적으로 가장 짧은 직선으로 유도한다. 경로가 직선에 가까울수록, 이를 수치 적분(Numerical Integration)할 때 발생하는 오차가 줄어든다. 결과적으로, 확산 모델이 구불구불한 경로를 따라가기 위해 많은 스텝을 필요로 했던 것과 달리, 플로우 매칭은 단 1~2번의 적분 스텝(Euler Integration Step)만으로도 목표 지점(최적 행동)에 도달할 수 있다.15</p>
<h3>2.2 년 핵심 알고리즘: ManiFlow와 FlowPolicy</h3>
<p>최근 연구들은 플로우 매칭이 이론적 우위를 넘어 실제 로봇 제어에서도 SOTA 성능을 발휘함을 입증하고 있다.</p>
<ol>
<li><strong>ManiFlow (Consistency Flow Matching):</strong> 2025년 발표된 <em>ManiFlow</em>는 일관성 학습(Consistency Training)을 플로우 매칭에 결합한 모델이다. 이 알고리즘은 시각, 언어, 고유 수용성 감각(Proprioception) 등 다양한 멀티모달 입력을 처리하기 위해 DiT-X(Diffusion Transformer-X) 아키텍처를 채택했다. 실험 결과, ManiFlow는 기존 3D Diffusion Policy 대비 양손 조작(Bimanual Manipulation) 성공률을 대폭 향상시켰으며, 특히 추론 스텝을 10회에서 1~2회로 줄여도 성능 저하가 거의 발생하지 않음을 보여주었다. 이는 실시간 반응이 필수적인 동적 환경에서의 로봇 제어에 혁신적인 돌파구를 마련했다.17</li>
<li><strong>FlowPolicy:</strong> 3D 포인트 클라우드(Point Cloud)를 활용한 <em>FlowPolicy</em>는 AAAI 2025에서 소개된 기술로, 3D 공간 정보를 직접 처리하는 생성형 정책이다. 이 연구는 기존 확산 기반 방법론 대비 추론 속도를 7배 가속화하면서도 경쟁력 있는 성공률을 유지했다. 특히 <em>Consistency Flow Matching</em>을 통해 3D 공간상의 복잡한 6-DoF(Degree of Freedom) 행동 궤적을 단일 추론 단계(Single Inference Step)로 생성할 수 있는 가능성을 열었다.15</li>
<li><strong>FlowRAM:</strong> 기하학적 정밀도가 요구되는 조작 작업을 위해 제안된 <em>FlowRAM</em>은 영역 인식(Region-Aware) 지각 능력과 SSM을 결합했다. 동적 반경 스케줄(Dynamic Radius Schedule)을 통해 로봇이 전체 장면(Global Scene)에서 미세한 기하학적 디테일(Fine-grained Geometry)로 주의를 집중하게 함으로써, RLBench와 같은 벤치마크에서 SOTA를 달성했다. 이는 생성형 모델이 단순히 행동 분포만 학습하는 것이 아니라, 환경을 이해하는 지각 모델과 긴밀히 결합되어야 함을 시사한다.20</li>
</ol>
<p>결론적으로, 로봇 제어 알고리즘의 트렌드는 “확산(Diffusion)에서 플로우(Flow)로” 이동하고 있다. 이는 생성형 모델의 강력한 표현력을 유지하면서도, 물리적 세계의 제약 조건인 ’시간’을 극복하기 위한 필연적인 기술 진화이다.21</p>
<h2>3.  시간적 연속성의 구조화: 액션 청킹(Action Chunking)과 트랜스포머</h2>
<p>생성형 모델이 ’어떤 행동을 할 것인가(What to do)’에 대한 확률적 해답을 제시한다면, **액션 청킹(Action Chunking)**은 ’행동을 어떻게 시간적으로 구성할 것인가(How to organize in time)’에 대한 구조적 해법을 제공한다. 인간의 행동은 단절된 순간의 연속이 아니라, 의미 있는 단위(Chunk)들의 유기적인 결합이다. 이러한 직관을 알고리즘적으로 구현한 것이 바로 *Action Chunking with Transformers (ACT)*이다.22</p>
<h3>3.1 ACT 알고리즘의 아키텍처 및 메커니즘</h3>
<p>ACT는 매 타임스텝마다 단 하나의 행동(<span class="math math-inline">a_t</span>)을 예측하는 기존의 Markovian 정책과 달리, 현재의 관측(<span class="math math-inline">o_t</span>)을 바탕으로 미래의 <span class="math math-inline">k</span> 스텝에 해당하는 행동 시퀀스(<span class="math math-inline">a_{t:t+k}</span>)를 통째로 예측한다. 이를 위해 ACT는 CVAE(Conditional Variational Autoencoder)와 트랜스포머(Transformer)를 결합한 독창적인 구조를 사용한다.1</p>
<ul>
<li><strong>CVAE를 통한 스타일 학습:</strong> ACT는 훈련 시 인코더를 통해 전체 행동 시퀀스와 관측 정보를 잠재 변수(Latent Variable) <span class="math math-inline">z</span>로 압축한다. 이 <span class="math math-inline">z</span>는 해당 행동의 ’스타일(Style)’을 포착한다. 추론 시에는 <span class="math math-inline">z</span>를 사전 분포(Prior, 주로 정규분포)의 평균인 0으로 설정함으로써, 결정론적(Deterministic)이면서도 데이터 분포의 중심에 위치한 강건한 행동을 생성한다. 이는 순수 생성형 모델의 과도한 무작위성을 제어하고, 일관된 동작을 유도하는 역할을 한다.23</li>
<li><strong>트랜스포머 디코더:</strong> <span class="math math-inline">z</span>와 현재의 관측 정보(이미지, 관절 상태 등)는 트랜스포머 디코더에 입력되어, 어텐션(Attention) 메커니즘을 통해 <span class="math math-inline">k</span> 길이의 행동 시퀀스를 생성한다. 트랜스포머의 셀프 어텐션은 시퀀스 내의 행동들 간의 의존성을 모델링하여, 급격한 움직임 변화(Jerky Motion)를 억제하고 부드러운 궤적을 만든다.26</li>
</ul>
<h3>3.2 시간적 앙상블(Temporal Ensembling)의 수학적 원리</h3>
<p>ACT가 실제 로봇 제어에서 탁월한 부드러움을 보여주는 핵심 비결은 <strong>시간적 앙상블(Temporal Ensembling)</strong> 기법에 있다. 로봇이 매 스텝마다 <span class="math math-inline">k</span> 길이의 청크를 예측한다고 가정하자. 시점 <span class="math math-inline">t</span>에서의 행동 <span class="math math-inline">a_t</span>는 시점 <span class="math math-inline">t</span>에서 예측된 청크의 첫 번째 요소일 수도 있고, 시점 <span class="math math-inline">t-1</span>에서 예측된 청크의 두 번째 요소일 수도 있으며, 시점 <span class="math math-inline">t-k+1</span>에서 예측된 청크의 마지막 요소일 수도 있다. 즉, 임의의 시점 <span class="math math-inline">t</span>에는 서로 다른 과거 시점들에서 예측된 다수의 <span class="math math-inline">a_t</span> 후보들이 존재한다.</p>
<p>ACT는 이 후보들을 가중 평균(Weighted Average)하여 최종 행동을 결정한다. 일반적으로 지수 가중치(Exponential Weighting, <span class="math math-inline">w_i = e^{-mi}</span>)를 사용하여, 가장 최근의 예측에 더 높은 신뢰도를 부여하면서도 과거의 예측 정보를 반영한다.<br />
<span class="math math-display">
a_t = \frac{1}{\sum w_i} \sum_{j=0}^{k-1} w_j \cdot \hat{a}_{t}^{(t-j)}
</span><br />
이러한 앙상블 과정은 개별 예측의 오차를 상쇄하고, 시간적으로 매우 매끄러운 제어 신호를 생성한다. 실험 결과, 시간적 앙상블은 ACT의 성공률을 유의미하게 향상시켰으며, 특히 정밀한 조작이 필요한 작업에서 필수적인 요소로 작용했다.23</p>
<h3>3.3 파생 연구와 하드웨어의 민주화</h3>
<p>ACT의 등장은 고가의 로봇 하드웨어 없이도 정교한 작업을 수행할 수 있는 ’로봇의 민주화’를 가속화했다. 스탠포드 대학의 <em>ALOHA</em> 프로젝트는 ACT를 기반으로 수백만 원대의 저가형 로봇 팔로 요리, 정리 정돈, 기구 조작 등 복잡한 양손 작업을 수행하는 데 성공했다.29 이후 ACT는 다양한 형태로 진화하고 있다.</p>
<ul>
<li><strong>Mobile ACT (MACT):</strong> 이동 조작(Mobile Manipulation) 로봇을 위해 공간적 위치 임베딩과 시간적 위치 임베딩을 결합한 하이브리드 인코딩 방식을 제안했다. 이는 수술 로봇의 스캐닝 작업과 같이 베이스의 이동과 팔의 조작이 동시에 이루어져야 하는 작업에서 베이스라인 대비 60-80% 높은 성공률을 기록했다.28</li>
<li><strong>Bi-ACT:</strong> 힘 제어(Force Control)가 중요한 작업에서 리더-팔로워 로봇 간의 양방향 제어(Bilateral Control) 데이터를 ACT로 학습하여, 위치뿐만 아니라 힘의 피드백까지 모방하는 연구로 확장되었다.30</li>
<li><strong>One ACT Play:</strong> 단 하나의 데모(Single Demonstration)만으로도 행동을 복제할 수 있도록 ACT의 시간적 앙상블에 표준편차(Standard Deviation) 기반의 불확실성 추정을 통합하여 강건성을 높인 연구도 발표되었다.27</li>
</ul>
<h2>4.  연산 효율성의 혁명: Mamba와 상태 공간 모델(SSM)</h2>
<p>트랜스포머는 자연어 처리를 넘어 로봇 학습에서도 강력한 성능을 입증했지만, <span class="math math-inline">O(N^2)</span>의 이차적 계산 복잡도(Quadratic Complexity)라는 태생적 한계를 안고 있다. 로봇의 제어 시퀀스가 길어질수록, 혹은 멀티모달 입력의 해상도가 높아질수록 트랜스포머의 어텐션 연산 비용은 기하급수적으로 증가한다. 이는 제한된 연산 자원을 가진 온보드(On-board) 로봇 시스템이나, 수천 스텝 이상의 장기 기억(Long-term Memory)이 필요한 작업에서 치명적인 병목이 된다.31</p>
<p>2024년 하반기부터 이를 대체하기 위한 새로운 아키텍처로 <strong>Mamba</strong>와 **상태 공간 모델(State Space Models, SSM)**이 급부상하고 있다. Mamba는 입력 길이에 대해 선형적인(Linear, <span class="math math-inline">O(N)</span>) 계산 복잡도를 가지면서도 트랜스포머 수준의 모델링 능력을 유지하는 획기적인 아키텍처이다.</p>
<h3>4.1 Mamba 아키텍처의 로봇 적용 메커니즘</h3>
<p>Mamba의 핵심은 ‘선택적 스캔(Selective Scan)’ 메커니즘이다. 기존의 RNN(Recurrent Neural Networks)이 정보를 무차별적으로 압축하여 망각(Forgetting) 문제가 발생했다면, Mamba는 입력 데이터의 내용에 따라 정보를 선택적으로 기억하거나 무시하도록 게이팅(Gating) 파라미터를 동적으로 조절한다. 이를 통해 긴 시퀀스에서도 중요한 정보를 손실 없이 전파할 수 있다.</p>
<p>로봇 제어 분야에서 Mamba의 도입은 다음과 같은 형태로 구체화되고 있다:</p>
<ol>
<li><strong>Decision Mamba (DM):</strong> 오프라인 강화학습(Offline RL)의 대표 주자인 <em>Decision Transformer</em>를 대체하기 위해 제안되었다. DM은 트랜스포머 기반 모델보다 더 적은 파라미터로 D4RL 벤치마크 등에서 더 높은 점수를 기록했다. 특히 DM은 보상(Reward) 시퀀스에 대한 의존성을 제거하고도 안정적인 정책을 학습할 수 있음을 증명하여, 보상 설계가 어려운 실제 로봇 환경에서의 적용 가능성을 높였다.32</li>
<li><strong>Mamba Policy:</strong> 모방 학습을 위한 <em>Mamba Policy</em>는 트랜스포머 기반 정책 대비 파라미터 수를 80% 줄이면서도 성공률을 5% 이상 향상시켰다. 특히 3D 시점 변경이나 긴 호라이즌(Long-horizon) 작업에서 트랜스포머보다 강건한 성능을 보였으며, GPU 메모리 사용량을 대폭 절감시켜 엣지 디바이스 배포를 용이하게 했다.35</li>
<li><strong>RoboMamba:</strong> 비전-언어-행동(VLA) 모델의 경량화를 목표로 하는 <em>RoboMamba</em>는 Mamba를 백본으로 사용하여 로봇의 시각적 상식 추론(Reasoning)과 행동 생성을 통합했다. 이는 기존 트랜스포머 기반 VLA 대비 3배 빠른 추론 속도를 달성했으며, 미세 조정(Fine-tuning) 시 0.1%의 파라미터만 업데이트해도 새로운 기술을 습득할 수 있는 효율성을 보여주었다.37</li>
</ol>
<h3>4.2 Mamba vs. Transformer: 로봇 제어 관점의 비교</h3>
<p>Mamba의 등장은 트랜스포머의 종말을 의미하는 것이 아니라, 적재적소에 맞는 아키텍처 선택의 중요성을 부각한다. 트랜스포머는 글로벌 컨텍스트(Global Context)를 한 번에 파악해야 하는 이미지 처리나 짧은 시퀀스에서 여전히 강력하지만, Mamba는 지속적으로 들어오는 센서 데이터 스트림을 실시간으로 처리해야 하는 로봇 제어 루프에서 압도적인 효율성을 제공한다. 최근에는 <em>Jamba</em>와 같이 트랜스포머 레이어와 Mamba 레이어를 교차하여 두 아키텍처의 장점을 결합하려는 하이브리드 시도도 나타나고 있다.39</p>
<h2>5.  행동 공간의 재해석: 이산적(Discrete) vs. 연속적(Continuous)</h2>
<p>로봇 제어 알고리즘의 또 다른 중요한 논쟁점은 행동 공간(Action Space)의 정의에 있다. 물리적 로봇의 모터는 연속적인 전압이나 토크 값을 입력받지만, 최근의 연구들은 행동 공간을 이산화(Discretization)하는 것이 학습 효율성과 일반화 성능을 높일 수 있다는 증거를 제시하고 있다.40</p>
<h3>5.1 이산 잠재 공간과 VQ-BeT</h3>
<p>연속적인 행동 공간은 탐색(Exploration)이 어렵고, 멀티모달리티를 표현하기 위해 복잡한 생성 모델이 필요하다. 반면, 행동을 유한한 코드북(Codebook)으로 양자화(Quantization)하면 문제를 분류(Classification) 문제로 단순화할 수 있다. *VQ-BeT (Vector Quantized Behavior Transformer)*는 행동 데이터를 VQ-VAE를 통해 이산적인 잠재 공간(Latent Space)으로 매핑하고, 트랜스포머가 이 잠재 코드(Latent Code)를 예측하도록 학습한다.</p>
<p>VQ-BeT은 자율 주행 벤치마크와 로봇 조작 작업에서 확산 정책 대비 5배에서 25배 빠른 추론 속도를 기록했다. 이는 확산 모델의 반복적인 디노이징 과정 없이, 한 번의 패스(Single-pass)만으로 멀티모달 행동을 생성할 수 있기 때문이다. 또한, 이산화된 행동 표현은 로봇이 ‘잡기’, ‘들기’, ’놓기’와 같은 의미론적 단위의 기술을 학습하는 데 유리하며, 장기적인 계획(Planning) 수립에 적합한 추상화 수준을 제공한다.42</p>
<h3>5.2 계층적 구조와 CARP</h3>
<p>이산적 접근과 연속적 접근의 장점을 결합하려는 시도로 **CARP (Coarse-to-Fine AutoRegressive Policy)**가 제안되었다. CARP는 행동 생성을 두 단계로 분리한다. 먼저 행동 오토인코더가 전체 행동 시퀀스의 대략적인(Coarse) 표현을 학습하고, 이후 GPT 스타일의 트랜스포머가 이를 바탕으로 세밀한(Fine) 행동을 자기회귀적으로 정제한다. 이 방식은 확산 기반 정책의 높은 정확도를 유지하면서도, 다중 디노이징 스텝으로 인한 비효율성을 제거하여 트랜스포머의 빠른 추론 속도를 확보했다.43</p>
<h2>6.  시뮬레이션 기반 학습과 SOTA의 확장</h2>
<p>SOTA 알고리즘들은 데이터 기근 문제를 해결하기 위해 시뮬레이션 기술과도 깊이 결합하고 있다. 단순히 시뮬레이션에서 데이터를 모으는 것을 넘어, 시뮬레이터의 내부 정보(Privileged Information)를 활용하여 학습을 가속화하는 기법들이 등장하고 있다.</p>
<p><strong>Simulation-Guided Fine-Tuning (SGFT)</strong> 프레임워크는 시뮬레이션에서 학습된 가치 함수(Value Function)를 실세계 미세 조정(Fine-tuning) 과정의 가이드로 활용한다. 이는 시뮬레이션과 현실 사이의 동역학 차이(Dynamics Gap)가 존재하더라도, 시뮬레이터가 제공하는 구조적 사전 지식(Structural Priors)을 통해 로봇이 현실 세계에서 안전하고 효율적으로 탐색하도록 돕는다. 실험 결과, SGFT는 베이스라인 대비 10배 적은 실세계 샘플만으로도 정교한 조작 기술을 성공적으로 전이(Transfer)시켰다.44</p>
<h2>7. 결론: 융합과 진화</h2>
<p>2025년의 로봇 학습 알고리즘 트렌드는 **“생성형(Generative)”, “고효율(Efficient)”, “장기 시퀀스(Long-horizon)”**라는 세 가지 축으로 요약된다.</p>
<ul>
<li><strong>Diffusion &amp; Flow:</strong> 불확실성을 다루는 생성형 모델은 확산 정책에서 시작하여 플로우 매칭으로 진화하며, 실시간성과 정밀도라는 두 마리 토끼를 잡고 있다.</li>
<li><strong>Structure &amp; Sequence:</strong> ACT와 Mamba는 로봇의 행동을 단순한 점의 집합이 아닌, 시간적 맥락을 가진 시퀀스로 파악하며, 이를 처리하기 위한 연산 구조를 혁신하고 있다.</li>
<li><strong>Hybridization:</strong> 이산적 표현과 연속적 제어의 결합(VQ-BeT), 생성형 모델과 물리적 시뮬레이션의 결합(SGFT) 등 서로 다른 패러다임의 융합이 가속화되고 있다.</li>
</ul>
<p>이러한 알고리즘적 진보는 로봇이 단순히 정해진 궤적을 따라가는 자동화 기계(Automaton)에서, 불확실한 세계를 이해하고 그 안에서 최적의 행동을 스스로 생성해내는 진정한 의미의 지능형 에이전트(Intelligent Agent)로 거듭나는 토대를 마련하고 있다. 다음 절에서는 이러한 알고리즘들이 대규모 데이터 및 파운데이션 모델과 만나 어떻게 로봇 지능의 범용성(Generalizability)을 확장하고 있는지 살펴볼 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Generative Models for Robot Learning - ICLR 2026, https://iclr.cc/virtual/2025/workshop/23977</li>
<li>Integrating Reinforcement Learning with Visual Generative Models: Foundations and Advances - arXiv, https://arxiv.org/html/2508.10316v1</li>
<li>2025 Robotics Revolution: Latest Breakthroughs Reshaping the Industry | RoboCloud Hub, https://robocloud-dashboard.vercel.app/learn/blog/robotics-2025-revolution</li>
<li>Visuomotor Policy Learning via Action Diffusion - arXiv, https://arxiv.org/pdf/2303.04137</li>
<li>Visuomotor Policy Learning via Action Diffusion - arXiv, https://arxiv.org/html/2303.04137v5</li>
<li>Imitating Human Behaviour with Diffusion Models - OpenReview, https://openreview.net/forum?id=Pv1GPQzRrC8</li>
<li>Visuomotor Policy Learning via Action Diffusion, https://diffusion-policy.cs.columbia.edu/diffusion_policy_ijrr.pdf</li>
<li>[PDF] Diffusion policy: Visuomotor policy learning via action diffusion - Semantic Scholar, https://www.semanticscholar.org/paper/Diffusion-policy%3A-Visuomotor-policy-learning-via-Chi-Feng/bdba3bd30a49ea4c5b20b43dbd8f0eb59e9d80e2</li>
<li>Visuomotor Policy Learning via Action Diffusion, https://diffusion-policy.cs.columbia.edu/diffusion_policy_2023.pdf</li>
<li>Two-Steps Diffusion Policy for Robotic Manipulation via Genetic Denoising - arXiv, https://arxiv.org/pdf/2510.21991</li>
<li>Efficient Task-specific Conditional Diffusion Policies: Shortcut Model Acceleration and SO(3) Optimization - arXiv, https://arxiv.org/html/2504.09927v1</li>
<li>Robot Manipulation with Flow Matching - OpenReview, https://openreview.net/pdf?id=l8DzhzIcEj</li>
<li>Flow Matching Explained: From Noise to Robot Actions - Federico Sarrocco, https://federicosarrocco.com/blog/flow-matching</li>
<li>An introduction to Flow Matching · Cambridge MLG Blog, https://mlg.eng.cam.ac.uk/blog/2024/01/20/flow-matching.html</li>
<li>[AAAI 2025 Oral] FlowPolicy: Enabling Fast and Robust 3D Flow-based Policy via Consistency Flow Matching for Robot Manipulation - GitHub, https://github.com/zql-kk/FlowPolicy</li>
<li>Flow matching models vs (traditional) diffusion models, which one do you like better? : r/StableDiffusion - Reddit, https://www.reddit.com/r/StableDiffusion/comments/1m5d2t8/flow_matching_models_vs_traditional_diffusion/</li>
<li>ManiFlow: A General Robot Manipulation Policy via Consistency Flow Training - arXiv, https://arxiv.org/html/2509.01819v1</li>
<li>ManiFlow: A General Robot Manipulation Policy via Consistency Flow Training - arXiv, https://arxiv.org/abs/2509.01819</li>
<li>FlowPolicy: Enabling Fast and Robust 3D Flow-Based Policy via Consistency Flow Matching for Robot Manipulation | Proceedings of the AAAI Conference on Artificial Intelligence, https://ojs.aaai.org/index.php/AAAI/article/view/33617</li>
<li>[2506.16201] FlowRAM: Grounding Flow Matching Policy with Region-Aware Mamba Framework for Robotic Manipulation - arXiv, https://arxiv.org/abs/2506.16201</li>
<li>Normalizing Flows are Capable Visuomotor Policy Learning Models - arXiv, https://arxiv.org/html/2509.21073v1</li>
<li>Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware - arXiv, https://arxiv.org/abs/2304.13705</li>
<li>Dissecting Action Chunking with Transformers (ACT): Precision Imitation Learning for Robotic Manipulation - phospho, https://blog.phospho.ai/dissecting-action-chunking-with-transformers-act-precision-imitation-learning-for-robotic-manipulation/</li>
<li>ACT (Action Chunking with Transformers) - Hugging Face, https://huggingface.co/docs/lerobot/act</li>
<li>Action Chunking with Transformer (ACT) - Emergent Mind, https://www.emergentmind.com/topics/action-chunking-with-transformer-act</li>
<li>Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware - Robotics, https://www.roboticsproceedings.org/rss19/p016.pdf</li>
<li>[2309.10175] One ACT Play: Single Demonstration Behavior Cloning with Action Chunking Transformers - arXiv, https://arxiv.org/abs/2309.10175</li>
<li>Memorized action chunking with Transformers: Imitation learning for vision-based tissue surface scanning - arXiv, https://arxiv.org/html/2411.04050v1</li>
<li>Learning Fine-Grained Bimanual Manipulation with Low-Cost …, https://tonyzhaozh.github.io/aloha/</li>
<li>[2401.17698] Bi-ACT: Bilateral Control-Based Imitation Learning via Action Chunking with Transformer - arXiv, https://arxiv.org/abs/2401.17698</li>
<li>Mamba, Selective State Space Models, and the Rise of Post-Transformer AI - Medium, https://medium.com/@raktims2210/mamba-selective-state-space-models-and-the-rise-of-post-transformer-ai-f197f05e8ab8</li>
<li>Decision Mamba Architectures - arXiv, https://arxiv.org/pdf/2405.07943</li>
<li>[2406.05427] Decision Mamba: A Multi-Grained State Space Model with Self-Evolution Regularization for Offline RL - arXiv, https://arxiv.org/abs/2406.05427</li>
<li>Decision Mamba Architectures - arXiv, https://arxiv.org/html/2405.07943v2</li>
<li>Towards Efficient 3D Diffusion Policy with Hybrid Selective State Models - arXiv, https://arxiv.org/html/2409.07163v1</li>
<li>Towards Efficient 3D Diffusion Policy with Hybrid Selective State Models - arXiv, https://arxiv.org/html/2409.07163v2</li>
<li>RoboMamba: Efficient Vision-Language-Action Model for Robotic Reasoning and Manipulation - arXiv, https://arxiv.org/html/2406.04339v2</li>
<li>[2406.04339] RoboMamba: Efficient Vision-Language-Action Model for Robotic Reasoning and Manipulation - arXiv, https://arxiv.org/abs/2406.04339</li>
<li>MTIL: Encoding Full History with Mamba for Temporal Imitation Learning - arXiv, https://arxiv.org/html/2505.12410v3</li>
<li>Discrete Action Space: A Comprehensive Guide for 2025 - Shadecoder - 100% Invisibile AI Coding Interview Copilot, https://www.shadecoder.com/topics/discrete-action-space-a-comprehensive-guide-for-2025</li>
<li>Advancements in humanoid robot dynamics and learning-based locomotion control methods - OAE Publishing Inc., https://www.oaepublish.com/articles/ir.2025.32</li>
<li>Fast Tracks to Diverse Behaviors: VQ-BeT Achieves 5x Speed Surge Compared to Diffusion Policies - Synced Review, https://syncedreview.com/2024/03/11/fast-tracks-to-diverse-behaviors-vq-bet-achieves-5x-speed-surge-compared-to-diffusion-policies/</li>
<li>CARP: Visuomotor Policy Learning via Coarse-to-Fine Autoregressive Prediction - arXiv, https://arxiv.org/html/2412.06782v3</li>
<li>Rapidly Adapting Policies to the Real-World via Simulation-Guided Fine-Tuning, https://openreview.net/forum?id=XwUrzurG94</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>