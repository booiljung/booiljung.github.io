<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.2.2 무어의 법칙 그 이후: 범용 프로세서에서 로봇 전용 가속기(FPGA, ASIC)로의 전환</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.2.2 무어의 법칙 그 이후: 범용 프로세서에서 로봇 전용 가속기(FPGA, ASIC)로의 전환</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 4. 하드웨어와 AI의 공진화 (Co-Evolution)</a> / <a href="index.html">4.2 하드웨어 복권 ( The Hardware Lottery)</a> / <span>4.2.2 무어의 법칙 그 이후: 범용 프로세서에서 로봇 전용 가속기(FPGA, ASIC)로의 전환</span></nav>
                </div>
            </header>
            <article>
                <h1>4.2.2 무어의 법칙 그 이후: 범용 프로세서에서 로봇 전용 가속기(FPGA, ASIC)로의 전환</h1>
<h2>1.  서론: 무어의 법칙의 황혼과 로봇 컴퓨팅의 실존적 위기</h2>
<p>지난 반세기 동안 디지털 혁명을 견인해 온 가장 강력한 동력은 단연 ’무어의 법칙(Moore’s Law)’이었다. 1965년 고든 무어(Gordon Moore)가 제창한 이 법칙은 반도체 칩에 집적되는 트랜지스터의 수가 약 2년마다 두 배로 증가한다는 경험칙으로, 컴퓨팅 성능의 기하급수적 향상과 비용 절감을 약속하는 보증수표와도 같았다.1 그러나 2020년대를 기점으로 이 견고했던 법칙은 물리적, 경제적 한계에 봉착했다. 스탠포드 대학의 마크 호로위츠(Mark Horowitz) 교수는 무어의 법칙이 “기본적으로 끝났다(basically over)“고 선언했으며, 엔비디아(Nvidia)의 젠슨 황(Jensen Huang) CEO 역시 2022년 칩 가격 인상을 정당화하며 무어의 법칙의 죽음을 공식화했다.3 트랜지스터의 집적도는 여전히 미세하게 증가하고 있으나, 과거와 같은 비용 절감 효과는 사라졌으며 전력 밀도의 한계를 설명하던 데나드 스케일링(Dennard Scaling)의 종료와 맞물려 범용 프로세서의 단일 코어 성능 향상은 정체기에 접어들었다.3</p>
<p>이러한 컴퓨팅 패러다임의 변화는 데이터센터보다도 ‘체화된 인공지능(Embodied AI)’, 즉 로봇 산업에 더욱 심각한 실존적 위기를 초래하고 있다. 데이터센터는 막대한 전력을 공급받으며 수천 개의 GPU를 병렬로 연결해 성능의 한계를 물량으로 극복할 수 있지만, 제한된 배터리와 공간, 그리고 열 설계 전력(TDP) 제약을 가진 모바일 로봇은 그러한 사치를 누릴 수 없기 때문이다.4 더욱이 로봇이 수행해야 할 인공지능 모델의 복잡도는 하드웨어의 발전 속도를 훨씬 상회하고 있다. 2022년 챗GPT 등장 당시 AI 에이전트가 수행할 수 있는 코딩 작업의 시간 범위(Time Horizon)는 불과 30초 수준이었으나, 2025년에는 2시간 이상으로 늘어났으며, 이는 2029년까지 167시간(약 1개월) 분량의 작업을 자율적으로 수행하는 수준으로 급증할 것으로 예측된다.5</p>
<p>이러한 상황에서 범용 프로세서(CPU, GPU)에 의존하는 기존의 로봇 제어 아키텍처는 더 이상 유효하지 않다. 로봇 공학자들은 이제 범용 칩의 성능 향상을 수동적으로 기다리는 것에서 벗어나, 로봇의 인지(Perception), 판단(Planning), 제어(Control)라는 고유한 워크로드에 최적화된 하드웨어를 직접 선택하고 설계해야 하는 전환점에 서 있다. 본 섹션에서는 무어의 법칙 이후 시대의 대안으로 떠오르고 있는 FPGA(Field-Programmable Gate Array)와 ASIC(Application-Specific Integrated Circuit)으로의 전환을 심도 있게 분석하고, 이들이 어떻게 ’하드웨어 복권(Hardware Lottery)’의 당첨 확률을 높이고 있는지 고찰한다.</p>
<h2>2.  범용 프로세서의 구조적 한계와 ’하드웨어 복권’의 역설</h2>
<h3>2.1  하드웨어 복권(The Hardware Lottery) 이론과 로봇 공학</h3>
<p>구글 리서치의 사라 후커(Sara Hooker)가 제안한 ‘하드웨어 복권’ 이론은 현재 AI와 로봇 기술의 발전 방향이 알고리즘의 본질적인 우수성보다는 당대 하드웨어와의 ’운 좋은 호환성’에 의해 결정된다고 지적한다.6 딥러닝(Deep Learning)이 2010년대에 폭발적으로 성장할 수 있었던 것은 그 이론이 완벽해서가 아니라, 그래픽 처리를 위해 설계된 GPU의 병렬 아키텍처가 우연히도 신경망의 행렬 연산과 완벽하게 맞아떨어졌기 때문이다. 반면, 로봇 공학에서 필수적인 기호주의적 AI, 복잡한 제어 이론, 동적 그래프 최적화 기법들은 GPU의 아키텍처와 호환되지 않아 발전이 지체되는 ’잃어버린 수십 년(Lost Decades)’을 겪을 위험에 처해 있다.8</p>
<h3>2.2  폰 노이만 병목과 불규칙한 메모리 접근</h3>
<p>전통적인 CPU와 GPU는 프로그램과 데이터를 메모리에 저장하고 이를 버스(Bus)를 통해 순차적으로 불러와 처리하는 폰 노이만(Von Neumann) 아키텍처를 기반으로 한다. 이 구조는 범용성을 보장하지만, 프로세서와 메모리 사이의 데이터 이동 속도가 전체 시스템 성능을 제한하는 ’폰 노이만 병목(Von Neumann Bottleneck)’을 필연적으로 동반한다.8</p>
<p>로봇의 자율주행을 위한 핵심 알고리즘인 SLAM(Simultaneous Localization and Mapping)이나 모션 플래닝은 이러한 병목 현상을 최악의 형태로 드러낸다. 로봇이 환경을 인식하고 지도를 작성하는 과정에서 생성되는 팩터 그래프(Factor Graph)나 희소 행렬(Sparse Matrix) 데이터는 메모리 상에 불규칙하게 흩어져 있다(Irregular Memory Access). GPU는 메모리의 연속된 블록을 한 번에 읽어와 처리할 때(Coalesced Memory Access) 성능이 극대화되도록 설계되었기 때문에, 로봇의 불규칙한 데이터 접근 패턴 앞에서는 캐시 적중률(Cache Hit Rate)이 급락하고 메모리 대역폭 효율이 바닥으로 떨어진다.9</p>
<h3>2.3  GPU의 딜레마: 처리량(Throughput) 대 지연 시간(Latency)</h3>
<p>GPU는 수천 개의 코어를 활용해 데이터를 대량으로 묶어서 처리하는 배치 처리(Batch Processing)에 특화되어 있어 ‘처리량’ 면에서 압도적이다. 그러나 로봇은 실시간으로 변화하는 환경에 즉각 반응해야 하므로, 입력된 센서 데이터 하나하나를 즉시 처리해야 하는 ‘지연 시간’ 중심의 워크로드를 가진다.11</p>
<p>단일 이미지 프레임이나 단일 라이다(LiDAR) 스캔 데이터를 처리할 때 GPU를 가동하는 것은, 마치 피자 한 판을 배달하기 위해 대형 트레일러를 시동 거는 것과 같은 비효율을 초래한다. 2025년 발표된 비교 연구에 따르면, 실시간 제어 루프에서 GPU는 FPGA나 ASIC에 비해 전력 소모가 극심하고, 데이터 전송 오버헤드로 인해 응답 속도가 느려지는 현상이 관찰된다.11 이는 무어의 법칙이 둔화된 현 시점에서, 단순히 GPU의 클럭을 높이는 것만으로는 로봇 시스템의 실시간성을 보장할 수 없음을 시사한다.</p>
<h2>3.  FPGA: 결정론적 제어와 데이터 흐름 아키텍처의 재발견</h2>
<p>FPGA는 하드웨어의 내부 회로를 사용자가 직접 프로그래밍하여 재구성할 수 있는 반도체로, 포스트 무어 시대 로봇 공학의 가장 강력한 대안 중 하나이다. FPGA는 폰 노이만 아키텍처의 한계를 벗어나 ‘데이터 흐름(Dataflow)’ 아키텍처를 구현할 수 있다는 점에서 로봇의 감각-반응 루프에 이상적이다.</p>
<h3>3.1  결정론적 지연 시간(Deterministic Latency)의 보장</h3>
<p>로봇의 제어 시스템, 특히 고속 드론이나 이족 보행 로봇의 자세 제어는 마이크로초(μs) 단위의 정확한 타이밍을 요구한다. 범용 CPU나 GPU는 운영체제(OS)의 스케줄러, 인터럽트, 백그라운드 프로세스 등으로 인해 연산 시간이 들쭉날쭉한 ’지터(Jitter)’가 발생한다. 반면, FPGA는 하드웨어 회로 자체가 병렬로 작동하므로, 입력 신호에 대해 항상 일정한 클럭 사이클 내에 결과를 출력하는 ’결정론적 성능’을 보장한다.14 이는 미션 크리티컬한 로봇 시스템의 안전성을 담보하는 핵심 요소이다.</p>
<h3>3.2  데이터 흐름 아키텍처를 통한 불규칙 워크로드 가속</h3>
<p>FPGA는 데이터를 메모리에 저장했다가 다시 불러오는 과정을 생략하고, 센서에서 들어오는 데이터를 파이프라인(Pipeline)을 통해 흐르는 물처럼 즉시 처리할 수 있다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>CPU/GPU (폰 노이만)</strong></th><th><strong>FPGA (데이터 흐름)</strong></th><th><strong>로봇 워크로드 이점</strong></th></tr></thead><tbody>
<tr><td><strong>실행 방식</strong></td><td>명령어 인출-해석-실행의 반복</td><td>데이터 도착 시 하드웨어 로직 즉시 실행</td><td>센서 데이터 입력 즉시 처리 (Low Latency)</td></tr>
<tr><td><strong>메모리 접근</strong></td><td>캐시 계층 구조 의존 (Cache Miss 취약)</td><td>온칩 메모리(BRAM/URAM) 직접 배선</td><td>희소 행렬/그래프 등 불규칙 데이터 고속 처리</td></tr>
<tr><td><strong>병렬성</strong></td><td>스레드/워프 단위 병렬성</td><td>비트/파이프라인 수준의 미세 병렬성</td><td>다양한 센서 퓨전 및 비트 단위 연산 최적화</td></tr>
<tr><td><strong>유연성</strong></td><td>소프트웨어 업데이트</td><td>하드웨어 회로 재구성 (Reconfiguration)</td><td>현장 상황에 맞춰 센서 인터페이스 변경 가능</td></tr>
</tbody></table>
<p><em>표 4.2.2-1: 폰 노이만 아키텍처와 FPGA 데이터 흐름 아키텍처의 비교</em></p>
<p>최신 연구인 ‘SuperNoVA’(ASPLOS 2025)는 FPGA의 이러한 특성을 활용하여 VSLAM의 백엔드 최적화 과정을 가속화했다. 이 연구는 FPGA 상에서 동적 그래프 처리를 위한 가상화 기술과 커스텀 메모리 아키텍처를 도입함으로써, CPU 대비 89.5%, 임베디드 GPU 대비 78.6%의 지연 시간 감소를 달성했다.16 또한, 2025년 ‘Accelerated Feature Detectors for Visual SLAM’ 연구에서는 FPGA가 SuperPoint와 같은 딥러닝 기반 특징점 추출 알고리즘을 GPU보다 3.1배 더 빠르게, 1.4배 더 높은 에너지 효율로 처리할 수 있음을 입증했다.17 이는 FPGA가 딥러닝 추론에서도 특정 조건하에서는 GPU를 능가할 수 있음을 보여주는 중요한 사례이다.</p>
<h3>3.3  HLS(High-Level Synthesis)와 개발 장벽의 완화</h3>
<p>과거 FPGA는 Verilog나 VHDL과 같은 하드웨어 기술 언어(HDL)를 능숙하게 다루는 소수의 엔지니어만이 접근할 수 있는 영역이었다. 그러나 C++, Python과 같은 고수준 언어를 하드웨어 회로로 자동 변환해 주는 고수준 합성(HLS) 기술의 발전은 로봇 소프트웨어 개발자들이 FPGA의 성능을 활용할 수 있는 길을 열어주었다.18 AMD(Xilinx)의 Vitis HLS나 Intel의 OneAPI와 같은 도구들은 이제 로봇 운영체제(ROS)의 노드(Node)를 FPGA 하드웨어 블록으로 직접 컴파일하는 수준에 이르렀다.</p>
<h2>4.  ASIC: 대량 생산과 도메인 특화 아키텍처(DSA)의 정점</h2>
<p>ASIC은 특정 용도에 맞춰 설계된 주문형 반도체로, 유연성은 떨어지지만 성능과 전력 효율 면에서는 타협하지 않는 최상의 결과를 제공한다. 로봇 산업이 실험실 단계를 넘어 대량 생산 단계로 진입함에 따라, ASIC은 경제성과 성능을 동시에 잡는 필수적인 선택지가 되고 있다.</p>
<h3>4.1  규모의 경제와 ASIC 전환의 임계점</h3>
<p>FPGA는 초기 개발 비용이 낮고 수정이 용이하여 프로토타입이나 소량 생산에 적합하지만, 칩당 단가가 높고 전력 소모가 ASIC보다는 크다. 반면 ASIC은 초기 설계 및 마스크 제작 비용(NRE Cost)이 막대하지만, 대량 생산 시 칩당 단가를 획기적으로 낮출 수 있다.11 로봇 청소기, 배송 로봇, 자율주행차와 같이 수만 대 이상 생산되는 제품군에서는 전력 효율과 BOM(Bill of Materials) 비용 절감을 위해 ASIC 전환이 필수적이다.</p>
<h3>4.2  도메인 특화 아키텍처(DSA)의 진화</h3>
<p>단순히 특정 알고리즘 하나를 가속하는 것을 넘어, 로봇의 전체 인지-판단-제어 파이프라인을 하드웨어적으로 구현한 도메인 특화 아키텍처(DSA)가 ASIC의 형태로 등장하고 있다. 구글의 TPU가 AI 연산에 특화된 DSA라면, 로봇 분야에서는 호라이즌 로보틱스(Horizon Robotics)의 BPU(Brain Processing Unit)나 테슬라의 FSD 칩이 대표적이다.</p>
<p>이러한 전용 칩들은 범용 칩에서 소프트웨어로 처리하던 작업들, 예를 들어 이미지의 왜곡 보정, 센서 간 시간 동기화, 특징점 추출 등을 하드웨어 블록(Hard IP)으로 내장하여 CPU의 부하를 덜고 전체 시스템의 반응 속도를 극대화한다.</p>
<h2>5.  핵심 알고리즘과 하드웨어의 공진화 (Co-evolution)</h2>
<p>무어의 법칙 이후 시대의 로봇 기술 혁신은 하드웨어와 알고리즘이 서로의 특성에 맞춰 함께 진화하는 ’공진화(Co-evolution)’를 통해 이루어지고 있다. 특히 연산 비용이 높은 SLAM과 MPC 분야에서 이러한 경향이 두드러진다.</p>
<h3>5.1  희소 행렬 가속을 통한 SLAM 최적화</h3>
<p>VSLAM의 백엔드에서는 로봇의 궤적과 지도 오차를 최소화하기 위해 비선형 최소자승법(Non-linear Least Squares)을 푼다. 이 과정에서 생성되는 행렬은 대부분의 원소가 0인 희소 행렬(Sparse Matrix)이다.</p>
<ul>
<li><strong>문제점:</strong> 기존 GPU는 밀집 행렬(Dense Matrix) 연산에 최적화되어 있어, 희소 행렬을 처리할 때 메모리 대역폭을 낭비하고 연산 효율이 떨어진다.10</li>
<li><strong>해결책:</strong> FPGA나 전용 ASIC을 사용하여 희소 행렬의 0이 아닌 요소(Non-zero elements)만을 추적하고 연산하는 인덱싱 로직을 하드웨어로 구현한다. 2025년 연구에서는 FPGA의 온칩 메모리를 활용하여 희소 행렬 벡터 곱셈(SpMV)의 효율을 극대화함으로써 g2o나 GTSAM과 같은 최적화 라이브러리의 성능을 획기적으로 개선했다.17 이는 로봇이 더 넓은 공간에서 더 정밀한 지도를 실시간으로 작성할 수 있게 해준다.</li>
</ul>
<h3>5.2  MPC 솔버의 하드웨어화: ADMM 대 IPM</h3>
<p>모델 예측 제어(MPC)는 로봇의 동역학적 제약을 고려하여 최적의 제어를 수행하지만, 매 순간 복잡한 최적화 문제를 풀어야 하는 부담이 있다. 이를 해결하기 위해 두 가지 주요 알고리즘이 하드웨어 가속 대상으로 경쟁하고 있다.</p>
<ul>
<li><strong>내부점 방법(Interior Point Method, IPM):</strong> 적은 반복 횟수로 정확한 해를 찾지만, 각 반복마다 복잡한 선형 시스템을 풀어야 하므로 병렬화가 어렵다.23</li>
<li><strong>교대 방향 승수법(ADMM):</strong> 문제를 작은 조각으로 나누어 병렬로 풀 수 있는 알고리즘으로, FPGA의 병렬 아키텍처와 궁합이 매우 좋다. 2025년 연구들은 ADMM 기반의 MPC 솔버를 FPGA에 구현하여, CPU 기반 솔버 대비 수십 배 빠른 수렴 속도를 달성했다.23 이는 고속 드론의 회피 기동이나 4족 보행 로봇의 동적 균형 제어와 같은 고성능 제어를 가능하게 한다.</li>
</ul>
<h3>5.3  부트스트랩 MPC(Bootstrapped MPC)와 하이브리드 가속</h3>
<p>2025년 ICLR에서 발표된 ’부트스트랩 MPC’는 신경망 정책(Policy)과 MPC가 상호 보완적으로 작동하는 구조를 제안했다. 신경망은 MPC에게 좋은 초기 해(Warm Start)를 제공하여 연산 시간을 줄이고, MPC는 신경망에게 고품질의 학습 데이터를 제공한다.28 이러한 알고리즘을 실시간으로 구동하려면, 신경망 추론을 담당하는 NPU와 최적화 연산을 담당하는 FPGA/DSP가 긴밀하게 결합된 이기종 컴퓨팅 플랫폼이 필수적이다.</p>
<h2>6.  차세대 로봇 프로세싱 유닛(RPU)의 아키텍처 심층 분석</h2>
<p>로봇 전용 가속기의 필요성은 산업계에서 ‘로봇 프로세싱 유닛(RPU: Robot Processing Unit)’ 또는 ’로봇 코어(RobotCore)’라는 개념으로 구체화되고 있다.14 주요 기업들의 RPU 아키텍처를 분석해보면, 이기종 통합(Heterogeneous Integration)이 공통된 트렌드임을 알 수 있다.</p>
<h3>6.1  Horizon Robotics의 BPU (Brain Processing Unit)</h3>
<p>중국의 호라이즌 로보틱스는 자율주행과 로봇을 위한 전용 아키텍처인 BPU를 개발하며 ‘소프트웨어 2.0’ 시대에 대응하고 있다.</p>
<ul>
<li><strong>아키텍처 진화:</strong> 1세대 베르누이(Bernoulli)에서 시작하여 베이즈(Bayes), 내시(Nash), 그리고 2025년 발표된 4세대 리만(Riemann) 아키텍처로 발전했다.31</li>
<li><strong>기술적 특징:</strong> BPU는 단순한 CNN 가속을 넘어, 트랜스포머(Transformer) 모델과 시공간 예측을 위한 BEV(Bird’s Eye View) 변환을 하드웨어적으로 지원한다. 특히 리만 아키텍처는 인지-예측-결정에 이르는 전 과정을 처리할 수 있도록 설계되어, 범용 로봇을 위한 진정한 의미의 ‘두뇌’ 역할을 지향한다. 이는 “알고리즘이 칩을 정의한다“는 철학 하에 소프트웨어와 하드웨어를 공동 설계한 결과물이다.</li>
</ul>
<h3>6.2  Nvidia Jetson Orin: DLA와 PVA의 전략적 분업</h3>
<p>엔비디아의 Jetson Orin 플랫폼은 강력한 GPU를 기반으로 하지만, 로봇 워크로드의 특수성을 고려하여 두 가지 보조 가속기를 내장하고 있다.</p>
<ul>
<li><strong>DLA (Deep Learning Accelerator):</strong> GPU보다 전력 효율이 3~5배 높은 딥러닝 전용 고정 기능 ASIC이다. 지속적으로 실행되어야 하는 객체 감지나 세그멘테이션 작업을 DLA에 오프로딩함으로써, GPU는 더 복잡한 추론이나 훈련 작업에 집중할 수 있게 한다.33</li>
<li><strong>PVA (Programmable Vision Accelerator):</strong> VLIW(Very Long Instruction Word) 기반의 DSP로, 딥러닝이 아닌 전통적인 컴퓨터 비전(특징점 추적, 필터링 등)을 초저전력으로 처리한다.35 이는 딥러닝 만능주의의 한계를 인정하고, 여전히 효율적인 고전 알고리즘을 위한 전용 하드웨어 공간을 마련했다는 점에서 의미가 크다.</li>
</ul>
<h3>6.3  Qualcomm Robotics RB5와 Hexagon DSP</h3>
<p>모바일 AP의 강자 퀄컴은 RB5 플랫폼을 통해 스마트폰 기술을 로봇으로 확장했다.</p>
<ul>
<li><strong>Hexagon DSP:</strong> 퀄컴 아키텍처의 핵심으로, HVX(Hexagon Vector eXtensions)라는 벡터 연산 확장을 통해 이미지 신호 처리와 센서 퓨전을 담당한다. CPU나 GPU를 거치지 않고 DSP 내부에서 센서 데이터를 직접 처리함으로써 지연 시간을 최소화한다.37</li>
<li><strong>EVA (Engine for Video Analytics):</strong> 비전 처리 전용 엔진으로, VSLAM의 특징점 추출이나 광학 흐름(Optical Flow) 계산을 하드웨어적으로 가속하여 전체 시스템의 전력 효율을 극대화한다.</li>
</ul>
<h3>6.4  AMD Kria SOM과 적응형 컴퓨팅(Adaptive Computing)</h3>
<p>AMD(구 Xilinx)의 Kria KR260은 FPGA(Programmable Logic)와 ARM CPU(Processing System)가 하나의 칩에 통합된 Zynq MPSoC 기반의 플랫폼이다.</p>
<ul>
<li><strong>적응형 가속:</strong> Kria는 ROS 2의 하드웨어 가속을 기본적으로 지원하며, 개발자가 Vitis와 같은 도구를 사용해 인식 노드나 제어 노드를 FPGA 로직으로 오프로딩할 수 있게 한다.40 이는 하드웨어 설계 지식이 부족한 로봇 개발자도 FPGA의 결정론적 성능과 저지연 이점을 누릴 수 있도록 하는 ‘적응형 컴퓨팅’ 전략의 핵심이다. 특히 산업용 통신(EtherCAT, TSN)과 비전 처리를 단일 칩에서 동시에 처리할 수 있어 산업용 로봇 제어기에 최적화되어 있다.</li>
</ul>
<table><thead><tr><th><strong>플랫폼</strong></th><th><strong>주요 가속기 구성</strong></th><th><strong>핵심 기술 및 특징</strong></th><th><strong>주요 타겟 애플리케이션</strong></th></tr></thead><tbody>
<tr><td><strong>Horizon BPU</strong></td><td>BPU (ASIC)</td><td>트랜스포머/BEV 하드웨어 지원, SW-HW 공동 설계</td><td>자율주행, 스마트 모빌리티</td></tr>
<tr><td><strong>Nvidia Orin</strong></td><td>GPU + DLA + PVA</td><td>DLA(효율적 AI)와 PVA(비전 DSP)의 이기종 분업</td><td>고성능 AI 로봇, 엣지 서버</td></tr>
<tr><td><strong>Qualcomm RB5</strong></td><td>Adreno GPU + Hexagon DSP</td><td>HVX 벡터 확장, EVA 비전 엔진, 5G 통합</td><td>드론, 서비스 로봇, AMR</td></tr>
<tr><td><strong>AMD Kria</strong></td><td>ARM CPU + FPGA (PL)</td><td>하드웨어 재구성 가능성, 결정론적 제어, ROS 2 가속</td><td>산업용 로봇, 공장 자동화</td></tr>
</tbody></table>
<p><em>표 4.2.2-2: 주요 로봇 전용 프로세서(RPU) 아키텍처 비교</em></p>
<h2>7.  결론: 포스트 무어 시대의 로봇 컴퓨팅 패러다임</h2>
<p>무어의 법칙의 종료는 로봇 공학자들에게 더 이상 범용 프로세서의 성능 향상에 기댈 수 없다는 냉혹한 현실을 마주하게 했다. 그러나 이는 역설적으로 ’하드웨어 복권’의 굴레에서 벗어나, 로봇의 본질인 ’행동(Action)’과 ’상호작용(Interaction)’에 진정으로 최적화된 컴퓨팅 아키텍처를 탐구하게 만든 기폭제가 되었다.</p>
<p>FPGA와 ASIC으로의 전환은 단순한 성능 향상을 위한 선택이 아니다. 이는 로봇이 통제된 환경을 벗어나 복잡하고 예측 불가능한 현실 세계(Real World)에서 생존하기 위한 진화적 적응이다. 불규칙한 메모리 접근을 해결하는 데이터 흐름 아키텍처, 딥러닝과 고전 제어 이론을 아우르는 이기종 통합, 그리고 생산 규모에 따른 경제성 확보는 포스트 무어 시대 로봇 컴퓨팅의 새로운 표준이 될 것이다.</p>
<p>미래의 로봇은 CPU, GPU, FPGA, NPU가 하나의 유기체처럼 통합된 ‘초이기종(Hyper-Heterogeneous)’ 두뇌를 갖게 될 것이며, 소프트웨어가 하드웨어를 정의하고 다시 하드웨어가 소프트웨어의 가능성을 확장하는 공진화의 사이클을 통해 지능의 새로운 지평을 열어갈 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Moore’s Law Accelerated: The Exponential Growth of AI - Sidecar AI, https://sidecar.ai/blog/moores-law-accelerated-the-exponential-growth-of-ai</li>
<li>The Death of Moore’s Law: What it means and what might fill the gap …, https://cap.csail.mit.edu/death-moores-law-what-it-means-and-what-might-fill-gap-going-forward</li>
<li>AI investors face post-Moore’s Law reality - Top1000funds.com, https://www.top1000funds.com/2025/10/ai-investors-face-post-moores-law-reality/</li>
<li>The Impact of the End of Moore’s Law on the AI Gold Rush - EE Times, https://www.eetimes.com/the-impact-of-the-end-of-moores-law-on-the-ai-gold-rush/</li>
<li>A new Moore’s Law for AI agents - AI Digest, https://theaidigest.org/time-horizons</li>
<li>Scaling Artificial Intelligence for Robotics in 2021 | by Matt Shaffer, https://discovermatt.medium.com/scaling-artificial-intelligence-for-robotics-in-2021-b0cc9919bced</li>
<li>The Hardware Lottery: Sara Hooker | PDF | Graphics Processing Unit, https://www.scribd.com/document/490478747/2009-06489</li>
<li>The Hardware Lottery, https://hardwarelottery.github.io/</li>
<li>[2303.13954] Compiler Optimization for Irregular Memory Access …, https://arxiv.org/abs/2303.13954</li>
<li>Accelerating Sparse Matrix-Matrix Multiplication on GPUs … - arXiv, https://arxiv.org/html/2512.12036v1</li>
<li>FPGA vs. ASIC vs. GPU: Which is the Right Choice for Your Project?, https://www.kynix.com/Blog/fpga-vs-asic-vs-gpu-which-is-the-right-choice-for-your-project.html</li>
<li>FPGA vs ASIC vs GPU: Choosing the Right Hardware for the Right Job, https://reshal-saba.medium.com/fpga-vs-asic-vs-gpu-choosing-the-right-hardware-for-the-right-job-95a322d997b3</li>
<li>FPGA vs. GPU for Deep Learning Applications - IBM, https://www.ibm.com/think/topics/fpga-vs-gpu</li>
<li>ROBOTCORE® RPU | Robot Processing Unit specialized in ROS …, https://accelerationrobotics.com/robotcore.php</li>
<li>Incremental Model Predictive Control Exploiting Time-Delay …, https://elib.dlr.de/148786/3/elib_TCST_21-0575_published.pdf</li>
<li>SuperNoVA: Algorithm-Hardware Co-Design for Resource-Aware …, https://people.eecs.berkeley.edu/~ysshao/assets/papers/supernova-asplos2025.pdf</li>
<li>[2510.13546] Accelerated Feature Detectors for Visual SLAM, https://arxiv.org/abs/2510.13546</li>
<li>Exploring Visual SLAM Acceleration with High-Level Synthesis, https://research.manchester.ac.uk/en/studentTheses/exploring-visual-slam-acceleration-with-high-level-synthesis/</li>
<li>FPT’25 Design Competition, https://fpt2025.shanghaitech.edu.cn/fpt25-design-contest.pdf</li>
<li>Comparing Leading GPU, FPGA, and ASIC AI Accelerators, https://www.geniatech.com/ai-hardware-2025/</li>
<li>Sparse Matrices and Parallel Processing on GPUs, https://icl.utk.edu/~hanzt/talks/SparseMatricesAndParallelProcessingOnGPUs.pdf</li>
<li>Hardware Acceleration for SLAM in Mobile Systems - JCST, https://jcst.ict.ac.cn/en/article/pdf/preview/10.1007/s11390-021-1523-5.pdf</li>
<li>Fast Trajectory Tracking Control Algorithm for Autonomous Vehicles …, https://pmc.ncbi.nlm.nih.gov/articles/PMC10610838/</li>
<li>A Comparison of Interior Point and Active Set Methods for FPGA …, https://dr.ntu.edu.sg/server/api/core/bitstreams/25309ade-f36e-4194-965b-6eb155b4ff8d/content</li>
<li>A Comparison of Interior Point and Active Set Methods for FPGA …, https://www.researchgate.net/publication/265399430_A_Comparison_of_Interior_Point_and_Active_Set_Methods_for_FPGA_Implementation_of_Model_Predictive_Control</li>
<li>A Sparsity-Aware Autonomous Path Planning Accelerator with HW …, https://arxiv.org/html/2507.16177v1</li>
<li>Easy and Straightforward FPGA Implementation of Model Predictive …, https://www.mdpi.com/2079-9292/14/3/419</li>
<li>BOOTSTRAPPED MODEL PREDICTIVE CONTROL - OpenReview, https://openreview.net/pdf?id=i7jAYFYDcM</li>
<li>[2503.18871] Bootstrapped Model Predictive Control - arXiv, https://arxiv.org/abs/2503.18871</li>
<li>Robotic Processing Unit - GitHub, https://github.com/ros-acceleration/robotic_processing_unit</li>
<li>Horizon Robotics Unveils Fourth-Generation BPU Architecture …, https://pandaily.com/horizon-robotics-unveils-fourth-generation-bpu-architecture-riemann-delivering-a-10-performance-boost</li>
<li>Core Technologies - Horizon Robotics, https://en.horizon.auto/core-technologies/</li>
<li>Maximizing Deep Learning Performance on NVIDIA Jetson Orin with …, https://developer.nvidia.com/blog/maximizing-deep-learning-performance-on-nvidia-jetson-orin-with-dla/</li>
<li>NVIDIA Jetson AGX Orin Series - OpenZeka, https://openzeka.com/wp-content/uploads/2022/02/Jetson_AGX_Orin_DS-10662-001_v1.1.pdf</li>
<li>Architecture — PVA SDK - NVIDIA Documentation, https://docs.nvidia.com/pva/sdk/2.7.1/architecture.html</li>
<li>Optimizing the CV Pipeline in Automotive Vehicle Development …, https://www.edge-ai-vision.com/2024/10/optimizing-the-cv-pipeline-in-automotive-vehicle-development-using-the-pva-engine/</li>
<li>Qualcomm® Robotics RB5 Development Kit - Thundercomm, https://www.thundercomm.com/product/qualcomm-robotics-rb5-development-kit/</li>
<li>Qualcomm® Robotics RB5 Platform Product Brief, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/qualcomm-robotics-rb5-platform-product-brief.pdf</li>
<li>Qualcomm Dragonwing™ QRB5165 | Robotics CPU with AI &amp; 5G, https://www.qualcomm.com/internet-of-things/products/q5-series/qrb5165</li>
<li>Kria KR260 Robotics Starter Kit - AMD, https://www.amd.com/en/products/system-on-modules/kria/k26/kr260-robotics-starter-kit.html</li>
<li>Kria KR260 Robotics Starter Kit: Unleashing Roboticists through …, https://www.mouser.com/pdfDocs/wp544-kr260.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>