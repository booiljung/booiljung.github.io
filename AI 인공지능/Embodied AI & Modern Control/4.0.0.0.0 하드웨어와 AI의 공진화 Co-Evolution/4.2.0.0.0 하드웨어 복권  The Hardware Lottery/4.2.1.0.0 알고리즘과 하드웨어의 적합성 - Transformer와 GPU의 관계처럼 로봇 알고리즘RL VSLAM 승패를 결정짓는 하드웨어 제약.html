<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.2.1 알고리즘과 하드웨어의 적합성: Transformer와 GPU의 관계처럼, 로봇 알고리즘(RL, VSLAM) 승패를 결정짓는 하드웨어 제약</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.2.1 알고리즘과 하드웨어의 적합성: Transformer와 GPU의 관계처럼, 로봇 알고리즘(RL, VSLAM) 승패를 결정짓는 하드웨어 제약</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 4. 하드웨어와 AI의 공진화 (Co-Evolution)</a> / <a href="index.html">4.2 하드웨어 복권 ( The Hardware Lottery)</a> / <span>4.2.1 알고리즘과 하드웨어의 적합성: Transformer와 GPU의 관계처럼, 로봇 알고리즘(RL, VSLAM) 승패를 결정짓는 하드웨어 제약</span></nav>
                </div>
            </header>
            <article>
                <h1>4.2.1 알고리즘과 하드웨어의 적합성: Transformer와 GPU의 관계처럼, 로봇 알고리즘(RL, VSLAM) 승패를 결정짓는 하드웨어 제약</h1>
<h2>1. 서론: 하드웨어 복권(The Hardware Lottery)과 로봇 공학의 딜레마</h2>
<p>인공지능(AI)과 로봇 공학의 발전사를 되돌아볼 때, 우리는 종종 뛰어난 알고리즘이 모든 기술적 난제를 해결했다는 영웅적 서사에 매몰되곤 한다. 그러나 기술 발전의 이면을 정밀하게 들여다보면, 특정 알고리즘의 성공과 실패를 가른 결정적인 요인이 순수한 수학적 우아함이나 이론적 완결성이 아니었음을 알게 된다. 오히려 그 시대에 가용했던 하드웨어 아키텍처와 소프트웨어 생태계가 해당 알고리즘의 연산 특성을 얼마나 잘 지원해주었느냐가 생존을 결정지었다. 구글 브레인(Google Brain)의 연구자 사라 후커(Sara Hooker)는 이러한 현상을 **“하드웨어 복권(The Hardware Lottery)”**이라는 개념으로 정립하였다.1 이 이론은 연구 아이디어의 승리가 본질적인 우수성보다는 당대의 하드웨어—연산 장치의 설계 철학, 메모리 계층 구조, 통신 대역폭 등—와의 ’적합성(Fit)’에 의해 좌우된다고 주장한다.</p>
<p>딥러닝(Deep Learning)의 폭발적인 부흥은 하드웨어 복권의 가장 극적인 당첨 사례이자, 현대 AI 연구가 특정 방향으로 쏠리게 된 원인이다. 역전파(Backpropagation)와 심층 신경망(Deep Neural Networks)의 이론적 토대는 이미 1980년대에 마련되어 있었으나, 당시의 범용 CPU 중심 컴퓨팅 환경은 행렬 연산이 주를 이루는 신경망 학습을 감당할 수 없었다.2 폰 노이만 병목현상(Von Neumann Bottleneck)으로 인해 CPU는 데이터 이동에 막대한 시간을 허비해야 했고, 이는 신경망 연구를 수십 년간의 ’암흑기(Lost Decades)’로 몰아넣었다. 그러나 2000년대 초반, 그래픽 처리를 위해 고안된 GPU(Graphics Processing Unit)가 우연히도 신경망의 대규모 병렬 연산 특성과 맞아떨어진다는 사실이 발견되면서 상황은 반전되었다.2</p>
<p>오늘날 우리가 목격하는 거대 언어 모델(LLM)과 생성형 AI의 성공은 <strong>트랜스포머(Transformer)</strong> 아키텍처와 GPU가 맺은 완벽한 공생 관계의 산물이다. 트랜스포머는 GPU의 강점인 대규모 행렬 곱셈(GEMM) 처리 능력과 높은 메모리 대역폭 활용을 극대화하도록 설계되었다. 즉, 트랜스포머는 현대 하드웨어 복권의 명백한 승자이며, 이 승리는 더 큰 모델, 더 많은 GPU 투입이라는 선순환(또는 쏠림)을 만들어내고 있다.</p>
<p>그러나 이러한 성공 방정식이 로봇 공학(Robotics) 분야에서도 그대로 유효할까? 로봇의 ’두뇌’에 해당하는 강화학습(Reinforcement Learning, RL)과 ’눈’에 해당하는 시각적 동시 위치 추정 및 지도 작성(Visual SLAM) 알고리즘으로 시선을 돌리면, 우리는 불편한 진실과 마주하게 된다. 로봇 알고리즘은 트랜스포머와 달리 GPU 하드웨어와 미묘한, 때로는 치명적인 불협화음을 내고 있다. 로봇은 순차적인 의사결정(Sequential Decision Making), 희소한(Sparse) 데이터 처리, 그리고 극도로 낮은 지연 시간(Low Latency)을 요구하는데, 이는 대량의 데이터를 배치(Batch)로 묶어 처리량(Throughput)을 높이는 데 최적화된 GPU의 설계 철학과 정면으로 배치되기 때문이다.5</p>
<p>본 장에서는 하드웨어 복권의 관점에서 로봇 알고리즘의 현재와 미래를 심층 분석한다. 먼저 트랜스포머가 어떻게 GPU와의 적합성을 통해 세상을 지배하게 되었는지 그 메커니즘을 분석하고, 반대로 로봇 알고리즘(RL, VSLAM)이 겪고 있는 하드웨어적 제약과 비효율성을 파헤친다. 나아가 이러한 하드웨어적 한계가 로봇 알고리즘의 진화 방향을 어떻게 왜곡하거나 강제하고 있는지—예를 들어, 희소성 기반의 SLAM이 왜 비효율적인 Dense SLAM으로 대체되고 있는지—를 탐구하고, 이를 극복하기 위한 하드웨어-알고리즘 공동 설계(Co-design)의 가능성을 모색한다.</p>
<h2>2.  승자의 방정식: Transformer와 GPU의 완벽한 결합 (The Perfect Alignment)</h2>
<p>로봇 알고리즘이 직면한 하드웨어적 소외를 이해하기 위해서는, 먼저 현재의 ’승자’인 트랜스포머와 GPU의 결합이 왜 그토록 강력한 시너지를 내는지 이해해야 한다. 이들의 결합은 단순한 호환성을 넘어, 상호 간의 발전을 가속화하는 ’공진화(Co-evolution)’의 단계에 도달해 있다.</p>
<h3>2.1  GPU 아키텍처의 본질: 처리량(Throughput) 중심 설계의 미학</h3>
<p>GPU는 태생적으로 CPU와는 전혀 다른 목적 함수를 가지고 설계되었다. CPU가 복잡한 분기 예측(Branch Prediction), 비순차적 실행(Out-of-Order Execution), 그리고 거대한 캐시 메모리를 통해 단일 스레드의 지연 시간(Latency)을 최소화하는 데 집중한다면, GPU는 수천 개의 단순한 코어를 이용해 전체 처리량(Throughput)을 극대화하는 데 초점을 맞춘다.8</p>
<h4>2.1.1  SIMT (Single Instruction, Multiple Threads) 구조</h4>
<p>GPU 아키텍처의 핵심은 SIMT 구조이다. 이는 하나의 명령어를 여러 스레드가 동시에 실행하는 방식이다. 엔비디아(NVIDIA) GPU의 경우, 32개의 스레드가 하나의 ’워프(Warp)’라는 단위로 묶여 락스텝(Lock-step) 방식으로 실행된다.10</p>
<ul>
<li><strong>효율성의 극대화:</strong> 32개의 스레드가 “데이터 A와 B를 더하라“라는 동일한 명령을 수행할 때, GPU는 명령어 디코딩과 제어 로직을 32개 스레드가 공유하게 함으로써 트랜지스터 효율을 극대화한다.</li>
<li><strong>조건부의 제약:</strong> 반면, 스레드들이 서로 다른 명령을 수행해야 하는 상황(예: 조건문 분기)에서는 이 구조가 독이 된다. 이는 후술할 VSLAM에서의 ‘워프 다이버전스’ 문제의 원인이 된다.</li>
</ul>
<h4>2.1.2  메모리 계층과 산술 강도 (Arithmetic Intensity)</h4>
<p>GPU는 수천 개의 코어에 데이터를 끊임없이 공급하기 위해 HBM(High Bandwidth Memory)과 같은 초고속 메모리를 사용한다. 하지만 연산 속도의 발전 속도가 메모리 대역폭의 발전 속도를 항상 앞지르기 때문에, GPU 성능의 핵심 지표는 ’산술 강도’가 된다.11</p>
<ul>
<li>
<p>산술 강도의 정의: 산술 강도는 메모리에서 가져온 데이터 1바이트당 수행하는 부동 소수점 연산(FLOPs)의 횟수를 의미한다.<br />
<span class="math math-display">
\text{Arithmetic Intensity} = \frac{\text{Total FLOPs}}{\text{Total Bytes Accessed}}
</span></p>
</li>
<li>
<p><strong>루프라인 모델(Roofline Model):</strong> 산술 강도가 높은 작업은 ‘연산 제한(Compute-bound)’ 영역에 속하여 GPU의 연산 성능을 온전히 활용하지만, 산술 강도가 낮은 작업은 ‘메모리 제한(Memory-bound)’ 영역에 속하여 GPU 코어가 데이터가 오기를 기다리며 놀게 된다(Stall).</p>
</li>
</ul>
<h3>2.2  Transformer의 알고리즘적 특성: 고밀도(Dense)와 병렬성(Parallelism)</h3>
<p>트랜스포머 아키텍처는 GPU가 가장 좋아하는 연산 패턴을 완벽하게 제공한다. 2017년 구글이 발표한 “Attention Is All You Need” 논문은 사실상 “GEMM Is All You Need“라고 불러도 무방할 정도로, 트랜스포머는 GPU 친화적인 행렬 연산의 집합체이다.8</p>
<h4>2.2.1  거대 행렬 곱셈 (GEMM)의 연속</h4>
<p>트랜스포머의 핵심인 셀프 어텐션(Self-Attention) 메커니즘과 피드포워드 네트워크(Feed-Forward Network, FFN)는 본질적으로 <span class="math math-inline">Q \times K^T</span>, <span class="math math-inline">V \times \text{Score}</span>와 같은 거대 행렬 곱셈(GEMM)으로 이루어져 있다.</p>
<ul>
<li><strong>메모리 응집(Memory Coalescing):</strong> 고밀도 행렬(Dense Matrix)은 메모리상에 데이터가 연속적으로 저장되어 있다. GPU 스레드들이 인접한 메모리 주소를 동시에 읽어들이는 ’메모리 응집’이 자연스럽게 발생하여 메모리 대역폭 효율이 극대화된다.8</li>
<li><strong>텐서 코어(Tensor Core) 활용:</strong> 현대 GPU는 행렬 곱셈을 가속하기 위한 전용 하드웨어인 텐서 코어를 탑재하고 있다. 트랜스포머의 연산은 이 텐서 코어의 입력 포맷에 정확히 부합하며, FP16, BF16, 심지어 FP8과 같은 저정밀도 연산을 통해 처리량을 비약적으로 높일 수 있다.14</li>
</ul>
<h4>2.2.2  병렬 처리의 용이성</h4>
<p>과거 자연어 처리를 지배했던 순환 신경망(RNN)이나 LSTM은 이전 타임스텝의 은닉 상태(Hidden State)가 다음 타임스텝의 입력이 되는 순차적 의존성(Sequential Dependency)을 가지고 있었다. 이는 GPU의 병렬성을 저해하는 치명적인 요소였다.</p>
<ul>
<li>반면 트랜스포머는 입력 시퀀스 전체를 한 번에 행렬로 변환하여 처리한다. 문장 내의 모든 단어 간의 관계(Attention Score)를 동시에 계산할 수 있으므로, 시퀀스 길이에 비례하는 병렬성을 GPU에 제공한다. 이는 학습 속도를 획기적으로 단축시켰고, 모델 크기를 키우는 경쟁을 가능하게 했다.</li>
</ul>
<h3>2.3  하드웨어-알고리즘 공진화 (Co-evolution)</h3>
<p>트랜스포머의 성공은 단순히 소프트웨어가 하드웨어에 맞춘 결과만은 아니다. 하드웨어 제조사(주로 NVIDIA) 역시 트랜스포머를 더 잘 돌리기 위해 하드웨어를 진화시켰다.</p>
<ul>
<li><strong>전용 연산기:</strong> 텐서 코어는 세대를 거듭하며 트랜스포머 학습에 필요한 데이터 타입(BF16, FP8)을 지원하기 시작했다.</li>
<li><strong>메모리 아키텍처:</strong> 트랜스포머 모델이 커짐에 따라 GPU 메모리 용량과 대역폭은 기하급수적으로 증가했다(HBM2 -&gt; HBM3 -&gt; HBM3e).</li>
<li><strong>소프트웨어 최적화:</strong> FlashAttention과 같은 알고리즘은 GPU의 메모리 계층 구조(SRAM vs HBM)를 고려하여 메모리 접근 횟수를 줄이는 방식으로, 하드웨어 특성을 역이용해 속도를 높였다.13</li>
</ul>
<p>결론적으로, 트랜스포머와 GPU는 서로를 위해 최적화된 “승자의 연합“을 형성했다. 이 강력한 결합은 AI 연구의 자원을 블랙홀처럼 빨아들이며, 다른 형태의 알고리즘 연구가 설 자리를 좁히고 있다.</p>
<h2>3.  로봇 알고리즘의 하드웨어 부적합성 I: 강화학습(RL)과 실시간 제어의 딜레마</h2>
<p>트랜스포머가 누리는 풍요와 달리, 로봇 제어의 핵심인 강화학습(RL)은 현대 GPU 하드웨어 환경에서 심각한 비효율성과 싸우고 있다. 이는 단순히 성능 최적화의 문제가 아니라, 로봇이 작동하는 방식과 GPU가 작동하는 방식 사이의 근본적인 철학적 충돌에서 기인한다.</p>
<h3>3.1  순차적 의사결정(Sequential Decision Making)과 Batch Size 1의 저주</h3>
<p>강화학습, 특히 로봇 제어(Robotic Control)에 적용되는 RL은 학습(Training) 단계와 추론(Inference/Execution) 단계의 하드웨어 요구사항이 극단적으로 비대칭적이다. 학습 시에는 시뮬레이션에서 수천 개의 에이전트를 동시에 돌리며 배치를 구성할 수 있지만, 실제 로봇에 배포되었을 때는 상황이 달라진다.</p>
<h4>3.1.1  인과율(Causality)에 묶인 로봇</h4>
<p>로봇은 매 순간 센서 데이터를 받아 판단하고 액추에이터에 명령을 내려야 한다. 이 과정은 엄격한 인과율의 지배를 받는다. 현재의 행동(Action)이 수행되어야만 환경이 변하고, 비로소 다음 상태(State)를 관측할 수 있다.</p>
<ul>
<li><strong>Batch Size 1 문제:</strong> 실시간 로봇 제어 루프에서는 한 번에 하나의 관측(Observation)만이 들어온다. 즉, 강제적으로 ’배치 크기 = 1’인 상황이 발생한다.6</li>
<li><strong>GPU의 유휴 상태(Idle):</strong> GPU는 수천 개의 데이터를 한꺼번에 처리할 때 효율적이도록 설계되었다. 배치 크기가 1일 때, GPU의 수천 개 코어 중 극히 일부만 사용되고 나머지는 유휴 상태로 대기하게 된다. 이는 마치 대형 버스(GPU)에 승객 한 명(데이터)만 태우고 운행하는 것과 같은 비효율이다.</li>
</ul>
<h4>3.1.2  메모리 대역폭의 낭비와 낮은 산술 강도</h4>
<p>배치 크기가 1일 때 발생하는 더 심각한 문제는 ‘메모리 바운드(Memory Bound)’ 현상이다.</p>
<ul>
<li>최신 RL 모델(특히 픽셀 입력을 받는 Vision-based RL)은 수백 메가바이트(MB) 이상의 가중치(Parameters)를 가진다.</li>
<li>추론을 한 번 수행하기 위해 GPU는 이 거대한 가중치 전체를 VRAM에서 연산 유닛(SRAM/Register)으로 불러와야 한다.</li>
<li>하지만 로봇의 입력 데이터(센서값)는 고작 수 킬로바이트(KB)에 불과하다.</li>
<li>결과적으로 GPU는 연산(Compute)보다 데이터를 옮기는(Data Movement) 데 대부분의 시간과 에너지를 소비한다. 산술 강도가 극도로 낮아지며, 루프라인 모델 상에서 최악의 효율 영역에 위치하게 된다.7</li>
</ul>
<h3>3.2  Sim-to-Real 하드웨어 격차: 서버에서 엣지로의 추락</h3>
<p>RL 모델은 주로 엔비디아 A100이나 H100과 같은 고성능 서버급 GPU 클러스터에서 학습된다. 이곳에서는 대규모 병렬 시뮬레이션(Isaac Gym 등)을 통해 수십억 단계의 경험을 빠르게 학습한다. 하지만 학습된 정책(Policy)이 실제로 탑재되는 곳은 로봇 내부의 열악한 임베디드 보드(Jetson Orin, Xavier, Raspberry Pi)이다.</p>
<h4>3.2.1  지연 시간(Latency)과 실시간성(Real-time Constraints)</h4>
<p>서버 환경에서는 처리량(Throughput)이 중요하지만, 로봇 제어에서는 지연 시간(Latency)이 생명이다. 로봇 팔이나 드론, 4족 보행 로봇은 500Hz에서 1kHz 이상의 제어 주기를 요구한다. 즉, 센서 입력부터 모터 명령 출력까지 1~2ms 이내에 완료되어야 한다.16</p>
<ul>
<li><strong>커널 런칭 오버헤드(Kernel Launch Overhead):</strong> GPU에서 연산을 수행하려면 CPU가 GPU에게 명령을 내려야 하는데, 이 과정(커널 런칭) 자체에 수 마이크로초에서 수십 마이크로초가 소요된다. 거대 모델 추론 시에는 이 시간이 무시할 만하지만, 아주 작은 연산을 매우 자주 수행해야 하는 고빈도 제어 루프에서는 이 오버헤드가 전체 실행 시간의 상당 부분을 차지하는 ‘배보다 배꼽이 더 큰’ 상황이 발생한다.9</li>
<li><strong>지터(Jitter):</strong> GPU의 스케줄링 방식이나 OS의 인터럽트 등으로 인해 연산 완료 시간이 들쭉날쭉할 수 있다. 이는 정밀한 제어를 방해하는 치명적인 요소이다.</li>
</ul>
<h4>3.2.2  모델 경량화의 딜레마</h4>
<p>엣지 디바이스의 메모리와 전력 제약으로 인해, 연구자들은 학습된 거대 모델을 가지치기(Pruning)하거나 양자화(Quantization)해야 한다.19</p>
<ul>
<li>그러나 이는 모델의 성능(성공률) 저하를 야기할 수 있다. 특히 복잡한 조작(Manipulation) 작업에서는 미세한 정밀도가 중요한데, INT8 양자화 과정에서 정보 손실이 발생하여 시뮬레이션에서는 성공했던 작업이 실제 로봇에서는 실패하는 원인이 된다. 이는 하드웨어 제약이 알고리즘의 잠재력을 갉아먹는 전형적인 사례이다.</li>
</ul>
<h3>3.3  하드웨어 복권의 영향: MPC의 생존과 RL의 고전</h3>
<p>이러한 하드웨어적 제약은 로봇 제어 분야에서 **모델 예측 제어(Model Predictive Control, MPC)**가 여전히 강력한 지위를 유지하는 이유를 설명해준다.</p>
<ul>
<li>MPC는 최적화 문제를 푸는 과정으로, CPU의 캐시 구조와 분기 예측 기능을 잘 활용하도록 최적화되어 왔다.</li>
<li>반면 RL은 GPU 가속이 필수적인데, 엣지단에서의 비효율성 때문에 현장 적용이 지연되고 있다. 최근에는 RL로 MPC의 비용 함수를 학습하거나, RL을 상위 계획(Planner)에만 쓰고 하위 제어는 MPC에 맡기는 하이브리드 방식이 대안으로 제시되고 있다.21 이는 RL이 아직 로봇 하드웨어 복권에서 완전히 승리하지 못했음을 보여주는 방증이다.</li>
</ul>
<h2>4.  로봇 알고리즘의 하드웨어 부적합성 II: Visual SLAM과 희소성(Sparsity)의 역설</h2>
<p>로봇이 시각 정보를 통해 자신의 위치를 파악하고 지도를 그리는 VSLAM(Visual SLAM) 기술 역시 GPU와의 관계가 껄끄럽다. VSLAM이 다루는 데이터의 본질적 특성인 ’희소성(Sparsity)’과 ’비정형성(Irregularity)’이 GPU의 병렬 처리 구조와 충돌하기 때문이다.</p>
<h3>4.1  희소 데이터(Sparse Data)와 비효율적 메모리 접근</h3>
<p>LiDAR 포인트 클라우드나 이미지에서 추출된 특징점(Feature Points)은 3차원 공간상에서 매우 희소하게 분포한다. 이는 꽉 채워진 2차원 이미지 픽셀(Dense Data)과는 전혀 다른 성질을 가진다.</p>
<h4>4.1.1  비응집 메모리 접근 (Uncoalesced Memory Access)</h4>
<p>GPU는 인접한 메모리 주소를 한 번에 묶어서 읽어오는 ’메모리 응집(Coalescing)’을 통해 성능을 낸다.</p>
<ul>
<li><strong>VSLAM의 문제:</strong> 희소 특징점이나 포인트 클라우드는 메모리상에 불연속적으로 저장된다. 알고리즘이 “주변의 이웃 점들을 찾아라“라고 명령할 때, GPU 스레드들은 메모리의 여기저기 흩어진 주소를 제각각 참조하게 된다(Gather/Scatter 패턴).</li>
<li><strong>성능 저하:</strong> 이는 메모리 컨트롤러에 막대한 부하를 주며, 유효 대역폭을 급격히 떨어뜨린다. 마치 택배 기사가 아파트 단지(Dense)를 돌며 배달하는 것(GPU 선호)과, 전국 각지의 산간 오지(Sparse)를 돌며 배달하는 것(VSLAM 현실)의 차이와 같다.24</li>
</ul>
<h4>4.1.2  번들 조정(Bundle Adjustment)의 병목</h4>
<p>VSLAM의 핵심인 번들 조정(BA)은 카메라의 포즈와 3D 포인트의 위치를 동시에 최적화하는 과정이다. 이는 거대한 비선형 최소제곱 문제를 푸는 것으로, 야코비안(Jacobian) 행렬과 헤시안(Hessian) 행렬을 다룬다.</p>
<ul>
<li>이 행렬들은 극도로 희소하다(Sparse Matrix). 대부분의 원소가 0이다.</li>
<li>희소 행렬 연산(SpMV, SpMM)은 GPU에서 구현하기 매우 까다롭다. 0이 아닌 원소의 위치를 찾는 인덱싱 오버헤드가 크고, 부하 불균형(Load Imbalance)이 발생하기 쉽다. 트랜스포머의 고밀도 행렬 연산과 정반대 성격이다.26</li>
</ul>
<h3>4.2  워프 다이버전스(Warp Divergence): 병렬성의 붕괴</h3>
<p>SLAM 알고리즘, 특히 특징점 기반(Feature-based) 방식은 수많은 조건문과 예외 처리를 포함한다.</p>
<ul>
<li>예: “이 특징점이 이전 프레임과 매칭되는가?”, “RANSAC 과정에서 이 매칭은 인라이어(Inlier)인가 아웃라이어(Outlier)인가?”</li>
</ul>
<h4>4.2.1  조건부 분기와 실행 경로의 분리</h4>
<p>GPU의 워프(32개 스레드)는 군대처럼 동일한 명령을 수행해야 한다. 하지만 SLAM에서는 데이터마다 처리 경로가 달라진다.</p>
<ul>
<li><strong>워프 다이버전스 발생:</strong> 워프 내의 32개 스레드 중 16개는 매칭 성공(<code>if</code> 분기), 나머지 16개는 매칭 실패(<code>else</code> 분기)인 경우를 가정해보자. SIMT 구조상 GPU는 <code>if</code> 블록을 실행하는 동안 <code>else</code>에 해당하는 스레드들을 멈춰 세우고(Masking), 그 다음 <code>else</code> 블록을 실행할 때 반대로 <code>if</code> 스레드들을 멈춘다.</li>
<li><strong>결과:</strong> 두 경로의 실행 시간을 합친 만큼 시간이 소요되며, 실제 하드웨어 활용률은 50% 이하로 떨어진다. 조건문이 복잡할수록 성능 저하는 기하급수적으로 커진다.9</li>
</ul>
<h3>4.3  하드웨어 복권이 바꾼 알고리즘: Sparse에서 Dense로의 강제적 이주</h3>
<p>흥미로운 점은 이러한 하드웨어적 제약이 SLAM 알고리즘의 유행 자체를 바꾸고 있다는 사실이다.</p>
<ul>
<li><strong>과거:</strong> ORB-SLAM과 같은 희소 특징점 방식이 주류였다. 이는 계산량이 적고 기하학적으로 효율적이지만, CPU 의존도가 높고 GPU 가속이 어렵다.26</li>
<li><strong>현재:</strong> NeRF(Neural Radiance Fields)나 3D Gaussian Splatting을 활용한 <strong>Dense SLAM</strong>이 급부상하고 있다.32</li>
<li><strong>Dense SLAM의 부상 이유:</strong> NeRF나 Gaussian Splatting은 공간을 희소한 점이 아니라, 신경망 가중치나 대량의 가우시안 분포(Dense Representation)로 표현한다. 렌더링 과정은 픽셀마다 독립적인 연산을 수행하므로 GPU의 병렬 처리 능력과 완벽하게 맞아떨어진다.</li>
<li><strong>하드웨어에 의한 선택:</strong> 기하학적으로는 희소 특징점 방식이 더 효율적일 수 있음에도(필요한 정보만 처리하므로), GPU라는 하드웨어가 Dense한 연산을 압도적으로 빠르게 처리해주기 때문에 연구 트렌드가 Dense SLAM으로 이동하고 있다. 이것이야말로 사라 후커가 말한 “하드웨어 복권“의 전형적인 사례이다. 알고리즘의 내재적 우수성보다 하드웨어 적합성이 승패를 가르고 있는 것이다.</li>
</ul>
<h2>5.  하드웨어 제약이 빚어낸 알고리즘 생태계의 편향</h2>
<p>로봇 알고리즘과 GPU 간의 불일치는 단순한 성능 저하에 그치지 않고, 로봇 공학 연구 생태계 전반에 구조적인 편향(Bias)을 만들어내고 있다. 이는 연구자들이 어떤 문제를 풀 것인지, 어떤 방법론을 선택할지까지 결정하는 보이지 않는 손으로 작용한다.</p>
<h3>5.1  “SOTA(State-of-the-Art)“의 함정과 벤치마크 복권</h3>
<p>현재 AI 및 로봇 연구 성과는 주로 표준화된 벤치마크에서의 점수로 평가된다. 그러나 이 벤치마크들조차 GPU 친화적인 모델에 유리하게 구성되어 있을 가능성이 높다. 이를 **“벤치마크 복권(Benchmark Lottery)”**이라고 부른다.36</p>
<ul>
<li><strong>하드웨어 적합성이 성능으로 둔갑:</strong> 특정 알고리즘이 벤치마크에서 SOTA를 달성했을 때, 그것이 정말로 “지능적으로 더 우수한” 것인지, 아니면 단순히 “A100 GPU 8개를 병렬로 돌리기에 더 적합해서 더 많은 데이터를 학습할 수 있었던 것인지” 구분하기 어렵다.</li>
<li><strong>대안적 방법론의 소외:</strong> 예를 들어, 스파이킹 신경망(Spiking Neural Networks, SNN)은 로봇과 같이 이벤트 기반(Event-based)의 희소한 데이터를 처리하고 초저전력으로 작동하는 데 이론적으로 훨씬 우월하다. 그러나 SNN을 효율적으로 가속할 수 있는 하드웨어(뉴로모픽 칩)가 대중화되지 않았고, 기존 GPU에서는 SNN 시뮬레이션이 매우 비효율적이다. 그 결과 SNN은 주류 연구에서 밀려나 있으며, GPU에서 잘 돌아가는 트랜스포머 기반의 로봇 모델(VLA 등)만이 각광받고 있다.15</li>
</ul>
<h3>5.2  알고리즘의 획일화: 모든 것이 트랜스포머가 되다</h3>
<p>하드웨어 제약은 로봇 알고리즘의 다양성을 해치고 획일화를 부추긴다.</p>
<ul>
<li><strong>Robot Transformer의 등장:</strong> 구글의 RT-1, RT-2와 같은 모델은 로봇 제어 문제를 “토큰 예측 문제“로 치환하여 트랜스포머를 적용했다. 이는 로봇 제어의 본질적인 특성(동역학, 연속성)을 무시하는 측면이 있지만, GPU의 연산 능력을 등에 업고 압도적인 성능을 보여주었다.</li>
<li><strong>연구의 쏠림:</strong> 이제 로봇 연구자들은 로봇 고유의 제어 이론을 깊게 파기보다는, 어떻게 하면 로봇 데이터를 트랜스포머가 먹을 수 있는 형태로 바꿀지(Tokenization)를 고민한다. 이는 단기적으로는 성과를 내지만, 장기적으로는 로봇 기술이 GPU라는 특정 하드웨어 아키텍처에 종속되는 결과를 낳을 수 있다.</li>
</ul>
<h2>6.  미래의 방향: 공동 설계(Co-design)와 새로운 하드웨어 복권</h2>
<p>현재의 GPU 독주 체제가 영원할 수는 없다. 로봇 공학의 요구사항(저전력, 저지연, 희소 데이터 처리)을 충족시키기 위해, 하드웨어와 알고리즘을 동시에 설계하는 <strong>공동 설계(Co-design)</strong> 움직임이 가속화되고 있다. 이는 새로운 하드웨어 복권을 준비하는 과정이다.</p>
<h3>6.1  FPGA와 맞춤형 가속기: 유연성의 부활</h3>
<p>FPGA(Field-Programmable Gate Array)는 회로를 소프트웨어처럼 프로그래밍할 수 있는 반도체이다. 이는 RL의 불규칙한 데이터 흐름이나 VSLAM의 희소 연산에 딱 맞는 파이프라인을 하드웨어 레벨에서 구축할 수 있게 해준다.</p>
<ul>
<li><strong>지연 시간 해결:</strong> FPGA는 데이터를 메모리에 저장했다가 다시 읽는 과정 없이, 스트리밍 방식으로 처리(Dataflow Architecture)할 수 있어 RL의 지연 시간 문제를 근본적으로 해결할 수 있다.</li>
<li><strong>희소성 지원:</strong> 희소 행렬 연산 로직을 전용 회로로 구현하여 GPU의 워프 다이버전스 문제 없이 높은 효율을 달성할 수 있다.38 최근 딥러닝 가속을 위한 NPU(Neural Processing Unit)들도 희소성 지원(Sparsity Support)을 핵심 기능으로 탑재하고 있다.</li>
</ul>
<h3>6.2  뉴로모픽 컴퓨팅(Neuromorphic Computing): 생체를 닮은 하드웨어</h3>
<p>인텔의 Loihi 2와 같은 뉴로모픽 칩은 폰 노이만 구조를 탈피하여 뇌의 신경망 구조를 모방한다.</p>
<ul>
<li><strong>이벤트 기반 처리:</strong> 데이터가 발생할 때만 전력을 소모하며, 스파이크 신호를 통해 비동기적으로 통신한다. 이는 로봇의 이벤트 카메라(Event Camera) 데이터 처리나 SNN 기반 제어에 혁명적인 효율성을 가져올 수 있다.41</li>
<li><strong>아직은 당첨 대기 중:</strong> 하드웨어는 등장했지만, 이를 지원할 컴파일러나 알고리즘 라이브러리가 아직 부족하다. 이 생태계가 성숙해지는 순간, 로봇 분야의 새로운 하드웨어 복권 당첨자가 될 잠재력이 있다.</li>
</ul>
<h3>6.3  결론: 하드웨어를 이해하는 자가 승리한다</h3>
<p>“4.2.1 알고리즘과 하드웨어의 적합성“을 통해 우리는 기술의 승패가 단순히 지능의 구현 능력뿐만 아니라, **‘누가 당대의 하드웨어 특성을 더 잘 활용하는가’**에 달려 있음을 확인했다. 트랜스포머는 GPU의 병렬 연산 구조에 완벽히 부합하여 승자가 되었고, 로봇 알고리즘들은 그 구조적 불일치로 인해 고전하고 있다.</p>
<p>로봇 공학자들에게 주어진 과제는 이중적이다.</p>
<ol>
<li><strong>단기적 적응:</strong> 현재의 하드웨어(GPU) 특성을 깊이 이해하여, 로봇 알고리즘을 GPU 친화적인 형태(Dense Representation, Batch Processing)로 변형하고 최적화해야 한다. (예: Dense SLAM, Transformer-based Control)</li>
<li><strong>장기적 혁신:</strong> GPU의 틀에 갇히지 않고, 로봇의 본질에 맞는 새로운 컴퓨팅 패러다임(Neuromorphic, FPGA)을 적극적으로 탐색하고 이들과 알고리즘을 함께 발전(Co-design)시켜야 한다.</li>
</ol>
<p>하드웨어 복권은 운에 의해 결정되는 것처럼 보이지만, 그 복권의 당첨 번호를 예측하고 준비하는 것은 연구자의 몫이다. 차세대 로봇 기술의 패권은 하드웨어의 물리적 제약을 가장 현명하게 극복하거나, 혹은 그 제약을 역이용하는 진영이 차지하게 될 것이다.</p>
<p><strong>표 4.2.1-1. Transformer와 로봇 알고리즘(RL/SLAM)의 하드웨어 적합성 상세 비교</strong></p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Transformer (LLM)</strong></th><th><strong>로봇 강화학습 (RL)</strong></th><th><strong>Visual SLAM</strong></th><th><strong>GPU 적합성 분석</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 연산</strong></td><td>고밀도 행렬 곱셈 (Dense GEMM)</td><td>소규모 행렬-벡터 곱 (GEMV)</td><td>희소 행렬 연산, 기하 변환</td><td><strong>Transformer 최적</strong> (GPU는 GEMM 가속기임)</td></tr>
<tr><td><strong>데이터 처리 단위</strong></td><td>대규모 배치 (Batch Processing)</td><td>단일 데이터 (Batch Size = 1)</td><td>비정형 포인트 클라우드</td><td><strong>Transformer 최적</strong> (GPU 처리량 극대화)</td></tr>
<tr><td><strong>메모리 접근 패턴</strong></td><td>규칙적, 연속적 (Coalesced)</td><td>불규칙적 (Weights &gt;&gt; Inputs)</td><td>임의 접근 (Gather/Scatter)</td><td><strong>Transformer 최적</strong> (대역폭 효율 100% 활용)</td></tr>
<tr><td><strong>실행 흐름 (Control Flow)</strong></td><td>일관된 파이프라인 (SIMT 친화적)</td><td>순차적 의존성 (Sequential)</td><td>잦은 조건문 분기 (Divergent)</td><td><strong>Transformer 최적</strong> (워프 다이버전스 없음)</td></tr>
<tr><td><strong>주요 병목 현상</strong></td><td>연산량 (Compute Bound)</td><td>메모리 대역폭 &amp; 지연 시간 (Latency)</td><td>메모리 지연 &amp; 분기 예측</td><td><strong>로봇 알고리즘 불리</strong> (GPU는 Latency에 취약)</td></tr>
<tr><td><strong>대표 하드웨어</strong></td><td>H100, TPU (Cloud)</td><td>Jetson, CPU, FPGA (Edge)</td><td>CPU, FPGA, DSP</td><td><strong>불일치 심화</strong> (Sim-to-Real Gap)</td></tr>
</tbody></table>
<h2>7. 참고 자료</h2>
<ol>
<li>The Hardware Lottery: Sara Hooker | PDF | Graphics Processing Unit, https://www.scribd.com/document/490478747/2009-06489</li>
<li>The Hardware Lottery, https://hardwarelottery.github.io/</li>
<li>(PDF) The Hardware Lottery - ResearchGate, https://www.researchgate.net/publication/344244795_The_Hardware_Lottery</li>
<li>Flavour Tagging and Monolithic Pixel Sensors at the FCC-ee - PUBDB, https://bib-pubdb1.desy.de/record/637692/files/thesis_ploerer.pdf?subformat=pdfa</li>
<li>Towards Hardware Accelerated Reinforcement Learning for …, https://www.doc.ic.ac.uk/~wl/papers/18/asap18ss.pdf</li>
<li>OpenVLA finetuning with online RL | Haonan’s blog, https://www.haonanyu.blog/post/openvla_rl/</li>
<li>Characterizing Reasoning LLM Deployment on Edge GPUs - arXiv, https://arxiv.org/html/2511.01866v1</li>
<li>Inside NVIDIA GPUs: Anatomy of high performance matmul kernels, https://www.aleksagordic.com/blog/matmul</li>
<li>The Parallel Paradigm Shift: A Comprehensive Analysis of GPU …, https://uplatz.com/blog/the-parallel-paradigm-shift-a-comprehensive-analysis-of-gpu-architecture-programming-models-and-algorithmic-optimization/</li>
<li>Exploiting Inter-Warp Heterogeneity to Improve GPGPU Performance, https://users.ece.cmu.edu/~omutlu/pub/MeDiC-for-GPGPUs_pact15.pdf</li>
<li>An Integrated FPGA Accelerator for Deep Learning-Based 2D/3D …, https://ieeexplore.ieee.org/iel7/12/10527219/10474486.pdf</li>
<li>Cooperative Design of Machine Learning and GPU-Based Systems …, https://escholarship.org/content/qt3k28x4dz/qt3k28x4dz_noSplash_ce08db4f6ff3eaac5eb721d0c988a34f.pdf</li>
<li>T3: Transparent Tracking &amp; Triggering for Fine-grained Overlap of …, https://arxiv.org/html/2401.16677v1</li>
<li>Improving GEMM Kernel Auto-Tuning Efficiency on NVIDIA GPUs …, https://developer.nvidia.com/blog/improving-gemm-kernel-auto-tuning-efficiency-on-nvidia-gpus-with-heuristics-and-cutlass-4-2/</li>
<li>Harnessing Manycore Processors with Distributed Memory for …, https://ojs.aaai.org/index.php/AAAI/article/view/29087/30056</li>
<li>xLSTM Enables Fast Inference for Robotics Tasks - GitHub, https://raw.githubusercontent.com/mlresearch/v267/main/assets/schmied25a/schmied25a.pdf</li>
<li>(PDF) Towards Latency Efficient DRL Inference: Improving UAV …, https://www.researchgate.net/publication/382489831_Towards_Latency_Efficient_DRL_Inference_Improving_UAV_Obstacle_Avoidance_at_the_Edge_Through_Model_Compression</li>
<li>Customizing LLMs for Efficient Latency-Aware Inference at the Edge, https://www.usenix.org/system/files/atc25-tian.pdf</li>
<li>Algorithm-Hardware Co-Design of Distribution-Aware Logarithmic …, https://www.researchgate.net/publication/385646623_Algorithm-Hardware_Co-Design_of_Distribution-Aware_Logarithmic-Posit_Encodings_for_Efficient_DNN_Inference</li>
<li>FERO: Efficient Deep Reinforcement Learning based UAV Obstacle …, https://ieeexplore.ieee.org/iel8/8782664/10834807/11130910.pdf</li>
<li>Reinforced model predictive control (RL-MPC) for building … - Lirias, https://lirias.kuleuven.be/retrieve/647112</li>
<li>Model Predictive Control With Reinforcement Learning-Based …, https://ieeexplore.ieee.org/iel8/6287639/10820123/10909478.pdf</li>
<li>Reinforcement learning and model predictive control for robust …, https://www.researchgate.net/publication/330348090_Reinforcement_learning_and_model_predictive_control_for_robust_embedded_quadrotor_guidance_and_control</li>
<li>The Ubiquitous Sparse Matrix-Matrix Products - arXiv, https://arxiv.org/html/2508.04077v1</li>
<li>Algorithmic and parametric choices and of a general point cloud …, https://www.researchgate.net/figure/Algorithmic-and-parametric-choices-and-of-a-general-point-cloud-registration-pipeline_tbl1_336457586</li>
<li>MSF-SLAM: Enhancing Dynamic Visual SLAM with Multi-Scale …, https://www.mdpi.com/2076-3417/15/9/4735</li>
<li>Improving Accuracy and Computational Burden of Bundle …, https://www.scirp.org/journal/paperinformation?paperid=128766</li>
<li>GPZ: GPU-Accelerated Lossy Compressor for Particle Data - arXiv, https://arxiv.org/html/2508.10305v1</li>
<li>Efficient Sparse Voxel Octrees – Analysis, Extensions, and …, https://research.nvidia.com/sites/default/files/pubs/2010-02_Efficient-Sparse-Voxel/laine2010tr1_paper.pdf</li>
<li>Performance analysis and optimization of highly diverging … - OPUS, https://opus4.kobv.de/opus4-uni-koblenz/files/2161/schwanekamp_2021_optimization.pdf</li>
<li>MASt3R-SLAM: Real-Time Dense SLAM with 3D Reconstruction, https://learnopencv.com/mast3r-slam-realtime-dense-slam-explained/</li>
<li>GSFusion:Globally Optimized LiDAR-Inertial-Visual Mapping … - arXiv, https://arxiv.org/html/2507.23273v1</li>
<li>GSFusion:Globally Optimized LiDAR-Inertial-Visual Mapping for …, https://chatpaper.com/paper/172226</li>
<li>SLAM-Former: Putting SLAM into One Transformer - arXiv, https://arxiv.org/html/2509.16909v1</li>
<li>3D-Vision-World/awesome-NeRF-and-3DGS-SLAM - GitHub, https://github.com/3D-Vision-World/awesome-NeRF-and-3DGS-SLAM</li>
<li>arXiv:2107.07002v1 [cs.LG] 14 Jul 2021, https://arxiv.org/pdf/2107.07002</li>
<li>The Benchmark Lottery - OpenReview, https://openreview.net/pdf?id=5Str2l1vmr-</li>
<li>6 Hardware-Aware Execution, https://www.doc.ic.ac.uk/~cg1710/pub/2023/mlrc23cg.pdf</li>
<li>Balancing Performance and Cost—FPGA-Based CNN Accelerators …, https://ieeexplore.ieee.org/iel8/6287639/10820123/11105416.pdf</li>
<li>A survey on FPGA-based accelerator for ML models This work was …, https://arxiv.org/html/2412.15666v1</li>
<li>Neuromorphic Computing 2025: Current SotA - human / unsupervised, https://humanunsupervised.com/papers/neuromorphic_landscape.html</li>
<li>A DIAGONAL STRUCTURED STATE SPACE MODEL ON LOIHI 2 …, https://openreview.net/pdf/0978c21ea95442d247a9f0185f930e0b45dd9806.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>