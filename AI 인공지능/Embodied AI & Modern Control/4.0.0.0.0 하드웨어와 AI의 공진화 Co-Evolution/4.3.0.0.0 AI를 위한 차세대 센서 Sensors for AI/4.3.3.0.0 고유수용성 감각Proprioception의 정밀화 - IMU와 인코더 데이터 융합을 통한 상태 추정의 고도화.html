<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.3.3 고유수용성 감각(Proprioception)의 정밀화: IMU와 인코더 데이터 융합을 통한 상태 추정의 고도화</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.3.3 고유수용성 감각(Proprioception)의 정밀화: IMU와 인코더 데이터 융합을 통한 상태 추정의 고도화</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="../../index.html">제목: Embodied AI & Modern Control</a> / <a href="../index.html">Chapter 4. 하드웨어와 AI의 공진화 (Co-Evolution)</a> / <a href="index.html">4.3 AI를 위한 차세대 센서 (Sensors for AI)</a> / <span>4.3.3 고유수용성 감각(Proprioception)의 정밀화: IMU와 인코더 데이터 융합을 통한 상태 추정의 고도화</span></nav>
                </div>
            </header>
            <article>
                <h1>4.3.3 고유수용성 감각(Proprioception)의 정밀화: IMU와 인코더 데이터 융합을 통한 상태 추정의 고도화</h1>
<h2>1.  서론: 로봇 자율성의 근간, 고유수용성 감각의 심층적 재정의</h2>
<h3>1.1  자율 시스템에서의 고유수용성 감각의 위상</h3>
<p>로봇 공학, 특히 다리와 같은 관절 구조를 갖춘 보행 로봇(Legged Robot)이나 복잡한 환경에서 작동하는 모바일 매니퓰레이터(Mobile Manipulator)의 제어에 있어 가장 근본적인 질문은 “나는 지금 어디에 있으며, 내 신체는 어떤 상태인가?“로 귀결된다. 이를 **고유수용성 감각(Proprioception)**이라 정의하며, 이는 로봇이 외부 환경을 인지하는 외수용성 감각(Exteroception, 예: LiDAR, 카메라, 초음파 센서)과 구분되는 내재적 상태 인식 능력을 의미한다.1</p>
<p>시각 센서나 LiDAR와 같은 외수용성 센서는 ‘슬램(SLAM)’ 기술을 통해 지도 작성과 위치 인식을 가능하게 하지만, 연기가 자욱한 화재 현장, 조명이 없는 심해, 또는 특징점이 부족한 긴 터널과 같은 환경(Perceptually Degraded Environments)에서는 무용지물이 되기 쉽다. 반면, 고유수용성 감각은 외부 환경의 조건에 구애받지 않고 로봇 내부의 관성력과 기구학적 변화를 통해 자신의 상태를 추정하므로, 로봇 생존을 위한 최후의 보루이자 제어 루프의 가장 안쪽(Inner loop)을 담당하는 핵심 요소로 작용한다.2</p>
<h3>1.2  단순 융합을 넘어선 정밀화의 필요성</h3>
<p>초기의 로봇 상태 추정은 관성 측정 장치(IMU)와 휠/관절 인코더(Encoder)의 데이터를 단순히 결합하는 수준에 머물렀다. 그러나 로봇 하드웨어의 성능이 비약적으로 발전하여 백플립(Backflip)이나 파쿠르(Parkour)와 같은 고기동 동작이 요구됨에 따라, 단순한 센서 데이터의 선형적 결합만으로는 필요한 정밀도를 달성할 수 없게 되었다. 특히 다음과 같은 물리적, 수학적 난제들이 대두되었다.</p>
<ol>
<li><strong>IMU의 확률적 편향(Stochastic Bias):</strong> 저가형 MEMS 센서의 온도 변화 및 진동에 따른 예측 불가능한 편향 드리프트.4</li>
<li><strong>기구학적 불확실성과 미끄러짐(Slip):</strong> 다리 끝단(End-effector)이 지면에 완벽히 고정되지 않고 미세하게 미끄러질 때 발생하는 기구학적 오차의 누적.5</li>
<li><strong>유연한 구조의 변형(Soft/Flexible Dynamics):</strong> 소프트 로봇이나 고하중을 견디는 다리 링크의 탄성 변형으로 인한 모델 불일치.7</li>
</ol>
<p>본 장에서는 이러한 한계를 극복하고 고유수용성 감각을 극한으로 정밀화하기 위한 최신 방법론들을 심도 있게 분석한다. 구체적으로, **확장 칼만 필터(EKF)**의 기하학적 한계를 극복하는 <strong>불변 확장 칼만 필터(Invariant EKF, InEKF)</strong> 이론, 비선형 최적화를 위한 <strong>팩터 그래프(Factor Graph)</strong> 기반의 <strong>IMU 사전적분(Preintegration)</strong> 기법, 그리고 물리 모델의 불확실성을 데이터로 보정하는 <strong>학습 기반(Learning-aided) 상태 추정</strong>의 융합 메커니즘을 상세히 다룬다.</p>
<h2>2.  센서 데이터의 물리적 특성과 수학적 모델링의 심화</h2>
<p>정밀한 상태 추정 알고리즘을 설계하기 위해서는 각 센서가 생성하는 데이터의 물리적 특성, 오차의 근원, 그리고 이를 표현하는 수학적 모델에 대한 엄밀한 이해가 선행되어야 한다.</p>
<h3>2.1  관성 측정 장치(IMU): 고주파수 동역학의 핵심</h3>
<p>IMU는 로봇의 기저(Base) 링크에 부착되어 가속도와 각속도를 측정하며, 외부 레퍼런스 없이도 로봇의 자세(Attitude)와 속도 변화를 고주파수(수백 Hz ~ 수 kHz)로 추적할 수 있게 해주는 핵심 센서이다.1 하지만 IMU는 본질적으로 ‘미분된’ 물리량을 측정하므로, 이를 적분하여 위치와 자세를 얻는 과정에서 오차가 기하급수적으로 누적되는 특성을 가진다.</p>
<h4>2.1.1  IMU 측정 모델과 오차 요인</h4>
<p>IMU의 가속도계(<span class="math math-inline">\mathbf{a}_m</span>)와 자이로스코프(<span class="math math-inline">\boldsymbol{\omega}_m</span>) 측정값은 다음과 같은 연속 시간 모델로 표현된다8:<br />
<span class="math math-display">
\begin{aligned} \mathbf{a}_m(t) &amp;= \mathbf{R}_{WB}^T(t) (\mathbf{a}_W(t) - \mathbf{g}_W) + \mathbf{b}_a(t) + \mathbf{n}_a(t) \\ \boldsymbol{\omega}_m(t) &amp;= \boldsymbol{\omega}_B(t) + \mathbf{b}_\omega(t) + \mathbf{n}_\omega(t) \end{aligned}
</span><br />
여기서 각 변수의 의미는 다음과 같다.</p>
<ul>
<li><span class="math math-inline">\mathbf{R}_{WB}</span>: 월드 프레임(<span class="math math-inline">W</span>)에서 바디 프레임(<span class="math math-inline">B</span>)으로의 회전 행렬.</li>
<li><span class="math math-inline">\mathbf{a}_W</span>: 월드 프레임 기준 로봇의 실제 선형 가속도.</li>
<li><span class="math math-inline">\mathbf{g}_W</span>: 월드 프레임 기준 중력 가속도 벡터(일반적으로 <span class="math math-inline">[0, 0, -9.81]^T</span>).</li>
<li><span class="math math-inline">\mathbf{b}_a, \mathbf{b}_\omega</span>: 가속도계와 자이로스코프의 시간 가변적 편향(Bias).</li>
<li><span class="math math-inline">\mathbf{n}_a, \mathbf{n}_\omega</span>: 가우시안 백색 잡음(Gaussian White Noise).</li>
</ul>
<p>심층 분석: 브라운 운동(Brownian Motion)으로서의 편향</p>
<p>단순한 상수 편향과 달리, 실제 센서의 편향 <span class="math math-inline">\mathbf{b}(t)</span>는 시간에 따라 확률적으로 변하는 랜덤 워크(Random Walk) 과정을 따른다. 이는 센서 내부의 온도가 변하거나 기계적 응력이 가해질 때 발생하며, 이를 수학적으로는 브라운 운동의 도함수로 모델링한다.10<br />
<span class="math math-display">
\dot{\mathbf{b}}_a(t) = \mathbf{n}_{b_a}(t), \quad \dot{\mathbf{b}}_\omega(t) = \mathbf{n}_{b_\omega}(t)
</span><br />
여기서 <span class="math math-inline">\mathbf{n}*{b_a}, \mathbf{n}*{b_\omega}</span>는 편향의 변화율을 구동하는 잡음이다. Fink et al.2의 연구에 따르면, 고가의 광섬유 자이로(FOG) 기반 IMU(예: KVH-1775)와 저가의 MEMS IMU(예: 3DM-GX5-15)는 노이즈 특성(Allan Variance 등)에서 큰 차이를 보이지만, 적절한 센서 융합 알고리즘이 적용될 경우 최종 상태 추정 성능의 차이는 예상보다 미미할 수 있음이 보고되었다. 이는 알고리즘이 센서의 하드웨어적 한계를 얼마나 잘 보정할 수 있는지를 보여주는 중요한 사례이다.</p>
<h3>2.2  인코더 및 기구학: 상대적 위치 정보의 원천과 한계</h3>
<p>관절 인코더는 로봇의 관절 각도(<span class="math math-inline">\mathbf{q}</span>)와 관절 속도(<span class="math math-inline">\dot{\mathbf{q}}</span>)를 제공한다. 이를 순기구학(Forward Kinematics) 식에 대입하면, 로봇 기저에 대한 다리 끝단(Foot)의 상대적 위치(<span class="math math-inline">\mathbf{p}_{foot}^B</span>)와 속도를 계산할 수 있다.<br />
<span class="math math-display">
\mathbf{p}_{foot}^B = f_{kin}(\mathbf{q}), \quad \mathbf{v}_{foot}^B = \mathbf{J}(\mathbf{q})\dot{\mathbf{q}}
</span><br />
여기서 <span class="math math-inline">\mathbf{J}(\mathbf{q})</span>는 기구학적 자코비안(Jacobian) 행렬이다. 인코더 데이터는 IMU와 달리 발산하지 않는 특성을 가지지만, 다음과 같은 미세 오차 요인들을 내포하고 있다.</p>
<ol>
<li><strong>양자화 잡음 및 미분 잡음:</strong> 디지털 인코더의 해상도 한계로 인한 양자화 오차는 속도(<span class="math math-inline">\dot{\mathbf{q}}</span>)를 계산하기 위해 미분할 때 크게 증폭된다. 이를 억제하기 위해 저주파 통과 필터(LPF)를 사용하면 필연적으로 위상 지연(Phase Delay)이 발생하여 빠른 제어에 악영향을 준다.11</li>
<li><strong>유연성 및 변형(Compliance &amp; Deformation):</strong> 특히 소프트 로봇이나 험지를 주파하는 대형 로봇의 경우, 링크 자체가 힘을 받아 휘어지거나 관절부에 유격(Backlash)이 발생한다. 이 경우 이론적인 기구학 모델 <span class="math math-inline">f_{kin}(\mathbf{q})</span>과 실제 발 위치 사이에 괴리가 발생한다.7 최신 연구에서는 이러한 변형을 보정하기 위해 IMU를 다리 링크마다 부착하거나, 굽힘 센서(Bend sensor)를 추가하여 기구학적 모델을 실시간으로 수정하는 방법이 제안되고 있다.7</li>
</ol>
<h2>3.  확률론적 상태 추정의 고전적 접근: 확장 칼만 필터(EKF)의 적용과 구조적 한계</h2>
<p>지난 수십 년간 로봇 상태 추정의 표준(De facto standard)은 **확장 칼만 필터(EKF)**였다. EKF는 비선형 시스템을 국소적으로 선형화하여 가우시안 분포를 가정하고 상태를 추정하는 재귀적 알고리즘이다.4</p>
<h3>3.1  로봇 상태 추정을 위한 EKF 사이클</h3>
<p>보행 로봇의 고유수용성 상태 추정에서 EKF는 일반적으로 다음과 같은 ‘예측-보정’ 구조를 따른다.</p>
<h4>3.1.1  예측 단계 (Propagate/Predict)</h4>
<p>높은 주파수의 IMU 데이터를 적분하여 로봇의 위치, 속도, 자세를 예측한다. 이 과정은 시스템의 ’Process Model’에 해당한다.<br />
<span class="math math-display">
\hat{\mathbf{x}}_{k|k-1} = f(\hat{\mathbf{x}}_{k-1}, \mathbf{u}_{k-1})
</span><br />
여기서 상태 벡터 <span class="math math-inline">\mathbf{x}</span>는 일반적으로 <span class="math math-inline">^T</span> 등으로 구성된다. 예측 단계에서는 IMU의 노이즈 공분산(<span class="math math-inline">Q</span>)이 적분 과정을 통해 전파되어 상태 불확실성 공분산(<span class="math math-inline">P</span>)을 증가시킨다.</p>
<h4>3.1.2  보정 단계 (Update/Correct)</h4>
<p>예측된 상태를 외부 정보로 수정하는 단계이다. 고유수용성 추정에서는 주로 **기구학적 정보(Leg Odometry)**가 관측값으로 사용된다.<br />
<span class="math math-display">
\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</span><br />
가장 대표적인 기법은 **Zero Velocity Update (ZUPT)**이다. 로봇의 발이 지면에 닿아있는(Stance) 동안, 발 끝의 속도는 0이어야 한다는 물리적 제약조건을 가상의 관측값 <span class="math math-inline">\mathbf{v}_{foot} = 0</span>으로 활용하여, IMU 적분으로 인해 발산하는 속도 오차를 초기화한다.2<br />
<span class="math math-display">
\mathbf{K}_k = \mathbf{P}_{k|k-1}\mathbf{H}_k^T (\mathbf{H}_k\mathbf{P}_{k|k-1}\mathbf{H}_k^T + \mathbf{R}_k)^{-1}
</span></p>
<p><span class="math math-display">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_k(\mathbf{z}_k - h(\hat{\mathbf{x}}_{k|k-1}))
</span></p>
<h3>3.2  EKF의 구조적 한계와 비일관성(Inconsistency) 문제</h3>
<p>EKF는 널리 사용되지만, 고정밀 고유수용성 감각 구현에는 몇 가지 치명적인 한계가 존재한다.</p>
<ol>
<li><strong>선형화 오차 (Linearization Error):</strong> EKF는 현재 추정된 상태 <span class="math math-inline">\hat{\mathbf{x}}</span>를 기준으로 비선형 함수 <span class="math math-inline">f</span>와 <span class="math math-inline">h</span>를 1차 테일러 근사(Jacobian)한다. 만약 초기 추정치가 실제 값과 크게 다르거나 로봇이 급격하게 회전하는 등 비선형성이 큰 기동을 할 경우, 선형화 오차가 누적되어 필터가 실제 상태를 따라가지 못하고 발산할 수 있다.4</li>
<li><strong>관측 가능성(Observability)의 불일치:</strong> 실제 물리 시스템에서 절대적인 위치(Global Position)나 중력 축에 대한 회전(Yaw)은 GPS나 나침반 없이는 관측 불가능(Unobservable)하다. 즉, 이 값들에 대한 불확실성(Covariance)은 시간이 지남에 따라 줄어들지 않아야 한다. 그러나 표준 EKF는 선형화 과정에서 자코비안이 잘못 계산되어, 마치 관측 불가능한 상태들에 대한 정보를 얻은 것처럼 불확실성을 과도하게 축소시키는 현상(Spurious Information Gain)이 발생한다. 이는 필터의 **비일관성(Inconsistency)**을 초래하여 과신(Overconfidence)과 발산으로 이어진다.5</li>
<li><strong>동적 접촉 상황에서의 취약성:</strong> EKF의 보정 단계는 발이 지면에 완벽하게 고정되어 있다는 가정에 의존한다. 그러나 빙판길이나 모래와 같은 비정상 지형(Non-stationary terrain)에서 발이 미끄러질 경우(Slip), “속도가 0이다“라는 가정은 위배된다. 이 경우 EKF는 미끄러짐에 의한 속도를 로봇 자체의 이동으로 오인하여 심각한 위치 추정 드리프트를 발생시킨다.5</li>
</ol>
<hr />
<h2>4.  기하학적 정밀화: 불변 확장 칼만 필터 (Invariant EKF, InEKF)</h2>
<p>EKF의 선형화 문제와 관측 가능성 불일치 문제를 근본적으로 해결하기 위해 도입된 개념이 바로 **불변 확장 칼만 필터(Invariant EKF, InEKF)**이다. 이는 로봇의 상태 공간을 단순한 벡터 공간이 아닌 **매트릭스 리 군(Matrix Lie Group, <span class="math math-inline">SE(3)</span>)**으로 모델링함으로써 기하학적 대칭성을 활용한다.5</p>
<h3>4.1  리 군(Lie Group) 이론과 불변 오차의 정의</h3>
<p>InEKF의 핵심은 상태 오차를 산술적인 뺄셈(<span class="math math-inline">\hat{x} - x</span>)이 아닌, 리 군 상에서의 연산으로 정의하는 것이다. 이를 **불변 오차(Invariant Error)**라 하며, 다음과 같이 두 가지 형태로 정의된다.</p>
<ul>
<li><strong>우불변 오차 (Right-Invariant Error):</strong> <span class="math math-inline">\eta_R = \hat{X} X^{-1}</span></li>
<li><strong>좌불변 오차 (Left-Invariant Error):</strong> <span class="math math-inline">\eta_L = X^{-1} \hat{X}</span></li>
</ul>
<p>여기서 <span class="math math-inline">X</span>는 로봇의 회전(<span class="math math-inline">R</span>), 속도(<span class="math math-inline">v</span>), 위치(<span class="math math-inline">p</span>) 등을 포함하는 확장된 상태 행렬로, 주로 <span class="math math-inline">SE_2(3)</span> 군에 속한다. 예를 들어 <span class="math math-inline">SE_2(3)</span>의 원소 <span class="math math-inline">X</span>는 다음과 같이 표현된다.<br />
<span class="math math-display">
X = \begin{bmatrix} \mathbf{R} &amp; \mathbf{v} &amp; \mathbf{p} \\ \mathbf{0}_{1 \times 3} &amp; 1 &amp; 0 \\ \mathbf{0}_{1 \times 3} &amp; 0 &amp; 1 \end{bmatrix}
</span></p>
<h3>4.2  InEKF의 수학적 우위성: 로그-선형(Log-Linear) 동역학</h3>
<p>InEKF의 가장 강력한 특징은 오차 동역학(Error Dynamics)이 <strong>상태 추정치와 무관하게(State-independent)</strong> 유도된다는 점이다.</p>
<p>기존 EKF에서는 오차의 전파 과정이 현재 상태 <span class="math math-inline">\hat{X}</span>에 의존하는 자코비안 <span class="math math-inline">\mathbf{F}(\hat{X})</span>에 의해 결정되었다. 따라서 <span class="math math-inline">\hat{X}</span>가 틀리면 오차 추정 또한 엉망이 되었다. 그러나 InEKF에서는 불변 오차 <span class="math math-inline">\eta</span>의 동역학이 다음과 같이 **자율적(Autonomous)**인 미분 방정식 형태를 띤다.15<br />
<span class="math math-display">
\frac{d}{dt}\xi = \mathbf{A}\xi + \mathbf{w}, \quad \xi \in \mathfrak{se}_2(3)
</span><br />
여기서 <span class="math math-inline">\xi</span>는 리 대수(Lie Algebra) 상의 오차 벡터이며, 행렬 <span class="math math-inline">\mathbf{A}</span>는 시스템의 입력이나 추정 상태와 무관한 상수 행렬이거나 센서 입력에만 의존한다. 이를 <strong>‘Log-Linear’</strong> 성질이라 한다. 이 성질 덕분에 InEKF는 초기 오차가 매우 크더라도 시스템이 관측 가능하기만 하다면 **글로벌 수렴성(Global Convergence)**에 가까운 안정성을 보장한다. 이는 예측 불가능한 험지를 이동하며 큰 자세 변화를 겪는 보행 로봇에게 필수적인 특성이다.10</p>
<h3>4.3  접촉 지원 InEKF (Contact-Aided InEKF) 프레임워크</h3>
<p>Hartley et al.18은 InEKF를 보행 로봇에 적용하여 <strong>Contact-Aided InEKF</strong>를 제안하였다. 이 프레임워크의 핵심 아이디어는 발의 접촉 지점을 환경 랜드마크처럼 취급하되, 이를 상태 벡터에 포함시켜 불변 관측 모델(Invariant Observation Model)을 형성하는 것이다.</p>
<ul>
<li><strong>관측 모델의 불변화:</strong> 다리 기구학을 통해 계산된 발의 위치를 사용하여, 로봇의 상태 <span class="math math-inline">X</span>와 관측값 <span class="math math-inline">Y</span> 사이의 관계를 <span class="math math-inline">Y = X^{-1} b + V</span> (Right-Invariant) 형태나 <span class="math math-inline">Y = X b + V</span> (Left-Invariant) 형태로 만들어 선형화 오차를 제거한다.</li>
<li><strong>미끄러짐 및 외란 관측기(Disturbance Observer):</strong> InEKF 구조 내에 외란 관측기를 통합하여, 발의 미끄러짐을 속도 편차 항으로 모델링한다. 이를 통해 미끄러짐이 발생했을 때 필터가 이를 ’위치 이동’이 아닌 ’속도 바이어스’로 해석하도록 유도하여 위치 드리프트를 억제한다.12</li>
</ul>
<h2>5.  비동기 데이터와 지연의 극복: 팩터 그래프 최적화 (Factor Graph Optimization)</h2>
<p>필터 기반(EKF, InEKF) 방식은 실시간성(Real-time)에는 유리하지만, ’마르코프 가정(Markov Assumption)’에 묶여 있어 현재 시점의 추정이 과거의 모든 정보를 요약한다고 가정한다. 따라서 과거의 선형화 오차를 수정하거나 지연된 측정을 반영하기 어렵다. 이를 극복하기 위해 전체 궤적을 최적화하는 **팩터 그래프 최적화(Factor Graph Optimization, FGO)**가 대두되었다.14</p>
<h3>5.1  IMU 사전적분 (IMU Preintegration) 이론의 심화</h3>
<p>FGO를 적용할 때 가장 큰 기술적 장벽은 IMU 데이터의 높은 주파수(수백 Hz)와 최적화 주파수(수십 Hz) 간의 괴리이다. 그래프의 엣지(Edge)를 구성하기 위해 매 최적화 단계마다 수백 개의 IMU 데이터를 다시 적분하는 것은 계산적으로 불가능하다. 이를 해결하기 위해 Forster et al.21은 <strong>IMU 사전적분(Preintegration)</strong> 이론을 정립하였다.</p>
<h4>5.1.1  사전적분 측정 모델과 잔차(Residual)</h4>
<p>사전적분의 핵심은 두 키프레임(Keyframe) <span class="math math-inline">i</span>와 <span class="math math-inline">j</span> 사이의 IMU 적분항을 초기 상태(속도, 자세)와 분리하여, **상대적인 움직임(Relative Motion)**만을 미리 계산해두는 것이다.</p>
<p>Forster의 이론에 따르면, 사전적분된 회전(<span class="math math-inline">\Delta \tilde{R}_{ij}</span>), 속도(<span class="math math-inline">\Delta \tilde{v}_{ij}</span>), 위치(<span class="math math-inline">\Delta \tilde{p}_{ij}</span>)는 다음과 같이 정의된다.<br />
<span class="math math-display">
\Delta \tilde{R}_{ij} = \prod_{k=i}^{j-1} \text{Exp}((\tilde{\boldsymbol{\omega}}_k - \mathbf{b}_{\omega_i})\Delta t)
</span><br />
이때 최적화 과정에서 바이어스 <span class="math math-inline">\mathbf{b}</span>가 업데이트되더라도 전체를 재적분하지 않기 위해, 바이어스에 대한 자코비안 <span class="math math-inline">\mathbf{J}{b}</span>을 이용하여 1차 근사 보정을 수행한다.<br />
<span class="math math-display">
\Delta \tilde{R}{ij}(\mathbf{b}^+) \approx \Delta \tilde{R}{ij}(\mathbf{b}) \cdot \text{Exp}(\mathbf{J}{\Delta R}^{\mathbf{b}} \delta \mathbf{b})
</span></p>
<h4>5.1.2  스컬링(Sculling)과 코닝(Coning) 보상</h4>
<p>고정밀 항법을 위해서는 단순 적분 외에도 진동 환경에서 발생하는 비가환(Non-commutative) 오차인 **스컬링(속도 적분 오차)**과 **코닝(자세 적분 오차)**을 보상해야 한다. 최신 연구23에 따르면, 사전적분 모델 내에 다음과 같은 고차항 보정을 포함시킴으로써 동적 환경에서의 위치 정밀도를 크게 향상시킬 수 있다.<br />
<span class="math math-display">
\hat{\boldsymbol{\omega}}_{ib}^b = (\Delta \boldsymbol{\theta}_k + \frac{1}{12} \Delta \boldsymbol{\theta}_{k-1} \times \Delta \boldsymbol{\theta}_k) / \Delta t
</span></p>
<h3>5.2  팩터 그래프의 유연성: 다중 센서 및 지연 처리</h3>
<p>팩터 그래프는 다양한 비동기 센서 데이터를 확률적 제약조건(Factor)으로 유연하게 통합한다.</p>
<table><thead><tr><th><strong>팩터 유형</strong></th><th><strong>역할 및 특징</strong></th></tr></thead><tbody>
<tr><td><strong>IMU Factor</strong></td><td>두 상태 간의 상대적 기동을 사전적분된 값으로 제약. 바이어스 추정 포함.</td></tr>
<tr><td><strong>Leg Kinematics Factor</strong></td><td>인코더 데이터를 기반으로 기저와 발 사이의 상대 위치 제약.</td></tr>
<tr><td><strong>Contact Factor</strong></td><td>발이 지면에 닿아있는 동안 “발의 속도는 0” 또는 “위치 고정” 제약 추가.24</td></tr>
<tr><td><strong>Learned Displacement</strong></td><td>딥러닝 모델이 예측한 변위를 제약조건으로 추가 (Section 6 참조).</td></tr>
</tbody></table>
<p>FGO는 <strong>iSAM2</strong>와 같은 점진적 스무딩(Incremental Smoothing) 알고리즘을 사용하여, 새로운 데이터가 들어올 때 그래프 전체를 재계산하지 않고 영향받는 부분만 효율적으로 업데이트한다. 이를 통해 실시간성을 확보하면서도 EKF보다 월등한 정확도와 강인함을 달성한다.14 특히 통신 지연이나 센서 데이터 누락이 발생했을 때, 그래프에 노드를 늦게 삽입하고 다시 최적화하는 것만으로 자연스러운 보정이 가능하다는 점은 큰 장점이다.</p>
<hr />
<h2>6.  데이터 주도형 혁신: 학습 기반(Learning-Aided) 상태 추정의 융합</h2>
<p>물리 기반 모델(EKF, InEKF, FGO)은 강력하지만, “수학적으로 모델링하기 어려운 현상“에 취약하다. 대표적인 것이 <strong>접촉(Contact)</strong> 판별의 모호성, 불규칙한 <strong>미끄러짐(Slip)</strong>, 그리고 복잡한 <strong>센서 노이즈</strong> 특성이다. 최근 연구들은 이러한 부분에 딥러닝을 도입하여 하이브리드 형태의 상태 추정기를 구축하고 있다.4</p>
<h3>6.1  신경망 측정 네트워크 (Neural Measurement Network, NMN)</h3>
<p>전통적인 접촉 감지는 발바닥의 힘 센서(F/T 센서)가 특정 임계값을 넘는지를 판단하는 이진(Binary) 방식이었다. 그러나 푹신한 지면이나 빠른 충격 시에는 이 방식이 잦은 오류를 범한다. 이를 해결하기 위해 **신경망 측정 네트워크(NMN)**가 도입되었다.12</p>
<h4>6.1.1  네트워크 아키텍처 및 입출력</h4>
<p>Youm et al.26과 Teng et al.12이 제안한 NMN은 시계열 데이터 처리에 특화된 구조를 갖는다.</p>
<ul>
<li><strong>아키텍처:</strong> 1D CNN(ResNet1D 기반) 또는 GRU(Gated Recurrent Unit)를 사용하여 센서 데이터의 시간적 흐름과 패턴을 학습한다. 예를 들어 Youm et al.은 128차원의 은닉층을 가진 GRU와 [256x128] 크기의 MLP를 결합한 구조를 사용한다.26</li>
<li><strong>입력 (<span class="math math-inline">\mathbf{m}_t</span>):</strong> IMU 가속도/각속도, 관절 각도/속도, 그리고 이전 시점의 제어 목표값(Joint Targets)을 포함한다. 제어 입력을 포함하는 이유는 로봇의 의도된 동작과 실제 반응 사이의 차이가 지면 특성을 반영하기 때문이다.</li>
<li><strong>출력:</strong></li>
</ul>
<ol>
<li><strong>접촉 확률 (<span class="math math-inline">\hat{c}_t</span>):</strong> 단순한 0/1이 아닌, 0~1 사이의 확률값으로 출력하여 필터 내에서 가중치로 활용된다.</li>
<li><strong>유사 선속도 (Pseudo-Body Velocity, <span class="math math-inline">{}^b \hat{v}_t</span>):</strong> 기구학적 계산이 아닌, 네트워크가 직관적으로 추론한 몸체의 선속도이다. 이는 모든 다리가 미끄러지는 상황에서 필터의 발산을 막는 결정적인 “관측값” 역할을 한다.</li>
</ol>
<p>이러한 NMN은 시뮬레이션에서 생성된 대량의 데이터(다양한 지형, 미끄러짐 조건)를 통해 학습되며, 실제 로봇(Sim-to-Real)에서도 놀라운 일반화 성능을 보여준다.3</p>
<h3>6.2  적응형 공분산 튜닝 (Adaptive Covariance Tuning) 메커니즘</h3>
<p>센서 융합에서 측정 잡음 공분산 행렬 <span class="math math-inline">\mathbf{R}</span>은 센서 정보의 신뢰도를 의미한다. 고정된 <span class="math math-inline">\mathbf{R}</span> 값은 변화하는 환경(예: 평지 vs 자갈밭)에 적응하지 못한다. 학습 기반 접근법은 현재의 센서 데이터 패턴을 분석하여 <strong>공분산 <span class="math math-inline">\mathbf{R}</span>을 실시간으로 추론</strong>한다.28</p>
<ul>
<li>
<p><strong>메커니즘:</strong> 신경망이 현재 지면이 미끄럽다고 판단하면, 기구학적 관측 모델의 공분산 <span class="math math-inline">\mathbf{R}_{kin}</span>을 급격히 증가시킨다. 이는 필터(Kalman Gain)가 기구학적 속도 정보(미끄러짐 포함)를 무시하고, IMU 예측이나 NMN이 추론한 속도를 더 신뢰하도록 유도한다.</p>
</li>
<li>
<p><strong>수식적 구현 (Joseph Form):</strong> 가변적인 공분산을 필터에 안정적으로 적용하기 위해 조셉 형태(Joseph form)의 공분산 업데이트 식을 사용하기도 한다.30<br />
<span class="math math-display">
\mathbf{P}^+ = (\mathbf{I} - \mathbf{K}\mathbf{H})\mathbf{P}^-(\mathbf{I} - \mathbf{K}\mathbf{H})^T + \mathbf{K}\mathbf{R}_{adaptive}\mathbf{K}^T
</span></p>
</li>
</ul>
<p>이러한 **적응형 불변 확장 칼만 필터(Adaptive InEKF)**는 미끄러운 지면에서 기존 필터 대비 수십 퍼센트 이상의 위치 추정 오차 감소 효과를 입증하였다.31</p>
<h3>6.3  학습된 관성 오도메트리 (Learned Inertial Odometry)와 팩터 그래프 융합</h3>
<p>Buchanan et al.32은 팩터 그래프 내에 **‘학습된 변위 팩터(Learned Displacement Factor)’**를 추가하는 혁신적인 방법을 제안했다.</p>
<ul>
<li><strong>개념:</strong> IMU 데이터 윈도우만을 입력받아 짧은 시간 동안의 변위(Displacement)와 그 불확실성(Covariance)을 예측하는 신경망을 학습시킨다.</li>
<li><strong>팩터 그래프 통합:</strong> 이 네트워크의 출력을 팩터 그래프의 제약조건(Constraint)으로 추가한다. 시각 센서가 차단되거나(Visual Blackout), 다리 기구학이 매우 불안정한(Slip) 상황에서도, 로봇은 학습된 IMU 패턴만으로 꽤 정확한 상대 위치 변화를 추정할 수 있다.</li>
<li><strong>성능:</strong> 실험 결과, 시각 정보가 없는 험지 환경에서 기존 기구학-관성 융합 대비 37% 이상의 오차 감소를 달성하였다.34</li>
</ul>
<h2>7.  결론: 하이브리드 아키텍처를 향한 진화</h2>
<p>본 절에서 분석한 고유수용성 감각의 정밀화 기술들은 로봇의 자율성을 한 단계 도약시키는 핵심 기술들이다.</p>
<ol>
<li><strong>InEKF</strong>는 수학적 불변성을 통해 예측 불가능한 기동 중에도 필터의 수렴성과 일관성을 보장한다.</li>
<li><strong>Factor Graph</strong>는 비동기 데이터와 지연을 유연하게 처리하며, 전체 궤적의 최적화를 통해 정밀도를 극대화한다.</li>
<li><strong>Learning-aided Estimation</strong>은 물리 모델이 담아내지 못하는 미끄러짐, 접촉 불확실성, 복잡한 노이즈를 데이터의 힘으로 해결한다.</li>
</ol>
<p>미래의 로봇 상태 추정 시스템은 이 세 가지가 결합된 **계층적 하이브리드 아키텍처(Hierarchical Hybrid Architecture)**로 진화할 것이다. 고주파수 제어 루프를 위해서는 빠른 <strong>InEKF</strong>가, 장기적인 드리프트 보정과 맵핑을 위해서는 <strong>Factor Graph</strong>가, 그리고 환경 적응과 파라미터 튜닝을 위해서는 <strong>Neural Network</strong>가 유기적으로 작동하는 시스템이다. 나아가 전체 파이프라인을 미분 가능하게 만들어(Differentiable Factor Graphs), 필터와 네트워크를 End-to-End로 동시에 학습시키는 연구35가 차세대 기술로 부상하고 있다. 이러한 기술적 진보는 로봇이 시각 정보가 차단된 극한 환경에서도 인간 수준, 혹은 그 이상의 감각적 정밀함으로 임무를 수행할 수 있게 할 것이다.</p>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>