<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:iRoPE</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>iRoPE</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">토큰화 (Tokenizations)</a> / <span>iRoPE</span></nav>
                </div>
            </header>
            <article>
                <h1>iRoPE</h1>
<h2>1.  트랜스포머 아키텍처에서 위치 인식의 필요성</h2>
<p>트랜스포머 아키텍처의 등장은 자연어 처리(NLP)를 비롯한 여러 시퀀스 모델링 분야에서 혁신을 가져왔다. 그러나 이 아키텍처의 핵심인 자기 주의(self-attention) 메커니즘은 본질적으로 입력 시퀀스의 순서에 불변하는(permutation-invariant) 특성을 가진다. 이러한 내재적 한계를 극복하고 시퀀스 내 토큰의 순서 정보를 모델에 주입하기 위해 위치 인코딩(positional encoding) 기법이 필수적으로 요구된다. 본 섹션에서는 초기 위치 인코딩 방식부터 회전 패러다임에 이르기까지의 기술적 진화 과정을 추적하며, RoPE(Rotary Position Embedding) 및 iRoPE(interleaved Rotary Position Embedding)의 등장 배경을 설명한다.</p>
<h3>1.1  자기 주의에서의 순서 불변성 문제</h3>
<p>자기 주의 메커니즘은 시퀀스 내의 모든 토큰 쌍 간의 상호작용을 계산하여 각 토큰의 문맥적 표현을 생성한다. 이 과정에서 각 토큰은 다른 모든 토큰과의 관계를 동시에 고려하게 되는데, 이는 병렬 처리 능력의 극대화를 가져왔다. 하지만 이 메커니즘은 토큰을 순서가 없는 집합, 즉 ’단어 가방(bag of words)’처럼 취급한다.1 그 결과, “개는 돼지를 쫓는다“와 “돼지는 개를 쫓는다“와 같이 단어는 동일하지만 순서가 달라 의미가 완전히 반대되는 문장을 구별하지 못한다.2 이러한 순서 불변성은 언어의 구문론적, 의미론적 구조를 이해하는 데 치명적인 제약으로 작용하며, 이를 해결하기 위한 명시적인 위치 정보의 필요성을 야기한다.</p>
<h3>1.2  위치 인코딩의 진화: 상대적 인식으로의 여정</h3>
<p>순서 불변성 문제를 해결하기 위해 다양한 위치 인코딩 기법이 제안되었다. 초기에는 각 토큰의 절대적인 위치를 인코딩하는 방식이 주를 이루었으나, 점차 토큰 간의 상대적인 거리를 인코딩하는 방향으로 발전했다.</p>
<h4>1.2.1 절대 위치 임베딩 (Absolute Positional Embeddings, APE)</h4>
<p>“Attention Is All You Need” 논문에서 처음 제안된 절대 위치 임베딩(APE)은 각 토큰의 절대 위치에 고유한 벡터를 할당하는 방식이다.1 APE는 주로 두 가지 방식으로 구현된다. 첫째는 학습 가능한 임베딩으로, 사전 정의된 최대 시퀀스 길이에 대해 각 위치 벡터를 모델의 다른 파라미터와 함께 학습하는 방식이다. 이 방식은 학습 데이터에 없던 더 긴 시퀀스에 대해서는 일반화하기 어렵다는 명백한 한계를 가진다.2</p>
<p>둘째는 사인 함수(sinusoidal) 임베딩으로, 서로 다른 주파수를 가진 사인 및 코사인 함수를 사용하여 위치 벡터를 결정론적으로 생성한다. 이 방식은 이론적으로는 임의의 길이를 가진 시퀀스를 처리할 수 있다는 장점이 있다.2 사인 함수 APE의 수학적 공식은 다음과 같다.<br />
<span class="math math-display">
PE_{(pos, 2i)} = \sin(pos / 10000^{2i/d_{\text{model}}})
</span></p>
<p><span class="math math-display">
PE_{(pos, 2i+1)} = \cos(pos / 10000^{2i/d_{\text{model}}})
</span></p>
<p>여기서 <span class="math math-inline">pos</span>는 토큰의 위치, <span class="math math-inline">i</span>는 임베딩 벡터의 차원 인덱스, <span class="math math-inline">d_{\text{model}}</span>은 임베딩 차원의 크기를 나타낸다.3 이 공식에서 임베딩 차원의 인덱스 <span class="math math-inline">i</span>가 증가함에 따라 주파수는 기하급수적으로 감소한다. 즉, 낮은 차원에서는 위치 변화에 따라 값이 빠르게 변하는 고주파수 정보가, 높은 차원에서는 느리게 변하는 저주파수 정보가 인코딩된다.1</p>
<p>그러나 APE는 근본적인 한계를 가진다. 모델은 위치 5가 위치 6과 가깝다는 관계를 내재적으로 이해하지 못하고, 데이터로부터 이러한 관계를 학습해야만 한다.5 더 중요한 것은, 어텐션 계산 시 토큰의 의미론적 정보와 절대 위치 정보가 덧셈으로 결합되어 순수한 상대 위치 정보를 분리해내기 어렵다는 점이다.1</p>
<h4>1.2.2 상대 위치 임베딩 (예: ALiBi)</h4>
<p>이러한 APE의 한계를 극복하기 위해 토큰의 절대 위치가 아닌 토큰 간의 거리에 초점을 맞추는 상대 위치 임베딩 개념이 등장했다.2 대표적인 예로 선형 편향을 사용한 어텐션(Attention with Linear Biases, ALiBi)이 있다. ALiBi는 위치 임베딩 벡터를 토큰 임베딩에 더하는 대신, 어텐션 점수 행렬에 토큰 간의 거리에 비례하는 편향(bias)을 직접 더한다.1 이 편향은 일종의 ’최근성 편향(recency bias)’으로 작용하여, 가까운 토큰에 더 높은 가중치를 부여하는 경향을 만든다.1</p>
<p>ALiBi는 일부 실험에서 RoPE보다 우수한 길이 외삽(length extrapolation) 성능과 빠른 학습 속도를 보여주었다.1 하지만 시퀀스가 매우 길어질 경우, 거리에 비례하는 편향 값이 과도하게 커져 사실상 제한적인 크기의 슬라이딩 윈도우처럼 작동할 수 있다는 비판이 제기되었다. 이는 모델이 매우 멀리 떨어진 토큰에 주의를 기울이는 능력을 저해할 수 있다.7</p>
<h3>1.3  회전 패러다임: 근본적인 전환</h3>
<p>RoPE(Rotary Position Embedding)는 위치 정보를 인코딩하는 방식에 있어 패러다임의 전환을 제시한다. 기존 방식들이 위치 정보를 덧셈(APE)이나 편향(ALiBi)의 형태로 추가했다면, RoPE는 쿼리(query)와 키(key) 벡터를 ’회전(rotate)’시키는 곱셈적(multiplicative) 접근법을 채택한다.2</p>
<p>이 방식은 절대 위치와 상대 위치 정보를 우아하게 통합한다. 각 토큰은 자신의 절대 위치에 기반한 고유한 각도만큼 회전되지만, 두 토큰의 회전된 벡터 간의 내적(dot product)은 오직 두 토큰의 상대적인 거리에만 의존하게 된다.6 이는 APE의 핵심적인 한계, 즉 의미론적 정보와 위치 정보가 분리되지 않는 문제를 근본적으로 해결한다. 이처럼 위치 인코딩의 발전 과정은 위치 정보를 외부의 부가적인 특징으로 취급하는 방식에서 벗어나, 어텐션 메커니즘 자체의 기하학적 속성으로 내재화하려는 방향으로 나아왔다. APE가 위치 벡터</p>
<p><span class="math math-inline">p_m</span>을 토큰 임베딩 <span class="math math-inline">x_m</span>에 더하는 <span class="math math-inline">x_m + p_m</span> 형태였다면, ALiBi는 어텐션 점수 <span class="math math-inline">q^T k + \text{bias}</span>를 직접 수정했다. 반면 RoPE는 어텐션 점수 계산의 입력값인 쿼리 <span class="math math-inline">q</span>와 키 <span class="math math-inline">k</span> 자체를 회전을 통해 변환한다. 상대 위치 정보는 변환된 벡터들의 내적 <code>&lt;R_m q, R_n k&gt;</code>로부터 자연스럽게 나타난다. 이는 위치 정보를 어텐션의 유사도 측정 과정에 원리적으로 통합하는 가장 진보된 접근 방식이라 할 수 있다.</p>
<table><thead><tr><th>방법론</th><th>인코딩 유형</th><th>메커니즘</th><th>길이 외삽 능력</th><th>파라미터 유무</th><th>주요 한계</th></tr></thead><tbody>
<tr><td><strong>APE (Sinusoidal)</strong></td><td>절대</td><td>덧셈 (Additive)</td><td>이론적으로 가능하나 성능 저하</td><td>없음</td><td>상대 위치 관계를 내재적으로 표현하지 못함; 의미론적 정보와 위치 정보가 혼합됨.</td></tr>
<tr><td><strong>ALiBi</strong></td><td>상대</td><td>편향 (Bias)</td><td>우수함</td><td>없음</td><td>매우 긴 시퀀스에서 과도한 편향으로 인해 사실상 슬라이딩 윈도우처럼 작동할 수 있음.</td></tr>
<tr><td><strong>RoPE</strong></td><td>절대 &amp; 상대 통합</td><td>곱셈/회전 (Multiplicative/Rotational)</td><td>우수함 (스케일링 기법과 결합 시)</td><td>없음</td><td>내적의 장거리 감쇠 속성에 대한 논쟁이 존재함.</td></tr>
</tbody></table>
<h2>2.  회전 위치 임베딩(RoPE)의 기본 원리</h2>
<p>RoPE는 위치 정보를 벡터 공간에서의 회전이라는 기하학적 변환으로 해석함으로써 기존의 위치 인코딩 방식들이 가진 한계를 극복한다. 본 섹션에서는 RoPE의 직관적인 개념부터 엄밀한 수학적 공식, 그리고 주요 특성에 이르기까지 심층적으로 탐구한다.</p>
<h3>2.1  개념적 프레임워크: 덧셈에서 회전으로</h3>
<p>RoPE의 핵심 아이디어를 직관적으로 이해하기 위해 여러 개의 시곗바늘이 있는 시계를 상상할 수 있다. 임베딩 벡터의 각 차원 쌍은 서로 다른 속도로 회전하는 시곗바늘에 해당한다.6 낮은 차원에 해당하는 시곗바늘은 빠르게 회전하여 토큰 간의 미세한 순서 관계(지역적 문맥)를 포착하고, 높은 차원에 해당하는 시곗바늘은 느리게 회전하여 거시적인 순서 관계(장거리 문맥)를 포착한다.1</p>
<p>기하학적으로 이 과정은 <span class="math math-inline">d</span>차원 벡터를 <span class="math math-inline">d/2</span>개의 2차원 부분 공간으로 나누고, 각 부분 공간에서 벡터를 회전시키는 것과 같다. 회전 각도는 토큰의 절대 위치 <span class="math math-inline">m</span>에 비례하는 <span class="math math-inline">m\theta</span>이지만, 두 토큰 <span class="math math-inline">m</span>과 <span class="math math-inline">n</span>의 회전된 벡터 간의 상대적인 각도는 오직 두 토큰의 거리 <span class="math math-inline">m-n</span>에만 의존하게 된다. 이 상대 각도가 내적 값을 결정하므로, 어텐션 점수는 자연스럽게 상대 위치 정보를 반영하게 된다.2</p>
<h3>2.2  RoPE의 수학적 공식</h3>
<p>RoPE의 수학적 목표는 위치 <span class="math math-inline">m</span>의 토큰 임베딩 <span class="math math-inline">x_m</span>과 위치 <span class="math math-inline">n</span>의 토큰 임베딩 <span class="math math-inline">x_n</span>에 각각 함수 <span class="math math-inline">f_q</span>와 <span class="math math-inline">f_k</span>를 적용했을 때, 그 내적 값이 오직 <span class="math math-inline">x_m</span>, <span class="math math-inline">x_n</span>, 그리고 상대 위치 <span class="math math-inline">m-n</span>에만 의존하는 함수 <span class="math math-inline">g</span>로 표현되도록 하는 것이다.8<br />
<span class="math math-display">
\langle f_q(x_m, m), f_k(x_n, n) \rangle = g(x_m, x_n, m - n)
</span></p>
<h4>2.2.1 차원에서의 유도 (복소수 활용)</h4>
<p>이 목표를 달성하는 해법은 복소수를 사용하여 우아하게 유도할 수 있다.9 2차원 쿼리/키 벡터를 복소수</p>
<p><span class="math math-inline">z = a+ib</span>로 간주하고, 위치 정보를 복소수 곱셈 <span class="math math-inline">z \cdot e^{im\theta}</span>를 통해 적용한다. 위치 <span class="math math-inline">m</span>의 쿼리 <span class="math math-inline">q_m</span>과 위치 <span class="math math-inline">n</span>의 키 <span class="math math-inline">k_n</span>에 대해 위치 정보를 적용한 후 내적(복소수에서는 <span class="math math-inline">q_m \cdot k_n^*</span>의 실수부)을 계산하면 다음과 같다.<br />
<span class="math math-display">
\text{Re} = \text{Re}
</span><br />
여기서 <span class="math math-inline">(W_k x_n e^{in\theta})^*</span>는 켤레 복소수를 의미한다. 최종 결과가 오직 상대 위치 <span class="math math-inline">m-n</span>에 의존하는 항 <span class="math math-inline">e^{i(m-n)\theta}</span>를 포함하므로, RoPE의 상대성 원리가 증명된다.</p>
<h4>2.2.2 <span class="math math-inline">d</span>차원으로의 일반화 (회전 행렬)</h4>
<p>이러한 2차원 회전 개념을 <span class="math math-inline">d</span>차원으로 일반화하기 위해, <span class="math math-inline">d</span>차원 임베딩 벡터를 <span class="math math-inline">d/2</span>개의 2차원 벡터 쌍으로 나눈다.13 각 쌍은 독립적인 2차원 부분 공간에서 회전 변환을 거친다. 위치 <span class="math math-inline">t</span>에 대한 2차원 회전 행렬 <span class="math math-inline">R_{\theta,t}</span>는 다음과 같이 정의된다.<br />
<span class="math math-display">
R_{\theta,t} = \begin{pmatrix} \cos t\theta &amp; -\sin t\theta \\ \sin t\theta &amp; \cos t\theta \end{pmatrix}
</span><br />
1</p>
<p>이를 <span class="math math-inline">d</span>차원으로 확장한 블록 대각 행렬(block-diagonal matrix) <span class="math math-inline">R^d_{\Theta,m}</span>은 다음과 같다.<br />
<span class="math math-display">
R^d_{\Theta,m} = \begin{pmatrix}
\cos m\theta_1 &amp; -\sin m\theta_1 &amp; \cdots &amp; 0 &amp; 0 \\
\sin m\theta_1 &amp; \cos m\theta_1 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; \cos m\theta_{d/2} &amp; -\sin m\theta_{d/2} \\
0 &amp; 0 &amp; \cdots &amp; \sin m\theta_{d/2} &amp; \cos m\theta_{d/2}
\end{pmatrix}
</span><br />
8</p>
<p>여기서 <span class="math math-inline">\Theta = \{\theta_i = 10000^{-2(i-1)/d} \mid i \in [1, \dots, d/2]\}</span>는 각 2차원 부분 공간에 적용될 서로 다른 주파수(회전 속도)의 집합이다.8 베이스 값 <code>10000</code>은 사인 함수 APE에서와 유사하게 파장의 범위를 결정하는 역할을 한다.4</p>
<p>최종적으로 위치 <span class="math math-inline">m</span>의 쿼리 <span class="math math-inline">q_m</span>과 위치 <span class="math math-inline">n</span>의 키 <span class="math math-inline">k_n</span>의 내적은 다음과 같이 정리된다.<br />
<span class="math math-display">
q_m^T k_n = (R^d_{\Theta,m} W_q x_m)^T (R^d_{\Theta,n} W_k x_n) = x_m^T W_q^T (R^d_{\Theta,m})^T R^d_{\Theta,n} W_k x_n = x_m^T W_q^T R^d_{\Theta,n-m} W_k x_n
</span><br />
9</p>
<p>이 식에서 내적 값이 오직 상대 위치 <span class="math math-inline">n-m</span>에 의존하는 회전 행렬 <span class="math math-inline">R^d_{\Theta,n-m}</span>에 의해 결정됨을 명확히 확인할 수 있다.</p>
<h3>2.3  속성 및 시사점</h3>
<p>RoPE는 그 수학적 구조로부터 여러 중요한 속성을 가진다.</p>
<h4>2.3.1 장거리 감쇠 논쟁 (Long-Term Decay Debate)</h4>
<p>초기 RoFormer 논문에서는 RoPE가 장거리 감쇠(long-term decay) 속성을 가진다고 주장했다. 즉, 두 토큰 간의 상대적 거리 <span class="math math-inline">\vert m-n \vert</span>이 증가함에 따라 내적 값이 자연스럽게 감소하여, 멀리 떨어진 토큰 간의 상호작용이 약화된다는 것이다.1 이는 직관적으로 바람직한 속성으로 여겨졌다.</p>
<p>그러나 최근의 한 분석(“Round and Round We Go!”)에서는 이러한 주장에 이의를 제기한다. 해당 연구는 장거리 감쇠 속성이 쿼리/키 벡터가 상수일 때라는 비현실적인 가정 하에서만 성립하며, 보다 현실적인 가우시안 분포를 따르는 벡터를 사용할 경우 감쇠 현상이 거의 나타나지 않음을 실험적으로 보였다.18</p>
<p>이 논쟁은 RoPE의 효과가 단순한 수학적 정의를 넘어 임베딩 공간 자체의 통계적 특성과 깊이 얽혀 있음을 시사한다. 즉, RoPE의 고정된 회전 기하학과 모델이 학습하는 동적인 토큰 임베딩의 기하학 간의 상호작용이 실제 어텐션 동작을 결정한다는 것이다. 현실적인 벡터 분포에서 감쇠가 나타나지 않는다는 점은 오히려 RoPE의 장점일 수 있다. 이는 RoPE가 거리에 따른 중요도에 대한 강력하고 인위적인 사전 가정을 강요하지 않고, 모델이 장거리 의존성을 보다 유연하게 학습할 수 있도록 허용한다는 의미로 해석될 수 있다.18</p>
<h4>2.3.2 확장성 및 스케일링</h4>
<p>RoPE의 수학적 구조는 훈련 시 보았던 것보다 긴 시퀀스에 대해서도 자연스럽게 확장될 수 있는 기반을 제공한다.6 하지만 초장문 컨텍스트로 확장할 경우, 분포 외(out-of-distribution) 문제로 인해 성능이 저하될 수 있다.19 이를 해결하기 위해 위치 보간(Position Interpolation, PI) 20, NTK-aware 스케일링 7, YaRN 6 등 RoPE의 베이스</p>
<p><span class="math math-inline">\theta</span>나 주파수를 조정하는 다양한 스케일링 기법들이 개발되었다. 이러한 기법들의 등장은 RoPE가 고정된 해결책이 아니라, 핵심적인 회전 메커니즘을 유지하면서도 파라미터를 동적으로 조절하여 새로운 길이의 컨텍스트에 적응할 수 있는 유연한 ’프레임워크’임을 보여준다. 이는 RoPE가 효율적인 컨텍스트 확장 전략의 핵심 기술로 자리 잡게 된 중요한 이유이다.</p>
<h4>2.3.3 계산 효율성</h4>
<p>회전 행렬 <span class="math math-inline">R^d_{\Theta,m}</span>은 블록 대각 구조를 가지므로 희소 행렬(sparse matrix)이다. 따라서 완전한 행렬 곱셈을 수행할 필요 없이, 벡터의 원소별 곱셈과 덧셈만으로 효율적인 계산이 가능하다.8 이는 RoPE를 실제 모델에 적용할 때 계산상의 부담을 최소화하는 중요한 장점이다.</p>
<h2>3.  iRoPE 아키텍처: 초장문 컨텍스트를 위한 하이브리드 전략</h2>
<p>iRoPE는 RoPE의 원리를 기반으로 초장문 컨텍스트 처리 능력을 극대화하기 위해 고안된 새로운 아키텍처 패턴이다. 본 섹션에서는 먼저 용어의 혼동을 명확히 한 후, iRoPE 아키텍처의 구조와 그 시너지적 작동 원리를 상세히 분석한다.</p>
<h3>3.1  “Interleaved“의 이중적 의미 해소</h3>
<p>“Interleaved“라는 용어는 RoPE 및 iRoPE의 맥락에서 두 가지 완전히 다른 의미로 사용되어 혼란을 야기할 수 있다. 이를 명확히 구분하는 것이 중요하다.</p>
<ul>
<li><strong>의미 1: 아키텍처 인터리빙 (iRoPE):</strong> 이는 Llama 4와 같은 모델에서 사용되는 고수준 아키텍처 패턴을 지칭한다. 즉, RoPE가 적용된 트랜스포머 레이어와 위치 인코딩이 없는(No Positional Embedding, NoPE) 레이어를 주기적으로 ’교차 배치(interleaving)’하는 구조를 의미한다.5 이 개념은 여러 주제를 섞어서 학습할 때 학습 효과가 향상된다는 인지 과학의 ’인터리빙 효과(interleaving effect)’에서 영감을 받은 것이다.25</li>
<li><strong>의미 2: 벡터 구성 요소 인터리빙 (RoPE 구현):</strong> 이는 RoPE를 구현할 때 <span class="math math-inline">d</span>차원 벡터를 <span class="math math-inline">d/2</span>개의 2차원 쌍으로 구성하는 저수준 방식 중 하나를 의미한다. 예를 들어, 벡터의 전반부 <span class="math math-inline">d/2</span>개 차원과 후반부 <span class="math math-inline">d/2</span>개 차원을 짝지을 수도 있고(split/rotate_half), 인접한 두 차원(<span class="math math-inline">x_0</span>와 <span class="math math-inline">x_1</span>, <span class="math math-inline">x_2</span>와 <span class="math math-inline">x_3</span>,…)을 짝지을 수도 있다. 후자의 방식을 ‘인터리빙’ 패턴이라고 부른다.27 이는 오디오 채널을 저장할 때 좌우 채널 데이터를 교차로 배열(LRLRLR…)하는 인터리빙 방식과 비유할 수 있다.28</li>
</ul>
<p>본 안내서에서 다루는 <strong>iRoPE</strong>는 <strong>의미 1</strong>, 즉 아키텍처 패턴을 지칭하며, 이는 구현 방식의 선택인 의미 2와는 구별되는 개념이다.</p>
<h3>3.2  아키텍처 패턴: RoPE와 NoPE 레이어의 교차 배치</h3>
<p>iRoPE 아키텍처의 핵심은 서로 다른 역할을 하는 두 종류의 트랜스포머 레이어를 주기적으로 반복하는 것이다. Llama 4 Scout 모델에서는 3개의 연속된 RoPE 적용 레이어 다음에 1개의 NoPE 레이어가 오는 3:1 비율의 블록 구조가 반복적으로 사용된다.5</p>
<p>NoPE(No Positional Embedding)는 이름 그대로 명시적인 위치 인코딩을 완전히 제거하는 방식이다. 연구에 따르면, 모델은 인과적 어텐션 마스크(causal attention mask)로부터 암묵적인 위치 정보를 학습할 수 있기 때문에 명시적인 위치 인코딩 없이도 작동할 수 있다.29 NoPE 모델은 일반적인 퍼플렉시티(perplexity)와 같은 지표에서는 성능이 다소 저하될 수 있지만, 위치에 구애받지 않는 전역적인(global) 관계를 포착하는 데 강점을 보이며, 이는 초장문 컨텍스트 처리에서 매우 중요하다.29</p>
<p>정보의 흐름 관점에서, 토큰 표현은 이 3-RoPE-then-1-NoPE 블록을 통과하면서 반복적으로 지역적 위치 문맥에 기반을 둔 후, 전역적으로 ’혼합’되는 과정을 거치게 된다.</p>
<h3>3.3  시너지 메커니즘: 지역적 및 전역적 문맥 주의의 융합</h3>
<p>iRoPE의 진정한 힘은 두 종류의 레이어가 만들어내는 시너지 효과에 있다.</p>
<ul>
<li><strong>RoPE 레이어의 역할:</strong> 3개의 연속된 RoPE 레이어는 ‘지역 전문가(local experts)’ 역할을 한다. 이 레이어들은 주변 토큰들의 정확한 상대적 위치가 중요한 구문 분석 및 단거리 의미 관계 파악에 집중하여, 지역 문맥에 대한 정교하고 충실도 높은 표현을 구축한다. 이 레이어들에서의 어텐션 패턴은 주변 토큰에 강하게 집중하고 멀리 있는 토큰에 대해서는 지수적으로 감쇠하는 경향을 보인다.5</li>
<li><strong>NoPE 레이어의 역할:</strong> 뒤따르는 NoPE 레이어는 ‘전역 통합자(global aggregator)’ 또는 ‘정보 라우터(information router)’ 역할을 한다. 모든 명시적 위치 정보를 제거함으로써, 이 레이어는 어텐션 메커니즘이 거리에 상관없이 컨텍스트 내의 모든 토큰을 동등하게 고려하도록 강제한다.5 이를 통해 책의 첫 문단에 나온 세부 사항과 마지막 장의 주제를 연결하는 것과 같이, 매우 멀리 떨어진 개념들 간의 연결을 형성할 수 있다.</li>
</ul>
<p>이러한 교차 배치는 매우 효과적인 학습 전략을 구성한다. RoPE 레이어에서 위치 정보가 풍부하게 포함된 정교한 특징(feature)들이 추출된다. 그 다음 NoPE 레이어는 이 풍부한 특징들을 가져와 전체 컨텍스트에 걸쳐 재분배함으로써, 이미 지역적 환경에서 잘 이해된 토큰들 간의 장거리 관계가 수립될 수 있도록 한다. 이는 모델이 지역적인 세부 사항에 매몰되는 것을 방지하고, 문서 전체에 대한 계층적 이해를 가능하게 한다.</p>
<p>iRoPE 아키텍처는 위치 정보의 유용성이 거리에 따라 일정하지 않다는 아이디어를 암묵적으로 모델링한다. RoPE 자체는 강력한 장거리 감쇠를 강제하지 않을 수 있지만(섹션 2.3 참조), iRoPE 아키텍처는 NoPE 레이어를 통해 주기적으로 위치 의존성을 ’리셋’하는 효과를 강제한다. 매우 가까운 토큰들에게는 상대 위치가 절대적으로 중요하지만, 수만 토큰 떨어진 토큰들 사이에서는 정확한 상대 거리(<code>50,000</code> 대 <code>50,001</code>)보다는 위치와 무관한 의미론적 관계가 더 중요할 가능성이 높다. NoPE 레이어는 “이 처리 단계에서는 정밀한 위치 지도를 무시하고, 모든 토큰의 의미론적 내용에만 전역적으로 집중하라“는 지시와 같다. 따라서 iRoPE는 방대한 거리에 걸쳐 위치 정보의 효용이 감소하는 문제에 대한 아키텍처 수준의 해결책이라고 볼 수 있다.</p>
<p>또한, 3:1이라는 비율은 임의적이라기보다는 특징 추출(지역 문맥 필요)과 전역적 정보 전파 사이의 균형을 경험적으로 발견한 결과일 가능성이 높다. 1:1 비율이었다면, 전역적으로 혼합되기 전에 충분히 정교한 특징이 추출되지 않을 수 있다. 반대로 10:1 비율이었다면, 모델이 지역적 위치 신호에 과적합되어 전역적 정보 전파에 어려움을 겪을 수 있다. 3:1 비율은 여러 단계의 지역적 특징 정제 후 한 단계의 전역적 통합이 이루어지는 처리 패턴을 시사하며, 이는 여러 합성곱 레이어 뒤에 풀링 레이어가 오는 CNN과 같은 다른 분야의 계층적 처리 방식과 유사하다.</p>
<table><thead><tr><th>레이어 유형</th><th>주요 기능</th><th>위치 정보</th><th>어텐션 범위</th><th>일반적인 어텐션 패턴</th><th>모델 전체에 대한 기여</th></tr></thead><tbody>
<tr><td><strong>RoPE 적용 레이어</strong></td><td>지역적 특징 추출</td><td>명시적 상대 위치</td><td>지역 중심 (Locally-focused)</td><td>주변 토큰에 집중, 거리에 따라 감쇠</td><td>구문, 단거리 의미 관계 등 정교한 지역 문맥 표현 구축</td></tr>
<tr><td><strong>NoPE 레이어</strong></td><td>전역적 정보 통합</td><td>암묵적 (인과적 마스크)</td><td>전역 (Global)</td><td>컨텍스트 전체에 걸쳐 균일한 분포</td><td>장거리 의존성 포착, 멀리 떨어진 개념 간의 의미적 연결 형성</td></tr>
</tbody></table>
<h2>4.  아키텍처 분석 및 성능 영향</h2>
<p>본 섹션에서는 iRoPE 아키텍처가 최신 대규모 언어 모델(LLM)에 어떻게 적용되고, 그 성능에 어떤 영향을 미치는지 분석한다. 특히, 방대한 컨텍스트 윈도우를 구현하는 데 있어 iRoPE가 수행하는 핵심적인 역할을 조명한다.</p>
<h3>4.1  하이브리드 RoPE/NoPE 접근법의 장점</h3>
<p>iRoPE 아키텍처는 RoPE 또는 NoPE를 단독으로 사용하는 것의 한계를 극복하고, 두 방식의 장점을 결합하여 균형 잡힌 표현 학습을 가능하게 한다.5</p>
<ul>
<li><strong>균형 잡힌 표현:</strong> iRoPE는 지역적으로는 정밀하면서도 전역적으로는 넓은 시야를 가진 표현을 생성한다. RoPE 레이어는 문장의 구문 구조나 단락 내의 논리적 흐름과 같이 세밀한 순서 정보가 중요한 부분을 처리하고, NoPE 레이어는 문서 전체를 관통하는 주제나 인물 간의 관계처럼 거시적인 연결을 담당한다.</li>
<li><strong>초장문 컨텍스트로의 확장성:</strong> 이 아키텍처는 근본적으로 확장성을 염두에 두고 설계되었다. 주기적으로 NoPE 레이어를 사용함으로써, 모델은 수백만 토큰에 걸쳐 상대 위치를 계산할 때 발생할 수 있는 누적 오차나 노이즈의 영향을 완화할 수 있다. 이는 모델이 매우 긴 시퀀스를 안정적으로 처리할 수 있는 기반을 제공한다.</li>
</ul>
<h3>4.2  실제 적용 사례: Llama 4와 1,000만 토큰 컨텍스트</h3>
<p>iRoPE는 Llama 4 Scout 모델이 업계 최고 수준인 1,000만 토큰의 컨텍스트 윈도우를 달성할 수 있게 한 핵심 기술 혁신으로 평가된다.5</p>
<h4>4.2.1 장문 컨텍스트 벤치마크에서의 성능</h4>
<p>초장문 컨텍스트 처리 능력은 ’건초더미에서 바늘 찾기(Needle-in-a-Haystack, NIAH)’와 같은 특수한 벤치마크를 통해 평가된다. NIAH 테스트는 모델이 방대한 양의 관련 없는 텍스트(‘건초더미’) 속에서 특정 정보(‘바늘’)를 정확히 찾아내는 능력을 측정한다.33 이는 장문 컨텍스트에서의 정보 회수 능력을 평가하는 대표적인 방법이다. 이 외에도 L-Eval, LongBench 등 긴 텍스트에 대한 복잡한 추론 능력을 평가하는 벤치마크들이 있다.21 그러나 많은 모델들이 32,000 토큰 정도의 컨텍스트에서도 성능이 급격히 저하되는 등, 장문 컨텍스트 처리는 여전히 도전적인 과제임을 보여준다.34</p>
<p>Llama 4의 장문 컨텍스트 성능은 iRoPE 아키텍처의 효과를 입증하는 강력한 증거로 볼 수 있다.31 물론, 1,000만 토큰과 같은 거대한 컨텍스트를 처리하기 위해서는 KV 캐시(KV cache)를 위한 막대한 메모리가 요구되며, 이를 효율적으로 관리하기 위한 하이브리드 어텐션 메커니즘 등 추가적인 기술이 필요하다는 기술적 타당성에 대한 분석도 존재한다.35</p>
<p>iRoPE와 같은 아키텍처의 등장은 LLM 아키텍처 설계가 성숙기에 접어들고 있음을 시사한다. 초기 트랜스포머가 모든 레이어가 동일한 구조를 가지는 단일체(monolithic) 접근법을 취했다면, iRoPE는 서로 다른 기능을 수행하는 이질적인(heterogeneous) 레이어들을 조합하는 방향으로 나아가고 있다. 이는 특정 처리 단계에서 서로 다른 계산 도구(위치 인식 vs. 위치 불변 어텐션)가 필요하다는 인식에 기반한 것으로, 향후 LLM 설계의 주요 트렌드가 될 수 있다.</p>
<h3>4.3  잠재적 한계 및 연구 방향</h3>
<p>iRoPE는 초장문 컨텍스트 모델링에 있어 중요한 진전을 이루었지만, 여전히 탐구해야 할 과제들이 남아있다.</p>
<ul>
<li><strong>최적의 비율:</strong> 현재 사용되는 3:1 비율이 모든 태스크나 모델 크기에 대해 보편적으로 최적인지는 불분명하다. 모델의 깊이나 특정 태스크의 요구에 따라 비율을 동적으로 조절하는 방법에 대한 연구가 필요하다.</li>
<li><strong>계산 비용:</strong> iRoPE는 아키텍처 수준의 개선이지만, 완전 어텐션(full attention)의 근본적인 이차 복잡도(<span class="math math-inline">O(N^2)</span>) 문제를 해결하지는 않는다. 따라서 1,000만 토큰을 처리하는 데 드는 계산 비용, 특히 KV 캐시의 크기는 여전히 막대하다.35 iRoPE는 반드시 희소 어텐션(sparse attention)과 같은 효율적인 어텐션 메커니즘과 결합되어야 그 잠재력을 완전히 발휘할 수 있다.</li>
<li><strong>텍스트를 넘어서:</strong> RoPE와 유사한 구조를 비디오와 같은 다른 모달리티에 적용하는 연구도 활발히 진행되고 있다. 비디오는 시간과 공간(가로, 세로)이라는 복잡한 시공간 구조를 가지므로, 1차원 RoPE를 2D/3D 데이터로 확장하는 데에는 새로운 도전 과제들이 존재한다 (예: VideoRoPE).12</li>
</ul>
<p>iRoPE와 같은 아키텍처가 가능하게 한 수백만 토큰 단위의 컨텍스트 윈도우는 ’태스크’의 정의 자체를 근본적으로 바꾸고 있다. 과거에는 긴 문서를 처리하기 위해 문서를 조각내고, 임베딩하고, 관련 부분을 검색하여 제한된 컨텍스트 윈도우를 가진 모델에 입력하는 복잡한 검색 증강 생성(Retrieval-Augmented Generation, RAG) 파이프라인이 필수적이었다. 하지만 1,000만 토큰 컨텍스트는 ‘검색 데이터베이스’ 전체를 모델의 컨텍스트에 직접 입력하는 것을 가능하게 한다.31 이는 다단계 RAG 파이프라인을 단일 순전파(forward pass)로 압축시켜 과정을 단순화하고, 모델이 왜곡되지 않은 전체 문맥을 보도록 한다. 따라서 iRoPE는 단순히 성능을 개선하는 기술을 넘어, 이전에는 다룰 수 없었던 새로운 종류의 ‘인컨텍스트 추론(in-context reasoning)’ 애플리케이션을 가능하게 하는 핵심 동력이다.</p>
<h2>5.  결론: 대규모 언어 모델의 진화 속에서 iRoPE의 역할 종합</h2>
<p>본 안내서는 트랜스포머 아키텍처의 근본적인 한계인 순서 불변성 문제를 해결하기 위한 위치 인코딩의 발전 과정을 추적하고, 그 정점에 있는 iRoPE 아키텍처를 심층적으로 분석했다.</p>
<h3>5.1 주요 분석 결과 요약</h3>
<ol>
<li><strong>RoPE로의 진화:</strong> 위치 인코딩은 덧셈 방식의 절대 위치 임베딩(APE)에서 시작하여, 어텐션 점수에 직접 편향을 가하는 상대 위치 인코딩(ALiBi)을 거쳐, 쿼리/키 벡터를 직접 회전시키는 곱셈 방식의 RoPE로 발전했다. RoPE는 절대 위치와 상대 위치 정보를 기하학적으로 통합하여 기존 방식들의 한계를 극복하는 우아하고 강력한 프레임워크를 제공한다.</li>
<li><strong>iRoPE의 시너지 메커니즘:</strong> iRoPE는 RoPE의 원리를 한 단계 더 발전시킨 아키텍처 혁신이다. RoPE가 적용된 레이어와 위치 인코딩이 없는 NoPE 레이어를 구조적으로 교차 배치함으로써, 지역적 문맥에 대한 정밀한 분석 능력과 전역적 문맥에 대한 거시적인 통합 능력을 동시에 확보한다. 이 시너지적 결합은 모델이 초장문 텍스트의 미세한 구조와 거대한 구조를 모두 효과적으로 학습할 수 있게 한다.</li>
<li><strong>초장문 컨텍스트의 실현:</strong> iRoPE는 Llama 4와 같은 최신 대규모 언어 모델이 수백만에서 천만 토큰에 이르는 방대한 컨텍스트 윈도우를 실현할 수 있게 한 핵심 기술이다. 이는 단순히 더 많은 정보를 처리하는 것을 넘어, 복잡한 RAG 파이프라인을 대체하고 전체 문서를 단일 컨텍스트 내에서 추론하는 새로운 패러다임을 열었다.</li>
</ol>
<h3>5.2 광범위한 영향 및 향후 전망</h3>
<p>iRoPE의 등장은 LLM 아키텍처 설계의 새로운 흐름을 보여주는 대표적인 사례이다. 이는 모든 레이어가 동일한 역할을 수행하는 단일체 구조에서 벗어나, 정보 처리의 각기 다른 측면을 담당하는 전문화된 레이어들로 구성된 이질적인 아키텍처로의 전환을 의미한다.</p>
<p>앞으로 모델이 더욱 복잡하고, 다중 모달이며, 극도로 긴 컨텍스트에 대한 추론을 요구받게 됨에 따라, iRoPE의 기저에 있는 원리, 즉 정보 처리의 각 단계에 특화된 계산 모듈을 설계하는 접근법은 더욱 중요해질 것이다. 미래의 LLM은 단순히 더 커지는 것을 넘어, iRoPE와 같이 더 지능적이고 구조화된 아키텍처를 통해 발전해 나갈 것이다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>Positional Embeddings in Transformers: A Math Guide to RoPE &amp; ALiBi, https://towardsdatascience.com/positional-embeddings-in-transformers-a-math-guide-to-rope-alibi/</li>
<li>Rotary Positional Embeddings: A Detailed Look and Comprehensive Understanding | by azhar - Medium, https://medium.com/ai-insights-cobet/rotary-positional-embeddings-a-detailed-look-and-comprehensive-understanding-4ff66a874d83</li>
<li>Rotary Positional Embedding (RoPE) | by Devansh Sinha | Medium, https://medium.com/@dewanshsinha71/rotary-positional-embedding-rope-7bc5afb92af9</li>
<li>Math Behind Positional Embeddings in Transformer Models | by Freedom Preetham | Autonomous Agents | Medium, https://medium.com/autonomous-agents/math-behind-positional-embeddings-in-transformer-models-921db18b0c28</li>
<li>Llama 4’s Architecture Deconstructed: MoE, iRoPE, and Early …, https://medium.com/@mandeep0405/llama-4s-architecture-deconstructed-moe-irope-and-early-fusion-explained-e58eb9403067</li>
<li>Inside RoPE: Rotary Magic into Position Embeddings - LearnOpenCV, https://learnopencv.com/rope-position-embeddings/</li>
<li>Why people use RoPE instead of Alibi when buliding their models? : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/165b0tw/why_people_use_rope_instead_of_alibi_when/</li>
<li>A gentle introduction to Rotary Position Embedding - Martin Krasser’s Blog, http://krasserm.github.io/2022/12/13/rotary-position-embedding/</li>
<li>RoFormer: Enhanced Transformer with Rotary Position Embedding, https://arxiv.org/abs/2104.09864</li>
<li>Rotary Embeddings: A Relative Revolution | EleutherAI Blog, https://blog.eleuther.ai/rotary-embeddings/</li>
<li>Rotary Positional Embeddings (RoPE) - The Large Language Model Playbook, https://cyrilzakka.github.io/llm-playbook/nested/rot-pos-embed.html?utm_source=hnblogs.substack.com</li>
<li>VideoRoPE: What Makes for Good Video Rotary Position Embedding? - arXiv, https://arxiv.org/html/2502.05173v1</li>
<li>Round and Round We Go! What makes Rotary Positional Encodings useful? - arXiv, https://arxiv.org/html/2410.06205v1</li>
<li>Learning the RoPEs: Better 2D and 3D Position Encodings with STRING - arXiv, https://arxiv.org/html/2502.02562v1</li>
<li>A Deep Dive into Rotary Positional Embeddings (RoPE): Theory and …, https://medium.com/@parulsharmmaa/understanding-rotary-positional-embedding-and-implementation-9f4ad8b03e32</li>
<li>Rotary Positional Embeddings (RoPE) - labml.ai, https://nn.labml.ai/transformers/rope/index.html</li>
<li>Long-term decay of RoPE | Download Scientific Diagram, https://www.researchgate.net/figure/Long-term-decay-of-RoPE_fig8_383532719</li>
<li>Paper Summary: What Makes Rope Useful | Alan Dao’s personal blog, https://alandao.net/posts/paper-summary-what-makes-rope-useful/</li>
<li>NeurIPS Poster Base of RoPE Bounds Context Length, https://nips.cc/virtual/2024/poster/96017</li>
<li>Extending the RoPE - EleutherAI Blog, https://blog.eleuther.ai/yarn/</li>
<li>Long Context Evaluation Guidance - OpenCompass’ documentation! - Read the Docs, https://opencompass.readthedocs.io/en/latest/advanced_guides/longeval.html</li>
<li>How Rotary Position Embedding Supercharges Modern LLMs [RoPE] - YouTube, https://www.youtube.com/watch?v=SMBkImDWOyQ</li>
<li>Understanding the RoPE Extensions of Long-Context LLMs: An Attention Perspective - arXiv, https://arxiv.org/html/2406.13282v1</li>
<li>@wassemgtk on Hugging Face: “I’ve been diving into the iRoPE architecture from Llama 4—a game-changer for…”, https://huggingface.co/posts/wassemgtk/755158543554585</li>
<li>L2L Strategy - Interleaving - Academic Affairs - The University of Arizona, https://academicaffairs.arizona.edu/l2l-strategy-interleaving</li>
<li>What is Interleaving? – A&amp;S Office of Teaching Excellence and Innovation, https://wp.nyu.edu/fas-edtech/2025/03/what-is-interleaving/</li>
<li>RotaryEmbedding - ONNX 1.20.0 documentation, https://onnx.ai/onnx/operators/onnx__RotaryEmbedding.html</li>
<li>What’s the interleaved audio ? [closed] - Stack Overflow, https://stackoverflow.com/questions/17879933/whats-the-interleaved-audio</li>
<li>Rope to Nope and Back Again: A New Hybrid Attention Strategy - arXiv, https://arxiv.org/html/2501.18795v1</li>
<li>Rope to Nope and Back Again: A New Hybrid Attention Strategy - arXiv, https://arxiv.org/pdf/2501.18795</li>
<li>Llama: Industry Leading, Open-Source AI, https://www.llama.com/</li>
<li>Unmatched Performance and Efficiency | Llama 4, https://www.llama.com/models/llama-4/</li>
<li>NoLiMa: Long-Context Evaluation Beyond Literal Matching - arXiv, https://arxiv.org/html/2502.05167v3</li>
<li>NoLiMa: Long-Context Evaluation Beyond Literal Matching - Finally a good benchmark that shows just how bad LLM performance is at long context. Massive drop at just 32k context for all models. - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/1io3hn2/nolima_longcontext_evaluation_beyond_literal/</li>
<li>Analysis of Llama 4’s 10 Million Token Context Window Claim | by Sander Ali Khowaja, https://sandar-ali.medium.com/analysis-of-llama-4s-10-million-token-context-window-claim-9e68ee5abcde</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>