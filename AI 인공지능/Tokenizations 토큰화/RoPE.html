<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:회전 위치 임베딩(RoPE)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>회전 위치 임베딩(RoPE)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">토큰화 (Tokenizations)</a> / <span>회전 위치 임베딩(RoPE)</span></nav>
                </div>
            </header>
            <article>
                <h1>회전 위치 임베딩(RoPE)</h1>
<h2>1.  시퀀스 변환 모델 순서 정보의 필연성</h2>
<h3>1.1  자기-어텐션 메커니즘의 순열 등변성</h3>
<p>트랜스포머 아키텍처의 핵심을 이루는 자기-어텐션(self-attention) 메커니즘은 본질적으로 순열 등변성(permutation equivariance)이라는 특성을 갖는다.1 이는 입력 시퀀스의 토큰 순서를 바꾸면 출력 시퀀스에서 해당 토큰들의 표현 순서도 동일하게 바뀔 뿐, 각 토큰의 표현 자체는 변하지 않음을 의미한다. 결과적으로, 모델은 입력 시퀀스를 순서가 없는 ’단어 가방(bag of words)’처럼 처리하게 된다.1 이러한 병렬 처리 방식은 계산 효율성을 극대화하는 장점이 있지만, “개는 고양이를 쫓았다“와 “고양이는 개를 쫓았다“와 같이 단어의 순서가 문장의 의미를 결정하는 데 결정적인 역할을 하는 경우, 순서 정보를 완전히 소실시키는 치명적인 단점을 야기한다.1 따라서, 순서가 중요한 데이터를 처리하는 모든 트랜스포머 기반 모델에는 위치 정보를 명시적으로 주입하는 메커니즘이 반드시 필요하다.1</p>
<h3>1.2  위치 인코딩 전략의 분류</h3>
<p>이러한 순서 정보의 필요성에 따라 다양한 위치 인코딩(positional encoding) 전략이 개발되었다. 이 전략들은 크게 세 가지 범주로 분류할 수 있다.1</p>
<ol>
<li><strong>절대 위치 임베딩 (Absolute Positional Embeddings, APE):</strong> 시퀀스 내 각 토큰의 절대적인 위치(예: 0, 1, 2,…)에 고유한 벡터를 할당하는 방식이다.</li>
<li><strong>상대 위치 임베딩 (Relative Positional Embeddings, RPE):</strong> 토큰의 절대적인 위치보다는 토큰 쌍 간의 상대적인 거리(예: j-i)에 초점을 맞추는 방식이다.</li>
<li><strong>하이브리드 접근법 (Hybrid Approaches):</strong> 절대 위치와 상대 위치 정보의 장점을 결합하려는 시도로, 회전 위치 임베딩(RoPE)이 이 범주의 대표적인 예이다.</li>
</ol>
<p>이 외에도 최근에는 입력 토큰의 내용에 따라 위치 정보를 동적으로 생성하는 문맥적 임베딩(contextual embeddings)이나, 명시적인 위치 인코딩을 아예 사용하지 않는 NoPE(No Positional Embedding)와 같은 새로운 개념들도 탐구되고 있다.5</p>
<h3>1.3  초기 접근법의 한계: 절대 및 가산적 상대 인코딩</h3>
<h4>1.3.1  절대 위치 임베딩 (APE)</h4>
<p>절대 위치 임베딩은 각 위치에 고유한 벡터를 생성하여 토큰 임베딩에 더하는(additive) 방식으로 작동한다.2 이 벡터를 생성하는 방식은 크게 두 가지로 나뉜다.</p>
<ul>
<li><strong>학습 기반 APE:</strong> 모델 훈련 과정에서 각 위치에 해당하는 벡터를 다른 모델 파라미터와 함께 학습한다.4</li>
<li><strong>고정 APE (사인/코사인 함수):</strong> 원본 트랜스포머 논문에서 제안된 방식으로, 서로 다른 주파수의 사인 및 코사인 함수를 이용하여 각 위치에 대한 고유한 벡터를 결정론적으로 생성한다.1</li>
</ul>
<p>하지만 APE는 다음과 같은 명백한 한계를 지닌다.</p>
<ul>
<li><strong>길이 외삽(Extrapolation)의 어려움:</strong> 학습 기반 APE는 훈련 시 관찰된 최대 시퀀스 길이를 넘어서는 위치에 대한 표현을 생성할 수 없다.7 사인/코사인 방식은 이론적으로는 더 긴 시퀀스로 확장 가능하지만, 훈련 길이를 크게 벗어날 경우 성능이 저하되는 경향이 있다.</li>
<li><strong>정보의 혼합 및 관계 학습의 비효율성:</strong> 위치 벡터를 토큰 임베딩에 직접 더하는 방식은 의미론적 정보와 위치 정보를 하나의 벡터 안에 혼합시킨다. 또한, 각 위치 벡터는 독립적으로 생성되므로 모델은 위치 1과 2의 관계가 위치 500과 501의 관계와 유사하다는 사실을 데이터로부터 처음부터 학습해야 한다. 이는 언어 구조의 미묘한 관계성을 파악하는 데 비효율적이다.7</li>
</ul>
<h4>1.3.2  가산적 상대 위치 임베딩 (Additive RPE)</h4>
<p>이러한 APE의 한계를 극복하기 위해 상대 위치 임베딩이 제안되었다. 대표적인 예로 T5 모델에서 사용된 편향(bias) 기반 방식이 있다.7</p>
<ul>
<li><strong>메커니즘:</strong> 이 방식은 토큰 쌍 간의 상대적 거리에 해당하는 학습 가능한 스칼라 편향 값을 어텐션 점수 행렬에 직접 더한다. 즉, 쿼리 벡터와 키 벡터의 내적 값에 상대 거리에 따른 편향을 추가하여 어텐션 가중치를 조절한다.7</li>
</ul>
<p>RPE는 APE에 비해 길이 외삽 능력이 뛰어나다는 장점이 있지만, 여전히 해결해야 할 과제가 존재한다.</p>
<ul>
<li><strong>계산 비효율성:</strong> 어텐션 계산 단계마다 상대 위치 편향 행렬을 생성하고 더하는 추가적인 연산이 필요하므로, 특히 시퀀스 길이가 길어질수록 계산 비용이 증가한다.7</li>
<li><strong>KV 캐시 사용의 복잡성:</strong> 생성(inference) 과정에서 효율성을 높이기 위해 사용되는 Key-Value(KV) 캐시 메커니즘의 적용을 복잡하게 만든다.7</li>
</ul>
<p>위치 인코딩의 발전 과정은 트랜스포머 아키텍처에 순서 정보를 안내하는 방식에 대한 근본적인 개념적 전환을 보여준다. 초기 APE가 각 토큰에 명시적인 ’좌표계’를 부여하는 방식이었다면, RPE는 ’병진 불변성(translational invariance)’이라는 귀납적 편향을 주입하는 방향으로 진화했다. APE는 각 토큰에 고유한 ’주소’를 제공하지만, 이는 경직된 방식이어서 모델이 위치 5와 6의 관계가 위치 105와 106의 관계와 유사하다는 점을 처음부터 학습해야만 했다. 반면, RPE는 토큰 간의 ‘거리’(<span class="math math-inline">j-i</span>)를 직접 인코딩하여, 위치 5와 6(거리 1)의 관계가 위치 105와 106(거리 1)의 관계와 동일하다는 정보를 모델에 직접 제공한다. 이는 절대적 위치보다 상대적 위치가 더 중요한 대부분의 자연어 처리 태스크에서 강력한 귀납적 편향으로 작용한다. 이어지는 장에서 살펴볼 RoPE는 이러한 진화의 다음 단계로, 절대 위치를 인코딩하면서도 어텐션 메커니즘의 내적 연산 내에서 자연스럽게 상대 위치 정보를 유도해내는 독창적인 방법을 통해 절대적 기준점의 필요성과 상대적 기하학의 일관성 사이의 긴장을 해소한다.</p>
<h2>2.  RoPE의 공식화: 회전을 통한 위치 인코딩</h2>
<p>RoPE(Rotary Positional Embedding)는 기존 위치 인코딩 방식들의 한계를 극복하기 위해 Su et al. (2021)에 의해 제안된 혁신적인 방법이다.14 RoPE는 위치 정보를 임베딩에 더하는 대신, 임베딩 벡터 자체를 위치에 따라 ’회전’시키는 독창적인 아이디어를 기반으로 한다.</p>
<h3>2.1  직관적 프레임워크: 복소수에서 고차원 회전까지</h3>
<p>RoPE의 핵심 원리는 비유를 통해 직관적으로 이해할 수 있다. 위치 벡터를 단순히 더하는 대신, RoPE는 토큰 임베딩 벡터를 고차원 공간에서 회전시킨다.7 이때 회전 각도는 토큰의 절대 위치 <span class="math math-inline">m</span>에 비례하는 <span class="math math-inline">m\theta</span>로 결정된다.7</p>
<p>이 개념은 서로 다른 속도(주파수)로 회전하는 여러 개의 시곗바늘에 비유할 수 있다.19 각 시곗바늘 쌍(임베딩의 두 차원)은 고유한 회전 속도를 가지며, 빠른 속도의 시곗바늘은 가까운 토큰 간의 미세한 위치 관계를, 느린 속도의 시곗바늘은 시퀀스 전체에 걸친 거시적인 위치 관계를 인코딩한다. 이러한 회전은 임베딩 차원을 두 개씩 짝지어 복소수의 실수부와 허수부로 간주하고, 오일러 공식을 이용한 복소수 곱셈을 통해 효율적으로 구현된다.15</p>
<h3>2.2  수학적 유도 및 핵심 공식</h3>
<p>RoPE의 수학적 유도는 2차원 공간에서 시작하여 고차원으로 일반화된다. 목표는 위치 <span class="math math-inline">m</span>의 쿼리 벡터 <span class="math math-inline">q_m</span>과 위치 <span class="math math-inline">n</span>의 키 벡터 <span class="math math-inline">k_n</span>의 내적이 두 토큰의 임베딩 <span class="math math-inline">x_m, x_n</span>과 상대 위치 <span class="math math-inline">m-n</span>에만 의존하는 함수 <span class="math math-inline">g</span>로 표현되도록 하는 것이다.15<br />
<span class="math math-display">
\langle f_q(x_m, m), f_k(x_n, n) \rangle = g(x_m, x_n, m-n)
</span><br />
2차원 벡터를 복소수 <span class="math math-inline">z = x_1 + ix_2</span>로 표현할 때, 이 벡터를 각도 <span class="math math-inline">m\theta</span>만큼 회전시키는 것은 복소수 <span class="math math-inline">e^{im\theta}</span>를 곱하는 것과 동일하다. 이 원리를 적용하여, 위치 정보가 주입된 쿼리와 키 함수는 다음과 같이 정의할 수 있다.<br />
<span class="math math-display">
f_{\{q,k\}}(x_m, m) = (W_{\{q,k\}} x_m)e^{im\theta}
</span><br />
여기서 <span class="math math-inline">W_{\{q,k\}}</span>는 쿼리 또는 키를 위한 투영 행렬이다.</p>
<p>이 개념을 <span class="math math-inline">d</span>차원 벡터로 확장하기 위해, <span class="math math-inline">d</span>차원 임베딩 공간을 <span class="math math-inline">d/2</span>개의 2차원 하위 공간으로 나눈다.11 각 하위 공간(차원 쌍)은 독립적으로 회전 변환을 겪는다. 위치 <span class="math math-inline">m</span>에 대한 <span class="math math-inline">d</span>차원 회전 행렬 <span class="math math-inline">R^d_{\Theta,m}</span>은 다음과 같은 블록 대각 행렬(block diagonal matrix) 형태로 정의된다.15<br />
<span class="math math-display">
R^d_{\Theta,m} = \begin{pmatrix}
\cos m\theta_1 &amp; -\sin m\theta_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\sin m\theta_1 &amp; \cos m\theta_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \cos m\theta_2 &amp; -\sin m\theta_2 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \sin m\theta_2 &amp; \cos m\theta_2 &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos m\theta_{d/2} &amp; -\sin m\theta_{d/2} \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \sin m\theta_{d/2} &amp; \cos m\theta_{d/2}
\end{pmatrix}
</span><br />
여기서 <span class="math math-inline">\Theta = \{\theta_i = b^{-2(i-1)/d}, i \in [1, 2,..., d/2]\}</span>는 미리 정의된 회전 주파수 집합이며, <span class="math math-inline">b</span>는 일반적으로 10000으로 설정되는 기저(base) 값이다.15 이 기하급수적으로 감소하는 주파수 <span class="math math-inline">\theta_i</span>는 차원 인덱스 <span class="math math-inline">i</span>가 작을수록(고차원) 회전 속도가 빠르고, <span class="math math-inline">i</span>가 클수록(저차원) 회전 속도가 느려지는 주파수 스펙트럼을 형성한다.1</p>
<p>최종적으로 위치 <span class="math math-inline">m</span>의 토큰 <span class="math math-inline">x_m</span>에 RoPE를 적용하는 공식은 다음과 같다.<br />
<span class="math math-display">
f_{\{q,k\}}(x_m, m) = R^d_{\Theta,m} W_{\{q,k\}}x_m
</span></p>
<h3>2.3  이론적 증명: 상대 위치 의존성 확보</h3>
<p>RoPE의 가장 중요한 수학적 속성은 회전된 쿼리 벡터와 키 벡터의 내적이 오직 상대 위치에만 의존한다는 점이다. 이는 다음과 같이 증명된다.15</p>
<p>위치 <span class="math math-inline">m</span>의 쿼리 <span class="math math-inline">q_m</span>과 위치 <span class="math math-inline">n</span>의 키 <span class="math math-inline">k_n</span>의 내적은 다음과 같다.<br />
<span class="math math-display">
q_m^\intercal k_n = (R^d_{\Theta,m} W_q x_m)^\intercal (R^d_{\Theta,n} W_k x_n) = x_m^\intercal W_q^\intercal (R^d_{\Theta,m})^\intercal R^d_{\Theta,n} W_k x_n
</span><br />
회전 행렬은 직교 행렬(orthogonal matrix)이므로, 전치 행렬은 역행렬과 같다. 즉, <span class="math math-inline">(R^d_{\Theta,m})^\intercal = (R^d_{\Theta,m})^{-1} = R^d_{\Theta,-m}</span> 이다. 두 회전 행렬의 곱은 각도의 합에 해당하는 회전과 같으므로, 다음의 핵심적인 관계가 성립한다.<br />
<span class="math math-display">
(R^d_{\Theta,m})^\intercal R^d_{\Theta,n} = R^d_{\Theta,-m} R^d_{\Theta,n} = R^d_{\Theta,n-m}
</span><br />
따라서 내적 공식은 다음과 같이 단순화된다.<br />
<span class="math math-display">
q_m^\intercal k_n = x_m^\intercal W_q^\intercal R^d_{\Theta,n-m} W_k x_n
</span><br />
이 최종식은 어텐션 점수가 토큰 임베딩 <span class="math math-inline">x_m, x_n</span>과 두 토큰의 **상대 위치 <span class="math math-inline">n-m</span>**에만 의존함을 명확히 보여준다.15 이로써 RoPE는 각 토큰의 절대 위치를 회전이라는 연산을 통해 인코딩하면서도, 자기-어텐션 메커니즘 내에서는 자연스럽게 상대 위치 정보를 활용하도록 설계되었음이 증명된다.</p>
<h3>2.4  주요 속성: 장기 감쇠 및 선형 어텐션 호환성</h3>
<p>RoPE는 위와 같은 수학적 특성으로부터 두 가지 중요한 속성을 갖는다.</p>
<ul>
<li><strong>장기 감쇠 (Long-term Decay):</strong> 내적 공식에 포함된 코사인, 사인 함수의 진동 특성으로 인해, 두 토큰 간의 상대 거리가 멀어질수록 어텐션 점수의 상한이 점차 감소하는 경향을 보인다. 이는 자연어에서 멀리 떨어진 단어 간의 연관성이 일반적으로 약하다는 직관과 부합하는 바람직한 속성이다.9</li>
<li><strong>선형 어텐션과의 호환성:</strong> RoPE는 쿼리와 키 벡터에 곱셈 연산을 통해 적용되므로 벡터의 L2 노름(norm)을 보존한다. 이는 가산적(additive) 방식과 달리 벡터의 크기를 변화시키지 않기 때문에, 선형 어텐션(linear attention)과 같은 근사 어텐션 메커니즘과 쉽게 결합될 수 있다.9</li>
</ul>
<p>RoPE의 설계는 의미론적 정보와 위치 정보의 우아한 분리를 보여준다. 토큰의 의미론적 내용은 임베딩 벡터의 크기(magnitude)와 초기 방향에 인코딩되는 반면, 위치 정보는 순수하게 해당 벡터에 적용되는 회전으로만 인코딩된다. 가산적 APE에서 최종 벡터는 <code>의미 벡터 + 위치 벡터</code>로 두 신호가 혼합되어 모델이 이를 분리하는 법을 배워야 했다. 그러나 RoPE에서 최종 벡터는 <code>회전(m) * 의미 벡터</code> 형태가 된다. 회전은 직교 변환이므로 벡터의 L2 노름을 보존하며, 이는 <code>||최종 벡터|| = ||의미 벡터||</code>임을 의미한다. 따라서 토큰의 핵심 의미가 담긴 ’에너지’는 위치에 상관없이 보존되고, 위치는 오직 고차원 공간 내에서 벡터의 ’방향’에만 영향을 미친다. 이는 모델에게 토큰의 핵심 의미는 위치에 따라 변하지 않지만, 다른 토큰과의 관계(내적으로 측정되는)는 변한다는 강력한 귀납적 편향을 제공한다. 이러한 정보의 분리는 학습 과제를 더 쉽고 안정적으로 만들며, 노름 보존 연산에 의존하는 선형 어텐션과의 높은 호환성을 설명하는 핵심적인 이유가 된다.</p>
<h2>3.  외삽 문제: 근본적인 한계</h2>
<p>RoPE는 이론적으로 우아하고 여러 장점을 지녔지만, 실제 적용에 있어 가장 큰 난관에 부딪히는데, 바로 훈련 시 경험한 문맥 길이(context length)를 벗어나는 시퀀스에 대한 외삽(extrapolation) 문제이다.</p>
<h3>3.1  훈련 문맥을 넘어서는 성능 저하 분석</h3>
<p>RoPE를 사용하여 최대 길이 <span class="math math-inline">L</span>의 시퀀스로 훈련된 모델에 <span class="math math-inline">L&#39; &gt; L</span>인 시퀀스를 입력으로 제공하면, 모델의 성능(예: Perplexity)이 급격하게 저하되는 현상이 관찰된다.22 이는 모델이 훈련 과정에서 특정 범위의 상대 각도 (<span class="math math-inline">(m-n)\theta_i</span>)에 대한 내적 값만을 해석하도록 학습되었기 때문이다. 위치 <span class="math math-inline">m, n</span>이 <span class="math math-inline">L</span>을 초과하면, 상대 각도는 모델이 한 번도 보지 못한 분포 외(Out-of-Distribution, OOD) 범위에 속하게 된다. 이 OOD 입력에 대해 모델은 안정적인 표현을 학습하지 못했으므로, 어텐션 점수가 예측 불가능하게 발산하거나 혼란스러운 패턴을 보여 전체적인 성능 붕괴로 이어진다.27</p>
<h3>3.2  “RoPE 기반 외삽의 스케일링 법칙”</h3>
<p>이 외삽 문제를 해결하기 위한 연구 과정에서 “RoPE 기반 외삽의 스케일링 법칙(Scaling Laws of RoPE-based Extrapolation)“이라는 통합된 프레임워크가 제안되었다.28 이 프레임워크는 모델의 외삽 성능이 RoPE의 기저(base) 값과 미세조정(fine-tuning) 시 사용되는 문맥 길이, 이 두 가지 핵심 요소와 어떤 관계를 맺는지를 설명한다.</p>
<p>이 연구의 가장 놀라운 발견 중 하나는, 기존의 통념(기저 값을 키워야만 외삽 성능이 향상된다)을 뒤집고, 미세조정 시 훈련 때보다 훨씬 <strong>크거나 작은</strong> 기저 값을 사용하면 모두 외삽 성능을 크게 향상시킬 수 있다는 점이다.28</p>
<ul>
<li><strong>더 큰 기저 값 사용:</strong> 기저 값을 키우면 회전 주파수 <span class="math math-inline">\theta_i</span>가 작아져 결과적으로 회전 각도가 감소한다. 이는 학습된 위치 표현의 범위를 ‘늘리는’ 효과를 가져와, 더 긴 위치를 기존에 학습된 각도 범위 내로 ’보간(interpolation)’하는 것과 유사하게 작동한다. 이를 ’회전 보간(rotational interpolation)’이라고도 한다.28</li>
<li><strong>더 작은 기저 값 사용:</strong> 기저 값을 줄이면 회전 주파수가 높아진다. 이는 훈련 중에 모델이 더 넓은 범위의 사인/코사인 함수 입력값(즉, 더 많은 전체 회전)에 노출되도록 하여, 보지 못한 각도에 대한 일반화 성능을 향상시킨다.29</li>
</ul>
<h3>3.3  “임계 차원“의 개념과 분포 외 임베딩</h3>
<p>외삽 문제가 발생하는 근본 원인을 더 깊이 이해하기 위해 “임계 차원(critical dimension)“이라는 개념이 도입되었다.28</p>
<ul>
<li><strong>정의:</strong> 임계 차원은 특정 차원의 회전 파장(wavelength, <span class="math math-inline">\lambda = 2\pi/\theta_i</span>)이 모델의 훈련 문맥 길이 <span class="math math-inline">L</span>과 거의 같아지는 차원을 의미한다. 즉, 한 번의 완전한 회전을 하는 데 필요한 토큰의 수가 훈련 길이와 비슷해지는 지점이다.</li>
</ul>
<p>이 임계 차원을 기준으로 임베딩 차원들은 두 그룹으로 나뉜다.</p>
<ul>
<li><strong>임계 이전 차원 (Pre-critical dimensions):</strong> 파장이 짧고(<span class="math math-inline">\lambda &lt; L</span>) 주파수가 높은 차원들이다. 이 차원들은 훈련 중에 여러 번의 완전한 회전(<span class="math math-inline">[0, 2\pi]</span>)을 경험하므로, 다양한 각도에 대한 표현을 충분히 학습하여 외삽 상황에서도 비교적 안정적이다.</li>
<li><strong>임계 이후 차원 (Post-critical dimensions):</strong> 파장이 길고(<span class="math math-inline">\lambda &gt; L</span>) 주파수가 낮은 차원들이다. 이 차원들은 훈련 중에 한 번의 완전한 회전조차 마치지 못한다. 따라서 시퀀스 길이가 <span class="math math-inline">L</span>을 초과하면, 이 차원들의 사인/코사인 함수에 입력되는 값은 훈련 시 전혀 경험하지 못한 OOD 영역에 해당하게 된다. 이것이 바로 외삽 실패의 직접적인 원인이 된다.28</li>
</ul>
<p>결론적으로, RoPE의 외삽 문제는 모델 전체의 단일한 실패가 아니라, RoPE가 정의하는 주파수 스펙트럼에 따라 발생하는 차원별 문제이다. 이 분석은 문제 해결의 방향이 주파수를 고려해야 함을 명확히 시사한다. 초기 관찰은 단순히 ’RoPE가 긴 시퀀스에서 실패한다’는 것이었다. 첫 번째 분석 수준에서는 ’상대 각도가 OOD이기 때문’이라고 이해했다. 그러나 ‘임계 차원’ 개념을 통해 더 깊이 분석한 결과, 이 OOD 문제는 임베딩 차원 전체에 걸쳐 균일하게 발생하지 않는다는 사실이 밝혀졌다. 문제는 주로 각도 범위 측면에서 ‘불충분하게 훈련된’ 저주파수(임계 이후) 차원에 집중된다. 고주파수 차원들은 이미 강건하다. 이는 해결책에 대한 중요한 시사점을 제공한다. 예를 들어, 위치 보간(PI)과 같은 순진한 해결책은 모든 차원을 균일하게 스케일링한다. 이는 이미 강건한 고주파수 차원을 불필요하게 압축하여 모델이 지역적 문맥을 이해하는 능력을 손상시킬 수 있으므로 차선책이다. 따라서 더 정교한 해결책은 고주파수와 저주파수 차원을 다르게 취급해야만 한다. 이러한 문제 진단은 NTK-aware 방법의 비균일 스케일링과 YaRN의 더 세분화된 “NTK-by-parts” 접근 방식의 설계를 직접적으로 이끌었다.</p>
<h2>4.  문맥 창 확장 방법론</h2>
<p>RoPE의 외삽 문제를 해결하기 위해 여러 기법이 개발되었다. 이 장에서는 주요 기법들을 심층적으로 분석하고 정량적으로 비교한다.</p>
<h3>4.1  선형 위치 보간 (PI): 기초적인 접근법</h3>
<ul>
<li><strong>메커니즘:</strong> 위치 보간(Position Interpolation, PI)의 핵심 아이디어는 간단하다. 더 긴 시퀀스의 위치 인덱스를 모델이 원래 훈련된 문맥 창 크기에 맞도록 선형적으로 축소하는 것이다.22 예를 들어, 2048 길이로 훈련된 모델을 4096 길이로 확장하고 싶다면, 0부터 4095까지의 위치 인덱스를 0부터 2047.5까지의 범위로 압축하여 RoPE를 계산한다. 수학적으로는 <span class="math math-inline">f&#39;(x, m) = f(x, mL/L&#39;)</span>로 표현된다.27</li>
<li><strong>장단점:</strong> PI는 구현이 간단하고 적은 양의 미세조정만으로도 상당한 효과를 볼 수 있다는 장점이 있다.22 그러나 모든 차원의 주파수를 균일하게 스케일링하기 때문에, 지역적 관계 모델링에 중요한 고주파수 정보가 손실되어 성능 저하를 유발할 수 있다.22</li>
</ul>
<h3>4.2  NTK-Aware 스케일링: 차별화된 주파수 보간</h3>
<ul>
<li><strong>메커니즘:</strong> 신경망 접선 커널(Neural Tangent Kernel, NTK) 이론에서 영감을 받은 이 방법은 PI의 단점을 보완한다. 모든 주파수를 동일하게 압축하는 대신, 비선형적인 스케일링을 적용하여 고주파수 성분은 덜 압축하고 저주파수 성분은 더 많이 압축한다.22 이는 주로 RoPE의 기저(base) 값 <span class="math math-inline">b</span>를 조정함으로써 구현된다.35</li>
<li><strong>장단점:</strong> PI에 비해 고주파수 세부 정보를 더 잘 보존하여 성능을 향상시킨다.22 하지만 일부 주파수가 여전히 훈련 범위를 벗어나 성능 불안정을 야기할 수 있으며, 특정 상황에서는 미세조정 시 PI보다 성능이 저하될 수도 있다.22</li>
</ul>
<h3>4.3  YaRN: “NTK-by-parts“와 온도 스케일링을 통한 최첨단 확장</h3>
<ul>
<li><strong>메커니즘:</strong> YaRN(Yet another RoPE extensioN method)은 현재 가장 진보된 문맥 확장 기법 중 하나로, 두 가지 핵심 혁신을 결합했다.22</li>
</ul>
<ol>
<li><strong>“NTK-by-parts” 보간:</strong> 이 기법은 차원의 파장에 따라 각기 다른 스케일링 전략을 적용한다. 파장이 매우 짧은(고주파수) 차원은 거의 스케일링하지 않고, 파장이 매우 긴(저주파수) 차원은 선형 보간하며, 그 사이의 차원들은 두 전략을 혼합하여 적용한다. 이를 통해 각 차원의 특성에 맞는 최적의 스케일링을 수행한다.35</li>
<li><strong>어텐션 온도 스케일링 (Attention Temperature Scaling):</strong> 위치 보간은 회전 각도를 줄여 멀리 떨어진 토큰 간의 내적 값을 증가시키고, 이로 인해 소프트맥스(softmax) 분포가 불필요하게 ‘뾰족해지는(sharp)’ 문제를 야기한다. YaRN은 이를 해결하기 위해 어텐션 로짓(logit)에 온도(temperature) 인자 <span class="math math-inline">t</span>를 도입하여 스케일링함으로써 어텐션 엔트로피를 보존하고 분포를 부드럽게 만든다.22</li>
</ol>
<ul>
<li><strong>장점:</strong> YaRN은 기존 방법들보다 훨씬 적은 미세조정 데이터와 훈련 단계만으로도 월등한 성능을 보인다. 128k 이상의 매우 긴 문맥에서도 안정적인 성능을 유지하며, 계산 효율성이 매우 높다.32</li>
</ul>
<h3>4.4  정량적 벤치마킹: 비교 분석</h3>
<p>이러한 확장 기법들의 성능을 정량적으로 비교하기 위해 Perplexity(PPL)와 “Needle-in-a-Haystack”(NIAH) 테스트 결과가 널리 사용된다.</p>
<ul>
<li><strong>Perplexity (PPL):</strong> PPL은 언어 모델이 주어진 텍스트를 얼마나 잘 예측하는지를 측정하는 지표로, 낮을수록 좋다. Proof-pile과 같은 장문 텍스트 벤치마크에서 NTK 기반 방법들과 YaRN은 PI나 기본 RoPE에 비해 확장된 문맥 길이에서 일관되게 더 낮은 PPL을 달성했다.34</li>
<li><strong>“Needle-in-a-Haystack” (NIAH) 테스트:</strong> 이 테스트는 모델이 긴 문서(건초더미) 속에 숨겨진 특정 정보(바늘)를 얼마나 잘 찾아내는지를 평가한다.40 실험 결과, RoPE 확장 기법들은 기본 모델에 비해 NIAH 테스트 통과율을 크게 향상시켰다. 하지만 어텐션 불확실성이 높은 구간에서는 여전히 실패하는 경향을 보였으며, 더 긴 문맥으로 미세조정된 모델이 가장 좋은 성능을 나타냈다.34</li>
</ul>
<p>다음 표는 주요 RoPE 확장 기법들의 정량적 성능을 요약한 것이다.</p>
<table><thead><tr><th>방법</th><th>핵심 메커니즘</th><th>미세조정 비용</th><th>최대 문맥</th><th>장문 PPL</th><th>NIAH 성능</th></tr></thead><tbody>
<tr><td><strong>기본 RoPE</strong></td><td>스케일링 없음</td><td>해당 없음</td><td><span class="math math-inline">L_{train}</span></td><td>발산</td><td>실패</td></tr>
<tr><td><strong>위치 보간 (PI)</strong></td><td>위치 인덱스의 선형 축소</td><td>낮음 (약 1k 스텝)</td><td>~62k</td><td>안정적이나 NTK/YaRN보다 높음</td><td>보통, 불확실성 높은 구간에서 실패</td></tr>
<tr><td><strong>NTK-Aware 스케일링</strong></td><td>비선형 스케일링 (기저 값 수정)</td><td>낮음-중간</td><td>~128k</td><td>PI보다 낮음</td><td>좋음, 때로 불안정</td></tr>
<tr><td><strong>YaRN</strong></td><td>“NTK-by-parts” + 어텐션 온도</td><td>매우 낮음 (약 400 스텝)</td><td>128k+</td><td>최첨단, 가장 낮은 PPL</td><td>최첨단, 높은 통과율</td></tr>
</tbody></table>
<h2>5.  실제 적용 사례: 구현 및 채택</h2>
<p>이 장에서는 RoPE가 실제 대규모 언어 모델(LLM)에 어떻게 통합되고 다양한 데이터 유형에 맞게 변형되며, 계산적 측면에서 어떤 특징을 갖는지 살펴본다.</p>
<h3>5.1  최신 LLM 아키텍처로의 통합 (LLaMA, PaLM)</h3>
<p>RoPE는 이론적 우아함과 강력한 성능 덕분에 LLaMA 시리즈, PaLM, Falcon, GPT-NeoX 등 다수의 최첨단 오픈 소스 LLM에서 사실상의 표준 위치 인코딩 방식으로 채택되었다.10</p>
<p>실제 구현에서는 쿼리(<span class="math math-inline">q</span>)와 키(<span class="math math-inline">k</span>) 텐서의 마지막 차원을 2개씩 짝지어 복소수처럼 다루도록 형태를 변환한 후, 미리 계산된 회전 주파수 텐서(<code>freqs_cis</code>)와 원소별 곱셈(element-wise multiplication)을 수행하는 방식으로 효율적으로 적용된다.16 LLaMA와 같은 모델의 설정 파일에서는 <code>rope_theta</code> 파라미터를 통해 RoPE의 기저 값을 조절할 수 있다.10</p>
<h3>5.2  비전 트랜스포머를 위한 변형: 2D RoPE와 RoPE-Mixed</h3>
<p>1차원 시퀀스 데이터에 최적화된 RoPE를 이미지와 같은 2차원 데이터에 직접 적용하는 것은 공간 구조 정보를 제대로 활용하지 못하는 차선책이다.4 이 문제를 해결하기 위해 비전 트랜스포머(ViT)를 위한 RoPE 변형이 개발되었다.</p>
<ul>
<li><strong>2D 축 방향 RoPE (2D Axial RoPE):</strong> 가장 간단한 확장 방식으로, 1D RoPE를 x축과 y축에 각각 독립적으로 적용한다. 이 방식은 대각선 방향의 공간적 관계를 효과적으로 포착하지 못하는 한계가 있다.4</li>
<li><strong>RoPE-Mixed:</strong> 이 한계를 극복하기 위해 제안된 방식으로, x축과 y축에 대한 주파수 파라미터를 혼합하여 사용하며 이 파라미터들을 학습 가능하게 만든다. 이를 통해 모델은 대각선 방향을 포함한 모든 2차원 공간 관계를 학습할 수 있으며, 추론 시 입력 이미지의 해상도를 높이는 외삽 상황에서 뛰어난 성능을 보인다.4</li>
</ul>
<h3>5.3  계산 및 메모리 복잡도 분석</h3>
<ul>
<li><strong>파라미터 효율성:</strong> RoPE는 학습 가능한 파라미터를 추가하지 않는 ‘파라미터-프리(parameter-free)’ 방식이다. 이는 학습 기반 APE나 T5 스타일의 편향 방식에 비해 모델 크기 측면에서 상당한 이점을 제공한다.49</li>
<li><strong>계산 비용 (FLOPs):</strong> RoPE 적용에는 쿼리 및 키 텐서에 대한 원소별 곱셈과 덧셈이 포함된다. 이는 어텐션 레이어의 주요 연산인 행렬 곱셈에 비하면 무시할 수 있는 수준의 추가 비용이다.7 최근에는 회로 복잡도 이론을 통해 RoPE 기반 트랜스포머의 계산 능력을 특정 복잡도 등급 내에 위치시키는 이론적 분석도 이루어지고 있다.55</li>
<li><strong>하드웨어 가속:</strong> NVIDIA의 cuDNN과 같은 최신 GPU 라이브러리나 FlashAttention-2와 같은 특화된 어텐션 구현은 전체 어텐션 연산을 하나의 융합된 커널(fused kernel)로 처리하여 최적화한다. RoPE 연산은 이 커널의 일부로 포함되어 암묵적으로 가속화된다. 비록 RoPE가 일부 빠른 어텐션 알고리즘을 복잡하게 만들 수 있지만, 이를 효율적으로 구현하기 위한 연구가 지속되고 있다.58</li>
</ul>
<p>주요 LLM들이 알려진 외삽 문제에도 불구하고 RoPE를 널리 채택한 사실은, RoPE의 핵심적인 장점들—파라미터 효율성, 훈련 문맥 내에서의 강력한 성능, 상대 위치 인코딩의 우아함—이 그것의 주된 한계점보다 더 중요하게 평가되었음을 시사한다. 이는 연구 커뮤니티가 RoPE를 ‘사용하기에 너무 결함이 많은’ 기술이 아니라 ‘고쳐서 쓸 가치가 충분한’ 기술로 판단했음을 보여준다. LLaMA나 PaLM과 같은 모델 개발 당시, APE는 확장성 문제가, T5-bias는 복잡성과 파라미터 추가 문제가 있었다. 반면 RoPE는 파라미터가 없고 계산적으로 깔끔하며 훈련 문맥 내에서 매우 우수한 성능을 보였다. 개발자들은 핵심 과제에 가장 우아하고 성능 좋은 방법을 채택하고, 장문 문맥 문제는 해결 가능한 별도의 공학적 과제로 취급하는 실용적인 선택을 한 것으로 보인다. 이러한 결정은 이후 PI, NTK, YaRN과 같은 연구들이 RoPE의 기반이 확장될 수 있을 만큼 견고함을 입증하면서 성공적인 전략이었음이 증명되었다.</p>
<h2>6.  심층 이론 분석 및 새로운 패러다임</h2>
<p>이 장에서는 RoPE에 대한 더 깊은 이론적 해석을 탐구하고, 차세대 위치 인코딩 방법론과 대안적인 아키텍처를 조망한다.</p>
<h3>6.1  비교 분석: RoPE 대 ALiBi</h3>
<ul>
<li><strong>ALiBi (Attention with Linear Biases) 메커니즘:</strong> RoPE의 주요 경쟁자인 ALiBi는 임베딩 자체를 수정하는 대신, 쿼리-키 어텐션 점수에 직접적으로 거리에 비례하여 선형적으로 감소하는 정적 편향(static bias)을 더하는 방식으로 작동한다.1</li>
<li><strong>외삽 성능 논쟁:</strong> 초기 ALiBi 논문은 RoPE보다 우수한 외삽 성능을 주장했다.63 그러나 후속 연구들은 이것이 ALiBi가 부과하는 강력한 ‘최신성 편향(recency bias)’ 때문일 수 있음을 시사한다. 이 편향은 사실상 부드러운 어텐션 윈도우(soft attention window) 역할을 하여 PPL 지표에는 도움이 될 수 있지만, 진정한 장거리 의존성이 필요한 태스크에서는 성능을 저해할 수 있다.65</li>
<li><strong>성능 및 채택:</strong> ALiBi는 BLOOM과 같은 모델에 사용되었지만, RoPE의 외삽 문제가 스케일링 기법들로 성공적으로 해결되면서 RoPE가 최신 모델들에서 더 폭넓게 채택되었다. 이는 ALiBi의 제한적인 편향이 장문 태스크에서 약점으로 작용할 수 있다는 인식 때문이다.66</li>
<li><strong>어텐션 싱크 (Attention Sink) 현상:</strong> 많은 자기회귀 모델에서 관찰되는 ‘어텐션 싱크’ 현상은, 의미론적 중요성과 무관하게 모델이 시퀀스의 첫 몇 개 토큰에 불균형적으로 높은 어텐션을 할당하는 것을 말한다.67 이는 상대 위치만 인코딩하는 RoPE에서는 역설적으로 보인다. 이에 대한 설명은 인과적 마스크(causal mask)가 암묵적인 절대 위치 기준점(anchor)을 제공하고, 모델이 이 초기 토큰들을 일종의 ’전역 정보 저장소’로 활용하도록 학습하기 때문이라는 것이다.67 이 현상은 ALiBi나 APE를 사용하는 모델에서도 동일하게 관찰되므로, 특정 위치 인코딩 방식의 특성이라기보다는 자기회귀 어텐션 메커니즘 자체의 창발적 속성(emergent property)으로 이해된다.67</li>
</ul>
<p>다음 표는 RoPE와 ALiBi의 핵심적인 특징을 비교한다.</p>
<table><thead><tr><th>특징</th><th>회전 위치 임베딩 (RoPE)</th><th>선형 편향 어텐션 (ALiBi)</th></tr></thead><tbody>
<tr><td><strong>메커니즘</strong></td><td>Q/K를 위치 의존적 회전 행렬로 곱함</td><td>어텐션 점수에 정적, 거리 비례 음수 편향을 더함</td></tr>
<tr><td><strong>정보 유형</strong></td><td>절대 위치를 인코딩하여 상대 의존성 유도</td><td>상대 거리를 직접 페널티로 인코딩</td></tr>
<tr><td><strong>파라미터</strong></td><td>파라미터 없음</td><td>파라미터 없음 (기울기는 헤드별로 고정)</td></tr>
<tr><td><strong>외삽 성능</strong></td><td>스케일링 기법(PI, YaRN) 없이는 취약. 스케일링 적용 시 최첨단.</td><td>별도 기법 없이 우수하나, 소프트 윈도우처럼 작동하여 장거리 어텐션을 제한할 수 있음.</td></tr>
<tr><td><strong>계산 비용</strong></td><td>Q/K에 대한 원소별 곱셈. 일부 테스트에서 ALiBi보다 느림.71</td><td>어텐션 행렬에 단순 덧셈. T5-bias보다 빠르고 메모리 효율적.63</td></tr>
<tr><td><strong>귀납적 편향</strong></td><td>거리에 따른 부드러운 의존성 감쇠</td><td>강력한 최신성 편향. 먼 토큰에 대한 어텐션이 크게 페널티를 받음.</td></tr>
<tr><td><strong>채택 현황</strong></td><td>최신 SOTA 모델(LLaMA, PaLM, Mistral)에서 지배적</td><td>BLOOM과 같은 모델에서 사용됨</td></tr>
<tr><td><strong>어텐션 싱크</strong></td><td>현상 나타남. 인과적 마스크와의 상호작용으로 추정.</td><td>현상 나타남. PE에 특화된 현상이 아님을 시사.</td></tr>
</tbody></table>
<h3>6.2  암묵적 푸리에 변환으로서의 RoPE: 스펙트럼 손상과 FoPE</h3>
<ul>
<li><strong>이론적 관점:</strong> 최근 분석은 RoPE를 은닉 상태에 대해 암묵적으로 비균일 이산 푸리에 변환(Non-Uniform Discrete Fourier Transform, NUDFT)을 수행하여 주기적인 어텐션을 가능하게 하는 메커니즘으로 해석한다.72</li>
<li><strong>스펙트럼 손상 (Spectrum Damage):</strong> 이 관점은 RoPE의 새로운 한계를 드러낸다. 트랜스포머 블록 내의 선형 레이어와 활성화 함수가 ’스펙트럼 손상’을 일으킨다는 것이다. 즉, 스펙트럼 누수와 왜곡을 통해 여러 주파수 성분이 단일 차원에 섞이게 되어 RoPE가 의도한 주기성을 훼손한다.73</li>
<li><strong>푸리에 위치 임베딩 (FoPE):</strong> 이 문제에 대한 해결책으로 푸리에 위치 임베딩(Fourier Position Embedding, FoPE)이 제안되었다. FoPE는 각 차원을 단일 사인파가 아닌 완전한 푸리에 급수(Fourier Series)로 모델링하여 파장별 정보 분리를 개선한다. 또한, 길이 외삽에 해로운, 불충분하게 훈련된 고주파수 성분을 명시적으로 제거(zero-out)함으로써 스펙트럼 손상에 대한 강건성을 높인다.72</li>
</ul>
<h3>6.3  SO(2)를 넘어서: 리 군 이론을 통한 RoPE의 일반화 (LieRE)</h3>
<ul>
<li><strong>RoPE의 한계:</strong> RoPE의 수학적 기반은 SO(2) 리 군(Lie group), 즉 2차원 평면에서의 회전이다. 이는 1차원 시퀀스에는 효과적인 귀납적 편향이지만, 이미지나 비디오와 같이 공간적 관계가 더 복잡한 고차원 데이터에는 최적이 아니다.77</li>
<li><strong>LieRE의 일반화:</strong> LieRE(Lie Group Relative Encodings)는 RoPE를 일반화하여, 고정된 블록-대각 2D 회전 행렬을 SO(n) 리 군에서 유도된 학습 가능한 고밀도(dense) 고차원 회전 행렬로 대체한다. LieRE는 비대칭 행렬(리 대수 원소)의 기저를 학습한 후, 이를 지수 사상(exponential map)을 통해 회전 행렬로 변환한다. 이를 통해 n차원 데이터에 더 적합한 풍부하고 학습 가능한 위치 인코딩을 생성한다.5</li>
</ul>
<h3>6.4  동적, 내용-인식 위치 정보 (CABLE)</h3>
<ul>
<li><strong>RoPE/ALiBi의 한계:</strong> RoPE와 ALiBi는 모두 정적(static)이다. 즉, 위치 정보가 토큰의 실제 내용과 무관하게 오직 위치 인덱스에 의해서만 결정된다.</li>
<li><strong>CABLE의 혁신:</strong> CABLE(Context-Aware Biases for Length Extrapolation)은 동적인, 내용-결정적(content-determined) 위치 편향을 도입한다. CABLE은 각 토큰 임베딩을 작은 신경망에 통과시켜 토큰별, 헤드별 편향을 학습한다. 이를 통해 위치 편향이 입력 시퀀스의 내용에 따라 동적으로 적응할 수 있게 되어, 고정된 RPE의 경직성을 극복한다.83</li>
</ul>
<h3>6.5  아키텍처 대안: 상태 공간 모델(Mamba)의 암묵적 위치 인식</h3>
<ul>
<li><strong>새로운 패러다임:</strong> Mamba와 같은 상태 공간 모델(State Space Models, SSMs)은 어텐션 메커니즘에서 벗어난 새로운 아키텍처이다. Mamba는 시퀀스를 선형적으로 처리하는 완전 순환(fully recurrent) 모델이다.92</li>
<li><strong>암묵적 순서 처리:</strong> 순환적인 특성으로 인해 Mamba는 본질적으로 정보를 순서대로 처리한다. 특히 선택적 상태(selective state) 메커니즘은 현재 토큰의 내용에 기반하여 각 단계에서 어떤 정보를 전파하고 어떤 정보를 잊을지 결정한다.94 이러한 내재적인 순차 처리 능력 덕분에, 순열 등변적인 어텐션 블록에 위치 정보를 ’추가’해야 하는 트랜스포머와 달리, Mamba는 RoPE와 같은 명시적인 위치 인코딩 메커니즘이 필요하지 않다.99</li>
</ul>
<p>위치 인코딩 분야 전체는 AI 연구의 경로 의존성(path-dependency)을 보여주는 대표적인 사례이다. 트랜스포머의 초기 설계에서 강력하지만 순열 등변적인 어텐션 메커니즘을 채택한 결정은, 이 하나의 한계를 ’수정’하기 위한 복잡한 하위 연구 분야 전체를 탄생시켰다. APE에서 RPE, RoPE, YaRN, CABLE, LieRE에 이르는 발전은 모두 독창적인 해결책이지만, 근본적으로는 초기 설계에 대한 ’패치’이다. 한편, Mamba와 같은 아키텍처의 등장은 순차적 상태 업데이트라는 핵심 개념을 유지하면서 트랜스포머 수준의 성능을 달성할 수 있음을 보여준다. 이는 미래의 시퀀스 모델이 처음부터 내재적인 순차 인식 능력을 갖도록 설계되어, 명시적인 위치 인코딩이라는 개념 자체를 불필요하게 만들 수 있음을 시사한다. 따라서 RoPE와 그 후속 연구들의 역사는 뛰어난 혁신의 이야기인 동시에, 초기 아키텍처 선택이 가져오는 장기적인 결과에 대한 잠재적인 교훈이기도 하다.</p>
<h2>7.  종합 및 향후 연구 방향</h2>
<h3>7.1  트랜스포머 생태계에서 RoPE의 역할에 대한 비판적 평가</h3>
<p>본 안내서의 분석을 종합하면, RoPE는 이전 세대 위치 인코딩의 문제점들을 우아하게 해결했지만, ’길이 외삽’이라는 새로운 도전 과제를 제시한 중추적인 혁신으로 평가할 수 있다. 이후 RoPE 스케일링에 대한 연구들은 현재의 장문맥 LLM 시대를 여는 데 결정적인 역할을 했다. RoPE의 근본적인 강점은 의미론적 정보와 위치 정보를 깔끔하게 분리(decoupling)하는 능력에 있으며, 이는 미래의 아키텍처 설계에서도 중요한 원칙으로 작용할 수 있다.100</p>
<h3>7.2  미해결 과제와 위치 정보의 미래</h3>
<p>위치 인코딩 연구의 흐름은 정적이고 내용과 무관한 방식(RoPE)에서 동적이고 내용에 민감하며(CABLE, TAPE 107), 기하학적으로 더 풍부한(LieRE) 표현으로 나아가고 있다.</p>
<p>궁극적으로는 Mamba와 같은 SSM 기반 아키텍처가 명시적인 위치 인코딩의 필요성을 없애는 방향으로 패러다임이 전환될 수 있다.92 더 나아가, RoPE와 같은 명시적이고 경직된 구조가 LLM의 ’창발적 능력(emergent abilities)’을 제한할 수 있는지, 그리고 NoPE나 SSM과 같이 더 유연하거나 암묵적인 방식이 새로운 능력을 발현시킬 수 있는지에 대한 철학적 질문도 중요한 연구 주제로 남는다.65 위치 정보 처리 방식의 진화는 단순히 기술적 개선을 넘어, 인공지능이 순서와 구조를 이해하는 근본적인 방식에 대한 우리의 이해를 심화시키는 과정이 될 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Positional Embeddings in Transformers: A Math Guide to RoPE &amp; ALiBi, https://towardsdatascience.com/positional-embeddings-in-transformers-a-math-guide-to-rope-alibi/</li>
<li>Understanding Positional Embeddings in Transformers: From Absolute to Rotary, https://towardsdatascience.com/understanding-positional-embeddings-in-transformers-from-absolute-to-rotary-31c082e16b26/</li>
<li>Rotatory Position Embedding (RoPE) - Karthick Panner Selvam, https://karthick.ai/blog/2024/Rotatory-Position-Embedding-(RoPE)/</li>
<li>Rotary Position Embedding for Vision Transformer - arXiv, https://arxiv.org/html/2403.13298v1</li>
<li>LieRE: Generalizing Rotary Position Encodings - arXiv, https://arxiv.org/html/2406.10322v1</li>
<li>Rope to Nope and Back Again: A New Hybrid Attention Strategy - arXiv, https://arxiv.org/html/2501.18795v1</li>
<li>Rotary Positional Embeddings: A Detailed Look and Comprehensive Understanding | by azhar - Medium, https://medium.com/ai-insights-cobet/rotary-positional-embeddings-a-detailed-look-and-comprehensive-understanding-4ff66a874d83</li>
<li>Understanding Positional Embeddings in Transformers: From …, https://towardsdatascience.com/understanding-positional-embeddings-in-transformers-from-absolute-to-rotary-31c082e16b26</li>
<li>(PDF) RoFormer: Enhanced Transformer with Rotary Position Embedding - ResearchGate, https://www.researchgate.net/publication/351019664_RoFormer_Enhanced_Transformer_with_Rotary_Position_Embedding</li>
<li>Llama - Hugging Face, https://huggingface.co/docs/transformers/main/model_doc/llama</li>
<li>Understanding Rotary Positional Encoding | by Ngieng Kianyew - Medium, https://medium.com/@ngiengkianyew/understanding-rotary-positional-encoding-40635a4d078e</li>
<li>Llama 4’s Architecture Deconstructed: MoE, iRoPE, and Early Fusion Explained - Medium, https://medium.com/@mandeep0405/llama-4s-architecture-deconstructed-moe-irope-and-early-fusion-explained-e58eb9403067</li>
<li>Building a Transformer LLM with Code: Evolution of Positional Encoding - Saurabh Yadav, https://www.yadavsaurabh.com/building-a-transformer-llm-with-code-evolution-of-positional-encoding/</li>
<li>RoFormer: Enhanced Transformer with Rotary Position Embedding - Cool Papers, https://papers.cool/arxiv/2104.09864</li>
<li>[2104.09864] RoFormer: Enhanced Transformer with Rotary Position Embedding - arXiv, https://arxiv.org/abs/2104.09864</li>
<li>A Deep Dive into Rotary Positional Embeddings (RoPE): Theory and …, https://medium.com/@parulsharmmaa/understanding-rotary-positional-embedding-and-implementation-9f4ad8b03e32</li>
<li>Effective Long-Context Scaling of Foundation Models - arXiv, https://arxiv.org/pdf/2309.16039</li>
<li>Resonance RoPE: Improving Context Length Generalization of Large Language Models, https://arxiv.org/html/2403.00071v1</li>
<li>Rotary Positional Embeddings (RoPE) - The Large Language Model Playbook, https://cyrilzakka.github.io/llm-playbook/nested/rot-pos-embed.html?utm_source=hnblogs.substack.com</li>
<li>RoPE-As-Implemented-in-LlaMa-Source-Code.ipynb - GitHub, https://github.com/rohan-paul/LLM-FineTuning-Large-Language-Models/blob/main/LLM_Techniques_and_utils/RoPE-As-Implemented-in-LlaMa-Source-Code.ipynb</li>
<li>Round and Round We Go! What makes Rotary Positional Encodings useful? - arXiv, https://arxiv.org/html/2410.06205v1</li>
<li>Long Text Processing Method — Yarn | by tangbasky | Data Science Collective | Medium, https://medium.com/data-science-collective/long-text-processing-method-yarn-d7b2d1f289a0</li>
<li>ZhuiyiTechnology/roformer: Rotary Transformer - GitHub, https://github.com/ZhuiyiTechnology/roformer</li>
<li>[2104.09864] RoFormer: Enhanced Transformer with Rotary Position Embedding - ar5iv, https://ar5iv.labs.arxiv.org/html/2104.09864</li>
<li>RoPE: Rotary Positional Embeddings - My Computational Genomic Playground - zqfang, https://zqfang.github.io/2024-07-29-nlp-rope/</li>
<li>What is RoPE Scaling - Hopsworks, https://www.hopsworks.ai/dictionary/rope-scaling</li>
<li>Extending Context Window of Large Language Models via …, https://arxiv.org/pdf/2306.15595</li>
<li>Scaling Laws of RoPE-based Extrapolation - OpenReview, https://openreview.net/forum?id=JO7k0SJ5V6</li>
<li>Paper page - Scaling Laws of RoPE-based Extrapolation, https://huggingface.co/papers/2310.05209</li>
<li>Scaling Laws of RoPE-based Extrapolation - arXiv, https://arxiv.org/html/2310.05209v2</li>
<li>Resonance RoPE: Improving Context Length Generalization of Large Language Models - ACL Anthology, https://aclanthology.org/2024.findings-acl.32.pdf</li>
<li>YaRN: Efficient Context Window Extension of Large Language Models - arXiv, https://arxiv.org/pdf/2309.00071</li>
<li>Extending Context Window of Large Language Models via Positional Interpolation - arXiv, https://arxiv.org/abs/2306.15595</li>
<li>Understanding the RoPE Extensions of Long … - ACL Anthology, https://aclanthology.org/2025.coling-main.600.pdf</li>
<li>Understanding YaRN: Extending Context Window of LLMs | by RAJAT CHAWLA | Medium, https://medium.com/@rcrajatchawla/understanding-yarn-extending-context-window-of-llms-3f21e3522465</li>
<li>YARN: EFFICIENT CONTEXT WINDOW EXTENSION … - OpenReview, https://openreview.net/pdf?id=wHBfxhZu1u</li>
<li>Linear Rope vs NTK vs YaRN vs CoPE | by Zain ul Abideen | Medium, https://medium.com/@zaiinn440/linear-rope-vs-ntk-vs-yarn-vs-cope-d33587ddfd35</li>
<li>YaRN: Efficient Context Window Extension of Large Language Models, https://iclr.cc/media/iclr-2024/Slides/17499.pdf</li>
<li>[R] YaRN: Efficient Context Window Extension of Large Language Models - Nous Research 2023 - Open source allows context windows of up to 128k! : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/16a1hfe/r_yarn_efficient_context_window_extension_of/</li>
<li>The Needle In a Haystack Test: Evaluating the Performance of LLM RAG Systems - Arize AI, https://arize.com/blog-course/the-needle-in-a-haystack-test-evaluating-the-performance-of-llm-rag-systems/</li>
<li>The Needle In a Haystack Test. Evaluating the performance of RAG… | by Aparna Dhinakaran | TDS Archive | Medium, https://medium.com/data-science/the-needle-in-a-haystack-test-a94974c1ad38</li>
<li>Needle In A Haystack Evaluation - OpenCompass’ documentation! - Read the Docs, https://opencompass.readthedocs.io/en/latest/advanced_guides/needleinahaystack_eval.html</li>
<li>Needle in a Haystack full results for Phi3-mini (3.8B)-128k. - ResearchGate, https://www.researchgate.net/figure/Needle-in-a-Haystack-full-results-for-Phi3-mini-38B-128k_fig2_389398875</li>
<li>Future of LLM: 3 Inventions Shaping the Next-Gen AI Models, https://www.analyticsvidhya.com/blog/2025/08/future-of-llm/</li>
<li>[2401.07004] Extending LLMs’ Context Window with 100 Samples - arXiv, https://arxiv.org/abs/2401.07004</li>
<li>Optimizing LLMs for Speed and Memory - Hugging Face, https://huggingface.co/docs/transformers/llm_tutorial_optimization</li>
<li>Scaling Instruction-Tuned LLMs to Million-Token Contexts via Hierarchical Synthetic Data Generation - arXiv, https://arxiv.org/html/2504.12637v1</li>
<li>7 Popular LLMs Explained in 7 Minutes: GPT, BERT, LLaMA &amp; More | by Rohan Mistry | Medium, https://medium.com/@rohanmistry231/7-popular-llms-explained-in-7-minutes-gpt-bert-llama-more-239807219f6f</li>
<li>Inside RoPE: Rotary Magic into Position Embeddings - LearnOpenCV, https://learnopencv.com/rope-position-embeddings/</li>
<li>Implementing LLaMA 4 from Scratch - Daily Dose of Data Science, https://www.dailydoseofds.com/building-llama-4-from-scratch-with-python/</li>
<li>Rotary Position Embedding for Vision Transformer, https://arxiv.org/abs/2403.13298</li>
<li>Rotary Position Embedding for Vision Transformer | Request PDF - ResearchGate, https://www.researchgate.net/publication/385505481_Rotary_Position_Embedding_for_Vision_Transformer</li>
<li>Rotary Position Embedding for Vision Transformer - ChatPaper, https://chatpaper.com/chatpaper/paper/100062</li>
<li>Daily Papers - Hugging Face, <a href="https://huggingface.co/papers?q=2D+RoPE">https://huggingface.co/papers?q=2D%20RoPE</a></li>
<li>[Literature Review] Circuit Complexity Bounds for RoPE-based Transformer Architecture, https://www.themoonlight.io/en/review/circuit-complexity-bounds-for-rope-based-transformer-architecture</li>
<li>Circuit Complexity Bounds for RoPE-based Transformer Architecture - arXiv, https://arxiv.org/html/2411.07602v1</li>
<li>Fast RoPE Attention: Combining the Polynomial Method and Fast Fourier Transform - arXiv, https://arxiv.org/html/2505.11892v1</li>
<li>catie-aq/flashT5: A fast implementation of T5/UL2 in PyTorch using Flash Attention - GitHub, https://github.com/catie-aq/flashT5</li>
<li>FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning, https://openreview.net/forum?id=mZn2Xyh9Ec</li>
<li>Accelerating Self-Attentions for LLM Serving with FlashInfer, https://flashinfer.ai/2024/02/02/introduce-flashinfer.html</li>
<li>Accelerating Transformers with NVIDIA cuDNN 9 | NVIDIA Technical Blog, https://developer.nvidia.com/blog/accelerating-transformers-with-nvidia-cudnn-9/</li>
<li>The Impact of Positional Encoding on Length Generalization in …, https://arxiv.org/pdf/2305.19466</li>
<li>Train Short, Test Long: Attention with Linear Biases Enables Input …, https://arxiv.org/pdf/2108.12409</li>
<li>ALiBi Deep Dive: Interpolation vs. Extrapolation - SambaNova, https://sambanova.ai/blog/alibi-interpolation-vs-extrapolation</li>
<li>The Impact of Positional Encoding on Length Generalization in Transformers - OpenReview, https://openreview.net/forum?id=Drrl2gcjzl</li>
<li>Why people use RoPE instead of Alibi when buliding their models? : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/165b0tw/why_people_use_rope_instead_of_alibi_when/</li>
<li>Question on intuition of “attention sink” and “alibi PE” · Issue #42 · mit-han-lab/streaming-llm, https://github.com/mit-han-lab/streaming-llm/issues/42</li>
<li>When Attention Sink Emerges in Language Models: An Empirical View - OpenReview, https://openreview.net/forum?id=78Nn4QJTEN</li>
<li>Efficient Streaming Language Models with Attention Sinks - OpenReview, https://openreview.net/forum?id=NG7sS51zVF</li>
<li>[R] How do RoPE-based LLMs learn attention sinks (or encode absolute positions)? - Reddit, https://www.reddit.com/r/MachineLearning/comments/1g8yurr/r_how_do_ropebased_llms_learn_attention_sinks_or/</li>
<li>The Use Case for Relative Position Embeddings - Ofir Press, https://ofir.io/The-Use-Case-for-Relative-Position-Embeddings/</li>
<li>Fourier Position Embedding: Enhancing Attention’s Periodic Extension for Length Generalization - arXiv, https://arxiv.org/html/2412.17739v3</li>
<li>Fourier Position Embedding: Enhancing Attention’s Periodic Extension for Length Generalization - arXiv, https://arxiv.org/html/2412.17739v1</li>
<li>[2412.17739] Fourier Position Embedding: Enhancing Attention’s Periodic Extension for Length Generalization - arXiv, https://arxiv.org/abs/2412.17739</li>
<li>(PDF) EnergyFormer: Energy Attention with Fourier Embedding for Hyperspectral Image Classification - ResearchGate, https://www.researchgate.net/publication/389748529_EnergyFormer_Energy_Attention_with_Fourier_Embedding_for_Hyperspectral_Image_Classification</li>
<li>EnergyFormer: Energy Attention with Fourier Embedding for Hyperspectral Image Classification - arXiv, https://arxiv.org/pdf/2503.08239</li>
<li>LieRE: Lie Rotational Positional Encodings - arXiv, https://arxiv.org/html/2406.10322v3</li>
<li>LieRE: Lie Rotational Positional Encodings | OpenReview, <a href="https://openreview.net/forum?id=yMJAYbGcCc&amp;noteId=ou3QtiZb5B">https://openreview.net/forum?id=yMJAYbGcCc¬eId=ou3QtiZb5B</a></li>
<li>LieRE: Lie Rotational Positional Encodings - Stanford Computer …, https://cs.stanford.edu/people/baxelrod/pdfs/liere.pdf</li>
<li>LieRE: Generalizing Rotary Position Encodings to Higher …, https://openreview.net/forum?id=xHMMt7r3GW</li>
<li>LieRE: Generalizing Rotary Position Encodings | Request PDF - ResearchGate, https://www.researchgate.net/publication/381484765_LieRE_Generalizing_Rotary_Position_Encodings</li>
<li>LieRE: Lie Rotational Positional Encodings - Brian Axelrod - Stanford Computer Science, https://cs.stanford.edu/people/baxelrod/liere/</li>
<li>Context-aware Biases for Length Extrapolation - arXiv, https://arxiv.org/html/2503.08067v1</li>
<li>[2503.08067] Context-aware Biases for Length Extrapolation - arXiv, https://arxiv.org/abs/2503.08067</li>
<li>Context-aware Biases for Length Extrapolation - arXiv, https://arxiv.org/html/2503.08067v2</li>
<li>Paper page - Context-aware Biases for Length Extrapolation - Hugging Face, https://huggingface.co/papers/2503.08067</li>
<li>[Revisión de artículo] Context-aware Biases for Length Extrapolation - Moonlight, https://www.themoonlight.io/es/review/context-aware-biases-for-length-extrapolation</li>
<li>(PDF) Context-aware Biases for Length Extrapolation - ResearchGate, https://www.researchgate.net/publication/389748371_Context-aware_Biases_for_Length_Extrapolation</li>
<li>Context-aware Biases for Length Extrapolation - ChatPaper, https://chatpaper.com/paper/119716</li>
<li>Context-aware Biases for Length Extrapolation - OpenReview, https://openreview.net/attachment?id=gU5bzWRmDV&amp;name=pdf</li>
<li>Context-aware Biases for Length Extrapolation - arXiv, https://arxiv.org/pdf/2503.08067</li>
<li>state-spaces/mamba: Mamba SSM architecture - GitHub, https://github.com/state-spaces/mamba</li>
<li>A hybrid model based on transformer and Mamba for enhanced sequence modeling - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC11968869/</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, https://arxiv.org/html/2312.00752v2</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective State Spaces - Semantic Scholar, https://www.semanticscholar.org/paper/Mamba%3A-Linear-Time-Sequence-Modeling-with-Selective-Gu-Dao/7bbc7595196a0606a07506c4fb1473e5e87f6082</li>
<li>[2312.00752] Mamba: Linear-Time Sequence Modeling with Selective State Spaces - arXiv, https://arxiv.org/abs/2312.00752</li>
<li>MAMBA and State Space Models Explained | by Astarag Mohapatra - Medium, https://athekunal.medium.com/mamba-and-state-space-models-explained-b1bf3cb3bb77</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective … - arXiv, https://arxiv.org/pdf/2312.00752</li>
<li>Positional Encoding · Issue #51 · state-spaces/mamba - GitHub, https://github.com/state-spaces/mamba/issues/51</li>
<li>Positional Embeddings in Transformer Models: Evolution from Text to Vision Domains | ICLR Blogposts 2025 - Cloudfront.net, https://d2jud02ci9yv69.cloudfront.net/2025-04-28-positional-embedding-19/blog/positional-embedding/</li>
<li>Paper page - DDT: Decoupled Diffusion Transformer - Hugging Face, https://huggingface.co/papers/2504.05741</li>
<li>On the Emergence of Position Bias in Transformers - arXiv, <a href="https://arxiv.org/pdf/2502.01951">https://arxiv.org/pdf/2502.01951?</a></li>
<li>[2504.05741] DDT: Decoupled Diffusion Transformer - arXiv, https://arxiv.org/abs/2504.05741</li>
<li>[2408.06123] DPDETR: Decoupled Position Detection Transformer for Infrared-Visible Object Detection - arXiv, https://arxiv.org/abs/2408.06123</li>
<li>DDT: Decoupled Diffusion Transformer - arXiv, https://arxiv.org/html/2504.05741v2</li>
<li>[2104.08698] A Simple and Effective Positional Encoding for Transformers - arXiv, https://arxiv.org/abs/2104.08698</li>
<li>[2501.00712] Rethinking Addressing in Language Models via Contexualized Equivariant Positional Encoding - arXiv, https://arxiv.org/abs/2501.00712</li>
<li>How Effective are State Space Models for Machine Translation? - ACL Anthology, https://aclanthology.org/2024.wmt-1.111.pdf</li>
<li>[R] Are Emergent Abilities in Large Language Models just In-Context Learning? - Reddit, https://www.reddit.com/r/MachineLearning/comments/19bkcqz/r_are_emergent_abilities_in_large_language_models/</li>
<li>Why Are Positional Encodings Nonessential for Deep Autoregressive Transformers? Revisiting a Petroglyph - arXiv, https://arxiv.org/html/2501.00659v1</li>
<li>[2203.16634] Transformer Language Models without Positional Encodings Still Learn Positional Information - arXiv, https://arxiv.org/abs/2203.16634</li>
<li>Emergent Abilities in Large Language Models: An Explainer, https://cset.georgetown.edu/article/emergent-abilities-in-large-language-models-an-explainer/</li>
<li>Examining Emergent Abilities in Large Language Models | Stanford HAI, https://hai.stanford.edu/news/examining-emergent-abilities-large-language-models</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>