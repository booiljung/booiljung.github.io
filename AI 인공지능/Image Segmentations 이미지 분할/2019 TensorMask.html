<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:TensorMask (2019)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>TensorMask (2019)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">이미지 분할 (Image Segmentations)</a> / <span>TensorMask (2019)</span></nav>
                </div>
            </header>
            <article>
                <h1>TensorMask (2019)</h1>
<h2>1. 인스턴스 분할의 새로운 패러다임, TensorMask</h2>
<h3>1.1  기존 인스턴스 분할의 지배적 패러다임: ‘탐지 후 분할’</h3>
<p>컴퓨터 비전 분야에서 인스턴스 분할(instance segmentation)은 각 객체의 경계 상자(bounding box)를 찾는 것을 넘어, 픽셀 단위로 정확한 윤곽(mask)을 식별해야 하는 고차원적 과제이다. 이 분야는 오랫동안 Mask R-CNN에 의해 대중화된 ’탐지 후 분할(detect-then-segment)’이라는 2단계(two-stage) 패러다임이 지배해왔다.1 이 접근법은 먼저 Faster R-CNN과 같은 객체 탐지기를 사용하여 이미지 내 객체들의 위치를 나타내는 후보 영역(region proposal) 또는 경계 상자를 생성한다. 이후, 각 후보 영역에 대해 독립적으로 분할 네트워크를 적용하여 최종적인 픽셀 단위 마스크를 예측하는 순차적 구조를 가진다.4</p>
<p>이러한 2단계 방식은 높은 정확도를 달성하며 인스턴스 분할 분야의 표준으로 자리 잡았으나, 구조적인 한계 또한 내포하고 있다. 전체 과정이 순차적으로 진행되므로 구조가 복잡하며, 최종 분할 성능이 첫 단계인 객체 탐지, 즉 후보 영역의 품질에 강하게 의존한다는 단점이 존재한다.</p>
<h3>1.2  조밀한 예측(Dense Prediction)의 가능성과 미개척 분야</h3>
<p>인스턴스 분할과 달리, 객체 탐지 분야에서는 슬라이딩 윈도우(sliding-window) 방식에 기반한 조밀한 예측(dense prediction) 모델들이 큰 성공을 거두었다. SSD(Single Shot MultiBox Detector)나 RetinaNet과 같은 모델들은 이미지 전체에 걸쳐 조밀하고 규칙적인 그리드(grid) 위에서 직접 객체의 위치와 클래스를 예측한다.1 이러한 1단계(one-stage) 접근법은 2단계 방식에 대한 효율적이고 강력한 대안을 제시하며 객체 탐지 기술의 발전을 이끌었다.</p>
<p>하지만 인스턴스 분할 분야에서는 이러한 조밀한 슬라이딩 윈도우 방식이 놀라울 정도로 탐구되지 않은 미개척 분야로 남아 있었다.2 경계 상자는 4개의 좌표 값으로 표현되는 저차원 구조인 반면, 마스크는 그 자체가 2차원의 공간적 구조를 가지기 때문에 조밀한 예측을 적용하기가 개념적으로 더 복잡했기 때문이다. 이로 인해 객체 탐지 분야의 발전과 인스턴스 분할 분야의 발전 사이에 방법론적 격차가 발생하였다.</p>
<h3>1.3  TensorMask의 제안: 조밀한 분할을 위한 근본적 토대</h3>
<p>TensorMask는 바로 이 연구의 공백을 메우고, 조밀한 슬라이딩 윈도우 인스턴스 분할이라는 새로운 패러다임을 탐구하기 위한 근본적인 토대를 제공하고자 제안되었다.2 연구의 핵심 통찰은 인스턴스 분할 작업이 다른 조밀한 예측 작업, 예컨대 의미론적 분할(semantic segmentation)이나 경계 상자 탐지와는 본질적으로 다르다는 인식에서 출발한다. 즉, 이미지의 모든 공간 위치 <code>(x, y)</code>에서의 예측 결과가 단순한 클래스 레이블이나 좌표 값이 아니라, 그 자체로 고유한 공간 차원 <code>(V, U)</code>를 갖는 하나의 ’기하학적 구조(geometric structure)’인 마스크라는 점이다.1</p>
<p>이러한 통찰을 공식화하기 위해, TensorMask는 인스턴스 분할 문제를 구조화된 4차원(4D) 텐서에 대한 예측 작업으로 재정의하였다.2 이는 단순히 Mask R-CNN의 대안을 제시하는 것을 넘어, 문제 자체에 대한 관점의 전환을 촉발했다. 기존 방식이 “객체가 어디에 있는가?“를 먼저 묻고 그 답을 바탕으로 “어떤 모양인가?“를 순차적으로 해결했다면, TensorMask는 이미지의 모든 위치에서 “만약 이곳을 중심으로 객체가 존재한다면, 그 객체는 어떤 모양일까?“라는 질문을 동시에 던지고 답하는 근본적인 패러다임의 변화를 시도한 것이다. 이 과정은 ’슬라이딩 윈도우’라는 아이디어를 분할에 적용하기 위해 ’마스크의 본질은 무엇인가?’라는 근본적인 질문으로 이어졌고, ’기하학적 구조’라는 답을 통해 4D 텐서라는 해결책을 도출한 논리적 귀결이다.</p>
<p>비록 TensorMask 자체는 추론 속도의 한계로 인해 산업계에서 널리 채택되지는 못했지만, ’모든 픽셀 위치에서 직접 마스크를 예측할 수 있다’는 가능성을 학술적으로 증명함으로써 중요한 ‘징검다리’ 역할을 수행했다. 이는 이후 등장한 SOLO, CenterMask와 같은 Anchor-free 및 1단계 인스턴스 분할 모델들의 이론적 토대를 마련했으며, 복잡한 후보 영역 제안 단계를 제거하고 더 빠르고 간단한 모델을 개발하도록 후속 연구에 큰 영감을 주었다.7</p>
<h2>2.  핵심 개념: 4D 텐서를 통한 마스크 표현</h2>
<h3>2.1  문제의 재정의: 3D에서 4D 텐서로</h3>
<p>과거에도 조밀한 마스크 예측을 시도한 연구들, 예컨대 DeepMask나 InstanceFCN 등이 존재했다.2 하지만 이들은 마스크를 비구조화된 3D 텐서, 즉 형태가 <code>(C,H,W)</code>인 텐서로 표현하는 한계를 가졌다.2 여기서</p>
<p><code>(H, W)</code>는 특징 맵의 공간적 위치를 나타내고, <code>C</code>는 채널 차원을 의미한다. 마스크의 2D 공간 정보 <code>(V, U)</code>를 표현하기 위해, 이들은 <code>C=V×U</code>개의 채널을 사용했다. 즉, 2차원 마스크를 1차원 벡터처럼 길게 펼쳐 채널 차원에 ’압축(packed)’한 것이다. 이러한 방식은 마스크가 본래 가지고 있는 2차원 기하학적 구조와 인접 픽셀 간의 관계 정보를 상실하게 만드는 근본적인 문제를 안고 있었다. 이는 마치 2D 이미지를 처리하기 위해 컨볼루션 신경망(ConvNet) 대신 다층 퍼셉트론(MLP)을 사용하는 것과 유사한 정보 손실을 야기한다.2</p>
<p>TensorMask는 이 문제를 해결하기 위해 마스크 표현을 위한 구조화된 4D 텐서 <code>(V,U,H,W)</code>를 제안한다.2 이 표현법에서는 텐서의 축을 두 개의 기하학적 하위 텐서(sub-tensor)로 명확히 구분한다:</p>
<ul>
<li><strong>위치 하위 텐서 <code>(H, W)</code></strong>: 이미지 내 객체의 공간적 위치(position)를 나타내는 축이다. 이는 슬라이딩 윈도우의 중심이 놓이는 조밀한 그리드에 해당한다.</li>
<li><strong>기하학 하위 텐서 <code>(V, U)</code></strong>: <code>(H, W)</code>의 각 위치를 기준으로 예측되는 마스크 자체의 2차원 기하학적 형태(geometry)를 나타내는 축이다.</li>
</ul>
<p>이처럼 마스크의 위치와 형태를 독립적인 축으로 분리함으로써, 마스크를 온전한 2D 엔티티로 다룰 수 있게 되어 구조적 정보를 보존하고, 마스크에 특화된 새로운 연산자(operator)를 설계할 수 있는 길을 열었다.</p>
<h3>2.2  이중 표현 체계: 자연 표현과 정렬 표현</h3>
<p>TensorMask는 4D 텐서를 다루기 위해 ’자연 표현(Natural Representation)’과 ’정렬 표현(Aligned Representation)’이라는 두 가지 상호 보완적인 표현 방식을 도입했다. 이 이중 표현 체계는 단순히 기술적 선택을 넘어, ’인간의 직관적 이해’와 ‘기계(CNN)의 연산 효율성’ 사이의 균형을 맞추려는 깊은 설계 철학을 반영한다.</p>
<h4>2.2.1 자연 표현 (Natural Representation)</h4>
<p>자연 표현은 사람이 결과를 직관적으로 이해하기 쉬운 형태로, 네트워크의 최종 출력단에서 사용된다. 4D 텐서 <code>Fnat</code>가 자연 표현으로 주어졌을 때, 좌표 <code>(v, u, y, x)</code>에 위치한 값은 이미지 좌표 <code>(y, x)</code>를 중심으로 하는 윈도우 내에서, 중심으로부터 <code>(αv,αu)</code>만큼 떨어진 상대적 위치에 해당하는 마스크 값을 의미한다.2 여기서 <code>α</code>는 단위 길이의 비율을 나타내는 스케일링 팩터(<code>α=σVU/σHW</code>)이다. 즉, <code>(H, W)</code> 평면의 한 점 <code>(y, x)</code>에 해당하는 <code>(V, U)</code> 하위 텐서 전체가 <code>(y, x)</code>를 중심으로 하는 하나의 완전한 마스크를 나타낸다. 이는 손실 함수를 계산하고 예측 결과를 시각화하는 데 매우 직관적이다.2</p>
<h4>2.2.2 정렬 표현 (Aligned Representation)</h4>
<p>반면, 정렬 표현은 컨볼루션 연산과 같은 기계적 처리에 최적화된 형태로, 네트워크의 중간 계층에서 주로 사용된다. 4D 텐서 <code>Faligned</code>가 정렬 표현으로 주어졌을 때, 좌표 <code>(v, u, y, x)</code>에 위치한 값은 이미지의 절대 좌표 <code>(y, x)</code>에 여러 윈도우들이 겹쳐 있을 때, 그중 <code>(y−αv,x−αu)</code>를 중심으로 하는 윈도우가 <code>(y, x)</code> 위치에 기여하는 마스크 값을 의미한다.2 다시 말해, <code>(H, W)</code> 평면의 한 점 <code>(y, x)</code>에 해당하는 <code>(V, U)</code> 하위 텐서는, <code>(y, x)</code>라는 동일한 픽셀 위치에 대한 서로 다른 마스크들의 값을 모아놓은 것이다.</p>
<p>이러한 특성 덕분에 정렬 표현은 픽셀 대 픽셀(pixel-to-pixel) 정렬이 완벽하게 보존된다. 이는 표준 컨볼루션 필터를 적용하여 공간적 특징을 효과적으로 추출하는 데 매우 유리하다. 이 개념은 RoIAlign이 제안 영역 내 특징들의 공간적 정렬을 보존하여 성능을 향상시킨 동기와 유사하다.2</p>
<h3>2.3  표현 간 변환 연산</h3>
<p>TensorMask의 유연성은 이 두 표현 사이를 자유롭게 오갈 수 있는 변환 연산의 존재 덕분이다. <code>align2nat</code>이라는 좌표 변환 연산은 정렬 표현을 자연 표현으로 변환하는 ‘번역기’ 역할을 한다.2 이 변환은 다음 수식으로 정의된다:<br />
<span class="math math-display">
F_{nat}(v, u, y, x) = F_{aligned}(v, u, y + \alpha v, x + \alpha u)
</span><br />
이 변환 연산 덕분에 네트워크 설계자는 중간 계층에서는 연산 효율성이 높은 정렬 표현을 사용하여 특징을 추출하고, 최종 출력단에서는 직관적인 자연 표현으로 변환하여 손실을 계산하는 등, 각 계층의 목적에 맞는 최적의 표현 방식을 유연하게 선택할 수 있다.</p>
<p>더 나아가, <code>up_align2nat</code>이라는 통합 연산은 정렬 표현의 <code>(V, U)</code> 차원에서 이중선형 보간(bilinear interpolation)을 수행하여 마스크의 해상도를 높인 후, 자연 표현으로 변환하는 과정을 한 번에 처리한다. 이 연산은 고해상도 마스크를 효율적으로 생성하는 데 핵심적인 역할을 하며, 뒤이어 설명할 텐서 바이피라미드 구조의 근간을 이룬다.2 이처럼 TensorMask는 단순히 새로운 표현법을 제안하는 데 그치지 않고, 그 표현들을 유기적으로 연결하고 활용하는 구체적인 연산 체계까지 함께 설계함으로써 완성도 높은 프레임워크를 구축했다.</p>
<h2>3.  TensorMask 네트워크 아키텍처 상세 분석</h2>
<h3>3.1  전체 구조: FPN 백본과 다중 예측 헤드</h3>
<p>TensorMask의 전체 아키텍처는 객체 탐지 분야에서 검증된 표준적인 구조를 기반으로 한다. 백본 네트워크로는 다중 스케일 특징을 효과적으로 추출하는 ResNet-FPN(Feature Pyramid Network)을 사용한다.2 FPN은 입력 이미지로부터 여러 해상도의 특징 맵 피라미드를 생성하며, 각 피라미드 레벨은 서로 다른 크기의 객체를 탐지하는 데 특화되어 있다.</p>
<p>FPN의 각 레벨에서 추출된 특징 맵은 세 가지 독립적인 예측 헤드(prediction head)의 입력으로 병렬적으로 전달된다.5 각 헤드는 특정 작업을 수행하며, 파라미터는 서로 다른 헤드 간에는 공유되지 않지만, 동일한 헤드 내에서는 모든 FPN 레벨에 걸쳐 공유된다.</p>
<ul>
<li><strong>인스턴스 분할 헤드 (Instance Segmentation Head):</strong> TensorMask의 핵심으로, 앞서 설명한 구조화된 4D 텐서 <code>(V,U,H,W)</code> 형태로 클래스와 무관한(class-agnostic) 마스크를 예측한다.</li>
<li><strong>객체 분류 헤드 (Object Classification Head):</strong> 각 슬라이딩 윈도우 위치에 객체가 존재하는지, 존재한다면 어떤 클래스에 속하는지를 예측한다.</li>
<li><strong>경계 상자 회귀 헤드 (Bounding Box Regression Head):</strong> 선택적으로 사용되며, 예측된 마스크를 더 잘 감싸는 정밀한 경계 상자의 좌표를 예측한다.</li>
</ul>
<h3>3.2  혁신적 구조: 텐서 바이피라미드</h3>
<p>TensorMask 아키텍처의 가장 혁신적인 부분은 ‘텐서 바이피라미드(Tensor Bipyramid)’ 구조이다.2 이는 FPN의 개념을 단순히 특징 공간(feature space)에 머무르게 하지 않고, 예측 결과물 자체의 공간인 출력 공간(output space)으로 확장한 것이다. FPN이 입력 이미지의 스케일 변화에 대응하기 위해 특징 맵의 해상도 <code>(H, W)</code>를 조절했다면, 텐서 바이피라미드는 마스크 자체의 스케일 변화에 대응하기 위해 마스크의 해상도 <code>(V, U)</code>까지 동시에 고려한다.2</p>
<p>텐서 바이피라미드는 스케일 레벨 <code>k</code>가 증가함에 따라 예측 텐서의 형태가 다음과 같이 변하는 구조로 정의된다 2:<br />
<span class="math math-display">
(2^k V, 2^k U, \frac{1}{2^k} H, \frac{1}{2^k} W)
</span><br />
이 구조의 핵심 원리는 다음과 같다. FPN의 상위 레벨(즉, <code>k</code>가 큰 값, 저해상도 특징 맵)로 갈수록 더 큰 객체를 탐지하게 된다. 텐서 바이피라미드는 이러한 상위 레벨의 특징을 입력받아, 객체 위치 예측은 더 성기게(coarsely) 하고(<code>H,W</code> 감소), 대신 마스크 예측은 더 정밀하게(finely) 한다(<code>V,U</code> 증가). 이는 “큰 객체는 윤곽을 자세히 묘사하기 위해 더 많은 픽셀, 즉 고해상도 마스크가 필요하다“는 매우 직관적인 아이디어를 네트워크 구조에 직접적으로 구현한 것이다.2</p>
<p>이러한 바이피라미드 구조를 효율적으로 구현하기 위해 <code>swap_align2nat</code>이라는 핵심 연산이 사용된다.2 이 연산은 정렬 표현으로 된 입력 특징 맵을 받아, 마스크 차원</p>
<p><code>(V, U)</code>에서는 업샘플링을 수행하고 위치 차원 <code>(H, W)</code>에서는 다운샘플링을 수행하여 바이피라미드의 다음 레벨 텐서를 생성한다. 결과적으로 텐서 바이피라미드는 FPN의 다중 스케일 철학을 계승하되, 그 적용 대상을 특징에서 최종 예측물인 마스크로 확장한, 개념적으로 한 단계 더 발전된 구조라 할 수 있다. 이는 향후 모델들이 각 작업의 출력 특성에 맞는 독자적인 피라미드 구조를 설계하는 것이 더 효과적일 수 있음을 시사하며, ‘작업에 특화된(task-specific)’ 다중 스케일 전략의 가능성을 열었다.</p>
<h2>4.  학습 및 추론 과정</h2>
<h3>4.1  통합 손실 함수 설계</h3>
<p>TensorMask의 학습은 다중 작업 학습(multi-task learning) 방식으로 이루어지며, 전체 손실 함수는 각 예측 헤드에서 계산된 개별 손실들의 가중합으로 구성된다.2<br />
<span class="math math-display">
L_{total} = w_{mask} L_{mask} + w_{cls} L_{cls} + w_{box} L_{box}
</span><br />
각 손실 함수의 구성 요소는 다음과 같다:</p>
<ul>
<li><strong>마스크 손실 (<code>Lmask</code>):</strong> 예측된 마스크의 정확도를 평가하기 위해 픽셀 단위 이진 교차 엔트로피(Binary Cross-Entropy) 손실이 사용된다. 일반적으로 마스크 내에서는 배경(background) 픽셀이 전경(foreground) 픽셀보다 훨씬 많기 때문에 발생하는 데이터 불균형 문제를 완화하기 위해, 전경 픽셀의 손실에 1.5의 가중치를 부여한다.2</li>
<li><strong>분류 손실 (<code>Lcls</code>):</strong> 쉬운 샘플(easy example)보다 어려운 샘플(hard example)에 더 집중하여 학습할 수 있도록 설계된 Focal Loss (FL*)를 채택하여 클래스 불균형 문제를 효과적으로 다룬다.2</li>
<li><strong>박스 회귀 손실 (<code>Lbox</code>):</strong> 예측된 경계 상자와 실제 경계 상자 간의 차이를 측정하기 위해 표준적인 L1 손실을 사용한다.2</li>
</ul>
<h3>4.2  독자적인 레이블 할당 전략</h3>
<p>학습 과정에서 어떤 슬라이딩 윈도우를 긍정(positive) 샘플로, 어떤 것을 부정(negative) 샘플로 지정할지 결정하는 레이블 할당(label assignment)은 모델 성능에 매우 중요하다. 기존의 객체 탐지기들은 대부분 예측 상자와 실제 상자 간의 IoU(Intersection over Union) 값을 기준으로 레이블을 할당한다. 그러나 TensorMask는 ’마스크 중심(mask-driven)’의 독자적인 할당 전략을 채택한다.2</p>
<p>이 전략은 TensorMask가 ’상자(box)’가 아닌 ’마스크(mask)’를 객체의 기본 단위로 간주하는 핵심 철학을 학습 과정에까지 일관되게 반영한 결과이다. 만약 IoU 기반 할당을 사용했다면, 실제 마스크의 복잡한 형태 정보를 버리고 이를 감싸는 부정확한 사각형을 기준으로 학습해야 했을 것이다. 대신, TensorMask는 마스크의 실제 형태를 직접적으로 고려하여 다음과 같은 세 가지 조건을 모두 만족하는 윈도우를 긍정 샘플로 정의한다 2:</p>
<ol>
<li><strong>포함(Containment):</strong> 윈도우가 Ground-Truth 마스크를 완전히 포함해야 한다.</li>
<li><strong>중심성(Centrality):</strong> Ground-Truth 마스크의 중심이 윈도우의 중심 근처에 위치해야 한다.</li>
<li><strong>고유성(Uniqueness):</strong> 위의 두 조건을 만족하는 다른 Ground-Truth 마스크가 해당 윈도우에 없어야 한다.</li>
</ol>
<p>이러한 마스크 중심 할당 전략은 객체를 사각형으로 근사할 때 발생하는 정보 손실을 줄여주며, 특히 비정형적인 형태를 가진 객체에 대해 더 적절한 윈도우를 학습 샘플로 선택할 수 있는 잠재력을 가진다. 또한, 이 전략은 적은 수의 앵커(윈도우 크기)만으로도 효과적으로 작동하는 장점이 있다.2</p>
<h3>4.3  추론 단계</h3>
<p>추론 시, 네트워크는 FPN의 모든 레벨과 모든 슬라이딩 윈도우 위치에 대해 마스크, 클래스 점수, 경계 상자를 조밀하게 예측한다. 이렇게 생성된 수많은 예측 결과들 중에서 중복을 제거하고 최종 결과를 선택하기 위해 비최대 억제(Non-Maximum Suppression, NMS) 기법이 예측된 경계 상자에 적용된다.2 NMS를 통과한 예측들에 해당하는 소프트 마스크(soft mask)는 최종적으로 특정 임계값을 기준으로 이진화(binarize)되어 최종 분할 맵을 생성한다.</p>
<h2>5.  실험 결과 및 성능 분석</h2>
<h3>5.1  정량적 성능 비교</h3>
<p>TensorMask가 제안한 조밀한 분할 프레임워크의 실질적인 경쟁력을 입증하기 위해, COCO(Common Objects in Context) 데이터셋에서 당시 최고 성능 모델인 Mask R-CNN과 성능을 비교했다. 아래 표는 COCO <code>test-dev</code> 데이터셋에서의 인스턴스 분할 AP(Average Precision) 결과를 요약한 것이다.2</p>
<table><thead><tr><th>method</th><th>backbone</th><th>aug</th><th>epochs</th><th>AP</th><th><code>$AP_{50}$</code></th><th><code>$AP_{75}$</code></th><th><code>$AP_{S}$</code></th><th><code>$AP_{M}$</code></th><th><code>$AP_{L}$</code></th></tr></thead><tbody>
<tr><td>Mask R-CNN</td><td>R-50-FPN</td><td></td><td>24</td><td>34.9</td><td>57.2</td><td>36.9</td><td>15.4</td><td>36.6</td><td>50.8</td></tr>
<tr><td>Mask R-CNN, ours</td><td>R-50-FPN</td><td>X</td><td>72</td><td>36.8</td><td>59.2</td><td>39.3</td><td>17.1</td><td>38.7</td><td>52.1</td></tr>
<tr><td><strong>TensorMask</strong></td><td><strong>R-50-FPN</strong></td><td><strong>X</strong></td><td><strong>72</strong></td><td><strong>35.4</strong></td><td><strong>57.2</strong></td><td><strong>37.3</strong></td><td><strong>16.3</strong></td><td><strong>36.8</strong></td><td><strong>49.3</strong></td></tr>
<tr><td>Mask R-CNN, ours</td><td>R-101-FPN</td><td>X</td><td>72</td><td>38.3</td><td>61.2</td><td>40.8</td><td>18.2</td><td>40.6</td><td>54.1</td></tr>
<tr><td><strong>TensorMask</strong></td><td><strong>R-101-FPN</strong></td><td><strong>X</strong></td><td><strong>72</strong></td><td><strong>37.1</strong></td><td><strong>59.3</strong></td><td><strong>39.4</strong></td><td><strong>17.4</strong></td><td><strong>39.1</strong></td><td><strong>51.6</strong></td></tr>
</tbody></table>
<p><em><code>aug</code> 열의 ’X’는 훈련 시 스케일 증강(scale augmentation) 사용을 의미한다.</em></p>
<p>분석 결과, TensorMask는 잘 최적화된 Mask R-CNN 구현체와 비교하여 매우 근접한(comparable) 성능을 달성했다.6 더 강력한 ResNet-101-FPN 백본을 사용했을 때, TensorMask의 AP는 37.1로 Mask R-CNN과의 성능 격차는 불과 1.2 AP 포인트에 불과했다. 이 결과는 TensorMask가 단순한 학술적 제안을 넘어, 실제 벤치마크에서 최고 수준의 모델과 경쟁할 수 있는 실질적인 성능을 갖춘 프레임워크임을 증명하는 핵심적인 증거이다.2 이는 조밀한 분할 패러다임의 가능성을 성공적으로 입증한 것이다.</p>
<h3>5.2  Ablation Study: 핵심 구성 요소의 효과 검증</h3>
<p>TensorMask의 성능이 어떤 구성 요소로부터 기인하는지 명확히 파악하기 위해 상세한 분석 연구(ablation study)가 수행되었다. 특히, 핵심 구조적 혁신인 텐서 바이피라미드의 효과를 검증한 결과는 다음과 같다.2</p>
<table><thead><tr><th>head</th><th>AP</th><th><code>$AP_{50}$</code></th><th><code>$AP_{75}$</code></th><th><code>$AP_{S}$</code></th><th><code>$AP_{M}$</code></th><th><code>$AP_{L}$</code></th></tr></thead><tbody>
<tr><td>feature pyramid, best</td><td>28.9</td><td>52.5</td><td>29.3</td><td>14.6</td><td>30.8</td><td>40.7</td></tr>
<tr><td><strong>tensor bipyramid</strong></td><td><strong>34.0</strong></td><td><strong>55.2</strong></td><td><strong>35.8</strong></td><td><strong>15.3</strong></td><td><strong>36.3</strong></td><td><strong>48.4</strong></td></tr>
<tr><td><code>$\Delta$</code></td><td>+5.1</td><td>+2.7</td><td>+6.5</td><td>+0.7</td><td>+5.5</td><td>+7.7</td></tr>
</tbody></table>
<p>표준 FPN 헤드를 사용한 베이스라인 모델과 비교했을 때, 텐서 바이피라미드를 도입하자 전체 AP가 5.1 포인트나 크게 향상되었다. 특히 주목할 점은 대형 객체에 대한 성능 지표인 AP<span class="math math-inline">_{L}</span>이 7.7 포인트나 급증했다는 것이다. 이는 텐서 바이피라미드가 큰 객체에 대해 고해상도 마스크를 할당하도록 한 설계 의도가 실제 성능 향상으로 정확히 이어졌음을 명확히 보여준다.2</p>
<p>이 외에도 헤드 아키텍처와 표현 방식에 대한 분석을 통해, 중간 계층에서 픽셀 정렬을 유지하는 ’정렬 표현’을 사용하는 것이 ’자연 표현’을 사용하는 것보다 AP를 최대 9.2 포인트까지 향상시킨다는 사실이 밝혀졌다.2 이는 TensorMask의 높은 성능이 단일 아이디어가 아닌, 4D 텐서, 정렬 표현, 텐서 바이피라미드 등 여러 핵심 개념들이 유기적으로 결합되었을 때 비로소 발현됨을 보여준다.</p>
<h3>5.3  정성적 분석 및 추론 속도</h3>
<p>정성적 평가에서 TensorMask는 작고 큰 객체는 물론, 특히 객체들이 서로 겹쳐 있는(overlapping) 복잡한 상황에서 뛰어난 분할 품질을 보여주었다.2 각 위치에서 독립적으로 마스크를 예측하는 조밀한 접근 방식 덕분에, 한 객체의 예측이 다른 객체에 의해 방해받는 현상이 적기 때문이다. 이는 NMS 과정에서 IoU가 높은 상자 중 하나가 제거되면 해당 객체의 마스크 예측 기회 자체가 사라질 수 있는 Mask R-CNN과 차별화되는 지점이다.</p>
<p>그러나 이러한 장점은 명백한 단점을 동반했다. 바로 추론 속도이다. ResNet-101-FPN 백본 기준, TensorMask는 V100 GPU에서 이미지 당 0.38초가 소요된 반면, Mask R-CNN은 0.09초에 불과했다.2 이는 이미지 내 수많은 위치(&gt;100k) 각각에 대해 마스크를 조밀하게 예측하는 데 따르는 막대한 계산 비용 때문이다. 반면 Mask R-CNN은 소수의 후보 영역(≤100개)에 대해서만 마스크를 계산하므로 훨씬 효율적이다. 결국, TensorMask의 핵심 철학인 ’조밀함(density)’은 겹친 객체 처리와 같은 성능의 원천인 동시에, 속도 저하의 근본적인 원인이 되는 양날의 검이었던 것이다.</p>
<h2>6.  종합 평가 및 의의</h2>
<h3>6.1  TensorMask의 장점과 단점 요약</h3>
<p>TensorMask는 인스턴스 분할 분야에 새로운 방향을 제시한 기념비적인 연구로, 그 장점과 단점은 명확하다.</p>
<p><strong>장점:</strong></p>
<ul>
<li><strong>개념적 혁신:</strong> Mask R-CNN이 지배하던 분야에 ’조밀한 인스턴스 분할’이라는 대안적이고 근본적인 연구 방향을 성공적으로 개척했다.2</li>
<li><strong>우수한 마스크 품질:</strong> 구조화된 4D 텐서 표현과 텐서 바이피라미드 구조를 통해 겹치거나 다양한 크기의 객체에 대해 시각적으로 우수한 고품질 마스크를 생성할 수 있다.2</li>
<li><strong>단순한 구조:</strong> 원칙적으로 RoI Pooling/Align과 같은 복잡한 연산 없이, 완전 컨볼루션 신경망(FCN) 형태의 단일 네트워크로 설계가 가능하다는 점에서 구조적 단순성을 가진다.5</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li><strong>느린 추론 속도:</strong> 조밀한 예측으로 인한 높은 계산 비용이 상용화를 가로막는 가장 큰 실질적인 한계점이다.2</li>
<li><strong>구현 복잡성:</strong> 개념은 단순할 수 있으나, 정렬/자연 표현 간의 변환, <code>swap_align2nat</code> 등 맞춤형 연산자의 구현이 필요하여 기존 프레임워크에 쉽게 통합하기 어렵다.9</li>
</ul>
<h3>6.2  컴퓨터 비전 분야에 미친 영향</h3>
<p>TensorMask의 진정한 가치는 그 자체의 상업적 성공보다는, 후속 연구에 미친 지대한 영향력에 있다. 이 연구는 중요한 ’학술적 촉매제’로서, 인스턴스 분할 연구의 새로운 장을 열었다.</p>
<p>TensorMask가 ’모든 위치에서 직접 마스크를 예측할 수 있다’는 가능성을 증명하자, 많은 후속 연구들이 이 아이디어를 계승하여 TensorMask의 가장 큰 약점이었던 속도 문제를 해결하는 방향으로 발전했다. SOLO, CondInst, 그리고 CenterMask2와 같은 대표적인 Anchor-free, 1단계 인스턴스 분할 모델들이 그 결과물이다.7 특히 CenterMask2는 TensorMask보다 훨씬 빠르면서도 더 높은 성능을 달성함으로써, TensorMask가 제시한 방향성이 올바르되 효율성 개선의 여지가 많았음을 입증했다.8</p>
<h3>6.3  결론 및 미래 연구를 위한 제언</h3>
<p>결론적으로, TensorMask는 ’탐지 후 분할’이라는 단일 패러다임에 머물러 있던 인스턴스 분할 분야에 ’조밀한 예측’이라는 근본적으로 다른 접근법을 성공적으로 제시하고, 그 잠재력과 명백한 한계를 모두 보여준 중요한 연구이다.2 이는 문제 해결을 위한 새로운 관점과 풍부한 연구 주제를 제공하며 해당 분야의 지평을 넓혔다.</p>
<p>TensorMask가 남긴 과제는 여전히 유효하며, 미래 연구를 위한 제언으로 이어질 수 있다. 첫째, 조밀한 예측의 효율성을 높이기 위한 연구가 필요하다. 예측이 불필요한 배경 영역을 동적으로 건너뛰는 희소 컨볼루션(sparse convolution)의 적용이나 예측 위치를 동적으로 선택하는 방법을 통해 계산량을 줄일 수 있을 것이다. 둘째, TensorMask의 구조화된 텐서 표현을 파노라마 분할(panoptic segmentation)이나 비디오 객체 분할(video object segmentation)과 같은 다른 조밀한 예측 과제에 확장하여 적용하는 연구 또한 유망한 방향이 될 것이다. TensorMask는 하나의 완성된 해결책이라기보다, 무한한 가능성을 품은 새로운 탐구의 시작점으로서 그 의의를 가진다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>TensorMask: A Foundation for Dense Object Segmentation | Facebook AI Research, https://ai.meta.com/research/publications/tensormask-a-foundation-for-dense-object-segmentation/</li>
<li>TensorMask: A Foundation for Dense Object … - CVF Open Access, https://openaccess.thecvf.com/content_ICCV_2019/papers/Chen_TensorMask_A_Foundation_for_Dense_Object_Segmentation_ICCV_2019_paper.pdf</li>
<li>[1903.12174] TensorMask: A Foundation for Dense Object Segmentation - arXiv, https://arxiv.org/abs/1903.12174</li>
<li>TensorMask: A Foundation for Dense Object Segmentation - Meta Research - Facebook, https://research.facebook.com/publications/tensormask-a-foundation-for-dense-object-segmentation/</li>
<li>TensorMask: A Foundation for Dense Object Segmentation, https://www.csc.kth.se/cvap/cvg/rg/materials/yonk_001_slides.pdf</li>
<li>TensorMask a Foundation for Dense Object Segmentation - Scribd, https://www.scribd.com/document/876560262/TensorMask-a-Foundation-for-Dense-Object-Segmentation</li>
<li>TensorMask: A Foundation for Dense Object Segmentation - Semantic Scholar, https://www.semanticscholar.org/paper/TensorMask%3A-A-Foundation-for-Dense-Object-Chen-Girshick/ffae2a8c24bf4bbeb92eaefe77cae1e1ce239698</li>
<li>youngwanLEE/centermask2: [CVPR 2020] CenterMask : Real-time Anchor-Free Instance Segmentation - GitHub, https://github.com/youngwanLEE/centermask2</li>
<li>projects/TensorMask · v0.1 · 8cherwai / Detectrontest - Git, https://git.informatik.uni-hamburg.de/8cherwai/Detectrontest/-/tree/v0.1/projects/TensorMask</li>
<li>Instance Segmentation, TensorMask - GitHub, https://github.com/CaoWGG/TensorMask</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>