<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.1 GPT 시리즈의 진화 - Zero-shot, One-shot, Few-shot</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.1 GPT 시리즈의 진화 - Zero-shot, One-shot, Few-shot</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>4.1 GPT 시리즈의 진화 - Zero-shot, One-shot, Few-shot</span></nav>
                </div>
            </header>
            <article>
                <h1>4.1 GPT 시리즈의 진화 - Zero-shot, One-shot, Few-shot</h1>
<p>2025-12-19, G30DR</p>
<p>인공지능 연구의 역사, 특히 자연어 처리(Natural Language Processing, NLP)의 궤적을 추적할 때, ’특이점(Singularity)’이라 부를 만한 결정적 순간은 모델이 단순히 학습된 데이터를 재생산하는 것을 넘어, 학습하지 않은 과제를 문맥(Context)만으로 해결하기 시작한 시점과 일치한다. 2017년 구글의 트랜스포머(Transformer) 아키텍처 발표 이후, OpenAI는 이 구조를 활용하여 생성적 사전 학습(Generative Pre-training)이라는 새로운 패러다임을 제시했고, 이는 GPT-1, GPT-2, GPT-3로 이어지는 일련의 시리즈를 통해 ’범용 인공지능(AGI)’을 향한 거대한 도약을 이루어냈다.</p>
<p>본 장에서는 GPT 시리즈가 어떻게 지도 학습(Supervised Learning)의 한계를 극복하고, 별도의 파라미터 업데이트 없이 과제를 수행하는 인컨텍스트 러닝(In-Context Learning, ICL) 능력을 획득하게 되었는지 그 진화 과정을 심층적으로 분석한다. 우리는 Zero-shot, One-shot, Few-shot으로 대변되는 이 학습 방법론이 단순한 프롬프트의 차이를 넘어, 기계가 언어를 이해하고 세상을 모델링하는 방식의 근본적인 변화임을 논증할 것이다. 또한, 이러한 능력이 발현되게 만든 기저의 메커니즘—스케일링 법칙(Scaling Laws), 유도 헤드(Induction Heads), 암시적 경사 하강법(Implicit Gradient Descent)—을 해부함으로써 트랜스포머 싱귤래리티의 기술적 실체를 규명하고자 한다.</p>
<h2>1.  지도 학습의 병목과 GPT-1의 탄생: 패러다임의 전환</h2>
<p>2018년 이전, 자연어 처리 분야의 주류 패러다임은 순환 신경망(RNN)이나 LSTM(Long Short-Term Memory)을 기반으로 한 지도 학습이었다. 이 시기의 모델들은 특정 작업(Task)—예를 들어 감성 분석, 번역, 질의응답—을 수행하기 위해 해당 작업에 특화된 고품질의 라벨링 데이터(Labeled Data)를 대량으로 필요로 했다. 그러나 인간이 일일이 주석을 달아야 하는 라벨링 데이터는 구축 비용이 매우 높고, 언어의 무한한 가변성을 모두 담아내기에 희소하다는 치명적인 한계를 가지고 있었다.1</p>
<pre><code class="language-mermaid">graph TD
    subgraph Phase1 ["Phase 1: Unsupervised Pre-training"]
        A["Large Unlabeled Corpus&lt;br&gt;(e.g., BookCorpus)"] --&gt; B("Language Modeling Objective")
        B --&gt; C["Pre-trained Parameters&lt;br&gt;(General Knowledge)"]
    end

    subgraph Phase2 ["Phase 2: Supervised Fine-tuning"]
        D["Small Labeled Data&lt;br&gt;(Specific Task)"] --&gt; E("Add Linear Output Layer")
        C --&gt; E
        E --&gt; F("Gradient Descent Update")
        F --&gt; G["Task-Specific Model"]
    end

    style Phase1 fill:#f9f9f9,stroke:#333,stroke-width:2px
    style Phase2 fill:#e6f3ff,stroke:#333,stroke-width:2px
</code></pre>
<h3>1.1 생성적 사전 학습(Generative Pre-training)의 제안</h3>
<p>OpenAI는 2018년 6월, “Improving Language Understanding by Generative Pre-Training“이라는 논문을 통해 GPT-1을 세상에 내놓으며 이러한 병목 현상을 타개할 새로운 접근법을 제시했다.1 GPT-1의 핵심 아이디어는 ’반지도 학습(Semi-supervised Learning)’으로, 이를 두 단계의 프로세스로 정립했다.</p>
<ol>
<li><strong>비지도 사전 학습(Unsupervised Pre-training):</strong> 레이블이 없는 대규모 텍스트 코퍼스(BookCorpus 등)를 사용하여 언어 모델링(Language Modeling) 목표를 학습한다. 이는 모델이 다음 단어를 예측하는 과정에서 문법, 문장 구조, 그리고 일정 수준의 의미론적 지식을 파라미터에 내재화하도록 유도한다.</li>
<li><strong>지도 미세 조정(Supervised Fine-tuning):</strong> 사전 학습된 모델에 작업 특화 레이어(Linear Output Layer)를 추가하고, 소량의 라벨링 데이터를 사용하여 특정 작업에 맞게 파라미터를 미세 조정한다.1</li>
</ol>
<p>이 접근법은 기존의 ‘밑바닥부터 학습(Training from scratch)’ 방식이 가졌던 데이터 부족 문제를 획기적으로 해결했다. 사전 학습 단계에서 모델은 텍스트의 장기 의존성(Long-range Dependencies)을 처리하는 능력을 배양하며, 이는 지도 학습 단계에서 일종의 정칙화(Regularization) 효과를 제공하여 일반화 성능을 극대화했다.2</p>
<h3>1.2 트랜스포머 디코더 아키텍처의 채택</h3>
<p>GPT-1은 구글의 트랜스포머 아키텍처 중 디코더(Decoder) 블록만을 12개 쌓아 올린 구조를 채택했다.3 인코더-디코더 구조를 모두 사용하는 원본 트랜스포머나 BERT와 달리, GPT-1은 오직 이전 토큰들만을 보고 다음 토큰을 예측하는 자기 회귀(Auto-regressive) 속성을 강조했다. 이는 생성(Generation)에 최적화된 구조였으며, 향후 GPT 시리즈가 ’문장 생성’을 통해 모든 문제를 해결하는 범용성을 갖게 되는 구조적 기반이 되었다.</p>
<p>GPT-1은 자연어 추론(NLI), 질의응답(QA), 의미 유사도 판별 등 12개의 과제 중 9개에서 당시 최고 성능(SOTA)을 경신했다.3 그러나 GPT-1 단계에서 ’범용성’은 여전히 제한적이었다. 새로운 작업을 수행하기 위해서는 반드시 모델의 최상단 구조를 변경해야 했고, 해당 작업에 맞는 데이터로 경사 하강법(Gradient Descent)을 수행하여 가중치를 업데이트해야만 했다. 즉, GPT-1은 ’잘 훈련된 학생’이었지만, 새로운 문제를 풀기 위해서는 여전히 ’교사의 정답 지도’가 필수적인 단계였다.</p>
<h2>2.  GPT-2: Zero-shot과 <span class="math math-inline">P(output | input, task)</span>의 재정의</h2>
<p>2019년 발표된 GPT-2는 “Language Models are Unsupervised Multitask Learners“라는 논문을 통해, 별도의 지도 학습 없이도 언어 모델이 다양한 작업을 수행할 수 있다는 대담한 가설을 증명했다.5 GPT-2는 파라미터 수를 15억 개(1.5B)로 GPT-1 대비 10배 이상 확장했으며, 데이터셋의 규모와 품질을 비약적으로 높였다. 하지만 가장 중요한 변화는 모델을 바라보는 관점, 즉 확률적 프레임워크의 변화였다.</p>
<pre><code class="language-mermaid">graph TD
    User["User Intent: Translate English to Korean"] --&gt; Strategy
    
    subgraph Strategies ["In-Context Learning Strategies"]
        Strategy --&gt; Zero["Zero-shot"]
        Strategy --&gt; One["One-shot"]
        Strategy --&gt; Few["Few-shot"]
        
        Zero --&gt; Z_Context["Prompt:&lt;br&gt;'Translate: cheese =&gt;'"]
        One --&gt; O_Context["Prompt:&lt;br&gt;'sea otter =&gt; 해달&lt;br&gt;cheese =&gt;'"]
        Few --&gt; F_Context["Prompt:&lt;br&gt;'sea otter =&gt; 해달&lt;br&gt;peppermint =&gt; 박하&lt;br&gt;... (10~100 examples) ...&lt;br&gt;cheese =&gt;'"]
    end

    Z_Context --&gt; Model["Frozen GPT Model"]
    O_Context --&gt; Model
    F_Context --&gt; Model

    Model --&gt; Output["Output Generation&lt;br&gt;(Probability Distribution)"]
    
    Output -- Zero-shot Result --&gt; R1["'치즈' (Low Confidence)"]
    Output -- One-shot Result --&gt; R2["'치즈' (Better Format)"]
    Output -- Few-shot Result --&gt; R3["'치즈' (High Accuracy &amp; Adaptation)"]
</code></pre>
<h3>2.1 작업 조건부 확률 분포의 모델링</h3>
<p>기존의 기계 학습 모델은 특정 작업 하나에 대해 입력(<span class="math math-inline">input</span>)이 주어졌을 때 출력(<span class="math math-inline">output</span>)이 나올 확률인 <span class="math math-inline">P(output | input)</span>을 추정하는 데 집중했다. 그러나 Radford 등은 단일 모델이 여러 작업을 동시에 수행하기 위해서는 작업(<span class="math math-inline">task</span>) 자체도 입력의 일부로 조건화되어야 한다고 보았다. 즉, 모델은 <span class="math math-inline">P(output | input, task)</span>를 모델링해야 한다는 것이다.5</p>
<p>GPT-2는 언어 모델이 충분히 방대한 데이터와 파라미터 용량(Capacity)을 확보한다면, 텍스트 내에 자연스럽게 존재하는 언어적 패턴(Natural Language Demonstrations)을 통해 작업의 의도를 파악할 수 있다고 가정했다. 예를 들어, 텍스트 코퍼스 내에 “영어 문장: 프랑스어 번역문“과 같은 패턴이 존재한다면, 모델은 이를 학습함으로써 명시적인 번역 훈련 없이도 번역 능력을 습득할 수 있다는 것이다.5</p>
<h3>2.2 Zero-shot 전이(Transfer)의 구현</h3>
<p>이러한 가설을 바탕으로 GPT-2는 <strong>Zero-shot</strong> 설정을 주력으로 내세웠다. Zero-shot이란 모델에게 그 어떤 예시(Example)도 제공하지 않고, 오직 작업에 대한 지시(Instruction)나 질문만을 던져 결과를 얻어내는 방식이다. GPT-1과 달리 파라미터 업데이트나 아키텍처 수정(Fine-tuning)이 전혀 허용되지 않는다.5</p>
<ul>
<li><strong>메커니즘:</strong> “이 텍스트를 요약해 줘“라고 명령하거나, 단순히 본문 뒤에 “TL;DR (Too Long; Didn’t Read)“이라는 토큰을 붙이는 것만으로 모델이 요약 작업을 수행하도록 유도한다. 번역의 경우 <code>English sentence = French sentence</code>와 같은 프롬프트를 사용하여 다음 토큰 생성을 유도한다.</li>
<li><strong>성과와 한계:</strong> GPT-2는 LAMBADA(장기 의존성 예측) 데이터셋에서 퍼플렉서티(Perplexity)를 99.8에서 8.6으로 극적으로 낮추었고, CoQA(질의응답)에서는 훈련 데이터 없이도 베이스라인 시스템들과 경쟁 가능한 성능(55 F1)을 기록했다.5 그러나 요약이나 번역 같은 복잡한 생성 작업에서는 여전히 전문적인 지도 학습 모델에 비해 성능이 떨어졌으며, 텍스트가 길어질수록 일관성을 잃거나 환각(Hallucination)을 일으키는 한계를 보였다.</li>
</ul>
<h3>2.3 데이터의 질적 혁명: WebText</h3>
<p>GPT-2의 Zero-shot 성능은 단순히 모델 크기뿐만 아니라, <strong>WebText</strong>라는 고품질 데이터셋의 구축에 기인한다. OpenAI는 기존의 Common Crawl 데이터가 노이즈가 심하고 품질이 낮아 언어 모델의 학습 효율을 저해한다고 판단했다. 이에 대한 대안으로, 인간의 필터링이 개입된 데이터를 수집하는 전략을 택했다.8</p>
<table><thead><tr><th><strong>데이터셋</strong></th><th><strong>GPT-2 (WebText)</strong></th><th><strong>GPT-3 (Filtered Common Crawl)</strong></th></tr></thead><tbody>
<tr><td><strong>수집 원칙</strong></td><td>인간의 큐레이션 개입</td><td>자동화된 품질 분류기 및 퍼지 중복 제거</td></tr>
<tr><td><strong>필터링 기준</strong></td><td>Reddit에서 3 Karma 이상 받은 외부 링크</td><td>WebText와 유사한 고품질 문서 선별</td></tr>
<tr><td><strong>데이터 크기</strong></td><td>약 40GB (800만 문서)</td><td>570GB (정제 후)</td></tr>
<tr><td><strong>특징</strong></td><td>다양하고 높은 문맥적 품질</td><td>압도적인 규모와 통계적 대표성</td></tr>
</tbody></table>
<p>WebText는 Reddit이라는 커뮤니티에서 최소 3명 이상의 인간이 ’추천’을 누른 링크만을 크롤링함으로써, 스팸이나 무의미한 텍스트를 배제하고 정보 가치가 높은 텍스트만을 확보했다.8 이는 모델이 다양한 도메인(뉴스, 블로그, 기술 문서 등)의 지식을 흡수하고, 보다 정교한 언어 구사력을 갖추게 하는 결정적인 토대가 되었다.</p>
<h2>3.  GPT-3: 스케일링과 인컨텍스트 러닝(Few-shot)의 완성</h2>
<p>2020년, OpenAI는 “Language Models are Few-Shot Learners“라는 기념비적인 논문을 통해 GPT-3를 발표했다.9 1,750억(175B) 개라는, 전례 없는 규모의 파라미터를 가진 GPT-3는 단순히 GPT-2를 크게 만든 것이 아니었다. 그것은 양적 변화가 질적 변화(Qualitative Change)를 일으키는 ’창발(Emergence)’의 증거였으며, **인컨텍스트 러닝(In-Context Learning)**이라는 새로운 학습 패러다임을 확립했다.</p>
<h3>3.1 Zero-shot, One-shot, Few-shot의 체계화</h3>
<p>GPT-3 논문은 추론(Inference) 시 모델에게 제공되는 문맥 정보의 양(Number of demonstrations)에 따라 학습 방식을 세 가지로 명확히 구분하고, 각 방식의 성능을 체계적으로 분석했다.9 이 구분은 모델의 가중치를 업데이트하지 않는다는 공통점을 가지며, 오직 프롬프트(Prompt) 디자인의 차이일 뿐이다.</p>
<ol>
<li><strong>Zero-shot (제로 샷):</strong></li>
</ol>
<ul>
<li><strong>정의:</strong> 작업에 대한 자연어 설명(Task Description)만을 제공한다. 예시는 없다.</li>
<li><strong>프롬프트:</strong> <code>영어를 한국어로 번역하라: cheese =&gt;</code></li>
<li><strong>특징:</strong> 모델이 사전 학습된 지식에 전적으로 의존해야 하므로 가장 난이도가 높다. 인간의 자연스러운 대화 방식에 가깝지만, 작업의 형식이 모호할 경우 모델이 의도를 파악하지 못할 수 있다.9</li>
</ul>
<ol start="2">
<li><strong>One-shot (원 샷):</strong></li>
</ol>
<ul>
<li>
<p><strong>정의:</strong> 작업 설명과 함께 단 하나의 예시(Demonstration)를 제공한다.</p>
</li>
<li>
<p>프롬프트:</p>
</li>
</ul>
<p>영어를 한국어로 번역하라.</p>
<p>sea otter =&gt; 해달</p>
<p>cheese =&gt;</p>
<ul>
<li><strong>특징:</strong> 단 하나의 예시가 제공됨으로써 모델은 출력의 형식(Format)과 작업의 성격을 훨씬 더 명확하게 인지한다. 이는 인간이 새로운 작업을 배울 때 “예를 들어, 이렇게 하는 거야“라고 한 번 보여주는 것과 유사한 효과를 낸다.9</li>
</ul>
<ol start="3">
<li><strong>Few-shot (퓨 샷):</strong></li>
</ol>
<ul>
<li>
<p><strong>정의:</strong> 작업 설명과 함께 모델의 컨텍스트 윈도우(Context Window)가 허용하는 한도 내에서 여러 개(보통 10~100개)의 예시를 제공한다.</p>
</li>
<li>
<p>프롬프트:</p>
</li>
</ul>
<p>영어를 한국어로 번역하라.</p>
<p>sea otter =&gt; 해달</p>
<p>peppermint =&gt; 박하</p>
<p>plush girafe =&gt; 기린 인형</p>
<p>… (다수 예시)…</p>
<p>cheese =&gt;</p>
<ul>
<li><strong>특징:</strong> GPT-3가 가장 강력한 위력을 발휘하는 설정이다. 예시의 수가 늘어날수록 성능은 로그 선형적(Log-linear)으로 향상되며, 충분한 예시가 주어졌을 때는 미세 조정(Fine-tuning)된 전문 모델의 성능을 능가하기도 한다.9 이는 모델이 문맥 내의 패턴을 실시간으로 학습하고 적응하는 능력이 탁월함을 보여준다.</li>
</ul>
<p>아래 표는 GPT-3 논문에서 제시된 각 설정별 특징과 미세 조정과의 비교를 요약한 것이다.</p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>Zero-shot</strong></th><th><strong>One-shot</strong></th><th><strong>Few-shot</strong></th><th><strong>Fine-tuning (전통적 방식)</strong></th></tr></thead><tbody>
<tr><td><strong>예시 제공</strong></td><td>없음 (설명만 제공)</td><td>1개</td><td>10~100개 (다수)</td><td>수천~수십만 개 (데이터셋)</td></tr>
<tr><td><strong>가중치 업데이트</strong></td><td>없음</td><td>없음</td><td>없음</td><td><strong>있음 (Gradient Update)</strong></td></tr>
<tr><td><strong>추론 시 연산</strong></td><td>프롬프트 처리</td><td>프롬프트 + 예시 1개 처리</td><td>프롬프트 + 다수 예시 처리</td><td>입력만 처리 (모델이 이미 변경됨)</td></tr>
<tr><td><strong>장점</strong></td><td>최대의 범용성, 편리함</td><td>포맷 지시 용이</td><td>높은 정확도, 유연성</td><td>특정 작업 최고 성능(SOTA)</td></tr>
<tr><td><strong>단점</strong></td><td>작업 이해도 낮을 수 있음</td><td>데이터 부족할 수 있음</td><td>긴 컨텍스트 비용 발생</td><td>과적합 위험, 재학습 비용</td></tr>
</tbody></table>
<h3>3.2 메타 학습(Meta-Learning) 가설: Learning to Learn</h3>
<p>GPT-3의 저자들은 이러한 인컨텍스트 러닝 능력을 <strong>메타 학습</strong>의 관점에서 설명했다.9 모델은 두 가지 루프(Loop)를 통해 학습한다.</p>
<ul>
<li><strong>외부 루프(Outer Loop):</strong> 사전 학습(Pre-training) 단계. 수천억 개의 토큰을 처리하며 경사 하강법을 통해 모델의 파라미터를 최적화한다. 이 과정은 느리며, 언어의 일반적인 통계적 구조와 광범위한 세계 지식을 학습한다.</li>
<li><strong>내부 루프(Inner Loop):</strong> 인컨텍스트 러닝(ICL) 단계. 추론 시점에 프롬프트 내에 주어진 예시들을 처리하며 발생하는 ’일시적 학습’이다. 모델은 고정된 가중치를 가지고 있지만, 어텐션 메커니즘을 통해 입력 시퀀스 내의 패턴을 파악하고 이에 맞춰 다음 토큰의 예측 확률을 조정한다. 이는 마치 모델이 “학습하는 법을 학습(Learning to learn)“한 것과 같으며, 새로운 과제에 빠르게 적응하는 유동 지능(Fluid Intelligence)을 보여준다.9</li>
</ul>
<h2>4.  인컨텍스트 러닝(ICL)의 작동 메커니즘 심층 분석</h2>
<p>GPT-3가 보여준 Few-shot 능력은 마치 마법처럼 보이지만, 최근의 연구들은 이를 수학적, 기계적으로 설명 가능한 현상으로 규명하고 있다. 이는 단순한 ’기억’이나 ’유사도 매칭’을 넘어선 복잡한 최적화 과정의 발현이다.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Context as "Context History"
    participant Current as "Current Token [A]"
    participant Head as "Induction Head"
    participant Next as "Next Token Prediction"

    Note over Context, Next: "Pattern in Context: ... [A] followed by [B] ..."
    
    Current-&gt;&gt;Head: "Input Token [A] arrives"
    Head-&gt;&gt;Context: "Prefix Matching: Search for previous [A]"
    Context--&gt;&gt;Head: "Found [A] at position i"
    Head-&gt;&gt;Context: "Copying: Look at token at position i+1"
    Context--&gt;&gt;Head: "Token at i+1 is [B]"
    
    Head-&gt;&gt;Next: "Increase probability of [B]"
    Next--&gt;&gt;Current: "Output generated: [B]"
</code></pre>
<h3>4.1 메커니즘 1: 암시적 경사 하강법 (Implicit Gradient Descent)</h3>
<p>가장 흥미로운 이론적 발견 중 하나는 트랜스포머의 인컨텍스트 러닝이 수학적으로 <strong>암시적 경사 하강법</strong>과 등가(Equivalent)라는 것이다.13</p>
<p>Von Oswald 등(2023)과 Dai 등(2022)의 연구에 따르면, 트랜스포머의 선형 어텐션(Linear Attention) 메커니즘은 순전파(Forward pass) 과정에서 입력된 예시(Prompt)들을 사용하여 모델 내부의 표현(Representation)을 수정하는데, 이 과정이 마치 경사 하강법을 한 스텝 수행하여 모델을 미세 조정한 것과 동일한 효과를 낸다는 것이다.</p>
<p>구체적으로 설명하면 다음과 같다:</p>
<ol>
<li><strong>메타 옵티마이저(Meta-Optimizer):</strong> 트랜스포머 모델 자체가 하나의 옵티마이저 역할을 한다.</li>
<li><strong>순전파 내의 학습:</strong> 프롬프트에 제공된 <code>(입력, 출력)</code> 쌍들은 학습 데이터 역할을 하며, 어텐션 레이어는 이 데이터들 간의 관계(Error signal과 유사한 정보)를 계산하여 쿼리(Query) 토큰에 대한 예측을 수정한다.</li>
<li><strong>가상 가중치 업데이트:</strong> 실제 모델 파라미터 <span class="math math-inline">W</span>는 고정되어 있지만, 어텐션에 의해 생성된 문맥 벡터(<span class="math math-inline">\Delta W</span>와 유사)가 원래의 가중치에 더해지는 효과를 내어, 결과적으로 해당 작업에 특화된 모델로 순간 변신한다.15</li>
</ol>
<p>이 이론은 왜 모델이 가중치를 업데이트하지 않고도 새로운 함수나 규칙을 근사할 수 있는지를 강력하게 설명해 준다. ICL은 추론 시간(Inference-time)에 일어나는 고속 최적화 과정인 것이다.</p>
<pre><code class="language-mermaid">graph TD
    Input["Prompt with Examples (Input, Output pairs)"] --&gt; Forward["Transformer Forward Pass"]
    
    subgraph ICL_Process ["In-Context Learning as Meta-Optimization"]
        Forward --&gt; Attn("Attention Mechanism")
        Attn --&gt; ErrorCalc["Calculate Relation (Error Signal)"]
        ErrorCalc --&gt; RepUpdate["Update Internal Representations"]
        RepUpdate --&gt; Note["Equivalent to: One step of Gradient Descent"]
    end
    
    RepUpdate --&gt; FinalPred["Predict Query Output"]
    
    style Note fill:#fffdd0,stroke:#d4a017,stroke-dasharray: 5 5
</code></pre>
<h3>4.2 메커니즘 2: 유도 헤드 (Induction Heads)</h3>
<p>Anthropic의 Olsson 등(2022)은 트랜스포머 내부의 특정 부품인 **유도 헤드(Induction Heads)**가 ICL 능력의 물리적 실체라고 주장했다.17 유도 헤드는 기계적인 패턴 매칭 회로로, 다음과 같은 2단계 알고리즘을 수행한다.</p>
<ol>
<li><strong>Prefix Matching (접두사 일치):</strong> 현재 토큰(A)이 과거 문맥 어디에서 등장했는지를 찾는다. (예: <code>... [A]... [A]</code>)</li>
<li><strong>Copying (복사):</strong> 과거에 토큰 A 뒤에 따라왔던 토큰(B)을 찾아, 현재 위치의 다음 토큰 예측 확률을 높인다. (<code>... [A] -&gt;</code>)</li>
</ol>
<p>Few-shot 프롬프트는 본질적으로 <code>입력 -&gt; 출력</code> 패턴의 반복이다. 유도 헤드는 앞선 예시들에서 <code>입력 A</code> 뒤에 <code>출력 B</code>가 왔다는 패턴을 감지하고, 새로운 <code>입력 A'</code>가 주어졌을 때 이와 유사한 논리적 구조를 가진 <code>출력 B'</code>를 생성하도록 유도한다.19</p>
<p>특히 중요한 점은, 모델의 학습 과정에서 <strong>유도 헤드가 형성되는 시점과 모델의 ICL 능력이 급격히 향상되는 시점이 정확히 일치</strong>한다는 것이다. 이는 ICL이 우연한 산물이 아니라, 트랜스포머 구조 내에서 필연적으로 발생하는 기계적 회로에 기반함을 시사한다.17</p>
<h3>4.3 메커니즘 3: 베이지안 추론 (Bayesian Inference)</h3>
<p>Xie 등(2021)은 ICL을 <strong>암시적 베이지안 추론</strong> 과정으로 해석했다.20 거대 언어 모델은 사전 학습을 통해 수많은 ‘잠재 개념(Latent Concepts)’(예: 번역, 요약, 감정 분석, 코드 생성 등)의 혼합 분포를 학습한다.</p>
<ul>
<li><strong>개념 위치 파악(Concept Locating):</strong> 프롬프트로 주어지는 예시들은 모델이 이 거대한 개념 공간에서 현재 사용자가 원하는 작업(Concept)이 무엇인지를 좁혀 나가는 증거(Evidence)가 된다.</li>
<li><strong>사후 확률 최대화:</strong> 모델은 주어진 예시들을 관측 데이터로 삼아, 사전 학습된 분포(Prior) 위에서 사후 확률(Posterior)을 계산하고, 이를 통해 가장 적합한 개념을 선택하여 출력을 생성한다.</li>
</ul>
<p>이 관점은 모델의 크기가 클수록 ICL 성능이 좋아지는 이유를 설명한다. 더 큰 모델은 더 많은 개념을 저장할 수 있고, 더 정교한 추론 능력을 통해 예시들로부터 정확한 개념을 유추할 수 있기 때문이다.21</p>
<h2>5.  스케일링 법칙과 창발성(Emergence)</h2>
<p>GPT-3의 성공을 뒷받침한 가장 강력한 이론적 배경은 바로 **스케일링 법칙(Scaling Laws)**이다. Kaplan 등(2020)은 언어 모델의 성능(Loss)이 모델 파라미터 수(<span class="math math-inline">N</span>), 데이터셋 크기(<span class="math math-inline">D</span>), 연산량(<span class="math math-inline">C</span>)과 멱법칙(Power Law) 관계를 따른다는 것을 규명했다.22</p>
<h3>5.1 멱법칙의 지배: <span class="math math-inline">L \propto N^{-\alpha}</span></h3>
<p>이 법칙은 모델의 성능 향상이 무작위적이거나 수확 체감의 법칙에 의해 멈추는 것이 아니라, 자원을 투입하는 만큼 예측 가능한 속도로 계속 좋아짐을 의미한다.</p>
<ul>
<li><strong>예측 가능성:</strong> 아키텍처의 세부적인 튜닝(너비, 깊이 등)보다는 ‘규모’ 자체가 성능을 결정짓는 가장 지배적인 변수(Parameter count is king)라는 사실이 밝혀졌다. 이는 OpenAI가 1.5B(GPT-2)에서 175B(GPT-3)로 과감하게 스케일을 100배 이상 키울 수 있었던 확신을 제공했다.24</li>
<li><strong>데이터 효율성:</strong> 더 큰 모델은 더 적은 데이터 샘플로도 동일한 성능에 도달할 수 있는 샘플 효율성(Sample Efficiency)이 뛰어났다. 이는 Few-shot 학습에서 큰 모델이 압도적으로 유리한 이유를 뒷받침한다.25</li>
</ul>
<h3>5.2 창발적 능력 (Emergent Abilities)</h3>
<p>하지만 스케일링 법칙만으로는 설명되지 않는 현상이 있다. Wei 등(2022)은 모델의 크기가 특정 임계점(Threshold)을 넘어서면, 이전에는 전혀 관찰되지 않았던 능력들이 갑자기 발현되는 **창발성(Emergence)**을 보고했다.26</p>
<ul>
<li><strong>상전이(Phase Transition):</strong> 작은 모델에서 성능이 0%에 가까웠던 작업들이, 특정 파라미터 규모(예: 10B, 100B)를 넘어서는 순간 성능이 급격히 상승하는 ‘계단형(Step Function)’ 그래프를 보인다.</li>
<li><strong>대표적 사례:</strong></li>
<li><strong>3자리 덧셈/뺄셈:</strong> 소형 모델은 숫자의 패턴을 단순히 외우려다 실패하지만, GPT-3와 같은 거대 모델은 산술 연산의 알고리즘을 내부적으로 형성하여 높은 정확도로 문제를 해결한다.29</li>
<li><strong>다단계 추론(Chain-of-Thought):</strong> 복잡한 논리 문제를 단계별로 풀어서 설명하는 능력은 일정 규모 이상의 모델에서만 나타나며, 이는 Few-shot 프롬프팅과 결합하여 시너지를 낸다.31</li>
</ul>
<p>이러한 창발적 능력은 Zero-shot이나 Few-shot이 단순히 ’작은 모델의 흉내 내기’가 아니라, 스케일이 가져온 질적으로 다른 차원의 지능임을 증명한다.</p>
<pre><code class="language-mermaid">graph TD
    Resources["Resources"] --&gt; Scale
    Scale["Scale Increase"] --&gt;|Power Law| Loss["Loss Decrease&lt;br&gt;(Linear)"]
    
    Scale --&gt;|Threshold Passed| Emergence["Emergent Abilities"]
    
    subgraph Abilities ["New Capabilities"]
        Emergence --&gt; Arithmetic["3-digit&lt;br&gt;Arithmetic"]
        Emergence --&gt; CoT["Chain-of-Thought&lt;br&gt;Reasoning"]
        Emergence --&gt; Code["Complex&lt;br&gt;Coding"]
    end
    
    style Emergence fill:#ffcccc,stroke:#ff0000,stroke-width:2px
</code></pre>
<h2>6.  데이터 엔지니어링: 보이지 않는 공신</h2>
<p>GPT-3가 보여준 놀라운 ICL 능력의 뒤편에는 모델 크기만큼이나 중요한 데이터 엔지니어링의 혁신이 있었다. 인터넷 전체를 크롤링한 Common Crawl 데이터는 양은 방대하지만, 품질이 낮고 중복이 많아 그대로 사용할 경우 모델의 성능을 저하시키거나 ICL 능력을 왜곡시킬 위험이 있었다.32</p>
<p>OpenAI는 이를 해결하기 위해 정교한 데이터 정제 파이프라인을 구축했다.33</p>
<ol>
<li><strong>퍼지 중복 제거 (Fuzzy Deduplication):</strong></li>
</ol>
<ul>
<li>완전히 동일한 문서뿐만 아니라, 내용이 매우 유사한 문서들을 제거하기 위해 <strong>MinHashLSH</strong> 알고리즘을 사용했다. Spark 기반의 이 알고리즘은 문서 간의 Jaccard 유사도를 근사하여 중복을 찾아낸다.34</li>
<li><strong>효과:</strong> 중복 데이터는 모델이 특정 문장을 ’암기(Overfitting)’하게 만들어 일반화 능력을 떨어뜨린다. 이를 제거함으로써 모델은 다양한 문맥에서 언어 규칙을 추상화하는 훈련을 하게 되며, 테스트 세트와의 오염(Contamination)을 방지하여 Zero-shot 성능 평가의 신뢰성을 높였다.</li>
</ul>
<ol start="2">
<li><strong>품질 분류기 (Quality Classifier):</strong></li>
</ol>
<ul>
<li>GPT-2에서 구축한 고품질 데이터셋인 <strong>WebText</strong>를 긍정 샘플(Positive Reference)로, Common Crawl의 원본 데이터를 부정 샘플로 사용하여 로지스틱 회귀(Logistic Regression) 분류기를 학습시켰다.12</li>
<li><strong>선별 과정:</strong> 이 분류기를 통해 Common Crawl 데이터 중 WebText와 문체나 정보 밀도가 유사한 ‘고품질’ 문서만을 우선적으로 선별하여 학습에 사용했다. 이는 모델이 문법적 오류나 비논리적인 흐름에 방해받지 않고, 양질의 지식을 습득하는 결정적인 토대가 되었다.</li>
</ul>
<pre><code class="language-mermaid">graph TD
    Raw["Common Crawl (Raw Data)"] --&gt; Step1
    
    subgraph Pipeline ["Data Filtering Pipeline"]
        Step1("Fuzzy Deduplication")
        Step1 --&gt;|MinHashLSH Algorithm| Step2["Remove Similar Documents"]
        Step2 --&gt; Step3("Quality Classification")
        
        Ref["WebText (High Quality Reference)"] -.-&gt; Step3
        Step3 --&gt;|Train Logistic Regression| Step4["Score Documents"]
        Step4 --&gt;|Keep High Score| Clean["High Quality Data"]
        Step4 --&gt;|Discard Low Score| Trash["Discarded Noise"]
    end
    
    Clean --&gt; Training["GPT Training Loop"]
</code></pre>
<h2>7.  결론: 프롬프팅 시대의 개막</h2>
<p>GPT-1에서 시작하여 GPT-3에 이르는 진화 과정은 인공지능 역사상 가장 드라마틱한 ‘특이점’ 중 하나다. GPT-1이 미세 조정(Fine-tuning)을 통해 ’특정 작업의 전문가(Specialist)’를 만드는 효율적인 방법을 제시했다면, GPT-3는 인컨텍스트 러닝(Few-shot)을 통해 ’모든 작업의 제너럴리스트(Generalist)’가 될 수 있는 가능성을 증명했다.</p>
<p>미세 조정과 인컨텍스트 러닝의 비교는 이제 인공지능 개발의 핵심적인 의사결정 요소가 되었다.37</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>미세 조정 (Fine-tuning)</strong></th><th><strong>인컨텍스트 러닝 (ICL)</strong></th></tr></thead><tbody>
<tr><td><strong>방법론</strong></td><td>파라미터 업데이트 (재학습)</td><td>프롬프트 디자인 (추론만 수행)</td></tr>
<tr><td><strong>자원 소모</strong></td><td>높음 (GPU 학습 비용, 데이터 라벨링)</td><td>낮음 (추론 비용만 발생)</td></tr>
<tr><td><strong>유연성</strong></td><td>낮음 (새로운 작업마다 재학습 필요)</td><td>높음 (프롬프트만 바꾸면 즉시 적응)</td></tr>
<tr><td><strong>정확도</strong></td><td>특정 도메인에서 최고 성능(SOTA)</td><td>일반적인 상황에서 준수한 성능 (Strong Baseline)</td></tr>
<tr><td><strong>데이터 요구</strong></td><td>수천 개의 라벨링 데이터 필수</td><td>소수의 예시(0~100개)만 있으면 가능</td></tr>
</tbody></table>
<p>GPT 시리즈의 진화는 단순히 모델 성능의 향상을 넘어, 인간과 기계가 상호작용하는 인터페이스의 혁명을 가져왔다. 이제 우리는 모델에게 복잡한 코드를 입력하여 학습시키는 대신, 자연어로 “이것 좀 해봐, 예를 들면 이런 거야“라고 말함으로써 작업을 지시한다. 유도 헤드가 과거의 패턴을 복사하고, 암시적 경사 하강법이 순식간에 모델을 최적화하며, 거대한 파라미터가 창발적 지능을 뿜어내는 이 현상은, 우리가 진정한 의미의 ’언어 이해(Language Understanding)’에 한 걸음 더 다가섰음을 시사한다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>GPT-1 - Wikipedia, https://en.wikipedia.org/wiki/GPT-1</li>
<li>Improving Language Understanding by Generative Pre-Training - OpenAI, https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf</li>
<li>Improving Language Understanding by Generative Pre-Training - DAMAS, https://ulaval-damas.github.io/glo4030/assets/slides/3.2-GPT.pdf</li>
<li>Paper summary: GPT 1 — Improving Language Understanding by Generative Pre-Training, https://sannaperzon.medium.com/paper-summary-gpt-1-improving-language-understanding-by-generative-pre-training-c43bd7ff242a</li>
<li>Language Models are Unsupervised Multitask Learners | OpenAI, https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf</li>
<li>Language Models are Unsupervised Multitask Learners (GPT-2) | Fan Pu Zeng, https://fanpu.io/summaries/2023-08-10-language-models-are-unsupervised-multitask-learners/</li>
<li>GPT-2: Language Models are Unsupervised Multitask Learners - YouTube, https://www.youtube.com/watch?v=u1_qMdb0kYU</li>
<li>Data | CS324, https://stanford-cs324.github.io/winter2022/lectures/data/</li>
<li>Language Models are Few-Shot Learners - NIPS papers, https://proceedings.neurips.cc/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf</li>
<li>GPT-3: Language Models are Few-Shot Learners | by Grigory Sapunov | Medium, https://moocaholic.medium.com/gpt-3-language-models-are-few-shot-learners-a13d1ae8b1f9</li>
<li>Language Models are Few Shot Learners - Meta Learning with GPT-3, https://www.auroria.io/language-models-are-few-shot-learners-analyzing-gpt-3-meta-learning-nlp/</li>
<li>Language Models are Few-Shot Learners - arXiv, https://arxiv.org/pdf/2005.14165</li>
<li>Understanding In-Context Learning in Transformers and LLMs by Learning to Learn Discrete Functions | OpenReview, https://openreview.net/forum?id=ekeyCgeRfC</li>
<li>Trained Transformers Learn Linear Models In-Context, https://jmlr.org/papers/v25/23-1042.html</li>
<li>Learning without training: The implicit dynamics of in-context learning - arXiv, https://arxiv.org/html/2507.16003v2</li>
<li>How Exactly Does In-Context Few-Shot Learning Actually Work in Theory (Under the Hood), Despite only Having a “Few” Support Examples to “Train On”? - Data Science Stack Exchange, https://datascience.stackexchange.com/questions/115554/how-exactly-does-in-context-few-shot-learning-actually-work-in-theory-under-the</li>
<li>In-context Learning and Induction Heads - ResearchGate, https://www.researchgate.net/publication/363859214_In-context_Learning_and_Induction_Heads</li>
<li>[2209.11895] In-context Learning and Induction Heads - arXiv, https://arxiv.org/abs/2209.11895</li>
<li>In-context Learning and Induction Heads - Transformer Circuits Thread, https://transformer-circuits.pub/2022/in-context-learning-and-induction-heads/index.html</li>
<li>An Explanation of In-context Learning as Implicit Bayesian Inference - OpenReview, https://openreview.net/forum?id=RdJVFCHjUMI</li>
<li>[Quick Review] An Explanation of In-context Learning as Implicit Bayesian Inference - Liner, https://liner.com/review/an-explanation-of-incontext-learning-as-implicit-bayesian-inference</li>
<li>AI Scaling Laws Explained - Medium, https://medium.com/@pacosun/beyond-the-parameter-count-8ba5bb3a5543</li>
<li>Scaling Laws from the Data Manifold Dimension Abstract 1. Introduction - Journal of Machine Learning Research, https://jmlr.csail.mit.edu/papers/volume23/20-1111/20-1111.pdf</li>
<li>Scaling Laws for Neural Language Models - arXiv, https://arxiv.org/pdf/2001.08361</li>
<li>Scaling Laws for Neural Language Models | Elias Z. Wang | AI Researcher &amp; PhD Candidate at Stanford, https://eliaszwang.com/paper-reviews/scaling-laws-neural-lm/</li>
<li>Emergent Abilities of Large Language Models - GitHub Pages, https://fernandoperezc.github.io/Advanced-Topics-in-Machine-Learning-and-Data-Science/Puntener.pdf</li>
<li>Overview of Emergent Abilities in AI - World Scholars Review, https://www.worldscholarsreview.org/article/overview-of-emergent-abilities-in-ai</li>
<li>Emergent Abilities of Large Language Models | Request PDF - ResearchGate, https://www.researchgate.net/publication/361323261_Emergent_Abilities_of_Large_Language_Models</li>
<li>Emergent Properties in Large Language Models: A Deep Research Analysis - Greg Robison, https://gregrobison.medium.com/emergent-properties-in-large-language-models-a-deep-research-analysis-d6886c37061b</li>
<li>Foundation Models in HEP - Anna Hallin - TUM Physikdepartment (Indico), https://indico.ph.tum.de/event/7906/contributions/10714/attachments/6920/9623/Foundation_models_for_HEP_Anna_Hallin.pdf</li>
<li>Large Language Models are few(1)-shot Table Reasoners - ACL Anthology, https://aclanthology.org/2023.findings-eacl.83.pdf</li>
<li>Training Data for the Price of a Sandwich - Mozilla Foundation, https://www.mozillafoundation.org/en/research/library/generative-ai-training-data/common-crawl/</li>
<li>GPT Technical Evolutionary History (1) | by Jinpeng Zhang - Medium, https://dataturbo.medium.com/gpt-technical-evolutionary-history-1-b639a770a0af</li>
<li>GPT-3 - Wikipedia, https://en.wikipedia.org/wiki/GPT-3</li>
<li>Mastering Duplicate Data Management in Machine Learning for Optimal Model Performance, https://dagshub.com/blog/mastering-duplicate-data-management-in-machine-learning-for-optimal-model-performance/</li>
<li>GPT-3 An Overview, https://dzlab.github.io/ml/2020/07/25/gpt3-overview/</li>
<li>Pre-training vs Fine-Tuning vs In-Context Learning of Large Language Models, https://www.entrypointai.com/blog/pre-training-vs-fine-tuning-vs-in-context-learning-of-large-language-models/</li>
<li>Fine-Tuning vs. In-Context Learning: A Practical Guide | by Hey Amit - Medium, https://medium.com/@heyamit10/fine-tuning-vs-in-context-learning-a-practical-guide-08163ede6d1a</li>
<li>Key AI Methodologies: Fine-Tuning vs. In-Context Learning - AI-PRO.org, https://ai-pro.org/learn-ai/articles/optimal-strategies-for-ai-performance-fine-tune-vs-incontext-learning</li>
<li>Few-shot Fine-tuning vs. In-context Learning: A Fair Comparison and Evaluation - ACL Anthology, https://aclanthology.org/2023.findings-acl.779.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>