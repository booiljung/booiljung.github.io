<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.1 BERT 양방향 문맥 학습과 마스크드 언어 모델(MLM)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.1 BERT 양방향 문맥 학습과 마스크드 언어 모델(MLM)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>3.1 BERT 양방향 문맥 학습과 마스크드 언어 모델(MLM)</span></nav>
                </div>
            </header>
            <article>
                <h1>3.1 BERT 양방향 문맥 학습과 마스크드 언어 모델(MLM)</h1>
<p>2025-12-19, G30DR</p>
<h2>1.  자연어 처리의 패러다임 전환: 단방향에서 양방향으로</h2>
<p>2018년 구글이 발표한 BERT(Bidirectional Encoder Representations from Transformers)는 자연어 처리(NLP) 분야에서 단순한 성능 향상을 넘어선 근본적인 패러다임의 전환을 가져왔다.1 BERT 이전의 NLP 모델링은 주로 단방향(Unidirectional) 혹은 얕은 양방향(Shallow Bidirectional) 구조에 의존하고 있었으며, 이는 인간의 언어 이해 방식을 온전히 모사하는 데 명확한 한계를 지니고 있었다. 본 절에서는 BERT가 등장하게 된 역사적, 기술적 배경과 함께, 기존 모델들이 가졌던 구조적 제약을 극복하기 위해 채택한 혁신적인 아키텍처 설계를 심도 있게 분석한다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "Unidirectional (GPT)"
        G1["Input: A B C"] --&gt; G2["Process: Left-to-Right"]
        G2 --&gt; G3["Output: Predict D based on A,B,C"]
        style G1 fill:#f9f,stroke:#333
    end

    subgraph "Shallow Bidirectional (ELMo)"
        E1["Input: A B C"] --&gt; E2["Forward LSTM (L-to-R)"]
        E1 --&gt; E3["Backward LSTM (R-to-L)"]
        E2 --&gt; E4["Concatenation"]
        E3 --&gt; E4
        E4 --&gt; E5["Output: Combined Features"]
        style E1 fill:#ff9,stroke:#333
    end

    subgraph "Deep Bidirectional (BERT)"
        B1["Input: A B C"] --&gt; B2["Transformer Encoder"]
        B2 --&gt; B3["Mechanism: Self-Attention (All-to-All)"]
        B3 --&gt; B4["Output: Contextual Representation"]
        style B1 fill:#9cf,stroke:#333
    end
</code></pre>
<h3>1.1  순차적 처리의 한계와 트랜스포머 아키텍처의 도입</h3>
<p>BERT의 등장을 이해하기 위해서는 먼저 2017년 구글의 “Attention Is All You Need” 논문이 가져온 충격을 되짚어볼 필요가 있다. 이 논문은 기존의 순환 신경망(RNN)과 장단기 메모리(LSTM)가 지배하던 시퀀스 모델링 분야에 ’트랜스포머(Transformer)’라는 새로운 아키텍처를 제시했다.3 RNN 기반 모델들은 데이터를 순차적으로 처리해야 한다는 본질적인 제약 때문에 병렬 처리가 불가능했고, 이는 대규모 데이터 학습을 저해하는 주요 요인이었다. 또한, 문장의 길이가 길어질수록 앞부분의 정보가 소실되는 ‘장기 의존성(Long-term Dependency)’ 문제를 근본적으로 해결하지 못하고 있었다.4</p>
<p>트랜스포머는 이러한 순환(Recurrence) 구조를 완전히 배제하고, 어텐션(Attention) 메커니즘만으로 입력 시퀀스 전체의 관계를 파악하는 방식을 제안했다. “트랜스포머“라는 이름은 당시 논문의 저자 중 한 명인 야콥 우츠코라이트(Jakob Uszkoreit)가 이 단어의 어감을 좋아하여 채택되었으며, 초기 설계 문서에는 변신 로봇 프랜차이즈인 트랜스포머의 캐릭터들이 그려져 있기도 했다.3 이 모델은 문장 내의 모든 단어가 서로를 동시에 참조할 수 있는 구조를 통해 병렬 처리 효율을 극대화했고, 이는 훗날 BERT와 같은 거대 언어 모델이 탄생할 수 있는 하드웨어적, 알고리즘적 기반이 되었다.5</p>
<p>그러나 트랜스포머 초기 모델은 기계 번역과 같은 시퀀스-투-시퀀스(Seq2Seq) 과제에 초점을 맞추고 있었다. 인코더-디코더 구조를 갖춘 이 모델에서 디코더 부분은 여전히 이전 단어를 통해 다음 단어를 예측하는 자기회귀(Autoregressive) 방식을 따랐으며, 이는 언어 모델링의 관점에서는 여전히 ‘왼쪽에서 오른쪽으로(Left-to-Right)’ 흐르는 단방향성을 유지하고 있음을 의미했다.3</p>
<h3>1.2  얕은 양방향성(ELMo) 대 깊은 양방향성(Deep Bidirectionality)</h3>
<p>BERT 이전에도 문맥을 양방향으로 파악하려는 시도는 존재했다. 대표적인 예가 2018년 초에 제안된 ELMo(Embeddings from Language Models)이다. ELMo는 순방향(Forward) LSTM과 역방향(Backward) LSTM을 각각 독립적으로 학습시킨 후, 두 모델이 생성한 은닉 상태(Hidden State)를 연결(Concatenation)하여 사용하는 방식을 택했다.7</p>
<p><span class="math math-display">
ELMo_{k}^{task} = \gamma^{task} \sum_{j=0}^L s_j^{task} h_{k,j}^{LM}
</span><br />
이러한 접근 방식은 단방향 모델보다는 풍부한 문맥 정보를 제공했지만, 진정한 의미의 양방향 통합이라고 보기는 어렵다. 순방향 정보와 역방향 정보가 학습 과정에서 유기적으로 상호작용하는 것이 아니라, 최종 단계에서 단순히 물리적으로 결합되기 때문이다. 이를 학계에서는 ’얕은 양방향성(Shallow Bidirectionality)’이라고 칭한다.8 얕은 양방향성은 문장 내 단어들이 갖는 복잡한 의미 관계와 중의성을 해소하는 데 있어 한계를 드러냈다.</p>
<p>반면, BERT는 트랜스포머의 인코더(Encoder) 구조만을 떼어내어 활용함으로써 ’깊은 양방향성(Deep Bidirectionality)’을 구현했다.1 BERT의 인코더 내에서는 셀프 어텐션(Self-Attention) 메커니즘이 작동하여, 입력된 문장의 모든 단어가 계층(Layer)을 거칠 때마다 서로의 정보를 동시에 참조하고 융합한다. 즉, 특정 단어를 표현하는 벡터는 해당 단어의 왼쪽 문맥과 오른쪽 문맥 전체의 정보를 모든 레이어에서 통합하여 계산된다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>GPT (Generative Pre-trained Transformer)</strong></th><th><strong>ELMo (Embeddings from Language Models)</strong></th><th><strong>BERT (Bidirectional Encoder Representations from Transformers)</strong></th></tr></thead><tbody>
<tr><td><strong>기반 아키텍처</strong></td><td>Transformer Decoder</td><td>Bi-LSTM</td><td>Transformer Encoder</td></tr>
<tr><td><strong>문맥 학습 방향</strong></td><td>단방향 (Unidirectional)</td><td>얕은 양방향 (Shallow Bidirectional)</td><td>깊은 양방향 (Deep Bidirectional)</td></tr>
<tr><td><strong>정보 흐름</strong></td><td>Left-to-Right</td><td>Left-to-Right &amp; Right-to-Left (독립적)</td><td>All-to-All (동시 참조)</td></tr>
<tr><td><strong>주요 활용</strong></td><td>텍스트 생성 (Generation)</td><td>특징 추출 (Feature Extraction)</td><td>텍스트 이해 (Understanding)</td></tr>
</tbody></table>
<p>위 표는 주요 언어 모델들의 구조적 차이를 요약한 것이다.6 GPT와 같은 단방향 모델은 문장 생성에는 탁월하지만, 문맥의 ’이해’가 필요한 과제에서는 뒤쪽 문맥을 참조하지 못하는 맹점을 가진다. 반면 BERT는 인코더 전용(Encoder-only) 설계를 통해 생성 능력은 다소 희생하더라도, 문장의 의미를 파악하는 이해력(Comprehension) 부분에서 압도적인 우위를 점하게 되었다.10</p>
<h3>1.3  인코더 전용 아키텍처의 설계 철학</h3>
<p>왜 BERT는 디코더를 버리고 인코더만 선택했는가? 이 질문에 대한 답은 BERT가 해결하고자 했던 문제의 본질, 즉 ’자연어 이해(NLU, Natural Language Understanding)’에 있다.6 감정 분석, 개체명 인식(NER), 질의응답(QA)과 같은 다운스트림 태스크들은 문장을 생성하는 것보다 주어진 문장의 전체적인 맥락과 의미를 정확히 파악하는 것이 훨씬 중요하다.</p>
<p>예를 들어, “The bank of the river“와 “The bank of Korea“에서 ’bank’라는 단어의 의미를 구분하기 위해서는 ’bank’의 앞뿐만 아니라 뒤에 오는 ’river’나 ’Korea’라는 단어를 동시에 보아야 한다. 단방향 모델(GPT)은 ’bank’를 처리하는 시점에 뒤에 나올 단어를 알지 못하므로 문맥적 중의성을 완벽히 해결하기 어렵다.9 BERT의 설계자들은 이러한 NLU 태스크의 특성에 주목하여, 생성 능력(Decoder)을 포기하는 대신 인식 능력(Encoder)을 극대화하는 전략을 취했다. 이는 자기회귀적(Autoregressive) 속성을 버리고 오토인코딩(Autoencoding)에 가까운 방식을 채택함으로써 가능해졌다.15</p>
<p>또한 인코더 전용 모델은 배치 처리가 용이하고, 디코더의 순차적 생성 과정(Decoding step)이 필요 없기 때문에 문장 임베딩 생성과 같은 작업에서 병렬화 이점을 최대한 누릴 수 있다는 장점도 존재한다.16 결과적으로 BERT의 아키텍처는 “문맥은 단방향으로 축적되는 것이 아니라, 전체가 동시에 존재하며 상호작용하는 것“이라는 언어학적 통찰을 딥러닝 모델로 구현한 결실이라 할 수 있다.</p>
<h2>2.  마스크드 언어 모델(MLM): 클로즈 테스트의 현대적 재해석</h2>
<p>BERT의 깊은 양방향성을 학습시키는 데에는 치명적인 기술적 난관이 존재했다. 일반적인 언어 모델링(다음 단어 예측) 과제에 양방향 어텐션을 그대로 적용하면, 모델이 예측해야 할 정답 단어를 자기 자신을 포함한 문맥을 통해 미리 ‘볼 수 있는(See itself)’ 상황이 발생하기 때문이다.17 이를 해결하기 위해 BERT 연구진은 **마스크드 언어 모델(Masked Language Model, MLM)**이라는 새로운 학습 목표를 고안해냈다.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Corpus as "Original&lt;br&gt;Corpus"
    participant Tokenizer as "Tokenizer"
    participant Masking as "Masking&lt;br&gt;Strategy"
    participant BERT as "BERT&lt;br&gt;Model"
    participant Loss as "Loss&lt;br&gt;Function"

    Corpus-&gt;&gt;Tokenizer: "Get Sentence:&lt;br&gt;my dog is hairy"
    Tokenizer-&gt;&gt;Masking: "Tokens:&lt;br&gt;[my, dog, is, hairy]"
    
    Note over Masking: "Select 15%&lt;br&gt;of tokens"
    Masking-&gt;&gt;BERT: "Input:&lt;br&gt;[my, dog, is, MASK]"
    
    activate BERT
    Note right of BERT: "Bidirectional&lt;br&gt;Context Learning"
    BERT-&gt;&gt;Loss: "Output Vector&lt;br&gt;for [MASK]"
    deactivate BERT

    Loss-&gt;&gt;Loss: "Compare with&lt;br&gt;original 'hairy'"
    Loss--&gt;&gt;BERT: "Backpropagation&lt;br&gt;(Minimize Cross-Entropy)"
</code></pre>
<h3>2.1  인지심리학적 기원: 게슈탈트 이론과 윌슨 테일러의 클로즈 테스트</h3>
<p>MLM의 개념은 딥러닝 시대에 갑자기 등장한 것이 아니다. 그 기원은 1953년 윌슨 테일러(Wilson L. Taylor)가 제안한 <strong>클로즈 테스트(Cloze Test)</strong> 혹은 클로즈 절차(Cloze Procedure)로 거슬러 올라간다.18 테일러는 게슈탈트 심리학(Gestalt Psychology)의 ‘폐쇄성(Closure)’ 원리에서 영감을 받았다. 인간은 불완전한 형태(예: 끊어진 원)를 보았을 때 이를 완전한 전체로 인식하려는 경향이 있는데, 테일러는 이를 언어 영역에 적용하여 문장의 일부가 누락되더라도 문맥을 통해 이를 복원할 수 있는 능력이 언어 이해도와 직결된다고 보았다.19</p>
<p>테일러의 논문 “Cloze Procedure: A New Tool for Measuring Readability“에 기술된 바와 같이, 클로즈 테스트는 텍스트에서 기계적으로(예: 매 n번째 단어마다) 혹은 선택적으로 단어를 지우고 피험자가 이를 채워 넣게 하는 방식이다.18 예를 들어, “Today I went to the ______ and bought milk“라는 문장에서 빈칸을 채우기 위해서는 ’bought milk’라는 뒤쪽 문맥과 ’went to’라는 앞쪽 문맥을 종합하여 ’supermarket’이나 ‘store’ 같은 단어를 유추해야 한다.19</p>
<p>BERT의 MLM은 이 클로즈 테스트를 대규모 신경망 학습을 위한 목적함수로 재구성한 것이다. 모델은 마치 클로즈 테스트를 수행하는 학생처럼, 가려진 단어()를 주변 문맥을 단서로 하여 추론하도록 훈련받는다. 이는 모델이 단어의 표면적인 순서 통계(Co-occurrence statistics)를 넘어서, 문장 내의 의미적, 구문적 의존 관계를 깊이 있게 학습하도록 강제한다.14</p>
<h3>2.2  정보 유출(Information Leakage) 문제와 마스킹 전략</h3>
<p>양방향 인코더 구조에서 전통적인 조건부 언어 모델링(Conditional Language Modeling)을 사용할 경우 발생하는 문제는 명확하다.<br />
<span class="math math-display">
P(w_i | w_1, \dots, w_{i-1}, w_{i+1}, \dots, w_n)
</span><br />
위 식에서 보듯, 타겟 단어 <span class="math math-inline">w_i</span>를 예측하기 위해 <span class="math math-inline">w_i</span>를 제외한 모든 단어를 참조할 수 있다면, 다층 신경망 구조 내에서 정보가 전파되는 과정에서 <span class="math math-inline">w_i</span>에 대한 정보가 간접적으로 유출될 가능성이 매우 높다. 특히 셀프 어텐션 메커니즘은 모든 위치의 정보를 집계(Aggregation)하므로, 모델은 문맥을 이해하려 노력하기보다 단순히 정답 신호를 복사해오는 쉬운 길(Trivial solution)을 택하게 된다.17</p>
<p>MLM은 입력 자체에서 타겟 단어를 제거(마스킹)함으로써 이 문제를 근본적으로 차단한다. 입력 시퀀스 <span class="math math-inline">X</span>에서 일부 토큰을 특수 토큰 <code>로 치환한 $X_{masked}$를 모델에 입력하고, 모델은 이 </code> 위치에 원래 있던 단어가 무엇인지 예측해야 한다. 이 과정에서 모델은 오로지 `` 주변의 문맥 정보에만 의존해야 하므로, 필연적으로 양방향 문맥을 깊이 있게 분석할 수밖에 없다.15</p>
<h3>2.3  MLM의 확률적 모델링과 손실 함수</h3>
<p>BERT는 전체 입력 토큰의 **15%**를 무작위로 선택하여 마스킹 대상으로 삼는다.9 이 15%라는 비율은 실험적으로 결정된 최적의 균형점이다. 비율이 너무 낮으면(예: 1%) 학습에 기여하는 신호가 부족하여 수렴 속도가 느려지고 계산 비용이 낭비된다. 반대로 비율이 너무 높으면(예: 50%) 문맥 정보가 지나치게 파괴되어 추론 자체가 불가능해지거나, 남은 정보만으로 문장을 재구성하는 것이 무의미해질 수 있다.23</p>
<p>수학적으로 MLM의 손실 함수(Loss Function)는 마스킹된 토큰 집합 <span class="math math-inline">M</span>에 대해 다음과 같은 음의 로그 우도(Negative Log-Likelihood)를 최소화하는 것으로 정의된다.<br />
<span class="math math-display">
L_{MLM} = - \sum_{m \in M} \log P(x_m | X_{\setminus M}; \theta)
</span><br />
여기서 <span class="math math-inline">x_m</span>은 마스킹된 위치의 원래 단어이고, <span class="math math-inline">X_{\setminus M}</span>은 마스킹된 입력을 의미한다. BERT는 최종 은닉 벡터를 소프트맥스(Softmax) 함수에 통과시켜 전체 어휘 집합(Vocabulary)에 대한 확률 분포를 구하고, 이를 정답 단어의 원-핫 인코딩(One-hot Encoding)과 비교하여 크로스 엔트로피(Cross-Entropy) 손실을 계산한다.24</p>
<h2>3.  학습과 추론의 간극: 80-10-10 규칙의 심층 분석</h2>
<p>BERT의 MLM은 강력한 문맥 학습 도구이지만, 구조적인 딜레마를 안고 있다. 바로 <strong>사전 학습(Pre-training)과 미세 조정(Fine-tuning) 환경의 불일치(Mismatch)</strong> 문제이다. 이 문제를 해결하기 위해 도입된 것이 소위 **‘80-10-10 규칙’**이라 불리는 정교한 마스킹 전략이다.</p>
<pre><code class="language-mermaid">graph TD
    Start("Input Sequence Tokenization") --&gt; Select("Select 15% Random Tokens for Prediction")
    
    Select --&gt; Case1("Case 1: 80% Probability")
    Select --&gt; Case2("Case 2: 10% Probability")
    Select --&gt; Case3("Case 3: 10% Probability")

    Case1 --&gt; Action1["Replace with [MASK] Token"]
    Action1 --&gt; Ex1["Ex: my dog is [MASK]"]
    Ex1 --&gt; Goal1["Goal: Force Model to rely on Context"]

    Case2 --&gt; Action2["Replace with Random Word"]
    Action2 --&gt; Ex2["Ex: my dog is apple"]
    Ex2 --&gt; Goal2["Goal: Contextual Verification &amp; Noise Injection"]

    Case3 --&gt; Action3["Keep Original Word"]
    Action3 --&gt; Ex3["Ex: my dog is hairy"]
    Ex3 --&gt; Goal3["Goal: Bias towards actual observation &amp; Reduce Gap"]

    Goal1 --&gt; Merge("Compute Loss for Predicted Position")
    Goal2 --&gt; Merge
    Goal3 --&gt; Merge
</code></pre>
<h3>3.1  사전 학습과 미세 조정의 불일치(Discrepancy) 문제</h3>
<p>사전 학습 단계에서 BERT는 수많은 <code>토큰을 입력으로 받는다. 모델은</code>가 보이면 “아, 이 위치의 단어를 맞춰야 하는구나“라고 인식하고 해당 위치의 문맥 표현을 정교하게 다듬는 데 집중한다. 그러나 실제 질의응답이나 감정 분석과 같은 다운스트림 태스크를 수행하는 미세 조정 단계, 그리고 실제 서비스에 투입되는 추론(Inference) 단계에서는 입력 데이터에 `` 토큰이 전혀 등장하지 않는다.22</p>
<p>만약 모델이 <code>토큰이 있을 때만 문맥을 제대로 파악하도록 학습된다면,</code>가 없는 일반 텍스트가 들어왔을 때 성능이 저하될 수 있다. 즉, 모델이 ``라는 특정 신호에 과적합(Overfitting)되는 것을 막고, 어떤 입력이 들어오더라도 문맥을 파악하는 능력을 일반화(Generalization)할 필요가 있다.9</p>
<h3>3.2  80-10-10 전략의 구성과 의의</h3>
<p>BERT 연구진은 마스킹 대상으로 선정된 15%의 토큰 위치(i번째 토큰)에 대해 다음과 같은 3가지 변형을 가하는 전략을 수립했다.22</p>
<ol>
<li><strong>80%: 토큰으로 치환</strong></li>
</ol>
<ul>
<li><strong>예시:</strong> <code>my dog is hairy</code> <span class="math math-inline">\rightarrow</span> <code>my dog is</code></li>
<li><strong>메커니즘:</strong> 이는 표준적인 MLM 학습 방식이다.</li>
<li><strong>목적:</strong> 모델에게 명시적으로 “이 빈칸을 채우라“는 과제를 부여하여, 양방향 문맥을 활용한 단어 추론 능력을 극대화한다. 전체 학습의 주축이 되는 부분이다.</li>
</ul>
<ol start="2">
<li><strong>10%: 임의의 단어(Random Token)로 치환</strong></li>
</ol>
<ul>
<li><strong>예시:</strong> <code>my dog is hairy</code> <span class="math math-inline">\rightarrow</span> <code>my dog is apple</code></li>
<li><strong>메커니즘:</strong> 원래 단어를 코퍼스 내의 무작위 단어로 교체한다.</li>
<li><strong>목적:</strong> 이 전략은 **노이즈 주입(Noise Injection)**과 **문맥 검증(Contextual Verification)**을 위한 것이다. 만약 항상 <code>만 예측 대상이 된다면, 모델은 </code>가 아닌 단어들은 무조건 “참(True)“이라고 가정하고 문맥적 정합성을 따지지 않을 수 있다. 랜덤 단어 치환을 통해 모델은 현재 보이는 단어가 문맥상 어색하지 않은지 끊임없이 의심하고 검증해야 한다. 이는 모델이 특정 단어의 임베딩 정보에만 의존하지 않고, 전체 문맥의 흐름을 파악하여 이상치(Outlier)를 탐지하고 수정하는 능력을 기르게 한다.26 이는 디노이징 오토인코더(Denoising Autoencoder)의 원리와도 맞닿아 있다.</li>
</ul>
<ol start="3">
<li><strong>10%: 원본 단어(Original Token) 유지</strong></li>
</ol>
<ul>
<li><strong>예시:</strong> <code>my dog is hairy</code> <span class="math math-inline">\rightarrow</span> <code>my dog is hairy</code></li>
<li><strong>메커니즘:</strong> 마스킹 대상으로 선정되었으나, 실제로는 변경하지 않고 그대로 둔다. 단, 모델에게는 여전히 이 위치의 단어를 예측하라고 요구한다.</li>
<li><strong>목적:</strong> 이 전략은 **관측 데이터 편향(Bias towards actual observation)**을 유도하고 <strong>학습-추론 간극을 해소</strong>하기 위한 것이다. 모델 입장에서는 어떤 토큰이 예측 대상인지 알 수 없으므로(모든 입력 토큰을 잠재적 예측 대상으로 간주), 모든 토큰 위치에 대해 항상 문맥 정보를 최적으로 유지하려 노력하게 된다. 또한, 입력된 단어가 실제로 정답일 경우 이를 그대로 출력하도록 학습함으로써, 미세 조정 시 ``가 없는 문장을 처리할 때도 안정적인 표현(Representation)을 생성할 수 있게 돕는다.26</li>
</ul>
<h3>3.3  마스킹 비율(15%)에 대한 경험적 고찰과 대안적 전략</h3>
<p>15%라는 마스킹 비율과 80-10-10의 혼합 비율은 광범위한 실험을 통해 도출된 경험적 수치이다. BERT 원저자들의 실험에 따르면, 마스킹 비율을 이보다 높일 경우 학습 효율은 증가할 수 있으나 문맥 정보 손실로 인한 성능 저하가 발생했다.</p>
<p>흥미롭게도 후속 연구들에서는 이 규칙에 대한 반론도 제기되었다. 2023년 EACL에 발표된 연구 등 일부 논문에서는 80-10-10 규칙 대신 단순히 100% 마스킹을 적용하거나 다른 비율을 적용해도 성능 차이가 미미하거나 오히려 특정 태스크에서는 80-10-10 규칙이 성능을 저하시킬 수 있음을 시사하기도 했다.23 예를 들어, 랜덤 토큰 치환(10%)이 모델에게 불필요한 혼란을 주어 수렴을 방해한다는 주장도 있다. 그러나 BERT가 발표될 당시, 그리고 현재까지도 이 80-10-10 규칙은 사전 학습된 언어 모델의 강건성(Robustness)을 확보하고 전이 학습(Transfer Learning)의 효율을 높이는 표준적인 방법론으로 자리 잡고 있다. 이는 BERT가 단순한 빈칸 채우기 기계를 넘어, 문맥의 진위를 판별하고 노이즈를 스스로 제거할 수 있는 고도의 언어 이해 능력을 갖추게 된 결정적인 요인 중 하나이다.</p>
<h2>4.  다음 문장 예측(NSP): 담화 수준의 이해</h2>
<p>BERT의 사전 학습 목표는 MLM 하나만이 아니다. 단어 수준의 문맥 파악을 넘어, 문장과 문장 사이의 논리적 관계를 이해하는 능력은 더욱 복잡한 NLP 과제를 수행하는 데 필수적이다. 이를 위해 BERT는 **다음 문장 예측(Next Sentence Prediction, NSP)**이라는 보조 과제를 도입했다.25</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Input Processing"
        SentA["Sentence A"] 
        SentB["Sentence B"]
        Sep["[SEP] Token"]
        CLS["[CLS] Token"]
    end

    CLS --&gt; InputStream["Full Input Sequence"]
    SentA --&gt; InputStream
    Sep --&gt; InputStream
    SentB --&gt; InputStream

    InputStream --&gt; BERT["BERT Transformer Layers"]
    
    BERT --&gt; Extract["Extract [CLS] Final Hidden State"]
    Extract --&gt; Classifier["Binary Classification Layer"]
    
    Classifier --&gt; Result{{"Prediction"}}
    Result --&gt; True["IsNext (50%)"]
    Result --&gt; False["NotNext (50%)"]

    style CLS fill:#f96,stroke:#333,stroke-width:2px
    style Result fill:#9f9,stroke:#333,stroke-width:2px
</code></pre>
<h3>4.1  문장 간 논리적 연결성 학습의 필요성</h3>
<p>질의응답(QA)이나 자연어 추론(NLI)과 같은 태스크는 두 문장 사이의 관계를 파악하는 것이 핵심이다. 예를 들어, QA에서는 질문(Question)과 지문(Passage) 사이의 연관성을 파악해야 하고, NLI에서는 전제(Premise)와 가설(Hypothesis)이 함의(Entailment), 모순(Contradiction), 혹은 중립(Neutral) 관계인지 판단해야 한다. MLM만으로는 문장 내부의 통계적 관계는 학습할 수 있어도, 문장 간의 거시적인 담화 구조(Discourse Structure)를 학습하기에는 부족하다는 것이 BERT 개발팀의 판단이었다.5</p>
<h3>4.2  토큰과 이진 분류 메커니즘</h3>
<p>NSP는 모델에게 두 개의 문장 A와 B를 입력으로 주고, “B가 A의 바로 다음에 오는 문장인가?“를 판별하는 이진 분류(Binary Classification) 문제이다.</p>
<ul>
<li><strong>입력 데이터 생성:</strong></li>
<li><strong>50% (IsNext):</strong> 실제 코퍼스에서 문장 A 바로 다음에 이어지는 문장을 B로 선택한다.</li>
<li><strong>50% (NotNext):</strong> 코퍼스 내의 전혀 다른 문서에서 무작위로 추출한 문장을 B로 선택한다.</li>
</ul>
<p>이 학습 과정에서 BERT의 입력 맨 앞에는 <code>(Classification)라는 특수 토큰이 추가된다. BERT 모델의 전체 레이어를 통과한 후 </code> 토큰 위치의 최종 은닉 벡터 <span class="math math-inline">C \in \mathbb{R}^H</span>는 문장 A와 B의 결합된 의미 정보를 함축하고 있다고 가정된다. 이 벡터 <span class="math math-inline">C</span>에 별도의 분류 레이어(Classification Layer) <span class="math math-inline">W \in \mathbb{R}^{K \times H}</span>를 연결하여 <code>IsNext</code>인지 <code>NotNext</code>인지를 예측하도록 학습한다.25<br />
<span class="math math-display">
P = \text{softmax}(CW^T)
</span><br />
또한 두 문장을 구분하기 위해 문장 사이에는 ``(Separator) 토큰이 삽입되며, 각 토큰에는 자신이 속한 문장을 나타내는 세그먼트 임베딩(Segment Embedding)이 더해진다.24</p>
<h3>4.3  NSP의 효용성에 대한 논쟁: RoBERTa의 소거 연구(Ablation Study)</h3>
<p>BERT 원논문에서는 NSP를 제거했을 때 QNLI, MNLI, SQuAD와 같은 태스크에서 성능이 유의미하게 하락했다고 보고하며 NSP의 중요성을 강조했다.5 그러나 이후 등장한 후속 연구들, 특히 페이스북 AI의 **RoBERTa(Robustly optimized BERT approach)**는 이러한 결론에 의문을 제기하며 NSP의 실효성에 대한 논쟁을 촉발시켰다.32</p>
<p>RoBERTa 연구진은 정교한 소거 연구(Ablation Study)를 통해 다음과 같은 사실을 발견했다:</p>
<ol>
<li><strong>세그먼트 쌍(Segment-pair) vs 문장 쌍(Sentence-pair):</strong> BERT는 NSP를 위해 입력을 두 개의 ‘문장’ 단위로 구성했는데, 이는 입력 길이를 짧게 만들어 모델이 긴 문맥(Long-range dependency)을 학습하는 것을 방해했다.</li>
<li><strong>NSP 제거 효과:</strong> NSP 손실 함수를 제거하고, 대신 하나의 긴 연속된 텍스트(Doc-sentences 혹은 Full-sentences)를 입력으로 주어 MLM만 학습시켰을 때, 오히려 GLUE 벤치마크 점수와 SQuAD 성능이 향상되거나 대등한 결과를 보였다.32</li>
</ol>
<p>이러한 결과는 NSP 자체가 불필요하다기보다는, NSP를 구현하기 위해 입력을 인위적으로 자르고 구성하는 방식이 학습 데이터의 질을 저하시켰음을 시사한다. 또한 최근의 연구들은 모델의 크기가 커지고 학습 데이터가 방대해질수록, MLM만으로도 문장 간의 관계를 충분히 내재적으로 학습할 수 있음을 보여준다.28 결과적으로 최신 모델들(예: ALBERT, RoBERTa)은 NSP를 제거하거나, 문장 순서 예측(Sentence Order Prediction, SOP)과 같은 더 어려운 과제로 대체하는 추세이다.34 하지만 BERT가 최초로 제안한 NSP는 언어 모델이 문장 단위의 관계성을 명시적으로 학습하도록 시도했다는 점에서 역사적으로 중요한 이정표임은 부인할 수 없다.</p>
<h2>5.  BERT의 입력 표현 체계: 벡터 공간의 결합</h2>
<p>BERT가 양방향 문맥과 문장 간 관계를 효과적으로 학습하기 위해서는 입력 데이터를 표현하는 방식(Input Representation) 또한 매우 정교해야 한다. BERT는 텍스트를 숫자로 변환하는 과정에서 <strong>토큰 임베딩(Token Embeddings)</strong>, <strong>세그먼트 임베딩(Segment Embeddings)</strong>, **위치 임베딩(Position Embeddings)**이라는 세 가지 벡터를 합산하는 독특한 방식을 사용한다.<br />
<span class="math math-display">
E_{input} = E_{token} + E_{segment} + E_{position}
</span></p>
<p>이 세 벡터의 요소별 합(Element-wise Sum)을 통해, BERT는 개별 단어의 의미, 문장 내의 소속 정보, 그리고 문장 내의 위치 정보를 하나의 통합된 벡터 공간에 투영한다.29</p>
<pre><code class="language-mermaid">graph BT
    subgraph "Final Input Representation"
        Final["BERT Input Vector"]
    end

    subgraph "Embedding Summation Layer"
        Sum(("(+)")) --&gt; Final
    end

    subgraph "Embedding Components"
        Token["Token Embeddings"] --"Word Meaning"--&gt; Sum
        Segment["Segment Embeddings"] --"Sentence A vs B"--&gt; Sum
        Position["Position Embeddings"] --"Sequence Order"--&gt; Sum
    end

    Raw["Raw Text Input"] --&gt; Token
    Raw --&gt; Segment
    Raw --&gt; Position

    style Sum fill:#fff,stroke:#333,stroke-width:4px
    style Final fill:#fc9,stroke:#333
</code></pre>
<h3>5.1  WordPiece 토큰화와 미등록 단어(OOV) 처리</h3>
<p>BERT는 입력 텍스트를 처리하기 위해 <strong>WordPiece</strong> 토크나이저를 사용한다. 이는 단어를 통째로 처리하는 기존 방식과 달리, 단어를 의미를 가진 더 작은 단위(Subword)로 쪼개는 방식이다.25</p>
<ul>
<li><strong>작동 원리:</strong> 빈도수가 높은 단어(예: “play”)는 하나의 토큰으로 유지하고, 빈도수가 낮은 복합어(예: “playing”)는 “play“와 “##ing“으로 분리한다. 여기서 “##“은 해당 토큰이 앞 단어에 붙어서 파생된 접미사임을 나타내는 표시이다.</li>
<li><strong>효과:</strong> 이 방식을 사용하면 약 30,000개의 비교적 작은 어휘 집합(Vocabulary)만으로도 거의 모든 단어를 표현할 수 있다. 훈련 데이터에 없는 희귀한 단어(Out-Of-Vocabulary, OOV)가 등장하더라도, 이미 알고 있는 서브워드들의 조합으로 분해하여 처리할 수 있기 때문이다. 이는 다양한 도메인의 텍스트를 처리해야 하는 범용 언어 모델에 있어 필수적인 기능이다.35</li>
</ul>
<h3>5.2  세그먼트 임베딩과 위치 임베딩의 수학적 결합</h3>
<ul>
<li><strong>세그먼트 임베딩(Segment Embeddings):</strong> NSP 과제나 QA 태스크에서는 두 개의 문장(질문과 지문 등)이 하나의 입력으로 들어온다. 모델은 어느 부분이 첫 번째 문장(Sentence A)이고 어느 부분이 두 번째 문장(Sentence B)인지 구별해야 한다. 이를 위해 BERT는 Sentence A에 속한 모든 토큰에 벡터 <span class="math math-inline">E_A</span>를, Sentence B에 속한 토큰에는 벡터 <span class="math math-inline">E_B</span>를 더해준다.25 이는 물리적으로 연결된 시퀀스 내에서 논리적인 경계를 구분 짓는 역할을 한다.</li>
<li><strong>위치 임베딩(Position Embeddings):</strong> 트랜스포머 구조는 순환(RNN)이나 컨볼루션(CNN)을 사용하지 않으므로, 입력된 토큰들의 순서 정보를 내재적으로 알 수 없다. “Tom killed Jerry“와 “Jerry killed Tom“을 구별하기 위해서는 단어의 위치 정보가 필수적이다. BERT는 최대 512개의 위치에 대해 학습 가능한(Learned) 위치 임베딩을 사용하여, 각 토큰이 문장의 몇 번째 위치에 있는지를 벡터에 더해준다. 이는 트랜스포머 원본 논문에서 사인/코사인 함수를 이용한 고정된 위치 인코딩(Sinusoidal Position Encoding)을 사용한 것과 차별화되는 점으로, 학습 데이터에 최적화된 위치 정보를 학습할 수 있다는 장점이 있다.29</li>
</ul>
<h3>5.3  특수 토큰(,)의 역할과 임베딩 전략</h3>
<p>BERT의 입력 체계에서 가장 눈에 띄는 것은 <code>와 </code>라는 특수 토큰의 존재이다.</p>
<ul>
<li><strong>:</strong> 모든 입력 시퀀스의 가장 첫 번째 자리는 항상 `` 토큰이 차지한다. 이 토큰의 최종 출력 벡터는 문장 전체의 의미를 요약하는 역할을 하도록 학습되며, 텍스트 분류(Classification) 문제에서 입력으로 사용된다.24</li>
<li><strong>:</strong> 두 문장을 구분하거나 문장의 끝을 알리기 위해 사용된다. 입력 시퀀스가 하나의 문장일지라도 끝에는 반드시 <code>가 붙으며, 두 문장이 입력될 때는 그 사이에 </code>가 삽입된다.24</li>
</ul>
<p>이러한 정교한 입력 표현 방식은 BERT가 단어의 국소적인 의미뿐만 아니라, 문장 전체의 구조와 맥락을 동시에 파악할 수 있는 강력한 기반을 제공한다.</p>
<h2>6.  실험적 검증과 NLP 생태계에 미친 영향</h2>
<p>BERT의 등장은 NLP 연구의 판도를 완전히 뒤바꾸어 놓았다. 양방향 문맥 학습과 MLM, NSP의 결합은 당시 존재하던 모든 NLP 벤치마크의 기록을 경신하며 압도적인 성능을 증명했다.</p>
<pre><code class="language-mermaid">graph TD
    Data["Large Scale Corpus (Wikipedia + BooksCorpus)"] --&gt; Pretrain["Pre-training Phase"]
    
    subgraph "Pre-training Tasks"
        Pretrain --&gt; MLM["Masked Language Model (MLM)"]
        Pretrain --&gt; NSP["Next Sentence Prediction (NSP)"]
    end

    MLM &amp; NSP --&gt; Base["Pre-trained BERT Model"]

    Base --&gt; FineTune["Fine-tuning Phase"]

    subgraph "Downstream Tasks (GLUE etc.)"
        FineTune --&gt; Task1["Question Answering&lt;br&gt;(SQuAD)"]
        FineTune --&gt; Task2["Sentiment Analysis&lt;br&gt;(SST-2)"]
        FineTune --&gt; Task3["Inference&lt;br&gt;(MNLI)"]
        FineTune --&gt; Task4["Named Entity Recognition&lt;br&gt;(NER)"]
    end

    style Base fill:#ff9,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
</code></pre>
<h3>6.1  GLUE 벤치마크를 통한 성능 평가 및 비교 분석</h3>
<p><strong>GLUE(General Language Understanding Evaluation)</strong> 벤치마크는 다양한 NLP 태스크를 종합적으로 평가하기 위한 표준 데이터셋이다. BERT는 GLUE의 9개 태스크 중 8개 이상에서 당시 최고 성능(SOTA)을 달성했다.5</p>
<table><thead><tr><th><strong>모델 (Model)</strong></th><th><strong>GLUE 평균 (Score)</strong></th><th><strong>MNLI (정확도)</strong></th><th><strong>SST-2 (정확도)</strong></th><th><strong>MRPC (F1)</strong></th><th><strong>파라미터 수</strong></th></tr></thead><tbody>
<tr><td><strong>GPT-1</strong></td><td>72.8</td><td>82.1%</td><td>91.3%</td><td>82.3</td><td>117M</td></tr>
<tr><td><strong>BERT-Base</strong></td><td><strong>79.6</strong></td><td><strong>84.6%</strong></td><td><strong>93.5%</strong></td><td><strong>88.9</strong></td><td>110M</td></tr>
<tr><td><strong>BERT-Large</strong></td><td><strong>82.1</strong></td><td><strong>86.7%</strong></td><td><strong>94.9%</strong></td><td><strong>89.3</strong></td><td>340M</td></tr>
</tbody></table>
<p>위 표는 BERT 논문에 보고된 GLUE 벤치마크 결과의 일부를 재구성한 것이다.37 파라미터 수가 비슷한 GPT-1과 비교했을 때, BERT-Base는 평균 점수에서 약 7점 이상의 큰 격차를 보였다. 특히 문장 간의 복잡한 추론을 요구하는 MNLI(Multi-Genre Natural Language Inference)와 의미적 유사성을 판단하는 MRPC(Microsoft Research Paraphrase Corpus)에서 BERT의 양방향성이 빛을 발했다. 이는 단방향 모델이 놓치기 쉬운 문맥의 미묘한 차이를 BERT가 훨씬 정교하게 포착했음을 방증한다.40</p>
<h3>6.2  생성 모델(GPT)과의 비교 및 BERT의 구조적 한계</h3>
<p>BERT의 성공이 GPT와 같은 생성 모델의 종말을 의미하는 것은 아니다. 두 모델은 서로 다른 목적을 가지고 발전해왔다.</p>
<ul>
<li><strong>BERT의 강점:</strong> 문장의 의미를 깊이 있게 파악해야 하는 <strong>‘이해(Understanding)’</strong> 태스크(분류, 개체명 인식, 질의응답)에서 압도적이다.6</li>
<li><strong>BERT의 약점:</strong> MLM의 특성상 텍스트를 순차적으로 생성하는 <strong>‘생성(Generation)’</strong> 능력은 부족하다. 마스킹된 단어들을 독립적으로 예측하는 구조이기 때문에, 문장 전체를 유창하게 작문하거나 이야기를 지어내는 능력은 자기회귀 모델인 GPT에 비해 현저히 떨어진다.41 또한, 긴 문맥을 처리할 때 연산량이 길이의 제곱(<span class="math math-inline">O(n^2)</span>)으로 증가하는 트랜스포머의 특성상 512토큰이라는 입력 길이 제한은 여전히 실무적인 제약으로 작용한다.</li>
</ul>
<p>또한 일부 연구에서는 BERT가 상식적인 추론(Common-sense reasoning)이나 논리적 함의를 파악하는 데 있어 여전히 인간에 비해 부족하며, 통계적 패턴 매칭에 과도하게 의존한다는 비판도 제기된다.42</p>
<h3>6.3  사전 학습-미세 조정(Pre-training then Fine-tuning) 패러다임의 정착</h3>
<p>BERT가 남긴 가장 큰 유산은 NLP 개발의 표준 프로세스를 **‘사전 학습 후 미세 조정(Pre-training then Fine-tuning)’**으로 완전히 고착화시켰다는 점이다.36 과거에는 특정 태스크를 위해 모델을 처음부터 설계하고 학습시켜야 했지만, BERT 이후에는 대용량 코퍼스로 사전 학습된 거대 모델을 다운로드받아 자신의 데이터셋에 맞게 약간만 튜닝(Fine-tuning)하여 사용하는 것이 상식이 되었다.</p>
<p>이는 데이터가 부족한 소규모 프로젝트나 기업에서도 최첨단(State-of-the-art) 성능을 누릴 수 있게 해주었으며, NLP 기술의 민주화와 확산에 결정적인 기여를 했다. BERT의 아키텍처와 학습 방법론은 이후 RoBERTa, ALBERT, ELECTRA, 그리고 현재의 초거대 언어 모델(LLM)에 이르기까지 수많은 후속 모델의 근간이 되었다. 즉, 3.1절에서 다룬 BERT의 양방향 문맥 학습과 MLM은 현대 NLP 기술의 뼈대를 이루는 가장 핵심적인 개념이라 할 수 있다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Attention Is All You Need - A Deep Dive into the Revolutionary Transformer Architecture, https://towardsai.net/p/machine-learning/attention-is-all-you-need-a-deep-dive-into-the-revolutionary-transformer-architecture</li>
<li>Transformer Architecture: Attention is all you need! | by Vedanth Venkatesh - Medium, https://medium.com/@dogoodwithdata/transformer-architecture-attention-is-all-you-need-d25ac634c68b</li>
<li>Attention Is All You Need - Wikipedia, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need</li>
<li>Attention Is All You Need — Understanding the Transformer Model | by Okan Yenigün, https://levelup.gitconnected.com/attention-is-all-you-need-understanding-the-transformer-model-10519074916f</li>
<li>[1706.03762] Attention Is All You Need - arXiv, https://arxiv.org/abs/1706.03762</li>
<li>GPT Vs. BERT: A Technical Deep Dive | Al Rafay Global, https://alrafayglobal.com/gpt-vs-bert/</li>
<li>Comparison between BERT, GPT-2 and ELMo | by Gaurav Ghati - Medium, https://medium.com/@gghati/comparison-between-bert-gpt-2-and-elmo-9ad140cd1cda</li>
<li>The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning) - Jay Alammar, https://jalammar.github.io/illustrated-bert/</li>
<li>A Complete Guide to BERT with Code | Towards Data Science, https://towardsdatascience.com/a-complete-guide-to-bert-with-code-9f87602e4a11/</li>
<li>BERT Model - NLP - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/explanation-of-bert-model-nlp/</li>
<li>GPT vs BERT - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/gpt-vs-bert/</li>
<li>Encoder Only Architecture: BERT - Medium, https://medium.com/@pickleprat/encoder-only-architecture-bert-4b27f9c76860</li>
<li>Why is BERT considered an encoder-only model, and what implications does this have for its applications? - Module 6 Review - Use this assignment in your class! - OpenClass, https://open.openclass.ai/resource/assignment-65f96eddd5069a4bbeaea0d9/question-65f9715dd5069a4bbeaea115/feedback/share?code=4sIYzWHIo2accg</li>
<li>BERT vs GPT: A Guide to Two Powerful Language Models | by Ravjot Singh | Medium, https://ravjot03.medium.com/bert-vs-gpt-a-guide-to-two-powerful-language-models-b14502438065</li>
<li>BERT vs GPT - Kaggle, https://www.kaggle.com/general/391847</li>
<li>[D] What is the point of encoder only models like bert and roberta anymore? - Reddit, https://www.reddit.com/r/MachineLearning/comments/1ff54no/d_what_is_the_point_of_encoder_only_models_like/</li>
<li>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding - ACL Anthology, https://aclanthology.org/N19-1423.pdf</li>
<li>Taylor, W. L. (1953). Cloze procedure A new tool for measuring readability. Journalism Quarterly, 30, 415-433. - References - Scientific Research Publishing, https://www.scirp.org/reference/referencespapers?referenceid=410598</li>
<li>Cloze test - Wikipedia, https://en.wikipedia.org/wiki/Cloze_test</li>
<li>How to Use the Cloze Test (Cloze Deletion Test) to Score Readability – ReadabilityFormulas.com, https://readabilityformulas.com/how-to-use-the-cloze-test/</li>
<li>“Cloze Procedure”: A New Tool for Measuring Readability - Gwern.net, https://gwern.net/doc/psychology/writing/1953-taylor.pdf</li>
<li>A Dive into BERT’s Masked Language Modeling | by Nilay Parikh | Nov, 2025 | Medium, https://blog.nilayparikh.com/a-dive-into-berts-masked-language-modeling-67d14107a16e</li>
<li>Should You Mask 15% in Masked Language Modeling? - ACL Anthology, https://aclanthology.org/2023.eacl-main.217.pdf</li>
<li>An introduction to the BERT model in details with code | by Pritam Kumar Roy | Medium, https://medium.com/@pritamkumarroy/an-introduction-to-the-bert-model-in-details-with-code-211546d18a95</li>
<li>Understanding the BERT Model - Medium, https://medium.com/analytics-vidhya/understanding-the-bert-model-a04e1c7933a9</li>
<li>BERT MLM - 80% [MASK], 10% random words and 10% same word - how does this work?, https://stats.stackexchange.com/questions/575002/bert-mlm-80-mask-10-random-words-and-10-same-word-how-does-this-work</li>
<li>BERT MLM - 80% [MASK], 10% random words and 10% same word - how does this work?, https://discuss.huggingface.co/t/bert-mlm-80-mask-10-random-words-and-10-same-word-how-does-this-work/17867</li>
<li>NSP-BERT: A Prompt-based Few-Shot Learner through an Original Pre-training Task —— Next Sentence Prediction - ACL Anthology, https://aclanthology.org/2022.coling-1.286.pdf</li>
<li>BERT Input Representation - AFAIK.io, https://afaik.io/wiki/kKwmbJvZ</li>
<li>Introduction to BERT and Segment Embeddings - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2021/05/all-you-need-to-know-about-bert/</li>
<li>[D] In BERT, what is the purpose of the [SEP] token when Segment Embeddings are already included in the input? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/nciv12/d_in_bert_what_is_the_purpose_of_the_sep_token/</li>
<li>Next sentence prediction in RoBERTa - Data Science Stack Exchange, https://datascience.stackexchange.com/questions/76872/next-sentence-prediction-in-roberta</li>
<li>How did RoBERTa outperform XLNet with no architectural changes to the original BERT? - Naoki, https://naokishibuya.medium.com/roberta-eba94eb819d3</li>
<li>Performance Analysis of Transformer Based Models (BERT, ALBERT and RoBERTa) in Fake News Detection - ResearchGate, https://www.researchgate.net/publication/373016675_Performance_Analysis_of_Transformer_Based_Models_BERT_ALBERT_and_RoBERTa_in_Fake_News_Detection</li>
<li>How are the TokenEmbeddings in BERT created? - Stack Overflow, https://stackoverflow.com/questions/57960995/how-are-the-tokenembeddings-in-bert-created</li>
<li>Daily Papers - Hugging Face, <a href="https://huggingface.co/papers?q=GLUE+benchmark+tasks">https://huggingface.co/papers?q=GLUE%20benchmark%20tasks</a></li>
<li>google-bert/bert-base-uncased - Hugging Face, https://huggingface.co/google-bert/bert-base-uncased</li>
<li>Human vs. Muppet: A Conservative Estimate of Human Performance on the GLUE Benchmark - ACL Anthology, https://aclanthology.org/P19-1449.pdf</li>
<li>Improving the Language Understanding Capabilities of Large Language Models Using Reinforcement Learning - arXiv, https://arxiv.org/html/2410.11020v3</li>
<li>arXiv:1810.04805v2 [cs.CL] 24 May 2019, https://arxiv.org/pdf/1810.04805</li>
<li>12월 19, 2025에 액세스, [https://www.coursera.org/articles/bert-vs-gpt#:<sub>:text=GPT%20is%20unidirectional%2C%20which%20means,way%20since%20its%20early%20development.](https://www.coursera.org/articles/bert-vs-gpt#:</sub>:text=GPT is unidirectional%2C which means, <a href="https://www.coursera.org/articles/bert-vs-gpt#:~:text=GPT%20is%20unidirectional%2C%20which%20means,way%20since%20its%20early%20development.">https://www.coursera.org/articles/bert-vs-gpt#:~:text=GPT%20is%20unidirectional%2C%20which%20means,way%20since%20its%20early%20development.</a></li>
<li>Exploring the Limitations of BERT LLM: What Can It Not Do?, https://botpenguin.com/blogs/limitations-of-bert-llm</li>
<li>Addressing the Training-Inference Discrepancy in Discrete Diffusion for Text Generation - ACL Anthology, https://aclanthology.org/2025.coling-main.477.pdf</li>
<li>Limitations of Transformers on Clinical Text Classification - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC8387496/</li>
<li>HyPe: Better Pre-trained Language Model Fine-tuning with Hidden Representation Perturbation - ACL Anthology, https://aclanthology.org/2023.acl-long.182.pdf</li>
<li>GLUE Explained: Understanding BERT Through Benchmarks - Chris McCormick, https://mccormickml.com/2019/11/05/GLUE/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>