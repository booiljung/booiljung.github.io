<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.2 인코더-디코더(Encoder-Decoder) 구조의 완벽한 이해</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.2 인코더-디코더(Encoder-Decoder) 구조의 완벽한 이해</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>2.2 인코더-디코더(Encoder-Decoder) 구조의 완벽한 이해</span></nav>
                </div>
            </header>
            <article>
                <h1>2.2 인코더-디코더(Encoder-Decoder) 구조의 완벽한 이해</h1>
<p>2025-12-18, G30DR</p>
<h2>1.  시퀀스 모델링의 패러다임 변화와 아키텍처의 철학적 기원</h2>
<p>트랜스포머(Transformer) 아키텍처의 등장은 자연어 처리(NLP)를 넘어 인공지능 전반의 시퀀스 모델링 방식을 근본적으로 재정의했다. 2017년 “Attention Is All You Need” 논문을 통해 제시된 이 구조는 기존의 순환 신경망(RNN)이나 컨볼루션 신경망(CNN)이 가졌던 한계를 극복하기 위해 설계되었다.1 특히 인코더-디코더(Encoder-Decoder) 구조는 기계 번역과 같은 시퀀스-투-시퀀스(Seq2Seq) 작업의 핵심적인 틀을 유지하면서도, 그 내부 작동 원리를 완전히 어텐션(Attention) 메커니즘으로 대체함으로써 계산의 효율성과 정보의 표현력을 극대화하였다.1</p>
<p>기존의 RNN 기반 모델들은 데이터를 순차적으로 처리해야 했기에 긴 문장에서 발생하는 정보 소실(Vanishing Gradient)과 정보 병목(Information Bottleneck) 현상을 피하기 어려웠다.4 인코더가 전체 입력 문장을 하나의 고정된 크기의 컨텍스트 벡터(Context Vector)로 압축해야 하는 구조적 제약은 모델이 복잡한 문맥적 관계를 학습하는 데 큰 걸림돌이 되었다.4 트랜스포머의 인코더-디코더 구조는 이러한 정적인 정보 압축 방식을 버리고, 디코더가 생성의 매 순간 인코더가 생성한 모든 토큰의 표상을 직접 참조할 수 있는 동적인 체계를 구축하였다.4</p>
<p>인코더는 입력 시퀀스를 추상적인 중간 표상으로 변환하는 역할을 수행하며, 디코더는 이 표상을 바탕으로 타겟 시퀀스를 한 토큰씩 생성하는 역할을 담당한다.1 이 두 구성 요소는 독립적인 층(Layer)의 스택으로 이루어져 있으며, 크로스 어텐션(Cross-Attention)이라는 정교한 메커니즘을 통해 서로 소통한다.6 이러한 이분법적 설계는 모델이 ’입력의 이해’와 ’출력의 생성’이라는 두 가지 본질적인 과정을 각각 전문화된 하위 네트워크에서 처리할 수 있게 함으로써 성능을 비약적으로 향상시켰다.9</p>
<pre><code class="language-mermaid">mindmap
  root((시퀀스 모델링의 진화))
    (기존 RNN 기반 접근)
      (순차적 처리)
      (정보 병목 현상)
        (고정 크기 컨텍스트 벡터)
        (긴 문장에서 정보 소실)
    (트랜스포머 인코더-디코더)
      (병렬 처리 가능)
      (동적 컨텍스트 참조)
        (모든 토큰의 표상 참조)
        (어텐션 메커니즘)
      (역할의 분리)
        (인코더: 입력 이해 및 추상화)
        (디코더: 출력 생성 및 인과성)
</code></pre>
<h2>2.  인코더(Encoder): 입력 정보의 전역적 맥락화</h2>
<pre><code class="language-mermaid">graph TD
    Input["입력 시퀀스 (Input Sequence)"] --&gt; Emb["입력 임베딩 + 위치 인코딩"]
    
    subgraph "인코더 레이어 (N=6 Stack)"
        direction TB
        Emb --&gt; Split["복제 (Residual Connection용)"]
        Split --&gt; QKV["Q, K, V 벡터 투영"]
        QKV --&gt; SA["멀티 헤드 셀프 어텐션 (Multi-Head Self-Attention)"]
        SA --&gt; Concat["헤드 결합 및 선형 변환"]
        
        Concat --&gt; AddNorm1["잔차 연결 + 층 정규화 (Add &amp; Norm)"]
        Split --&gt; AddNorm1
        
        AddNorm1 --&gt; Split2["복제 (Residual Connection용)"]
        Split2 --&gt; FFN["위치별 피드포워드 네트워크 (Position-wise FFN)"]
        FFN --&gt; AddNorm2["잔차 연결 + 층 정규화 (Add &amp; Norm)"]
        Split2 --&gt; AddNorm2
    end
    
    AddNorm2 --&gt; Output["인코더 출력 (Key, Value for Decoder)"]
    
    style Input fill:#f9f,stroke:#333,stroke-width:2px
    style Output fill:#bbf,stroke:#333,stroke-width:2px
    style SA fill:#dfd,stroke:#333
    style FFN fill:#fdd,stroke:#333
</code></pre>
<h3>2.1  인코더 스택의 구조적 설계</h3>
<p>트랜스포머의 인코더는 동일한 구조를 가진 <span class="math math-inline">N</span>개의 층이 수직으로 쌓인 형태를 띤다. 표준적인 아키텍처에서는 <span class="math math-inline">N=6</span>을 사용하며, 각 층은 입력받은 데이터를 점진적으로 더 높은 수준의 추상적 표현으로 변환한다.7 인코더의 각 층은 두 개의 주요 서브 레이어로 구성된다. 첫 번째는 멀티 헤드 셀프 어텐션(Multi-head Self-Attention) 층이며, 두 번째는 위치별 완전 연결 피드포워드 네트워크(Position-wise Feed-Forward Network)이다.7</p>
<p>이 모든 과정은 잔차 연결(Residual Connection)과 층 정규화(Layer Normalization)를 통해 보호받는다.7 잔차 연결은 하위 층의 정보를 상위 층으로 직접 전달함으로써 깊은 신경망에서도 그래디언트가 원활하게 흐르도록 돕고, 층 정규화는 학습 과정의 안정성을 보장한다.13 데이터가 인코더 스택을 통과함에 따라, 각 단어의 초기 임베딩은 주변 단어들과의 관계가 반영된 ’문맥화된 벡터’로 거듭나게 된다.1</p>
<h3>2.2  셀프 어텐션과 입력 정보의 재구성</h3>
<p>인코더 내부의 셀프 어텐션 메커니즘은 문장 내의 각 토큰이 다른 모든 토큰과의 상관관계를 계산하여 자신의 표현을 갱신하는 과정이다.11 이를 위해 각 입력 벡터는 세 가지 다른 역할을 수행하는 쿼리(Query), 키(Key), 밸류(Value) 벡터로 투영된다.2 쿼리는 정보를 찾는 주체이며, 키는 정보가 가진 특징을 나타내고, 밸류는 실제 담고 있는 의미 정보를 의미한다.13</p>
<p>어텐션 연산은 쿼리와 키의 내적을 통해 유사도를 구하고, 이를 키의 차원 <span class="math math-inline">\sqrt{d_k}</span>로 나누어 스케일링한 후 소프트맥스(Softmax) 함수를 적용하여 가중치를 도출한다.2 이 가중치를 밸류 벡터에 곱해 합산함으로써, 현재 토큰과 가장 관련이 깊은 단어들의 정보가 강조된 새로운 벡터가 생성된다.13 인코더는 이 과정을 멀티 헤드로 병렬 처리함으로써 문법적 관계, 의미적 연관성, 위치적 정보 등 다양한 측면의 문맥을 동시에 포착한다.2</p>
<table><thead><tr><th><strong>인코더 구성 요소</strong></th><th><strong>주요 역할 및 특징</strong></th><th><strong>수학적 핵심 원리</strong></th></tr></thead><tbody>
<tr><td>멀티 헤드 셀프 어텐션</td><td>입력 시퀀스 내의 전역적 의존성 학습</td><td><span class="math math-inline">QK^T</span> 내적 연산 및 소프트맥스 2</td></tr>
<tr><td>피드포워드 네트워크</td><td>각 토큰 위치에서의 비선형 특징 추출</td><td><span class="math math-inline">\max(0, xW_1 + b_1)W_2 + b_2</span> 7</td></tr>
<tr><td>잔차 연결</td><td>깊은 네트워크의 학습 안정성 및 정보 보존</td><td><span class="math math-inline">x + \text{Sublayer}(x)</span> 7</td></tr>
<tr><td>층 정규화</td><td>그래디언트 소실/폭주 방지 및 수렴 속도 향상</td><td>특징 값의 평균 및 분산 정규화 13</td></tr>
</tbody></table>
<h3>2.3  인코더의 출력과 정보 전송</h3>
<p>인코더 스택의 마지막 층에서 나오는 출력은 입력 시퀀스와 동일한 길이를 가진 벡터 시퀀스이다. 이 벡터들은 단순한 단어의 의미를 넘어, 문장 전체의 구조 속에서 해당 단어가 가지는 역할과 의미를 함축하고 있다.1 이 출력 행렬은 디코더의 모든 층으로 전달되어 크로스 어텐션의 키(Key)와 밸류(Value)로 활용된다.6 즉, 인코더는 원시 데이터를 디코더가 이해하기 쉬운 형태의 ’지식 기반’으로 가공하여 전송하는 시스템이라고 할 수 있다.1</p>
<h2>3.  디코더(Decoder): 자기회귀적 생성과 인과관계</h2>
<pre><code class="language-mermaid">graph TD
    DecInput["디코더 입력 (Shifted Right)"] --&gt; DecEmb["출력 임베딩 + 위치 인코딩"]
    EncOut["인코더 출력 행렬 (Memory)"]
    
    subgraph "디코더 레이어 (N=6)"
        direction TB
        
        DecEmb --&gt; MaskedSA["1: 마스크드 멀티 헤드 셀프 어텐션&lt;br/&gt;(Masked Self-Attention)&lt;br/&gt;'미래 정보 차단'"]
        MaskedSA --&gt; AddNormD1["Add &amp; Norm"]
        
        AddNormD1 --&gt; Query["쿼리(Query) 생성"]
        EncOut -.-&gt; KeyVal["키(Key) &amp; 밸류(Value) 제공"]
        
        Query &amp; KeyVal --&gt; CrossAttn["2: 인코더-디코더 크로스 어텐션&lt;br/&gt;(Cross-Attention)&lt;br/&gt;'정보의 정렬 및 융합'"]
        CrossAttn --&gt; AddNormD2["Add &amp; Norm"]
        
        AddNormD2 --&gt; FFN_D["3: 피드포워드 네트워크&lt;br/&gt;(FFN)"]
        FFN_D --&gt; AddNormD3["Add &amp; Norm"]
    end
    
    AddNormD3 --&gt; Linear["선형 레이어 (Linear)"]
    Linear --&gt; Softmax["소프트맥스 (Softmax)"]
    Softmax --&gt; Result["다음 토큰 확률 분포"]

    style EncOut fill:#bbf,stroke:#333,stroke-width:4px
    style CrossAttn fill:#ff9,stroke:#f66,stroke-width:2px
    style MaskedSA fill:#eee,stroke:#333
</code></pre>
<h3>3.1  디코더의 3단계 구조</h3>
<p>디코더 역시 <span class="math math-inline">N=6</span>개의 층으로 구성되지만, 인코더와는 달리 각 층에 세 개의 서브 레이어가 존재한다.7 첫 번째는 마스크드 멀티 헤드 셀프 어텐션(Masked Multi-head Self-Attention), 두 번째는 인코더-디코더 크로스 어텐션(Encoder-Decoder Cross-Attention), 세 번째는 위치별 피드포워드 네트워크이다.7</p>
<p>디코더의 본질적인 임무는 이전에 생성한 토큰들을 바탕으로 다음 토큰을 예측하는 것이다.1 이를 위해 디코더는 자기회귀(Auto-regressive) 방식을 따르며, 학습 단계에서는 티처 포싱(Teacher Forcing)이라는 기법을 통해 효율적으로 훈련된다.14 인코더가 입력 문장을 병렬적으로 처리하는 것과 달리, 디코더는 생성 시점마다 이전의 출력물들을 입력으로 다시 받아들이며 시퀀스를 확장해 나간다.1</p>
<h3>3.2  마스킹(Masking)과 인과율의 보존</h3>
<p>디코더의 첫 번째 서브 레이어인 마스크드 셀프 어텐션은 미래의 정보를 참조하지 못하게 막는 특수한 장치를 포함한다.7 학습 시에는 정답 문장이 한꺼번에 입력되는데, 만약 모델이 현재 위치 이후의 단어들을 볼 수 있다면 학습은 매우 쉬워지지만 실제 추론 시에는 성능을 발휘하지 못하게 된다.22</p>
<p>이를 방지하기 위해 어텐션 스코어 행렬의 상삼각형 부분(Upper Triangle)을 <span class="math math-inline">-\infty</span>로 채워 소프트맥스 결과값이 0이 되도록 만든다.7 이 과정을 통해 디코더는 특정 시점 <span class="math math-inline">t</span>에서 오직 <span class="math math-inline">1</span>부터 <span class="math math-inline">t</span>까지의 단어들만을 사용하여 연산을 수행하게 되며, 이는 모델이 시간에 따른 인과관계(Causality)를 학습하도록 강제한다.16</p>
<h3>3.3  출력 생성과 확률 분포 도출</h3>
<p>디코더 스택의 최상단 출력은 선형 레이어(Linear Layer)와 소프트맥스 레이어를 통과하며 최종적인 예측으로 변환된다.13 선형 레이어는 모델의 내부 벡터를 전체 어휘 사전의 크기에 맞는 로짓(Logits) 벡터로 투영한다.13 이후 소프트맥스 함수는 이 로짓을 확률 분포로 바꾸어, 어떤 단어가 다음에 올 확률이 가장 높은지를 결정하게 한다.14 추론 과정에서는 가장 높은 확률을 가진 단어를 선택하거나 빔 서치(Beam Search)와 같은 전략을 사용하여 최적의 문장을 구성한다.1</p>
<h2>4.  크로스 어텐션(Cross-Attention): 두 세계를 잇는 교량</h2>
<h3>4.1  정보의 정렬과 융합 메커니즘</h3>
<p>크로스 어텐션은 인코더-디코더 구조의 정수(Essence)이자 두 구성 요소가 정보를 교환하는 유일한 창구이다.6 이 층에서 디코더는 자신이 현재 생성 중인 문맥(Query)과 인코더가 제공하는 원문 정보(Key, Value) 사이의 관계를 계산한다.6</p>
<p>여기서 쿼리는 디코더의 하위 층에서 올라온 출력값이며, 키와 밸류는 인코더 스택의 마지막 층에서 전달된 출력값이다.8 디코더는 이 쿼리를 통해 인코더에게 “지금 내가 번역할 단어와 가장 관련 있는 원문의 단어는 무엇인가?“라고 묻는 것과 같다.6 인코더의 키 벡터들은 이 질문에 답하기 위한 지표 역할을 하며, 일치도가 높은 부분의 밸류 벡터들이 디코더로 흡수되어 다음 단어 생성의 근거가 된다.6</p>
<h3>4.2  차원 정합성과 멀티 헤드 정렬</h3>
<p>크로스 어텐션이 효과적으로 작동하기 위해서는 인코더와 디코더 사이의 벡터 차원 매핑이 정교하게 설계되어야 한다. 트랜스포머는 모델의 전체 차원인 <span class="math math-inline">d_{model}</span>을 각 헤드로 균등하게 나누어 처리한다.8</p>
<table><thead><tr><th><strong>파라미터 유형</strong></th><th><strong>변수 기호</strong></th><th><strong>표준 설정값</strong></th><th><strong>관련 설명</strong></th></tr></thead><tbody>
<tr><td>모델 임베딩 차원</td><td><span class="math math-inline">d_{model}</span></td><td>512</td><td>인코더와 디코더의 모든 벡터 차원 8</td></tr>
<tr><td>멀티 헤드 수</td><td><span class="math math-inline">h</span></td><td>8</td><td>병렬로 수행되는 어텐션 연산의 개수 8</td></tr>
<tr><td>개별 헤드 차원</td><td><span class="math math-inline">d_k, d_v</span></td><td>64</td><td>각 헤드에서 쿼리, 키, 밸류가 가지는 차원 8</td></tr>
<tr><td>순방향 신경망 차원</td><td><span class="math math-inline">d_{ff}</span></td><td>2048</td><td>FFN 내부의 은닉층 차원 7</td></tr>
</tbody></table>
<p>이러한 구조 덕분에 디코더는 원문의 복잡한 문맥을 여러 관점에서 동시에 바라볼 수 있다. 어떤 헤드는 주어와 동사의 관계를 맞추는 데 집중하고, 다른 헤드는 목적어나 수식어구의 정렬을 담당함으로써 정확한 정보 전이가 가능해진다.2</p>
<h2>5.  수학적 기반: 어텐션 연산의 기하학적 의미</h2>
<pre><code class="language-mermaid">graph TD
    Q["Query (Q)"]
    K["Key (K)"]
    V["Value (V)"]
    
    Q &amp; K --&gt; MatMul1["내적 연산 (MatMul)&lt;br/&gt;Q * K^T"]
    MatMul1 --&gt; Scale["스케일링 (Scale)&lt;br/&gt;Divide by sqrt(d_k)"]
    Scale --&gt; Mask["마스킹 (Masking)&lt;br/&gt;(디코더의 경우 적용)"]
    Mask --&gt; Softmax["소프트맥스 (Softmax)&lt;br/&gt;확률 분포 변환"]
    Softmax --&gt; Weights["어텐션 가중치 (Attention Weights)"]
    
    Weights &amp; V --&gt; MatMul2["가중 합 연산 (MatMul)&lt;br/&gt;Weights * V"]
    MatMul2 --&gt; Final["어텐션 출력값 (Context Vector)"]

    style MatMul1 fill:#e1f5fe,stroke:#01579b
    style Softmax fill:#fff9c4,stroke:#fbc02d
    style Final fill:#e8f5e9,stroke:#2e7d32
</code></pre>
<h3>5.1  스케일드 닷 프로덕트 어텐션(Scaled Dot-product Attention)</h3>
<p>트랜스포머의 어텐션은 두 벡터의 내적(Dot-product)을 기본으로 한다. 수학적으로 내적은 두 벡터 사이의 유사도를 측정하는 가장 효율적인 방법 중 하나이다.18 그러나 벡터의 차원이 커질수록 내적의 결과값이 극단적으로 커질 수 있으며, 이는 소프트맥스 함수의 그래디언트를 매우 작게 만들어 학습을 방해한다.7</p>
<p>이를 방지하기 위해 트랜스포머는 <span class="math math-inline">\sqrt{d_k}</span>로 나누는 스케일링 과정을 도입하였다.2</p>
<p><span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
이 수식은 인코더-디코더 구조 전반에서 정보를 필터링하고 가중치를 부여하는 핵심 원리이다. 기하학적으로 이는 쿼리 벡터가 키 벡터들이 형성하는 공간에서 어디에 위치하는지를 찾고, 그 위치에 상응하는 밸류 벡터들의 가중 합으로 새로운 지점을 정의하는 과정이다.27</p>
<h3>5.2  크로스 어텐션의 복잡도 분석</h3>
<p>인코더와 디코더가 상호작용할 때 발생하는 연산 복잡도는 시퀀스 길이의 제곱(<span class="math math-inline">O(n^2)</span>)에 비례한다.6 인코더의 입력 길이를 <span class="math math-inline">n</span>, 디코더의 출력 길이를 <span class="math math-inline">m</span>이라 할 때, 크로스 어텐션 행렬의 크기는 <span class="math math-inline">n \times m</span>이 된다.6 이는 매우 긴 문서를 처리하거나 고해상도 이미지를 다룰 때 메모리와 계산 자원에 큰 부담을 주는 요인이 된다.6 그럼에도 불구하고 이 구조가 선호되는 이유는 시퀀스 내의 모든 요소가 단 한 번의 연산으로 직접 연결될 수 있는 ’전역적 가독성’을 제공하기 때문이다.2</p>
<h2>6.  학습과 추론의 이중성: 병렬성과 순차성</h2>
<pre><code class="language-mermaid">graph LR
    subgraph "학습 단계 (Training Phase)"
        Truth["정답 시퀀스 전체 입력"] --&gt; Encoder_T["인코더"]
        Truth --&gt; Decoder_T["디코더 (With Masking)"]
        Encoder_T --&gt; Cross_T["크로스 어텐션"]
        Decoder_T --&gt; Cross_T
        Cross_T --&gt; Pred_T["모든 시점 동시 예측"]
        Pred_T --&gt; Loss["손실 계산 (Parallel)"]
    end

    subgraph "추론 단계 (Inference Phase)"
        Start["시작 토큰 &lt;SOS&gt;"] --&gt; LoopStart
        Input_I["입력 문장"] --&gt; Encoder_I["인코더 (1회 실행)"]
        Encoder_I --&gt; Memory["Key/Value 메모리 고정"]
        
        LoopStart{{"반복 생성 루프"}}
        Memory --&gt; Cross_I["크로스 어텐션"]
        Start --&gt; Decoder_I["디코더 (이전 토큰들)"]
        Decoder_I --&gt; Cross_I
        Cross_I --&gt; NextToken["다음 토큰 예측"]
        NextToken --&gt; LoopStart
        NextToken -.-&gt; End["&lt;EOS&gt; 발생 시 종료"]
    end

    style Truth fill:#ffccbc,stroke:#d84315
    style Loss fill:#ffccbc,stroke:#d84315
    style NextToken fill:#c8e6c9,stroke:#2e7d32
</code></pre>
<h3>6.1  티처 포싱(Teacher Forcing)을 통한 병렬 학습</h3>
<p>트랜스포머 인코더-디코더의 가장 큰 강점 중 하나는 학습 시의 압도적인 속도이다.2 RNN 기반 모델은 <span class="math math-inline">t</span> 시점의 결과를 계산하기 위해 <span class="math math-inline">t-1</span> 시점의 결과가 반드시 필요했으나, 트랜스포머는 마스킹 기법과 티처 포싱을 결합하여 모든 시점의 손실을 동시에 계산할 수 있다.14</p>
<p>학습 과정에서 디코더는 실제 정답(Ground Truth) 시퀀스를 입력으로 받으며, 각 위치에서 모델이 예측한 값과 정답 사이의 교차 엔트로피(Cross-Entropy) 손실을 측정한다.14 이 과정은 이전 단계의 오류가 다음 단계로 전이되지 않도록 방지하여 학습 초기 단계를 가속화하고 수렴을 돕는다.14</p>
<h3>6.2  추론(Inference) 단계의 자기회귀성</h3>
<p>추론 단계에서는 정답 문장을 알 수 없으므로, 모델은 다시 순차적인 생성 모드로 전환된다.14 인코더는 입력 시퀀스를 한 번만 처리하여 고정된 키와 밸류 행렬을 생성하고, 디코더는 이를 반복적으로 참조하며 토큰을 하나씩 만들어낸다.9</p>
<ol>
<li>디코더 입력에 <code>&lt;SOS&gt;</code>(시작 토큰)을 넣는다.14</li>
<li>인코더의 출력과 현재까지 생성된 토큰들을 바탕으로 다음 토큰의 확률 분포를 계산한다.1</li>
<li>예측된 토큰을 시퀀스 끝에 추가하고 다시 입력으로 사용한다.1</li>
<li><code>&lt;EOS&gt;</code>(종료 토큰)이 생성될 때까지 이 과정을 반복한다.1</li>
</ol>
<p>이 단계에서 모델의 성능을 극대화하기 위해 그리디 디코딩(Greedy Decoding) 대신 빔 서치(Beam Search)와 같은 알고리즘이 적용된다.24 빔 서치는 여러 개의 유망한 문장 후보군을 동시에 유지하며 전체적인 시퀀스 확률이 가장 높은 경로를 선택함으로써 더 자연스러운 문장을 생성하게 한다.24</p>
<h2>7.  정보 병목 현상의 해결과 아키텍처의 의의</h2>
<pre><code class="language-mermaid">graph LR
    Core["인코더-디코더 아키텍처"]
    
    Core --&gt; EncoderRole["인코더의 역할"]
    EncoderRole --&gt; Understanding["입력의 깊은 이해"]
    EncoderRole --&gt; NonCausal["비인과적 (전체 문맥 참조)"]
    EncoderRole --&gt; Abstract["추상적 지식 베이스 생성"]
    
    Core --&gt; DecoderRole["디코더의 역할"]
    DecoderRole --&gt; Generation["논리적 출력 생성"]
    DecoderRole --&gt; Causal["인과적 (과거 정보만 참조)"]
    DecoderRole --&gt; CondProb["조건부 확률 모델링"]
    
    Core --&gt; Future["미래 및 확장"]
    Future --&gt; MultiModal["멀티모달 (영상-&gt;텍스트 등)"]
    Future --&gt; Optimization["선형 어텐션 등 효율화"]
    Future --&gt; LLM["현대 LLM의 기술적 근간"]

    style Core fill:#333,stroke:#fff,color:#fff
    style EncoderRole fill:#e3f2fd,stroke:#1565c0
    style DecoderRole fill:#f3e5f5,stroke:#7b1fa2
</code></pre>
<h3>7.1  고정 크기 벡터의 한계 극복</h3>
<p>과거 RNN 기반 Seq2Seq 모델의 가장 큰 약점은 인코더가 모든 정보를 하나의 컨텍스트 벡터로 압축해야 한다는 점이었다.4 이는 정보 손실을 야기하고 긴 문장의 앞부분 정보를 잊게 만드는 주된 원인이었다.4 트랜스포머의 인코더-디코더 구조는 인코더의 모든 은닉 상태를 메모리 형태로 보존하고, 디코더가 필요한 시점에 필요한 만큼 접근할 수 있도록 설계됨으로써 이 문제를 근본적으로 해결하였다.4</p>
<h3>7.2  이해와 생성의 전문화</h3>
<p>인코더는 비인과적(Non-causal) 방식으로 전체 문맥을 자유롭게 훑으며 고도의 추상적 표상을 만드는 데 최적화되어 있고, 디코더는 인과적(Causal) 제약 하에서 논리적인 시퀀스를 생성하는 데 최적화되어 있다.5 이러한 역할의 분담은 모델이 복잡한 추론이나 정교한 문체 변화를 요구하는 작업에서도 일관성을 유지할 수 있게 한다.9</p>
<table><thead><tr><th><strong>모델 유형</strong></th><th><strong>인코더 특징</strong></th><th><strong>디코더 특징</strong></th><th><strong>주요 장점</strong></th></tr></thead><tbody>
<tr><td><strong>인코더-디코더</strong></td><td>양방향 문맥 학습, 비인과적</td><td>자기회귀 생성, 크로스 어텐션 사용</td><td>번역, 요약 등 복잡한 변환에 강함 5</td></tr>
<tr><td><strong>디코더 전용</strong></td><td>(없음)</td><td>모든 문맥 학습, 마스크드 셀프 어텐션</td><td>제로샷 생성, 학습 효율성 높음 5</td></tr>
<tr><td><strong>인코더 전용</strong></td><td>양방향 문맥 학습</td><td>(없음)</td><td>분류, 개체명 인식 등 이해 작업 특화 5</td></tr>
</tbody></table>
<h2>8.  결론 및 향후 전망</h2>
<p>트랜스포머의 인코더-디코더 구조는 정보의 압축이 아닌 ’관계의 보존’을 선택함으로써 시퀀스 모델링의 새로운 표준을 세웠다.1 크로스 어텐션이라는 혁신적인 인터페이스는 인코더의 정적인 지식과 디코더의 동적인 생성을 완벽하게 결합하였으며, 이는 현대 AI가 인간의 언어를 번역하고 요약하며 대화하는 기술적 근간이 되었다.6</p>
<p>물론 <span class="math math-inline">O(n^2)</span>의 연산 복잡도와 추론 시의 자기회귀적 지연 시간이라는 숙제가 남아있으나, 이를 해결하기 위한 선형 어텐션이나 투기적 디코딩 등의 기술들이 이 구조를 바탕으로 발전하고 있다.28 인코더와 디코더의 분리된 설계는 향후 멀티모달(Multimodal) 학습에서도 영상 인코더와 텍스트 디코더를 결합하는 등 무한한 확장성을 제공할 것으로 기대된다.6 결국 이 구조를 완벽하게 이해하는 것은 단순한 모델 분석을 넘어, 데이터들 사이의 복잡한 연결 고리를 지능적으로 포착해내는 현대 인공지능의 사고방식을 이해하는 것과 같다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>How Transformers Work: A Detailed Exploration of Transformer Architecture - DataCamp, https://www.datacamp.com/tutorial/how-transformers-work</li>
<li>Attention Is All You Need - Wikipedia, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need</li>
<li>Transformer (deep learning) - Wikipedia, https://en.wikipedia.org/wiki/Transformer_(deep_learning)</li>
<li>The Attention Mechanism: Understand the in depth architecture | by …, https://medium.com/@robin5002234/the-attention-mechanism-understand-the-in-depth-architecture-90b4bb849635</li>
<li>Step-by-Step with Transformers: From Seq2Seq Bottlenecks to Cutting-Edge Attention Mechanisms in NLP - Arbisoft, https://arbisoft.com/blogs/step-by-step-with-transformers-from-seq2-seq-bottlenecks-to-cutting-edge-attention-mechanisms-in-nlp</li>
<li>Cross-Attention Mechanism in Transformers - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/cross-attention-mechanism-in-transformers/</li>
<li>Attention Is All You Need : A Complete Guide to Transformers - Medium, https://medium.com/@alejandro.itoaramendia/attention-is-all-you-need-a-complete-guide-to-transformers-8670a3f09d02</li>
<li>Cross-Attention: Bridging Different Modalities | ML &amp; CV Consultant …, https://www.abhik.xyz/concepts/attention/cross-attention</li>
<li>Return of the Encoder: Maximizing Parameter Efficiency for SLMs - arXiv, https://arxiv.org/html/2501.16273v1</li>
<li>Architecture and Working of Transformers in Deep Learning - GeeksforGeeks, https://www.geeksforgeeks.org/deep-learning/architecture-and-working-of-transformers-in-deep-learning/</li>
<li>Attention is all you need: Discovering the Transformer paper | Towards Data Science, https://towardsdatascience.com/attention-is-all-you-need-discovering-the-transformer-paper-73e5ff5e0634/</li>
<li>Transformer Encoder–Decoder Architecture - Emergent Mind, https://www.emergentmind.com/topics/transformer-encoder-decoder-architecture</li>
<li>Transformer Architecture Explained With Self-Attention Mechanism - Codecademy, https://www.codecademy.com/article/transformer-architecture-self-attention-mechanism</li>
<li>Transformers Explained Visually (Part 1): Overview of Functionality - Towards Data Science, https://towardsdatascience.com/transformers-explained-visually-part-1-overview-of-functionality-95a6dd460452/</li>
<li>Attention Is All You Need — Understanding the Transformer Model | by Okan Yenigün, https://levelup.gitconnected.com/attention-is-all-you-need-understanding-the-transformer-model-10519074916f</li>
<li>Multi-Head Attention Mechanism - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/multi-head-attention-mechanism/</li>
<li>What are the Different Types of Attention Mechanisms? - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2024/01/different-types-of-attention-mechanisms/</li>
<li>Stefan’s Blog - Understanding Transformers and Attention, https://stefanbschneider.github.io/blog/posts/understanding-transformers-attention/</li>
<li>Transformers Explained Visually (Part 3): Multi-head Attention, deep dive, https://towardsdatascience.com/transformers-explained-visually-part-3-multi-head-attention-deep-dive-1c1ff1024853/</li>
<li>Masked Multi Head Attention in Transformer | by Sachin Soni - Medium, https://medium.com/@sachinsoni600517/masked-multi-head-attention-in-transformer-f3e096d56961</li>
<li>Explain Self-Attention, and Masked Self-Attention as used in Transformers - AIML.com, https://aiml.com/explain-self-attention-and-masked-self-attention-as-used-in-transformers/</li>
<li>How to understand masked multi-head attention in transformer [closed] - Stack Overflow, https://stackoverflow.com/questions/58127059/how-to-understand-masked-multi-head-attention-in-transformer</li>
<li>In the Transformer model, how is the decoder trained and how is the inference run on the decoder, exactly? : r/MLQuestions - Reddit, https://www.reddit.com/r/MLQuestions/comments/12qkbwa/in_the_transformer_model_how_is_the_decoder/</li>
<li>Transformers: a Primer, http://www.columbia.edu/~jsl2239/transformers.html</li>
<li>Cross Attention in Transformer - by Sachin Soni - Medium, https://medium.com/@sachinsoni600517/cross-attention-in-transformer-f37ce7129d78</li>
<li>Some Intuition on Attention and the Transformer - Eugene Yan, https://eugeneyan.com/writing/attention/</li>
<li>Geometric Transform Attention (GTA) - ICLR 2024 - Takeru Miyato, https://takerum.github.io/gta/</li>
<li>Geometry Meets Attention: Interpretable Transformers via SVD Inspiration - IEEE Xplore, https://ieeexplore.ieee.org/iel8/6287639/6514899/11072340.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>