<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.1 T5 - 모든 텍스트 문제는 텍스트 생성 문제다</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.1 T5 - 모든 텍스트 문제는 텍스트 생성 문제다</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>5.1 T5 - 모든 텍스트 문제는 텍스트 생성 문제다</span></nav>
                </div>
            </header>
            <article>
                <h1>5.1 T5 - 모든 텍스트 문제는 텍스트 생성 문제다</h1>
<p>2025-12-20, G30DR</p>
<h2>1.  서론: 자연어 처리의 통합된 패러다임</h2>
<p>2010년대 후반, 자연어 처리(NLP) 분야는 딥러닝 기반의 전이 학습(Transfer Learning)이 주도하는 급격한 변화의 시기를 겪었다. 특히 2018년 구글의 BERT(Bidirectional Encoder Representations from Transformers)와 OpenAI의 GPT(Generative Pre-trained Transformer) 시리즈의 등장은 NLP 모델링의 표준을 ’사전 학습(Pre-training)’과 ’미세 조정(Fine-tuning)’이라는 2단계 파이프라인으로 재정립했다. 그러나 이러한 성과에도 불구하고, 당시의 NLP 생태계는 과업(Task)의 성격에 따라 모델 구조와 학습 방식이 파편화되어 있었다. 이해(Understanding)가 필요한 분류나 질의응답 과업에는 인코더 기반의 BERT가, 생성(Generation)이 필요한 번역이나 요약 과업에는 시퀀스-투-시퀀스(Seq2Seq) 구조나 디코더 기반의 모델이 각각 별도로 적용되는 것이 일반적이었다.1</p>
<p>이러한 맥락에서 2020년 콜린 라펠(Colin Raffel) 등이 발표한 T5(Text-to-Text Transfer Transformer)는 기존의 파편화된 접근 방식을 근본적으로 뒤집는 새로운 패러다임을 제시했다. T5의 핵심 철학은 “모든 자연어 처리 문제는 텍스트를 입력으로 받아 텍스트를 출력하는 문제로 치환될 수 있다“는 것이다. 이는 기계 번역이나 요약과 같은 전형적인 생성 문제뿐만 아니라, 분류(Classification), 회귀(Regression), 개체명 인식(NER) 등 전통적으로 비생성(Non-generative) 과업으로 분류되던 문제들까지 모두 단일한 ‘텍스트-투-텍스트(Text-to-Text)’ 포맷으로 통일함을 의미한다.3</p>
<p>이러한 통합적 접근은 단순히 모델 구조를 단순화하는 것을 넘어, 단일 모델(Single Model)이 동일한 손실 함수(Loss Function)와 하이퍼파라미터(Hyperparameter)를 사용하여 사실상 모든 NLP 과업을 수행할 수 있게 하는 범용 인공지능(General Purpose AI)으로의 도약을 예고했다. 본 장에서는 T5가 제시한 이 혁신적인 프레임워크의 이론적 배경부터 모델 아키텍처, 데이터셋 구축, 그리고 실험적 검증 과정에 이르기까지 그 기술적 실체를 심층적으로 분석한다.</p>
<pre><code class="language-mermaid">flowchart TD
    subgraph "Pre-T5 Era: Fragmented Approach"
        direction TB
        A["Task: Understanding&lt;br&gt;(Classification/QA)"] --&gt; B["Model: Encoder-only&lt;br&gt;(e.g., BERT)"]
        C["Task: Generation&lt;br&gt;(Translation/Summary)"] --&gt; D["Model: Seq2Seq / Decoder-only&lt;br&gt;(e.g., GPT)"]
        B --&gt; E["Architecture Dependent&lt;br&gt;on Task"]
        D --&gt; E
    end

    subgraph "T5 Era: Unified Paradigm"
        direction TB
        F["Any NLP Task"] --&gt; G["Text-to-Text&lt;br&gt;Framework"]
        G --&gt; H["Single Model (Transformer&lt;br&gt;Encoder-Decoder)"]
        H --&gt; I["Same Loss Function &amp;&lt;br&gt;Hyperparameters"]
    end

    E -.-&gt;|"Paradigm Shift"| G
</code></pre>
<h2>2.  텍스트-투-텍스트(Text-to-Text) 프레임워크의 상세 구조</h2>
<p>T5의 가장 큰 기여는 모델의 입출력 인터페이스를 과업의 종류와 무관하게 ’텍스트 문자열’로 고정했다는 점이다. 기존의 BERT 모델은 감정 분석을 위해 토큰 위에 별도의 선형 분류기(Linear Classifier) 층을 추가해야 했으며, 개체명 인식을 위해서는 각 토큰 위치마다 분류 헤드를 부착해야 했다. 반면, T5는 모델의 구조적 변경 없이 입력 텍스트의 형태(Format)만을 변경하여 다양한 과업을 수행한다.</p>
<p><strong>Text-to-Text Transformation</strong></p>
<pre><code class="language-mermaid">flowchart TD
   
    subgraph "Inputs (with Prefix)"
        I1["'translate English to German:&lt;br&gt;That is good.'"]
        I2["'mnli premise:&lt;br&gt;I hate pigeons... hypothesis: ...'"]
        I3["'stsb sentence1:&lt;br&gt;The cat... sentence2: ...'"]
    end

    M(("T5 Model
    (Unified Architecture)"))

    subgraph "Outputs (Text String)"
        O1["'Das ist gut.'"]
        O2["'entailment'"]
        O3["'4.8' (String Representation)"]
    end

    I1 --&gt; M --&gt; O1
    I2 --&gt; M --&gt; O2
    I3 --&gt; M --&gt; O3

    style O3 stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5
    note["Note regarding STS-B: Regression value is treated as text string"]
    O3 --- note
</code></pre>
<h3>2.1  과업의 재정의와 프롬프트의 도입</h3>
<p>T5 프레임워크에서 모델은 입력된 텍스트가 어떤 과업을 요구하는지 식별해야 한다. 이를 위해 연구진은 입력 문장의 시작 부분에 자연어 형태의 ’접두사(Prefix)’를 추가하는 방식을 채택했다. 이는 현대 거대 언어 모델(LLM)에서 널리 사용되는 ’프롬프트 엔지니어링(Prompt Engineering)’과 ’지시 튜닝(Instruction Tuning)’의 원형(Archetype)이라 할 수 있다.5</p>
<table><thead><tr><th><strong>과업 유형 (Task Type)</strong></th><th><strong>기존 접근 방식 (Traditional Approach)</strong></th><th><strong>T5의 텍스트-투-텍스트 접근 (T5 Approach)</strong></th><th><strong>입력 예시 (Input Example)</strong></th><th><strong>출력 예시 (Target Output)</strong></th></tr></thead><tbody>
<tr><td><strong>기계 번역</strong></td><td>Source-Target Seq2Seq 모델</td><td>번역 지시 접두사 추가 후 생성</td><td>“translate English to German: That is good.”</td><td>“Das ist gut.”</td></tr>
<tr><td><strong>텍스트 분류</strong> (MNLI)</td><td>토큰 벡터를 Softmax 분류기에 입력</td><td>클래스 레이블(단어) 직접 생성</td><td>“mnli premise: I hate pigeons. hypothesis: My feelings towards pigeons are filled with animosity.”</td><td>“entailment”</td></tr>
<tr><td><strong>유사도 회귀</strong> (STS-B)</td><td>두 문장의 임베딩 코사인 유사도 또는 회귀 헤드 사용</td><td>점수를 0.2 단위로 양자화하여 문자열로 생성</td><td>“stsb sentence1: The cat is playing. sentence2: The kitten is playing.”</td><td>“4.8”</td></tr>
<tr><td><strong>문서 요약</strong></td><td>문단 추출 또는 별도 Seq2Seq 모델</td><td>요약 지시 접두사 추가 후 생성</td><td>“summarize: [Article Content]”</td><td>“”</td></tr>
<tr><td><strong>질의응답</strong> (SQuAD)</td><td>지문 내 정답의 시작/끝 인덱스 예측</td><td>정답 텍스트 직접 생성</td><td>“question: [Question] context: [Context]”</td><td>“”</td></tr>
</tbody></table>
<p><strong>표 5.1.1</strong> 다양한 NLP 과업의 텍스트-투-텍스트 변환 예시.7</p>
<p>위 표 5.1.1에서 볼 수 있듯이, T5는 모델의 출력 층을 과업별로 설계할 필요가 없다. 특히 주목할 점은 회귀 문제인 STS-B(Semantic Textual Similarity Benchmark)의 처리 방식이다. 일반적으로 회귀 문제는 실수(Real Number) 값을 예측하기 위해 마지막 레이어에 1차원 선형 출력을 사용하고 평균제곱오차(MSE) 등의 손실 함수를 사용한다. 그러나 T5는 1.0부터 5.0까지의 점수를 0.2 단위로 나누어 이를 “1.0”, “1.2”,…, “5.0“과 같은 문자열 클래스로 취급한다. 모델은 숫자 “4.8“을 수치가 아닌 하나의 단어(토큰 시퀀스)로 학습하고 생성한다. 추론 시에는 생성된 문자열을 파싱하여 다시 숫자로 변환한다.5 이는 언어 모델이 충분한 규모와 데이터를 가질 경우, 수리적 개념조차 텍스트 패턴 매칭의 일환으로 학습할 수 있음을 시사한다.</p>
<h3>2.2  분류 문제에서의 제약된 디코딩(Constrained Decoding)</h3>
<p>분류 문제(예: MNLI, 감정 분석)에서 모델이 정해진 레이블(예: “entailment”, “neutral”, “contradiction”) 이외의 텍스트(예: “potato”)를 생성할 가능성은 이론적으로 존재한다. 그러나 T5 연구진은 학습된 모델이 대부분의 경우 접두사에 맞는 올바른 레이블을 생성함을 확인했다. 만약 모델이 정해진 레이블 외의 텍스트를 생성할 경우 오답으로 처리된다.</p>
<p>추론 단계에서의 안정성을 높이기 위해, 전체 단어 집합(Vocabulary)에 대한 소프트맥스(Softmax) 확률을 계산하는 대신, 타겟 레이블에 해당하는 특정 토큰들의 로그 우도(Logits)만을 비교하는 방식을 사용할 수 있다. 예를 들어, “entailment“와 “contradiction“에 해당하는 토큰의 확률값만을 비교하여 더 높은 값을 선택하는 식이다. 이는 생성 모델을 분류기로 사용할 때의 정확도와 안정성을 보장하는 중요한 추론 기법이다.3</p>
<h2>3.  C4 데이터셋: 데이터 품질의 중요성 재조명</h2>
<p>T5 연구의 또 다른 핵심 축은 데이터셋이다. 연구진은 전이 학습의 한계를 탐구하기 위해 단순히 모델의 크기만을 키우는 것이 아니라, 학습 데이터의 품질과 양이 성능에 미치는 영향을 체계적으로 분석했다. 이를 위해 구축된 것이 C4(Colossal Clean Crawled Corpus) 데이터셋이다.</p>
<p><strong>C4 Dataset Cleaning Pipeline</strong></p>
<pre><code class="language-mermaid">flowchart TD

    Raw["Raw Common Crawl Data (Petabytes)"] --&gt; FilterStart{"Heuristic Filtering"}
    
    FilterStart --&gt; R1['Sentence Ending Punctuation Check']
    R1 --&gt;|'Remove lines without ., !, ?'| R2["Length Check"]
    R2 --&gt;|"Remove &lt; 5 sentences or &lt; 3 words lines"| R3["Blocklist Filtering"]
    R3 --&gt;|"Remove pages with obscene/bad words"| R4["Technical Clean-up"]
    R4 --&gt;|"Remove Javascript warnings, 'lorem ipsum', Code with '{'"| R5["Language Detection"]
    R5 --&gt;|"Keep only English (Prob &gt; 0.99)"| R6["Deduplication"]
    R6 --&gt;|"Remove duplicate spans &gt; 3 sentences"| Clean["C4 Dataset (High Quality, 750GB)"]

    Clean --&gt; Impact["Result: Improved Downstream Performance"]
</code></pre>
<h3>3.1  Common Crawl의 한계와 정제(Cleaning) 철학</h3>
<p>기존의 많은 연구들이 위키백과(Wikipedia)와 같이 잘 정제된 데이터를 선호했지만, 위키백과는 양적인 측면에서 한계가 있었다. 반면 웹 크롤링 데이터인 Common Crawl은 페타바이트 단위의 방대한 양을 제공하지만, 그 품질이 매우 조악하다는 단점이 있다. 여기에는 기계 번역된 부자연스러운 텍스트, 광고, 메뉴, 코드 조각, 욕설, 중복된 내용 등이 혼재되어 있어, 이를 그대로 학습할 경우 모델의 언어 생성 능력이 저하될 위험이 크다.</p>
<p>T5 연구진은 “깨끗한 데이터(Clean Data)“가 모델 성능의 핵심 변수임을 가정하고, Common Crawl 데이터에 엄격한 휴리스틱(Heuristic) 필터를 적용하여 C4를 구축했다. 이 정제 과정은 단순히 노이즈를 제거하는 것을 넘어, 모델이 ’자연어’를 학습하는 데 방해가 되는 모든 요소를 배제하는 데 초점을 맞추었다.3</p>
<h3>3.2  C4 데이터 정제 파이프라인</h3>
<p>C4 구축을 위해 적용된 구체적인 필터링 규칙은 다음과 같다. 이 규칙들은 향후 대규모 언어 모델 학습 데이터 구축의 표준적인 가이드라인으로 자리 잡았다.5</p>
<ol>
<li><strong>문장 종결성 검사:</strong> 각 텍스트 라인은 반드시 마침표(.), 느낌표(!), 물음표(?), 또는 따옴표(“)와 같은 문장 종결 부호로 끝나야 한다. 이는 문장이 중간에 잘리거나, 불완전한 텍스트(예: 메뉴 항목, 제목)를 제거하기 위함이다.</li>
<li><strong>길이 제한:</strong> 5문장 미만으로 구성된 짧은 페이지는 문맥 학습에 도움이 되지 않는다고 판단하여 제거했다. 또한 각 라인은 최소 3단어 이상으로 구성되어야 한다.</li>
<li><strong>유해 콘텐츠 필터링 (Blocklist):</strong> “List of Dirty, Naughty, Obscene or Otherwise Bad Words” 목록을 사용하여, 해당 목록에 있는 단어가 하나라도 포함된 페이지는 전체를 삭제했다. 이는 모델이 부적절한 언어를 생성하는 것을 방지하기 위한 윤리적 조치이자 데이터 품질 관리 조치이다.</li>
<li><strong>자바스크립트 및 에러 메시지 제거:</strong> 웹 크롤링 데이터에 흔히 포함되는 “Javascript must be enabled“와 같은 경고 문구를 제거하기 위해, “Javascript“라는 단어가 포함된 라인을 삭제했다.</li>
<li><strong>무의미한 텍스트 제거:</strong> 웹페이지 레이아웃을 잡기 위해 사용되는 “lorem ipsum“이 포함된 페이지를 삭제했다.</li>
<li><strong>코드 제거:</strong> 중괄호 <code>{</code> 가 포함된 페이지를 삭제했다. 중괄호는 프로그래밍 언어에서 주로 사용되므로, 이를 통해 자연어 텍스트가 아닌 코드가 포함된 문서를 효과적으로 걸러낼 수 있다.</li>
<li><strong>언어 필터링:</strong> langdetect 도구를 사용하여 영어가 아닌 것으로 판별된 페이지(확률 0.99 미만)를 제거했다. T5의 초기 실험은 영어 데이터에 집중했기 때문이다.</li>
<li><strong>중복 제거 (Deduplication):</strong> 3문장 이상의 스팬(Span)이 데이터셋 내에서 중복되어 나타날 경우 하나만 남기고 제거했다. 데이터 중복은 모델이 특정 패턴을 암기(Memorization)하게 하여 일반화 성능을 저해하는 주된 요인이다.</li>
</ol>
<p>이러한 과정을 거쳐 구축된 C4 데이터셋은 약 750GB 규모의 고품질 텍스트로 구성되었으며, 이는 T5가 다양한 다운스트림 과업에서 뛰어난 성능을 발휘하는 기반이 되었다.</p>
<h3>3.3  데이터 품질과 성능의 상관관계 분석</h3>
<p>연구진은 C4의 효과를 검증하기 위해 필터링되지 않은 원본 데이터(Unfiltered C4)와 정제된 C4로 각각 모델을 학습시켜 비교했다. 결과적으로 정제된 C4로 학습한 모델이 다운스트림 과업에서 일관되게 더 높은 성능을 보였다. 특히 문법적 정확성과 문맥 이해도가 요구되는 생성 과업에서 그 차이가 두드러졌다. 이는 데이터의 양(Quantity)만큼이나 질(Quality)이 중요하며, 적절한 전처리가 모델의 학습 효율을 크게 높일 수 있음을 시사한다.10</p>
<h2>4.  T5 모델 아키텍처: 트랜스포머의 계승과 변형</h2>
<p>T5의 아키텍처는 기본적으로 “Attention Is All You Need”(Vaswani et al., 2017)에서 제안된 트랜스포머(Transformer)의 인코더-디코더 구조를 따른다. 당시 GPT 계열의 디코더 전용(Decoder-only) 모델이나 BERT 계열의 인코더 전용(Encoder-only) 모델이 유행하던 상황에서, T5가 인코더-디코더 구조를 채택한 것은 ‘텍스트-투-텍스트’ 프레임워크를 가장 효과적으로 구현하기 위한 선택이었다.1</p>
<p><strong>T5 Architecture &amp; Modifications</strong></p>
<pre><code class="language-mermaid">flowchart TD
    subgraph "Structural Choice"
        Enc["Encoder (BERT-like)"] -- "Full Context Understanding" --&gt; Core
        Dec["Decoder (GPT-like)"] -- "Autoregressive Generation" --&gt; Core
        Core(("T5: Encoder-Decoder"))
    end

    subgraph "Modifications from Original Transformer"
        Core --&gt; M1["Relative Position Embeddings"]
        M1 -- "Scalar value based on offset" --&gt; M1_Detail["Handles longer sequences (Extrapolation)"]
        
        Core --&gt; M2["Simplified Layer Norm"]
        M2 -- "No Bias, Scale only (RMSNorm style)" --&gt; M2_Detail["Pre-Norm for stability"]

        Core --&gt; M3["Activation Function"]
        M3 -- "ReLU -&gt; Gated GELU" --&gt; M3_Detail["Better Performance"]
    end
</code></pre>
<h3>4.1  인코더-디코더 구조의 적합성</h3>
<p>인코더-디코더 구조는 입력 시퀀스를 처리하는 인코더와 출력 시퀀스를 생성하는 디코더로 구성된다. 인코더는 입력 전체를 양방향(Bidirectional)으로 참조하여 깊이 있는 문맥 이해를 수행하며, 디코더는 인코더의 출력과 이전에 생성된 토큰들을 참조하여 순차적(Autoregressive)으로 다음 토큰을 생성한다.</p>
<ul>
<li><strong>인코더(Encoder):</strong> BERT와 유사하게 입력 텍스트의 모든 토큰이 서로를 참조(Self-attention)할 수 있어 문장의 의미를 온전히 파악한다. 분류나 회귀 문제와 같이 입력 이해가 중요한 과업에 강점이 있다.</li>
<li><strong>디코더(Decoder):</strong> GPT와 유사하게 마스킹된 어텐션(Masked Attention)을 사용하여 미래의 토큰을 보지 않고 현재까지의 정보만으로 다음 토큰을 예측한다. 번역이나 요약과 같은 생성 과업에 필수적이다.</li>
</ul>
<p>T5는 이 두 구조를 결합함으로써 이해와 생성이 모두 필요한 복합적인 과업들을 단일 모델로 수행할 수 있게 되었다. 연구진은 인코더와 디코더의 파라미터를 공유하는 방식(Shared Encoder-Decoder)과 공유하지 않는 방식을 비교 실험했으며, 파라미터 공유가 모델 크기를 줄이는 데는 효과적이나 성능 면에서는 공유하지 않는 방식이 미세하게 우세함을 확인하고 최종적으로 파라미터를 분리하는 방식을 채택했다.14</p>
<h3>4.2  아키텍처의 세부 수정 사항</h3>
<p>T5는 원조 트랜스포머 구조를 기반으로 하되, 학습 안정성과 성능 향상을 위해 몇 가지 중요한 수정 사항을 적용했다.7</p>
<ol>
<li>상대적 위치 임베딩 (Relative Position Embeddings):</li>
</ol>
<p>기존 트랜스포머는 각 토큰의 절대적인 위치(Absolute Position)를 나타내는 고정된 정현파 임베딩이나 학습 가능한 임베딩을 사용했다. 그러나 T5는 쿼리(Query)와 키(Key) 사이의 상대적인 거리(Offset)에 따라 어텐션 가중치를 조절하는 스칼라 값을 학습하는 방식을 도입했다. 이는 문장 내에서 단어들 간의 절대적 위치보다 상대적 거리가 의미 파악에 더 중요하다는 언어적 특성을 반영한 것이다. 또한, 이 방식은 학습 때 보지 못한 더 긴 길이의 시퀀스가 입력되더라도 모델이 유연하게 대처할 수 있게 해 준다(Extrapolation).</p>
<ol start="2">
<li>간소화된 레이어 정규화 (Simplified Layer Norm):</li>
</ol>
<p>T5는 레이어 정규화(Layer Normalization) 과정에서 편향(Bias) 항을 제거하고 오직 스케일(Scale) 조정만 수행하는 방식을 사용했다(RMSNorm과 유사). 또한 정규화를 잔차 연결(Residual Connection) 외부가 아닌 내부에 적용하는 Pre-Norm 방식을 채택하여 심층 신경망의 학습 안정성을 강화했다.</p>
<ol start="3">
<li>피드포워드 네트워크(FFN)의 활성화 함수:</li>
</ol>
<p>초기 버전에서는 ReLU를 사용했으나, 이후 실험을 통해 Gated GELU(Gaussian Error Linear Unit) 등의 변형이 더 나은 성능을 보임을 확인했다.</p>
<h2>5.  사전 학습 목표: 스팬 오염(Span Corruption)과 센티넬 토큰</h2>
<p>T5의 성공을 이끈 또 다른 요인은 효율적인 사전 학습(Pre-training) 목표의 설계다. 연구진은 BERT의 마스크 언어 모델링(MLM)과 GPT의 인과적 언어 모델링(CLM)을 비교 분석한 끝에, 텍스트-투-텍스트 생성에 최적화된 ‘스팬 오염(Span Corruption)’ 방식을 고안했다.10</p>
<p><strong>Span Corruption Mechanism</strong></p>
<pre><code class="language-mermaid">flowchart TD

    subgraph "Original Text"
        Orig["'The cute dog walks in the park'"]
    end

    process["Masking Process (15%, Mean Span 3)"]

    subgraph "Model Input (Encoder)"
        Input["'The &lt;extra_id_0&gt; walks in &lt;extra_id_1&gt; park'"]
    end

    subgraph "Model Target (Decoder)"
        Output["'&lt;extra_id_0&gt; cute dog &lt;extra_id_1&gt; the &lt;extra_id_2&gt;'"]
    end

    Orig --&gt; process --&gt; Input
    Input --&gt;|"T5 Training"| Output
    
    note["Effect: Simulates both understanding (Encoder) and generation (Decoder)"]
    Output --- note
</code></pre>
<h3>5.1  스팬 오염(Span Corruption) 메커니즘</h3>
<p>BERT의 MLM은 개별 토큰을 독립적으로 마스킹하고 예측한다. 이는 이해(Understanding) 능력 배양에는 좋지만, 긴 텍스트를 생성하는 능력에는 한계가 있다. 반면 T5의 스팬 오염은 연속된 토큰들의 구간(Span)을 마스킹하고, 디코더가 이를 순차적으로 복원하게 한다.</p>
<p>구체적인 과정은 다음과 같다5:</p>
<ol>
<li><strong>입력 오염:</strong> 원본 문장에서 임의의 구간을 선택하여 마스킹한다. 이때 전체 토큰의 약 15%를 오염시키며, 각 스팬의 평균 길이는 3개 토큰이 되도록 설정한다.</li>
<li><strong>센티넬 토큰(Sentinel Tokens) 사용:</strong> 마스킹된 구간은 유니크한 센티넬 토큰(<code>&lt;extra_id_0&gt;</code>, <code>&lt;extra_id_1&gt;</code>,…)으로 대체된다. 예를 들어 “The cute dog walks in the park“에서 “cute dog“와 “the“가 마스킹된다면, 입력은 다음과 같이 변환된다.</li>
</ol>
<ul>
<li><strong>입력:</strong> <code>The &lt;extra_id_0&gt; walks in &lt;extra_id_1&gt; park</code></li>
</ul>
<ol start="3">
<li><strong>타겟 생성:</strong> 모델의 출력(Target)은 전체 문장을 복원하는 것이 아니라, 마스킹된 내용만을 순서대로 생성하는 것이다. 각 복원된 구간 앞에는 해당 센티넬 토큰이 붙고, 구간 뒤에는 다음 센티넬 토큰이 붙어 구분된다.</li>
</ol>
<ul>
<li><strong>타겟:</strong> <code>&lt;extra_id_0&gt; cute dog &lt;extra_id_1&gt; the &lt;extra_id_2&gt;</code></li>
<li>마지막에는 시퀀스의 끝을 알리는 토큰이 추가된다.</li>
</ul>
<p>이 방식은 다음과 같은 장점이 있다:</p>
<ul>
<li><strong>효율성:</strong> 모델이 전체 문장을 다시 생성할 필요 없이, 누락된 정보만 예측하면 되므로 계산 비용이 절감된다.</li>
<li><strong>문맥 이해 및 생성 능력 동시 배양:</strong> 인코더는 센티넬 토큰이 포함된 문맥을 이해해야 하고, 디코더는 가변 길이의 텍스트를 생성해야 하므로 이해와 생성 능력이 동시에 향상된다.</li>
</ul>
<h3>5.2  다양한 목적 함수(Objective Function) 비교 실험</h3>
<p>T5 연구진은 최적의 사전 학습 목표를 찾기 위해 광범위한 비교 실험을 수행했다.7</p>
<ul>
<li><strong>언어 모델링 (Language Modeling):</strong> 왼쪽에서 오른쪽으로 다음 단어를 예측 (GPT 스타일).</li>
<li><strong>BERT 스타일 MLM:</strong> 개별 토큰 마스킹.</li>
<li><strong>Deshuffling:</strong> 순서가 섞인 문장을 원래 순서로 복원.</li>
</ul>
<p>실험 결과, 스팬 오염 방식이 다운스트림 과업 성능에서 가장 우수한 결과를 보였다. 특히 텍스트 생성 과업과 분류 과업 모두에서 균형 잡힌 성능을 제공했다. 마스킹 비율(Corruption Rate)에 대한 실험에서는 15%가 최적임을 재확인했으며, 평균 스팬 길이(Span Length)는 3일 때 가장 효율적이었다. 스팬 길이가 너무 길면 문맥 정보가 부족해지고, 너무 짧으면 예측이 지나치게 쉬워지거나 연산 효율이 떨어지는 트레이드오프가 존재했다.</p>
<h2>6.  실험 설계와 체계적 절제 연구 (Ablation Studies)</h2>
<p>T5 논문의 부제인 “Exploring the Limits of Transfer Learning“에 걸맞게, 연구진은 모델의 성능에 영향을 미치는 거의 모든 요소를 체계적으로 분석했다. 이들은 ’좌표 하강법(Coordinate Descent)’과 유사한 방법론을 사용하여, 베이스라인 모델을 설정한 뒤 한 번에 하나의 변수(데이터셋, 아키텍처, 학습 목표 등)만을 변경하며 그 효과를 측정했다.5</p>
<p><strong>Experiments &amp; Scaling</strong></p>
<pre><code class="language-mermaid">flowchart TD

    subgraph "Training Strategy Comparison"
        S1["Fine-tuning Strategy"]
        S1 --&gt; S1_Res["All Parameters &gt; Adapter Layers &gt; Gradual Unfreezing"]
        
        S2["Multi-task vs. Pre-train + Fine-tune"]
        S2 --&gt; S2_Res["Pre-train + Fine-tune is generally superior"]
    end

</code></pre>
<h3>6.1  베이스라인 설정</h3>
<p>실험의 기준이 되는 베이스라인 모델은 BERT-Base와 유사한 크기(약 2.2억 파라미터)의 인코더-디코더 모델로 설정되었다. 이 모델은 C4 데이터셋으로 스팬 오염 목표(15% 마스킹, 평균 길이 3)를 사용하여 사전 학습되었으며, 이후 GLUE, SuperGLUE, CNN/Daily Mail(요약), SQuAD(질의응답), WMT(번역) 등 다양한 벤치마크에서 평가되었다.</p>
<h3>6.2  학습 전략 비교</h3>
<p>연구진은 미세 조정(Fine-tuning) 단계에서의 전략도 비교했다.</p>
<ol>
<li><strong>전체 미세 조정 (All parameters):</strong> 모델의 모든 파라미터를 업데이트.</li>
<li><strong>어댑터 레이어 (Adapter Layers):</strong> 트랜스포머 레이어 사이에 작은 신경망(어댑터)을 추가하고, 기존 파라미터는 고정한 채 어댑터만 학습.</li>
<li><strong>점진적 해동 (Gradual Unfreezing):</strong> 초기에는 상위 레이어만 학습하다가 점차 하위 레이어로 학습 범위를 넓힘.</li>
</ol>
<p>결과적으로 모든 파라미터를 미세 조정하는 것이 가장 성능이 좋았으나, 어댑터 레이어를 사용하는 방식도 훨씬 적은 파라미터 업데이트만으로도 경쟁력 있는 성능을 보여줌을 확인했다. 이는 거대 모델을 효율적으로 서빙해야 하는 실무 환경에서 중요한 시사점이다.</p>
<h3>6.3  멀티태스크 학습 vs. 사전 학습 후 미세 조정</h3>
<p>T5는 모든 과업을 텍스트-투-텍스트로 변환했기 때문에, 여러 과업을 동시에 학습하는 멀티태스크 학습(Multi-task Learning)이 자연스럽게 가능하다. 연구진은 다음 두 가지 방식을 비교했다.</p>
<ol>
<li><strong>비지도 사전 학습 + 개별 과업 미세 조정:</strong> C4로 대규모 비지도 학습 후, 각 과업별로 별도 미세 조정.</li>
<li><strong>멀티태스크 학습:</strong> C4 데이터와 다운스트림 과업 데이터를 혼합하여 한 번에 학습.</li>
</ol>
<p>실험 결과, 1번 방식(사전 학습 후 미세 조정)이 여전히 가장 강력한 성능을 보였다. 멀티태스크 학습은 데이터 셋의 크기 불균형(Mixing Ratio)을 맞추기가 까다롭고, 특정 과업에 과적합(Overfitting)되거나 덜 학습(Underfitting)되는 문제가 발생하기 쉬웠다. 그러나 연구진은 데이터 혼합 비율을 세밀하게 조정한 멀티태스크 학습이 사전 학습 방식에 근접한 성능을 낼 수 있음을 보여주며, 단일 모델로 모든 과업을 처리하는 가능성을 열어두었다.14</p>
<h2>7.  확장성(Scaling Laws)과 SOTA 달성</h2>
<p>T5 연구의 정점은 모델의 규모 확장에 따른 성능 변화 분석이다. 연구진은 모델 크기, 학습 데이터 양, 학습 시간을 각각 늘려가며 성능 변화를 관측했다.</p>
<pre><code class="language-mermaid">flowchart TD
    subgraph "Scaling Laws (T5 Variants)"
        V1["T5-Small (60M)"]
        V2["T5-Base (220M)"]
        V3["T5-Large (770M)"]
        V4["T5-3B (3B)"]
        V5["T5-11B (11B)"]
        
        V1 --&gt; V2 --&gt; V3 --&gt; V4 --&gt; V5
        V5 -- "Achieved SOTA on 18/24 benchmarks" --&gt; SOTA["Scaling Insight: Bigger Model &gt; Longer Training"]
    end
</code></pre>
<h3>7.1  모델 사이즈의 스펙트럼</h3>
<p>T5는 다음과 같은 5가지 크기로 배포되어 다양한 컴퓨팅 환경에 대응했다.5</p>
<table><thead><tr><th><strong>모델 명 (Model Variant)</strong></th><th><strong>파라미터 수 (Parameters)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>T5-Small</strong></td><td>6,000만 (60M)</td><td>경량화 모델, 빠른 추론 속도</td></tr>
<tr><td><strong>T5-Base</strong></td><td>2억 2,000만 (220M)</td><td>BERT-Base급 표준 모델</td></tr>
<tr><td><strong>T5-Large</strong></td><td>7억 7,000만 (770M)</td><td>BERT-Large의 2배 규모</td></tr>
<tr><td><strong>T5-3B</strong></td><td>30억 (3B)</td><td>대형 모델, 높은 성능</td></tr>
<tr><td><strong>T5-11B</strong></td><td>110억 (11B)</td><td>초대형 모델, SOTA 달성</td></tr>
</tbody></table>
<p><strong>표 5.1.2</strong> T5 모델의 사이즈별 제원.</p>
<h3>7.2  스케일링의 교훈</h3>
<p>실험 결과, 성능을 높이는 가장 확실한 방법은 모델의 크기(파라미터 수)를 키우는 것이었다. 학습 시간을 4배 늘리는 것보다 모델 크기를 2배 키우는 것이 더 효율적인 경우도 있었다. 특히 가장 큰 모델인 T5-11B는 GLUE, SuperGLUE, SQuAD, CNN/Daily Mail 등 20여 개의 벤치마크 중 18개에서 당시 최고 성능(SOTA)을 경신했다.14</p>
<p>이는 “충분히 큰 모델과 충분히 깨끗한 데이터가 있다면, 별도의 과업별 아키텍처 엔지니어링 없이도 인간 수준의 언어 능력을 달성할 수 있다“는 사실을 입증한 것이다.</p>
<h2>8.  결론 및 NLP 역사적 의의: T5에서 LLM으로</h2>
<p>T5는 자연어 처리 역사에서 ’통합(Unification)’의 가치를 증명한 기념비적인 모델이다. T5가 제시한 텍스트-투-텍스트 프레임워크는 이후 등장한 모든 생성형 AI의 기반이 되었다.</p>
<p><strong>Historical Significance: Evolution to LLMs</strong></p>
<pre><code class="language-mermaid">flowchart TD

    T5["T5 Model (2020)"]
    
    Prop1["Task Definition: Prefix"]
    Prop2["Architecture: Text-to-Text"]
    
    T5 --&gt; Prop1
    T5 --&gt; Prop2

    Prop1 --&gt;|"Evolution"| FLAN["FLAN-T5 (Instruction Tuning)"]
    FLAN --&gt;|"Generalization"| PromptEng["Modern Prompt Engineering"]
    
    Prop2 --&gt;|"Standardization"| GenAI["Generative AI Paradigm"]
    GenAI --&gt;|"Foundation"| LLM["Large Language Models (GPT-4, Gemini, etc.)"]

    style T5 fill:#f9f,stroke:#333,stroke-width:2px
    style LLM fill:#bbf,stroke:#333,stroke-width:2px
</code></pre>
<h3>8.1  프롬프트 엔지니어링과 지시 튜닝의 시초</h3>
<p>T5가 사용한 과업 식별자(Prefix)는 오늘날 우리가 챗봇에게 자연어로 명령을 내리는 프롬프트의 원형이다. T5의 후속 모델인 FLAN-T5(Finetuned Language Net)는 이러한 접두사를 더욱 다양한 자연어 지시(Instruction) 형태로 확장하여, 모델이 학습하지 않은 새로운 과업도 지시문만으로 수행할 수 있는 ‘제로샷(Zero-shot)’ 능력을 획기적으로 향상시켰다.10 “번역해라:“라는 단순한 접두사가 “이 문장을 독일어로 번역해 줄래?“라는 대화형 지시로 진화한 것이다.</p>
<h3>8.2  범용 언어 모델의 표준화</h3>
<p>T5 이전에는 번역기, 요약기, 분류기가 서로 다른 소프트웨어였다면, T5 이후에는 모두가 하나의 ’언어 모델’이 되었다. 개발자는 이제 복잡한 모델 구조를 고민하는 대신, “문제를 어떻게 텍스트로 표현할 것인가?“와 “어떤 텍스트 데이터를 모델에게 보여줄 것인가?“에 집중하게 되었다.</p>
<p>결론적으로, “모든 텍스트 문제는 텍스트 생성 문제다“라는 T5의 명제는 단순한 기술적 주장을 넘어, 인공지능이 인간의 언어를 다루는 방식을 근본적으로 재정의했다. T5는 특화된 도구(Tool)들의 집합이었던 NLP를 범용적인 지능(Intelligence)으로 통합하는 결정적인 가교 역할을 수행했다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer - arXiv, https://arxiv.org/html/1910.10683</li>
<li>Understanding the T5 Model: A Comprehensive Guide | by Gagan Gupta | Medium, https://medium.com/@gagangupta_82781/understanding-the-t5-model-a-comprehensive-guide-b4d5c02c234b</li>
<li>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer - Journal of Machine Learning Research, https://jmlr.org/papers/volume21/20-074/20-074.pdf</li>
<li>T5 (Text-to-Text Transfer Transformer) - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/t5-text-to-text-transfer-transformer/</li>
<li>arXiv:1910.10683v4 [cs.LG] 19 Sep 2023, https://arxiv.org/pdf/1910.10683</li>
<li>Prompt engineering and prompt-tuning: Foundations, advancements and research direction, http://journalwjarr.com/sites/default/files/fulltext_pdf/WJARR-2025-4103.pdf</li>
<li>Review — T5: Text-to-Text Transfer Transformer | by Sik-Ho Tsang | Medium, https://sh-tsang.medium.com/review-t5-text-to-text-transfer-transformer-b3f0f3c07295</li>
<li>T5: Text-To-Text Transfer Transformer - ἐντελέχεια.άι - Jeju.ai, https://lecture.jeju.ai/lectures/nlp_deep/transformers/t5.html</li>
<li>Exploring the Robustness of the Natural Language Inference Capabilties of T5 - Karlsruher Institut für Technologie, https://publikationen.bibliothek.kit.edu/1000139678/132253525</li>
<li>T5 and Text-to-Text Framework: Unified NLP Through Text Transformations - Interactive | Michael Brenndoerfer, https://mbrenndoerfer.com/writing/t5-text-to-text-framework-unified-nlp-through-text-transformations</li>
<li>mT5: Multilingual T5, https://anwarvic.github.io/cross-lingual-lm/mT5</li>
<li>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer - Colin Raffel • Noam Shazeer - AI@NSU, https://ai.nsu.ru/attachments/download/3708/Nikolaev_NA_Exploring_the_Limits_of_Transfer_Learning_with_T5.pdf</li>
<li>C4: The Data Dynamo Behind T5’s Triumphs | by hallucinatingkitten | Generative AI, https://generativeai.pub/c4-the-data-dynamo-behind-t5s-triumphs-2c3769cfa466</li>
<li>Exploring the Limits of Transfer Learning with a unified Text-to-Text Transformer - CSE, IIT Delhi, https://www.cse.iitd.ac.in/~mausam/courses/col873/spring2020/slides/08-t5.pdf</li>
<li>T5 - Accubits Technologies, https://accubits.com/large-language-models-leaderboard/t5/</li>
<li>Sequence-to-sequence pretraining for a less-resourced Slovenian language - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC10086348/</li>
<li>T5 - Hugging Face, https://huggingface.co/docs/transformers/v4.47.1/model_doc/t5</li>
<li>Enhancing SPARQL Query Generation for Knowledge Base Question Answering Systems by Learning to Correct Triplets - MDPI, https://www.mdpi.com/2076-3417/14/4/1521</li>
<li>Revisiting Relation Extraction in the era of Large Language Models - arXiv, https://arxiv.org/html/2305.05003v2</li>
<li>FLAN-T5 Model Overview - Emergent Mind, https://www.emergentmind.com/topics/flan-t5-model</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>