<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:12.3 PatchTST와 iTransformer - 시계열 데이터의 패치화 및 역발상 구조</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>12.3 PatchTST와 iTransformer - 시계열 데이터의 패치화 및 역발상 구조</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>12.3 PatchTST와 iTransformer - 시계열 데이터의 패치화 및 역발상 구조</span></nav>
                </div>
            </header>
            <article>
                <h1>12.3 PatchTST와 iTransformer - 시계열 데이터의 패치화 및 역발상 구조</h1>
<p>2025-12-23, G30DR</p>
<p>2020년대 초반, 인공지능 학계는 자연어 처리(NLP)와 컴퓨터 비전(CV) 분야를 평정한 트랜스포머(Transformer) 아키텍처가 시계열 예측(Time Series Forecasting) 분야에서도 동일한 ’싱귤래리티(Singularity)’를 달성할 수 있을지에 대해 격렬한 논쟁을 벌였다. 2023년을 전후로 등장한 DLinear와 같은 단순 선형 모델이 복잡한 트랜스포머 기반 모델들(Informer, Autoformer 등)의 성능을 능가한다는 연구 결과가 발표되면서, “시계열 데이터에 과연 어텐션(Attention) 메커니즘이 유효한가?“라는 회의론이 대두되었기 때문이다.1 그러나 이러한 위기는 트랜스포머의 구조적 한계를 재해석하고 시계열 데이터의 본질적 특성에 맞게 입력을 재구성하는 혁신적인 접근법을 탄생시키는 계기가 되었다. 본 절에서는 이 반격의 선봉에 있는 두 가지 핵심 모델, **PatchTST(Patch Time Series Transformer)**와 **iTransformer(Inverted Transformer)**를 심도 있게 분석한다. 이들은 각각 ’시간 축의 패치화(Patching)’와 ’차원의 역전(Inversion)’이라는 상이한 메커니즘을 통해 트랜스포머의 효용성을 증명했으며, 시계열 데이터 처리의 패러다임을 ’시점(Time-step) 중심’에서 ’의미론적 단위(Semantic Unit) 중심’으로 전환시켰다.1</p>
<h2>1.  트랜스포머의 위기와 점별(Point-wise) 처리의 한계</h2>
<p>PatchTST와 iTransformer의 혁신성을 온전히 이해하기 위해서는, 먼저 기존 트랜스포머 기반 시계열 모델들이 직면했던 구조적 모순과 실패의 원인을 규명해야 한다. Informer 4, Autoformer 6, FEDformer 4와 같은 초기 모델들은 시계열 데이터를 NLP의 문장과 유사하게 취급하여, 각 시간 단계(Time-step)를 하나의 토큰으로 간주하는 <strong>점별(Point-wise) 어텐션</strong> 방식을 채택했다. 이러한 접근 방식은 다음과 같은 치명적인 한계를 내포하고 있었다.</p>
<p>첫째, <strong>의미론적 밀도(Semantic Density)의 결핍</strong>이다. NLP에서 단어 하나는 그 자체로 풍부한 의미를 내포하지만, 시계열 데이터의 단일 시점 값(Scalar)은 의미론적 정보량이 극히 낮다. 특정 시점 <span class="math math-inline">t</span>의 값 하나만으로는 국소적인 문맥(Local Context)을 파악하기 어려우며, 이는 어텐션 메커니즘이 인접한 시점들의 중요한 패턴을 놓치고 전역적(Global) 상관관계에만 과도하게 집중하게 만드는 결과를 낳았다.7 이는 결과적으로 잡음(Noise)에 취약한 어텐션 맵을 생성하게 된다.</p>
<p>둘째, <strong>연산 효율성과 정보 보존의 트레이드오프</strong>다. 트랜스포머의 self-attention은 시퀀스 길이 <span class="math math-inline">L</span>에 대해 <span class="math math-inline">O(L^2)</span>의 연산 복잡도를 가진다. 장기 시계열 예측(Long-term Time Series Forecasting, LTSF)을 위해서는 긴 과거 데이터(Look-back window)를 참조해야 하는데, 이는 메모리 폭발과 연산 속도 저하를 초래했다. Informer 등이 제안한 희소 어텐션(Sparse Attention) 기법은 효율성을 개선했으나, 정보 손실을 야기하여 예측 정확도를 희생시켰다는 비판을 받았다.5</p>
<p>셋째, <strong>다변량 데이터의 혼합 처리로 인한 모호성</strong>이다. 기존 모델들은 각 시점의 모든 변수(Variate)를 하나의 벡터로 임베딩하여 처리했다. 이는 변수 간의 물리적 특성이 상이하거나(예: 온도와 전력량), 변수 간의 시간적 지연(Lag)이 존재할 때, 모델이 개별 변수의 고유한 시간적 패턴을 학습하는 것을 방해하는 요인이 되었다.3</p>
<p>DLinear의 저자들은 이러한 복잡한 트랜스포머 모델들이 추세-계절성 분해(Trend-Seasonality Decomposition)를 수행하는 단순한 선형 모델보다 성능이 떨어진다는 것을 실험적으로 증명하며 ’트랜스포머 무용론’을 주장했다.2 이에 대한 응답으로 등장한 것이 바로 데이터의 입력 표현(Input Representation)과 처리 축(Processing Axis)을 혁신한 PatchTST와 iTransformer이다.</p>
<h2>2.  PatchTST: 채널 독립성과 패치화의 결합</h2>
<p>PatchTST는 ICLR 2023에서 제안된 모델로, “시계열 데이터는 64개의 단어(패치)로 충분하다“는 도발적인 명제를 던지며 등장했다.7 이 모델은 비전 트랜스포머(ViT)가 이미지를 패치 단위로 처리하는 것에서 영감을 받아, 시계열을 ’의미 있는 조각’으로 분해하고 이를 독립적인 채널로 처리하는 전략을 취했다.</p>
<h3>2.1  패치화(Patching): 시맨틱 정보의 보존과 연산 효율성 혁명</h3>
<p>PatchTST의 가장 직관적인 특징은 시계열 데이터를 개별 시점이 아닌, 짧은 하위 시계열(Sub-series) 조각인 ’패치’로 분할한다는 점이다. 길이 <span class="math math-inline">L</span>의 단변량 시계열 데이터 <span class="math math-inline">x^{(i)} \in \mathbb{R}^{1 \times L}</span>이 있을 때, 패치 길이 <span class="math math-inline">P</span>와 스트라이드 <span class="math math-inline">S</span>를 적용하여 <span class="math math-inline">N</span>개의 패치 시퀀스 <span class="math math-inline">x_p^{(i)} \in \mathbb{R}^{N \times P}</span>를 생성한다. 여기서 패치의 개수 <span class="math math-inline">N</span>은 다음과 같이 계산된다.13<br />
<span class="math math-display">
N = \left\lfloor \frac{L - P}{S} \right\rfloor + 2
</span><br />
이러한 패치화 과정은 시계열 예측에 있어 세 가지 결정적인 이점을 제공한다:</p>
<ul>
<li><strong>지역적 의미 정보(Local Semantic Information)의 포착:</strong> 단일 시점의 값은 노이즈에 취약하고 정보량이 적지만, 연속된 시점의 집합인 패치는 그 자체로 상승/하강 추세, 국소적인 주기성 등 물리적 의미를 내포한다. 패치를 하나의 토큰으로 임베딩함으로써, 트랜스포머는 비로소 ‘의미 있는 단위’ 간의 관계를 학습할 수 있게 된다.7 이는 음성 인식에서 음소 단위가 아닌 단어 단위로 처리할 때 이해도가 높아지는 것과 유사하다.</li>
<li><strong>연산 복잡도의 2차적 감소:</strong> 트랜스포머의 어텐션 맵은 토큰 수의 제곱에 비례하는 메모리를 요구한다. <span class="math math-inline">S=P</span>로 설정하여 겹치지 않게(Non-overlapping) 패치화할 경우, 토큰의 수 <span class="math math-inline">N</span>은 원래 길이 <span class="math math-inline">L</span>의 <span class="math math-inline">1/P</span>로 줄어든다. 즉, 어텐션 연산량은 <span class="math math-inline">O(L^2)</span>에서 <span class="math math-inline">O((L/P)^2)</span>로 급격히 감소한다. 이는 모델이 기존보다 훨씬 더 긴 과거 데이터(Look-back window)를 참조할 수 있게 하여, 장기 의존성(Long-term Dependency) 학습 능력을 극대화한다.7</li>
<li><strong>어텐션 메커니즘의 효율성 증대:</strong> 점별 어텐션이 값의 크기가 유사한 시점들에 불필요하게 집중하는 경향이 있다면, 패치 단위 어텐션은 패치의 형상(Shape)과 패턴의 유사성을 기반으로 작동하므로 훨씬 더 유의미한 시간적 인과관계를 학습한다.17</li>
</ul>
<h3>2.2  채널 독립성(Channel Independence): 다변량 데이터 처리의 역설</h3>
<p>기존의 다변량 시계열 모델(Crossformer, iTransformer 등)들은 모든 채널(변수)의 정보를 하나의 임베딩 벡터에 혼합(Channel Mixing)하여 변수 간 상관관계를 포착하려 했다. 그러나 PatchTST는 각 채널을 **완전히 독립적인 단변량 시계열(Univariate Time Series)**로 취급하는 ‘채널 독립성(Channel Independence)’ 전략을 채택했다.8</p>
<p>이 방식은 하나의 트랜스포머 백본(Backbone)이 모든 채널에 대해 공유되며(Weight Sharing), 각 채널의 데이터는 개별적으로 처리된 후 마지막 예측 단계에서 병합된다. 이 전략이 강력한 성능을 발휘하는 이유는 다음과 같다:</p>
<ul>
<li><strong>과적합(Overfitting) 방지 및 일반화 성능 강화:</strong> 다변량 시계열 데이터는 채널 간의 상관관계가 명확하지 않거나 시간에 따라 변하는(Non-stationary) 경우가 많다. 억지로 채널 간의 관계를 학습하려다 보면 오히려 노이즈에 과적합될 위험이 크다. 채널 독립 방식은 이러한 위험을 원천 차단하며, 변수 간의 관계가 희소한 데이터셋에서 특히 강력하다.1</li>
<li><strong>데이터 증강 효과:</strong> 모든 채널이 동일한 모델 파라미터를 공유하므로, 채널 수가 <span class="math math-inline">M</span>개인 데이터셋은 사실상 <span class="math math-inline">M</span>배의 훈련 데이터를 제공하는 효과를 낸다. 이는 훈련 데이터가 부족한 시계열 예측 작업에서 강력한 학습 기회를 제공한다.12</li>
</ul>
<h3>2.3  PatchTST의 아키텍처 및 세부 구현</h3>
<p>PatchTST는 인코더-디코더 구조를 버리고 <strong>인코더 전용(Encoder-only)</strong> 구조를 채택했다. 이는 기존의 인코더-디코더 구조가 장기 시계열 예측에서 디코더 부분의 기여도가 낮다는 연구 결과들을 반영한 것이다.4</p>
<ul>
<li><strong>가역적 인스턴스 정규화(RevIN):</strong> 각 패치화 단계 이전에 분포 이동(Distribution Shift) 문제를 해결하기 위해 Reversible Instance Normalization(RevIN)을 적용한다. 입력 데이터의 평균과 분산을 제거하여 정규화한 후 모델에 주입하고, 모델의 출력에 다시 평균과 분산을 더해 복원하는 방식이다. 이는 시계열 데이터의 비정상성(Non-stationarity)을 완화하는 데 핵심적인 역할을 한다.19</li>
<li><strong>위치 임베딩(Positional Embedding):</strong> 패치들의 시간적 순서를 모델이 인지할 수 있도록 학습 가능한 위치 임베딩(Learnable Positional Embedding) 또는 사인파(Sinusoidal) 임베딩을 추가한다. 흥미로운 점은 PatchTST가 위치 임베딩을 제거해도 성능 저하가 크지 않다는 연구 결과인데, 이는 패치 자체가 이미 순차적인 데이터 흐름의 정보를 내부적으로 포함하고 있기 때문으로 분석된다.13</li>
<li><strong>자기지도 학습(Self-supervised Learning):</strong> PatchTST는 마스킹된 패치를 복원하는 방식의 자기지도 학습을 지원한다. 이는 라벨이 없는 대규모 데이터셋에서 표현 학습(Representation Learning)을 수행한 뒤, 다운스트림 작업에 미세 조정(Fine-tuning)할 때 탁월한 성능을 보인다. 이는 NLP의 BERT와 유사한 방식이다.7</li>
</ul>
<table><thead><tr><th><strong>하이퍼파라미터</strong></th><th><strong>기본값 및 범위</strong></th><th><strong>설명</strong></th></tr></thead><tbody>
<tr><td><strong>Patch Length (<span class="math math-inline">P</span>)</strong></td><td>16 ~ 24</td><td>패치의 길이. 너무 짧으면 의미 정보 부족, 너무 길면 세밀함 상실.20</td></tr>
<tr><td><strong>Stride (<span class="math math-inline">S</span>)</strong></td><td><span class="math math-inline">S=P</span> (Non-overlap)</td><td>패치 간 간격. 겹치지 않게 설정하여 정보 중복 방지 및 연산 효율 극대화.</td></tr>
<tr><td><strong>Layers</strong></td><td>3</td><td>트랜스포머 인코더 층의 수.</td></tr>
<tr><td><strong>Look-back Window</strong></td><td>336 ~ 720</td><td>입력 시퀀스 길이. 길수록 장기 패턴 학습에 유리.</td></tr>
</tbody></table>
<p>[표 12.3.1] PatchTST의 주요 하이퍼파라미터 구성 및 권장 설정 20</p>
<h2>3.  iTransformer: 차원의 역전과 다변량 상관관계의 재발견</h2>
<p>PatchTST가 채널 독립성을 통해 변수 간의 관계를 의도적으로 배제하고 시간적 패턴에 집중했다면, **iTransformer(Inverted Transformer)**는 정반대의 철학을 가진다. ICLR 2024에서 발표된 이 모델은 트랜스포머의 구조를 수정하지 않으면서도, 입력 데이터의 차원을 전치(Transpose)하여 적용하는 것만으로 최첨단 성능을 달성했다.3</p>
<h3>3.1  역발상 구조(Inverted Architecture): 시간과 변수의 역할 교체</h3>
<p>전통적인 트랜스포머 시계열 모델은 입력 데이터 <span class="math math-inline">X \in \mathbb{R}^{T \times N}</span> (<span class="math math-inline">T</span>: 시간 길이, <span class="math math-inline">N</span>: 변수 개수)를 시점 <span class="math math-inline">t</span>를 기준으로 토큰화하여 <span class="math math-inline">T</span>개의 토큰을 생성했다. 이때 각 토큰은 <span class="math math-inline">N</span>차원의 벡터가 된다. 반면, iTransformer는 이를 전치하여 <span class="math math-inline">N</span>개의 **변수 토큰(Variate Token)**을 생성한다. 즉, 각 토큰은 특정 변수의 전체 시간 이력(Look-back window)을 임베딩한 벡터가 된다.22</p>
<p>이 단순해 보이는 구조적 반전(Inversion)은 트랜스포머의 핵심 모듈인 **어텐션(Attention)**과 **피드포워드 네트워크(FFN)**의 역할을 완전히 뒤바꾸며, 시계열 데이터 처리에 최적화된 귀납적 편향(Inductive Bias)을 제공한다.</p>
<h3>3.2  다변량 상관관계 학습을 위한 어텐션(Multivariate Correlation Attention)</h3>
<p>기존 모델에서 어텐션은 시간 축(Temporal Axis)을 따라 작용하여, “어떤 시점이 다른 시점과 관련이 있는가?“를 계산했다. 그러나 iTransformer의 역전된 구조에서는 어텐션이 **변수 축(Variate Axis)**을 따라 작동한다.</p>
<ul>
<li><strong>메커니즘:</strong> 쿼리(Query), 키(Key), 밸류(Value)는 각각 서로 다른 변수(예: 기상 데이터의 온도, 습도, 풍속)를 나타낸다. 따라서 계산된 어텐션 점수(Score)는 변수 간의 상호작용 강도, 즉 **다변량 상관관계(Multivariate Correlation)**를 의미하게 된다.24</li>
<li><strong>해석 가능성 및 효용:</strong> 이는 다변량 시계열 데이터에서 가장 중요한 정보인 “변수 간의 인과관계 및 상호작용“을 명시적으로 모델링한다. 예를 들어, 발전소 센서 데이터에서 특정 부품의 온도 상승이 다른 부품의 압력 변화와 어떻게 연결되는지를 어텐션 맵을 통해 직관적으로 해석할 수 있다.3</li>
</ul>
<h3>3.3  시간적 동적 모델링을 위한 FFN(Temporal Modeling via MLP)</h3>
<p>iTransformer의 가장 독창적인 부분은 시간적 흐름(Temporal Dynamics)을 처리하는 방식이다. 각 변수 토큰은 해당 변수의 전체 시간 정보를 벡터화한 것이다. 이 토큰이 FFN(Feed-Forward Network, 즉 MLP)을 통과할 때, FFN은 시계열의 시간적 패턴을 학습하고 미래 값을 생성하는 역할을 수행한다.23</p>
<ul>
<li><strong>MLP의 재발견과 효율성:</strong> 이는 DLinear와 같은 선형/MLP 모델이 보여준 “시계열의 시간적 패턴은 단순한 선형 레이어로도 충분히 모델링 가능하다“는 가설을 트랜스포머 내부로 통합한 것이다. FFN의 가중치는 모든 변수 토큰에 공유되므로, 모델은 모든 변수에 공통적으로 적용되는 시간적 특징을 효율적으로 학습한다.</li>
<li><strong>임의의 룩백 윈도우 활용:</strong> 기존 트랜스포머는 윈도우 크기가 커지면 연산량이 급증하고 성능이 저하되는 경향이 있었으나, iTransformer의 FFN 기반 시간 모델링은 긴 시퀀스에서도 강건한 성능을 유지하며, 오히려 룩백 윈도우가 길어질수록 정보량이 늘어나 예측 정확도가 향상되는 경향을 보인다.3 이는 <span class="math math-inline">O(L^2)</span>의 시간 복잡도를 가진 시간 축 어텐션을 제거하고, <span class="math math-inline">O(N^2)</span>의 변수 축 어텐션으로 대체했기 때문에, 시간 길이 <span class="math math-inline">L</span>이 증가해도 연산 부담이 선형적으로만 증가하기 때문이다.</li>
</ul>
<h3>3.4  아키텍처 구현 및 특징</h3>
<p>iTransformer의 구현은 기술적으로 매우 간결하다. 표준 트랜스포머 인코더 블록을 그대로 사용하되, 입력 차원만 뒤집어 넣는 것이다.</p>
<ul>
<li><strong>임베딩(Embedding):</strong> 시점별 임베딩이 아니라, 각 변수의 전체 시계열 <span class="math math-inline">X_{:, n} \in \mathbb{R}^{L}</span>을 MLP를 통해 <span class="math math-inline">D</span>차원 벡터로 투영한다. 이때 위치 임베딩(Positional Embedding)은 필수적이지 않다. 이는 FFN이 이미 순서가 고정된 벡터를 처리하므로 시간적 순서 정보를 암묵적으로 학습하기 때문이며, 실제로 위치 임베딩 없이도 성능 저하가 거의 없음이 실험적으로 증명되었다.23</li>
<li><strong>레이어 정규화(Layer Normalization):</strong> 변수 토큰에 대해 정규화를 수행하므로, 서로 다른 물리적 단위를 가진 변수들(예: 주식 가격 vs. 거래량) 간의 스케일 차이로 인한 분포 불일치 문제를 효과적으로 해결한다. 이는 기존의 시간 축 정규화가 시계열의 비정상성으로 인해 겪던 문제를 완화한다.10</li>
</ul>
<h2>4.  비교 분석: 패치화와 역발상의 대결 및 통합적 시각</h2>
<p>PatchTST와 iTransformer는 모두 기존 트랜스포머의 한계를 극복하고 SOTA(State-of-the-Art) 성능을 갱신했지만, 그 접근 방식과 철학은 대조적이다. 두 모델의 비교를 통해 현대 시계열 트랜스포머의 지형도를 명확히 할 수 있다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>PatchTST (ICLR 2023)</strong></th><th><strong>iTransformer (ICLR 2024)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 철학</strong></td><td>시간적 패턴의 의미론적 압축 (Patching)</td><td>다변량 상관관계와 시간적 역학의 분리 (Inversion)</td></tr>
<tr><td><strong>입력 토큰</strong></td><td>시간 축의 하위 시계열 (Sub-series)</td><td>변수 축의 전체 시계열 (Whole Series)</td></tr>
<tr><td><strong>어텐션의 대상</strong></td><td><strong>시간적 관계 (Temporal Attention)</strong></td><td><strong>변수 간 관계 (Variate/Channel Attention)</strong></td></tr>
<tr><td><strong>채널 처리</strong></td><td><strong>채널 독립 (Channel Independence)</strong></td><td><strong>채널 혼합 (Channel Mixing / Multivariate)</strong></td></tr>
<tr><td><strong>시간 모델링</strong></td><td>Self-Attention + Positional Embedding</td><td>Feed-Forward Network (MLP)</td></tr>
<tr><td><strong>장점</strong></td><td>데이터 효율성, 긴 시퀀스 처리에 강함, 과적합 방지</td><td>변수 간 상호작용 포착, 이종 변수 처리에 강함</td></tr>
<tr><td><strong>약점</strong></td><td>변수 간의 복잡한 상호작용 무시</td><td>변수 개수가 매우 많을 때(<span class="math math-inline">N \gg L</span>) 연산 부담</td></tr>
<tr><td><strong>적합한 데이터</strong></td><td>변수 간 독립성이 강하거나 데이터가 적은 경우</td><td>변수 간 관계가 중요하고 복잡한 시스템 (예: 발전소, 기상)</td></tr>
</tbody></table>
<p>[표 12.3.2] PatchTST와 iTransformer의 구조적 비교 및 특성 분석 1</p>
<ol>
<li>채널 독립성(Channel Independence) vs. 다변량 상관관계(Multivariate Correlation):</li>
</ol>
<p>PatchTST는 “변수 간의 관계는 불필요한 노이즈일 가능성이 높다“는 전제 하에 각 변수를 독립적으로 예측한다. 이는 ETT(전력 변압기) 데이터셋이나 교통 데이터와 같이 변수 간 동기화가 불분명하거나 개별 패턴이 지배적인 데이터에서 압도적인 성능을 보인다.1 반면, iTransformer는 “변수 간의 관계야말로 시스템을 이해하는 핵심“이라고 본다. 어텐션을 통해 변수 간의 관계를 동적으로 학습하므로, 변수들이 물리적으로 강하게 결합된 시스템이나 관측되지 않은 잠재 요인이 많은 경우(예: 기상 예측)에 유리하다.23 최근 연구에서는 이 두 가지 접근법을 결합하려는 시도(예: CT-PatchTST)도 나타나고 있다.13</p>
<ol start="2">
<li>트랜스포머의 역할 재정의:</li>
</ol>
<p>두 모델 모두 트랜스포머를 단순한 ’순차적 데이터 처리기(Sequential Processor)’로 보지 않는다. PatchTST에서 트랜스포머는 패치들 사이의 문맥을 연결하는 ‘비선형 매핑 함수’ 역할을, iTransformer에서는 변수들 사이의 그래프 구조를 학습하고 시계열의 전역적 특징을 추출하는 ‘표현 학습기(Representation Learner)’ 역할을 한다. 이는 NLP에서의 트랜스포머가 문법적 순서를 넘어 심층적인 의미적 관계를 학습하는 것과 궤를 같이한다.</p>
<ol start="3">
<li>성능 및 일반화(Generalization):</li>
</ol>
<p>실험 결과에 따르면, PatchTST는 일반적으로 안정적이고 높은 성능을 보이며 특히 룩백 윈도우가 길어질수록 성능이 향상되는 경향이 뚜렷하다.20 iTransformer는 변수의 개수가 많은 데이터셋이나 변수 간 상관관계가 뚜렷한 데이터셋에서 PatchTST를 능가하거나 대등한 성능을 보이며, 특히 일반화 능력—훈련하지 않은 새로운 변수(Unseen Variates)에 대한 예측—에서 두각을 나타낸다. 이는 iTransformer가 변수별로 특화된 파라미터를 학습하는 것이 아니라, 변수 간의 관계를 학습하기 때문이다.1 그러나 변수 간 관계가 희박한 데이터셋에서는 PatchTST의 채널 독립 방식이 더 우세한 경향이 있어, 두 모델은 상호 보완적인 관계에 있다.1</p>
<h2>5.  결론: 시계열 트랜스포머의 르네상스</h2>
<p>PatchTST와 iTransformer의 등장은 선형 모델(DLinear)에 의해 촉발된 트랜스포머의 위기를 기회로 전환시켰다. 이들은 트랜스포머 아키텍처 자체가 문제가 아니라, <strong>데이터를 어떻게 토큰화하고 어떤 차원에서 어텐션을 적용할 것인가</strong>가 문제였음을 증명했다. PatchTST는 시계열을 ’패치’라는 의미론적 단위로 격상시켜 계산 효율성과 예측 정확도를 동시에 잡았고, iTransformer는 기존의 통념을 뒤집는 차원 역전을 통해 트랜스포머를 강력한 다변량 상관관계 분석기로 탈바꿈시켰다.</p>
<p>결과적으로 이 두 모델은 트랜스포머가 시계열 데이터에서도 여전히 가장 강력한(SOTA) 백본임을 재확인시켜 주었으며, 향후 시계열 파운데이션 모델(Time Series Foundation Model)로 나아가는 중요한 기술적 토대를 마련했다.4 이제 우리는 시계열 데이터에서도 ’트랜스포머 싱귤래리티’가 도래했음을 인정해야 한다. 텍스트와 이미지를 넘어, 시간의 흐름을 다루는 영역에서도 어텐션은 여전히 유효하며, 다만 그 어텐션이 ‘어디를(Where)’ 그리고 ‘무엇을(What)’ 바라보아야 하는지에 대한 우리의 이해가 깊어졌을 뿐이다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>CSformer: Combining Channel Independence and Mixing for Robust Multivariate Time Series Forecasting - arXiv, https://arxiv.org/html/2312.06220v2</li>
<li>LTSF-Linear: Embarrassingly simple time series forecasting models | Neural Aspect, https://www.neuralaspect.com/posts/linear-ltsf</li>
<li>ITRANSFORMER: INVERTED TRANSFORMERS ARE EFFECTIVE FOR TIME SERIES FORECASTING - ICLR Proceedings, https://proceedings.iclr.cc/paper_files/paper/2024/file/2ea18fdc667e0ef2ad82b2b4d65147ad-Paper-Conference.pdf</li>
<li>Deep Dive into Transformer Architectures for Long-Term Time Series Forecasting - arXiv, https://arxiv.org/html/2507.13043v1</li>
<li>Transformers for Time Series Forecasting | by Serana AI - Medium, https://medium.com/@serana.ai/transformers-for-time-series-forecasting-e5e0327e78be</li>
<li>DeformableTST: Transformer for Time Series Forecasting without Over-reliance on Patching - NIPS papers, https://proceedings.neurips.cc/paper_files/paper/2024/file/a0b1082fc7823c4c68abcab4fa850e9c-Paper-Conference.pdf</li>
<li>A Time Series is Worth 64 Words: Long-term Forecasting with …, https://openreview.net/forum?id=Jbdc0vTOcol</li>
<li>PatchTST: Turning 64 Words Into a Time Series Prediction | by Dong-Keon Kim | Medium, https://medium.com/@kdk199604/patchtst-turning-64-words-into-a-time-series-prediction-7f99477933c1</li>
<li>Why Do Transformers Fail to Forecast Time Series In-Context? - OpenReview, https://openreview.net/forum?id=eBCk0nXz17</li>
<li>iTransformer: Inverted Transformers Are Effective for Time Series Forecasting - OpenReview, https://openreview.net/forum?id=JePfAI8fah</li>
<li>Are Self-Attentions Effective for Time Series Forecasting? - OpenReview, https://openreview.net/forum?id=iN43sJoib7</li>
<li>This is an offical implementation of PatchTST: A Time Series is Worth 64 Words: Long-term Forecasting with Transformers. - GitHub, https://github.com/yuqinie98/PatchTST</li>
<li>CT-PatchTST: Channel-Time Patch Time-Series Transformer for Long-Term Renewable Energy Forecasting - arXiv, https://arxiv.org/html/2501.08620v1</li>
<li>Diffusion Auto-regressive Transformer for Effective Self-supervised Time Series Forecasting, https://arxiv.org/html/2410.05711v1</li>
<li>Exploring Tokenization Techniques to Optimize Patch-Based Time-Series Transformers - Dartmouth Digital Commons, https://digitalcommons.dartmouth.edu/cgi/viewcontent.cgi?article=1030&amp;context=cs_senior_theses</li>
<li>A Time Series is Worth 64 Words: Long-term Forecasting with Transformers - arXiv, https://arxiv.org/abs/2211.14730</li>
<li>Why Attention Fails: The Degeneration of Transformers into MLPs in Time Series Forecasting - arXiv, https://arxiv.org/html/2509.20942v1</li>
<li>PatchTST: A Breakthrough in Time Series Forecasting - Data Science With Marco, https://www.datasciencewithmarco.com/blog/patchtst-a-breakthrough-in-time-series-forecasting</li>
<li>Understanding the PatchTST Model for Time Series Prediction - SignalPop, https://www.signalpop.com/2023/11/06/understanding-the-patchtst-model-for-time-series-prediction/</li>
<li>Long-term Forecasting with Transformers - arXiv, https://arxiv.org/pdf/2211.14730</li>
<li>transformers/src/transformers/models/patchtst/configuration_patchtst.py at main - GitHub, https://github.com/huggingface/transformers/blob/main/src/transformers/models/patchtst/configuration_patchtst.py</li>
<li>Official implementation for “iTransformer: Inverted Transformers Are Effective for Time Series Forecasting” (ICLR 2024 Spotlight) - GitHub, https://github.com/thuml/iTransformer</li>
<li>iTransformer: Better Time Series Forecasting by Flipping the Axis - Medium, https://medium.com/@kdk199604/itransformer-better-time-series-forecasting-by-flipping-the-axis-759b86a463c7</li>
<li>iTransformer: The Latest Breakthrough in Time Series Forecasting, https://www.datasciencewithmarco.com/blog/itransformer-the-latest-breakthrough-in-time-series-forecasting</li>
<li>iTransformer: Inverted Transformers Are Effective for Time Series Forecasting - Liner, https://liner.com/review/itransformer-inverted-transformers-are-effective-for-time-series-forecasting</li>
<li>Exploring diffusion-based approaches for the generation … - POLITesi, https://www.politesi.polimi.it/retrieve/fa3712a9-d83b-477f-a9fc-a2da43207520/2025_07_Tripodi_Tesi.pdf</li>
<li>Explaining the need for positional encodings in Transformers | by Ngieng Kianyew - Medium, https://medium.com/@ngiengkianyew/explaining-the-need-for-positional-encodings-in-transformers-db4209d4be10</li>
<li>iTransformer: Inverted Transformers Are Effective for Time Series Forecasting - arXiv, https://arxiv.org/html/2310.06625v4</li>
<li>Data Augmentation in Time Series Forecasting through Inverted Framework - arXiv, https://arxiv.org/html/2507.11439v1</li>
<li>Evaluating the Effectiveness of Time Series Transformers for Demand Forecasting in Retail, https://www.mdpi.com/2227-7390/12/17/2728</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>