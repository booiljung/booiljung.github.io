<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.5 피드포워드 네트워크(FFN)와 잔차 연결(Residual Connection)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.5 피드포워드 네트워크(FFN)와 잔차 연결(Residual Connection)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>2.5 피드포워드 네트워크(FFN)와 잔차 연결(Residual Connection)</span></nav>
                </div>
            </header>
            <article>
                <h1>2.5 피드포워드 네트워크(FFN)와 잔차 연결(Residual Connection)</h1>
<p>2025-12-18, G30DR</p>
<p>트랜스포머 아키텍처의 혁신은 단순히 셀프 어텐션(Self-Attention) 메커니즘에만 국한되지 않는다. 어텐션이 시퀀스 내 토큰 간의 관계를 파악하고 정보를 수집하는 ‘신경망의 눈’ 역할을 수행한다면, 그 이후에 배치되는 피드포워드 네트워크(Feed-Forward Network, FFN)와 이를 감싸는 잔차 연결(Residual Connection)은 수집된 정보를 정제하고 모델의 깊이를 확장 가능하게 만드는 ‘신경망의 중추’와 ‘혈관’에 해당한다.1 어텐션 메커니즘만으로는 입력 데이터의 복잡한 비선형 특징을 충분히 학습하기 어려우며, 층이 깊어질수록 발생하는 경사 소실(Vanishing Gradient)의 불안정성은 모델의 수렴을 심각하게 저해하기 때문이다.2 이 장에서는 트랜스포머의 계산 효율성과 표현력을 극대화하는 FFN의 내부 구조와, 심층 신경망 학습의 난제를 해결한 잔차 연결 및 정규화 기법의 결합 원리를 심도 있게 고찰한다.</p>
<h2>1.  피드포워드 네트워크(FFN): 개별 토큰의 비선형 변환과 지식 저장소</h2>
<p>트랜스포머의 각 인코더와 디코더 블록에는 멀티 헤드 어텐션 서브 레이어 이후에 위치하는 포지션 와이즈 피드포워드 네트워크(Position-wise Feed-Forward Network)가 포함되어 있다.1 이 네트워크의 가장 핵심적인 설계 원칙은 시퀀스의 각 위치(Position)에 있는 토큰 벡터들에 대해 동일한 매개변수를 가진 신경망이 독립적으로, 그리고 병렬적으로 적용된다는 점이다.1</p>
<pre><code class="language-mermaid">graph LR
    subgraph "FFN(Feed-Forward Network) Process"
        Input["입력 벡터 x (d_model=512)"]
        W1["1차 선형 변환 (W1) &lt;br/&gt; 차원 확장: 512 -&gt; 2048"]
        Bias1["편향 더하기 (b1)"]
        Act["비선형 활성화 함수 &lt;br/&gt; (ReLU / GeLU)"]
        W2["2차 선형 변환 (W2) &lt;br/&gt; 차원 축소: 2048 -&gt; 512"]
        Bias2["편향 더하기 (b2)"]
        Output["출력 벡터 (d_model=512)"]

        Input --&gt; W1
        W1 --&gt; Bias1
        Bias1 --&gt; Act
        Act --&gt; W2
        W2 --&gt; Bias2
        Bias2 --&gt; Output
    end
    
    style Input fill:#f9f,stroke:#333,stroke-width:2px
    style Act fill:#bbf,stroke:#333,stroke-width:2px
    style Output fill:#f9f,stroke:#333,stroke-width:2px
</code></pre>
<h3>1.1  FFN의 구조적 설계와 수학적 정의</h3>
<p>표준적인 FFN 구조는 두 개의 선형 변환(Linear Transformation)과 그 사이에 위치한 비선형 활성화 함수(Activation Function)로 구성된 2층 퍼셉트론 형태를 띤다.3 이를 수학적으로 정의하면 다음과 같다.<br />
<span class="math math-display">
FFN(x) = \max(0, xW_1 + b_1)W_2 + b_2
</span><br />
여기서 <span class="math math-inline">x</span>는 어텐션 층과 잔차 연결, 레이어 정규화를 거쳐 입력된 <span class="math math-inline">d_{model}</span> 차원의 벡터이며, <span class="math math-inline">W_1</span>과 <span class="math math-inline">W_2</span>는 학습 가능한 가중치 행렬, <span class="math math-inline">b_1</span>과 <span class="math math-inline">b_2</span>는 편향(Bias) 벡터를 의미한다.1 ‘Attention Is All You Need’ 논문의 기본 설정에 따르면, 입력 및 출력 차원인 <span class="math math-inline">d_{model}</span>은 512인 반면, 내부 은닉층의 차원 <span class="math math-inline">d_{ff}</span>는 2048로 설정되어 약 4배의 차원 확장이 일어난다.5 이러한 설계는 입력 벡터로부터 더 고차원적인 특징 형상(Feature)을 추출할 수 있는 풍부한 가중치 공간을 제공하기 위함이다.</p>
<p>FFN이 어텐션 메커니즘과 구별되는 가장 근본적인 차이는 ’토큰 간 상호작용의 완전한 배제’에 있다.3 어텐션은 다른 위치의 정보를 참조하여 현재 토큰의 벡터를 업데이트하지만, FFN은 오직 해당 위치의 벡터 정보만을 사용하여 연산을 수행한다.6 이러한 독립적 구조는 GPU와 같은 병렬 연산 장치에서 극도로 높은 처리 효율을 보여주며, 모델이 시퀀스 전체의 문맥을 파악한 뒤 각 토큰의 의미를 개별적으로 재해석하고 강화하는 단계를 제공한다.1</p>
<h3>1.2  비선형성 주입과 표현력의 확장</h3>
<p>단순한 선형 연산의 반복인 어텐션(내적 및 가중 평균)만으로는 복잡한 데이터 분포를 근사하는 데 한계가 있다.6 FFN은 ReLU(Rectified Linear Unit)와 같은 비선형 활성화 함수를 통해 모델에 비선형성을 주입한다.1 이는 신경망이 선형 결합으로는 표현할 수 없는 고차원적인 함수 관계를 학습 가능하게 하며, 층이 쌓일수록 모델의 표현력을 기하급수적으로 확장시킨다.6 만약 FFN이 제거된다면, 트랜스포머는 사실상 여러 번의 가중 평균 연산을 수행하는 선형 모델에 불과하게 되어 언어의 복잡한 문법적, 의미적 구조를 포착할 수 없게 된다.6</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>차원 변화 (dmodel=512,dff=2048)</strong></th><th><strong>주요 역할</strong></th></tr></thead><tbody>
<tr><td><strong>입력 벡터 (<span class="math math-inline">x</span>)</strong></td><td>512</td><td>어텐션 결과물이 통합된 중간 표현 5</td></tr>
<tr><td><strong>첫 번째 선형 층 (<span class="math math-inline">W_1, b_1</span>)</strong></td><td>512 → 2048</td><td>정보를 고차원 공간으로 투영하여 특징 추출 1</td></tr>
<tr><td><strong>활성화 함수 (<span class="math math-inline">\sigma</span>)</strong></td><td>2048 → 2048</td><td>비선형성 주입 및 특정 뉴런의 활성화 제어 3</td></tr>
<tr><td><strong>두 번째 선형 층 (<span class="math math-inline">W_2, b_2</span>)</strong></td><td>2048 → 512</td><td>확장된 특징을 원래 차원으로 압축 및 통합 3</td></tr>
</tbody></table>
<h2>2.  FFN의 새로운 해석: 키-값 메모리(Key-Value Memory) 가설</h2>
<p>최근의 자연어 처리 연구는 FFN의 역할을 단순한 연산 층 이상으로 해석하기 시작했다. 특히 Geva 등(2021)의 연구는 FFN이 모델이 학습 과정에서 습득한 거대한 ’지식 저장소’로 기능한다는 가설을 제시한다.6 이 관점에 따르면 FFN의 두 선형 층은 각각 ’키(Key)’와 ’값(Value)’의 역할을 수행한다.8</p>
<p><strong>Key-Value Memory Mechanism</strong></p>
<pre><code class="language-mermaid">graph TD
    Token["입력 토큰 벡터"]

    subgraph "Pattern Detection (Key)"
        W1["첫 번째 선형 층 (W1) &lt;br/&gt; '키(Key) 벡터들의 집합'"]
        Detect["특정 텍스트 패턴/문법 구조 감지"]
        Filter["활성화 함수에 의한 필터링 &lt;br/&gt; (높은 점수만 통과)"]
    end

    subgraph "Information Induction (Value)"
        W2["두 번째 선형 층 (W2) &lt;br/&gt; '값(Value) 벡터들의 집합'"]
        Retrieve["감지된 패턴에 대응하는 &lt;br/&gt; 문맥/확률 정보 인출"]
    end

    Result["다음 층으로 전달될 &lt;br/&gt; 강화된 의미 정보"]

    Token --&gt; W1
    W1 --&gt; Detect
    Detect --&gt; Filter
    Filter --&gt; W2
    W2 --&gt; Retrieve
    Retrieve --&gt; Result

style Detect fill:#ff9,stroke:#333
style Retrieve fill:#9f9,stroke:#333
</code></pre>
<h3>2.1  패턴 감지기로서의 첫 번째 선형 층</h3>
<p>FFN의 첫 번째 가중치 행렬 <span class="math math-inline">W_1</span>의 각 행은 일종의 ’키 벡터’로 간주될 수 있다.8 입력 토큰 벡터 <span class="math math-inline">x</span>가 <span class="math math-inline">W_1</span>과 곱해질 때, 이는 입력 벡터와 수많은 키 벡터들 사이의 유사도를 측정하는 과정과 같다.6 훈련 데이터에 존재하는 특정 텍스트 패턴(예: 문법적 구조, 특정 단어의 조합, 사실적 관계)이 입력될 때, 그에 대응하는 가중치 벡터가 높은 활성화 값을 갖게 된다.8 즉, <span class="math math-inline">W_1</span>은 입력 시퀀스에서 특정한 의미적 또는 구조적 패턴을 탐지하는 필터들의 집합체인 셈이다.6</p>
<h3>2.2  정보 유도기로서의 두 번째 선형 층</h3>
<p>활성화 함수 이후에 적용되는 두 번째 가중치 행렬 <span class="math math-inline">W_2</span>는 감지된 패턴에 대응하는 ’값 벡터’들의 집합이다.8 첫 번째 층에서 특정 패턴이 감지되어 높은 점수를 받으면, 그에 대응하는 <span class="math math-inline">W_2</span>의 성분들이 최종 출력 벡터에 큰 비중으로 더해진다.8 이는 감지된 패턴을 바탕으로 다음 층에서 사용할 문맥적 의미를 보강하거나, 언어 모델의 경우 다음에 올 단어의 확률 분포를 유도하는 정보적 기여를 수행한다.6</p>
<p>이 가설은 트랜스포머 파라미터의 약 66% 이상이 FFN에 집중되어 있는 현상을 명쾌하게 설명해 준다.6 어텐션은 정보를 ’전달’하는 통로라면, FFN은 정보를 ’저장’하고 필요할 때 꺼내 쓰는 백과사전 역할을 수행하는 것이다.8</p>
<h2>3.  활성화 함수의 진화: ReLU에서 SwiGLU까지</h2>
<p>트랜스포머 아키텍처의 성능 향상은 FFN 내부의 비선형 활성화 함수의 진화와 궤를 같이한다. 초기 모델에서 사용된 ReLU는 계산의 간결함에도 불구하고 ‘죽은 ReLU(Dead ReLU)’ 문제와 같은 한계가 명확했다.9</p>
<pre><code class="language-mermaid">graph TD
    subgraph "SwiGLU Architecture"
        InputX["입력 벡터 x"]
        
        subgraph "Gate Path"
            LinearW["선형 변환 (W)"]
            SwishAct["Swish 활성화 함수"]
            GateOut["게이트 값 (0~1 조절)"]
        end
        
        subgraph "Value Path"
            LinearV["선형 변환 (V)"]
            ValueOut["선형 정보 유지"]
        end
        
        ElementMult["원소별 곱 (Element-wise Product) &lt;br/&gt; '선택적 정보 통과'"]
        LinearOut["출력 선형 변환 (Wo)"]
        FinalOut["SwiGLU 출력"]

        InputX --&gt; LinearW
        LinearW --&gt; SwishAct
        SwishAct --&gt; GateOut
        
        InputX --&gt; LinearV
        LinearV --&gt; ValueOut
        
        GateOut --&gt; ElementMult
        ValueOut --&gt; ElementMult
        
        ElementMult --&gt; LinearOut
        LinearOut --&gt; FinalOut
    end

    style ElementMult fill:#f96,stroke:#333,stroke-width:4px
</code></pre>
<h3>3.1  GeLU (Gaussian Error Linear Unit)의 도입</h3>
<p>BERT 이후 표준으로 자리 잡은 GeLU는 입력을 단순히 0에서 자르는 대신, 표준 정규 분포의 누적 분포 함수를 사용하여 입력을 가중치 있게 조절한다.11<br />
<span class="math math-display">
GELU(x) = x \Phi(x) = x \cdot P(X \le x), \quad X \sim \mathcal{N}(0, 1)
</span><br />
GeLU는 원점 부근에서 매끄러운 곡선을 형성하며, 음수 영역에서도 미세한 기울기를 허용하여 그래디언트의 흐름을 개선한다.11 이러한 부드러운 전이는 심층 신경망의 최적화 과정에서 더 빠른 수렴과 높은 일반화 성능을 제공하며, 특히 대규모 언어 모델의 안정적인 학습에 기여했다.9</p>
<h3>3.2  SwiGLU (Swish Gated Linear Unit): 현대 LLM의 표준</h3>
<p>최근 LLaMA, PaLM, DeepSeek와 같은 최첨단 모델들은 FFN 구조를 일반적인 2층 퍼셉트론에서 게이팅(Gating) 메커니즘이 결합된 SwiGLU 구조로 변경하였다.9 SwiGLU는 두 개의 가중치 행렬을 병렬로 배치하여 하나는 Swish 활성화를 통과시키고, 다른 하나는 선형 값을 유지한 채 둘을 원소별 곱(Hadamard Product)으로 결합한다.9<br />
<span class="math math-display">
SwiGLU(x) = (Swish_{\beta}(xW) \otimes xV)W_o
</span></p>
<table><thead><tr><th><strong>활성화 함수</strong></th><th><strong>수학적 정의</strong></th><th><strong>주요 특징 및 장점</strong></th></tr></thead><tbody>
<tr><td><strong>ReLU</strong></td><td><span class="math math-inline">max(0, x)</span></td><td>연산이 매우 단순하며 희소성 유도에 강점이 있으나 음수 그래디언트 손실 위험 존재 1</td></tr>
<tr><td><strong>GeLU</strong></td><td><span class="math math-inline">x \Phi(x)</span></td><td>확률론적 해석을 기반으로 하며 매끄러운 미분 가능성을 통해 학습 안정성 제공 11</td></tr>
<tr><td><strong>SwiGLU</strong></td><td><span class="math math-inline">(Swish(xW) \otimes xV)</span></td><td>입력에 따른 동적 게이팅을 통해 표현력을 극대화하며 대규모 모델에서 탁월한 성능 입증 9</td></tr>
</tbody></table>
<p>SwiGLU의 게이팅 메커니즘은 특정 정보는 통과시키고 불필요한 정보는 차단하는 ‘선택적 활성화’ 능력을 강화한다.9 이는 모델이 더 정교한 논리 구조를 학습하도록 돕지만, 연산량이 기존 FFN 대비 약 1.5배가량 증가하므로 효율적인 하드웨어 가속이 뒷받침되어야 한다.9</p>
<h2>4.  잔차 연결(Residual Connection): 정보의 고속도로와 학습 안정성</h2>
<p>심층 신경망에서 층이 깊어질수록 입력 정보가 희석되거나 그래디언트가 사라지는 문제는 고질적인 난제였다.2 트랜스포머는 모든 서브 레이어(어텐션 및 FFN) 주위에 잔차 연결(Residual Connection)을 배치함으로써 이 문제를 해결한다.2</p>
<pre><code class="language-mermaid">graph LR
    subgraph "Residual Block Logic"
        Input["입력 x"]
        
        subgraph "Function Path (Learned Residual)"
            SubLayer["서브 레이어 F(x) &lt;br/&gt; (Attention or FFN)"]
            Weight["가중치 연산"]
        end
        
        subgraph "Identity Path (Gradient Highway)"
            Identity["항등 매핑 (Identity Mapping) &lt;br/&gt; x 그대로 전달"]
        end
        
        Add["덧셈 연산 (+) &lt;br/&gt; y = x + F(x)"]
        Next["다음 레이어"]
        
        Input --&gt; SubLayer
        SubLayer --&gt; Weight
        Weight --&gt; Add
        
        Input --&gt; Identity
        Identity --&gt; Add
        Add --&gt; Next
    end
    
    style Identity fill:#afa,stroke:#333,stroke-dasharray: 5 5
    style Add fill:#faa,stroke:#333,stroke-width:2px
</code></pre>
<h3>4.1  잔차 연결의 수학적 필연성</h3>
<p>잔차 연결은 서브 레이어의 입력 <span class="math math-inline">x</span>를 그 출력 <span class="math math-inline">\mathcal{F}(x)</span>에 직접 더해주는 구조를 가진다.12<br />
$$<br />
y = x + \mathcal{F}(x)$<br />
<span class="math math-display">
이러한 항등 매핑(Identity Mapping)은 역전파 과정에서 매우 중요한 수학적 이점을 제공한다.2 체인 룰(Chain Rule)에 의해 하위 층으로 전달되는 그래디언트를 계산하면 다음과 같다.
</span><br />
\frac{\partial y}{\partial x} = I + \frac{\partial \mathcal{F}}{\partial x}<br />
$$<br />
여기서 <span class="math math-inline">I</span>는 단위 행렬(Identity Matrix)이다.13 이 수식의 핵심은 서브 레이어의 가중치가 매우 작아져서 <span class="math math-inline">\frac{\partial \mathcal{F}}{\partial x}</span>가 0에 수렴하더라도, 최소한 1(단위 행렬)의 그래디언트는 유지되어 하위 층으로 전달된다는 점이다.2 이로 인해 트랜스포머는 12개를 넘어 수백 개의 레이어를 쌓아 올려도 정보의 손실 없이 효과적으로 학습을 진행할 수 있다.4</p>
<h3>4.2  잔차 연결이 부여하는 귀납적 편향(Inductive Bias)</h3>
<p>잔차 연결은 모델이 ’전체 정보’를 새로 만드는 대신 ’입력 대비 변화량(Residual)’만을 학습하도록 유도한다.2 이는 네트워크가 입력을 그대로 보존하는 항등 함수를 학습하기 쉽게 만들어주며, 학습 초기 단계에서 모델이 급격히 불안정해지는 것을 방지한다.2 또한, 각 층이 이전 층의 결과물을 점진적으로 개선하는 방식으로 작동하게 하여, 모델의 계층적 표현 학습을 돕는다.8</p>
<h2>5.  Add &amp; Norm: 레이어 정규화의 위치에 따른 패러다임 변화</h2>
<p>트랜스포머 블록의 설계에서 잔차 연결과 레이어 정규화(Layer Normalization)의 결합 방식은 모델의 학습 동역학에 결정적인 영향을 미친다.13</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Post-LN (Original Transformer)"
        Input1["입력 x"]
        SubLayer1["서브 레이어 연산"]
        Add1["잔차 연결 (+)"]
        Norm1["Layer Normalization"]
        Output1["출력 x_new"]

        Input1 --&gt; SubLayer1
        SubLayer1 --&gt; Add1
        Input1 --&gt;|Identity| Add1
        Add1 --&gt; Norm1
        Norm1 --&gt; Output1
    end

    subgraph "Pre-LN (Modern Standard: GPT, LLaMA)"
        Input2["입력 x"]
        Norm2["Layer Normalization"]
        SubLayer2["서브 레이어 연산"]
        Add2["잔차 연결 (+) &lt;br/&gt; '순수 항등 경로 보존'"]
        Output2["출력 x_new"]

        Input2 --&gt; Norm2
        Norm2 --&gt; SubLayer2
        SubLayer2 --&gt; Add2
        Input2 --&gt;|Clean Identity Path| Add2
        Add2 --&gt; Output2
    end

    style Input2 fill:#dff,stroke:#333
    style Add2 fill:#f99,stroke:#333
    style Norm1 fill:#ccc,stroke:#333
    style Norm2 fill:#aff,stroke:#333
</code></pre>
<h3>5.1  Post-LN: 원형 트랜스포머의 설계와 도전</h3>
<p>초기 트랜스포머(Vaswani et al., 2017)는 서브 레이어 연산과 잔차 연결을 수행한 직후에 정규화를 적용하는 Post-LN 방식을 사용했다.4<br />
<span class="math math-display">
x_{\ell+1} = LayerNorm(x_\ell + \mathcal{F}_\ell(x_\ell))
</span><br />
Post-LN은 각 층의 출력을 엄격하게 정규화하여 출력값의 크기가 폭주하는 것을 막고, 이론적으로는 더 강력한 표현력을 가질 수 있는 잠재력이 있다.4 그러나 수학적으로 분석했을 때, 그래디언트가 정규화 층의 아핀 변환(Affine Transform)을 반복적으로 통과하면서 깊은 층에서 얕은 층으로 갈수록 변동성이 커지는 불안정성을 유발한다.4 이 때문에 Post-LN 구조의 모델은 학습 초기 단계에서 매우 작은 학습률로 시작하는 웜업(Warmup) 기간이 필수적이며, 하이퍼파라미터 설정에 극도로 민감하다.13</p>
<h3>5.2  Pre-LN: 안정성을 위한 현대적 표준</h3>
<p>학습의 안정성을 극대화하기 위해 GPT-2 이후 대부분의 현대적 트랜스포머는 정규화를 서브 레이어 입력 직전에 수행하는 Pre-LN 구조를 채택한다.12<br />
<span class="math math-display">
x_{\ell+1} = x_\ell + \mathcal{F}_\ell(LayerNorm(x_\ell))
</span><br />
Pre-LN의 가장 큰 장점은 잔차 연결이 정규화 층의 간섭 없이 순수한 ’항등 경로(Identity Path)’를 유지한다는 점이다.13 이는 그래디언트가 하위 층까지 손실 없이 전달되게 하여, 웜업 없이도 안정적인 학습을 가능하게 하며 대규모 모델의 수렴 속도를 비약적으로 높였다.13</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Post-LN (Original)</strong></th><th><strong>Pre-LN (Modern)</strong></th></tr></thead><tbody>
<tr><td><strong>정규화 위치</strong></td><td>잔차 연결 덧셈 이후 5</td><td>서브 레이어 연산 직전 12</td></tr>
<tr><td><strong>그래디언트 안정성</strong></td><td>층이 깊어질수록 변동성 확대 및 소실 위험 4</td><td>순수 항등 경로를 통한 안정적인 흐름 13</td></tr>
<tr><td><strong>학습 편의성</strong></td><td>정교한 LR 웜업 및 초기화 필수 13</td><td>웜업 의존도 낮음, 하이퍼파라미터에 강건함 13</td></tr>
<tr><td><strong>표현력 잠재력</strong></td><td>성공 시 이론적으로 더 높은 성능 가능 4</td><td>깊은 층에서 레이어 기여도 감소 위험 (Representation Collapse) 13</td></tr>
</tbody></table>
<p>최근 연구들은 Pre-Norm 구조에서 발생하는 ‘표현력 붕괴(Representation Collapse)’—즉, 층이 깊어질수록 각 층의 기여도가 작아져 추가적인 층이 의미가 없어지는 현상—을 방지하기 위해 RMSNorm이나 정교한 가중치 스케일링 기법을 결합하여 성능과 안정성의 균형을 꾀하고 있다.9</p>
<h2>6.  FFN의 효율화와 파라미터 중복성: One Wide FFN</h2>
<p>트랜스포머 모델의 파라미터 중 FFN이 차지하는 비중은 절대적이지만, 동시에 이 층들 사이에 상당한 중복성이 존재한다는 비판도 제기되어 왔다.14 애플(Apple)의 연구진이 제안한 ‘One Wide FFN’ 연구는 이러한 중복성을 이용한 아키텍처 혁신을 보여준다.14</p>
<p>이 연구는 모든 레이어마다 별개의 FFN을 두는 대신, 인코더 전체에서 단 하나의 ‘넓은(Wide)’ FFN을 공유하고 디코더의 FFN을 아예 제거하더라도 모델의 성능이 거의 하락하지 않음을 입증했다.14 이는 FFN이 수행하는 ‘지식 저장’ 기능이 특정 위치나 레이어에 고착된 것이 아니라, 모델 전체에서 공통으로 활용될 수 있는 성질의 것임을 시사한다.14 이러한 접근법은 추론 시 메모리 대역폭을 획기적으로 절감하며, 특히 모바일 기기나 엣지 컴퓨팅 환경에서의 트랜스포머 배포에 큰 기여를 하고 있다.14</p>
<pre><code class="language-mermaid">graph LR
    subgraph "Traditional Transformer"
        L1["Encoder Layer 1"] --&gt; FFN1["FFN (독립 파라미터)"]
        L2["Encoder Layer 2"] --&gt; FFN2["FFN (독립 파라미터)"]
        L3["Encoder Layer 3"] --&gt; FFN3["FFN (독립 파라미터)"]
    end

    subgraph "One Wide FFN (Apple)"
        EL1["Encoder Layer 1"]
        EL2["Encoder Layer 2"]
        EL3["Encoder Layer 3"]
        
        SharedFFN["Shared Wide FFN &lt;br/&gt; '거대 지식 저장소 공유'"]
        
        EL1 --&gt; SharedFFN
        EL2 --&gt; SharedFFN
        EL3 --&gt; SharedFFN
        
        SharedFFN --&gt; EL1_Out["Layer 1 Output"]
        SharedFFN --&gt; EL2_Out["Layer 2 Output"]
        SharedFFN --&gt; EL3_Out["Layer 3 Output"]
    end
    
    style SharedFFN fill:#ff9,stroke:#333,stroke-width:4px
</code></pre>
<h2>7.  결론</h2>
<p>피드포워드 네트워크(FFN)와 잔차 연결은 트랜스포머가 단순한 통계적 언어 처리 모델을 넘어 복잡한 추론과 지식 활용 능력을 갖춘 거대 인공지능으로 진화하게 만든 핵심 동력이다. FFN은 비선형 변환과 키-값 메모리 메커니즘을 통해 언어의 심층적인 의미 구조를 저장하고 재구성하며, 잔차 연결과 정규화 기법은 이러한 연산이 수백 개의 계층 구조 속에서도 무너지지 않고 수행될 수 있는 수치적 안정성을 보장한다.2</p>
<p>특히 ReLU에서 SwiGLU로의 진화, Post-LN에서 Pre-LN으로의 아키텍처 변화는 이론적 완결성보다 ’규모의 확장(Scaling)’이라는 실용적 목적에 부합하는 방향으로 전개되어 왔다.9 이제 트랜스포머의 블록 구조는 성숙 단계에 접어들었으며, 연구자들은 여기서 한 걸음 더 나아가 FFN의 파라미터 효율성을 극대화하거나 MoE(Mixture of Experts)와 같은 동적 활성화 구조로 확장하는 단계에 이르렀다.6 이러한 기초 위에 트랜스포머는 2025년 현재, 단순한 텍스트 처리를 넘어 멀티모달 데이터를 통합하고 에이전트로서 행동하는 지능의 싱귤래리티를 향해 나아가고 있다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Attention Is All You Need : A Complete Guide to Transformers - Medium, https://medium.com/@alejandro.itoaramendia/attention-is-all-you-need-a-complete-guide-to-transformers-8670a3f09d02</li>
<li>Normalization and Residual Connections - Tutorials Point, https://www.tutorialspoint.com/gen-ai/normalization-and-residual-connections.htm</li>
<li>Transformer (deep learning) - Wikipedia, https://en.wikipedia.org/wiki/Transformer_(deep_learning)</li>
<li>On Layer Normalizations and Residual Connections in Transformers - OpenReview, https://openreview.net/attachment?id=oDDqFpK5Ru1&amp;name=pdf</li>
<li>Attention Is All You Need - arXiv, https://arxiv.org/html/1706.03762v7</li>
<li>What is the role of feed forward layer in Transformer Neural Network architecture?, https://stats.stackexchange.com/questions/485910/what-is-the-role-of-feed-forward-layer-in-transformer-neural-network-architectur</li>
<li>The Intuition Behind Transformers - Attention is All You Need - Towards Data Science, https://towardsdatascience.com/the-intuition-behind-transformers-attention-is-all-you-need-393b5cfb4ada/</li>
<li>Transformer Feed-Forward Layers Are Key-Value … - ACL Anthology, https://aclanthology.org/2021.emnlp-main.446.pdf</li>
<li>SwiGLU Activation in Transformer Models - Emergent Mind, https://www.emergentmind.com/topics/swiglu-activation</li>
<li>
<ol start="21">
<li>Activation Functions - Aussie AI, https://www.aussieai.com/book/ch21-activation-functions</li>
</ol>
</li>
<li>Beyond ReLU: Discovering the Power of SwiGLU | by heping_LU - Medium, <a href="https://medium.com/@jiangmen28/beyond-relu-discovering-the-power-of-swiglu-%E8%B6%85%E8%B6%8A-relu-%E5%8F%91%E7%8E%B0-swiglu-%E7%9A%84%E5%8A%9B%E9%87%8F-9dbc7d8258bf">https://medium.com/@jiangmen28/beyond-relu-discovering-the-power-of-swiglu-%E8%B6%85%E8%B6%8A-relu-%E5%8F%91%E7%8E%B0-swiglu-%E7%9A%84%E5%8A%9B%E9%87%8F-9dbc7d8258bf</a></li>
<li>Residual connections and layer normalization - Build an LLM from scratch with MAX, https://llm.modular.com/step_08.html</li>
<li>Pre-Norm Residual Connections in Transformers - Emergent Mind, https://www.emergentmind.com/topics/pre-norm-residual-connections-prenorm</li>
<li>One Wide Feedforward is All You Need - Apple Machine Learning …, https://machinelearning.apple.com/research/one-wide-ffn</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>