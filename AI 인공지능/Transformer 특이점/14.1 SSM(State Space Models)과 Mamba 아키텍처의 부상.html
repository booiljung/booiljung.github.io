<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:14.1 SSM(State Space Models)과 Mamba 아키텍처의 부상</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>14.1 SSM(State Space Models)과 Mamba 아키텍처의 부상</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>14.1 SSM(State Space Models)과 Mamba 아키텍처의 부상</span></nav>
                </div>
            </header>
            <article>
                <h1>14.1 SSM(State Space Models)과 Mamba 아키텍처의 부상</h1>
<p>2025-12-23, G30DR</p>
<h2>1.  서론: 컴퓨팅 효율성과 시퀀스 모델링의 새로운 패러다임</h2>
<p>2017년 구글(Google)의 ‘Attention Is All You Need’ 논문이 발표된 이래, 인공지능(AI) 연구의 지형은 트랜스포머(Transformer) 아키텍처에 의해 완전히 재편되었다. 자연어 처리(NLP)를 넘어 컴퓨터 비전(CV), 강화 학습, 생물정보학에 이르기까지 트랜스포머는 그야말로 ’싱귤래리티(Singularity)’를 견인하는 핵심 엔진으로 작동해 왔다. 그러나 모델의 파라미터가 수천억 개를 넘어서고, 처리해야 할 문맥(Context)의 길이가 수십만, 수백만 토큰으로 확장됨에 따라 트랜스포머 아키텍처가 가진 태생적 한계가 수면 위로 부상하기 시작했다. 이른바 <span class="math math-inline">O(N^2)</span>의 저주라 불리는, 시퀀스 길이의 제곱에 비례하는 연산 복잡도와 <span class="math math-inline">O(N)</span>으로 증가하는 KV 캐시(Key-Value Cache) 메모리 병목 현상이다.1</p>
<p>책 ’트랜스포머 싱귤래리티’의 14.1장은 이러한 병목을 돌파할 가장 유력한 대안으로 상태 공간 모델(State Space Models, SSM)과 그 진화형인 Mamba(맘바) 아키텍처를 지목한다. 본 보고서는 해당 챕터의 내용을 심층적으로 확장하여, 고전 제어 이론에서 출발한 SSM이 어떻게 현대 딥러닝의 최전선으로 복귀했는지, 그리고 Mamba 아키텍처가 어떻게 하드웨어의 물리적 특성과 알고리즘적 효율성을 결합하여 ‘선형 시간(Linear Time)’ 모델링의 혁명을 이뤄냈는지 분석한다. 또한, Mamba-1에서 시작하여 Mamba-2(SSD), Mamba-3, 그리고 최신 하이브리드 모델인 Jamba와 Nemotron-H에 이르는 기술적 진보의 궤적을 추적하고, 이것이 향후 인공지능 인프라와 모델링 방법론에 미칠 파급력을 규명한다.</p>
<h2>2.  시퀀스 모델링의 역사와 트랜스포머의 한계</h2>
<h3>2.1  순환신경망(RNN)의 흥망성쇠</h3>
<p>딥러닝 초기, 시퀀스 데이터를 처리하는 표준은 순환신경망(RNN)이었다. RNN은 현재의 입력 <span class="math math-inline">x_t</span>와 이전 시점의 은닉 상태 <span class="math math-inline">h_{t-1}</span>을 결합하여 현재의 상태 <span class="math math-inline">h_t</span>를 갱신하는 구조를 가진다. 이 방식은 시퀀스 길이에 관계없이 고정된 크기의 상태 벡터(Fixed-size State)만을 유지하면 되므로, 추론 시 <span class="math math-inline">O(1)</span>의 시간 복잡도와 메모리 효율성을 자랑했다.<br />
<span class="math math-display">
h_t = \sigma(W_h h_{t-1} + W_x x_t + b)
</span><br />
그러나 RNN은 치명적인 단점을 안고 있었다. 첫째, <strong>기울기 소실(Vanishing Gradient)</strong> 문제로 인해 긴 시퀀스의 정보를 장기간 보존하지 못했다. LSTM(Long Short-Term Memory)과 GRU(Gated Recurrent Unit)가 게이팅 메커니즘을 도입하여 이를 일부 완화했지만, 근본적인 해결책은 되지 못했다. 둘째, **순차적 의존성(Sequential Dependency)**으로 인해 학습 시 병렬 처리가 불가능했다. <span class="math math-inline">h_t</span>를 계산하기 위해서는 반드시 <span class="math math-inline">h_{t-1}</span>이 계산되어야 하므로, GPU와 같은 병렬 하드웨어의 성능을 온전히 활용할 수 없었다.3</p>
<h3>2.2  트랜스포머의 등장과 2차 복잡도의 벽</h3>
<p>트랜스포머는 RNN의 순차적 처리 방식을 버리고, 전체 시퀀스를 한꺼번에 처리하는 병렬화 전략을 취했다. 어텐션(Attention) 메커니즘은 시퀀스 내의 모든 토큰 쌍(Pair) 간의 상호작용을 계산하여 <span class="math math-inline">N \times N</span> 크기의 어텐션 맵을 생성한다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
이 방식은 장거리 의존성(Long-range dependency)을 포착하는 데 탁월한 성능을 보였으며, GPU 병렬 연산에 최적화되어 있어 대규모 언어 모델(LLM)의 폭발적인 성장을 이끌었다. 그러나 시퀀스 길이 <span class="math math-inline">N</span>이 길어질수록 연산량은 <span class="math math-inline">N^2</span>으로 급증한다. 예를 들어, 문맥 길이가 2배 늘어나면 연산량은 4배가 된다. 이는 10만 토큰 이상의 긴 문서를 처리하거나, DNA 염기서열과 같은 초장문 데이터를 분석하는 데 있어 넘기 힘든 물리적 장벽으로 작용했다.1</p>
<p>이러한 배경 속에서 연구자들은 “RNN의 효율성(선형 복잡도)과 트랜스포머의 성능(병렬 학습 및 장기 기억)을 동시에 달성할 수 없는가?“라는 질문을 던지게 되었고, 그 해답을 딥러닝이 아닌 고전 제어 공학의 **상태 공간 모델(SSM)**에서 찾기 시작했다.</p>
<h2>3.  구조적 상태 공간 모델(Structured State Space Models)의 이론적 토대</h2>
<p>SSM은 본래 물리 시스템이나 신호 처리를 모델링하기 위해 1960년대부터 사용된 개념이다. 이를 딥러닝의 시퀀스 모델링에 접목하려는 시도는 연속 시간(Continuous-time)의 동역학을 이산적인 데이터 처리에 활용하려는 혁신적인 접근이었다.</p>
<h3>3.1  연속 시간 시스템과 미분 방정식</h3>
<p>SSM의 기본 골격은 입력을 <span class="math math-inline">N</span>차원 잠재 상태(Latent State) <span class="math math-inline">h(t)</span>로 매핑하고, 이를 다시 출력 <span class="math math-inline">y(t)</span>로 변환하는 선형 상미분 방정식(ODE)으로 정의된다.<br />
<span class="math math-display">
h&#39;(t) = \mathbf{A}h(t) + \mathbf{B}x(t)
</span></p>
<p><span class="math math-display">
y(t) = \mathbf{C}h(t) + \mathbf{D}x(t)
</span></p>
<p>여기서 <span class="math math-inline">\mathbf{A}</span>는 상태 전이 행렬(State Transition Matrix), <span class="math math-inline">\mathbf{B}</span>는 입력 행렬, <span class="math math-inline">\mathbf{C}</span>는 출력 행렬, <span class="math math-inline">\mathbf{D}</span>는 직접 연결(Skip Connection)을 의미한다. 이 시스템은 입력 신호의 전체 이력을 상태 <span class="math math-inline">h(t)</span>에 압축적으로 저장한다. 트랜스포머가 과거의 모든 토큰(History)을 KV 캐시에 원본 그대로 저장하는 것과 달리, SSM은 수학적 모델을 통해 정보를 압축된 상태 벡터로 요약한다는 점에서 차이가 있다.6</p>
<h3>3.2  이산화(Discretization): 연속에서 디지털로</h3>
<p>텍스트나 이미지와 같은 데이터는 이산적(Discrete)이다. 따라서 연속 시간 모델인 SSM을 딥러닝에 적용하기 위해서는 <strong>이산화(Discretization)</strong> 과정이 필수적이다. 이산화는 시간 간격 <span class="math math-inline">\Delta</span>(Delta)를 도입하여 미분 방정식을 점화식(Recurrence)으로 변환하는 과정이다.</p>
<p>주로 사용되는 방식은 **Zero-Order Hold (ZOH)**이다. 이는 시간 간격 <span class="math math-inline">\Delta</span> 동안 입력 <span class="math math-inline">x(t)</span>가 일정하게 유지된다고 가정하는 방식이다. 이를 통해 연속 파라미터 <span class="math math-inline">(\mathbf{A}, \mathbf{B})</span>는 다음과 같이 이산 파라미터 <span class="math math-inline">(\overline{\mathbf{A}}, \overline{\mathbf{B}})</span>로 변환된다.9<br />
<span class="math math-display">
\overline{\mathbf{A}} = \exp(\Delta \mathbf{A})
</span></p>
<p><span class="math math-display">
\overline{\mathbf{B}} = (\Delta \mathbf{A})^{-1}(\exp(\Delta \mathbf{A}) - \mathbf{I}) \cdot \Delta \mathbf{B}
</span></p>
<p>이산화된 식은 다음과 같은 형태를 띠며, 이는 RNN의 구조와 정확히 일치한다.<br />
<span class="math math-display">
h_t = \overline{\mathbf{A}}h_{t-1} + \overline{\mathbf{B}}x_t
</span></p>
<p><span class="math math-display">
y_t = \mathbf{C}h_t
</span></p>
<p>여기서 <span class="math math-inline">\Delta</span>는 모델이 입력을 얼마나 세밀하게 샘플링할지를 결정하는 중요한 파라미터가 된다. <span class="math math-inline">\Delta</span>가 크면 현재 입력에 더 크게 반응하고, 작으면 이전 상태의 기억을 더 오래 보존하는 경향을 보인다.7</p>
<h3>3.3  S4 (Structured State Space): 효율성의 돌파구</h3>
<p>단순한 SSM을 딥러닝에 적용했을 때는 성능이 좋지 않았다. 특히 상태 행렬 <span class="math math-inline">\mathbf{A}</span>를 무작위로 초기화할 경우, 기울기 소실 문제가 발생하거나 장기 기억을 유지하지 못했다. 이를 해결하기 위해 등장한 것이 **S4 (Structured State Space Sequence Model)**이다.</p>
<p>S4의 핵심 기여는 두 가지다.</p>
<ol>
<li><strong>HiPPO 행렬 초기화:</strong> <span class="math math-inline">\mathbf{A}</span> 행렬을 <strong>HiPPO (High-order Polynomial Projection Operators)</strong> 이론에 기반하여 초기화했다. 이는 과거의 신호들을 다항식 기저(Polynomial Basis)로 투영하여 최적으로 압축하는 수학적 원리이다. 이를 통해 수만 스텝 이전의 정보도 잊지 않고 보존할 수 있는 능력을 갖추게 되었다.5</li>
<li><strong>LTI(선형 시불변) 시스템과 컨볼루션:</strong> S4는 파라미터가 시간에 따라 변하지 않는 <strong>LTI(Linear Time Invariant)</strong> 시스템이다. LTI 시스템에서는 전체 시퀀스에 대한 출력을 입력과 거대한 커널(Kernel) <span class="math math-inline">\bar{K}</span>의 **합성곱(Convolution)**으로 계산할 수 있다.</li>
</ol>
<p><span class="math math-display">
y = x * \bar{K}
</span></p>
<p>이 특성 덕분에 S4는 학습 시에는 **고속 푸리에 변환(FFT)**을 사용하여 <span class="math math-inline">O(N \log N)</span>의 속도로 병렬 처리가 가능하고, 추론 시에는 점화식(RNN 모드)을 사용하여 <span class="math math-inline">O(1)</span>의 속도로 처리할 수 있는 ’이중성’을 확보했다. 이는 RNN의 효율성과 CNN의 병렬성을 동시에 달성한 획기적인 성과였다.4</p>
<p>그러나 S4는 언어 모델링에서 결정적인 한계에 부딪혔다. 바로 <strong>’내용 기반 추론(Content-based Reasoning)’의 부재</strong>였다. LTI 시스템은 모든 토큰을 동일한 역학으로 처리하기 때문에, 문맥에 따라 “이 정보는 중요하니 기억하고, 저 정보는 무시하라“는 식의 선택적 정보 처리가 불가능했다. 이는 텍스트와 같이 문맥 의존성이 강한 데이터에서 트랜스포머를 넘어서지 못하는 원인이 되었다.3</p>
<h2>4.  Mamba-1: 선택적 상태 공간 모델(Selective SSM)과 하드웨어 혁신</h2>
<p>2023년 말 발표된 Mamba는 S4의 한계였던 LTI 제약을 깨고, 입력 데이터에 따라 모델의 파라미터가 동적으로 변하는 **선택 메커니즘(Selection Mechanism)**을 도입함으로써 SSM을 LLM의 반열에 올려놓았다.</p>
<h3>4.1  선택 메커니즘(Selection Mechanism)의 작동 원리</h3>
<p>Mamba의 가장 큰 혁신은 상태 공간 모델의 파라미터 <span class="math math-inline">(\Delta, \mathbf{B}, \mathbf{C})</span>를 입력 <span class="math math-inline">x_t</span>의 함수로 만든 것이다.<br />
<span class="math math-display">
\mathbf{B}_t = \text{Linear}(x_t) \\ \mathbf{C}_t = \text{Linear}(x_t) \\ \Delta_t = \text{Softplus}(\text{Parameter} + \text{Linear}(x_t))
</span><br />
기존 SSM에서는 이 파라미터들이 모든 시점에 대해 고정되어 있었지만, Mamba에서는 매 시점마다 입력값에 따라 달라진다. 이를 통해 모델은 다음과 같은 능력을 갖추게 된다.2</p>
<ul>
<li><strong>정보의 필터링 (Selective Filtering):</strong> <span class="math math-inline">\Delta_t</span>를 조절하여 현재 정보가 상태 <span class="math math-inline">h_t</span>에 얼마나 반영될지를 결정한다. 노이즈나 불필요한 단어는 차단하고, 중요한 키워드는 강하게 반영한다.</li>
<li><strong>문맥의 재설정 (Context Reset):</strong> 문장이나 주제가 바뀔 때 상태를 초기화하거나 급격하게 변경하여 이전 문맥의 간섭을 배제할 수 있다.</li>
</ul>
<p>이러한 메커니즘은 트랜스포머의 어텐션이 쿼리(Query)와 키(Key)의 상호작용을 통해 정보의 가중치를 결정하는 것과 유사한 효과를 낸다. 그러나 Mamba는 거대한 어텐션 행렬을 만들지 않고, 상태 벡터의 압축 과정을 제어함으로써 이를 구현하므로 연산 효율성이 월등히 높다.14</p>
<h3>4.2  하드웨어 인식(Hardware-Aware) 알고리즘: 병렬 스캔</h3>
<p>선택 메커니즘의 도입은 필연적으로 LTI 속성의 상실을 의미했다. 즉, 더 이상 효율적인 <strong>컨볼루션(Convolution) 연산을 사용할 수 없게 된 것</strong>이다. 이는 모델이 다시 느린 RNN과 같은 순차적 처리 방식으로 회귀해야 함을 시사하는 듯했다.</p>
<p>이 난관을 극복하기 위해 Mamba 연구진은 <strong>하드웨어 인식 병렬 스캔(Hardware-Aware Parallel Scan)</strong> 알고리즘을 고안했다.</p>
<ol>
<li><strong>병렬 스캔 (Parallel Scan / Prefix Sum):</strong> 순차적인 점화식 <span class="math math-inline">h_t = A_t h_{t-1} + B_t x_t</span>는 결합 법칙(Associative Property)이 성립한다. 이를 이용하면 <strong>블렐록 스캔(Blelloch Scan)</strong> 알고리즘과 같은 트리 구조의 병렬 연산을 통해 <span class="math math-inline">O(N)</span>이 아닌 <span class="math math-inline">O(\log N)</span> 단계에 전체 상태를 계산할 수 있다.16</li>
<li><strong>커널 퓨전 (Kernel Fusion)과 메모리 계층 최적화:</strong> 현대 GPU는 연산 속도(FLOPs)에 비해 메모리 대역폭(Bandwidth)이 병목이 되는 경우가 많다. Mamba는 이를 고려하여, 용량이 크지만 느린 **HBM (High Bandwidth Memory)**과 용량은 작지만 빠른 <strong>SRAM</strong>을 전략적으로 활용한다.</li>
</ol>
<ul>
<li>입력 데이터와 파라미터를 HBM에서 SRAM으로 로드한다.</li>
<li>SRAM 내부에서 병렬 스캔을 수행하여 중간 상태를 계산하고 출력값만 HBM에 쓴다.</li>
<li>거대한 중간 상태 <span class="math math-inline">h_t</span>를 HBM에 기록하지 않음으로써 메모리 입출력(I/O) 비용을 획기적으로 줄였다.12</li>
</ul>
<p>이러한 최적화 덕분에 Mamba는 시변(Time-varying) 시스템임에도 불구하고 트랜스포머와 대등하거나 더 빠른 학습 속도를 달성할 수 있었다. 특히 시퀀스 길이가 길어질수록 Mamba의 속도 우위는 더욱 두드러진다.</p>
<h3>4.3  Mamba 아키텍처의 단순화</h3>
<p>Mamba는 트랜스포머의 복잡한 블록 구조(Multi-head Attention + MLP)를 하나의 통합된 <strong>Mamba 블록</strong>으로 대체했다.</p>
<ul>
<li><strong>구조:</strong> 입력 투영 <span class="math math-inline">\rightarrow</span> 1D 합성곱 <span class="math math-inline">\rightarrow</span> SiLU 활성화 <span class="math math-inline">\rightarrow</span> <strong>SSM (Selection)</strong> <span class="math math-inline">\rightarrow</span> 출력 투영.</li>
<li><strong>특징:</strong> MLP 블록이 따로 존재하지 않으며, SSM 블록 내부에서 정보의 혼합(Mixing)과 변환이 동시에 일어난다. 이는 전체 파라미터 효율성을 높이는 결과를 가져왔다.11</li>
</ul>
<h2>5.  Mamba-2: 구조적 상태 공간의 이중성(SSD)과 텐서 코어의 정복</h2>
<p>Mamba-1은 혁신적이었지만, GPU의 핵심 연산 유닛인 **텐서 코어(Tensor Core)**를 충분히 활용하지 못한다는 아쉬움이 있었다. 텐서 코어는 행렬 곱셈(MatMul)에 특화되어 있는데, Mamba-1의 병렬 스캔은 이러한 행렬 연산 구조와 완벽히 맞아떨어지지는 않았기 때문이다. 2024년 발표된 <strong>Mamba-2</strong>는 이러한 문제를 이론적 통합과 알고리즘적 개선으로 해결했다.</p>
<h3>5.1  SSD (Structured State Space Duality) 이론</h3>
<p>Mamba-2의 핵심은 **“상태 공간 모델(SSM)과 선형 어텐션(Linear Attention)은 수학적으로 동등하다”**는 것을 증명한 <strong>SSD 이론</strong>이다.</p>
<p>Mamba-2는 상태 행렬 <span class="math math-inline">\mathbf{A}</span>에 <strong>스칼라-항등원(Scalar-times-Identity)</strong> 구조라는 제약을 가했다. 즉, 행렬 <span class="math math-inline">\mathbf{A}</span>가 대각 행렬이면서 모든 대각 성분이 동일한 스칼라 값 <span class="math math-inline">a_t</span>를 갖도록 제한한 것이다 (<span class="math math-inline">\mathbf{A}_t = a_t \mathbf{I}</span>).20</p>
<p>이 제약 조건 하에서 SSM의 연산은 <strong>반분리 행렬(Semiseparable Matrix)</strong> 구조를 갖는 행렬 곱셈으로 완벽하게 변환된다. 이를 수식으로 표현하면 마스킹된 어텐션(Masked Attention)의 형태와 일치하게 된다.<br />
<span class="math math-display">
Y = \text{SSM}(X) \iff Y = (L \circ (CB^T))X
</span><br />
여기서 <span class="math math-inline">L</span>은 <span class="math math-inline">A</span> 파라미터들의 누적 곱으로 구성된 하삼각 행렬(Causal Mask)이다. 이 발견은 SSM을 두 가지 모드로 자유롭게 해석하고 실행할 수 있게 해준다.22</p>
<table><thead><tr><th><strong>모드</strong></th><th><strong>연산 방식</strong></th><th><strong>시간 복잡도</strong></th><th><strong>특징</strong></th></tr></thead><tbody>
<tr><td><strong>선형 모드 (SSM)</strong></td><td>순차적 점화식 또는 스캔</td><td><span class="math math-inline">O(N)</span></td><td>추론 시 메모리와 속도 효율성 극대화 (RNN 스타일)</td></tr>
<tr><td><strong>2차 모드 (Attention)</strong></td><td><span class="math math-inline">N \times N</span> 행렬 곱셈</td><td><span class="math math-inline">O(N^2)</span></td><td>학습 시 텐서 코어 활용 극대화 (MatMul 스타일)</td></tr>
</tbody></table>
<h3>5.2  블록 행렬 분해 (Block Matrix Decomposition) 알고리즘</h3>
<p>Mamba-2는 이 이중성을 활용하여 <strong>블록 행렬 분해</strong> 알고리즘을 도입했다. 입력 시퀀스를 일정한 크기의 청크(Chunk)로 나누고, 청크 내부와 청크 간의 연산을 다르게 처리하는 방식이다.24</p>
<ol>
<li><strong>청크 내부 (Intra-Chunk):</strong> **2차 모드(어텐션)**를 사용하여 행렬 곱셈을 수행한다. 이 단계에서 GPU의 텐서 코어를 사용하여 연산을 가속화한다.</li>
<li><strong>청크 간 (Inter-Chunk):</strong> **선형 모드(SSM)**를 사용하여 이전 청크의 상태(State)를 다음 청크로 전달한다.</li>
</ol>
<p>이 하이브리드 접근법은 Mamba-1의 병렬 스캔보다 2~8배 빠른 학습 속도를 제공한다. 텐서 코어는 일반적인 부동소수점 연산보다 최대 16배 높은 처리량을 가지므로, 이를 적극 활용하는 것이 현대 AI 모델 최적화의 핵심이다. 결과적으로 Mamba-2는 상태 벡터의 차원(<span class="math math-inline">N</span>)을 기존 16에서 64, 128 이상으로 크게 늘릴 수 있었고, 이는 모델의 표현력과 기억 용량을 대폭 향상시켰다.20</p>
<h2>6.  Mamba-3와 최신 아키텍처 (2025년의 진화)</h2>
<p>2025년에 접어들며 발표된 <strong>Mamba-3</strong>와 관련 연구들은 SSM의 성능을 극한으로 끌어올리며 트랜스포머와의 격차를 더욱 좁히고 있다. Mamba-3는 “추론 우선(Inference-first)” 설계를 기치로 내걸고, 하드웨어 효율성과 모델의 표현력을 동시에 강화했다.</p>
<h3>6.1  MIMO (Multi-Input Multi-Output) SSM</h3>
<p>기존 SSM은 입력 채널별로 독립적인 SSM을 적용하는 단일 입력 단일 출력(SISO) 구조가 일반적이었다. 반면, Mamba-3는 <strong>MIMO</strong> 구조를 도입하여 다수의 입력을 동시에 처리하고 상호작용하게 만들었다. 이는 하드웨어 관점에서 **산술 강도(Arithmetic Intensity)**를 높여주는 효과가 있다. 즉, 메모리에서 데이터를 한 번 가져와서 더 많은 연산을 수행하게 함으로써, 메모리 대역폭의 병목을 완화하고 GPU 활용률을 극대화한다.25</p>
<h3>6.2  사다리꼴 이산화 (Trapezoidal Discretization)</h3>
<p>Mamba-3는 기존 ZOH(Zero-Order Hold) 이산화 방식 대신 <strong>사다리꼴(Trapezoidal) 법칙</strong> 기반의 이산화를 적용했다. ZOH가 입력 신호를 계단 형태로 근사하는 반면, 사다리꼴 방식은 선형 보간에 가까워 신호의 변화를 더 정밀하게 포착할 수 있다.</p>
<p>주목할 점은 사다리꼴 이산화를 적용할 경우, Mamba 블록 앞단에 필수적으로 존재했던 <strong>1D 합성곱(Convolution) 레이어가 불필요해진다는 것</strong>이다. 사다리꼴 이산화 자체가 국소적인 정보를 효과적으로 통합하는 특성을 가지기 때문이다. 이를 통해 모델의 레이어 구조를 더욱 단순화하면서도, 다운스트림 태스크에서의 성능은 오히려 향상되는 결과를 얻었다.9</p>
<h3>6.3  복잡한 상태 업데이트와 표현력 강화</h3>
<p>Mamba-3는 상태 업데이트 규칙을 더욱 정교하게 다듬어, 기존 SSM 모델들이 어려워했던 <strong>상태 추적(State Tracking)</strong> 과제에서 획기적인 성능 향상을 이뤄냈다. 특히 ‘패리티(Parity)’ 문제나 산술 연산과 같이 이전 상태를 정확히 기억하고 조작해야 하는 작업에서 Mamba-3는 트랜스포머에 버금가는, 혹은 능가하는 성능을 입증했다.25</p>
<h2>7.  하이브리드 아키텍처: 트랜스포머와 Mamba의 공존</h2>
<p>순수한 SSM만으로는 여전히 해결하기 어려운 문제, 특히 “Needle In A Haystack” (방대한 텍스트 속에서 극도로 희소한 정보를 찾아내는 과제)에서 SSM은 정보 압축 손실로 인해 트랜스포머보다 성능이 떨어질 수 있다는 우려가 존재했다.15 이에 대한 해답으로 2024년 하반기부터 <strong>하이브리드(Hybrid)</strong> 모델들이 대거 등장하여 산업계의 표준으로 자리 잡고 있다.</p>
<h3>7.1  Jamba: SSM + Attention + MoE</h3>
<p>AI21 Labs가 공개한 <strong>Jamba</strong>는 하이브리드 아키텍처의 대표적인 성공 사례다. Jamba는 레이어 구성에서 Mamba와 어텐션을 혼합하는 전략을 취했다.</p>
<ul>
<li><strong>아키텍처 구성:</strong> Mamba 레이어 7개마다 트랜스포머 어텐션 레이어 1개를 배치하는 식(예: 7:1 비율)으로 구성된다.</li>
<li><strong>효과:</strong> 대부분의 처리는 효율적인 Mamba가 담당하여 속도와 메모리를 절약하고, 주기적으로 등장하는 어텐션 레이어가 전체 문맥을 훑어보며 놓친 정보를 상기(Recall)시킨다.</li>
<li><strong>MoE (Mixture of Experts):</strong> 여기에 전문가 혼합(MoE) 방식을 더해, 활성 파라미터 수를 줄이면서도 모델의 총 용량은 키웠다. Jamba-1.5는 이를 통해 256K 토큰이라는 거대한 문맥을 단일 80GB GPU에서 처리하는 기염을 토했다.19</li>
</ul>
<h3>7.2  Nemotron-H: 엔비디아의 선택</h3>
<p>엔비디아(NVIDIA)가 발표한 <strong>Nemotron-H</strong> 역시 하이브리드 접근법을 채택했다.</p>
<ul>
<li><strong>설계 철학:</strong> Llama-3.1과 같은 강력한 트랜스포머 모델의 성능을 유지하면서 추론 비용을 획기적으로 낮추는 것을 목표로 했다.</li>
<li><strong>구조:</strong> 전체 레이어의 대부분을 Mamba-2로 구성하고, 매우 적은 수(약 4개)의 어텐션 레이어만을 전략적으로 배치했다.</li>
<li><strong>성능:</strong> 유사한 크기의 트랜스포머 모델 대비 최대 3배 빠른 추론 속도를 달성하면서도, 정확도 면에서는 대등한 수준을 유지했다. 이는 하드웨어 제조사인 엔비디아가 Mamba 기반 하이브리드 모델을 차세대 주력 아키텍처로 낙점했음을 시사한다.31</li>
</ul>
<h3>7.3  TransMamba: 지식 증류를 통한 진화</h3>
<p><strong>TransMamba</strong>는 기존에 학습된 트랜스포머 모델의 지식을 Mamba 모델로 효율적으로 이전(Transfer)하기 위한 방법론이다.</p>
<ul>
<li><strong>메모리 컨버터 (Memory Converter):</strong> 트랜스포머의 KV 캐시를 Mamba의 은닉 상태(Hidden State)로 손실 없이 변환하는 메커니즘을 제안했다.</li>
<li><strong>TransPoint:</strong> 시퀀스의 특정 지점(TransPoint) 이전까지는 어텐션으로 처리하여 정밀함을 확보하고, 그 이후는 SSM으로 처리하여 효율성을 챙기는 유연한 스케줄링이 가능하다. 이는 모델 학습 비용을 절감하고, 기존 트랜스포머 생태계의 유산을 SSM으로 계승하는 중요한 가교 역할을 한다.1</li>
</ul>
<h2>8.  심층 비교 분석: 트랜스포머 vs Mamba</h2>
<h3>8.1  계산 복잡도와 자원 효율성</h3>
<table><thead><tr><th><strong>특성</strong></th><th><strong>트랜스포머 (Standard Attention)</strong></th><th><strong>Mamba-1 (Selective SSM)</strong></th><th><strong>Mamba-2 (SSD)</strong></th></tr></thead><tbody>
<tr><td><strong>시간 복잡도 (학습)</strong></td><td><span class="math math-inline">O(N^2)</span> (병렬 가능)</td><td><span class="math math-inline">O(N)</span> (병렬 스캔)</td><td><span class="math math-inline">O(N)</span> (블록 분해+MatMul)</td></tr>
<tr><td><strong>시간 복잡도 (추론)</strong></td><td><span class="math math-inline">O(N)</span> (KV 캐시 전체 조회)</td><td><span class="math math-inline">O(1)</span> (상태 업데이트)</td><td><span class="math math-inline">O(1)</span></td></tr>
<tr><td><strong>메모리 요구량 (학습)</strong></td><td><span class="math math-inline">O(N^2)</span> (Attention Map)</td><td><span class="math math-inline">O(N)</span> (선형)</td><td><span class="math math-inline">O(N)</span></td></tr>
<tr><td><strong>메모리 요구량 (추론)</strong></td><td><span class="math math-inline">O(N)</span> (KV 캐시 누적)</td><td><span class="math math-inline">O(1)</span> (고정 상태 벡터)</td><td><span class="math math-inline">O(1)</span></td></tr>
<tr><td><strong>주요 하드웨어 연산</strong></td><td>행렬 곱셈 (MatMul)</td><td>스캔 (Prefix Sum), IO 의존적</td><td>행렬 곱셈 (Tensor Core 최적화)</td></tr>
<tr><td><strong>장거리 의존성 포착</strong></td><td>매우 우수 (모든 토큰 직접 참조)</td><td>우수 (선택적 기억 및 망각)</td><td>우수 (상태 차원 확대로 강화)</td></tr>
</tbody></table>
<p>위 표에서 알 수 있듯이, Mamba 계열은 추론 시 <span class="math math-inline">O(1)</span>의 일정한 메모리와 연산량을 가진다는 점에서 압도적인 강점을 가진다. 트랜스포머는 시퀀스가 길어질수록 KV 캐시가 GPU 메모리를 잠식하여 배치 크기(Batch Size)를 줄여야 하는 반면, Mamba는 백만 토큰을 처리하더라도 메모리 사용량이 일정하다.2</p>
<h3>8.2  검색(Retrieval) 대 추론(Reasoning)의 트레이드오프</h3>
<p>트랜스포머의 어텐션은 과거의 모든 정보를 원본 그대로 보존하고 있다가 필요할 때 검색(Retrieval)하는 방식이다. 따라서 “Needle In A Haystack” 테스트에서 완벽에 가까운 성능을 보인다. 반면, Mamba는 정보를 고정된 크기의 상태 벡터에 압축(Compression)해야 한다. 이 과정에서 필연적으로 정보의 손실이 발생할 수 있다.15</p>
<p>초기 Mamba 모델은 이 부분에서 약점을 보였으나, Mamba-2의 상태 차원 확대와 Mamba-3의 표현력 강화로 격차를 크게 줄였다. 특히 하이브리드 모델(Jamba, Nemotron-H)은 어텐션 레이어를 소수 섞어줌으로써 이 문제를 사실상 해결했다. 이는 인간의 뇌가 단기 기억(Attention)과 장기 기억(SSM/Weight)을 혼용하여 사용하는 것과 유사한 효율적 전략이다.</p>
<h2>9.  결론: 선형 시간의 시대를 향하여</h2>
<p>트랜스포머 싱귤래리티의 핵심 챕터인 “14.1 SSM과 Mamba 아키텍처의 부상“은 단순한 기술 소개를 넘어, AI 모델링의 철학적 전환을 시사한다. 우리는 그동안 <span class="math math-inline">O(N^2)</span>의 비용을 지불하면서 ‘모든 것을 기억하는’ 트랜스포머의 방식에 의존해 왔다. 그러나 Mamba는 ‘무엇을 기억하고 무엇을 잊을지 선택하는’ 지능적인 압축 메커니즘을 통해, 선형 시간(Linear Time)의 효율성으로 회귀하면서도 성능을 포기하지 않는 길을 열었다.</p>
<p>본고에서의 분석을 통해 도출된 핵심 시사점은 다음과 같다.</p>
<ol>
<li><strong>알고리즘과 하드웨어의 공진화:</strong> Mamba-1의 병렬 스캔에서 Mamba-2의 SSD에 이르는 과정은, 알고리즘이 하드웨어(GPU Tensor Core, SRAM)의 물리적 특성에 맞춰 진화하는 과정을 적나라하게 보여준다. 이는 향후 AI 가속기(NPU) 설계에도 지대한 영향을 미칠 것이다.</li>
<li><strong>하이브리드 아키텍처의 표준화:</strong> 순수 Mamba보다는 트랜스포머의 정밀함과 Mamba의 효율성을 결합한 하이브리드 모델이 고성능 LLM의 실질적인 표준(De facto standard)이 될 것이다. Jamba와 Nemotron-H는 그 서막에 불과하다.</li>
<li><strong>무한한 문맥의 가능성:</strong> Mamba 아키텍처는 수백만, 수천만 토큰의 문맥을 처리할 수 있는 길을 열었다. 이는 책 한 권을 넘어 도서관 전체를 문맥으로 삼는 초거대 문맥(Ultra-long Context) AI의 등장을 예고한다.</li>
</ol>
<p>결론적으로 SSM과 Mamba는 트랜스포머를 대체하는 것이 아니라, 트랜스포머가 도달할 수 없었던 효율성의 영역으로 AI를 확장시키는 핵심 열쇠이다. 2025년 이후의 AI 모델링은 Mamba가 쏘아 올린 ‘선형 시간의 혁명’ 위에서 더욱 거대하고, 빠르며, 지능적인 형태로 진화할 것이다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>TransMamba: Flexibly Switching between Transformer and Mamba - arXiv, https://arxiv.org/html/2503.24067v1</li>
<li>How Mamba Beats Transformers at Long Sequences - Galileo AI, https://galileo.ai/blog/mamba-linear-scaling-transformers</li>
<li>Mamba for Dummies: Efficient Linear-Time LLMs Explained | by Michiel Horstman - Medium, https://michielh.medium.com/mamba-for-dummies-linear-time-llms-explained-0d4b51efcf9f</li>
<li>EFFICIENTLY MODELING LONG SEQUENCES WITH STRUCTURED STATE SPACES - OpenReview, https://openreview.net/pdf?id=uYLFoz1vlAC</li>
<li>[2111.00396] Efficiently Modeling Long Sequences with Structured State Spaces - arXiv, https://arxiv.org/abs/2111.00396</li>
<li>The Annotated S4 - The ICLR Blog Track, https://iclr-blog-track.github.io/2022/03/25/annotated-s4/</li>
<li>modeling sequences with structured state spaces a dissertation submitted to the department of depart - Stacks are the Stanford, https://stacks.stanford.edu/file/druid:mb976vf9362/gu_dissertation-augmented.pdf</li>
<li>On the Tradeoffs of SSMs and Transformers | Goomba Lab, https://goombalab.github.io/blog/2025/tradeoffs/</li>
<li>Integrating Multi-Modal Input Token Mixer into Mamba-Based Decision Models - arXiv, https://arxiv.org/html/2408.10517v4</li>
<li>History of State Space Models (SSM) in 2022 - Hugging Face, https://huggingface.co/blog/lbourdois/ssm-2022</li>
<li>Mamba: Linear-Time Sequence Modeling with Selective … - arXiv, https://arxiv.org/abs/2312.00752</li>
<li>Mamba: SSM, Theory, and Implementation in Keras and TensorFlow, https://towardsdatascience.com/mamba-ssm-theory-and-implementation-in-keras-and-tensorflow-32d6d4b32546/</li>
<li>Mamba (deep learning architecture) - Wikipedia, https://en.wikipedia.org/wiki/Mamba_(deep_learning_architecture)</li>
<li>Mamba, Selective State Space Models, and the Rise of Post-Transformer AI - Medium, https://medium.com/@raktims2210/mamba-selective-state-space-models-and-the-rise-of-post-transformer-ai-f197f05e8ab8</li>
<li>Mamba Explained - The Gradient, https://thegradient.pub/mamba-explained/</li>
<li>A Visual Guide to Mamba and State Space Models - Maarten Grootendorst, https://www.maartengrootendorst.com/blog/mamba/</li>
<li>MAMBA and State Space Models Explained | by Astarag Mohapatra - Medium, https://athekunal.medium.com/mamba-and-state-space-models-explained-b1bf3cb3bb77</li>
<li>Mamba No. 5 (A Little Bit Of…) - Sparse Notes, https://jameschen.io/jekyll/update/2024/02/12/mamba.html</li>
<li>Mamba Selective State Space Model - Emergent Mind, https://www.emergentmind.com/topics/mamba-based-selective-state-space-model</li>
<li>State Space Duality (Mamba-2) Part I - The Model | Tri Dao, https://tridao.me/blog/2024/mamba2-part1-model/</li>
<li>Mamba-2: The ’Transform’ation of Mamba | by Utsavtiwari - Medium, https://medium.com/@utsavtiwari9936/mamba-2-the-transformation-of-mamba-125096294c51</li>
<li>State Space Duality (Mamba-2) Part II - The Theory | Goomba Lab, https://goombalab.github.io/blog/2024/mamba2-part2-theory/</li>
<li>[2405.21060] Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality - arXiv, https://arxiv.org/abs/2405.21060</li>
<li>State Space Duality (Mamba-2) Part III - The Algorithm | Tri Dao, https://tridao.me/blog/2024/mamba2-part3-algorithm/</li>
<li>Mamba-3: Improved Sequence Modeling using State Space Principles | OpenReview, https://openreview.net/forum?id=HwCvaJOiCj</li>
<li>Mamba-3 – the next evolution in language modeling - QuData, https://qudata.com/en/news/mamba-3-next-evolution-language-modeling/</li>
<li>[D] What Are the Fundamental Drawbacks of Mamba Compared to Transformers? - Reddit, https://www.reddit.com/r/MachineLearning/comments/1ayog60/d_what_are_the_fundamental_drawbacks_of_mamba/</li>
<li>Jamba-1.5: Hybrid Transformer-Mamba Models at Scale - arXiv, https://arxiv.org/html/2408.12570v1</li>
<li>AI21 Labs’ Jamba 1.5 Outpaces Transformers in Long-Text Processing - DeepLearning.AI, https://www.deeplearning.ai/the-batch/ai21-labs-jamba-1-5-outpaces-transformers-in-long-text-processing/</li>
<li>Jamba: AI21 Labs’ New Hybrid Transformer-Mamba Language Model - Unite.AI, https://www.unite.ai/jamba-ai21-labs-new-hybrid-transformer-mamba-language-model/</li>
<li>Nemotron 3 Nano: Open, Efficient Mixture-of-Experts Hybrid Mamba-Transformer Model for Agentic Reasoning - Research at NVIDIA, https://research.nvidia.com/labs/nemotron/files/NVIDIA-Nemotron-3-Nano-Technical-Report.pdf</li>
<li>nvidia/Nemotron-H-8B-Base-8K - Hugging Face, https://huggingface.co/nvidia/Nemotron-H-8B-Base-8K</li>
<li>Nemotron-H: A Family of Accurate and Efficient Hybrid Mamba-Transformer Models - arXiv, https://arxiv.org/pdf/2504.03624</li>
<li>TransMamba: Flexibly Switching between Transformer and Mamba - Hugging Face, https://huggingface.co/papers/2503.24067</li>
<li>Exploring the Limitations of Mamba in COPY and CoT Reasoning - arXiv, https://arxiv.org/html/2410.03810v3</li>
<li>Scaling Legal AI: Benchmarking Mamba and Transformers for Statutory Classification and Case Law Retrieval - arXiv, https://arxiv.org/pdf/2509.00141</li>
<li>[D] - Why MAMBA did not catch on? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/1hpg91o/d_why_mamba_did_not_catch_on/</li>
<li>Mamba-2: Algorithms and Systems | Princeton Language and Intelligence, https://pli.princeton.edu/blog/2024/mamba-2-algorithms-and-systems</li>
<li>A Discussion on Discretization and Practical Tradeoffs of the ZOH Equivalent ⋆ - Danny Abramovitch, https://dabramovitch.com/pubs/Abramovitch_23bb.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>