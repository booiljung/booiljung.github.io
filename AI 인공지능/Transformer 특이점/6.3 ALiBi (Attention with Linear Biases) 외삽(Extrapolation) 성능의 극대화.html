<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:6.3 ALiBi (Attention with Linear Biases) 외삽(Extrapolation) 성능의 극대화</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>6.3 ALiBi (Attention with Linear Biases) 외삽(Extrapolation) 성능의 극대화</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>6.3 ALiBi (Attention with Linear Biases) 외삽(Extrapolation) 성능의 극대화</span></nav>
                </div>
            </header>
            <article>
                <h1>6.3 ALiBi (Attention with Linear Biases) 외삽(Extrapolation) 성능의 극대화</h1>
<p>2025-12-21, G30DR</p>
<p>트랜스포머(Transformer) 아키텍처가 자연어 처리(NLP) 분야를 평정한 이래, 모델의 문맥 창(Context Window)을 확장하려는 시도는 끊임없이 계속되어 왔다. 특히 훈련 단계에서 접하지 못한 길이의 시퀀스를 추론 단계에서 처리할 수 있는 능력, 즉 <strong>외삽(Extrapolation)</strong> 능력의 부재는 트랜스포머 기반 대규모 언어 모델(LLM)의 실용성을 제한하는 가장 큰 장벽 중 하나였다. 본 장에서는 2022년 ICLR에서 발표된 “Train Short, Test Long” 연구1를 기점으로, 위치 정보 인코딩(Positional Encoding)의 패러다임을 근본적으로 전환시킨 <strong>ALiBi (Attention with Linear Biases)</strong> 메커니즘에 대해 심층적으로 논의한다.</p>
<p>ALiBi는 기존의 정현파(Sinusoidal) 위치 인코딩이나 학습 가능한 절대 위치 임베딩(Learned Absolute Positional Embedding)이 갖는 구조적 한계를 타파하고, 추가적인 학습 파라미터 없이 어텐션 메커니즘의 수식적 변형만으로 놀라운 외삽 성능을 달성했다. 본고에서는 ALiBi의 수학적 기초부터 시작하여, 기존 방법론들과의 비교 우위, MPT 및 BLOOM과 같은 최신 거대 모델에서의 적용 사례, 그리고 RoPE(Rotary Positional Embedding)와의 기술적 경쟁 구도와 그 함의를 포괄적으로 분석한다. 이는 단순한 기술 보고서를 넘어, 언어 모델이 ’거리(Distance)’와 ’순서(Order)’를 어떻게 인지해야 하는지에 대한 근원적인 고찰을 포함한다.</p>
<h2>1.  트랜스포머의 위치 인식 문제와 외삽의 딜레마</h2>
<p>트랜스포머 아키텍처의 핵심인 셀프 어텐션(Self-Attention)은 본질적으로 집합(Set) 연산이다. 즉, 입력 토큰들의 순서를 임의로 섞더라도(<span class="math math-inline">Permutation</span>), 어텐션 메커니즘이 계산하는 각 토큰 간의 관계 점수는 변하지 않는다.3 언어 모델링에서 단어의 순서는 의미를 결정짓는 절대적인 요소이므로, 트랜스포머가 시퀀스 데이터(Sequence Data)를 처리하기 위해서는 어떤 형태로든 위치 정보를 주입해야 한다. Vaswani et al.(2017)의 초기 연구는 사인과 코사인 함수를 이용한 절대적 위치 인코딩(Absolute Positional Encoding, APE)을 제안했고, 이후 GPT 시리즈는 학습 가능한 위치 임베딩을 채택했다.5</p>
<p>그러나 이러한 절대적 위치 인코딩 방식들은 치명적인 약점을 가지고 있다. 바로 훈련된 길이(<span class="math math-inline">L_{train}</span>)를 초과하는 입력에 대해 모델이 무력하다는 점이다. 예를 들어, 최대 1,024 토큰 길이로 학습된 GPT-3 모델에 2,048번째 토큰이 입력되면, 모델은 해당 위치에 대한 임베딩 벡터를 학습한 적이 없으므로 처리가 불가능하거나, 임의로 확장할 경우 성능이 붕괴(Collapse)한다. 이를 <strong>외삽 실패(Extrapolation Failure)</strong> 라고 정의한다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "훈련 단계 (Train Short)"
        Train["훈련 데이터 길이: L_train (예: 512)"]
        Cost["훈련 비용: O(L^2)"]
    end

    subgraph "추론 단계 (Test Long)"
        InputShort["입력 길이 &lt;= L_train"]
        InputLong["입력 길이 &gt; L_train (외삽 필요)"]
    end

    Train --&gt; InputShort
    Train --&gt; InputLong

    InputShort --&gt; ResultSuccess["성능 유지 (정상)"]
    
    InputLong -- "기존 APE/RoPE" --&gt; ResultFail["성능 붕괴 (PPL 폭발)"]
    InputLong -- "ALiBi 적용" --&gt; ResultALiBi["성능 유지 및 향상 (성공)"]

    style ResultFail fill:#ffcccc,stroke:#ff0000
    style ResultALiBi fill:#ccffcc,stroke:#00aa00
</code></pre>
<h3>1.1  “Train Short, Test Long“의 경제학</h3>
<p>외삽 능력이 중요한 이유는 단순히 긴 문서를 처리하기 위함만이 아니다. 여기에는 막대한 <strong>계산 비용의 경제학</strong>이 깔려 있다. 어텐션 메커니즘의 시간 및 메모리 복잡도는 시퀀스 길이 <span class="math math-inline">L</span>에 대해 <span class="math math-inline">O(L^2)</span>로 증가한다.7 따라서 훈련 길이를 2배로 늘리면 훈련 비용은 4배로 증가한다. 만약 모델이 짧은 시퀀스(<span class="math math-inline">L=512</span> 등)로 훈련하고, 추론 시에는 긴 시퀀스(<span class="math math-inline">L=16,384</span> 등)를 처리할 수 있다면, LLM의 훈련 비용을 획기적으로 절감할 수 있다.1</p>
<p>Press et al.(2022)이 제안한 ALiBi는 이러한 배경에서 탄생했다. 연구팀은 트랜스포머가 훈련 길이보다 긴 시퀀스에 대해 일반화하지 못하는 원인이 모델의 용량 부족이 아니라, 위치 정보를 인코딩하는 <strong>방식(Method)</strong> 자체에 있다고 가설을 세웠다. 그들은 위치 임베딩을 입력 단에 더하는 대신, 어텐션 스코어 계산 과정에 직접적인 편향(Bias)을 줌으로써 이 문제를 해결하고자 했다.2</p>
<h2>2.  ALiBi 메커니즘의 수학적 원리와 설계 철학</h2>
<p>ALiBi의 핵심 철학은 <strong>“귀납적 편향(Inductive Bias)으로서의 최신성(Recency)”</strong> 이다. 자연어에서 단어 간의 연관성은 거리가 멀어질수록 감소하는 경향이 있다. ALiBi는 이를 수학적으로 모델링하여, 쿼리(Query)와 키(Key) 사이의 거리가 멀수록 어텐션 점수에 페널티를 부여한다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "입력 단계"
        Token["토큰 임베딩 (Word Embedding)"]
        NoPos["위치 임베딩 제거 (No Positional Encoding)"]
        Token --&gt; Q["Query (Q)"]
        Token --&gt; K["Key (K)"]
    end

    subgraph "어텐션 연산 (ALiBi)"
        DotProd["Dot Product (Q * K^T)"]
        Scale["Scaling (1 / sqrt(d_k))"]
        
        Q --&gt; DotProd
        K --&gt; DotProd
        DotProd --&gt; Scale
        
        CalcDist["거리 계산: -(i - j)"]
        Slope["헤드별 기울기: m"]
        Bias["선형 편향: m * -(i - j)"]
        
        CalcDist --&gt; Bias
        Slope --&gt; Bias
        
        Scale --&gt; AddBias["스코어 + 편향 (Score + Bias)"]
        Bias --&gt; AddBias
        
        AddBias --&gt; Softmax["Softmax"]
        Softmax --&gt; Output["Context Vector"]
    end
    
    style NoPos fill:#f9f,stroke:#333,stroke-width:2px
    style AddBias fill:#ff9,stroke:#f66,stroke-width:2px
</code></pre>
<h3>2.1  어텐션 스코어의 재구성</h3>
<p>기존의 스케일드 닷-프로덕트 어텐션(Scaled Dot-Product Attention) 수식은 다음과 같다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
여기서 <span class="math math-inline">Q</span>와 <span class="math math-inline">K</span>는 위치 임베딩이 더해진 벡터들이다. ALiBi는 입력 임베딩 단계에서 위치 정보를 제거하고, 대신 소프트맥스 함수 내부의 어텐션 로짓(Logit)에 정적 편향(Static Bias)을 추가한다.10 <span class="math math-inline">i</span>번째 쿼리 토큰과 <span class="math math-inline">j</span>번째 키 토큰 (<span class="math math-inline">j \le i</span>) 사이의 어텐션 스코어는 다음과 같이 수정된다.<br />
<span class="math math-display">
\text{score}(q_i, k_j) = \frac{q_i \cdot k_j^T}{\sqrt{d_k}} + m \cdot (-(i-j))
</span><br />
여기서 <span class="math math-inline">i-j</span>는 두 토큰 사이의 거리이며, <span class="math math-inline">m</span>은 헤드(Head)별로 고정된 기울기(Slope) 파라미터이다. 거리가 0일 때(자기 자신) 편향은 0이며, 거리가 멀어질수록 <span class="math math-inline">m \times \text{거리}</span> 만큼의 페널티가 선형적으로 차감된다.11 이 방식은 학습 파라미터를 전혀 추가하지 않으며(<span class="math math-inline">0</span> parameters), 단순히 어텐션 행렬에 미리 정의된 마스크(Mask)를 더하는 것과 동일하므로 구현이 매우 간단하다.</p>
<h3>2.2  기하급수적 기울기(Geometric Sequence of Slopes)의 설계</h3>
<p>ALiBi의 성능을 결정짓는 핵심 요소는 기울기 <span class="math math-inline">m</span>의 값이다. 모든 헤드가 동일한 거리 페널티를 갖는다면, 모델은 다양한 범위의 문맥을 포착할 수 없다. 어떤 헤드는 바로 앞 단어에 집중해야 하고, 어떤 헤드는 문장 전체 혹은 문단 전체를 아울러야 한다. 이를 위해 ALiBi는 헤드마다 서로 다른 기울기를 할당하며, 이 값들은 <strong>기하급수열(Geometric Progression)</strong> 을 따른다.5</p>
<p>총 헤드 수가 <span class="math math-inline">n</span>개일 때, <span class="math math-inline">h</span>번째 헤드의 기울기 <span class="math math-inline">m_h</span>는 다음과 같이 정의된다.<br />
<span class="math math-display">
m_h = \frac{1}{2^{\frac{8 \cdot h}{n}}}
</span><br />
예를 들어, 8개의 헤드를 가진 모델의 경우 기울기 값은 다음과 같다:<br />
<span class="math math-display">
\frac{1}{2^1}, \frac{1}{2^2}, \frac{1}{2^3}, \dots, \frac{1}{2^8}
</span></p>
<p><span class="math math-display">
(0.5, 0.25, 0.125, \dots, 0.00390625)
</span></p>
<p>첫 번째 헤드(<span class="math math-inline">m=0.5</span>)는 거리가 1 멀어질 때마다 어텐션 점수를 0.5씩 깎아내려 매우 지역적인 정보(Local Context)에 집중하게 한다. 반면, 마지막 헤드(<span class="math math-inline">m \approx 0.004</span>)는 페널티가 매우 작아 수천 토큰 떨어진 정보도 거의 감쇠 없이 참조할 수 있게 하여 전역적인 정보(Global Context)를 포착한다.13 연구진은 <span class="math math-inline">m</span>을 학습 가능한 파라미터로 설정하는 실험도 진행했으나, 고정된 기하급수열이 외삽 성능 면에서 오히려 더 우수함을 발견했다.10</p>
<pre><code class="language-mermaid">graph TD
    Root["ALiBi Multi-Head Attention"]
    
    subgraph "Head 1 (Local Focus)"
        H1["Head 1"]
        Slope1["기울기 m = 0.5 (1/2^1)"]
        Penalty1["큰 페널티 (High Decay)"]
        Focus1["지역적 문맥 (직전 단어 집중)"]
        H1 --&gt; Slope1 --&gt; Penalty1 --&gt; Focus1
    end

    subgraph "Head ... (Mid Range)"
        H_mid["Head ..."]
        Slope_mid["기울기 m = 1/2^k"]
        Penalty_mid["중간 페널티"]
        H_mid --&gt; Slope_mid --&gt; Penalty_mid
    end

    subgraph "Head N (Global Focus)"
        HN["Head N (예: 8)"]
        SlopeN["기울기 m ≈ 0.004 (1/2^8)"]
        PenaltyN["작은 페널티 (Low Decay)"]
        FocusN["전역적 문맥 (수천 토큰 과거 참조)"]
        HN --&gt; SlopeN --&gt; PenaltyN --&gt; FocusN
    end

    Root --&gt; H1
    Root --&gt; H_mid
    Root --&gt; HN
</code></pre>
<h3>2.3  비(非) 2의 거듭제곱 헤드 수에 대한 보간법</h3>
<p>실제 모델 설계 시 헤드의 수(<span class="math math-inline">n</span>)가 항상 2의 거듭제곱(8, 16, 32 등)인 것은 아니다. 예를 들어 BLOOM이나 일부 MPT 모델처럼 12개, 40개 등의 헤드를 사용할 경우, ALiBi는 보간(Interpolation) 알고리즘을 통해 기울기를 생성한다.14</p>
<p>알고리즘의 구체적인 절차는 다음과 같다:</p>
<ol>
<li>현재 헤드 수 <span class="math math-inline">n</span>보다 작거나 같은 가장 큰 2의 거듭제곱수 <span class="math math-inline">2^k</span>를 계산한다. (예: <span class="math math-inline">n=12</span>이면 <span class="math math-inline">2^k=8</span>)</li>
<li>먼저 <span class="math math-inline">2^k</span>개의 헤드에 대해 기존 공식을 적용하여 기울기를 생성한다. (공비 <span class="math math-inline">2^{-8/2^k}</span>)</li>
<li>나머지 <span class="math math-inline">n - 2^k</span>개의 헤드에 대해서는, <span class="math math-inline">2^{k+1}</span>개의 헤드를 가정했을 때 생성될 기울기들 중, 앞서 생성되지 않은 사이사이의 값들을 가져온다. (공비 <span class="math math-inline">2^{-8/2^{k+1}}</span>)</li>
<li>이 두 그룹을 결합(Concatenate)하여 최종 <span class="math math-inline">n</span>개의 기울기를 구성한다.</li>
</ol>
<p>파이토치(PyTorch) 코드 관점에서 이는 다음과 같이 구현된다14:</p>
<pre><code class="language-Python">def get_alibi_slopes(n_heads):
    n = 2 ** math.floor(math.log2(n_heads))
    m_0 = 2.0 ** (-8.0 / n)
    m = torch.pow(m_0, torch.arange(1, 1 + n))
    
    if n &lt; n_heads:
        m_hat_0 = 2.0 ** (-4.0 / n) # 다음 단계의 공비 사용
        # 기존 값들 사이의 값을 선택 (Step=2)
        m_hat = torch.pow(m_hat_0, torch.arange(1, 1 + 2 * (n_heads - n), 2))
        m = torch.cat([m, m_hat])
    return m
</code></pre>
<p>이러한 설계는 모델의 규모가 커지거나 구조가 변경되어도 ALiBi가 의도한 “다중 스케일(Multi-scale) 거리 인식” 특성을 일관되게 유지하게 해준다.</p>
<pre><code class="language-mermaid">graph TD
    Start["시작: 헤드 수 n_heads 입력"]
    CalcPower["가장 가까운 2의 거듭제곱 2^k 계산 (2^k &lt;= n_heads)"]
    
    Start --&gt; CalcPower
    
    GenBase["기본 기울기 생성 (2^k개)"]
    Formula1["공식: 2^(-8 * h / 2^k)"]
    
    CalcPower --&gt; GenBase
    GenBase --&gt; Formula1
    
    Check["남은 헤드가 있는가? (n_heads &gt; 2^k)"]
    Formula1 --&gt; Check
    
    BranchYes["Yes"]
    BranchNo["No"]
    
    Check -- "Yes" --&gt; Step2["추가 기울기 보간 (Interpolation)"]
    Check -- "No" --&gt; Finish["종료: 기본 기울기 반환"]
    
    Step2 --&gt; UseNext["다음 단계 2^(k+1) 기준 공비 사용"]
    UseNext --&gt; SelectMid["기존 값 사이의 값 선택 (Step=2)"]
    SelectMid --&gt; Concat["기본 기울기 + 추가 기울기 결합 (Concatenate)"]
    Concat --&gt; Return["최종 n_heads개 기울기 반환"]
</code></pre>
<h2>3.  외삽 성능에 대한 실증적 분석 및 벤치마크</h2>
<p>ALiBi의 가장 강력한 무기는 단연코 훈련 길이를 초과하는 입력에 대한 처리 능력이다. Press et al.(2022)의 연구와 후속 논문들은 WikiText-103, CC100, The Pile 등 다양한 데이터셋에서 이를 입증했다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Train Length = 512"
        EvalShort["Eval Length: 512"]
    end
    
    subgraph "Eval Length: 1024 ~ 2048 (Extrapolation)"
        Sinusoidal["Sinusoidal (APE)"]
        RoPE["RoPE"]
        ALiBi["ALiBi"]
    end
    
    subgraph "Eval Length: &gt; 4096"
        ResSin["PPL &gt; 50 (Explosion/Fail)"]
        ResRoPE["PPL 증가 및 점진적 붕괴"]
        ResALiBi["PPL 유지 또는 감소 (Success)"]
    end

    EvalShort -- "모델별 분기" --&gt; Sinusoidal
    EvalShort -- "모델별 분기" --&gt; RoPE
    EvalShort -- "모델별 분기" --&gt; ALiBi

    Sinusoidal --&gt; ResSin
    RoPE --&gt; ResRoPE
    ALiBi --&gt; ResALiBi

    style ResSin fill:#ff9999
    style ResALiBi fill:#99ff99
</code></pre>
<h3>3.1  WikiText-103에서의 PPL 비교: 폭발(Explosion) vs 유지</h3>
<p>가장 극적인 비교는 훈련 길이 <span class="math math-inline">L=512</span>인 모델을 사용하여 <span class="math math-inline">L=1024, 2048, \dots, 16384</span> 길이의 시퀀스를 평가했을 때 나타난다.</p>
<table><thead><tr><th><strong>모델 (Train L=512)</strong></th><th><strong>Eval L=512 (PPL)</strong></th><th><strong>Eval L=1024 (PPL)</strong></th><th><strong>Eval L=2048 (PPL)</strong></th><th><strong>Eval L&gt;4096 (PPL)</strong></th></tr></thead><tbody>
<tr><td><strong>Sinusoidal (APE)</strong></td><td>~18.5</td><td>&gt; 50 (<strong>Explosion</strong>)</td><td>&gt; 100</td><td>N/A (Failure)</td></tr>
<tr><td><strong>RoPE</strong></td><td>~18.5</td><td>~22.0 (Degradation)</td><td>증가 추세</td><td>점진적 붕괴</td></tr>
<tr><td><strong>T5 Bias</strong></td><td>~18.0</td><td>~17.8</td><td>메모리 부족 (OOM)</td><td>속도 저하 심각</td></tr>
<tr><td><strong>ALiBi</strong></td><td>~18.5</td><td><strong>~18.0</strong></td><td><strong>~17.5</strong></td><td><strong>유지 또는 감소</strong></td></tr>
</tbody></table>
<p>위 표1에서 볼 수 있듯이, 정현파(Sinusoidal) 모델은 훈련 길이를 넘어서는 순간 펄플렉서티가 50 이상으로 치솟으며 언어 모델로서의 기능을 상실한다. 이는 모델이 훈련 중 보지 못한 위치 임베딩 벡터에 대해 일반화하지 못하기 때문이다. RoPE 역시 훈련되지 않은 회전 각도를 접하면 성능이 저하된다. 반면, ALiBi 모델은 평가 길이가 길어질수록 오히려 PPL이 낮아지는 경향을 보인다. 512 토큰만 보고 학습했음에도, 2048 토큰의 문맥을 주었을 때 더 정확한 예측을 수행한다는 것은 모델이 “상대적 거리“의 개념을 완벽하게 학습했음을 시사한다.13</p>
<h3>3.2  슬라이딩 윈도우 평가와 초기 토큰의 저주(Early Token Curse)</h3>
<p>ALiBi 논문은 외삽 성능 향상의 원인을 규명하기 위해 슬라이딩 윈도우(Sliding Window) 평가를 수행했다. 일반적으로 언어 모델은 시퀀스의 앞부분(초기 토큰)에서 문맥 정보가 부족하여 높은 PPL을 기록하는데, 이를 <strong>‘초기 토큰의 저주(Early Token Curse)’</strong> 라고 한다. 문맥 창을 늘리면 이 저주를 받는 토큰의 비율이 줄어들어 전체 평균 PPL이 낮아지는 효과가 있다.10</p>
<p>ALiBi는 훈련 길이보다 긴 윈도우를 사용했을 때, 이 ’저주’를 효과적으로 완화한다. 즉, 훈련 시에는 512개 토큰까지만 볼 수 있었지만, 추론 시에는 ALiBi의 거리 기반 감쇠 덕분에 더 먼 과거의 토큰들도 노이즈가 아닌 유효한 문맥으로 활용하며, 결과적으로 전체 시퀀스에 대해 더 안정적인 예측을 수행하게 된다. 이는 ALiBi가 단순히 에러를 억제하는 것을 넘어, 추가적인 정보를 능동적으로 활용하고 있음을 증명한다.</p>
<h2>4.  ALiBi vs. RoPE: LLM 위치 인코딩의 패권 경쟁</h2>
<p>현재 LLM 생태계는 Llama 시리즈를 위시한 <strong>RoPE(Rotary Positional Embedding)</strong> 진영과 MPT, BLOOM 등을 포함한 <strong>ALiBi</strong> 진영으로 양분되어 있다. 두 기술 모두 상대적 위치 정보를 인코딩한다는 공통점이 있지만, 접근 방식과 특성에는 분명한 차이가 있다.</p>
<pre><code class="language-mermaid">mindmap
  root((위치 인코딩 경쟁))
    RoPE_Rotary
      ["방식: 회전 변환 (Rotation)"]
      ["장점: 장기 기억 보존 (Long-term Decay X)"]
      ["장점: 표현력 (Expressiveness) 우수"]
      ["단점: 외삽 시 추가 튜닝/보간 필요"]
      ["단점: 연산 비용 (삼각함수, 복소수)"]
      ["대표 모델: Llama 2, Llama 3"]
    ALiBi_Linear
      ["방식: 선형 편향 (Linear Bias)"]
      ["장점: 구조적 외삽 (Native Extrapolation)"]
      ["장점: 연산 효율성 (단순 덧셈, 0 param)"]
      ["장점: 훈련 안정성 (Smooth Loss)"]
      ["단점: 먼 거리 정보 감쇠 (Decay)"]
      ["대표 모델: MPT, BLOOM"]
</code></pre>
<h3>4.1  어텐션 싱크(Attention Sink)와 장기 기억 보존</h3>
<p>최근 연구17에 따르면, 트랜스포머 모델은 시퀀스의 첫 번째 토큰(Start Token)에 과도한 어텐션을 부여하는 ‘어텐션 싱크’ 현상을 보인다. 이는 첫 토큰이 특별한 의미가 있어서가 아니라, 소프트맥스 확률의 합을 1로 맞추기 위해 불필요한 어텐션 값을 버릴 ’쓰레기통(Sink)’이 필요하기 때문이다.</p>
<ul>
<li><strong>RoPE의 강점</strong>: RoPE는 회전 변환을 통해 위치 정보를 인코딩하므로, 거리가 멀어져도 내적 값이 0으로 수렴하지 않고 보존될 수 있다. 이는 모델이 수만 토큰 전의 특정 정보(예: “비밀번호는 1234이다”)를 명확하게 기억하고 인출(Retrieval)해야 하는 작업(“Needle in a Haystack”)에서 유리하게 작용할 수 있다.20</li>
<li><strong>ALiBi의 약점?</strong>: ALiBi는 거리가 멀어지면 선형 페널티에 의해 어텐션 점수를 강제로 낮춘다. 이는 먼 거리의 토큰을 ’망각’하게 만드는 효과를 낳을 수 있다. 특히 어텐션 싱크 역할을 하는 첫 번째 토큰이 현재 토큰에서 멀어질 경우, ALiBi는 이 싱크에 대한 접근을 차단해버릴 위험이 있다. 이로 인해 초기 ALiBi 모델들은 초장문 문맥에서의 정밀한 정보 검색 능력에서 RoPE 기반 모델(특히 NTK-Aware 등으로 보정된)에 비해 약점을 보인다는 지적이 있었다.19</li>
</ul>
<h3>4.2  표현력(Expressiveness)과 의미론적 용량</h3>
<p>RoPE는 고주파(High frequency) 성분과 저주파(Low frequency) 성분을 혼합하여 위치를 인코딩한다. 연구 결과, RoPE의 저주파 성분은 단순한 위치 정보 외에도 의미론적(Semantic) 정보를 전달하는 데 기여하는 것으로 나타났다.22 반면 ALiBi는 모든 헤드에 대해 균일한 형태의 감쇠(Decay)만을 적용하므로, 위치 정보와 내용(Content) 정보의 상호작용을 모델링하는 유연성이 상대적으로 부족할 수 있다. Llama 2 및 3가 ALiBi 대신 RoPE를 선택한 주된 이유 중 하나는 이러한 <strong>표현력의 풍부함</strong>과, RoPE가 제공하는 <strong>장기 의존성(Long-term Dependency)의 보존 능력</strong> 때문으로 분석된다.23</p>
<h3>4.3  그럼에도 ALiBi가 선택되는 이유: 효율성과 안정성</h3>
<p>그렇다면 왜 MPT와 BLOOM은 ALiBi를 선택했는가?</p>
<ol>
<li><strong>압도적인 효율성</strong>: RoPE는 구현 시 삼각함수 연산과 복소수 곱셈이 필요하여 연산 비용이 발생한다. 반면 ALiBi는 단순 덧셈이므로 커널 퓨전(Kernel Fusion)을 통해 오버헤드를 거의 0에 가깝게 만들 수 있다.11</li>
<li><strong>훈련 안정성(Training Stability)</strong>: MPT 개발진(MosaicML)은 대규모 모델 훈련 시 ALiBi가 RoPE보다 손실 스파이크(Loss Spike)를 덜 유발하며 수렴이 안정적이라고 보고했다.25</li>
<li><strong>진정한 ‘무료’ 외삽</strong>: RoPE로 외삽을 하려면 위치 보간(PI)이나 야른(YaRN) 같은 추가적인 기법과 미세 조정(Fine-tuning)이 필요하다. 하지만 ALiBi는 구조적으로 외삽이 내재되어 있어, 아무런 조치 없이도 추론 길이를 늘릴 수 있는 유일한 솔루션에 가깝다.7</li>
</ol>
<h2>5.  사례 연구: MPT-7B와 BLOOM의 외삽 전략</h2>
<p>실제 대규모 서비스 모델에서 ALiBi가 어떻게 활용되었는지를 살펴보는 것은 이론적 논의를 넘어선 실용적 통찰을 제공한다.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Base as "Base Model Training"
    participant FineTune as "Fine-Tuning (StoryWriter)"
    participant Inference as "Inference Phase"

    Base-&gt;&gt;Base: "1T 토큰 학습 (L=2,048)"
    Note over Base: "ALiBi 적용됨"
    
    Base-&gt;&gt;FineTune: "모델 가중치 전달"
    FineTune-&gt;&gt;FineTune: "Books3 데이터 학습 (L=65,000)"
    Note over FineTune: "마스크 크기만 확장 (구조 변경 없음)"
    
    FineTune-&gt;&gt;Inference: "최종 모델 전달"
    Inference-&gt;&gt;Inference: "추론 수행 (L=84,000)"
    Note over Inference: "위대한 개츠비 분량 처리 가능"
</code></pre>
<h3>5.1  MosaicML MPT-7B: 2k에서 65k로의 도약</h3>
<p>MosaicML의 MPT-7B 모델은 ALiBi의 잠재력을 극적으로 보여준 사례다.</p>
<ul>
<li><strong>베이스 모델</strong>: 1조(1T) 토큰의 데이터로 훈련되었으며, 훈련 길이는 2,048 토큰이었다.</li>
<li><strong>StoryWriter 모델</strong>: 이 베이스 모델을 기반으로 소설 데이터셋(books3)을 이용해 65,000(65k) 토큰 길이로 파인튜닝(Fine-tuning)을 진행했다.</li>
<li><strong>결과</strong>: 놀랍게도, ALiBi 덕분에 모델은 65k 길이의 파인튜닝을 견뎌냈을 뿐만 아니라, 추론 시에는 84k 토큰(약 6만 단어 분량, ‘위대한 개츠비’ 소설 전체 분량)까지도 일관성 있는 텍스트를 생성해냈다.27</li>
<li><strong>의의</strong>: 만약 RoPE나 절대 위치 인코딩을 사용했다면, 2k에서 65k로 확장하기 위해 위치 임베딩을 재설계하거나 막대한 재훈련 비용을 치러야 했을 것이다. ALiBi는 단순히 마스크 크기만 늘리는 것으로 이 확장을 가능케 했다. 이는 “짧게 훈련하고(Train Short), 길게 적용한다(Test Long)“는 ALiBi의 슬로건이 허구가 아님을 증명한 기념비적 사례다.</li>
</ul>
<h3>5.2  BLOOM: 다국어 거대 모델의 선택</h3>
<p>1,760억 파라미터의 다국어 모델 BLOOM 역시 ALiBi를 채택했다. BLOOM 팀은 다양한 언어의 문법적 구조 차이와 시퀀스 길이 변화에 강건한 위치 인코딩이 필요했고, 초기 실험에서 ALiBi가 가장 우수한 일반화 성능을 보였다고 밝혔다.29 특히 훈련 리소스가 제한적인 오픈 사이언스 프로젝트 특성상, 훈련 효율성과 외삽 유연성을 동시에 제공하는 ALiBi는 최적의 선택지였다.</p>
<h2>6.  구현 및 최적화: 엔지니어링 고려사항</h2>
<p>ALiBi를 실제 프로덕션 레벨의 LLM에 적용하기 위해서는 몇 가지 기술적 세부 사항을 고려해야 한다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "Naive Implementation"
        MatMul["Q * K^T 연산"]
        MemWrite["메모리에 쓰기 (HBM)"]
        BiasCalc["ALiBi 편향 계산"]
        MemRead["메모리 읽기"]
        Add["덧셈 연산"]
        Softmax["Softmax"]
        NaivePath["느림 / 메모리 대역폭 낭비"]
    end

    subgraph "FlashAttention Optimization"
        FusedKernel["Fused Kernel (SRAM/Registers)"]
        OnTheFly["On-the-fly 편향 계산"]
        Output["최종 Output"]
        OptimPath["빠름 / 메모리 접근 최소화"]
    end

    MatMul --&gt; MemWrite --&gt; BiasCalc --&gt; Add --&gt; Softmax
    
    FusedKernel -- "메모리 쓰기 없이 즉시 계산" --&gt; OnTheFly
    OnTheFly --&gt; Output

    style FusedKernel fill:#ccf,stroke:#33f
    style OnTheFly fill:#ccf,stroke:#33f
</code></pre>
<h3>6.1  정밀도(Precision)와 오버플로우</h3>
<p>수만 토큰 이상의 초장문 시퀀스를 처리할 때, <span class="math math-inline">m \cdot |i-j|</span> 값은 상당히 커질 수 있다. 예를 들어 <span class="math math-inline">i-j=50,000</span>이고 <span class="math math-inline">m=0.5</span>라면 편향 값은 -25,000에 달한다. 이를 소프트맥스에 넣으면 <span class="math math-inline">e^{-25000}</span>이 되어 언더플로우(Underflow)가 발생, 0으로 처리된다. 반대로 기울기가 작은 헤드에서는 정밀도 손실이 발생할 수 있다. 따라서 ALiBi 편향을 계산하고 더하는 과정은 <strong>FP32(Single Precision)</strong> 로 수행하는 것이 안전하며, BF16이나 FP16 모드에서도 이 부분만큼은 높은 정밀도를 유지하도록 구현해야 한다.7</p>
<h3>6.2  커널 퓨전과 FlashAttention</h3>
<p>ALiBi는 어텐션 매트릭스 전체(<span class="math math-inline">L \times L</span>)에 덧셈 연산을 수행하므로, 나이브하게 구현하면 메모리 대역폭을 많이 소모한다. 최신 라이브러리인 FlashAttention은 ALiBi 편향을 어텐션 커널 내부에서 <strong>On-the-fly</strong>로(메모리에 쓰지 않고 레지스터에서 즉시) 계산하여 적용하는 기능을 지원한다. 이를 통해 ALiBi는 추가적인 메모리 접근 비용 없이, 표준 어텐션과 동일한 속도로 동작할 수 있다.24</p>
<h2>7.  차세대 연구: ALiBi를 넘어서</h2>
<p>ALiBi의 성공 이후, 이를 더욱 개선하려는 후속 연구들이 등장하고 있다.</p>
<ul>
<li><strong>CABLE (Context-aware Biases)</strong>: ALiBi의 편향이 고정(Static)되어 있다는 점을 지적하며, 입력 내용에 따라 편향을 동적으로 조절하는 방법을 제안했다. 이는 ALiBi의 외삽 능력은 유지하면서 표현력을 높이려는 시도다.31</li>
<li><strong>KERPLE</strong>: ALiBi의 선형 감쇠 대신 로그(Logarithmic) 감쇠나 멱법칙(Power-law) 감쇠를 적용하여, 더 먼 거리의 정보를 효과적으로 포착하려는 커널화(Kernelized) 접근법이다. 실험 결과, 로그 변형(Log Variant)이 원본 ALiBi보다 WikiText-103 등에서 더 나은 PPL을 보였다.33</li>
</ul>
<h2>8.  결론</h2>
<p>ALiBi는 트랜스포머 아키텍처의 고질적인 문제였던 길이 외삽 문제를 <strong>‘선형적 편향(Linear Bias)’</strong> 이라는 단순하고 우아한 수학적 장치로 해결했다. 이는 훈련 비용을 절감하면서도 추론 시 무한한 문맥 확장의 가능성을 열어주었으며, MPT와 BLOOM 같은 거대 모델의 성공을 통해 그 효용성이 증명되었다. 비록 RoPE와의 경쟁에서 ’장기 기억 보존’과 ‘표현력’ 측면의 도전 과제가 남아있지만, ALiBi가 제시한 “위치 임베딩 없는 위치 인식“이라는 패러다임은 향후 등장할 모든 효율적 LLM 아키텍처의 근간이 될 것이다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>Sinusoidal (APE)</strong></th><th><strong>Learned APE</strong></th><th><strong>RoPE</strong></th><th><strong>ALiBi</strong></th></tr></thead><tbody>
<tr><td><strong>위치 정보 주입</strong></td><td>입력 임베딩 +</td><td>입력 임베딩 +</td><td>Query/Key 회전</td><td><strong>Attention Score + Bias</strong></td></tr>
<tr><td><strong>학습 파라미터</strong></td><td>없음</td><td>있음 (<span class="math math-inline">L \times D</span>)</td><td>없음</td><td><strong>없음</strong></td></tr>
<tr><td><strong>외삽 성능 (Native)</strong></td><td><strong>실패 (PPL 폭발)</strong></td><td><strong>불가능</strong></td><td>제한적 (성능 저하)</td><td><strong>우수 (PPL 유지/감소)</strong></td></tr>
<tr><td><strong>장거리 의존성</strong></td><td>이론상 가능</td><td>훈련 길이에 제한</td><td>우수 (보존)</td><td><strong>거리 비례 감쇠 (Decay)</strong></td></tr>
<tr><td><strong>연산 효율성</strong></td><td>높음</td><td>높음</td><td>중간 (복소수 연산)</td><td><strong>최상 (단순 덧셈)</strong></td></tr>
<tr><td><strong>대표 모델</strong></td><td>Transformer (Original)</td><td>GPT-3</td><td>Llama 2, PaLM</td><td><strong>MPT, BLOOM</strong></td></tr>
</tbody></table>
<p><strong>표 6.3.1</strong> 주요 위치 인코딩 기법들의 특성 비교.29 ALiBi는 외삽 성능과 연산 효율성에서 독보적인 우위를 점하고 있다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>TRAIN SHORT, TEST LONG: ATTENTION WITH LINEAR BIASES ENABLES INPUT LENGTH EXTRAPOLATION - Ofir Press, https://ofir.io/train_short_test_long.pdf</li>
<li>[2108.12409] Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation - arXiv, https://arxiv.org/abs/2108.12409</li>
<li>[D] Paper Explained - ALiBi - Train Short, Test Long: Attention with linear biases enables input length extrapolation (Full Video Analysis) : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/pgsh73/d_paper_explained_alibi_train_short_test_long/</li>
<li>Masked Language Model with ALiBi and CLAP head | ICLR Blogposts 2024, https://iclr-blogposts.github.io/2024/blog/alibi-mlm/</li>
<li>Positional embeddings — NVIDIA NeMo Framework User Guide, https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/nlp/nemo_megatron/positional_embeddings.html</li>
<li>Positional Embeddings in Transformers: A Math Guide to RoPE &amp; ALiBi, https://towardsdatascience.com/positional-embeddings-in-transformers-a-math-guide-to-rope-alibi/</li>
<li>ALiBi Deep Dive: Interpolation vs. Extrapolation - SambaNova, https://sambanova.ai/blog/alibi-interpolation-vs-extrapolation</li>
<li>Long Context Windows in Generative AI: An AI Atlas Report | Emerge Haus Blog, https://www.emerge.haus/blog/long-context-windows-in-generative-ai</li>
<li>ALiBi - DEV Community, https://dev.to/alkanet88/alibi-4342</li>
<li>Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation. - arXiv, https://arxiv.org/pdf/2108.12409</li>
<li>ALiBi: Attention with Linear Biases | ML &amp; CV Consultant - Abhik Sarkar, https://www.abhik.xyz/concepts/attention/alibi</li>
<li>Sliding Window Attention Training for Efficient Large Language Models - arXiv, https://arxiv.org/pdf/2502.18845</li>
<li>ALiBi: Attention with Linear Biases | by Amy Pajak - Medium, https://medium.com/@pajakamy/alibi-attention-with-linear-biases-942abe042e9f</li>
<li>Attention with Linear Biases: ALiBi, https://www.k-a.in/pyt-alibi.html</li>
<li>Attention with Linear Biases (ALiBi) - labml.ai, https://nn.labml.ai/transformers/alibi/index.html</li>
<li>KERPLE: Kernelized Relative Positional Embedding for Length Extrapolation, https://papers.neurips.cc/paper_files/paper/2022/file/37a413841a614b5414b333585e7613b8-Paper-Conference.pdf</li>
<li>Attention Sinks in Transformer Models - Emergent Mind, https://www.emergentmind.com/topics/attention-sinks</li>
<li>Exploring Context Window of Large Language Models via Decomposed Positional Vectors - NIPS papers, https://papers.nips.cc/paper_files/paper/2024/file/1403ab1a427050538ec59c7f570aec8b-Paper-Conference.pdf</li>
<li>Question on intuition of “attention sink” and “alibi PE” · Issue #42 · mit-han-lab/streaming-llm, https://github.com/mit-han-lab/streaming-llm/issues/42</li>
<li>Round and Round We Go! What makes Rotary Positional Encodings useful? - arXiv, https://arxiv.org/html/2410.06205v1</li>
<li>Why people use RoPE instead of Alibi when buliding their models? : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/165b0tw/why_people_use_rope_instead_of_alibi_when/</li>
<li>Round and Round We Go! What makes Rotary Positional Encodings useful? - OpenReview, https://openreview.net/forum?id=GtvuNrk58a</li>
<li>Rotary Positional Embedding (RoPE) | by Devansh Sinha | Medium, https://medium.com/@dewanshsinha71/rotary-positional-embedding-rope-7bc5afb92af9</li>
<li>ALiBi FlashAttention - Speeding up ALiBi by 3-5x with a hardware-efficient implementation, https://pli.princeton.edu/blog/2024/alibi-flashattention-speeding-alibi-3-5x-hardware-efficient-implementation</li>
<li>Introducing MPT-7B: A New Standard for Open-Source, Commercially Usable LLMs, https://www.databricks.com/blog/mpt-7b</li>
<li>Optimizing LLMs for Speed and Memory - Hugging Face, https://huggingface.co/docs/transformers/en/llm_tutorial_optimization</li>
<li>mosaicml/mpt-7b - Hugging Face, https://huggingface.co/mosaicml/mpt-7b</li>
<li>mosaicml/mpt-7b-storywriter - Hugging Face, https://huggingface.co/mosaicml/mpt-7b-storywriter</li>
<li>Context-aware Biases for Length Extrapolation - arXiv, https://arxiv.org/html/2503.08067v1</li>
<li>[D] ALiBi enables transformer LMs to extrapolate to longer inputs (Video Lecture) - Reddit, https://www.reddit.com/r/MachineLearning/comments/ww146r/d_alibi_enables_transformer_lms_to_extrapolate_to/</li>
<li>Context-aware Biases for Length Extrapolation - ACL Anthology, https://aclanthology.org/2025.emnlp-main.1545.pdf</li>
<li>(PDF) Context-aware Biases for Length Extrapolation - ResearchGate, https://www.researchgate.net/publication/389748371_Context-aware_Biases_for_Length_Extrapolation</li>
<li>Toward Length-Extrapolatable Transformers | Language Technologies Institute - Carnegie Mellon University, https://www.lti.cs.cmu.edu/research/dissertations/tachungc_phd_lti_2024.pdf</li>
<li>KERPLE: Kernelized Relative Positional Embedding for Length Extrapolation - OpenReview, https://openreview.net/forum?id=hXzOqPlXDwm</li>
<li>Beyond Attention: How Advanced Positional Embedding Methods Improve upon the Original Approach in Transformer Architecture | by Elahe Aghapour - Medium, https://medium.com/data-science/beyond-attention-how-advanced-positional-embedding-methods-improve-upon-the-original-transformers-90380b74d324</li>
<li>Rope to Nope and Back Again: A New Hybrid Attention Strategy - arXiv, https://arxiv.org/pdf/2501.18795</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>