<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.3 DeBERTa - Disentangled Attention과 상대적 위치 정보의 결합</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.3 DeBERTa - Disentangled Attention과 상대적 위치 정보의 결합</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>3.3 DeBERTa - Disentangled Attention과 상대적 위치 정보의 결합</span></nav>
                </div>
            </header>
            <article>
                <h1>3.3 DeBERTa - Disentangled Attention과 상대적 위치 정보의 결합</h1>
<p>2025-12-19, G30DR</p>
<p>인공지능, 특히 자연어 처리(NLP) 분야에서 모델의 아키텍처는 기계가 언어를 이해하는 ’사고의 틀’을 규정한다. BERT(Bidirectional Encoder Representations from Transformers)의 등장이 양방향 문맥 학습이라는 새로운 지평을 열었다면, 마이크로소프트 리서치(Microsoft Research)가 제안한 DeBERTa(Decoding-enhanced BERT with disentangled attention)는 그 틀 내부의 정보 처리 방식을 근본적으로 재설계한 시도라 할 수 있다. DeBERTa는 단순히 기존 트랜스포머의 성능을 개선한 파생 모델이 아니다. 이 모델은 트랜스포머가 텍스트의 ’의미(Content)’와 ’위치(Position)’를 처리하는 방식에 존재했던 구조적 한계를 수학적으로 규명하고, 이를 ’분리(Disentanglement)’라는 개념을 통해 혁신적으로 해결했다. 본 장에서는 DeBERTa의 핵심 메커니즘인 분리된 어텐션(Disentangled Attention)과 강화된 마스크 디코더(Enhanced Mask Decoder, EMD)를 심층적으로 해부하고, 이것이 시퀀스 모델링의 패러다임을 어떻게 변화시켰는지 분석한다.</p>
<h2>1.  기존 위치 인코딩의 기하학적 딜레마와 정보 얽힘(Entanglement)</h2>
<p>트랜스포머 아키텍처의 가장 큰 특징이자 약점은 입력 데이터를 순차적이 아닌 병렬적으로 처리한다는 점이다. 이는 연산 효율성을 극대화하지만, 본질적으로 순서 정보(Sequence Order)를 상실하게 만든다. 이를 해결하기 위해 바스와니(Vaswani et al., 2017)의 원조 트랜스포머부터 BERT에 이르기까지, 대다수의 모델은 입력 임베딩에 위치 정보를 더하는 가산적(Additive) 방식을 채택했다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "BERT: 가산적 임베딩 (Information Entanglement)"
        B_Input["Input Token"] --&gt; B_Content["Content Embedding (Ec)"]
        B_Input --&gt; B_Pos["Position Embedding (Ep)"]
        B_Content --"+"--&gt; B_Sum["H = Ec + Ep (Summed Vector)"]
        B_Pos --"+"--&gt; B_Sum
        B_Sum --&gt; B_Attn["Standard Self-Attention"]
        B_Attn --&gt; B_Result["Output (Mixed Info)"]
        style B_Sum fill:#ffcccc,stroke:#333,stroke-width:2px
    end

    subgraph "DeBERTa: 분리된 임베딩 (Information Disentanglement)"
        D_Input["Input Token"] --&gt; D_Content["Content Vector (H)"]
        D_Input --&gt; D_Pos["Relative Position Vector (P)"]
        D_Content --"Separate Path"--&gt; D_Attn["Disentangled Attention Mechanism"]
        D_Pos --"Separate Path"--&gt; D_Attn
        D_Attn --&gt; D_Result["Output (Disentangled Info)"]
        style D_Content fill:#ccffcc,stroke:#333,stroke-width:2px
        style D_Pos fill:#ccffcc,stroke:#333,stroke-width:2px
    end
</code></pre>
<h3>1.1  가산적 임베딩의 한계: 정보의 불투명성</h3>
<p>BERT의 입력 표현 방식은 <span class="math math-inline">H_i = E_{content}(x_i) + E_{position}(i)</span>로 정의된다. 여기서 <span class="math math-inline">E_{content}</span>는 단어의 의미적 임베딩을, <span class="math math-inline">E_{position}</span>은 절대적 위치 임베딩을 의미한다. 이 방식은 벡터 공간 <span class="math math-inline">\mathbb{R}^d</span> 내에서 의미 정보와 위치 정보를 요소별 합(element-wise sum)을 통해 하나의 벡터 <span class="math math-inline">H_i</span>로 압축한다.1</p>
<p>이러한 접근법은 구현의 단순함에도 불구하고 ’정보의 얽힘(Entanglement)’이라는 본질적인 문제를 야기한다. 벡터의 합으로 표현된 <span class="math math-inline">H_i</span>가 어텐션 메커니즘을 통과할 때, 모델은 특정 신호가 단어의 의미적 유사성에서 기인한 것인지, 아니면 위치 정보에서 기인한 것인지를 명확히 구분하기 어렵다. 예를 들어, 어텐션 스코어(Attention Score)가 높게 계산되었을 때, 이것이 두 단어가 의미적으로 밀접하기 때문인지(예: ’deep’과 ‘learning’), 아니면 단순히 위치가 가깝기 때문인지(예: 인접한 관사와 명사)를 분해하여 해석하는 데 불필요한 학습 비용이 발생한다. 이는 모델이 문맥의 미세한 뉘앙스를 학습하는 데 방해가 되는 정보 병목(Information Bottleneck)으로 작용한다.3</p>
<h3>1.2  분리(Disentanglement)의 철학: 직교하는 정보의 독립적 처리</h3>
<p>DeBERTa 연구진은 의미와 위치 정보가 본질적으로 서로 다른 성질을 가진 정보라는 점에 주목했다. 의미 정보는 단어의 내재적 속성을 나타내며, 위치 정보는 단어 간의 관계적 속성을 나타낸다. 따라서 이 두 정보를 하나의 벡터 공간에 섞는 대신, 서로 다른 벡터 공간에서 독립적으로 처리한 후 그 결과를 결합하는 것이 더 효과적이라는 가설을 세웠다.</p>
<p>이에 따라 DeBERTa는 각 토큰을 두 개의 독립적인 벡터로 표현한다:</p>
<ol>
<li><strong>내용 벡터(Content Vector, <span class="math math-inline">H_i</span>):</strong> 토큰의 의미적 정보만을 담고 있는 벡터.</li>
<li><strong>위치 벡터(Position Vector, <span class="math math-inline">P_{i|j}</span>):</strong> 토큰 <span class="math math-inline">i</span>와 토큰 <span class="math math-inline">j</span> 사이의 상대적 위치 관계를 나타내는 벡터.</li>
</ol>
<p>이러한 분리 전략은 물리학에서 힘을 <span class="math math-inline">x</span>축과 <span class="math math-inline">y</span>축 성분으로 분해하여 분석하는 것과 유사하다. DeBERTa는 어텐션 연산 과정에서 이 두 벡터를 합치지 않고, 별도의 행렬 연산을 통해 각각의 상호작용을 계산한 뒤, 그 결과를 통합한다. 이는 정보의 손실을 방지하고, 모델이 의미와 위치라는 두 가지 요소를 명시적으로(Explicitly) 활용할 수 있게 한다.3</p>
<h2>2.  분리된 어텐션 메커니즘(Disentangled Attention Mechanism)의 수학적 해부</h2>
<p>DeBERTa의 핵심 혁신은 표준 셀프 어텐션(Standard Self-Attention) 수식을 분리된 벡터 구조에 맞게 재구성한 것에 있다. 이를 이해하기 위해서는 기존 어텐션 수식의 전개와 DeBERTa의 수식을 비교 분석해야 한다.</p>
<pre><code class="language-mermaid">graph TD
    title["Disentangled Attention Calculation Flow"]
    
    subgraph "Input Vectors"
        Qi["Query Content (Hc_i)"]
        Kj["Key Content (Hc_j)"]
        P_rel["Relative Position (P_delta)"]
    end

    subgraph "Projection (Matrices)"
        Wqc["W_q,c"]
        Wkc["W_k,c"]
        Wqr["W_q,r"]
        Wkr["W_k,r"]
    end

    %% Projections
    Qi --&gt; Wqc --&gt; Qc["Q_content"]
    Kj --&gt; Wkc --&gt; Kc["K_content"]
    P_rel --&gt; Wqr --&gt; Qr["Q_position"]
    P_rel --&gt; Wkr --&gt; Kr["K_position"]

    subgraph "Score Calculation (3 Terms)"
        Qc &amp; Kc --&gt; Op1["(a) Content-to-Content&lt;br/&gt;(Meaning Similarity)"]
        Qc &amp; Kr --&gt; Op2["(b) Content-to-Position&lt;br/&gt;(Content preference for pos)"]
        Qr &amp; Kc --&gt; Op3["(c) Position-to-Content&lt;br/&gt;(Position preference for content)"]
        
        style Op3 fill:#ffffcc,stroke:#f66,stroke-width:4px,stroke-dasharray: 5 5
    end

    Op1 --"+"--&gt; Sum["Sum of Scores"]
    Op2 --"+"--&gt; Sum
    Op3 --"+"--&gt; Sum
    
    Sum --&gt; Scale["Scaling (1 / sqrt(3d))"] --&gt; Softmax["Softmax"] --&gt; AttnOut["Attention Score"]
</code></pre>
<h3>2.1  표준 어텐션의 4항 전개와 그 한계</h3>
<p>표준 트랜스포머에서 쿼리(<span class="math math-inline">Q</span>), 키(<span class="math math-inline">K</span>)는 입력 벡터 <span class="math math-inline">H</span>에 투영 행렬 <span class="math math-inline">W</span>를 곱하여 생성된다. 만약 <span class="math math-inline">H</span>가 내용(<span class="math math-inline">C</span>)과 위치(<span class="math math-inline">P</span>)의 합(<span class="math math-inline">H = C + P</span>)이라면, 어텐션 스코어 <span class="math math-inline">A_{ij}</span>는 분배 법칙에 의해 다음과 같이 전개될 수 있다 (스케일링 팩터 제외):<br />
<span class="math math-display">
\begin{aligned} A_{i,j} &amp;= Q_i K_j^T \\ &amp;= (H_i W_Q) (H_j W_K)^T \\ &amp;= ((C_i + P_i) W_Q) ((C_j + P_j) W_K)^T \\ &amp;= \underbrace{C_i W_Q W_K^T C_j^T}_{\text{Content-to-Content}} + \underbrace{C_i W_Q W_K^T P_j^T}_{\text{Content-to-Position}} + \underbrace{P_i W_Q W_K^T C_j^T}_{\text{Position-to-Content}} + \underbrace{P_i W_Q W_K^T P_j^T}_{\text{Position-to-Position}} \end{aligned}
</span><br />
기존 BERT 모델에서는 이 네 가지 항이 하나의 내적(dot product) 연산 안에 섞여 있어, 각 항의 기여도를 개별적으로 제어하거나 모델링할 수 없다. 특히 위치 정보와 내용 정보가 동일한 투영 행렬 <span class="math math-inline">W_Q, W_K</span>를 공유한다는 점은 각 정보의 특성을 반영한 최적화된 변환을 방해한다.</p>
<h3>2.2  DeBERTa의 3항 분리 및 재구성</h3>
<p>DeBERTa는 위 네 가지 항 중 유의미한 세 가지 항을 독립적인 투영 행렬을 사용하여 개별적으로 계산한다. 토큰 <span class="math math-inline">i</span>가 토큰 <span class="math math-inline">j</span>에 주의(Attention)를 기울일 때, DeBERTa의 교차 어텐션 스코어 <span class="math math-inline">\tilde{A}_{i,j}</span>는 다음과 같이 구성된다.3<br />
<span class="math math-display">
\tilde{A}_{i,j} = \underbrace{Q_c^i K_c^j{}^T}_{(a) \text{Content-to-Content}} + \underbrace{Q_c^i K_r^{i,j}{}^T}_{(b) \text{Content-to-Position}} + \underbrace{K_c^j Q_r^{j,i}{}^T}_{(c) \text{Position-to-Content}}
</span><br />
여기서 <span class="math math-inline">Q_c, K_c, V_c</span>는 내용 벡터를 투영한 결과이며, <span class="math math-inline">Q_r, K_r</span>은 상대적 위치 벡터를 투영한 결과이다. 각 항의 의미와 수학적 디테일은 다음과 같다.</p>
<h4>2.2.1 (a) Content-to-Content (내용 대 내용)</h4>
<p><span class="math math-display">
Score_{C2C} = H_i W_{q,c} (H_j W_{k,c})^T
</span></p>
<p>이는 전통적인 의미론적 유사도를 계산한다. 위치와 무관하게 “cat“이라는 단어가 “animal“과 얼마나 관련이 있는지를 측정한다. 이 항은 기존 트랜스포머의 어텐션과 유사하지만, 위치 정보가 완전히 배제된 순수한 의미적 유사도만을 다룬다는 점에서 차이가 있다.7</p>
<h4>2.2.2 (b) Content-to-Position (내용 대 위치)</h4>
<p><span class="math math-display">
Score_{C2P} = H_i W_{q,c} (P_{\delta(i,j)} W_{k,r})^T
</span></p>
<p>이 항은 **“현재 단어(Query)의 의미가 특정 상대적 위치(Key Position)에 있는 것에 얼마나 민감한가?”**를 묻는다. 예를 들어, 영어의 주어(Subject)는 동사 앞(왼쪽)에 위치하는 경향이 있다. 이 항은 단어의 내용이 문법적 구조상 선호하는 상대적 위치를 포착한다. 여기서 <span class="math math-inline">P_{\delta(i,j)}</span>는 <span class="math math-inline">i</span>와 <span class="math math-inline">j</span> 사이의 상대 거리에 해당하는 위치 임베딩이다.2</p>
<h4>2.2.3 (c) Position-to-Content (위치 대 내용): 결정적 혁신</h4>
<p><span class="math math-display">
Score_{P2C} = P_{\delta(j,i)} W_{q,r} (H_j W_{k,c})^T
</span></p>
<p>DeBERTa의 가장 독창적인 기여는 바로 이 Position-to-Content 항의 명시적 활용이다. 기존의 상대적 위치 인코딩을 제안한 연구들(Shaw et al., 2018 등)은 주로 Content-to-Position 항에 집중하거나, 위치 정보를 편향(Bias) 값으로만 더해주었다. 그러나 DeBERTa 연구진은 **“특정 위치(Query Position)에 있는 단어가 어떤 내용(Key Content)일 때 중요한가?”**라는 역방향의 질문 역시 문맥 이해에 필수적이라고 주장했다.7</p>
<p>이 항은 문법적 호응 관계를 모델링하는 데 결정적이다. 예를 들어, “deep learning“이라는 구문에서 “deep”(<span class="math math-inline">i</span>)의 관점에서 볼 때, 바로 오른쪽(<span class="math math-inline">+1</span>) 위치에 “learning“과 같은 명사(<span class="math math-inline">j</span>의 내용)가 올 때 강한 어텐션을 주어야 한다. 즉, 위치 정보가 쿼리(Query)가 되고, 내용 정보가 키(Key)가 되는 관계를 모델링함으로써, 모델은 “내 위치 기준으로 <span class="math math-inline">+1</span> 거리에 있는 단어가 명사라면 집중하라“와 같은 고차원적인 문법 규칙을 학습할 수 있다.3 이는 언어의 구문론적(Syntactic) 특성을 포착하는 능력을 비약적으로 향상시킨다.</p>
<p><em>참고:</em> 수식에서 상대 거리 함수 <span class="math math-inline">\delta</span>의 인자가 <span class="math math-inline">(j, i)</span>로 사용된 것에 유의해야 한다. 이는 위치-내용 관계에서 기준점(Query)이 위치 벡터가 되기 때문에, 거리 계산의 방향성을 유지하기 위함이다.2</p>
<h4>2.2.4 (d) Position-to-Position 항의 제거와 그 이유</h4>
<p>DeBERTa는 네 번째 항인 Position-to-Position (<span class="math math-inline">P_i \cdot P_j</span>)을 의도적으로 제거했다. 기존 절대 위치 인코딩을 사용하는 모델에서는 이 항이 위치 간의 고정된 관계를 학습할 수 있으나, DeBERTa는 상대적 위치 인코딩을 사용한다. 상대적 위치 인코딩에서 토큰 <span class="math math-inline">i</span>와 <span class="math math-inline">j</span>의 관계는 이미 상대 거리 <span class="math math-inline">\delta(i, j)</span>를 통해 <span class="math math-inline">P_{\delta(i,j)}</span>에 내재되어 있다. 따라서 추가적인 위치 벡터 간의 내적은 정보량이 적거나 중복된다고 판단하여 연산 효율성을 위해 제외되었다.4</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Query: i (Position)"
        Loc_i["Position i (Start)"]
        Rel_Dist["Relative Distance = +1"]
        Loc_i --&gt; Rel_Dist
        Rel_Dist --&gt; Q_vector["Query Vector: Relative Position"]
        note_Q["'내 위치에서 +1 거리에 있는 단어는?'"]
    end

    subgraph "Key: j (Content)"
        Word_j["Word: 'learning'"]
        Word_j --&gt; K_vector["Key Vector: Content Embedding"]
        note_K["'내용은 명사(Noun)다'"]
    end

    Q_vector --"Interaction (Dot Product)"--&gt; Interaction{"High Attention Score"}
    K_vector --&gt; Interaction

    Interaction --&gt; Meaning["Syntactic Rule Learned:&lt;br/&gt;Target at +1 is Noun -&gt; Focus!"]
    
    style Interaction fill:#ffeb3b,stroke:#333,stroke-width:2px
    style Q_vector fill:#e1f5fe
    style K_vector fill:#e1f5fe
</code></pre>
<h3>2.3  스케일링 팩터의 조정 (<span class="math math-inline">\sqrt{3d}</span>)</h3>
<p>표준 트랜스포머는 어텐션 스코어의 분산을 일정하게 유지하기 위해 <span class="math math-inline">\sqrt{d}</span> (차원 수의 제곱근)로 나누어주는 스케일링을 수행한다. 그러나 DeBERTa는 어텐션 스코어가 세 개의 항(C2C, C2P, P2C)의 합으로 구성되므로, 단일 항일 때보다 결과값의 크기와 분산이 더 커질 수 있다. 이를 보정하고 학습 안정성을 확보하기 위해 DeBERTa는 스케일링 팩터로 <span class="math math-inline">\sqrt{3d}</span>를 사용한다.2<br />
<span class="math math-display">
\text{Attention}_{i,j} = \text{softmax}\left(\frac{\tilde{A}_{i,j}}{\sqrt{3d}}\right)
</span><br />
이는 단순한 수치 조정을 넘어, 다중 소스 정보 결합 시 발생할 수 있는 그라디언트 폭주(Gradient Exploding)나 소실(Vanishing) 문제를 미연에 방지하는 세심한 엔지니어링적 최적화이다.</p>
<h3>2.4  데이터 구조 비교: DeBERTa vs Standard Transformer</h3>
<p>다음 표는 표준 트랜스포머와 DeBERTa의 어텐션 메커니즘 구성을 비교한 것이다.</p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>표준 트랜스포머 (BERT/RoBERTa)</strong></th><th><strong>DeBERTa</strong></th></tr></thead><tbody>
<tr><td><strong>입력 표현</strong></td><td><span class="math math-inline">H = C + P</span> (합산)</td><td><span class="math math-inline">H</span> (내용), <span class="math math-inline">P</span> (상대 위치) (분리)</td></tr>
<tr><td><strong>어텐션 연산</strong></td><td><span class="math math-inline">(C+P)W_Q \times ((C+P)W_K)^T</span></td><td><span class="math math-inline">C2C + C2P + P2C</span> (개별 연산 후 합산)</td></tr>
<tr><td><strong>위치 정보 활용</strong></td><td>암묵적 혼합 (Implicit Mixing)</td><td>명시적 상호작용 (Explicit Interaction)</td></tr>
<tr><td><strong>P2C 항</strong></td><td>혼합되어 구분 불가</td><td>독립적으로 계산 및 활용</td></tr>
<tr><td><strong>스케일링</strong></td><td><span class="math math-inline">1/\sqrt{d}</span></td><td><span class="math math-inline">1/\sqrt{3d}</span></td></tr>
</tbody></table>
<p>이 표에서 알 수 있듯이, DeBERTa는 연산의 복잡도가 증가하는 것을 감수하고서라도 정보의 명확한 분리와 상호작용을 택했다. 이는 모델의 파라미터 효율성을 높이고 수렴 속도를 가속화하는 결과를 낳는다.</p>
<h2>3.  상대적 위치 인코딩(Relative Positional Encoding)의 심화 분석</h2>
<p>DeBERTa의 분리된 어텐션은 상대적 위치 인코딩을 전제로 한다. 절대적 위치(Absolute Position) <span class="math math-inline">i, j</span> 대신 두 토큰 사이의 거리 <span class="math math-inline">i-j</span>를 사용하는 것은 시퀀스 길이가 가변적인 NLP 태스크에서 일반화 성능을 높이는 데 유리하다. 그러나 DeBERTa의 방식은 기존의 상대적 위치 인코딩 방식들과 뚜렷한 차이점을 보인다.</p>
<h3>3.1  상대 거리 정의 및 버킷팅 메커니즘</h3>
<p>시퀀스 길이가 <span class="math math-inline">N</span>일 때, 모든 가능한 거리쌍을 표현하려면 <span class="math math-inline">2N-1</span>개의 임베딩이 필요하다. 그러나 자연어에서 문법적 종속성은 대부분 국소적인 범위(Local Context) 내에서 발생한다. DeBERTa는 최대 상대 거리 <span class="math math-inline">k</span>를 설정하고, 그 범위를 벗어나는 거리는 <span class="math math-inline">k</span>로 클리핑(clipping)하는 전략을 사용한다.</p>
<p>상대 거리 인덱스 <span class="math math-inline">\delta(i, j)</span>는 다음과 같이 정의된다 3:<br />
<span class="math math-display">
\delta(i, j) = \begin{cases}  0 &amp; \text{if } i - j \leq -k \\ 2k - 1 &amp; \text{if } i - j \geq k \\ i - j + k &amp; \text{otherwise} \end{cases}
</span><br />
이 수식에 따르면 상대 거리 인덱스는 <span class="math math-inline">0</span>부터 <span class="math math-inline">2k-1</span>까지의 값을 가지며, 모델은 이 인덱스를 사용하여 크기가 <span class="math math-inline">2k \times d</span>인 공유된 상대 위치 임베딩 행렬 <span class="math math-inline">P</span>에서 해당 벡터를 조회(Lookup)한다. 이는 시퀀스 길이 <span class="math math-inline">N</span>이 아무리 길어져도 위치 임베딩 파라미터의 수는 고정(<span class="math math-inline">2k</span>)됨을 의미하며, 긴 시퀀스로의 외삽(Extrapolation)을 용이하게 한다.</p>
<pre><code class="language-mermaid">graph TB
    Start["Calculate Distance: d = i - j"] --&gt; CheckMax["Check Upper Bound (d &gt;= k)"]
    
    CheckMax --"Yes"--&gt; SetMax["Index = 2k - 1"]
    CheckMax --"No"--&gt; CheckMin["Check Lower Bound (d &lt;= -k)"]
    
    CheckMin --"Yes"--&gt; SetMin["Index = 0"]
    CheckMin --"No"--&gt; CalcRel["Index = d + k"]
    
    SetMax --&gt; Lookup["Lookup in Relative Position Matrix P"]
    SetMin --&gt; Lookup
    CalcRel --&gt; Lookup
    
    Lookup --&gt; Output["Relative Position Vector P_delta"]

    subgraph "Example (k=2)"
        Ex1["i-j = 5 (&gt;=2) -&gt; Index 3"]
        Ex2["i-j = -5 (&lt;= -2) -&gt; Index 0"]
        Ex3["i-j = 0 -&gt; Index 2"]
    end
</code></pre>
<h3>3.2  기존 방법론(Shaw et al., T5)과의 비교: 편향(Bias) 대 상호작용(Interaction)</h3>
<p>상대적 위치 정보를 활용하는 선행 연구들과 DeBERTa의 가장 결정적인 차이는 위치 정보가 어텐션 스코어에 개입하는 방식에 있다.</p>
<ol>
<li>Shaw et al. (2018) 및 T5 모델:</li>
</ol>
<p>이 모델들은 상대적 위치 정보를 주로 어텐션 스코어에 더해지는 편향(Bias) 항으로 처리한다.<br />
<span class="math math-display">
   A_{ij} = Q_i K_j^T + b_{i,j}
</span><br />
여기서 <span class="math math-inline">b_{i,j}</span>는 상대적 거리에 따라 학습된 스칼라 값(또는 헤드별로 학습된 값)이다. 이 방식에서 위치 정보는 내용 정보(<span class="math math-inline">Q, K</span>)와 독립적으로 작용한다. 즉, 내용이 무엇이든 간에 거리가 가까우면 점수를 더하고, 멀면 점수를 뺀다는 식의 단순한 가산적 효과만을 갖는다.10 이는 위치 정보가 내용과 유기적으로 결합되지 못한다는 한계를 지닌다.</p>
<ol start="2">
<li>DeBERTa:</li>
</ol>
<p>DeBERTa는 상대적 위치 정보를 내용 벡터와 곱(Product), 즉 내적을 통해 상호작용시킨다.<br />
<span class="math math-display">
   A_{ij} \approx Q_c K_c^T + Q_c K_r^T + K_c Q_r^T
</span><br />
이 수식에서 <span class="math math-inline">Q_c K_r^T</span> (Content-to-Position)와 <span class="math math-inline">K_c Q_r^T</span> (Position-to-Content) 항은 내용 벡터와 위치 벡터가 직접적으로 곱해지는 구조를 가진다. 이는 단순한 거리 편향이 아니라, **“이 내용(Content)은 저 위치(Position)와 결합될 때 특별한 의미를 갖는다”**는 조건부 확률과 유사한 복잡한 관계를 모델링한다.3</p>
<p>예를 들어, T5 방식은 “거리가 1인 단어는 무조건 중요하다“라고 학습한다면, DeBERTa는 “단어 A가 단어 B로부터 거리 1에 있을 때, 단어 B가 명사라면 중요하다“는 식의 맥락적 위치 정보를 학습할 수 있다. 이러한 **상호작용 기반의 위치 인코딩(Interaction-based Positional Encoding)**은 DeBERTa가 기존 모델 대비 훨씬 정교한 언어 이해 능력을 갖추게 된 원동력이다.</p>
<h2>4.  상대성의 딜레마와 강화된 마스크 디코더 (Enhanced Mask Decoder, EMD)</h2>
<p>분리된 어텐션과 상대적 위치 인코딩은 문맥의 국소적 관계와 상대적 거리에 따른 의미 변화를 포착하는 데 탁월하다. 그러나 이 접근법에는 역설적이게도 치명적인 맹점이 존재한다. 바로 <strong>절대적 위치 정보(Absolute Position Information)의 상실</strong>이다. 모든 것을 ’상대적’으로만 파악할 때, 전체적인 구조 속에서의 ‘절대적’ 위치를 놓칠 수 있다.</p>
<h3>4.1  “Store vs Mall” 문제: 절대 위치의 필요성</h3>
<p>DeBERTa 논문의 저자들은 상대적 위치 정보만으로는 해결하기 어려운 구문론적 모호성을 설명하기 위해 다음과 같은 예시를 제시한다.2</p>
<blockquote>
<p>“A new <strong>store</strong> opened beside the new <strong>mall</strong>”</p>
</blockquote>
<p>이 문장에서 “store“와 “mall“이 마스킹(Masking)되었다고 가정해보자. 두 단어 모두 “new“라는 형용사 뒤에 위치하며, 문맥적으로 장소를 나타내는 명사라는 점에서 국소적 문맥(Local Context)이 매우 유사하다. 상대적 관점에서는 두 패턴이 (<span class="math math-inline">new \rightarrow \text{}</span>)로 거의 동일하게 보인다.</p>
<p>만약 모델이 오로지 상대적 위치 정보만 사용한다면, “store“가 문장의 주어 위치(문두)에 있고, “mall“이 전치사구의 목적어 위치(문미)에 있다는 구조적 차이를 명확히 구분하기 어렵다. 그러나 인간은 “opened beside“라는 동사구의 앞과 뒤라는 절대적 위치 흐름을 통해 누가 주체이고 객체인지를 파악한다. 이처럼 문장의 전체적인 구문 구조(Syntactic Structure)를 파악하고 복원하기 위해서는 토큰의 절대적인 위치 정보가 필수적이다.</p>
<p>BERT는 입력단에서 절대 위치 임베딩을 더해버리므로 이 정보를 처음부터 가지고 있지만, DeBERTa는 이를 분리하고 상대적 거리만 사용했기에 인코더 단계에서는 이 정보가 결여되어 있다.</p>
<h3>4.2  EMD 아키텍처: 늦은 통합 (Late Fusion) 전략</h3>
<p>이 문제를 해결하기 위해 DeBERTa는 **강화된 마스크 디코더(Enhanced Mask Decoder, EMD)**를 도입한다. 핵심 아이디어는 **“절대 위치 정보를 인코더의 입력단이 아닌, 최상위 레이어(디코더 직전)에 주입하자”**는 ‘늦은 통합(Late Fusion)’ 전략이다.</p>
<p>DeBERTa 연구진은 BERT처럼 초기 단계에서 절대 위치 정보를 섞어버리면, 모델이 상대적 위치 관계를 학습하는 데 방해가 될 수 있다고 판단했다. 따라서 트랜스포머의 모든 <span class="math math-inline">N</span>개 레이어(Transformer Layers)에서는 순수하게 분리된 어텐션과 상대적 위치 정보만을 사용하여 풍부한 문맥 표상을 학습하게 한다. 그리고 마지막에 마스크드 언어 모델(MLM) 예측을 수행하기 직전, 별도의 EMD 블록에서 절대 위치 임베딩(Absolute Position Embeddings)을 은닉 상태(Hidden States)와 결합한다.1</p>
<p>EMD의 작동 원리는 다음과 같다:</p>
<ol>
<li>
<p><strong>입력(<span class="math math-inline">H</span>):</strong> 트랜스포머 인코더의 마지막 레이어 출력. 여기에는 문맥 정보와 상대적 위치 정보가 고도로 추상화되어 있다.</p>
</li>
<li>
<p><strong>주입(<span class="math math-inline">I</span>):</strong> 절대 위치 임베딩(<span class="math math-inline">P_{abs}</span>).</p>
</li>
<li>
<p>연산: <span class="math math-inline">H</span>와 <span class="math math-inline">I</span>를 결합하여 추가적인 트랜스포머 레이어(DeBERTa에서는 <span class="math math-inline">n=2</span> 설정)를 통과시킨 후 최종 Softmax 레이어로 전달한다.<br />
<span class="math math-display">
H_{final} = \text{EMD}(H, P_{abs})
</span></p>
</li>
</ol>
<p>이러한 구조는 모델이 초기에는 단어 간의 관계(Relative)에 집중하여 의미를 파악하고, 마지막 단계에서 전체적인 구조(Absolute)를 참조하여 정답을 확정 짓도록 유도한다. 이는 인간이 문장을 이해할 때 단어 간의 관계를 먼저 파악하고, 나중에 전체적인 문장 구조를 확정 짓는 인지 과정과도 유사성을 갖는다. 실험 결과, EMD를 적용한 모델은 그렇지 않은 모델보다 SQuAD, MNLI 등 다양한 태스크에서 우수한 성능을 보였다.12</p>
<pre><code class="language-mermaid">graph TD
    subgraph "DeBERTa Encoder (N Layers)"
        Input["Input Tokens"] --&gt; Rel_Attn["Disentangled Attention&lt;br/&gt;(Relative Pos Only)"]
        Rel_Attn --&gt; Hidden["Hidden States (Contextualized)"]
        note_enc["Syntactic/Semantic Understanding&lt;br/&gt;(No Absolute Position)"]
    end

    Hidden --&gt; EMD_Start["EMD Input"]

    subgraph "Enhanced Mask Decoder (EMD)"
        Abs_Pos["Absolute Position Embeddings (P_abs)"]
        EMD_Start --"Combine"--&gt; Fusion["Inject Absolute Position"]
        Abs_Pos --&gt; Fusion
        
        Fusion --&gt; EMD_Layer1["Transformer Layer (n=1)"]
        EMD_Layer1 --&gt; EMD_Layer2["Transformer Layer (n=2)"]
    end

    EMD_Layer2 --&gt; Softmax["Softmax Layer"]
    Softmax --&gt; Output["Final Prediction (MLM)"]
    
    style Abs_Pos fill:#ffcc80,stroke:#333
    style Fusion fill:#ffe0b2,stroke:#333
    style Hidden fill:#b2dfdb,stroke:#333
</code></pre>
<h2>5.  성능 평가 및 계산 복잡도 분석</h2>
<p>DeBERTa의 이론적 우수성은 실제 벤치마크 테스트를 통해 입증되었다.</p>
<h3>5.1  SuperGLUE와 NLU 태스크에서의 압도적 성과</h3>
<p>DeBERTa 1.5B(15억 파라미터) 모델은 SuperGLUE 벤치마크에서 단일 모델 최초로 인간의 기준선(Human Baseline, 89.8점)을 상회하는 89.9점(앙상블 시 90.3점)을 기록했다. 이는 당시 최강 모델이었던 T5-11B(110억 파라미터)보다 파라미터 수가 훨씬 적음에도 불구하고 달성한 성과라는 점에서 더욱 의미가 크다.3</p>
<p>특히 주목할 만한 점은 학습 효율성(Sample Efficiency)이다. RoBERTa-Large와 비교했을 때, 절반의 학습 데이터만으로도 MNLI(자연어 추론), SQuAD(질의응답), RACE(독해) 등 다양한 NLU 태스크에서 일관되게 더 높은 성능을 보였다.12 이는 분리된 어텐션 메커니즘이 불필요한 정보 간섭을 줄여 모델이 언어의 핵심 패턴을 더 빠르고 정확하게 학습하도록 도왔음을 시사한다.</p>
<h3>5.2  계산 복잡도와 최적화</h3>
<p>분리된 어텐션 메커니즘은 필연적으로 연산량의 증가를 수반한다. 표준 어텐션이 1번의 <span class="math math-inline">QK^T</span> 연산을 수행하는 반면, DeBERTa는 <span class="math math-inline">Q_c K_c^T</span>, <span class="math math-inline">Q_c K_r^T</span>, <span class="math math-inline">K_c Q_r^T</span> 등 3번의 행렬 곱셈을 수행해야 하기 때문이다. 이론적으로 이는 <span class="math math-inline">O(N^2 d)</span>의 복잡도를 가지며, 상수항이 3배가 되는 효과가 있다.</p>
<p>그러나 DeBERTa 연구진은 파라미터 공유와 효율적인 행렬 연산 최적화를 통해 이러한 오버헤드를 최소화했다.</p>
<ol>
<li><strong>메모리 효율성:</strong> 절대 위치 행렬(<span class="math math-inline">N \times d</span>) 대신 상대 위치 행렬(<span class="math math-inline">2k \times d</span>)을 사용하므로, <span class="math math-inline">k \ll N</span>인 긴 시퀀스 처리 시 메모리 이점이 있다.</li>
<li><strong>구현 최적화:</strong> <span class="math math-inline">K_r</span>과 <span class="math math-inline">Q_r</span>은 모든 레이어에서 공유되거나 미리 계산될 수 있어, 반복적인 투영 연산을 줄일 수 있다.</li>
</ol>
<p>추론 속도 면에서는 BERT나 RoBERTa 대비 약간의 지연(Overhead)이 발생할 수 있지만, 학습 단계의 빠른 수렴 속도와 동일 크기 모델 대비 압도적인 성능 향상은 이러한 비용을 충분히 상쇄한다.5</p>
<h2>6.  요약 및 시사점: 위치 정보 처리의 패러다임 시프트</h2>
<p>DeBERTa의 3.3절에서 다룬 내용은 단순한 아키텍처의 변형이 아니다. 이는 언어 모델이 텍스트를 “어떻게 바라봐야 하는가“에 대한 근본적인 질문에 대해, “의미와 구조(위치)는 서로 다른 차원에서 다루어져야 하며, 그들의 상호작용은 명시적이어야 한다“는 강력한 대답을 제시한 것이다.</p>
<p>DeBERTa가 이룩한 성과는 다음 세 가지로 요약될 수 있다:</p>
<ol>
<li><strong>벡터 공간의 분리(Vector Space Disentanglement):</strong> 내용과 위치를 섞지 않고 끝까지 분리하여 유지함으로써, 정보의 손실을 막고 각각의 정보를 명확하게 활용했다. 이는 가산적 임베딩이 지배하던 시대를 끝내고 분리적 접근의 효용성을 증명했다.</li>
<li><strong>양방향 상호작용(Bi-directional Interaction):</strong> 특히 <strong>Position-to-Content</strong> 항을 통해 위치가 내용을 탐색하는 새로운 어텐션 경로를 개척했다. 이는 단순한 거리 편향을 넘어선 진정한 의미의 ’위치 기반 문맥 이해’를 가능하게 했다.</li>
<li><strong>EMD를 통한 보완:</strong> 상대적 위치 정보만으로는 부족한 구문론적 정보를 EMD를 통해 영리하게 보완함으로써, 상대성과 절대성의 장점을 모두 취하는 하이브리드 전략의 성공 사례를 남겼다.</li>
</ol>
<p>이러한 통찰은 이후 등장하는 거대 언어 모델(LLM)들의 위치 인코딩 전략(예: RoPE의 회전 변환, ALiBi의 선형 편향)에도 직간접적인 영감을 주었으며, 인코더 모델의 발전사에서 DeBERTa를 ’가장 완성된 형태의 BERT’로 기억되게 만들었다. DeBERTa의 성공은 단순히 점수 1~2점을 올린 것이 아니라, 모델이 언어라는 복잡한 신호를 해독하는 해상도(Resolution) 자체를 높인 결과라 평가할 수 있다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>DeBERTa: Decoding-enhanced BERT with Disentangled Attention, https://iclr.cc/media/iclr-2021/Slides/2562.pdf</li>
<li>Large Language Models: DeBERTa - Decoding-Enhanced BERT with Disentangled Attention | Towards Data Science, https://towardsdatascience.com/large-language-models-deberta-decoding-enhanced-bert-with-disentangled-attention-90016668db4b/</li>
<li>deberta: decoding-enhanced bert with dis - arXiv, https://arxiv.org/pdf/2006.03654</li>
<li>DeBERTa: Enhancing Token Positioning Awareness in BERT - Demystify ML, https://demystifyml.co/deberta-enhancing-token-positioning-awareness-in-bert</li>
<li>[PDF] DeBERTa: Decoding-enhanced BERT with Disentangled Attention | Semantic Scholar, https://www.semanticscholar.org/paper/DeBERTa%3A-Decoding-enhanced-BERT-with-Disentangled-He-Liu/14b65a86c82e38fce0eb3506e0d4084ad5cdb583</li>
<li>Papers Explained 08: DeBERTa. DeBERTa (Decoding-enhanced BERT with… | by Ritvik Rastogi | DAIR.AI | Medium, https://medium.com/dair-ai/papers-explained-08-deberta-a808d9b2c52d</li>
<li>Brief Review — DeBERTa: Decoding-enhanced BERT with Disentangled Attention, https://sh-tsang.medium.com/brief-review-deberta-decoding-enhanced-bert-with-disentangled-attention-f5cdb9a8bf0b</li>
<li>DEBERTA: DECODING-ENHANCED BERT WITH DIS- ENTANGLED ATTENTION - OpenReview, https://openreview.net/pdf?id=XPZIaotutsD</li>
<li>DeBERTa: Decoding-enhanced BERT with Disentangled Attention - Medium, https://medium.com/@Mustafa77/deberta-decoding-enhanced-bert-with-disentangled-attention-24948be8958c</li>
<li>Relative Positional Encoding - Jake Tae, https://jaketae.github.io/study/relative-positional-encoding/</li>
<li>position information in transformers: an overview - arXiv, https://arxiv.org/pdf/2102.11090</li>
<li>[Quick Review] DeBERTa: Decoding-enhanced BERT with Disentangled Attention - Liner, https://liner.com/review/deberta-decodingenhanced-bert-with-disentangled-attention</li>
<li>DeBERTa: Decoding-Enhanced BERT with Disentangled Attention - Microsoft Research, https://www.microsoft.com/en-us/research/publication/deberta-decoding-enhanced-bert-with-disentangled-attention-2/</li>
<li>[2006.03654] DeBERTa: Decoding-enhanced BERT with Disentangled Attention - arXiv, https://arxiv.org/abs/2006.03654</li>
<li>[D] Paper Explained - DeBERTa: Decoding-enhanced BERT with Disentangled Attention (Full Video Analysis) : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/lsgkln/d_paper_explained_deberta_decodingenhanced_bert/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>