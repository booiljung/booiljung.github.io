<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:15.3 DPO, KTO 인간 선호 정렬(Alignment)의 최신 기법</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>15.3 DPO, KTO 인간 선호 정렬(Alignment)의 최신 기법</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>15.3 DPO, KTO 인간 선호 정렬(Alignment)의 최신 기법</span></nav>
                </div>
            </header>
            <article>
                <h1>15.3 DPO, KTO 인간 선호 정렬(Alignment)의 최신 기법</h1>
<p>2025-12-25, G30DR</p>
<h3>0.1 서론: RLHF의 해체와 직접 정렬(Direct Alignment)의 시대</h3>
<p>2025년 12월, 인공지능 기술의 발전사를 되돌아볼 때, 2023년부터 2025년 사이의 기간은 대규모 언어 모델(LLM)의 ‘정렬(Alignment)’ 기술이 근본적인 구조적 변혁을 겪은 시기로 기록된다. 트랜스포머 아키텍처가 범용 인공지능(AGI)을 향한 하드웨어적, 구조적 수렴을 이루는 ‘싱귤래리티(Singularity)’ 과정에 진입했다면, 소프트웨어적 측면에서 모델을 인간의 의도, 윤리, 그리고 논리적 사고 체계에 일치시키는 정렬 기술은 복잡성을 제거하고 효율성을 극대화하는 방향으로 진화했다.</p>
<p>2022년 말 ChatGPT의 등장과 함께 표준으로 자리 잡았던 ’인간 피드백을 통한 강화학습(RLHF, Reinforcement Learning from Human Feedback)’은 강력했지만 비효율적이었다. 당시의 표준 파이프라인은 (1) 지도 미세 조정(SFT), (2) 보상 모델(Reward Model, RM) 훈련, (3) PPO(Proximal Policy Optimization)를 이용한 정책 최적화라는 3단계의 복잡한 공정을 요구했다. 특히 PPO는 본질적으로 불안정하고, 하이퍼파라미터에 극도로 민감하며, 가치 함수(Value Function)와 정책 네트워크(Policy Network)를 동시에 메모리에 올려야 하는 막대한 계산 비용을 수반했다.</p>
<p>그러나 2023년 스탠포드 대학 연구진이 제안한 **DPO(Direct Preference Optimization)**는 이 모든 과정을 하나의 수학적 통찰로 압축했다. “언어 모델 자체가 보상 모델이다“라는 이 혁명적인 발상은 별도의 보상 모델 훈련 없이 선호 데이터를 통해 정책 네트워크를 직접 최적화할 수 있는 길을 열었다. 이어 2024년에는 인간 심리학의 전망 이론(Prospect Theory)을 도입하여 데이터 효율성을 극대화한 **KTO(Kahneman-Tversky Optimization)**가 등장했고, 참조 모델(Reference Model)의 메모리 병목을 제거한 <strong>SimPO(Simple Preference Optimization)</strong>, 그리고 추론(Reasoning) 능력의 비약적 상승을 이끈 <strong>GRPO(Group Relative Policy Optimization)</strong> 등이 연이어 발표되며 정렬 기술의 춘추전국시대를 열었다.1</p>
<p>본 장에서는 2025년 현재 LLM 훈련의 표준이 된 이 기술들의 수학적 원리와 작동 메커니즘, 그리고 각 기법이 모델의 ’행동’과 ’사고’에 미치는 영향을 심층적으로 분석한다. 우리는 RLHF의 복잡성이 어떻게 해체되었는지, 그리고 인간의 미묘한 선호가 어떻게 수식으로 번역되어 기계의 신경망에 각인되는지 탐구할 것이다.</p>
<h2>1.  직접 선호 최적화 (DPO): 정렬의 수학적 재정의</h2>
<h3>1.1  RLHF의 한계와 DPO의 등장이 갖는 의미</h3>
<p>전통적인 RLHF, 특히 PPO 기반의 접근법은 강화학습의 강력한 탐색(Exploration) 능력을 활용하여 모델을 인간의 선호에 맞추려 했다. 그러나 언어 생성이라는 이산적(Discrete) 행동 공간에서 PPO를 안정적으로 학습시키는 것은 매우 난해한 작업이었다. 보상 모델은 종종 모델의 출력을 과도하게 단순화하거나 보상 해킹(Reward Hacking)에 취약했고, 정책 모델이 초기 SFT 모델에서 너무 멀어지지 않도록 강제하는 KL 발산(Kullback-Leibler Divergence) 페널티를 조절하는 것은 섬세한 예술의 영역에 가까웠다.</p>
<p>DPO의 핵심 기여는 RLHF를 강화학습 문제가 아닌 <strong>분류(Classification) 문제</strong>로 재정의했다는 데 있다. 기존 RLHF의 목적 함수는 다음과 같았다:<br />
<span class="math math-display">
\max_{\pi_\theta} \mathbb{E}_{x \sim \mathcal{D}, y \sim \pi_\theta(y|x)} [r_\phi(x, y)] - \beta \mathbb{D}_{KL}(\pi_\theta(y|x) | | \pi_{\text{ref}}(y|x))
</span><br />
여기서 <span class="math math-inline">r_\phi</span>는 학습된 보상 모델이고, <span class="math math-inline">\pi_{\text{ref}}</span>는 참조 모델(주로 SFT 모델)이다. DPO 연구진은 이 최적화 문제의 최적 해(Optimal Policy) <span class="math math-inline">\pi^*</span>가 보상 함수 <span class="math math-inline">r</span>에 대해 닫힌 형태(Closed Form)로 표현될 수 있음을 수학적으로 증명했다. 이를 역으로 이용하여, 보상 함수 <span class="math math-inline">r</span>을 최적 정책 <span class="math math-inline">\pi^*</span>와 참조 정책 <span class="math math-inline">\pi_{\text{ref}}</span>의 로그 확률 비율(Log-probability Ratio)로 표현하는 식을 유도해냈다 1:<br />
<span class="math math-display">
r^*(x, y) = \beta \log \frac{\pi^*(y|x)}{\pi_{\text{ref}}(y|x)} + \beta \log Z(x)
</span><br />
이 식은 “보상이 높다는 것은 참조 모델 대비 최적 모델이 해당 응답을 생성할 확률이 높다는 것과 동치“라는 직관을 수학적으로 공식화한 것이다. 이를 Bradley-Terry 선호 모델(두 대안 중 하나를 선택할 확률을 모델링하는 통계적 기법)에 대입함으로써, 우리는 보상 모델 <span class="math math-inline">r</span> 없이 정책 네트워크 <span class="math math-inline">\pi_\theta</span>를 직접 업데이트하는 DPO의 손실 함수를 얻게 된다.</p>
<h3>1.2  DPO 손실 함수의 심층 분석</h3>
<p>DPO의 손실 함수는 선호 데이터 쌍 <span class="math math-inline">(x, y_w, y_l)</span>이 주어졌을 때, 선호된 응답 <span class="math math-inline">y_w</span>와 비선호된 응답 <span class="math math-inline">y_l</span> 사이의 암시적 보상 차이를 최대화하는 방향으로 모델을 학습시킨다. 수식은 다음과 같다:<br />
<span class="math math-display">
\mathcal{L}_{\text{DPO}}(\pi_\theta; \pi_{\text{ref}}) = -\mathbb{E}_{(x, y_w, y_l) \sim \mathcal{D}} \left[ \log \sigma \left( \beta \log \frac{\pi_\theta(y_w|x)}{\pi_{\text{ref}}(y_w|x)} - \beta \log \frac{\pi_\theta(y_l|x)}{\pi_{\text{ref}}(y_l|x)} \right) \right]
</span><br />
여기서 <span class="math math-inline">\sigma</span>는 로지스틱 시그모이드 함수이다. 이 수식의 내부를 들여다보면, DPO의 작동 원리에 대한 깊은 통찰을 얻을 수 있다.</p>
<ol>
<li><strong>로그 확률 비율(Log Probability Ratio):</strong> 식의 핵심 항인 <span class="math math-inline">\log \frac{\pi_\theta(y|x)}{\pi_{\text{ref}}(y|x)}</span>는 모델이 참조 모델 대비 해당 응답을 얼마나 ‘더’ 선호하는지를 나타내는 척도다. DPO는 <span class="math math-inline">y_w</span>에 대한 이 비율을 높이고, <span class="math math-inline">y_l</span>에 대한 이 비율을 낮추도록 강제한다. 즉, 단순히 <span class="math math-inline">y_w</span>의 확률을 높이는 것이 아니라, <strong>참조 모델이 생성할 법한 확률 대비</strong> 더 높이도록 유도함으로써, 언어적 유창성을 유지하면서(참조 모델의 지식 보존) 선호도만 조정하는 효과를 낸다.4</li>
<li><strong>동적 가중치(Dynamic Importance Weighting):</strong> DPO 손실 함수의 기울기(Gradient)를 분석해보면 흥미로운 특성이 발견된다. 모델이 이미 <span class="math math-inline">y_w</span>를 <span class="math math-inline">y_l</span>보다 훨씬 높은 확률로 생성하고 있다면(즉, 선호 정렬이 잘 되어 있다면), 기울기는 0에 수렴하여 업데이트가 멈춘다. 반면, 모델이 <span class="math math-inline">y_l</span>을 <span class="math math-inline">y_w</span>보다 더 선호하는 오류를 범하고 있다면, 기울기 가중치가 급격히 커져 강력한 수정이 일어난다. 이는 별도의 중요도 샘플링(Importance Sampling) 없이도 어려운 예제에 집중하게 만드는 자동 커리큘럼 학습 효과를 낸다.2</li>
</ol>
<h3>1.3  2025년 시점에서의 DPO: 성과와 한계</h3>
<p>2024년을 거치며 DPO는 학계와 산업계의 표준이 되었다. 허깅페이스(HuggingFace)의 <code>trl</code> 라이브러리를 비롯한 주요 프레임워크에 기본 탑재되었으며, Llama 3, Mistral, Gemma 등 수많은 오픈 소스 모델들이 DPO를 통해 정렬되었다.</p>
<p><strong>주요 성과:</strong></p>
<ul>
<li><strong>훈련 안정성:</strong> PPO와 달리 발산(Divergence)하는 경우가 드물며, 하이퍼파라미터 튜닝이 비교적 단순하다.</li>
<li><strong>자원 효율성:</strong> 보상 모델을 메모리에 올릴 필요가 없고(단, 참조 모델은 필요), 샘플링(Generation) 과정이 없어 학습 속도가 PPO 대비 2~3배 빠르다.</li>
</ul>
<p>한계점과 부작용:</p>
<p>그러나 2025년 현재, DPO의 한계 또한 명확히 드러났다.</p>
<ul>
<li><strong>길이 편향(Length Bias):</strong> DPO의 암시적 보상에는 응답 길이에 대한 제약이 없다. 모델은 종종 인간의 선호를 만족시키기 위해 불필요하게 장황한 답변을 생성하는 ‘길이 해킹’ 전략을 학습한다. 이는 DPO가 로그 확률의 합을 최적화하기 때문에, 길이가 긴 문장이 자연스럽게 더 큰 값의 변동폭을 가지기 때문이다.7</li>
<li><strong>참조 모델의 메모리 점유:</strong> DPO는 훈련 내내 <span class="math math-inline">\pi_{\text{ref}}</span>를 메모리에 상주시켜야 한다. 모델이 수천억 파라미터(Hundreds of Billions) 규모로 커지면서, 훈련 모델과 동일한 크기의 참조 모델을 유지하는 것은 심각한 VRAM 병목을 초래했다.</li>
<li><strong>데이터 의존성:</strong> DPO는 반드시 승자(<span class="math math-inline">y_w</span>)와 패자(<span class="math math-inline">y_l</span>)의 쌍(Pair)이 필요하다. 그러나 현실 세계의 피드백은 “좋아요/싫어요“와 같은 단일 신호가 압도적으로 많다. 쌍 데이터를 억지로 구성하는 과정에서 노이즈가 발생하거나 데이터 낭비가 일어난다.</li>
</ul>
<p>이러한 한계는 필연적으로 KTO, SimPO와 같은 차세대 기법의 등장을 촉발했다.</p>
<h2>2.  KTO: 인간 심리학과 손실 함수의 만남</h2>
<h3>2.1  전망 이론(Prospect Theory)의 도입</h3>
<p>2024년 Ethayarajh 등에 의해 제안된 **KTO(Kahneman-Tversky Optimization)**는 정렬 문제에 대한 접근 방식을 근본적으로 비틀었다. 기존의 접근법들이 “어떤 응답이 더 나은가(Preference)“에 집중했다면, KTO는 “인간은 이득과 손실을 어떻게 인지하는가(Utility)“에 주목했다.</p>
<p>1979년 노벨 경제학상 수상자 대니얼 카너먼(Daniel Kahneman)과 아모스 트버스키(Amos Tversky)가 제안한 **전망 이론(Prospect Theory)**은 인간의 의사결정이 기대 효용(Expected Utility)을 단순히 최대화하는 것이 아니라, 기준점(Reference Point)을 중심으로 이득과 손실을 비대칭적으로 평가한다고 설명한다. 특히 인간은 동일한 크기의 이득보다 손실에 훨씬 더 민감하게 반응하는 <strong>손실 회피(Loss Aversion)</strong> 성향을 보인다.8</p>
<p>LLM 정렬의 맥락에서 이는 무엇을 의미하는가? 인간 사용자는 모델이 “훌륭한 답변을 내놓는 것(Gain)“보다 “해롭거나 멍청한 답변을 내놓는 것(Loss)“에 훨씬 더 부정적으로 반응할 수 있다는 것이다. 따라서 정렬 알고리즘은 훌륭한 답변을 장려하는 것과 나쁜 답변을 억제하는 것에 서로 다른 가중치를 부여해야 한다.</p>
<h3>2.2  HALOs와 KTO의 수학적 구조</h3>
<p>KTO는 HALOs(Human-Aware Loss Functions)라는 개념적 프레임워크 아래 설계되었다. KTO는 데이터셋을 쌍(Pair)으로 구성하지 않고, 개별 데이터 <span class="math math-inline">(x, y)</span>에 대해 그것이 <strong>바람직한지(Desirable)</strong> 또는 **바람직하지 않은지(Undesirable)**만을 태깅한다.</p>
<p>KTO의 손실 함수는 다음과 같이 정의된다 11:<br />
<span class="math math-display">
\mathcal{L}_{\text{KTO}}(\pi_\theta, \pi_{\text{ref}}) = \mathbb{E}_{x, y}
</span><br />
여기서 가치 함수 <span class="math math-inline">v_{\text{KTO}}</span>는 DPO의 암시적 보상과 유사한 형태를 띠며, 핵심은 가중치 <span class="math math-inline">w(y)</span>의 비대칭성에 있다.<br />
<span class="math math-display">
L_{KTO} = \begin{cases}  \lambda_D \cdot \sigma(\beta (\log \frac{\pi_\theta}{\pi_{\text{ref}}} - z_{\text{ref}})) &amp; \text{if } y \text{ is desirable} \\ \lambda_U \cdot \sigma(\beta (\log \frac{\pi_\theta}{\pi_{\text{ref}}} - z_{\text{ref}})) &amp; \text{if } y \text{ is undesirable}  \end{cases}
</span><br />
<em>(참고: 실제 구현에서는 KL 발산 항과 편향 보정 항이 포함된 더 복잡한 형태이나, 핵심은 위와 같은 가중치 분리이다.)</em></p>
<p>연구진은 실험을 통해 손실에 대한 가중치 <span class="math math-inline">\lambda_U</span>를 이득에 대한 가중치 <span class="math math-inline">\lambda_D</span>보다 크게 설정하는 것이 성능 향상에 기여함을 입증했다. 예를 들어, <span class="math math-inline">\lambda_D=1.0</span>, <span class="math math-inline">\lambda_U=1.33</span>으로 설정할 때 모델은 나쁜 응답을 피하려는 경향성을 더 강하게 학습하며, 이는 결과적으로 전체적인 생성 품질의 향상으로 이어진다.12</p>
<h3>2.3  데이터 효율성과 ’약한 지도(Weak Supervision)’의 승리</h3>
<p>KTO의 가장 강력한 장점은 데이터 요구조건의 유연성이다.</p>
<ol>
<li><strong>쌍 데이터 불필요:</strong> DPO를 위해 <span class="math math-inline">A</span>와 <span class="math math-inline">B</span> 답변을 모두 생성하고 비교할 필요가 없다. 단순히 “이 답변은 좋다”, “이 답변은 나쁘다“라는 이진 신호만 있으면 된다. 이는 기업이 보유한 로그 데이터(사용자의 ‘좋아요’ 클릭 여부 등)를 가공 없이 바로 학습에 사용할 수 있음을 의미한다.</li>
<li><strong>데이터 불균형 포용:</strong> 바람직한 예제가 적고 바람직하지 않은 예제가 많은 상황, 혹은 그 반대의 상황에서도 KTO는 안정적으로 학습한다. DPO는 승/패 비율이 맞지 않으면 학습이 편향되기 쉽다.</li>
<li><strong>성능 우위:</strong> 1B에서 30B 파라미터 규모의 다양한 실험에서, KTO는 쌍 데이터를 사용하지 않고도 DPO와 대등하거나 더 우수한 성능을 보였다. 특히 데이터에 노이즈가 많거나 모호한 경우(Intransitivity), KTO가 더 강건한(Robust) 모습을 보였다.9</li>
</ol>
<p>2025년 시점에서 KTO는, 값비싼 전문가 레이블링 대신 저비용의 대규모 바이너리 피드백을 활용하는 ‘약한 지도’ 정렬의 핵심 기술로 자리 잡았다.</p>
<h2>3.  효율성과 성능의 조화: SimPO와 ORPO</h2>
<p>DPO와 KTO가 정렬의 방법론을 혁신했다면, 2024년 중반 프린스턴 대학 연구진이 제안한 **SimPO(Simple Preference Optimization)**와 **ORPO(Odds Ratio Preference Optimization)**는 정렬의 ’효율성’과 ’품질’을 동시에 잡기 위한 구조적 최적화를 이루어냈다.</p>
<h3>3.1  참조 모델(Reference Model)로부터의 해방: SimPO</h3>
<p>DPO와 KTO의 공통적인 단점은 훈련 과정에서 참조 모델(<span class="math math-inline">\pi_{\text{ref}}</span>)을 필요로 한다는 점이었다. 이는 메모리 사용량을 두 배로 늘릴 뿐만 아니라, 모델의 생성이 참조 모델의 분포에 묶여 있어야 한다는 제약(KL constraint)으로 작용하기도 했다. SimPO는 과감하게 참조 모델을 손실 함수에서 제거했다.15</p>
<p>SimPO의 핵심 아이디어 1: 길이 정규화 (Length Normalization)</p>
<p>DPO의 고질적인 문제인 ’길이 해킹’을 해결하기 위해, SimPO는 보상을 응답의 길이 <span class="math math-inline">|y|</span>로 나눈 ’평균 로그 확률’을 사용한다.<br />
<span class="math math-display">
\text{Reward}(x, y) = \frac{\beta}{|y|} \log \pi_\theta(y|x)
</span><br />
이렇게 하면 모델이 단순히 확률 합을 높이기 위해 문장을 길게 늘이는 꼼수를 부릴 수 없게 된다. 이는 2025년 모델들이 간결하고 명확한 답변을 선호하게 된 결정적인 기술적 배경이다.7</p>
<p>SimPO의 핵심 아이디어 2: 목표 마진 (Target Margin)</p>
<p>참조 모델 없이 학습이 안정적으로 이루어지기 위해, SimPO는 승자 응답(<span class="math math-inline">y_w</span>)과 패자 응답(<span class="math math-inline">y_l</span>) 사이에 확실한 점수 차이(Margin)를 강제한다.<br />
<span class="math math-display">
\mathcal{L}_{\text{SimPO}} = -\mathbb{E} \left[ \log \sigma \left( \frac{\beta}{|y_w|} \log \pi_\theta(y_w|x) - \frac{\beta}{|y_l|} \log \pi_\theta(y_l|x) - \gamma \right) \right]
</span><br />
여기서 <span class="math math-inline">\gamma</span>는 목표 마진이다. 즉, 승자 응답의 점수가 패자 응답보다 최소한 <span class="math math-inline">\gamma</span>만큼은 더 높아야 손실이 0에 가까워진다. 이는 SVM(Support Vector Machine)의 마진 최대화와 유사한 기하학적 효과를 내며, 모델의 일반화 성능을 비약적으로 향상시켰다. 실험적으로 <span class="math math-inline">\gamma</span> 값은 0.5~1.5 범위에서 최적의 성능을 보였으며, 이는 AlpacaEval 2와 Arena-Hard 벤치마크에서 DPO를 큰 폭으로 따돌리는 결과를 낳았다.7</p>
<h3>3.2  단일 단계 학습: ORPO</h3>
<p>KAIST 연구진이 제안한 ORPO는 SFT와 정렬(Alignment)을 별도 단계로 나누는 관행에 의문을 제기했다. ORPO는 SFT 손실 함수에 <strong>오즈 비율(Odds Ratio)</strong> 기반의 페널티 항을 추가하여, 단 한 번의 학습으로 지시 이행(Instruction Following)과 선호 정렬을 동시에 수행한다.<br />
<span class="math math-display">
\mathcal{L}_{\text{ORPO}} = \mathcal{L}_{\text{SFT}} + \lambda \mathcal{L}_{\text{OR}}
</span><br />
오즈 비율 손실 <span class="math math-inline">\mathcal{L}_{\text{OR}}</span>은 모델이 비선호 응답 대비 선호 응답을 생성할 확률의 비율(Odds)을 최대화하도록 설계되었다. 이는 참조 모델을 사용하지 않으면서도, SFT 과정에서 모델이 비선호 데이터의 특징을 학습하는 것을 효과적으로 억제한다.3 2025년 12월 현재, ORPO와 SimPO는 제한된 컴퓨팅 자원을 가진 연구실이나 스타트업에서 고성능 모델을 훈련할 때 필수적으로 채택하는 기법이 되었다.</p>
<h2>4.  추론(Reasoning) 능력의 비약: GRPO와 Step-DPO</h2>
<p>2024년 하반기부터 2025년에 걸쳐 AI 업계의 최대 화두는 단연 ’추론 모델(Reasoning Models)’이었다. OpenAI의 o1 모델과 뒤이어 등장한 DeepSeek-R1은 복잡한 수학 문제, 코딩, 논리적 난제를 해결하기 위해 ’사고의 사슬(Chain of Thought, CoT)’을 스스로 확장하고 검증하는 능력을 보여주었다. 이러한 추론 능력의 폭발적 성장을 뒷받침한 정렬 기술이 바로 <strong>GRPO</strong>와 <strong>Step-DPO</strong>이다.19</p>
<h3>4.1  DeepSeek과 GRPO: 집단 지성을 통한 자기 검증</h3>
<p>DeepSeek-Math와 DeepSeek-R1의 성공 뒤에는 **GRPO(Group Relative Policy Optimization)**라는 혁신적인 알고리즘이 있다. 기존 PPO는 각 상태(State)의 가치를 평가하기 위해 모델 크기와 동일한 비평가(Critic/Value) 모델을 훈련해야 했다. 이는 모델이 수천억 파라미터 규모일 때 감당하기 힘든 메모리 부담이었다.</p>
<p>GRPO는 비평가 모델을 과감히 제거하고, **그룹 평균(Group Mean)**을 베이스라인(Baseline)으로 사용하는 영리한 전략을 취했다.21</p>
<p><strong>GRPO의 작동 메커니즘:</strong></p>
<ol>
<li>
<p><strong>그룹 샘플링:</strong> 하나의 질문 <span class="math math-inline">q</span>에 대해 현재 정책 모델 <span class="math math-inline">\pi_\theta</span>로부터 <span class="math math-inline">G</span>개의 서로 다른 출력 그룹 <span class="math math-inline">{o_1, o_2,..., o_G}</span>을 생성한다.</p>
</li>
<li>
<p><strong>보상 평가:</strong> 각 출력에 대해 보상 <span class="math math-inline">r_i</span>를 계산한다. 수학이나 코딩 문제의 경우, 정답 여부에 따라 명확한 규칙 기반 보상(Rule-based Reward)을 줄 수 있어 보상 모델의 부정확성 문제를 피할 수 있다.</p>
</li>
<li>
<p><strong>상대적 이점(Advantage) 계산:</strong> 그룹 내 보상들의 평균(<span class="math math-inline">\mu</span>)과 표준편차(<span class="math math-inline">\sigma</span>)를 구하여, 각 출력의 이점을 표준화한다.<br />
<span class="math math-display">
A_i = \frac{r_i - \mu}{\sigma}
</span><br />
이 과정이 핵심이다. 별도의 가치 함수 없이도, “이 답변이 같은 질문에 대해 생성된 다른 답변들보다 얼마나 더 나은가“를 평가함으로써 분산(Variance)을 획기적으로 줄인다.23</p>
</li>
<li>
<p><strong>정책 업데이트:</strong> 계산된 이점을 사용하여 정책을 업데이트한다. 손실 함수에는 PPO와 유사하게 클리핑(Clipping) 항이 포함되어 학습의 안정성을 보장한다.<br />
<span class="math math-display">
\mathcal{J}_{\text{GRPO}}(\theta) = \mathbb{E}_{q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{old}}} \left[ \frac{1}{G} \sum_{i=1}^G \left( \min \left( \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)} A_i, \text{clip} \left( \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}, 1-\epsilon, 1+\epsilon \right) A_i \right) - \beta D_{KL}(\pi_\theta \| \pi_{ref}) \right) \right]
</span></p>
</li>
</ol>
<p>GRPO는 **‘아하 모멘트(Aha Moment)’**라 불리는 현상을 유발했다. DeepSeek-R1-Zero 훈련 과정에서, 모델은 인간이 명시적으로 가르치지 않았음에도 불구하고 스스로 자신의 추론 과정을 검증하고, 오류를 수정하며, 문제를 다시 생각하는 행동 패턴을 창발적으로 학습했다. 이는 정렬 알고리즘이 단순히 인간의 선호를 모방하는 것을 넘어, 지능의 본질인 ’자기 성찰적 사고’를 강화할 수 있음을 증명한 사례다.24</p>
<h3>4.2  Step-DPO: 과정(Process) 중심의 정렬</h3>
<p>긴 호흡의 추론(Long-chain Reasoning)을 위해서는 최종 결과(Outcome)만 정답인 것으로는 부족하다. 중간 단계의 논리가 타당해야 한다. 기존 DPO는 전체 응답을 하나의 단위로 평가했기 때문에, 10단계의 추론 중 9단계가 맞고 마지막 1단계만 틀린 경우와, 처음부터 틀린 경우를 세밀하게 구분하지 못했다.</p>
<p><strong>Step-DPO</strong>와 **SCDPO(Step-Controlled DPO)**는 이러한 문제를 해결하기 위해 도입되었다. 이 기법들은 추론 과정을 [단계 1, 단계 2,…, 단계 N]으로 분해하고, 각 단계별로 선호 데이터를 구축한다.26</p>
<ul>
<li><strong>오류 주입(Error Injection):</strong> 데이터 생성 시, 특정 단계에서 의도적으로 논리적 오류를 포함한 부정적 샘플(Negative Sample)을 만든다.</li>
<li><strong>단계별 최적화:</strong> 모델은 올바른 추론 단계(<span class="math math-inline">y_w</span>)와 오류가 포함된 단계(<span class="math math-inline">y_l</span>)를 구분하도록 DPO 손실을 통해 학습한다.</li>
<li><strong>과정 보상(Process Reward):</strong> 2025년의 연구들은 이를 더욱 발전시켜, 전체 추론 체인에 대해 자체 지도(Self-Supervised) 방식으로 과정 보상 모델(PRM)을 훈련하고, 이를 기반으로 <strong>Full-Step-DPO</strong>를 수행하는 방향으로 나아가고 있다. 이는 수학적 증명이나 복잡한 코딩 문제에서 모델의 환각(Hallucination)을 획기적으로 줄이는 데 기여했다.28</li>
</ul>
<h2>5.  반복적 자기 개선: Iterative DPO와 SPIN</h2>
<p>정렬 기술의 마지막 퍼즐은 데이터의 **자가 생성(Self-Generation)**과 **반복적 학습(Iterative Training)**이다. 고정된 데이터셋으로 한 번만 학습하는 것(Offline)은 모델의 잠재력을 완전히 끌어내지 못한다.</p>
<h3>5.1  SPIN: 어제의 나를 이겨라</h3>
<p>**SPIN(Self-Play Preference Optimization)**은 “모델이 이전 세대의 자신과 경쟁하며 성장한다“는 자기 대국(Self-Play) 개념을 언어 모델 정렬에 도입했다. SPIN은 외부의 고품질 데이터(GPT-4 생성 데이터 등)에 의존하지 않고, 오직 SFT 데이터셋만을 가지고도 모델 성능을 향상시킨다.29</p>
<ul>
<li><strong>작동 원리:</strong> SFT 모델(플레이어 1)은 실제 데이터(<span class="math math-inline">y_{\text{real}}</span>)를 생성하려 하고, 이전 반복 단계의 모델(플레이어 2)은 이를 모방하려 한다. 정렬 과정은 현재 모델이 <span class="math math-inline">y_{\text{real}}</span>에는 높은 확률을, 자신이 과거에 생성했던 <span class="math math-inline">y_{\text{generated}}</span>에는 낮은 확률을 부여하도록 학습시킨다.</li>
<li><strong>의의:</strong> 이는 DPO가 승자/패자 데이터를 필요로 하는 것과 달리, SFT 데이터 자체가 승자, 모델이 생성한 데이터가 패자가 되는 구조를 통해 데이터 부족 문제를 근본적으로 해결했다. 반복(Iteration)이 거듭될수록 모델은 SFT 데이터 분포에 더 정교하게 수렴하며, 환각이나 편향을 스스로 제거한다.</li>
</ul>
<h3>5.2  Iterative DPO (Online DPO)</h3>
<p><strong>Iterative DPO</strong>는 Offline DPO의 가장 큰 문제점인 분포 변화(Distribution Shift)를 해결한다. Offline DPO는 고정된 데이터셋으로 학습하지만, 학습이 진행될수록 모델의 정책 <span class="math math-inline">\pi_\theta</span>는 데이터셋을 생성했던 원래 정책과 달라진다. 이로 인해 학습 후반부에는 모델이 보지 못한 데이터 영역에 대해 잘못된 확신을 가질 수 있다.</p>
<p>Iterative DPO는 훈련 루프 내에서 모델이 주기적으로 새로운 응답을 생성하고, 이를 (사람 또는 AI 보상 모델이) 평가하여 새로운 선호 데이터셋을 구축한 뒤 다시 DPO 학습을 수행한다. 2025년 현재, 최고 성능의 모델(State-of-the-Art)들은 대부분 **SFT <span class="math math-inline">\rightarrow</span> Offline DPO <span class="math math-inline">\rightarrow</span> Iterative DPO (with GRPO)**로 이어지는 하이브리드 파이프라인을 통해 훈련되고 있다.31</p>
<h2>6.  결론: 정렬 기술의 2025년 지형도</h2>
<p>2025년 12월의 시점에서 볼 때, LLM 정렬 기술은 **단순화(Simplicity), 인간 중심(Human-Centric), 자기 진화(Self-Evolution)**라는 세 가지 키워드로 요약된다. 복잡한 강화학습의 기계적 장치들은 DPO와 SimPO라는 우아한 수식으로 대체되었고, KTO는 기계에게 인간의 심리적 편향을 이해시켰으며, GRPO와 SPIN은 기계가 스스로 사고를 정제하는 능력을 부여했다.</p>
<p>다음의 표는 2025년 현재 주류로 자리 잡은 정렬 기법들의 특징을 비교 요약한 것이다.</p>
<table><thead><tr><th><strong>기법</strong></th><th><strong>핵심 철학</strong></th><th><strong>주요 특징 및 장점</strong></th><th><strong>수식적 특징</strong></th><th><strong>적용 최적 분야</strong></th></tr></thead><tbody>
<tr><td><strong>DPO</strong></td><td>보상 모델 제거</td><td>안정적 학습, 산업 표준, 구현 용이성</td><td><span class="math math-inline">\log \frac{\pi(y_w)}{\pi_{ref}(y_w)} - \log \frac{\pi(y_l)}{\pi_{ref}(y_l)}</span></td><td>일반적 대화, 챗봇, 지시 이행</td></tr>
<tr><td><strong>KTO</strong></td><td>전망 이론 (손실 회피)</td><td>비(非)쌍 데이터 활용, 높은 데이터 효율성</td><td><span class="math math-inline">\lambda_D</span>(이득)와 <span class="math math-inline">\lambda_U</span>(손실) 가중치 분리</td><td>로그 데이터 활용, 데이터 불균형 환경</td></tr>
<tr><td><strong>SimPO</strong></td><td>참조 모델 제거</td><td>메모리 효율 극대화, 길이 편향 제거</td><td>길이 정규화($\frac{1}{|y$), 목표 마진(<span class="math math-inline">(</span>\gam$)</td><td>제한된 자원, 고성능 미세조정</td></tr>
<tr><td><strong>GRPO</strong></td><td>그룹 평균 베이스라인</td><td>비평가 모델 불필요, 자기 검증 능력 강화</td><td><span class="math math-inline">\frac{1}{G} \sum (r_i - \mu)</span>, 표준화된 이점</td><td>수학, 코딩, 논리 추론 (Reasoning)</td></tr>
<tr><td><strong>Step-DPO</strong></td><td>단계별 제어</td><td>과정 중심 정렬, 환각 및 논리 오류 감소</td><td>단계별(Step-wise) 선호 최적화</td><td>CoT, 복잡한 문제 해결, 증명</td></tr>
</tbody></table>
<p>트랜스포머 싱귤래리티는 단순히 모델의 파라미터가 조(Trillion) 단위로 커지는 것만을 의미하지 않는다. 그것은 모델이 인간의 가치를 내면화하고, 스스로의 오류를 수정하며, 정답을 향해 논리적으로 수렴해가는 과정의 최적화를 의미한다. 15.3절에서 살펴본 정렬 기법들은 바로 그 최적화의 최전선에 있는 도구들이며, 인공지능이 진정한 의미의 ’동반자’로 거듭나기 위한 필수적인 교량 역할을 수행하고 있다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>DPO(Direct Preference Optimization) - AI Engineering Academy, https://aiengineering.academy/LLM/TheoryBehindFinetuning/DPO/</li>
<li>Direct Preference Optimization: Your Language Model is Secretly a …, https://arxiv.org/pdf/2305.18290</li>
<li>DPO Isn’t Enough: The Modern Post-Training Stack — SimPO, ORPO, KTO and Beyond | by James Fahey - Medium, https://medium.com/@fahey_james/dpo-isnt-enough-the-modern-post-training-stack-simpo-orpo-kto-and-beyond-d82e52a1ee6c</li>
<li>What is direct preference optimization (DPO)? | SuperAnnotate, https://www.superannotate.com/blog/direct-preference-optimization-dpo</li>
<li>Direct Preference Optimization (DPO) and SimPO paper explanation | by Astarag Mohapatra, https://athekunal.medium.com/direct-preference-optimization-dpo-and-simpo-paper-explanation-a680cc275287</li>
<li>DPO &amp; ORPO — Overview of Preference Alignment algorithms for LLM finetuning. - Medium, https://medium.com/@jakubstrawadev/dpo-orpo-overview-of-preference-alignment-algorithms-for-llm-finetuning-c4837fed0153</li>
<li>SimPO: Simple Preference Optimization with a Reference-Free Reward - arXiv, https://arxiv.org/html/2405.14734v1</li>
<li>[2402.01306] KTO: Model Alignment as Prospect Theoretic Optimization - arXiv, https://arxiv.org/abs/2402.01306</li>
<li>KTO: Model Alignment as Prospect Theoretic Optimization - arXiv, https://arxiv.org/html/2402.01306v3</li>
<li>LLM Alignments [Part 6: KTO]. Hello! Today we talk about KTO …, https://medium.com/@yianyao1994/llm-alignments-part-6-kto-813b38be14ae</li>
<li>Detailed Explanation of LoRA, DPO, KTO, and SFT Technologies | 黑头呆鱼进化之旅, <a href="https://chenhuiyu.github.io/2024/10/23/NLP%20Insights/Introduction%20to%20LLM%20Training%20Terminology:%20LoRA,%20DPO,%20KTO,%20and%20SFT%20Technologies/index.html">https://chenhuiyu.github.io/2024/10/23/NLP%20Insights/Introduction%20to%20LLM%20Training%20Terminology:%20LoRA,%20DPO,%20KTO,%20and%20SFT%20Technologies/index.html</a></li>
<li>Kahneman-Tversky Optimization(KTO): Revolutionizing Language Model Training with Prospect Theory | by Yatin Arora | Medium, https://medium.com/@SpielmitDaten/kahneman-tversky-optimization-kto-revolutionizing-language-model-training-with-prospect-theory-99f30c50481e</li>
<li>KTO Trainer - Hugging Face, https://huggingface.co/docs/trl/main/kto_trainer</li>
<li>RLHF and alternatives: KTO - Argilla, https://argilla.io/blog/mantisnlp-rlhf-part-7/</li>
<li>[NeurIPS 2024] SimPO: Simple Preference Optimization with a Reference-Free Reward - GitHub, https://github.com/princeton-nlp/SimPO</li>
<li>[2405.14734] SimPO: Simple Preference Optimization with a Reference-Free Reward - arXiv, https://arxiv.org/abs/2405.14734</li>
<li>Simple Preference Optimization (SimPO) - Emergent Mind, https://www.emergentmind.com/topics/simple-preference-optimization-simpo</li>
<li>ORPO: Monolithic Preference Optimization without Reference Model - arXiv, https://arxiv.org/html/2403.07691v2</li>
<li>Reasoning Beyond Limits: Advances and Open Problems for LLMs - arXiv, https://arxiv.org/html/2503.22732v1</li>
<li>Breaking down the DeepSeek-R1 training process—no PhD required - Vellum AI, https://www.vellum.ai/blog/the-training-of-deepseek-r1-and-ways-to-use-it</li>
<li>Hands-On LLM Alignment: Coding GRPO from Scratch, Step by Step, https://medium.com/@baicenxiao/hands-on-llm-alignment-coding-grpo-from-scratch-step-by-step-30c6aa4a2146</li>
<li>DeepSeek-R1 Dissection: Understanding PPO &amp; GRPO Without Any Prior Reinforcement Learning Knowledge - Hugging Face, https://huggingface.co/blog/NormalUhr/grpo</li>
<li>DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models - arXiv, https://arxiv.org/pdf/2402.03300</li>
<li>Understanding the Math Behind GRPO — DeepSeek-R1-Zero | by Yugen.ai - Medium, https://medium.com/yugen-ai-technology-blog/understanding-the-math-behind-grpo-deepseek-r1-zero-9fb15e103a0a</li>
<li>Aman’s AI Journal • Primers • DeepSeek-R1, https://aman.ai/primers/ai/deepseek-R1/</li>
<li>Step-Controlled DPO: Leveraging Stepwise Errors for Enhancing Mathematical Reasoning of Language Models | OpenReview, https://openreview.net/forum?id=ZRDa2IT1sQ</li>
<li>Implementation for “Step-DPO: Step-wise Preference Optimization for Long-chain Reasoning of LLMs” - GitHub, https://github.com/dvlab-research/Step-DPO</li>
<li>Full-Step-DPO: Self-Supervised Preference Optimization with Step-wise Rewards for Mathematical Reasoning - ACL Anthology, https://aclanthology.org/2025.findings-acl.1249.pdf</li>
<li>RLHF and alternatives: SPIN - Argilla, https://argilla.io/blog/mantisnlp-rlhf-part-5/</li>
<li>Recipe: Self-Play Fine-Tuning (SPIN) - verl documentation - Read the Docs, https://verl.readthedocs.io/en/latest/algo/spin.html</li>
<li>Iterative Direct Preference Optimization - Emergent Mind, https://www.emergentmind.com/topics/iterative-direct-preference-optimization-dpo-algorithm</li>
<li>Enhancing LLM Reasoning with Iterative DPO: A Comprehensive Empirical Investigation, https://openreview.net/forum?id=OgWh4J7bkT</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>