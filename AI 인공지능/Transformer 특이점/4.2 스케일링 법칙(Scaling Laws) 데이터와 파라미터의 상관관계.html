<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.2 스케일링 법칙(Scaling Laws) 데이터와 파라미터의 상관관계</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.2 스케일링 법칙(Scaling Laws) 데이터와 파라미터의 상관관계</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>4.2 스케일링 법칙(Scaling Laws) 데이터와 파라미터의 상관관계</span></nav>
                </div>
            </header>
            <article>
                <h1>4.2 스케일링 법칙(Scaling Laws) 데이터와 파라미터의 상관관계</h1>
<p>2025-12-19, G30DR</p>
<p>트랜스포머(Transformer) 아키텍처의 등장 이후 인공지능 연구의 흐름은 근본적인 변곡점을 맞이했다. 과거의 연구가 모델의 구조적 설계, 즉 귀납적 편향(Inductive Bias)을 정교하게 조율하여 특정 태스크에서의 성능을 높이는 ’설계의 시대’였다면, 트랜스포머 이후는 범용적인 아키텍처 위에 막대한 양의 데이터와 연산 자원(Compute)을 쏟아부어 지능의 총량을 확장하는 ’스케일링의 시대’로 정의된다. 이 새로운 시대를 지배하는 물리 법칙이 바로 **스케일링 법칙(Scaling Laws)**이다. 이 법칙은 단순한 경험적 관찰을 넘어, 모델의 크기(파라미터 수, <span class="math math-inline">N</span>), 데이터의 양(토큰 수, <span class="math math-inline">D</span>), 그리고 투입된 연산량(<span class="math math-inline">C</span>) 사이의 수학적 필연성을 규명한다. 본 절에서는 2020년 OpenAI의 초기 연구부터 2025년 현재의 추론 시간 스케일링(Inference-time Scaling)에 이르기까지, 데이터와 파라미터 간의 상관관계가 어떻게 재정의되어 왔으며, 이것이 거대언어모델(LLM)의 진화에 어떤 결정적인 이정표가 되었는지 심층적으로 분석한다.</p>
<h2>1.  스케일링 법칙의 태동과 멱법칙의 발견 (The Genesis of Scaling Laws)</h2>
<p>인공지능 모델의 성능이 데이터와 모델 크기에 따라 향상된다는 것은 직관적으로 알려진 사실이었으나, 이를 정량적인 수식으로 체계화한 것은 2020년 OpenAI의 Jared Kaplan 팀이 발표한 연구가 시초이다.1 이 연구는 딥러닝 모델, 특히 언어 모델의 성능 향상이 무작위적인 것이 아니라, 열역학 법칙과 같이 예측 가능한 멱법칙(Power Law)을 따른다는 사실을 입증함으로써 ’트랜스포머 싱귤래리티’의 이론적 토대를 마련했다.</p>
<pre><code class="language-mermaid">mindmap
  root(("4.2.1 스케일링 법칙의 태동"))
    ["멱법칙(Power Law) 발견"]
      ["교차 엔트로피 손실(L)의 결정 요인"]
        ["모델 크기(N) : L(N) ~ N^-alpha"]
        ["데이터 양(D) : L(D) ~ D^-alpha"]
        ["연산량(C) : L(C) ~ C^-alpha"]
      ["함의"]
        ["성능 예측 가능성(Predictability)"]
        ["공학적 설계 가능"]
    ["초기 해석: 파라미터 우선주의"]
      ["자원 배분 비율"]
        ["파라미터(N) : C^0.73"]
        ["데이터(D) : C^0.27"]
      ["전략적 결론"]
        ["거거익선 (Bigger is Better)"]
        ["데이터보다 모델 크기가 중요"]
      ["대표 모델"]
        ["GPT-3 (175B)"]
        ["토큰 대 파라미터 비율 약 1.7 : 1"]
</code></pre>
<h3>1.1  멱법칙(Power Law)의 보편성</h3>
<p>Kaplan 연구팀은 언어 모델의 성능 지표인 교차 엔트로피 손실(Cross-Entropy Loss, <span class="math math-inline">L</span>)이 모델 크기(<span class="math math-inline">N</span>), 데이터셋 크기(<span class="math math-inline">D</span>), 연산량(<span class="math math-inline">C</span>)과 각각 독립적인 멱법칙 관계를 맺고 있음을 발견했다. 이는 다른 변수가 충분하다면, 하나의 변수를 증가시킬 때 손실(<span class="math math-inline">L</span>)이 다음과 같이 로그-선형(Log-linear) 그래프 상에서 직선을 그리며 감소함을 의미한다.2<br />
<span class="math math-display">
L(N) \propto N^{-\alpha_N}
</span></p>
<p><span class="math math-display">
L(D) \propto D^{-\alpha_D}
</span></p>
<p><span class="math math-display">
L(C) \propto C^{-\alpha_C}
</span></p>
<p>여기서 <span class="math math-inline">\alpha</span>는 각 변수의 스케일링 계수(Scaling Coefficient)로, 성능 향상의 기울기를 결정한다. 이 발견이 주는 함의는 실로 거대했다. 연구자들은 더 이상 막연한 기대감으로 모델을 학습시키는 것이 아니라, 작은 규모의 실험을 통해 거대 모델의 성능을 외삽(Extrapolation)하여 예측할 수 있게 되었다. 즉, 목표 성능에 도달하기 위해 필요한 예산과 데이터를 사전에 계산할 수 있는 공학적 설계가 가능해진 것이다.3</p>
<h3>1.2  초기 해석의 오류: 파라미터 우선주의 (The Parameter Bias)</h3>
<p>Kaplan의 2020년 연구에서 도출된 결론 중 가장 논쟁적이면서도 당시 AI 개발 트렌드를 결정지었던 것은 파라미터(<span class="math math-inline">N</span>)와 데이터(<span class="math math-inline">D</span>)의 상대적 중요도였다. 당시 OpenAI의 분석에 따르면, 연산량(<span class="math math-inline">C</span>)을 증가시킬 때 모델의 크기를 키우는 것이 데이터의 양을 늘리는 것보다 훨씬 더 효율적이었다. 구체적으로, 그들은 연산 예산이 증가할 때 파라미터 수는 <span class="math math-inline">C^{0.73}</span>에 비례하여 늘리고, 데이터 수는 <span class="math math-inline">C^{0.27}</span>에 비례하여 늘리는 것이 최적이라고 제안했다.5<br />
<span class="math math-display">
N \propto C^{0.73}, \quad D \propto C^{0.27}
</span><br />
이 비율에 따르면, 모델의 크기를 10배 키울 때 데이터는 고작 1.8배 정도만 늘리면 된다. 이는 데이터보다 모델의 ‘지능 용량(Capacity)’ 자체가 성능을 결정짓는 핵심 변수라는 해석을 낳았고, 전 세계적인 ’거대 모델 경쟁’을 촉발했다. GPT-3(175B), Jurassic-1(178B), Megatron-Turing NLG(530B) 등 2020년부터 2021년 사이에 등장한 초거대 모델들은 모두 이 법칙에 근거하여 설계되었다.6 당시 GPT-3는 1,750억 개의 파라미터를 가졌지만 학습 데이터는 약 3,000억 토큰에 불과했다. 파라미터 대 토큰 비율은 약 <strong>1:1.7</strong> 수준이었다.8</p>
<p><strong>표 4.2.1 초기 스케일링 법칙(Kaplan et al., 2020)에 따른 자원 배분 전략</strong></p>
<table><thead><tr><th><strong>스케일링 변수</strong></th><th><strong>비례 관계</strong></th><th><strong>의미 및 전략적 함의</strong></th></tr></thead><tbody>
<tr><td><strong>모델 크기 (<span class="math math-inline">N</span>)</strong></td><td><span class="math math-inline">\propto C^{0.73}</span></td><td>연산 자원의 대부분을 모델 크기 확장에 투입. “거거익선(Bigger is Better)” 기조 형성.</td></tr>
<tr><td><strong>데이터 크기 (<span class="math math-inline">D</span>)</strong></td><td><span class="math math-inline">\propto C^{0.27}</span></td><td>데이터 확장은 부차적 요인으로 간주. 상대적으로 적은 데이터로도 큰 모델 학습 시도.</td></tr>
<tr><td><strong>최적 비율 (<span class="math math-inline">D/N</span>)</strong></td><td><strong>~ 1.7 : 1</strong></td><td>극단적인 파라미터 중심 설계. 모델이 데이터보다 더 중요하다고 판단함.</td></tr>
</tbody></table>
<p>그러나 이러한 ’파라미터 우선주의’는 이후 밝혀진 바와 같이, 학습률 스케줄(Learning Rate Schedule)을 데이터 양에 맞춰 조정하지 않은 실험 설계상의 한계에서 기인한 오판이었다.9 고정된 학습 스케줄을 사용함으로써, 더 많은 데이터를 통해 얻을 수 있는 성능 향상분을 제대로 측정하지 못한 것이다. 이로 인해 당시의 모델들은 막대한 연산 자원을 소모하면서도, 그 잠재력을 충분히 발휘하지 못한 채 학습이 종료되는 ‘과소적합(Undertraining)’ 상태에 머물러 있었다.</p>
<h2>2.  친칠라 패러다임: 컴퓨팅 최적화와 데이터의 복권 (The Chinchilla Shift)</h2>
<p>2022년 3월, DeepMind(현 Google DeepMind)의 Jordan Hoffmann 팀이 발표한 “Training Compute-Optimal Large Language Models” 논문은 기존의 스케일링 법칙을 전면적으로 수정하며 LLM 개발의 흐름을 뒤바꾸어 놓았다.6 이 연구에서 제안된 **친칠라 스케일링 법칙(Chinchilla Scaling Laws)**은 “주어진 연산 예산 내에서 최적의 성능을 내기 위한 파라미터와 데이터의 비율“을 재정의했다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "4.2.2 친칠라 손실 함수 (Loss Function) 구조"
    L["총 손실 L(N, D)"] --&gt; E["E: 줄일 수 없는 손실&lt;br/&gt;(자연어의 고유 엔트로피)"]
    L --&gt; Term_N["A / N^alpha&lt;br/&gt;(파라미터 부족에 의한 오차)"]
    L --&gt; Term_D["B / D^beta&lt;br/&gt;(데이터 부족에 의한 오차)"]
    
    Term_N --"모델 크기(N) 증가 시"--&gt; Zero1["0에 수렴"]
    Term_D --"데이터(D) 증가 시"--&gt; Zero2["0에 수렴"]
    end

    subgraph "최적화 결론: 균형의 회복"
    Analysis["3가지 교차 검증&lt;br/&gt;(Fix Model, IsoFLOP, Parametric Fit)"] --&gt; Result["N과 D의 기여도는 대등함"]
    Result --&gt; Ratio["최적 비율 (N : D)"]
    Ratio --&gt; Golden["1 : 20&lt;br/&gt;(파라미터 1개당 20개 토큰)"]
    Golden --&gt; Proof["Chinchilla(70B) &gt; Gopher(280B)"]
    end

    Style_N[/"Kaplan의 오판:&lt;br/&gt;파라미터 항을 과대평가"/] -.-&gt; Term_N
    Style_D[/"Chinchilla의 발견:&lt;br/&gt;두 항의 계수는 비슷함 (0.46 vs 0.54)"/] -.-&gt; Term_D
</code></pre>
<h3>2.1  세 가지 접근법을 통한 재검증</h3>
<p>Hoffmann 팀은 Kaplan의 결론을 반박하기 위해 7천만(70M) 개에서 160억(16B) 개에 이르는 파라미터를 가진 400개 이상의 모델을 다양한 데이터 규모로 학습시키며 엄밀한 교차 검증을 수행했다. 그들은 다음 세 가지 접근법을 통해 최적의 스케일링 비율을 도출했다.6</p>
<ol>
<li><strong>고정 파라미터 접근(Fix Model Size):</strong> 모델 크기를 고정하고 데이터 양을 늘려가며 성능 변화를 관측.</li>
<li><strong>고정 연산량 접근(IsoFLOP):</strong> 총 연산량(FLOPs)을 고정하고, 모델 크기와 데이터 양의 비율을 조절하며 최적점을 탐색.</li>
<li><strong>파라메트릭 손실 함수 적합(Parametric Loss Function Fitting):</strong> 모든 실험 데이터를 포괄하는 수리적 모델을 구축하여 최적 곡선을 유도.</li>
</ol>
<p>이 과정을 통해 도출된 결론은 명확했다. 모델의 크기와 데이터의 양은 연산량 증가에 따라 거의 <strong>1:1</strong>의 비율로 균형 있게 증가해야 한다는 것이다.<br />
<span class="math math-display">
N_{opt} \propto C^{a}, \quad D_{opt} \propto C^{b}
</span></p>
<p><span class="math math-display">
(a \approx 0.50, \quad b \approx 0.50)
</span></p>
<p>정밀하게 추정된 계수는 <span class="math math-inline">a \approx 0.46</span>, <span class="math math-inline">b \approx 0.54</span>로, 오히려 데이터의 증가율이 모델 크기의 증가율보다 아주 미세하게 더 높아야 함을 시사했다.6 이는 Kaplan의 <span class="math math-inline">0.73</span> 대 <span class="math math-inline">0.27</span>이라는 불균형을 완전히 뒤집는 결과였다.</p>
<h3>2.2  20:1의 황금비율 (The Golden Ratio)</h3>
<p>친칠라 법칙의 가장 실용적이고 강력한 가이드라인은 파라미터 수 대비 데이터 토큰 수의 비율이 약 <strong>20:1</strong>이어야 한다는 것이다.8 즉, 10억 파라미터(1B) 모델을 학습시키기 위해서는 최소 200억(20B) 토큰의 데이터가 필요하다는 뜻이다.</p>
<p>이 법칙을 증명하기 위해 DeepMind는 700억 파라미터(70B)를 가진 ‘친칠라(Chinchilla)’ 모델을 개발했다. 친칠라는 기존의 Gopher(280B) 모델과 동일한 연산 예산을 사용했지만, 파라미터 수를 1/4로 줄이는 대신 학습 데이터 양을 4배인 1.4조(1.4T) 토큰으로 늘렸다. 결과는 충격적이었다. 70B 크기의 친칠라가 280B 크기의 Gopher, 175B 크기의 GPT-3, 530B 크기의 MT-NLG를 모든 주요 벤치마크에서 능가한 것이다.6 이는 “더 큰 모델이 더 똑똑하다“는 기존의 믿음을 깨고, “더 많이 보고 배운 모델이 더 똑똑하다“는 새로운 진리를 확립했다.</p>
<h3>2.3  파라메트릭 손실 함수와 계수의 의미</h3>
<p>친칠라 연구팀은 손실(<span class="math math-inline">L</span>)을 모델 크기(<span class="math math-inline">N</span>)와 데이터 크기(<span class="math math-inline">D</span>)의 함수로 정의하는 다음과 같은 수식을 제안했다.6<br />
<span class="math math-display">
L(N, D) = E + \frac{A}{N^\alpha} + \frac{B}{D^\beta}
</span><br />
이 수식은 LLM의 성능 오차가 세 가지 요인의 합으로 구성됨을 보여준다.</p>
<ul>
<li><strong><span class="math math-inline">E</span> (Irreducible Loss, 줄일 수 없는 손실):</strong> 데이터 자체가 가진 고유한 불확실성(Entropy). 아무리 완벽한 모델이라도 자연어의 중의성과 무작위성 때문에 도달할 수 없는 한계치이다. Chinchilla 논문에서는 이를 약 1.69로 추정했다.13</li>
<li><strong><span class="math math-inline">A N^{-\alpha}</span> (파라미터 항):</strong> 모델의 용량이 유한해서 생기는 오차. 모델이 커질수록 0에 수렴한다.</li>
<li><strong><span class="math math-inline">B D^{-\beta}</span> (데이터 항):</strong> 학습 데이터가 유한해서 생기는 오차. 데이터를 많이 볼수록 0에 수렴한다.</li>
</ul>
<p>Kaplan과 Chinchilla 연구의 결정적 차이는 이 계수들의 추정값에 있었다. Kaplan 연구에서는 파라미터 항의 영향력이 과대평가되었던 반면, Hoffmann 연구에서는 두 항의 균형이 중요하다는 점이 입증되었다. 특히 <span class="math math-inline">\alpha</span>와 <span class="math math-inline">\beta</span>의 값이 유사하다는 것은(각각 약 0.46, 0.54의 비율 결정력), 모델 크기 증가와 데이터 증가는 상호 보완적이며 어느 한쪽만 비대해져서는 효율적인 성능 향상을 기대할 수 없음을 수학적으로 증명한다.5</p>
<h2>3.  스케일링의 진화: 추론 효율성과 과잉 학습 (Inference-Optimal &amp; Overtraining)</h2>
<p>친칠라 법칙이 ‘학습(Training)’ 단계에서의 자원 최적화를 위한 나침반을 제공했다면, 2023년 이후 등장한 LLaMA(Meta) 등의 오픈 모델들은 실제 ‘서비스(Inference)’ 단계의 비용을 고려한 새로운 스케일링 전략을 제시했다. 이를 통해 스케일링 법칙은 ’컴퓨팅 최적화(Compute-Optimal)’에서 ’추론 최적화(Inference-Optimal)’로 진화했다.</p>
<pre><code class="language-mermaid">timeline
    title "4.2.3 ~ 4.2.5 스케일링 전략과 주요 모델의 진화"
    2020 "파라미터 우선주의" : "Kaplan 법칙 (OpenAI)" : "GPT-3 (175B)" : "비율 ~ 1.7 : 1"
    2022 "컴퓨팅 최적화 (학습)" : "Chinchilla 법칙 (DeepMind)" : "Chinchilla (70B)" : "비율 ~ 20 : 1 (황금비율)"
    2023 "추론 최적화 (서비스)" : "과잉 학습 (Meta)" : "LLaMA-3 (8B)" : "비율 ~ 1,875 : 1"
    2024 "추론 시간 스케일링" : "System 2 사고 (OpenAI)" : "o1 (O-one)" : "정확도 ~ log(생각하는 시간)"
</code></pre>
<h3>3.1  학습 비용 vs. 추론 비용</h3>
<p>친칠라 최적점(20:1)은 주어진 학습 예산 내에서 가장 좋은 모델을 만드는 방법이다. 그러나 모델을 한 번 학습시켜 수백만 명의 사용자에게 서비스해야 하는 실제 비즈니스 환경에서는 학습 비용보다 추론 비용(Inference Cost)이 훨씬 더 큰 비중을 차지한다. 추론 비용은 모델의 파라미터 수(<span class="math math-inline">N</span>)에 비례한다. 모델이 클수록 추론 시 더 많은 GPU 메모리와 연산이 필요하기 때문이다.</p>
<p>따라서 총 소유 비용(TCO) 관점에서는, 학습 때 비용을 더 쓰더라도 모델 크기를 줄여 추론 비용을 낮추는 것이 유리하다. 즉, 작은 모델을 친칠라 최적점보다 훨씬 더 오래 학습시키는 전략이다.14</p>
<h3>3.2  LLaMA와 과잉 학습(Overtraining)의 미학</h3>
<p>Meta의 LLaMA 시리즈는 이러한 ‘과잉 학습’ 전략의 정점을 보여준다. LLaMA-3 8B 모델의 경우, 친칠라 법칙에 따른 최적 데이터 양은 약 1,600억(160B) 토큰이다. 그러나 Meta는 이 모델을 그보다 약 100배 많은 <strong>15조(15T)</strong> 토큰으로 학습시켰다. 비율로 환산하면 파라미터당 약 <strong>1,875 토큰</strong>에 달한다.8</p>
<p><strong>표 4.2.2 주요 모델별 파라미터 대비 데이터 비율(Token-to-Parameter Ratio) 변화</strong></p>
<table><thead><tr><th><strong>모델</strong></th><th><strong>출시 연도</strong></th><th><strong>파라미터 수 (N)</strong></th><th><strong>학습 토큰 수 (D)</strong></th><th><strong>비율 (D/N)</strong></th><th><strong>스케일링 전략</strong></th></tr></thead><tbody>
<tr><td><strong>GPT-3</strong></td><td>2020</td><td>175B</td><td>300B</td><td><strong>~ 1.7 : 1</strong></td><td>파라미터 극대화 (Kaplan)</td></tr>
<tr><td><strong>Gopher</strong></td><td>2021</td><td>280B</td><td>300B</td><td><strong>~ 1.1 : 1</strong></td><td>심각한 과소적합</td></tr>
<tr><td><strong>Chinchilla</strong></td><td>2022</td><td>70B</td><td>1.4T</td><td><strong>~ 20 : 1</strong></td><td>컴퓨팅 최적화 (Hoffmann)</td></tr>
<tr><td><strong>LLaMA-3</strong></td><td>2024</td><td>8B</td><td>15T</td><td><strong>~ 1,875 : 1</strong></td><td>추론 최적화 및 과잉 학습</td></tr>
</tbody></table>
<p>Meta의 연구 결과에 따르면, 친칠라 최적점을 지나 데이터를 계속 주입해도 모델의 성능은 포화되지 않고 로그-선형적으로 계속 향상된다.16 이는 작은 모델이라도 압도적인 양의 데이터를 학습하면 거대 모델과 대등한 성능을 낼 수 있음을 증명했다. 실제로 8B 크기의 LLaMA-3는 적절히 학습된 70B 모델들과 경쟁할 수 있는 성능을 보여주었다.</p>
<h3>3.3  파멸적 과잉 학습(Catastrophic Overtraining)의 경계</h3>
<p>그러나 무한정 데이터를 늘리는 것에도 위험은 따른다. 최근 연구에 따르면, 특정 임계점을 넘어선 과도한 사전 학습은 모델의 가소성(Plasticity)을 저하시킬 수 있다. 이를 ’파멸적 과잉 학습’이라 부르는데, 사전 학습 데이터에 너무 과하게 최적화된 나머지, 새로운 태스크를 배우는 미세 조정(Fine-tuning) 단계에서 성능이 오히려 떨어지는 현상이 관찰되었다.15 예를 들어, 3T 토큰으로 학습된 모델이 2.3T 토큰 모델보다 다운스트림 태스크 성능이 떨어지는 역설적인 상황이 발생하기도 한다. 따라서 현대의 스케일링 전략은 단순히 <span class="math math-inline">D</span>를 최대화하는 것을 넘어, 일반화 능력과 특화 능력 사이의 균형을 찾는 정밀한 튜닝이 요구된다.</p>
<h2>4.  데이터의 질(Quality)과 유효 데이터 스케일링</h2>
<p>스케일링 법칙의 초기 형태는 데이터의 양(<span class="math math-inline">D</span>)을 단순히 ’토큰의 개수’로 정의했다. 그러나 “쓰레기를 넣으면 쓰레기가 나온다(Garbage In, Garbage Out)“는 격언처럼, 모든 토큰이 동등한 학습 가치를 지니지 않는다는 점이 명확해지면서 데이터 품질이 새로운 변수로 부상했다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "4.2.4 유효 데이터 스케일링"
    Raw["Raw Data (D_raw)"] --&gt; Filter["품질 필터링 (Q)"]
    Filter --&gt; Synth["합성 데이터 추가&lt;br/&gt;(Textbooks Are All You Need)"]
    Synth --&gt; Deff["유효 데이터 (D_eff)&lt;br/&gt;D_eff = Q * D_raw"]
    Deff --&gt; Phi["Phi-1 (1.3B)"]
    Phi --"적은 데이터로 고성능 달성"--&gt; Shift["스케일링 곡선의 상향 이동"]
    end

    subgraph "4.2.5 추론 시간 스케일링 (Inference-Time Scaling)"
    Lim["Pre-training 성능의 한계 체감"] --&gt; NewPath["추론 연산량 투입 (Test-time Compute)"]
    NewPath --&gt; Sys2["System 2 사고&lt;br/&gt;(Chain of Thought)"]
    Sys2 --&gt; Time["생각하는 시간 (T) 증가"]
    Time --"로그-선형 관계"--&gt; Acc["정확도(Accuracy) 향상"]
    Acc --&gt; Model_o1["OpenAI o1 모델"]
    end
</code></pre>
<h3>4.1  Phi-1과 “Textbooks Are All You Need”</h3>
<p>Microsoft의 Phi-1(1.3B) 모델은 데이터 품질이 스케일링 법칙을 어떻게 왜곡시킬 수 있는지 보여준 극적인 사례이다. 이 모델은 고작 13억 개의 파라미터와 70억(7B) 토큰이라는 극소량의 데이터로 학습되었음에도 불구하고, 수십 배 더 큰 모델들을 코딩 벤치마크(HumanEval)에서 압도했다.18</p>
<p>비결은 웹상의 잡음 섞인 데이터 대신, 교과서 수준의 고품질 데이터와 GPT-3.5가 생성한 논리적인 합성 데이터(Synthetic Data)만을 선별하여 학습시킨 데 있었다. 이는 유효 데이터(<span class="math math-inline">D_{eff}</span>)가 실제 데이터 양(<span class="math math-inline">D_{raw}</span>)과 품질 계수(<span class="math math-inline">Q</span>)의 곱으로 표현될 수 있음을 시사한다 (<span class="math math-inline">D_{eff} = Q \times D_{raw}</span>). 고품질 데이터 1개는 저품질 데이터 100개 이상의 학습 효과를 낼 수 있으며, 이는 스케일링 법칙 곡선 자체를 위쪽으로 평행 이동(Shift)시키는 효과를 가져온다.20</p>
<h3>4.2  데이터 장벽(Data Wall)과 합성 데이터</h3>
<p>인터넷상의 고품질 텍스트 데이터가 2026~2030년경 고갈될 것이라는 ‘데이터 장벽’ 전망이 나오면서21, 스케일링 법칙을 지속하기 위한 연료로서 합성 데이터의 중요성은 더욱 커지고 있다. Phi-1의 성공은 잘 설계된 합성 데이터가 자연 데이터의 한계를 넘어설 수 있음을 증명하며, 향후 스케일링 경쟁이 ’데이터 확보’에서 ’데이터 생성’으로 이동할 것임을 예고한다.</p>
<h2>5.  새로운 차원: 추론 시간 스케일링 (Inference-Time Scaling)</h2>
<p>2024년 말, OpenAI의 o1(O-one) 모델 출시는 스케일링 법칙의 역사에 또 다른 차원을 추가했다. 기존의 법칙들이 ’모델을 만드는 과정(Pre-training)’에서의 자원 투입을 다뤘다면, o1은 ’모델이 답을 생성하는 과정(Inference)’에 자원을 투입하여 지능을 확장하는 **추론 시간 스케일링 법칙(Inference-Time Scaling Laws)**을 제시했다.</p>
<h3>5.1  System 1에서 System 2로의 전환</h3>
<p>대니얼 카너먼의 사고 체계 이론을 빌리자면, 기존 LLM은 직관적이고 빠르게 반응하는 ’System 1’에 가까웠다. 반면 o1 모델은 복잡한 문제에 직면했을 때 즉답을 피하고, 내부적으로 긴 ’생각의 사슬(Chain of Thought)’을 생성하며 논리적 오류를 스스로 검증하고 수정하는 ’System 2’적 사고를 모방한다.23</p>
<h3>5.2  생각하는 시간과 성능의 로그-선형 관계</h3>
<p>OpenAI의 분석에 따르면, o1 모델의 성능은 추론 시간에 비례하여 예측 가능하게 향상된다. 특히, 수학 올림피아드(AIME)나 코딩 테스트와 같은 복잡한 추론 태스크에서, 모델에게 더 많은 ’생각할 시간(토큰 생성)’을 부여할수록 정답률이 로그 스케일로 선형적으로 증가함이 확인되었다.23<br />
<span class="math math-display">
Accuracy \propto \log(Compute_{inference})
</span><br />
이는 사전 학습 단계에서의 성능 향상이 한계 체감(Diminishing Returns)에 부딪힐 때, 추론 단계에서의 연산량 투입을 통해 성능을 추가로 끌어올릴 수 있는 새로운 경로를 열어주었다. 기존에는 모델 성능이 <span class="math math-inline">L(N, D)</span>의 함수였다면, 이제는 추론 시간(<span class="math math-inline">T</span>)이 포함된 <span class="math math-inline">L(N, D, T)</span>의 함수로 확장된 것이다.26</p>
<p><strong>표 4.2.3 스케일링 패러다임의 3단계 진화</strong></p>
<table><thead><tr><th><strong>단계</strong></th><th><strong>패러다임</strong></th><th><strong>핵심 법칙</strong></th><th><strong>최적화 목표</strong></th><th><strong>대표 모델</strong></th></tr></thead><tbody>
<tr><td><strong>1단계</strong></td><td><strong>Pre-training Scaling</strong></td><td>Kaplan Laws</td><td>파라미터 극대화 (<span class="math math-inline">N \gg D</span>)</td><td>GPT-3</td></tr>
<tr><td><strong>2단계</strong></td><td><strong>Compute-Optimal</strong></td><td>Chinchilla Laws</td><td>파라미터-데이터 균형 (<span class="math math-inline">N \approx D</span>)</td><td>Chinchilla, Gopher</td></tr>
<tr><td><strong>3단계</strong></td><td><strong>Inference Scaling</strong></td><td>System 2 Scaling</td><td>추론 시간 연산 활용 (<span class="math math-inline">Accuracy \propto \log T</span>)</td><td>OpenAI o1, DeepSeek R1</td></tr>
</tbody></table>
<h3>5.3  에너지 비용과 경제적 함의</h3>
<p>추론 시간 스케일링은 AGI로 가는 유력한 경로이지만, 동시에 막대한 에너지 비용을 수반한다. 모델이 한 문제를 푸는 데 수십 초에서 수 분 동안 수천 개의 토큰을 내부적으로 생성해야 하기 때문이다. 이는 AI 서비스의 비용 구조를 근본적으로 변화시킬 수 있다. NVIDIA의 젠슨 황 CEO가 언급했듯, 데이터센터는 이제 단순한 학습장이 아니라 거대한 추론을 수행하는 ’AI 공장’으로 변모하고 있으며, 이는 전력 소모와 하드웨어 수요의 폭발적인 증가를 예고한다.27</p>
<h2>6.  결론: 동적 균형과 트랜스포머의 미래</h2>
<p>4.2절에서 살펴본 스케일링 법칙의 역사는 트랜스포머 아키텍처의 잠재력을 끌어내기 위한 인류의 탐구 과정이었다. Kaplan의 연구가 “규모가 깡패다“라는 직관을 멱법칙으로 증명하며 거대 모델의 시대를 열었다면, Chinchilla는 “데이터 없는 규모는 허상“임을 일깨우며 효율성의 시대를 열었다. 그리고 LLaMA와 o1은 각각 “과잉 학습“과 “숙고(Deliberation)“라는 새로운 무기를 통해 스케일링의 한계를 다시 한번 돌파하고 있다.</p>
<p>트랜스포머 싱귤래리티는 고정된 지점이 아니다. 그것은 파라미터, 데이터, 그리고 추론 시간이라는 세 가지 변수가 끊임없이 상호작용하며 확장해 나가는 동적인 과정이다. 현재 우리는 <span class="math math-inline">E</span>(자연어의 엔트로피)라는 절대적인 한계에 도전하고 있으며, 데이터 장벽과 에너지 제약이라는 물리적 벽을 마주하고 있다. 그러나 스케일링 법칙은 여전히 유효하며, 합성 데이터와 추론 시간 스케일링이라는 새로운 변수들이 이 법칙을 연장하고 있다. 결국 디코더의 시대에 ’생성’은 단순한 텍스트의 나열이 아니라, 최적의 자원 배분을 통해 압축된 지능을 발현하는 과정 그 자체라 할 수 있다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Scaling laws for neural language models - OpenAI, https://openai.com/index/scaling-laws-for-neural-language-models/</li>
<li>Scaling Laws for Neural Language Models - arXiv, https://arxiv.org/pdf/2001.08361</li>
<li>Scaling Laws In Large Language Model Training Accurately Predict Downstream Task Performance - Quantum Zeitgeist, https://quantumzeitgeist.com/training-performance-scaling-laws-large-language-model-accurately-predict-downstream/</li>
<li>Observational Scaling Laws and the Predictability of Language Model Performance - arXiv, https://arxiv.org/html/2405.10938v1</li>
<li>Reconciling Kaplan and Chinchilla Scaling Laws - arXiv, https://arxiv.org/html/2406.12907v2</li>
<li>Training Compute-Optimal Large Language Models, https://arxiv.org/abs/2203.15556</li>
<li>Beyond Bigger Models: The Evolution of Language Model Scaling Laws - Medium, https://medium.com/@aiml_58187/beyond-bigger-models-the-evolution-of-language-model-scaling-laws-d4bc974d3876</li>
<li>Chinchilla data-optimal scaling laws: In plain English - LifeArchitect.ai, https://lifearchitect.ai/chinchilla/</li>
<li>“Training Compute-Optimal Large Language Models”, Hoffmann et al 2022 {DeepMind} (current LLMs are significantly undertrained) : r/mlscaling - Reddit, https://www.reddit.com/r/mlscaling/comments/trwkck/training_computeoptimal_large_language_models/</li>
<li>Chinchilla Scaling Law Overview - Emergent Mind, https://www.emergentmind.com/topics/chinchilla-scaling-law</li>
<li>Chinchilla Scaling Laws: Compute-Optimal Training and Resource Allocation for Large Language Models - Michael Brenndoerfer, https://mbrenndoerfer.com/writing/chinchilla-scaling-laws-compute-optimal-training-resource-allocation</li>
<li>An empirical analysis of compute-optimal large language model training - Google DeepMind, https://deepmind.google/blog/an-empirical-analysis-of-compute-optimal-large-language-model-training/</li>
<li>Chinchilla Scaling: A replication attempt - arXiv, https://arxiv.org/html/2404.10102v2</li>
<li>How Long Should You Train Your Language Model? | Databricks Blog, https://www.databricks.com/blog/how-long-should-you-train-your-language-model</li>
<li>Overtrained Language Models Are Harder to Fine-Tune - arXiv, https://arxiv.org/pdf/2503.19206</li>
<li>[D] New Llama scaling laws? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/1eq95ga/d_new_llama_scaling_laws/</li>
<li>Overtrained Language Models Are Harder to Fine-Tune - arXiv, https://arxiv.org/html/2503.19206v1</li>
<li>[2306.11644] Textbooks Are All You Need - arXiv, https://arxiv.org/abs/2306.11644</li>
<li>Textbooks Are All You Need - Microsoft Research, https://www.microsoft.com/en-us/research/publication/textbooks-are-all-you-need/</li>
<li>Textbooks Are All You Need and Scaling Laws for LLMs | by Matthew Gunton | Medium, https://medium.com/@mgunton7/the-impact-of-better-data-on-llms-46153ba26795</li>
<li>Anton Korinek AI Scaling Laws and Market Structure - Princeton Economics Department, https://economics.princeton.edu/wp-content/uploads/2025/02/2024.11.26-MA-Anton-Korinek.pdf</li>
<li>Can AI scaling continue through 2030? - Epoch AI, https://epoch.ai/blog/can-ai-scaling-continue-through-2030</li>
<li>Learning to reason with LLMs | OpenAI, https://openai.com/index/learning-to-reason-with-llms/</li>
<li>o1: A Technical Primer - LessWrong, https://www.lesswrong.com/posts/byNYzsfFmb2TpYFPW/o1-a-technical-primer</li>
<li>hughbzhang/o1_inference_scaling_laws: Replicating O1 inference-time scaling laws - GitHub, https://github.com/hughbzhang/o1_inference_scaling_laws</li>
<li>Trading inference-time compute for adversarial robustness. | OpenAI, https://cdn.openai.com/papers/trading-inference-time-compute-for-adversarial-robustness-20250121_1.pdf</li>
<li>How Scaling Laws Drive Smarter, More Powerful AI - NVIDIA Blog, https://blogs.nvidia.com/blog/ai-scaling-laws/</li>
<li>3 Ways NVIDIA Is Powering the Industrial Revolution, https://blogs.nvidia.com/blog/gpu-cuda-scaling-laws-industrial-revolution/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>