<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:7.1 Pre-Norm vs Post-Norm 깊은 모델 학습의 딜레마</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>7.1 Pre-Norm vs Post-Norm 깊은 모델 학습의 딜레마</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>7.1 Pre-Norm vs Post-Norm 깊은 모델 학습의 딜레마</span></nav>
                </div>
            </header>
            <article>
                <h1>7.1 Pre-Norm vs Post-Norm 깊은 모델 학습의 딜레마</h1>
<p>2025-12-21, G30DR</p>
<p>인공지능의 역사는 모델의 깊이(Depth)를 확장하려는 투쟁의 역사와 궤를 같이한다. 얕은 신경망에서 시작하여 수백, 수천 층의 심층 신경망(Deep Neural Networks)으로 나아가는 과정은 단순한 파라미터 수의 증가가 아니라, 추상화 능력의 비약적인 상승을 의미하기 때문이다. 트랜스포머(Transformer) 아키텍처가 등장한 이래, 자연어 처리(NLP)를 넘어 전 범용 인공지능(AGI)을 향한 여정에서 가장 큰 걸림돌 중 하나는 역설적이게도 학습의 ’안정성’과 ‘성능’ 사이의 미묘한 줄타기였다. 이 줄타기의 핵심에 위치한 것이 바로 정규화(Normalization) 층의 배치 전략, 즉 **Pre-Norm(사전 정규화)**과 **Post-Norm(사후 정규화)**의 딜레마이다.</p>
<p>이 장에서는 트랜스포머 모델의 학습 역학(Training Dynamics)을 결정짓는 정규화의 위치 문제를 심도 있게 파헤친다. 우리는 초기 트랜스포머가 채택했던 Post-Norm의 이론적 우아함과 실질적 난관, 이를 극복하기 위해 등장하여 현대 거대언어모델(LLM)의 표준이 된 Pre-Norm의 안정성 신화, 그리고 그 이면에 도사리고 있는 ’표현 붕괴(Representation Collapse)’라는 새로운 위협을 분석할 것이다. 더 나아가 DeepNet, ResiDual, 그리고 최신 DeepSeek-V3와 LLaMA 3가 보여주는 RMSNorm 기반의 하이브리드 전략들이 어떻게 이 딜레마를 해결하고 트랜스포머를 ’싱귤래리티’로 이끌고 있는지 수학적, 경험적 증거를 통해 논증한다.</p>
<h2>1.  정규화의 기하학: Post-Norm의 이상과 현실</h2>
<pre><code class="language-mermaid">graph TD
    subgraph "Post-Norm 아키텍처 (Architecture)"
        In["입력 (Input x_l)"] --&gt; Op["연산 블록 F(x) (Attn/FFN)"]
        In --&gt; Add1(("잔차 연결 (+)"))
        Op --&gt; Add1
        Add1 --&gt; LN["정규화 (LayerNorm)"]
        LN --&gt; Out["출력 (Output x_l+1)"]
    end

    subgraph "깊이의 저주 (The Curse of Depth)"
        Init["가중치 초기화"] --&gt; Grad["역전파 시 그라디언트 계산"]
        LN --&gt; |"정규화가 그라디언트 경로 차단"| Grad
        Grad --&gt; |"하위 층으로 갈수록 소실/폭주"| Unstable["초기 학습 불안정성"]
        Unstable --&gt; |"발산 위험 증가"| NeedWarmup["긴 웜업(Warm-up) 필수"]
        NeedWarmup --&gt; |"학습 속도 저하"| Limit["초거대 모델 확장 불가"]
    end

    style LN fill:#ff9999,stroke:#333,stroke-width:2px
    style Unstable fill:#ffcccc,stroke:#f00,stroke-width:2px
</code></pre>
<h3>1.1  Post-Norm의 정의와 원초적 설계</h3>
<p>2017년 바스와니(Vaswani) 등이 제안한 원조 트랜스포머(“Attention Is All You Need”) 아키텍처는 Post-Norm 방식을 채택했다. Post-Norm은 각 하위 계층(Sub-layer)—멀티 헤드 어텐션(MHA)이나 피드포워드 네트워크(FFN)—의 연산을 수행하고 잔차 연결(Residual Connection)을 더한 <em>후에</em> 정규화를 적용하는 방식이다. 이를 수식으로 표현하면 다음과 같다 1:<br />
<span class="math math-display">
x_{l+1} = \text{LayerNorm}(x_l + \mathcal{F}_l(x_l))
</span><br />
여기서 <span class="math math-inline">x_l</span>은 <span class="math math-inline">l</span>번째 층의 입력 벡터이며, <span class="math math-inline">\mathcal{F}_l</span>은 해당 층의 연산 블록(Attention 또는 FFN)을 의미한다. 이 구조는 ResNet(Residual Network)의 “Pre-activation” 구조가 제안되기 전의 고전적인 잔차 학습 형식을 따르고 있다.</p>
<p>Post-Norm의 설계 철학은 직관적이다. 정규화 층을 잔차 블록의 마지막 관문으로 배치함으로써, 각 층의 출력이 항상 표준화된 분포(평균 0, 분산 1)를 유지하도록 강제하는 것이다. 이는 다음 층으로 넘어가는 입력값의 스케일을 일정하게 보장하므로, 이론적으로는 모델이 깊어지더라도 각 층이 다루는 데이터의 분포가 안정적으로 유지되어야 한다. 이러한 특성 때문에 Post-Norm은 학습이 성공적으로 수렴할 경우, 최적의 성능(Peak Performance)을 달성할 잠재력이 가장 높은 구조로 평가받는다.3 정규화된 출력이 다음 층의 비선형성(Non-linearity)을 최대한 활용할 수 있는 적절한 범위 내에 머물기 때문이다.</p>
<h3>1.2  깊이의 저주: 그라디언트 소실과 초기 학습의 불안정성</h3>
<p>그러나 이론적 우아함은 현실의 딥러닝 학습 과정에서 가혹한 도전에 직면했다. Post-Norm 트랜스포머는 모델의 층이 깊어질수록 학습 초기에 극심한 불안정성을 보였으며, 종종 학습이 아예 진행되지 않는 발산(Divergence) 현상을 겪었다.</p>
<p>이 현상의 원인을 규명하기 위해 슝(Xiong) 등(2020)은 평균장 이론(Mean Field Theory)을 도입하여 Post-Norm 트랜스포머의 순전파(Forward Pass)와 역전파(Backward Pass) 과정을 분석하였다.5 분석 결과, Post-Norm 구조에서는 잔차 연결을 통과할 때마다 신호의 분산이 누적되는 경향이 있음이 드러났다. 초기화 단계에서 <span class="math math-inline">l</span>번째 층의 출력 분산은 층의 깊이에 따라 선형적으로 증가하지 않고, 정규화 층에 의해 매번 리셋되지만, 이 과정이 반복되면서 역전파 시 그라디언트의 거동에 치명적인 영향을 미친다.</p>
<p>Post-Norm 구조에서 파라미터에 대한 손실 함수 <span class="math math-inline">\mathcal{L}</span>의 그라디언트 크기(Gradient Norm)는 출력 층(Last Layer) 근처에서는 매우 큰 값을 가지는 반면, 입력 층(First Layer)으로 갈수록 급격히 작아지거나 노이즈가 심해지는 경향을 보인다.6 구체적으로, 출력 층 부근의 그라디언트 기댓값은 층 깊이 <span class="math math-inline">L</span>에 비례하여 커질 수 있다. 이는 심층 신경망의 고전적인 난제인 ‘그라디언트 소실(Vanishing Gradient)’ 및 ‘그라디언트 폭주(Exploding Gradient)’ 문제의 변주이다. 특히 Post-Norm에서는 정규화 층이 그라디언트가 흐르는 경로 상에 위치하여, 역전파 과정에서 다수의 정규화 미분항이 곱해지게 된다. 이는 그라디언트 흐름을 가로막거나 왜곡시키는 병목으로 작용한다.2</p>
<h3>1.3  웜업(Warm-up)의 필연성</h3>
<p>이러한 불안정성 때문에 Post-Norm 트랜스포머를 학습시키기 위해서는 매우 조심스러운 접근이 필요했다. 그 해결책으로 등장한 것이 바로 ’학습률 웜업(Learning Rate Warm-up)’이다.6 웜업은 학습 초기에 학습률(Learning Rate)을 0에 가까운 매우 작은 값에서 시작하여 일정 스텝 동안 선형적으로 증가시키는 전략이다.</p>
<p>왜 웜업이 필수적인가? 류(Liu) 등(2020)과 슝(Xiong) 등(2020)의 연구에 따르면, 학습 초기 단계에서 Adam 옵티마이저는 큰 그라디언트 분산을 가진 파라미터들에 대해 과도하게 큰 업데이트 스텝을 밟을 위험이 있다.5 Post-Norm 구조에서는 초기화 직후 출력 층 부근의 그라디언트가 매우 크기 때문에, 웜업 없이 일반적인 학습률을 적용하면 파라미터가 최적화 경로를 이탈하여 나쁜 지역 최적점(Bad Local Minima)에 빠지거나 발산하게 된다. 웜업은 초기 그라디언트의 변동성을 억제하고, 파라미터들이 안정적인 영역으로 진입할 때까지 기다려주는 일종의 ‘안전장치’ 역할을 수행한다.6</p>
<p>하지만 웜업은 만병통치약이 아니다. 웜업 기간을 설정하는 것은 또 다른 하이퍼파라미터 튜닝의 부담을 주며, 전체 학습 속도를 늦추는 요인이 된다. 더 심각한 문제는 모델이 수백 층 이상으로 깊어질 경우(DeepNet), 아무리 긴 웜업을 사용하더라도 Post-Norm 모델은 학습에 실패할 확률이 높다는 점이다.7 이는 Post-Norm의 구조적 한계가 단순히 초기화나 학습률 조절만으로는 극복하기 어려운 본질적인 결함임을 시사한다.</p>
<h2>2.  Pre-Norm의 부상: 안정성 혁명과 그 대가</h2>
<pre><code class="language-mermaid">graph TD
    subgraph "Pre-Norm 아키텍처 (Architecture)"
        In2["입력 (Input x_l)"] --&gt; LN2["정규화 (LayerNorm)"]
        LN2 --&gt; Op2["연산 블록 F(x)"]
        In2 --&gt; |"항등 경로 (Identity Path)"| Add2(("잔차 연결 (+)"))
        Op2 --&gt; Add2
        Add2 --&gt; Out2["출력 (Output x_l+1)"]
    end

    subgraph "표현 붕괴 메커니즘 (Representation Collapse)"
        Deep["층이 깊어짐 (L 증가)"] --&gt; VarIncrease["메인 경로(x_l) 분산 증가"]
        LN2 --&gt; |"잔차 가지 크기 제한"| BranchLimit["잔차 기여도(F(x)) 상대적 감소"]
        VarIncrease --&gt; |"x_L ≈ x_L-1"| Sim["코사인 유사도 1에 수렴"]
        BranchLimit --&gt; Sim
        Sim --&gt; Collapse["표현 붕괴 (Rank Collapse)"]
        Collapse --&gt; |"깊은 층의 무용지물화"| PerfDrop["잠재적 성능 저하"]
    end

    style Add2 fill:#99ff99,stroke:#333,stroke-width:4px
    style Collapse fill:#ccccff,stroke:#00f,stroke-width:2px
</code></pre>
<h3>2.1  항등 경로(Identity Path)의 마법</h3>
<p>Post-Norm의 한계를 극복하기 위해 연구자들은 정규화 층의 위치를 잔차 연결 내부로 옮기는 실험을 감행했다. 이것이 바로 Pre-Norm(사전 정규화) 아키텍처의 탄생이다. Pre-Norm은 입력 <span class="math math-inline">x_l</span>을 먼저 정규화한 후 하위 계층 연산을 수행하고, 그 결과를 원본 입력 <span class="math math-inline">x_l</span>에 더한다.1<br />
<span class="math math-display">
x_{l+1} = x_l + \mathcal{F}_l(\text{LayerNorm}(x_l))
</span><br />
이 수식의 변화는 단순해 보이지만, 기하학적 의미는 심장하다. Pre-Norm 구조에서 원본 입력 <span class="math math-inline">x_l</span>은 어떠한 비선형 변환이나 정규화도 거치지 않고 다음 층으로 직접 전달되는 ’항등 경로(Identity Path)’를 확보하게 된다. 이는 ResNet v2에서 제안된 “Clean Residual Path” 개념과 일맥상통한다.</p>
<p>항등 경로의 존재는 역전파 시 그라디언트가 흐를 수 있는 ’고속도로’를 제공한다.2 손실 함수에서 발생한 오차 신호는 복잡한 연산 블록이나 정규화 층을 통과하며 감쇠될 필요 없이, 덧셈 연산(+)을 타고 최상위 층에서 최하위 층까지 막힘없이 전파된다. 이론적으로 Pre-Norm 트랜스포머의 그라디언트는 층의 깊이에 무관하게 비교적 일정한 크기(Norm)를 유지한다.6</p>
<h4>2.1.1  웜업 없는 학습과 확장성</h4>
<p>Pre-Norm의 가장 큰 기여는 학습의 안정성을 획기적으로 개선했다는 점이다. 슝(Xiong) 등의 분석에 따르면, Pre-Norm 구조에서는 초기화 시 그라디언트의 크기가 층의 깊이에 의존하지 않고 잘 제어된다.6 이는 곧 까다로운 학습률 웜업 단계가 불필요하거나, 매우 짧게 줄일 수 있음을 의미한다.</p>
<p>이러한 안정성은 모델의 확장에 결정적인 트리거가 되었다. GPT-3(175B), PaLM(540B), LLaMA, DeepSeek 등 최근 5년 간 등장한 거의 모든 거대언어모델(LLM)은 Pre-Norm 아키텍처를 기반으로 한다.13 수천 억 개의 파라미터를 가진 모델을 학습시킬 때, 발산의 위험을 최소화하고 예측 가능한 학습 곡선을 그리는 것은 선택이 아닌 필수이기 때문이다. Pre-Norm은 엔지니어들에게 “학습이 터지지 않을 것“이라는 확신을 주었다.</p>
<h4>2.1.2  Pre-Norm의 그림자: 표현 붕괴(Representation Collapse)</h4>
<p>그러나 빛이 있으면 그림자가 있는 법이다. Pre-Norm은 학습 안정성이라는 선물을 주었지만, 그 대가로 ‘표현 붕괴(Representation Collapse)’ 또는 ’깊이의 저주’라 불리는 새로운 문제를 안겨주었다.</p>
<p><strong>표현 붕괴의 메커니즘 분석</strong></p>
<p>Pre-Norm 구조의 수식을 재귀적으로 전개해보면 문제의 본질이 드러난다. <span class="math math-inline">L</span>번째 층의 출력 <span class="math math-inline">x_L</span>은 초기 입력 <span class="math math-inline">x_0</span>와 각 층의 변환 결과의 합으로 표현된다.<br />
<span class="math math-display">
x_L = x_0 + \sum_{l=0}^{L-1} \mathcal{F}_l(\text{LayerNorm}(x_l))
</span><br />
문제는 층이 깊어질수록 메인 경로인 <span class="math math-inline">x_l</span>의 분산(Variance)이 지속적으로 증가한다는 점이다. 반면, 잔차 가지(Residual Branch)인 <span class="math math-inline">\mathcal{F}_l(\text{LayerNorm}(x_l))</span>의 출력은 LayerNorm에 의해 그 크기가 제한된다. 결과적으로 층이 거듭될수록 전체 합(<span class="math math-inline">x_L</span>)에서 잔차 가지가 기여하는 비중은 기하급수적으로 줄어든다.11</p>
<p>이는 깊은 층으로 갈수록 해당 층이 학습에 기여하는 바가 미미해짐을 의미한다. 연구에 따르면, Pre-Norm 모델의 깊은 층들 사이의 코사인 유사도(Cosine Similarity)는 1에 가깝게 수렴한다.16 즉, <span class="math math-inline">x_{L}</span>과 <span class="math math-inline">x_{L-1}</span>이 거의 동일한 벡터가 되어버리는 것이다. 모델은 깊지만, 실질적으로는 얕은 모델과 다를 바 없는 상태가 된다. 이를 ’순위 붕괴(Rank Collapse)’라고도 하며, 모델이 깊이를 통해 얻을 수 있는 복잡한 계층적 특징(Hierarchical Features)을 학습하지 못하고 있음을 시사한다.</p>
<p>일부 연구에서는 Pre-Norm 모델의 깊은 층을 제거(Pruning)하더라도 성능 저하가 거의 발생하지 않는 현상을 보고하였다.19 이는 파라미터 효율성 측면에서 심각한 낭비이며, Pre-Norm이 모델의 잠재력을 100% 끌어내지 못하고 있다는 증거이다. 성능(Performance) 측면에서 Pre-Norm 모델은 동일한 깊이의 잘 튜닝된 Post-Norm 모델보다 낮은 성능을 보이는 경우가 많다.3 이는 ’안정성’과 ‘표현력’ 사이의 명확한 트레이드오프를 보여준다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>Post-Norm</strong></th><th><strong>Pre-Norm</strong></th></tr></thead><tbody>
<tr><td><strong>구조</strong></td><td><span class="math math-inline">x_{l+1} = \text{LN}(x_l + \mathcal{F}(x_l))</span></td><td><span class="math math-inline">x_{l+1} = x_l + \mathcal{F}(\text{LN}(x_l))</span></td></tr>
<tr><td><strong>학습 안정성</strong></td><td>낮음 (초기 발산 위험 높음)</td><td>높음 (안정적인 수렴)</td></tr>
<tr><td><strong>웜업 필요성</strong></td><td>필수 (긴 웜업 요구)</td><td>불필요하거나 짧음</td></tr>
<tr><td><strong>그라디언트 흐름</strong></td><td>하위 층으로 갈수록 소실/폭주</td><td>항등 경로를 통해 원활한 흐름</td></tr>
<tr><td><strong>표현력 (성능)</strong></td><td>높음 (잠재력 최대화)</td><td>다소 낮음 (표현 붕괴 위험)</td></tr>
<tr><td><strong>깊이 확장성</strong></td><td>어려움 (DeepNet 불가)</td><td>용이함 (LLM의 표준)</td></tr>
<tr><td><strong>주요 문제</strong></td><td>학습 불안정성</td><td>표현 붕괴, 깊은 층의 기여도 저하</td></tr>
</tbody></table>
<h3>2.2  딜레마의 돌파구: DeepNet과 DeepNorm</h3>
<p>마이크로소프트 리서치(Microsoft Research)가 제안한 DeepNet과 <strong>DeepNorm</strong>은 이 딜레마를 정면으로 돌파하려는 시도였다. 그들은 1,000층 이상의 트랜스포머를 학습시키기 위해 Post-Norm의 성능과 Pre-Norm의 안정성을 결합하는 수학적 해법을 제시했다.7</p>
<p>DeepNet 연구진은 Post-Norm의 불안정성이 ’모델 업데이트의 폭주(Exploding Model Update)’에서 기인함을 이론적으로 증명했다. 초기화 단계에서 각 층의 파라미터 업데이트 크기 <span class="math math-inline">|\Delta \theta|</span>가 층의 깊이 <span class="math math-inline">N</span>에 따라 누적되어 커지는 현상을 발견한 것이다.7 이를 제어하기 위해 그들은 잔차 연결의 가중치를 조절하는 DeepNorm 기법을 고안했다.</p>
<p>DeepNorm의 공식은 다음과 같다:<br />
<span class="math math-display">
x_{l+1} = \text{LayerNorm}(\alpha x_l + G(x_l, \theta_l))
</span><br />
여기서 <span class="math math-inline">\alpha</span>는 잔차 경로의 스케일을 조절하는 상수이다. 일반적인 Post-Norm은 <span class="math math-inline">\alpha=1</span>인 경우에 해당한다. DeepNorm은 <span class="math math-inline">\alpha</span>를 1보다 크게 설정하여 잔차 경로를 강화함으로써, Pre-Norm의 장점인 ‘신호 보존’ 효과를 모사한다. 동시에 연산 블록 <span class="math math-inline">G</span> 내부의 가중치 <span class="math math-inline">\theta_l</span>을 <span class="math math-inline">\beta</span>라는 상수로 스케일링하여 초기화한다.23</p>
<p>이론적으로 도출된 <span class="math math-inline">\alpha</span>와 <span class="math math-inline">\beta</span>의 값은 모델의 깊이 <span class="math math-inline">N</span>에 의존한다. 인코더의 경우 대략 다음과 같은 관계를 갖는다 24:<br />
<span class="math math-display">
\alpha \approx (2N)^{1/4}, \quad \beta \approx \frac{1}{(2N)^{1/4}}
</span><br />
(정확한 유도 식은 논문의 인코더/디코더 구조에 따라 <span class="math math-inline">\alpha = \sqrt{2N}, \beta = \frac{1}{\sqrt{2N}}</span> 등으로 다르게 표현되기도 하지만, 핵심은 깊이가 깊어질수록 잔차 경로(<span class="math math-inline">\alpha</span>)를 키우고 연산 블록의 초기 기여도(<span class="math math-inline">\beta</span>)를 줄인다는 점이다).</p>
<p>이 전략은 놀라운 성과를 거두었다. DeepNorm을 적용한 1,000층 트랜스포머는 웜업 없이도 안정적으로 학습되었으며, 동일한 깊이의 Pre-Norm 모델보다 더 높은 BLEU 점수(번역 성능)를 기록했다.7 이는 구조적 변경 없이 초기화와 스케일링 전략만으로도 Post-Norm의 성능과 Pre-Norm의 안정성을 동시에 달성할 수 있음을 입증한 사례로, 정규화 딜레마의 중요한 변곡점이 되었다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "DeepNorm 전략 (Rescaling Strategy)"
        Input["입력 (x_l)"]
        
        Input --&gt; |"Alpha Scaling (x ≈ (2N)^1/4)"| MainPath["메인 경로 강화 (alpha * x_l)"]
        Input --&gt; |"Beta Scaling"| ResidPath["잔차 경로 초기화 억제 (G(x) / beta)"]
        
        MainPath --&gt; Join(("결합 (+)"))
        ResidPath --&gt; Join
        
        Join --&gt; LN3["DeepNorm 적용"]
        LN3 --&gt; Output["안정된 고성능 출력"]
    end

    subgraph "효과 (Effects)"
        Stable["폭주 없는 업데이트"]
        Perf["Post-Norm급 성능"]
        Deep["1000층 이상 확장 가능"]
        
        LN3 --&gt; Stable
        Stable --&gt; Deep
        Deep --&gt; Perf
    end
    
    style MainPath fill:#fff2cc,stroke:#d6b656,stroke-width:2px
</code></pre>
<h3>2.3  현대 LLM의 표준: RMSNorm과 정밀 공학</h3>
<p>DeepNorm이 이론적인 돌파구를 마련했다면, 산업계의 거대언어모델들은 실용성과 효율성에 초점을 맞춘 독자적인 진화를 거듭했다. 현재 LLaMA, DeepSeek, Gopher 등 최신 모델들이 채택하고 있는 표준은 **RMSNorm(Root Mean Square Layer Normalization)**과 개량된 Pre-Norm 구조이다.</p>
<p><strong>DeepSeek-V3 / LLaMA 3 아키텍처</strong></p>
<pre><code class="language-mermaid">graph TD   
    subgraph "단일 블록 내부 (Inside Transformer Block)"
        InTok["입력 토큰"] --&gt; RMS1["Pre-RMSNorm (BF16/FP32)"]
        RMS1 --&gt; Attn["Attention / MoE (FP8 Mixed)"]
        InTok --&gt; Res1(("잔차 (+)"))
        Attn --&gt; Res1
        
        Res1 --&gt; RMS2["Pre-RMSNorm (BF16/FP32)"]
        RMS2 --&gt; FFN["FFN / SwiGLU (FP8 Mixed)"]
        Res1 --&gt; Res2(("잔차 (+)"))
        FFN --&gt; Res2
    end
    
    subgraph "전역 안정화 장치 (Global Stabilizers)"
        Res2 --&gt; FinalRMS["Final RMSNorm (출력 직전 보정)"]
        FinalRMS --&gt; Logits["Logits 출력"]
    end

    style RMS1 fill:#ccffcc,stroke:#333,stroke-width:2px
    style RMS2 fill:#ccffcc,stroke:#333,stroke-width:2px
    style FinalRMS fill:#ffcc99,stroke:#333,stroke-width:2px
    style Attn fill:#e1e1e1,stroke:#333,stroke-dasharray: 5 5
</code></pre>
<h4>2.3.1  LayerNorm에서 RMSNorm으로의 전환</h4>
<p>표준 LayerNorm은 입력의 평균(<span class="math math-inline">\mu</span>)과 분산(<span class="math math-inline">\sigma^2</span>)을 모두 계산하여 정규화(<span class="math math-inline">\frac{x - \mu}{\sigma}</span>)한 후, 학습 가능한 파라미터인 스케일(<span class="math math-inline">\gamma</span>)과 바이어스(<span class="math math-inline">\beta</span>)를 적용한다. 반면, RMSNorm은 평균을 중심화(Re-centering)하는 과정을 생략하고, 오직 제곱평균제곱근(RMS)만을 사용하여 스케일링(Re-scaling)한다.27<br />
<span class="math math-display">
\bar{x}_i = \frac{x_i}{\text{RMS}(x)} \cdot \gamma_i, \quad \text{where } \text{RMS}(x) = \sqrt{\frac{1}{d} \sum_{j=1}^d x_j^2}
</span><br />
RMSNorm의 도입 이유는 명확하다.</p>
<ol>
<li><strong>계산 효율성:</strong> 평균을 계산하고 빼는 연산이 제거되어, LayerNorm 대비 7%에서 최대 64%까지 연산 속도가 향상된다.14 수 조(Trillion) 단위의 토큰을 학습해야 하는 LLM에게 이러한 속도 향상은 막대한 비용 절감을 의미한다.</li>
<li><strong>안정성:</strong> 일부 연구에서는 LayerNorm의 중심화 과정이 특정 노이즈를 증폭시킬 수 있다고 지적한다. RMSNorm은 스케일 불변성(Scale Invariance)만을 유지함으로써 학습의 안정성에 기여한다.</li>
</ol>
<h4>2.3.2  DeepSeek-V3와 LLaMA 3의 아키텍처 분석</h4>
<p>2024년과 2025년을 강타한 DeepSeek-V3와 LLaMA 3는 Pre-Norm 기반의 RMSNorm을 채택하고 있다. 그러나 이들은 단순한 Pre-Norm의 단점을 보완하기 위해 정교한 엔지니어링을 추가했다.</p>
<p>DeepSeek-V3의 다층적 안정화 전략</p>
<p>DeepSeek-V3는 6,710억 파라미터의 초대형 MoE(Mixture-of-Experts) 모델로, 학습 안정성을 위해 극한의 설계를 보여준다.28</p>
<ul>
<li><strong>Pre-RMSNorm + Final Norm:</strong> 기본적으로 각 블록 앞에 RMSNorm을 배치하는 Pre-Norm 구조를 따르지만, 전체 모델의 최종 출력 직전에 다시 한번 RMSNorm을 적용하는 ’Final Norm’을 둔다.30 이는 Pre-Norm 구조의 고질적인 문제인 출력 층의 스케일 불일치와 표현 붕괴의 잔재를 보정하기 위한 필수적인 장치이다.</li>
<li><strong>혼합 정밀도의 섬세한 제어:</strong> DeepSeek-V3는 FP8(8비트 부동소수점) 기반의 학습을 수행하여 메모리와 연산 속도를 혁신했다. 그러나 모든 연산을 FP8로 처리하는 것은 아니다. 수치적 안정성에 민감한 <strong>RMSNorm</strong>과 <strong>Attention</strong> 연산만큼은 반드시 <strong>BF16(Bfloat16)</strong> 또는 <strong>FP32</strong>로 수행한다.29 이는 정규화 층이 전체 네트워크의 수치적 안정성을 지탱하는 ‘닻(Anchor)’ 역할을 하고 있음을 보여준다. 만약 정규화 층까지 저정밀도로 연산할 경우, 언더플로우나 오버플로우로 인해 학습이 즉시 발산할 수 있다.</li>
<li><strong>어텐션 출력의 정밀도:</strong> DeepSeek-V3는 어텐션 직후의 선형 변환(Linear Projection) 입력을 저장할 때 특수한 처리를 하는 등, 정규화 주변의 데이터 흐름을 마이크로 단위로 제어한다.32</li>
</ul>
<p>LLaMA 3의 선택</p>
<p>LLaMA 3 역시 Pre-RMSNorm을 채택했다.13 메타(Meta)의 연구진은 학습의 예측 가능성과 대규모 클러스터에서의 분산 학습 안정성을 최우선 가치로 두었다. Post-Norm이 가질 수 있는 미세한 발산 위험조차 허용하지 않겠다는 의지이다. 또한, LLaMA 3는 RoPE(Rotary Positional Embeddings)와 SwiGLU 활성화 함수를 결합하여 Pre-Norm 구조 내에서도 표현력을 극대화하는 방향으로 진화했다.13</p>
<h3>2.4  미래를 향한 제언: 하이브리드 노름과 그 너머</h3>
<p>Pre-Norm과 Post-Norm의 이분법은 이제 낡은 논쟁이 되어가고 있다. 연구의 최전선에서는 두 방식의 장점을 동적으로 결합하는 <strong>하이브리드(Hybrid)</strong> 기법들이 주목받고 있다.</p>
<ol>
<li>Peri-LN (Peripheral Layer Normalization):</li>
</ol>
<p>최근 연구(2025)에서 제안된 Peri-LN은 하위 층의 입력과 출력 모두에 정규화를 적용하는 방식이다.11<br />
<span class="math math-display">
   x_{l+1} = x_l + \text{LN}(\mathcal{F}(\text{LN}(x_l)))
</span><br />
입력단 정규화는 Pre-Norm처럼 그라디언트 흐름을 안정화하고, 출력단 정규화는 Post-Norm처럼 잔차 가지의 신호 강도를 제어한다. 이는 Pre-Norm에서 발생하는 ‘Massive Activations’(특정 뉴런의 값이 비정상적으로 커지는 현상)를 억제하고, 표현 붕괴를 막는 데 탁월한 효과를 보인다.11</p>
<ol start="2">
<li>HybridNorm:</li>
</ol>
<p>트랜스포머 내부의 구성 요소별로 정규화 민감도가 다르다는 점에 착안한 방식이다. 연구에 따르면 어텐션 층(Attention)은 정규화 방식에 매우 민감한 반면, FFN은 상대적으로 덜하다. HybridNorm은 어텐션 뒤에는 LayerNorm을, FFN 뒤에는 RMSNorm을 사용하는 등의 이종 결합을 통해 13~17%의 속도 향상과 안정성을 동시에 달성했다.35</p>
<ol start="3">
<li>Mix-LN:</li>
</ol>
<p>모델의 층 깊이에 따라 정규화 전략을 달리하는 것이다. 얕은 층(Shallow layers)에는 Post-Norm을 적용하여 그라디언트 흐름을 강하게 유지하고, 깊은 층(Deep layers)에는 Pre-Norm을 적용하여 안정성을 꾀한다.19 이는 모델 전체의 그라디언트 노름을 균일하게 맞추어, 모든 층이 학습에 유의미하게 기여하도록 유도한다.</p>
<ol start="4">
<li>ResiDual:</li>
</ol>
<p>마이크로소프트가 제안한 이 아키텍처는 잔차 연결을 이중화하여, 하나의 경로는 정규화를 거치고 다른 하나는 거치지 않게 설계했다.38 이를 통해 그라디언트 소실과 표현 붕괴를 동시에 해결하며, Post-Norm과 Pre-Norm 모델 모두를 능가하는 성능을 입증했다.</p>
<pre><code class="language-mermaid">mindmap
  root(("정규화 전략의 진화
  (Normalization Evolution)"))
    Post_Norm["Post-Norm"]
      Pros["최적 성능 (Performance)"]
      Cons["학습 불안정 (Instability)"]
      Use["초기 Transformer, BERT"]
    Pre_Norm["Pre-Norm"]
      Pros["학습 안정성 (Stability)"]
      Cons["표현 붕괴 (Representation Collapse)"]
      Use["GPT-3, PaLM, LLaMA"]
    DeepNorm["DeepNorm"]
      Method["가중치 스케일링 (Alpha/Beta)"]
      Result["Post성능 + Pre안정성"]
    Modern_Standard["현대 표준 (RMSNorm)"]
      Speed["연산 속도 향상 (No Mean centering)"]
      DeepSeek["FP8 혼합 정밀도 + Final Norm"]
    Hybrid_Future["미래 하이브리드 (Hybrid)"]
      Peri_LN["Peri-LN (입출력 양방향 정규화)"]
      HybridNorm["Attention=LN, FFN=RMS"]
      ResiDual["이중 잔차 경로 (Dual Residual)"]
</code></pre>
<h3>2.5  결론: 싱귤래리티를 위한 최적의 균형</h3>
<p>정규화 위치의 딜레마는 딥러닝 모델 설계가 단순한 ’블록 쌓기’가 아니라, 신호 전파(Signal Propagation)와 최적화 역학(Optimization Dynamics)을 조율하는 정밀 과학임을 보여준다.</p>
<ul>
<li><strong>Post-Norm</strong>은 이상적인 조건에서 최고의 성능을 약속하지만, 그 조건(완벽한 초기화, 웜업)을 맞추기가 모델이 거대해질수록 불가능에 가까워진다.</li>
<li><strong>Pre-Norm</strong>은 거대 모델 시대를 연 일등 공신이지만, ’표현 붕괴’라는 내재적 한계로 인해 모델의 잠재력을 갉아먹고 있다.</li>
<li><strong>DeepNorm</strong>과 <strong>Peri-LN</strong>, <strong>RMSNorm</strong>은 이 양극단을 잇는 가교로서, 현대 LLM의 표준으로 자리 잡았다.</li>
</ul>
<p>결론적으로, 다가오는 1조 파라미터 이상의 초대형 모델 시대, 즉 ’트랜스포머 싱귤래리티’를 맞이하기 위해서는 단순한 위치 선정을 넘어선 접근이 필요하다. DeepSeek-V3가 보여준 것처럼, 정규화의 위치뿐만 아니라 <strong>연산 정밀도(FP8 vs FP32)</strong>, <strong>초기화 스케일링</strong>, 그리고 <strong>하이브리드 토폴로지</strong>를 아우르는 통합적인 설계만이 학습의 안정성과 지능의 깊이라는 두 마리 토끼를 모두 잡을 수 있는 열쇠가 될 것이다. Pre-Norm의 안정성 위에 Post-Norm의 표현력을 얹는 것, 그것이 바로 깊은 모델 학습의 딜레마를 해결하는 궁극의 지향점이다.</p>
<pre><code class="language-mermaid">quadrantChart
    title "정규화 기법의 성능 vs 안정성 지형도"
    x-axis "학습 안정성 낮음 (Hard to Train)" --&gt; "학습 안정성 높음 (Easy to Train)"
    y-axis "표현력/성능 낮음 (Low Expressivity)" --&gt; "표현력/성능 높음 (High Expressivity)"
    
    quadrant-1 "이상적 영역 (Singularity)"
    quadrant-2 "표현력 중심 (High Risk High Return)"
    quadrant-3 "회피 영역 (Avoid)"
    quadrant-4 "안정성 중심 (Stable but Limited)"
    
    "Post-Norm (Vanilla)": [0.2, 0.9]
    "Pre-Norm (Standard)": [0.9, 0.4]
    "DeepNorm": [0.85, 0.88]
    "RMSNorm (Pre)": [0.92, 0.5]
    "DeepSeek-V3 (Hybrid)": [0.95, 0.95]
    "ResiDual": [0.8, 0.92]
</code></pre>
<h2>3. 참고 자료</h2>
<ol>
<li>12월 21, 2025에 액세스, [https://www.newline.co/@zaoyang/annotated-transformer-layernorm-explained–a0e93a57#:<sub>:text=Pre%2DLN%20applies%20LayerNorm%20before,LayerNorm%20after%20the%20residual%20connection.](https://www.newline.co/@zaoyang/annotated-transformer-layernorm-explained–a0e93a57#:</sub>:text=Pre-LN applies LayerNorm before, <a href="https://www.newline.co/@zaoyang/annotated-transformer-layernorm-explained--a0e93a57#:~:text=Pre-LN%20applies%20LayerNorm%20before,LayerNorm%20after%20the%20residual%20connection.">https://www.newline.co/@zaoyang/annotated-transformer-layernorm-explained–a0e93a57#:~:text=Pre%2DLN%20applies%20LayerNorm%20before,LayerNorm%20after%20the%20residual%20connection.</a></li>
<li>Pre-Norm Residual Connections in Transformers - Emergent Mind, https://www.emergentmind.com/topics/pre-norm-residual-connections-prenorm</li>
<li>Pre-Norm vs Post-Norm: Which to Use? - Newline.co, https://www.newline.co/@zaoyang/pre-norm-vs-post-norm-which-to-use–3ea6df8c</li>
<li>FuseNorm: Achieving the Best of Both Worlds from PreNorm and PostNorm | OpenReview, https://openreview.net/forum?id=azXOzJFwuf</li>
<li>On Layer Normalization in the Transformer Architecture - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v119/xiong20b/xiong20b.pdf</li>
<li>On Layer Normalization in the Transformer Architecture - arXiv, https://arxiv.org/pdf/2002.04745</li>
<li>DeepNet: Scaling Transformers to 1,000 Layers - IEEE Computer Society, https://www.computer.org/csdl/journal/tp/2024/10/10496231/1W28Cl4PeSI</li>
<li>Tutorial #17: Transformers III Training - Research Blog | RBC Borealis, https://rbcborealis.com/research-blogs/tutorial-17-transformers-iii-training/</li>
<li>(2020129) On Layer Normalization in The Transformer Architecture - Scribd, https://www.scribd.com/document/743627142/2020129-on-Layer-Normalization-in-the-Transformer-Architecture</li>
<li>Review — DeepNet: Scaling Transformers to 1,000 Layers | by Sik-Ho Tsang | Medium, https://sh-tsang.medium.com/review-deepnet-scaling-transformers-to-1-000-layers-6a632d4f5633</li>
<li>Peri-LN: Revisiting Layer Normalization in the Transformer Architecture - arXiv, https://arxiv.org/html/2502.02732v1</li>
<li>Why Pre-Norm Became the Default in Transformers | by ashutosh | Nov, 2025 - Medium, https://medium.com/@ashutoshs81127/why-pre-norm-became-the-default-in-transformers-4229047e2620</li>
<li>FareedKhan-dev/Building-llama3-from-scratch: LLaMA 3 is one of the most promising open-source model after Mistral, we will recreate it’s architecture in a simpler manner. - GitHub, https://github.com/FareedKhan-dev/Building-llama3-from-scratch</li>
<li>Pre-RMSNorm and Pre-CRMSNorm Transformers: Equivalent and Efficient Pre-LN Transformers, https://proceedings.neurips.cc/paper_files/paper/2023/file/8f1bacee31caf990a4f08d84f0ccb322-Paper-Conference.pdf</li>
<li>Peri-LN: Revisiting Normalization Layer in the Transformer Architecture - arXiv, https://arxiv.org/html/2502.02732v3</li>
<li>Wavy Transformer - OpenReview, https://openreview.net/pdf?id=ig4gfspaOq</li>
<li>Solving Oversmoothing in GNNs via Nonlocal Message Passing: Algebraic Smoothing and Depth Scalability - arXiv, https://arxiv.org/html/2512.08475v2</li>
<li>Normalization in Attention Dynamics - arXiv, https://arxiv.org/html/2510.22026v1</li>
<li>Mix-LN: Unleashing the Power of Deeper Layers by Combining Pre-LN and Post-LN, https://openreview.net/forum?id=BChpQU64RG</li>
<li>Curse of Depth in Deep Neural Architectures - Emergent Mind, https://www.emergentmind.com/topics/curse-of-depth-cod</li>
<li>[2203.00555] DeepNet: Scaling Transformers to 1,000 Layers - arXiv, https://arxiv.org/abs/2203.00555</li>
<li>DeepNet: Scaling Transformers to 1,000 Layers - IEEE Xplore, https://ieeexplore.ieee.org/iel7/34/10666888/10496231.pdf</li>
<li>DeepNorm - labml.ai, https://nn.labml.ai/normalization/deep_norm/index.html</li>
<li>DeepNet: Scaling Transformers to 1000 Layers - arXiv, https://arxiv.org/pdf/2203.00555</li>
<li>(PDF) DeepNet: Scaling Transformers to 1,000 Layers - ResearchGate, https://www.researchgate.net/publication/379742602_DeepNet_Scaling_Transformers_to_1000_Layers</li>
<li>On Layer Normalizations and Residual Connections in Transformers - OpenReview, https://openreview.net/attachment?id=oDDqFpK5Ru1&amp;name=pdf</li>
<li>LLaMA: Concepts Explained (Summary) | by Anshu Kumar - Medium, https://akgeni.medium.com/llama-concepts-explained-summary-a87f0bd61964</li>
<li>DeepSeek Architecture and The Aha Moment - Infosys, https://www.infosys.com/iki/techcompass/deepseek-architecture-aha-moment.html</li>
<li>DeepSeek-V3 Technical Report - arXiv, https://arxiv.org/pdf/2412.19437</li>
<li>Analyzing DeepSeek-V3 Model Performance - Atlas Cloud Blog, https://www.atlascloud.ai/blog/analyzing-deepseek-v3-model-performance</li>
<li>DeepSeek Explained 4: Multi-Token Prediction | by Shirley Li | Data Science Collective, https://medium.com/data-science-collective/deepseek-explained-4-multi-token-prediction-33f11fe2b868</li>
<li>Four unique takeaways from Deepseek v3 - AWS Builder Center, https://builder.aws.com/content/2rJj1WkztSfYwVfsIibhWxeqMf1/four-unique-takeaways-from-deepseek-v3</li>
<li>MAKING PREDICTION with LLAMA MODEL - 3 - Llama Nuts and Bolts, https://adalkiran.github.io/llama-nuts-and-bolts/16-MAKING-PREDICTION-WITH-LLAMA-MODEL-3/</li>
<li>On Layer Normalization in the Transformer Architecture | Request PDF - ResearchGate, https://www.researchgate.net/publication/339227957_On_Layer_Normalization_in_the_Transformer_Architecture</li>
<li>[R] HybridNorm: Combining Pre-Norm and Post-Norm for More Stable and Effective Transformer Training - Reddit, https://www.reddit.com/r/MachineLearning/comments/1j5l9mk/r_hybridnorm_combining_prenorm_and_postnorm_for/</li>
<li>HybridNorm: Towards Stable and Efficient Transformer Training via Hybrid Normalization - arXiv, https://arxiv.org/html/2503.04598v3</li>
<li>Mix-LN: Unleashing the Power of Deep Layers by Combining Pre-LN and Post-LN - arXiv, https://arxiv.org/html/2412.13795v1</li>
<li>Optimizing Transformers: Microsoft &amp; RUC’s ResiDual Solves Gradient Vanishing and Representation Collapse Issues - Synced Review, https://syncedreview.com/2023/05/03/optimizing-transformers-microsoft-rucs-residual-solves-gradient-vanishing-and-representation-collapse-issues/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>