<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:14.2 Jamba 트랜스포머와 Mamba의 하이브리드 아키텍처</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>14.2 Jamba 트랜스포머와 Mamba의 하이브리드 아키텍처</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>14.2 Jamba 트랜스포머와 Mamba의 하이브리드 아키텍처</span></nav>
                </div>
            </header>
            <article>
                <h1>14.2 Jamba 트랜스포머와 Mamba의 하이브리드 아키텍처</h1>
<p>2025-12-23, G30DR</p>
<p>거대 언어 모델(Large Language Model, LLM)의 발전사는 연산 효율성과 모델 성능(Capacity) 사이의 끊임없는 줄다리기 과정이라 정의할 수 있다. 2017년 구글이 트랜스포머(Transformer) 아키텍처를 발표한 이래, ‘어텐션(Attention)’ 메커니즘은 시퀀스 데이터 처리의 표준으로 자리 잡았다. 그러나 트랜스포머가 가진 태생적인 한계, 즉 입력 시퀀스의 길이(<span class="math math-inline">L</span>)에 따라 연산 복잡도가 <span class="math math-inline">O(L^2)</span>로 증가하고, 추론 시 KV 캐시(Key-Value Cache) 메모리가 선형적으로(<span class="math math-inline">O(L)</span>) 증가한다는 점은 긴 문맥(Long Context)을 처리하는 현대적 애플리케이션의 확장에 중대한 병목으로 작용해왔다.</p>
<p>AI21 Labs가 개발한 <strong>Jamba 아키텍처</strong>는 이러한 트랜스포머의 구조적 비효율성을 타파하고, 차세대 시퀀스 모델링의 핵심 기술로 부상한 상태 공간 모델(State Space Model, SSM)인 <strong>Mamba</strong>를 결합하여 새로운 파레토 최적(Pareto Frontier)을 제시한 하이브리드 모델이다. 본 절에서는 Jamba 아키텍처의 설계 철학, Mamba와 트랜스포머의 상호보완적 결합 방식, 그리고 이를 통해 달성한 압도적인 연산 효율성과 긴 문맥 처리 능력에 대해 심층적으로 분석한다.</p>
<h2>1.  아키텍처 설계 배경: 트랜스포머의 한계와 SSM의 부상</h2>
<p>Jamba의 등장을 이해하기 위해서는 먼저 기존 트랜스포머 아키텍처가 직면한 문제점과 이를 해결하기 위해 등장한 SSM의 특성을 명확히 파악해야 한다.</p>
<h3>1.1  트랜스포머의 메모리 병목과 KV 캐시</h3>
<p>트랜스포머 모델의 핵심인 ’셀프 어텐션(Self-Attention)’은 시퀀스 내의 모든 토큰이 다른 모든 토큰을 참조하는 전역적 상호작용을 수행한다. 이는 모델이 문맥을 깊이 있게 이해하고 복잡한 추론을 수행하는 데 필수적이지만, 추론 단계에서 심각한 메모리 오버헤드를 유발한다. 자기 회귀적(Autoregressive) 생성 과정에서 이전에 계산된 키(Key)와 값(Value) 벡터를 재계산하지 않기 위해 저장해두는 <strong>KV 캐시</strong>는 문맥 길이가 길어질수록 기하급수적으로 커진다.1</p>
<p>예를 들어, Llama-2 70B 모델이 256K 토큰의 문맥을 처리한다고 가정할 때, 필요한 KV 캐시 메모리는 단일 A100 80GB GPU의 용량을 훨씬 초과하여 128GB 이상에 달하게 된다.2 이는 긴 문서를 요약하거나 방대한 데이터베이스를 참조(RAG)해야 하는 엔터프라이즈 환경에서 트랜스포머 모델의 효용성을 급격히 떨어뜨리는 요인이다.</p>
<h3>1.2  Mamba와 선택적 상태 공간(Selective SSM)</h3>
<p>이러한 문제를 해결하기 위해 등장한 Mamba 아키텍처는 순환 신경망(RNN)과 유사하게 이전의 정보를 고정된 크기의 **상태(State)**로 압축하여 전달한다. Mamba는 입력에 따라 상태 공간 모델의 파라미터를 동적으로 변화시키는 <strong>선택적 스캔(Selective Scan)</strong> 메커니즘을 도입하여, 기존 SSM의 약점이었던 정보 선별 능력을 획기적으로 개선했다.3</p>
<p>Mamba의 가장 큰 강점은 추론 시의 연산 복잡도가 시퀀스 길이에 대해 선형적(<span class="math math-inline">O(L)</span>)이며, 메모리 사용량은 시퀀스 길이와 무관하게 상수(<span class="math math-inline">O(1)</span>)라는 점이다. 이는 이론적으로 무한한 길이의 문맥을 유한한 메모리로 처리할 수 있음을 의미한다. 그러나 순수 Mamba 모델은 트랜스포머에 비해 ’연상 기억(Associative Recall)’이나 ‘인컨텍스트 러닝(In-Context Learning)’ 능력이 다소 부족하다는 한계가 지적되어 왔다.5 이는 모든 정보를 고정된 상태 벡터에 압축해 넣어야 하는 구조적 특성상, 문맥 내의 아주 세밀한 정보를 나중에 정확히 꺼내 쓰는 데 어려움이 있기 때문이다.</p>
<h2>2.  Jamba의 하이브리드 아키텍처 상세 분석</h2>
<p>Jamba는 트랜스포머의 ’품질’과 Mamba의 ’효율성’이라는 두 마리 토끼를 잡기 위해 고안된 <strong>SSM-Transformer 하이브리드 아키텍처</strong>이다. 단순히 두 모델을 앙상블하는 것이 아니라, 단일 모델 내에서 레이어 단위로 두 아키텍처를 교차 배치(Interleaving)하는 정교한 설계를 채택했다.</p>
<h3>2.1  Jamba 블록(Block)과 레이어 구성 비율</h3>
<p>Jamba 아키텍처의 기본 단위는 <strong>Jamba 블록</strong>이다. 이 블록은 다수의 Mamba 레이어와 소수의 트랜스포머 어텐션 레이어로 구성되며, 각 레이어 뒤에는 MLP(Multi-Layer Perceptron) 또는 전문가 혼합(MoE) 모듈이 결합된다.7</p>
<p>Jamba 설계의 핵심은 어텐션 레이어와 Mamba 레이어의 비율(<span class="math math-inline">a:m</span>)이다. AI21 Labs의 연구진은 광범위한 소거법 연구(Ablation Study)를 통해 <strong>1:7의 비율</strong>을 최적의 구성으로 도출했다.8 즉, 8개의 레이어마다 1개의 트랜스포머 어텐션 레이어와 7개의 Mamba 레이어가 배치된다.</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>비율/수치</strong></th><th><strong>설계 의도 및 효과</strong></th></tr></thead><tbody>
<tr><td><strong>Attention:Mamba 비율</strong></td><td><strong>1 : 7</strong></td><td>트랜스포머 대비 KV 캐시 메모리 1/8로 절감, 처리량(Throughput) 극대화</td></tr>
<tr><td><strong>MoE 적용 빈도</strong></td><td><strong>매 2번째 레이어</strong></td><td>활성 파라미터 수 유지하며 모델 용량(Capacity) 확장</td></tr>
<tr><td><strong>레이어당 전문가 수</strong></td><td><strong>16개</strong></td><td>전문화된 지식 분산 저장</td></tr>
<tr><td><strong>토큰당 활성 전문가</strong></td><td><strong>Top-2</strong></td><td>추론 연산 비용 최소화 및 응답 속도 최적화</td></tr>
</tbody></table>
<p>이 비율은 트랜스포머 레이어가 전체의 12.5%에 불과하다는 것을 의미한다. 이는 모델이 처리해야 할 KV 캐시의 양을 획기적으로 줄여주며, 결과적으로 256K 토큰이라는 초장문 문맥을 처리할 때도 단일 80GB GPU 메모리에 모델과 문맥을 모두 적재할 수 있게 한다.10</p>
<h3>2.2  레이어 교차 배치(Interleaving) 전략과 정보 흐름</h3>
<p>Jamba의 레이어 배치는 무작위가 아니며, 정보의 효율적 압축과 회상(Recall)을 위해 전략적으로 구성된다. 일반적으로 <strong>Mamba 레이어들이 연속적으로 배치되어 정보를 효율적으로 처리하고 압축</strong>하다가, 주기적으로 <strong>어텐션 레이어가 등장하여 전체 문맥을 동기화</strong>하는 구조를 띤다.8</p>
<ol>
<li><strong>초기 정보 압축 (Mamba Layers):</strong> 입력된 토큰들은 먼저 연속된 Mamba 레이어를 통과한다. 이 과정에서 각 토큰의 정보는 SSM의 히든 스테이트로 변환되며, 문맥의 흐름에 따라 중요 정보가 선별적으로 필터링되고 압축된다. 이 단계는 연산 비용이 매우 낮아 빠른 처리가 가능하다.</li>
<li><strong>전역적 문맥 참조 (Attention Layer):</strong> 7개의 Mamba 레이어를 지나면 1개의 어텐션 레이어가 배치된다. 이 레이어는 압축된 상태 정보에만 의존하는 Mamba의 한계를 보완한다. 어텐션 메커니즘은 KV 캐시에 저장된(비록 1/8로 줄어들었지만) 이전의 핵심 토큰들을 직접 조회(Lookup)하여, Mamba 레이어가 놓쳤거나 희석된 세부 정보를 복원하고 문맥 간의 장거리 의존성(Long-range Dependency)을 강화한다.9</li>
<li><strong>반복적 정제:</strong> 이러한 블록이 반복됨으로써, Jamba는 긴 시퀀스를 처리하는 동안 낮은 메모리 점유율을 유지하면서도 주기적으로 정보의 정확성을 점검하는 ‘체크포인트’ 효과를 얻는다.</li>
</ol>
<p>연구 결과에 따르면, Mamba-1 레이어와 어텐션의 결합이 최신 Mamba-2와 어텐션의 결합보다 하이브리드 구조에서 더 나은 성능을 보이는 것으로 나타났다.10 이는 Mamba-2가 이론적으로는 더 효율적일지라도, 어텐션 레이어와의 상호작용 측면에서는 Mamba-1의 상태 공간 특성이 더 유리하게 작용함을 시사한다.</p>
<h3>2.3  전문가 혼합(Mixture-of-Experts, MoE) 모듈의 통합</h3>
<p>Jamba는 하이브리드 레이어 구조에 **MoE(Mixture-of-Experts)**를 결합하여 모델의 용량(Capacity)을 극대화했다. MoE는 모델의 전체 파라미터를 키우면서도, 실제 추론 시에는 그중 일부만 사용하여 연산 비용을 통제하는 기술이다.</p>
<ul>
<li><strong>구조:</strong> Jamba의 MoE는 매 2번째 레이어(Every other layer)마다 MLP(Feed-Forward Network)를 대체하여 적용된다.2 각 MoE 레이어는 16개의 전문가(Expert) 네트워크로 구성된다.</li>
<li><strong>라우팅(Routing):</strong> 입력된 각 토큰에 대해 라우터(Router)가 상위 2개(Top-2)의 가장 적합한 전문가를 선택하여 활성화한다. 이는 각 토큰이 전체 파라미터의 극히 일부만을 거치게 됨을 의미한다.</li>
<li><strong>파라미터 효율성:</strong> Jamba 1.5 Large 모델의 경우, 총 파라미터 수는 398B(3980억 개)에 달하지만, 추론 시 활성화되는 파라미터(Active Parameters)는 94B에 불과하다.11 이는 동급의 밀집(Dense) 모델인 Llama 3.1 405B와 비교했을 때, 훨씬 적은 연산 자원으로도 대등하거나 우수한 성능을 낼 수 있는 기반이 된다. Mini 모델의 경우 52B 총 파라미터 중 12B만이 활성화된다.</li>
</ul>
<p>특히 Jamba 1.5는 <strong>ExpertsInt8</strong>이라는 독자적인 양자화 기술을 도입하였다.10 MoE 모델은 활성 파라미터 수는 적지만 전체 파라미터를 메모리에 적재해야 하므로 메모리 대역폭이 병목이 될 수 있다. ExpertsInt8은 MoE의 가중치를 8비트로 양자화하여 메모리 사용량을 줄이고 데이터 전송 속도를 높임으로써, A100과 같은 기존 하드웨어에서도 높은 처리량(Throughput)을 유지할 수 있게 한다.</p>
<h2>3.  성능 및 효율성 심층 평가</h2>
<p>Jamba 아키텍처의 우수성은 실제 벤치마크와 효율성 지표를 통해 명확히 드러난다. 특히 긴 문맥 처리와 관련된 지표에서 기존 트랜스포머 모델들을 압도하는 결과를 보여준다.</p>
<h3>3.1  처리량(Throughput) 및 지연 시간(Latency) 비교</h3>
<p>하이브리드 구조 덕분에 Jamba는 긴 문맥에서의 생성 속도가 매우 빠르다. 128K 이상의 문맥 길이에서 Jamba는 Mixtral 8x7B 대비 약 3배 높은 처리량을 기록했다.2</p>
<ul>
<li><strong>Jamba 1.5 Large vs Llama 3.1 70B:</strong> 벤치마크 결과에 따르면, Jamba 1.5 Large는 긴 문맥 입력 시 Llama 3.1 70B보다 우수한 지연 시간 특성을 보인다. 특히 입력 길이가 100K 토큰을 넘어가는 구간에서 트랜스포머 모델들은 <span class="math math-inline">O(L^2)</span> 복잡도로 인해 속도가 급격히 저하되는 반면, Jamba는 선형적인 속도 유지가 가능하다.10</li>
<li><strong>토큰 생성 속도:</strong> 262,144 토큰(256K)이라는 극한의 입력 조건에서 Jamba 1.5 Mini는 초당 약 62 토큰을 생성한 반면, Llama 3.1 8B는 41 토큰, Mixtral은 39 토큰에 그쳤다.15 이는 Jamba가 긴 문서를 실시간으로 분석하고 요약해야 하는 서비스에 최적화되어 있음을 증명한다.</li>
</ul>
<h3>3.2  유효 문맥 길이(Effective Context Window)와 RULER 벤치마크</h3>
<p>많은 모델이 긴 문맥 윈도우(예: 128K, 200K)를 지원한다고 주장하지만, 실제로는 문맥 중간의 정보를 망각하는 ‘Lost-in-the-Middle’ 현상을 겪는다. 그러나 Jamba 1.5는 <strong>RULER 벤치마크</strong>에서 256K 토큰 길이에 이르기까지 정보 손실 없이 높은 정확도를 유지하는 것으로 확인되었다.11 이는 어텐션 레이어가 주기적으로 배치되어 Mamba의 상태 압축 손실을 보정해주는 하이브리드 아키텍처의 설계 의도가 적중했음을 보여준다.</p>
<h3>3.3  연상 기억(Associative Recall) 문제의 해결</h3>
<p>순수 SSM 모델들이 겪는 가장 큰 난제인 ‘연상 기억’ 문제, 즉 문맥 내의 특정 정보를 그대로 복사(Copy)하거나 인출하는 능력이 Jamba에서는 트랜스포머 수준으로 개선되었다.</p>
<ul>
<li><strong>문제의 본질:</strong> SSM은 고정된 상태 벡터에 정보를 압축하므로, “전화번호부에서 특정 이름의 전화번호 찾기“와 같은 태스크에서 정보가 소실될 가능성이 높다. 연구에 따르면 순수 Mamba 모델은 트랜스포머에 비해 이러한 복사 태스크(Copying Task) 학습에 100배 이상의 데이터가 필요하거나 일반화 성능이 떨어진다.16</li>
<li><strong>Jamba의 해결책:</strong> Jamba에 삽입된 트랜스포머 레이어는 ’유도 헤드(Induction Heads)’와 유사한 역할을 수행한다.17 이 레이어들은 문맥 전체를 조망하며 이전에 등장했던 패턴을 정확히 찾아내어 현재의 생성 단계로 가져오는 역할을 한다. 이를 통해 Jamba는 SSM의 효율성을 유지하면서도, 트랜스포머 특유의 강력한 인컨텍스트 러닝(In-Context Learning) 및 정보 회수 능력을 확보하였다.5</li>
</ul>
<h2>4.  결론 및 시사점</h2>
<p>14.2절에서 분석한 Jamba 아키텍처는 **“1:7의 Mamba-Transformer 비율”**과 **“MoE”**의 결합을 통해, 현대 LLM이 직면한 메모리 장벽과 연산 비용 문제를 해결하는 가장 진보된 해답 중 하나를 제시한다.</p>
<ol>
<li><strong>하이브리드 아키텍처의 표준화 가능성:</strong> Jamba는 Mamba와 트랜스포머가 상호 배타적인 경쟁 관계가 아니라, 상호 보완적인 관계임을 증명했다. Mamba는 ’압축’을 통해 뼈대를 세우고, 트랜스포머는 ’참조’를 통해 살을 붙이는 방식은 향후 초거대 모델 설계의 새로운 표준이 될 가능성이 높다.</li>
<li><strong>엔터프라이즈 AI의 실용성 증대:</strong> 256K에 달하는 문맥을 단일 GPU에서 처리할 수 있다는 점은 기업들이 값비싼 클러스터를 구축하지 않고도 긴 문서 분석, 복잡한 RAG 시스템, 장기간의 대화 기억 등의 고부가가치 AI 서비스를 구축할 수 있게 해준다. 이는 AI 기술의 민주화와 실질적인 산업 적용을 가속화하는 핵심 동력이 될 것이다.</li>
<li><strong>포스트 트랜스포머(Post-Transformer) 시대로의 도약:</strong> Jamba의 성공은 트랜스포머 일변도였던 LLM 연구가 다양한 아키텍처를 융합하는 방향으로 진화하고 있음을 시사한다. 특히 Jamba 1.5에서 보여준 파라미터 확장성(Scalability)은 하이브리드 모델이 단순히 틈새시장을 위한 경량화 모델이 아니라, 최상위 성능을 지향하는 파운데이션 모델(Foundation Model)로 자리 잡을 수 있음을 강력하게 시사한다.</li>
</ol>
<p>결론적으로 Jamba는 트랜스포머의 정확도와 Mamba의 효율성, 그리고 MoE의 확장성을 하나의 아키텍처 안에 성공적으로 융합함으로써, 거대 언어 모델의 아키텍처가 나아가야 할 새로운 방향을 제시한 이정표적인 모델이라 평가할 수 있다.</p>
<h2>5. 참고 자료</h2>
<ol>
<li>Build Long-Context AI Apps with Jamba - DeepLearning.AI - Learning Platform, https://learn.deeplearning.ai/courses/build-long-context-ai-apps-with-jamba/lesson/tfntk/transformer-mamba-hybrid-llm-architecture</li>
<li>Jamba: A Hybrid Transformer-Mamba Language Model with Mixture-of-Experts - Medium, https://medium.com/@sulbha.jindal/jamba-a-hybrid-transformer-mamba-language-model-with-mixture-of-experts-506281f2398e</li>
<li>What Is A Mamba Model? | IBM, https://www.ibm.com/think/topics/mamba-model</li>
<li>Mamba Selective SSM Architecture, https://www.emergentmind.com/topics/mamba-selective-state-space-architecture</li>
<li>An Empirical Study of Mamba-based Language Models : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/1devfmr/an_empirical_study_of_mambabased_language_models/</li>
<li>Revisiting associative recall in modern recurrent models - arXiv, https://arxiv.org/html/2508.19029v2</li>
<li>[2403.19887] Jamba: A Hybrid Transformer-Mamba Language Model - arXiv, https://arxiv.org/abs/2403.19887</li>
<li>Jamba: A Hybrid Transformer-Mamba Language Model - arXiv, https://arxiv.org/html/2403.19887v1</li>
<li>Architectural Evolution in Large Language Models: A Deep Dive into Jamba’s Hybrid Transformer-Mamba Design - Greg Robison, https://gregrobison.medium.com/architectural-evolution-in-large-language-models-a-deep-dive-into-jambas-hybrid-transformer-mamba-c3efa8ca8cae</li>
<li>Jamba-1.5: Hybrid Transformer-Mamba Models at Scale - arXiv, https://arxiv.org/html/2408.12570v1</li>
<li>Jamba-1.5: Hybrid Transformer-Mamba Models at Scale - arXiv, https://arxiv.org/pdf/2408.12570</li>
<li>Mamba-MLP-Transformer Architecture - Emergent Mind, https://www.emergentmind.com/topics/mamba-mlp-transformer-architecture</li>
<li>Jamba 1.5: Featuring the Hybrid Mamba-Transformer Architecture - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2024/11/jamba-1-5/</li>
<li>Decoding Jamba Research Paper: Simplified Insights into AI21Lab’s Groundbreaking Language Model | by Vinod Kumar G R | Medium, https://medium.com/@vinodkumargr/decoding-jamba-research-paper-simplified-insights-into-ai21labs-groundbreaking-language-model-74604e478b7d</li>
<li>AI21 Labs’ Jamba 1.5 Outpaces Transformers in Long-Text Processing - DeepLearning.AI, https://www.deeplearning.ai/the-batch/ai21-labs-jamba-1-5-outpaces-transformers-in-long-text-processing/</li>
<li>Repeat After Me: Transformers are Better than State Space Models at Copying, https://kempnerinstitute.harvard.edu/research/deeper-learning/repeat-after-me-transformers-are-better-than-state-space-models-at-copying/</li>
<li>How does Mamba Perform Associative Recall? A Mechanistic Study - OpenReview, https://openreview.net/pdf/e87ef54e80534fd6ef7c31181ee38c430db2cb7d.pdf</li>
<li>Hymba: A Hybrid-head Architecture for Small Language Models - Jan Kautz, https://www.jankautz.com/publications/Hymba_ICLR25.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>