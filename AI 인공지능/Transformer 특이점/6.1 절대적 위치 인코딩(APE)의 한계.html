<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:6.1 절대적 위치 인코딩(APE)의 한계</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>6.1 절대적 위치 인코딩(APE)의 한계</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>6.1 절대적 위치 인코딩(APE)의 한계</span></nav>
                </div>
            </header>
            <article>
                <h1>6.1 절대적 위치 인코딩(APE)의 한계</h1>
<p>2025-12-20, G30DR</p>
<p>트랜스포머(Transformer) 아키텍처가 2017년 “Attention Is All You Need“라는 논문을 통해 세상에 등장했을 때, 그것은 순환 신경망(RNN)이 지배하던 시퀀스 모델링의 패러다임을 송두리째 뒤바꾸었다.1 병렬 처리를 통한 압도적인 연산 효율성과 장거리 의존성(Long-range dependency) 학습 능력은 혁명적이었으나, 이 아키텍처에는 태생적인 결함이 하나 존재했다. 바로 순서 정보의 부재, 즉 ’순열 불변성(Permutation Invariance)’이었다.3 이를 해결하기 위해 바스wani(Vaswani) 등은 입력 임베딩에 위치 정보를 더하는 <strong>절대적 위치 인코딩(Absolute Positional Encoding, APE)</strong> 방식을 도입했다. 초기에는 이 방식이 사인파(Sinusoidal) 함수를 통한 우아한 수학적 해법으로 여겨졌으나, 모델이 거대해지고(LLM) 처리해야 할 컨텍스트가 인간의 책 한 권 분량을 넘어서는 ’특이점(Singularity)’에 도달하자, APE는 모델의 확장을 가로막는 결정적인 병목임이 드러났다.5</p>
<p>본 장에서는 초기 트랜스포머의 표준이었던 절대적 위치 인코딩이 왜 현대의 거대 언어 모델과 멀티모달 아키텍처에서 실패할 수밖에 없는지, 그 구조적, 수학적, 경험적 한계를 심층적으로 해부한다. 우리는 길이 외삽(Length Extrapolation)의 붕괴, 이동 불변성(Translation Invariance)의 결여, 정보의 얽힘(Entanglement)으로 인한 표현력 저하, 그리고 데이터 효율성(Data Efficiency)의 손실이라는 네 가지 핵심 축을 중심으로 논의를 전개할 것이다. 이는 단순한 기술적 결함의 나열이 아니라, 인공지능이 인간의 언어와 시공간적 맥락을 이해하는 데 있어 ’절대 좌표’라는 개념이 얼마나 부자연스럽고 비효율적인 접근인지를 증명하는 과정이다.</p>
<pre><code class="language-mermaid">mindmap
  root(("APE의 한계"))
    ["길이 외삽(Length Extrapolation) 붕괴"]
      ["훈련 길이 초과 시 성능 하락"]
      ["보이지 않는 위치(Unseen Positions)의 정의 불가"]
      ["사인파(Sinusoidal)의 주파수 과적합"]
      ["위치 앨리어싱(Aliasing)"]
    ["이동 불변성(Translation Invariance) 결여"]
      ["절대 좌표의 경직성"]
      ["위치별 패턴 중복 학습 필요"]
      ["이미지 패치(ViT)의 공간 구조 훼손"]
      ["시계열 데이터의 시간 이동 적응 실패"]
    ["정보의 얽힘(Entanglement)"]
      ["단순 합산(Summation)으로 인한 의미 희석"]
      ["깊은 층(Deep Layers)에서의 위치 정보 소실"]
      ["위치와 내용의 상호작용 분리 불가"]
    ["데이터 효율성 저하"]
      ["위치 과적합(Position Overfitting)"]
      ["특정 위치의 피상적 상관관계 암기"]
      ["마스킹된 언어 모델(MLM) 학습 효율 저하"]
</code></pre>
<h2>1.  길이 외삽(Length Extrapolation)의 붕괴와 일반화의 한계</h2>
<p>절대적 위치 인코딩의 가장 치명적이고 즉각적인 한계는 <strong>길이 외삽(Length Extrapolation)</strong> 능력의 부재다. 길이 외삽이란 모델이 훈련 단계에서 경험한 최대 시퀀스 길이(Context Window)보다 더 긴 시퀀스가 추론 단계에서 주어졌을 때, 이를 적절히 처리하고 문맥을 이해하는 능력을 의미한다.5 APE를 사용하는 트랜스포머는 훈련된 길이의 경계선(Boundary)을 넘는 순간, 성능이 급격히 하락하거나(perplexities explode) 아예 작동 불능 상태에 빠지는 현상을 보인다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "훈련 단계 (Training Phase)"
        T1["입력 시퀀스 길이: 0 ~ 1024"] --&gt; T2["위치 임베딩 테이블 학습&lt;br/&gt;(P_0 ... P_1023)"]
        T2 --&gt; T3["패턴 및 위상(Phase) 최적화"]
    end

    subgraph "추론 단계 (Inference Phase)"
        I1["입력 시퀀스 길이: 1025"] --&gt; I2{"위치 인덱스 1024 조회"}
        I2 -- "학습 가능한 APE" --&gt; I3["정의되지 않음(Undefined) 혹은&lt;br/&gt;업데이트 안 된 랜덤 벡터"]
        I2 -- "사인파 APE" --&gt; I4["값은 생성 가능하나&lt;br/&gt;모델이 해석 불가"]
        
        I3 --&gt; F1["노이즈 주입"]
        I4 --&gt; F2["주파수/위상 불일치(OOD)"]
        
        F1 --&gt; F3["Attention Score 붕괴"]
        F2 --&gt; F3
        F3 --&gt; Result["성능이 무작위 추측(Random Guessing) 수준으로 급락"]
    end
</code></pre>
<h3>1.1  훈련되지 않은 위치 임베딩의 공백 (The Void of Unseen Positions)</h3>
<p>학습 가능한 절대적 위치 인코딩(Learnable APE)을 사용하는 경우, 이 문제는 직관적인 ’정의되지 않음(Undefined)’의 문제로 귀결된다. 예를 들어, BERT나 GPT-2와 같은 모델이 최대 길이 <span class="math math-inline">L_{train} = 1024</span> 토큰까지의 문장으로만 학습되었다고 가정해보자. 이 모델은 위치 인덱스 <span class="math math-inline">0, 1,..., 1023</span>에 해당하는 위치 임베딩 벡터 <span class="math math-inline">P_0, P_1,..., P_{1023}</span>을 룩업 테이블(Lookup Table) 형태로 학습한다.</p>
<p>추론 시점에 길이가 1025인 문장이 입력될 경우, 모델은 <span class="math math-inline">P_{1024}</span>라는 벡터를 참조해야 한다. 그러나 <span class="math math-inline">P_{1024}</span>는 학습 과정에서 단 한 번도 역전파(Backpropagation)를 통해 업데이트되지 않은, 초기화 상태 그대로의 무작위 벡터이거나 아예 테이블에 존재하지 않는 값이다.5 모델은 이 ’보이지 않는 위치(Unseen Positions)’에 대해 어떠한 유의미한 정보도 가지고 있지 않다. 이는 단순히 마지막 토큰 하나를 처리하지 못하는 문제를 넘어선다. 셀프 어텐션(Self-Attention) 메커니즘은 시퀀스 내 모든 토큰 간의 상호작용(<span class="math math-inline">O(N^2)</span>)을 계산하므로, 하나의 정의되지 않은 위치 임베딩이 전체 쿼리(Query)-키(Key) 내적 연산에 치명적인 노이즈를 주입하게 된다.</p>
<p>연구 결과에 따르면, APE를 탑재한 대형 언어 모델(LLM)들은 훈련된 길이보다 아주 조금만 더 긴 시퀀스가 주어져도 성능이 무작위 추측(Random Guessing) 수준으로 전락하는 것으로 확인되었다.6 이는 법률 문서, 과학 논문, 소설 등 긴 문맥의 일관성을 유지해야 하는 작업에서 APE 기반 모델의 활용을 원천적으로 차단하는 장벽이 된다.</p>
<h3>1.2  사인파(Sinusoidal) 인코딩의 주파수 분석과 실패 원인</h3>
<p>바스wani 등이 제안한 사인파형 APE(Sinusoidal APE)는 학습 파라미터가 없는 고정된 함수를 사용하므로, 이론적으로는 <span class="math math-inline">L_{train}</span>을 초과하는 위치 <span class="math math-inline">i</span>에 대해서도 <span class="math math-inline">PE_i</span>를 생성할 수 있다.<br />
<span class="math math-display">
PE_{(pos, 2i)} = \sin\left(\frac{pos}{10000^{2i/d_{model}}}\right)
</span></p>
<p><span class="math math-display">
PE_{(pos, 2i+1)} = \cos\left(\frac{pos}{10000^{2i/d_{model}}}\right)
</span></p>
<p>원저자들은 이 방식이 “모델이 훈련 중에 보지 못한 더 긴 시퀀스 길이에 대해서도 외삽할 수 있게 해줄 것“이라고 가설을 세웠다.5 그러나 이후 수년간의 검증과 실험 결과, 사인파 APE 역시 길이 외삽에 처참하게 실패한다는 사실이 밝혀졌다.5 함수값 자체는 생성할 수 있지만, 모델이 그 값을 ’해석’하지 못하기 때문이다. 이 현상은 주파수 영역(Frequency Domain) 분석을 통해 명확히 설명된다.</p>
<ol>
<li><strong>고주파 성분의 과적합과 위상 불일치 (Phase Mismatch):</strong> 사인파 인코딩의 하위 차원(low dimensions)은 매우 높은 주파수를 가지며 빠르게 진동한다. 반면 상위 차원은 파장이 매우 길다. 신경망은 훈련 데이터의 길이에 맞춰 특정 주파수 패턴과 위상(Phase)의 조합에 과적합(Overfitting)된다. 훈련 범위를 벗어난 위치에서는 이러한 주파수 패턴의 위상이 모델이 학습한 ’유효한 조합’의 매니폴드(Manifold)를 벗어나거나, 훈련 데이터 내에서 전혀 관찰되지 않았던 새로운 위상 관계를 형성한다. 신경망 입장에서 이는 분포 외(Out-of-Distribution, OOD) 데이터로 인식된다.5</li>
<li><strong>주기성(Periodicity)과 위치 앨리어싱(Positional Aliasing):</strong> 사인파 함수는 본질적으로 주기적이다. 시퀀스 길이가 극도로 길어지면, 서로 다른 위치 <span class="math math-inline">pos_A</span>와 <span class="math math-inline">pos_B</span>가 유사한 임베딩 벡터를 가지게 되는 ‘위치 앨리어싱’ 현상이 발생할 수 있다.8 이는 모델이 먼 거리에 있는 토큰을 가까이 있는 토큰으로 오인하거나, 위치 정보를 모호하게 받아들이게 만든다. 훈련 중에 경험하지 못한 먼 거리의 주기가 반복될 때, 모델은 이를 새로운 위치가 아닌 과거의 특정 위치로 잘못 매핑할 위험이 있다.</li>
<li><strong>주의집중의 거리 기반 감쇠 부재 (Lack of Monotonic Decay):</strong> 인간의 인지 과정이나 언어의 통사적 특성상, 거리가 멀어질수록 정보의 연관성은 일반적으로 감소해야 한다(Locality Bias). 그러나 APE는 위치 벡터 간의 내적(Dot Product)이 거리에 따라 단조 감소(Monotonically Decreasing)하도록 강제하지 않는다.9 <span class="math math-inline">PE_i \cdot PE_j</span>의 값은 <span class="math math-inline">i</span>와 <span class="math math-inline">j</span>의 차이에 따라 진동(Oscillate)할 뿐, 거리가 멀다고 해서 0으로 수렴하지 않는다. 이로 인해 모델은 훈련되지 않은 먼 거리의 토큰에 대해 예측 불가능한 높은 어텐션 점수(Attention Score)를 부여할 수 있다. 이는 긴 시퀀스 추론 시, 먼 거리의 무관한 토큰이 현재 토큰의 맥락을 덮어버리는 ’주의집중 산만(Attention Distraction)’을 야기하여 생성 품질을 떨어뜨린다.11</li>
</ol>
<h3>1.3  산술 연산 및 알고리즘 태스크에서의 논리적 붕괴</h3>
<p>길이 외삽의 실패는 자연어 처리를 넘어, 논리적 추론 능력을 검증하는 산술 연산(Arithmetic) 태스크에서 더욱 극명하게 드러난다. 덧셈이나 곱셈과 같은 알고리즘 태스크에서, 트랜스포머는 짧은 숫자로 훈련받은 후 더 긴 숫자의 연산을 수행하지 못하는 경우가 빈번하다.7 연구에 따르면, APE를 사용하는 표준 트랜스포머는 훈련 길이의 2.5배만 되어도 단순 덧셈 연산에 실패한다.</p>
<p>이는 APE 모델이 숫자의 자릿수(상대적 위치, 예: 일의 자리, 십의 자리)를 이해하는 것이 아니라, 절대적인 위치 인덱스(예: “입력 시퀀스의 5번째 토큰은 항상 100의 자리 숫자다”)를 암기해버리기 때문이다.7 입력 시퀀스의 길이가 변하거나 숫자의 위치가 밀리게 되면(Shift), APE에 의존하여 학습된 모델은 이러한 시프트에 적응하지 못한 채 엉뚱한 자릿수끼리 연산을 수행하게 된다. 반면, ALiBi나 상대적 위치 인코딩(RPE)과 같은 기법은 상대적인 거리를 학습하므로 이러한 문제에서 훨씬 자유롭다.12 APE의 이러한 특성은 모델이 진정한 의미의 ’알고리즘’이나 ’규칙’을 학습하는 것을 방해하고, 얕은 수준의 ’위치 매핑 암기’에 머무르게 하는 주요 원인이 된다. 이는 트랜스포머가 범용 추론 기계(General Purpose Reasoning Machine)로 진화하는 데 있어 APE가 부적절함을 시사한다.</p>
<h2>2.  이동 불변성(Translation Invariance)의 결여와 데이터 비효율성</h2>
<p>자연어, 이미지, 그리고 시계열 데이터가 공유하는 핵심적인 기하학적 특징 중 하나는 <strong>이동 불변성(Translation Invariance)</strong> 또는 **이동 등가성(Translation Equivariance)**이다. “고양이가 매트 위에 앉아 있다“라는 문장은 문단의 처음에 나오든, 중간에 나오든, 끝에 나오든 그 의미적 결합과 구문론적 구조가 동일해야 한다. 그러나 절대적 위치 인코딩은 이 본질적인 원칙을 위배한다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "Case A: 문장 시작 부분"
        PosA["위치 인덱스:&lt;br&gt;0"]
        TokenA["토큰:&lt;br&gt;'Cat' (x)"]
        VecA["APE 벡터:&lt;br&gt;P_0"]
        SumA["최종 입력&lt;br&gt;A = x + P_0"]
    end

    subgraph "Case B: 5칸 밀린 위치 (Shifted)"
        PosB["위치 인덱스:&lt;br&gt;5"]
        TokenB["토큰:&lt;br&gt;'Cat' (x)"]
        VecB["APE 벡터:&lt;br&gt;P_5"]
        SumB["최종 입력&lt;br&gt;B = x + P_5"]
    end

    SumA -- "동일한 단어이나&lt;br/&gt;벡터 값이 다름" --&gt; Comp{"모델의&lt;br&gt;인식"}
    SumB --&gt; Comp
    
    Comp --&gt; Result1["별개의&lt;br&gt;패턴으로&lt;br&gt;인식"]
    Result1 --&gt; Result2["중복 학습 필요&lt;br&gt;(데이터 비효율성)"]
    Result2 --&gt; Result3["이동 불변성&lt;br&gt;(Translation Invariance)&lt;br&gt;실패"]
</code></pre>
<h3>2.1  절대 좌표계의 경직성 (Rigidity of Absolute Coordinates)</h3>
<p>APE는 각 토큰에 고유한 절대 좌표를 부여한다. 위치 <span class="math math-inline">pos</span>의 토큰 <span class="math math-inline">x</span>는 입력 단계에서 <span class="math math-inline">x + PE_{pos}</span>로 표현된다. 만약 전체 문장이 5칸 뒤로 밀려서 입력된다면, 동일한 토큰 <span class="math math-inline">x</span>는 이제 <span class="math math-inline">x + PE_{pos+5}</span>라는 전혀 다른 벡터로 표현된다.5 트랜스포머 모델의 셀프 어텐션 메커니즘은 입력 벡터의 수치에 극도로 민감하게 반응하므로, 입력 벡터가 달라지면 출력 결과와 어텐션 패턴도 달라질 수밖에 없다.</p>
<p>즉, APE를 사용하는 트랜스포머는 위치 <span class="math math-inline">i</span>에서 발생한 패턴(예: 주어-동사 관계)과 위치 <span class="math math-inline">i+k</span>에서 발생한 동일한 패턴을 서로 다른 현상으로 인식한다. 모델은 이 두 가지 경우를 각각 별도로 학습해야만 한다. 이는 컨볼루션 신경망(CNN)이 ’가중치 공유(Weight Sharing)’와 ’슬라이딩 윈도우(Sliding Window)’를 통해 이미지의 어느 위치에서든 동일한 필터로 특징을 추출할 수 있는 것과 대조적이다.14 CNN은 본질적으로 이동 불변성을 내재하고 있어 데이터 효율성이 높지만, APE 트랜스포머는 위치별로 동일한 패턴을 중복 학습해야 하므로 모델의 학습 데이터 요구량을 불필요하게 증가시킨다.5 모델은 “주어가 문장 앞에 올 때“의 문법과 “주어가 문장 중간에 올 때“의 문법을 마치 다른 규칙인 것처럼 학습해야 하는 비효율성에 직면한다.</p>
<h3>2.2  어텐션 매트릭스에서의 수학적 증명</h3>
<p>수학적으로, 쿼리(Query) <span class="math math-inline">q_i</span>와 키(Key) <span class="math math-inline">k_j</span> 사이의 어텐션 점수(Score)는 다음과 같이 분해될 수 있다 (바이어스 항 및 스케일링 팩터 생략):<br />
<span class="math math-display">
\text{Attention}(i, j) \propto (W_Q(x_i + p_i))^T (W_K(x_j + p_j))
</span><br />
이를 전개하면 다음과 같은 네 개의 항이 도출된다:<br />
<span class="math math-display">
= \underbrace{x_i^T W_Q^T W_K x_j}_{\text{Content-Content}} + \underbrace{x_i^T W_Q^T W_K p_j}_{\text{Content-Pos}} + \underbrace{p_i^T W_Q^T W_K x_j}_{\text{Pos-Content}} + \underbrace{p_i^T W_Q^T W_K p_j}_{\text{Pos-Pos}}
</span><br />
여기서 네 번째 항인 <span class="math math-inline">p_i^T W_Q^T W_K p_j</span>는 순수하게 위치 정보 간의 상호작용을 나타낸다. 이상적인 이동 불변성을 위해서는 이 항이 오직 두 토큰 사이의 상대적 거리 <span class="math math-inline">i-j</span>에만 의존하는 함수(<span class="math math-inline">f(i-j)</span>)여야 한다.</p>
<p>그러나 APE의 경우, <span class="math math-inline">p_i</span>와 <span class="math math-inline">p_j</span>는 절대 위치 벡터이므로, 이 항은 <span class="math math-inline">(i, j)</span>라는 절대 좌표 쌍에 의존한다.10 비록 사인파 APE의 경우 <span class="math math-inline">\sin(\omega i + \phi)</span> 형태를 띠므로 <span class="math math-inline">p_i^T p_j</span> (내적)가 <span class="math math-inline">i-j</span>의 함수로 표현될 수 있다는 주장(Vaswani et al.)이 있었으나, 이는 <span class="math math-inline">W_Q, W_K</span>라는 학습 가능한 선형 투영(Linear Projection) 행렬이 개입되면서 깨지게 된다. <span class="math math-inline">W_Q, W_K</span>가 회전 행렬이나 항등 행렬과 같은 특수한 형태가 아닌 이상, 투영된 공간에서의 내적은 더 이상 순수한 상대 거리 함수가 아니며, 절대 위치 성분이 잔존하게 된다.5</p>
<p>반면, RoPE(Rotary Positional Embedding)와 같은 최신 기법은 회전 변환을 통해 내적 연산 자체가 수학적으로 <span class="math math-inline">i-j</span>에만 의존하도록 강제함으로써 이 문제를 해결했다.2 APE의 실패는 바로 이 ’상대성(Relativity)’을 어텐션 메커니즘 내부 연산에 내재화하지 못하고, 입력단에 고정된 값을 더하는 얕은(Shallow) 방식에 기인한다.</p>
<pre><code class="language-mermaid">graph TD
    Eq["Attention(i, j) =&lt;br&gt;(xi + pi)^T * W_Q^T * W_K * (xj + pj)"]
    
    Eq --&gt; Term1["Content-Content&lt;br/&gt;(의미 상호작용)"]
    Eq --&gt; Term2["Content-Pos&lt;br/&gt;(의미-위치 섞임)"]
    Eq --&gt; Term3["Pos-Content&lt;br/&gt;(위치-의미 섞임)"]
    Eq --&gt; Term4["Pos-Pos&lt;br/&gt;(위치 간 상호작용)"]
    
    Term4 -- "문제 발생" --&gt; Problem["p_i^T * W * p_j"]
    Problem --&gt; Reason1["절대 좌표 (i, j) 쌍에 의존"]
    Problem --&gt; Reason2["상대 거리 (i - j) 함수가 아님"]
    Problem --&gt; Reason3["선형 투영(W)으로 인해&lt;br/&gt;거리 정보 왜곡"]
    
    Reason1 &amp; Reason2 &amp; Reason3 --&gt; Concl["이동 불변성 확보 불가"]
</code></pre>
<h3>2.3  이미지 및 시계열 데이터에서의 공간 정보 왜곡</h3>
<p>이동 불변성의 결여는 텍스트보다 2차원 이상의 구조를 가진 데이터에서 더욱 심각한 문제를 초래한다.</p>
<p>비전 트랜스포머(ViT)의 1차원 평탄화(Flattening) 문제:</p>
<p>ViT는 2차원 이미지를 패치(Patch)로 자른 뒤 1차원 시퀀스로 나열하고 1D APE를 적용하는 방식이 흔히 사용된다. 이 과정에서 이미지의 2차원 공간 구조(위/아래, 왼쪽/오른쪽 관계)가 심각하게 훼손된다.15 1D APE는 패치 간의 유클리드 거리(Euclidean Distance)를 반영하지 못한다.</p>
<ul>
<li>예를 들어, <span class="math math-inline">W \times H</span> 그리드에서 좌표 <span class="math math-inline">(x, y)</span>에 있는 패치의 바로 아래 패치 <span class="math math-inline">(x, y+1)</span>는 1차원 시퀀스 상에서는 인덱스 차이가 <span class="math math-inline">W</span>만큼 벌어지게 된다.</li>
<li>반면 바로 오른쪽 패치 <span class="math math-inline">(x+1, y)</span>는 인덱스 차이가 1이다.</li>
</ul>
<p>물리적으로는 등거리에 있는 이웃 패치들이지만, APE 상에서는 전혀 다른 거리 관계를 갖게 된다. 1D APE는 이러한 공간적 이웃(Spatial Neighborhood) 관계를 일관성 있게 표현하지 못하므로, 모델은 이미지의 지역적 구조(Local Structure)를 학습하는 데 더 많은 데이터를 필요로 하며, 공간적 귀납적 편향(Spatial Inductive Bias)의 이점을 누리지 못한다.14</p>
<p>시계열 데이터의 시간 이동(Time-Shift) 문제:</p>
<p>시계열 데이터 분석에서 시간 축에 따른 이동 불변성(Time-Shift Invariance)은 필수적이다. 주식 시장의 폭락 패턴이나 심전도의 이상 파형은 2020년에 발생하든 2024년에 발생하든 동일한 패턴으로 인식되어야 한다. 그러나 APE는 시점(Time Step) 자체에 고유한 값을 부여하므로, 모델이 특정 시점(절대 시간)에 과적합될 위험이 있다.4 예를 들어, 훈련 데이터가 2023년까지의 데이터라면, APE는 2023년의 타임스텝에 특화된 편향을 학습하게 되어, 2024년 이후의 데이터(Out-of-Distribution Time Steps)에 대해 일반화 능력이 떨어진다. 이는 미래 예측이 핵심인 시계열 태스크에서 APE 기반 트랜스포머의 신뢰성을 낮추는 요인이 된다.16</p>
<pre><code class="language-mermaid">graph TD
    subgraph "2D 이미지 그리드 (W x H)"
        Center["패치 (x, y)"]
        Right["오른쪽 이웃 (x+1, y)&lt;br/&gt;실제 거리: 1"]
        Bottom["아래쪽 이웃 (x, y+1)&lt;br/&gt;실제 거리: 1"]
        
        Center --- Right
        Center --- Bottom
    end

    Arrow["1D 평탄화 (Flattening) + APE 적용"]
    
    subgraph "1D 트랜스포머 시퀀스"
        SeqC["인덱스: i"]
        SeqR["인덱스: i + 1"]
        SeqB["인덱스: i + W (너비만큼 차이)"]
        
        SeqC -- "APE 거리: 1" --&gt; SeqR
        SeqC -- "APE 거리: W (매우 멂)" --&gt; SeqB
    end

    Center --&gt; Arrow
    Right --&gt; Arrow
    Bottom --&gt; Arrow
    
    Arrow --&gt; Distort["공간 정보 왜곡 발생&lt;br/&gt;(물리적 등거리가 APE에서는 다름)"]
</code></pre>
<h2>3.  정보의 얽힘(Entanglement)과 덧셈 연산의 정보 손실</h2>
<p>트랜스포머의 입력 임베딩 구성 방식인 <span class="math math-inline">E = E_{content} + E_{position}</span>은 직관적이고 구현이 간단하다는 장점이 있지만, 정보 이론적 관점에서 볼 때 심각한 정보 손실과 혼란을 야기하는 “얽힘(Entanglement)” 문제를 안고 있다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "입력 단계 (Input Layer)"
        Cont["내용 벡터&lt;br&gt;(Content)"]
        Pos["위치 벡터&lt;br&gt;(Pos)"]
        Add(("(+)"))
        Mixed["혼합 벡터&lt;br&gt;E = C + P&lt;br/&gt;(정보 얽힘 발생)"]
        Cont --&gt; Add
        Pos --&gt; Add
        Add --&gt; Mixed
    end

    Mixed --&gt; L1["Layer 1&lt;br/&gt;Self-Attention + FFN"]
    L1 --&gt; L2["Layer 2&lt;br/&gt;Mixing &amp; Projection"]
    L2 --&gt; Dots["..."]
    Dots --&gt; LN["Layer N&lt;br&gt;(Deep)"]
    
    LN --&gt; Result["위치 정보 희석&lt;br&gt;(Dilution)"]
    Result --&gt; Cause["반복적인 변환과&lt;br/&gt;Layer Norm으로 인해&lt;br/&gt;초기 위치 신호 소실"]
    
    subgraph "비교: DeBERTa 방식"
        D_Cont["Content"]
        D_Pos["Position"]
        D_Att["Disentangled Attention&lt;br/&gt;(별도 행렬 연산)"]
        D_Cont -.-&gt; D_Att
        D_Pos -.-&gt; D_Att
    end
</code></pre>
<h3>3.1  벡터 합산(Summation)에 의한 의미 희석</h3>
<p>서로 다른 성격의 두 벡터를 요소별 합(Element-wise Sum)으로 결합하는 것은 각 벡터의 고유한 정보를 혼합하여 복원하기 어렵게 만든다. 내용 정보(단어의 의미)와 위치 정보(순서)가 하나의 벡터 공간(<span class="math math-inline">d_{model}</span>)에 합산되면, 모델은 이후의 연산에서 이 두 정보를 명확히 분리해내기 위해 불필요한 계산 자원을 소모해야 한다.</p>
<p>특히, 단어 임베딩의 크기(Magnitude)와 위치 임베딩의 크기가 서로 다른 스케일을 가질 경우 문제가 발생한다. 만약 위치 임베딩의 노름(Norm)이 내용 임베딩에 비해 너무 작다면 위치 정보는 무시될 것이고, 너무 크다면 단어의 의미가 위치 정보에 의해 왜곡될 수 있다.17 이러한 합산 방식은 위치 정보를 내용 정보의 ’배경 잡음(Background Noise)’처럼 취급하게 만들 수 있다.</p>
<p>DeBERTa의 Disentangled Attention 실험:</p>
<p>Microsoft의 DeBERTa(Decoding-enhanced BERT with disentangled attention) 연구팀은 이 문제를 정면으로 비판하며 “Disentangled Attention” 메커니즘을 제안했다.19 그들은 내용 벡터와 위치 벡터를 더하지 않고 별도로 유지하며, 어텐션 스코어를 계산할 때도 서로 독립적인 행렬로 계산하여 합산하는 방식을 사용했다.</p>
<table><thead><tr><th><strong>모델 구조</strong></th><th><strong>임베딩 결합 방식</strong></th><th><strong>어텐션 계산 방식</strong></th><th><strong>특징 및 한계</strong></th></tr></thead><tbody>
<tr><td><strong>BERT (APE)</strong></td><td><span class="math math-inline">E = E_c + E_p</span> (합산)</td><td><span class="math math-inline">(H_i+P_i)^T (H_j+P_j)</span></td><td>정보 얽힘 발생. 위치와 내용의 상호작용이 뭉뚱그려짐.</td></tr>
<tr><td><strong>DeBERTa</strong></td><td><span class="math math-inline">H</span>와 <span class="math math-inline">P</span> 분리 유지</td><td><span class="math math-inline">H_i^T H_j + H_i^T P_{j \vert i} + P_{i \vert j}^T H_j</span></td><td><strong>상대적 위치</strong>를 사용하여 내용-내용, 내용-위치, 위치-내용 상호작용을 개별 계산. 정보 손실 최소화 및 효율적 학습 가능.</td></tr>
</tbody></table>
<p>DeBERTa의 실험 결과, 벡터를 단순히 더하는 BERT 방식보다 정보를 분리하여 처리하는 방식이 GLUE 벤치마크 등 주요 NLP 태스크에서 훨씬 더 뛰어난 성능을 보였다.21 특히 “deep“과 “learning“이라는 단어가 인접해 있을 때만 발생하는 강력한 의미적 결합을 포착하는 데 있어, APE의 단순 합산 방식은 상대적 위치 관계를 명확히 표현하지 못함이 증명되었다. 이는 APE의 덧셈 방식이 위치 정보와 의미 정보 사이의 복잡한 상호작용을 충분히 포착하지 못하는 차선책(Suboptimal)임을 시사한다.18</p>
<h3>3.2  깊은 층에서의 위치 정보 소실 (Positional Information Dilution)</h3>
<p>APE는 네트워크의 **가장 첫 번째 층(Input Layer)**에서만 단 한 번 주입된다. 트랜스포머가 깊어질수록(Layer가 12개, 24개, 96개 등으로 쌓일수록), 토큰들의 표현(Representation)은 셀프 어텐션과 피드포워드 네트워크(FFN)를 거치며 반복적으로 섞이고 변환된다. 이 과정에서 초기에 주입된 위치 정보는 점차 희석되거나 소실될 가능성이 매우 높다.23</p>
<p>이를 “위치 정보 희석(Positional Information Dilution)” 또는 “Lost-in-the-Middle” 현상의 원인 중 하나로 볼 수 있다.11</p>
<ul>
<li><strong>신호 대 잡음비(SNR) 감소:</strong> 깊은 층의 어텐션 메커니즘은 초기의 물리적 위치 신호보다는 상위 레벨의 의미적(Semantic), 추상적 관계에 더 집중하도록 학습된다. 이는 자연스러운 현상이지만, 문장의 복잡한 통사 구조(Syntactic Structure)를 파악하거나 장거리 의존성을 유지하기 위해 깊은 층에서도 여전히 정확한 위치 정보가 필요한 경우 문제가 된다.</li>
<li><strong>전파의 비효율성:</strong> 잔차 연결(Residual Connection)이 위치 정보를 상위 층으로 전달해주기는 하지만, 층을 거칠 때마다 수행되는 Layer Normalization과 비선형 활성화 함수는 위치 정보의 선명도를 떨어뜨린다.</li>
</ul>
<p>반면, RoPE나 ALiBi와 같은 최신 기법들은 **모든 어텐션 레이어(Every Attention Layer)**에서 위치 정보를 쿼리와 키에 직접적으로 주입하거나 어텐션 스코어를 변조(Modulation)한다. 이를 통해 네트워크의 깊이와 상관없이 위치 정보가 보존되도록 보장한다.13 APE의 “One-off Injection(일회성 주입)” 방식은 수십 개 층을 가진 심층 신경망(Deep Neural Networks)의 정보 전파 특성을 간과한 설계라 할 수 있다.</p>
<h2>4.  데이터 효율성(Data Efficiency) 저하와 위치 과적합</h2>
<p>절대적 위치 인코딩은 모델의 학습 효율성을 떨어뜨리고, 데이터의 편향(Bias)에 취약한 모델을 만든다.</p>
<h3>4.1  위치 과적합(Position Overfitting)과 숏컷 러닝</h3>
<p>APE를 사용하는 모델은 특정 단어나 패턴이 “항상 문장의 <span class="math math-inline">k</span>번째 위치에 등장한다“와 같은 피상적인 상관관계(Spurious Correlation)를 학습하기 쉽다. 이를 **위치 과적합(Position Overfitting)**이라 한다.5</p>
<ul>
<li><strong>사례:</strong> 뉴스 기사 데이터셋으로 학습된 모델은 “According to“나 “Breaking News“와 같은 표현이 문장의 시작 부분(위치 0~5)에 온다는 것을 위치 임베딩을 통해 강력하게 암기할 수 있다.</li>
<li><strong>결과:</strong> 만약 테스트 데이터에서 이러한 표현이 문장 중간이나 끝에 등장하면, 모델은 예측 확률 분포가 흐트러지며 성능이 저하된다.</li>
</ul>
<p>이는 모델이 언어의 본질적인 문법 구조나 인과관계를 학습하는 대신, 훈련 데이터셋에 편향된 위치 분포를 암기하는 ’지름길(Shortcut Learning)’을 택했음을 의미한다. 이러한 경향은 훈련 데이터가 적을수록, 그리고 모델의 파라미터가 많을수록 심화된다. 상대적 위치를 사용하는 모델은 “A 다음에 B가 온다“는 관계를 학습하므로 이러한 절대 위치 편향에서 자유롭다.</p>
<h3>4.2  마스킹된 언어 모델(MLM) 학습의 비효율성</h3>
<p>BERT와 같은 마스킹된 언어 모델(Masked Language Model) 훈련 시, 토큰의 원래 단어를 복원하기 위해 주변 문맥을 사용한다. 이때 토큰의 절대 위치 정보가 주어지지만, APE의 경직성으로 인해 모델은 마스킹된 위치와 주변 단어들 사이의 ’거리감’을 정밀하게 계산하는 데 어려움을 겪는다.19</p>
<p>DeBERTa 연구진은 BERT의 APE가 “상대적 위치에 따른 어텐션 가중치의 변화“를 충분히 반영하지 못하여, 문맥 파악의 정밀도가 떨어진다고 지적했다. 예를 들어, 마스킹된 단어가 바로 옆 단어(거리 1)와 10칸 떨어진 단어(거리 10)로부터 받는 영향력의 차이를 APE만으로는 섬세하게 조절하기 어렵다는 것이다. 이는 모델이 수렴하기 위해 더 많은 학습 스텝(Training Steps)과 더 많은 데이터를 필요로 하게 만드는 원인이 된다.22</p>
<h2>5.  결론: 절대성에서 상대성으로의 필연적 진화</h2>
<p>요약하자면, 절대적 위치 인코딩(APE)은 트랜스포머의 탄생과 함께 시퀀스 처리의 새로운 지평을 열었으나, 그 설계 사상에 내재된 ’절대성(Absoluteness)’은 모델의 확장성, 일반화 능력, 그리고 학습 효율성을 억제하는 족쇄가 되었다.</p>
<ol>
<li><strong>길이 외삽의 불가능성</strong>은 LLM이 더 긴 컨텍스트를 처리하고 추론하는 능력을 가로막는 가장 큰 장벽이었다.</li>
<li><strong>이동 불변성의 결여</strong>는 모델이 언어와 이미지의 본질적인 구조를 효율적으로 학습하는 것을 방해하고 데이터 요구량을 증가시켰다.</li>
<li><strong>정보의 얽힘과 희석</strong>은 깊은 신경망에서의 신호 전달 효율을 저하시키고, 정밀한 문맥 이해를 방해했다.</li>
</ol>
<p>이러한 한계점들은 필연적으로 <strong>상대적 위치 인코딩(Relative Positional Encoding, RPE)</strong>, <strong>회전 위치 임베딩(RoPE)</strong>, **ALiBi(Attention with Linear Biases)**와 같은 차세대 위치 인코딩 기술의 등장을 촉발했다. 현대의 최신 LLM(예: Llama, PaLM, GPT-4 등)이 APE를 버리고 RoPE나 ALiBi를 채택하는 것은 단순한 유행이 아니다. 이는 APE가 가진 구조적 결함을 극복하고, ’위치’라는 개념을 인간의 인지 방식과 더 유사한 ’관계적’이고 ’상대적’인 형태로 재정의하려는 진화의 결과이다.9 따라서 APE의 한계를 명확히 이해하는 것은 트랜스포머 아키텍처가 어떻게 ’싱귤래리티’를 향해 최적화되어 가는지, 그 진보의 궤적과 필연성을 파악하는 데 있어 가장 중요한 첫걸음이라 할 수 있다.</p>
<pre><code class="language-mermaid">graph TD
    Step1["초기 트랜스포머 (2017)&lt;br/&gt;절대적 위치 인코딩 (APE)"]
    
    Step1 -- "한계 발견: 길이 외삽 불가" --&gt; Pain1["긴 문맥 처리 실패"]
    Step1 -- "한계 발견: 이동 불변성 결여" --&gt; Pain2["데이터 비효율성"]
    Step1 -- "한계 발견: 정보 얽힘" --&gt; Pain3["깊은 층 성능 저하"]
    
    Pain1 &amp; Pain2 &amp; Pain3 --&gt; Evolution["패러다임 전환:&lt;br/&gt;절대 좌표 -&gt; 상대 관계"]
    
    Evolution --&gt; Sol1["T5 / Relative PE&lt;br/&gt;(학습 가능한 상대 거리 편향)"]
    Evolution --&gt; Sol2["RoPE (Rotary PE)&lt;br/&gt;(회전을 통한 상대성 내재화)"]
    Evolution --&gt; Sol3["ALiBi&lt;br/&gt;(선형 편향으로 외삽 성능 극대화)"]
    
    Sol1 &amp; Sol2 &amp; Sol3 --&gt; Current["현대 LLM의 표준 (Llama, GPT-4 등)"]
</code></pre>
<h2>6. 참고 자료</h2>
<ol>
<li>Positional Encoding Explained: A Deep Dive into Transformer PE - Medium, https://medium.com/thedeephub/positional-encoding-explained-a-deep-dive-into-transformer-pe-65cfe8cfe10b</li>
<li>How Transformers Encode Position: PE &amp; RoPE Made Simple | by Hugo Le Picard, PhD, https://medium.com/@lepicardhugo/how-transformers-encode-position-pe-rope-made-simple-024d5e03fa03</li>
<li>Transformers without positional encodings. : r/deeplearning - Reddit, https://www.reddit.com/r/deeplearning/comments/1ew4dv4/transformers_without_positional_encodings/</li>
<li>Positional Encoding in Transformer-Based Time Series Models: A Survey - arXiv, https://arxiv.org/html/2502.12370v2</li>
<li>Length Extrapolation of Transformers: A Survey from the Perspective of Positional Encoding, https://arxiv.org/html/2312.17044v4</li>
<li>Length Extrapolation of Transformers: A Survey from the Perspective of Positional Encoding - ACL Anthology, https://aclanthology.org/2024.findings-emnlp.582.pdf</li>
<li>TRANSFORMERS CAN ACHIEVE LENGTH GENERALIZATION BUT NOT ROBUSTLY - OpenReview, https://openreview.net/pdf?id=DWkWIh3vFJ</li>
<li>[Discussion] Why don’t sinusoidal PE work for longer sequences? : r/MachineLearning, https://www.reddit.com/r/MachineLearning/comments/1fxmn0z/discussion_why_dont_sinusoidal_pe_work_for_longer/</li>
<li>Giving LLMs too much RoPE: A limit on Sutton’s Bitter Lesson - Bradley C. Love, http://bradlove.org/blog/position-embd</li>
<li>Why cant we use normalise position encodings instead of the cos and sine encodings used in the Transformer paper?, https://datascience.stackexchange.com/questions/123062/why-cant-we-use-normalise-position-encodings-instead-of-the-cos-and-sine-encodin</li>
<li>On the Emergence of Position Bias in Transformers - arXiv, https://arxiv.org/html/2502.01951v4</li>
<li>Positional Embeddings in Transformers: A Math Guide to RoPE &amp; ALiBi, https://towardsdatascience.com/positional-embeddings-in-transformers-a-math-guide-to-rope-alibi/</li>
<li>Theoretical Analysis of Positional Encodings in Transformer Models: Impact on Expressiveness and Generalization - Preprints.org, https://www.preprints.org/manuscript/202506.0534</li>
<li>Quantitative Analysis of Deep Learning-Based Object Detection Models - IEEE Xplore, https://ieeexplore.ieee.org/iel7/6287639/6514899/10530876.pdf</li>
<li>Beyond flattening: a geometrically principled positional encoding for vision transformers with Weierstrass elliptic functions - ChatPaper, https://chatpaper.com/paper/183810</li>
<li>Positional Encoding in Transformer-Based Time Series Models: A Survey - arXiv, https://arxiv.org/html/2502.12370v1</li>
<li>Large Language Models: DeBERTa - Decoding-Enhanced BERT with Disentangled Attention | Towards Data Science, https://towardsdatascience.com/large-language-models-deberta-decoding-enhanced-bert-with-disentangled-attention-90016668db4b/</li>
<li>DeBERTa: Decoding-enhanced BERT with Disentangled Attention, https://arxiv.org/pdf/2006.03654</li>
<li>[Quick Review] DeBERTa: Decoding-enhanced BERT with Disentangled Attention - Liner, https://liner.com/review/deberta-decodingenhanced-bert-with-disentangled-attention</li>
<li>DeBERTa: Decoding-enhanced BERT with Disentangled Attention - Medium, https://medium.com/@Mustafa77/deberta-decoding-enhanced-bert-with-disentangled-attention-24948be8958c</li>
<li>DEBERTA: DECODING-ENHANCED BERT WITH DIS- ENTANGLED ATTENTION - OpenReview, https://openreview.net/pdf?id=XPZIaotutsD</li>
<li>DeBERTa: Decoding-Enhanced BERT with Disentangled Attention - Microsoft Research, https://www.microsoft.com/en-us/research/publication/deberta-decoding-enhanced-bert-with-disentangled-attention-2/</li>
<li>Deep Dive into Transformer Positional Encoding: A Comprehensive Guide - Medium, https://medium.com/the-software-frontier/deep-dive-into-transformer-positional-encoding-a-comprehensive-guide-5adcded5a38d</li>
<li>Rope to Nope and Back Again: A New Hybrid Attention Strategy - arXiv, https://arxiv.org/html/2501.18795v1</li>
<li>A Comparative Study on Positional Encoding for Time-Frequency Domain Dual-Path Transformer-Based Source Separation Models - IEEE Xplore, https://ieeexplore.ieee.org/iel8/11225917/11226019/11226241.pdf</li>
<li>[D] Paper Explained - DeBERTa: Decoding-enhanced BERT with Disentangled Attention (Full Video Analysis) : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/lsgkln/d_paper_explained_deberta_decodingenhanced_bert/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>