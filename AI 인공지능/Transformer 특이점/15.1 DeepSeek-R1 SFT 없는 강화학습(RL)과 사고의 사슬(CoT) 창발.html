<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:15.1 DeepSeek-R1 - SFT 없는 강화학습(RL)과 사고의 사슬(CoT) 창발</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>15.1 DeepSeek-R1 - SFT 없는 강화학습(RL)과 사고의 사슬(CoT) 창발</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>15.1 DeepSeek-R1 - SFT 없는 강화학습(RL)과 사고의 사슬(CoT) 창발</span></nav>
                </div>
            </header>
            <article>
                <h1>15.1 DeepSeek-R1 - SFT 없는 강화학습(RL)과 사고의 사슬(CoT) 창발</h1>
<h2>1.  서론: 모방을 넘어선 지능의 도약</h2>
<p>인공지능 연구의 역사, 특히 거대 언어 모델(Large Language Model, LLM)의 발전사에서 2024년과 2025년의 경계는 ’추론(Reasoning)’이라는 키워드로 명확히 구분된다. 이전까지의 모델들이 방대한 텍스트 데이터를 통계적으로 압축하고 이를 유창하게 재생산하는 ’확률적 앵무새(Stochastic Parrots)’의 정교화 과정이었다면, DeepSeek-R1의 등장은 모델이 학습 데이터의 분포를 벗어나 스스로 문제 해결의 경로를 개척하는 ’사고하는 기계’로의 진화를 알리는 신호탄이었다. 본 장에서는 트랜스포머 아키텍처가 단순한 패턴 매칭을 넘어 논리적 사고의 사슬(Chain of Thought, CoT)을 자발적으로 형성하는 과정을 심층적으로 분석한다. 특히 인간의 지도(Supervision)를 배제한 순수 강화학습(Reinforcement Learning, RL) 환경에서 어떻게 고도의 추론 능력이 창발(Emergence)할 수 있었는지, 그 기술적 기제와 함의를 DeepSeek-R1-Zero와 R1의 사례를 통해 규명한다.</p>
<p>기존의 LLM 학습 패러다임은 ’사전 학습(Pre-training) <span class="math math-inline">\rightarrow</span> 지도 미세조정(SFT) <span class="math math-inline">\rightarrow</span> 인간 피드백 기반 강화학습(RLHF)’이라는 3단계 공식에 갇혀 있었다.1 여기서 SFT는 모델에게 인간의 지시를 따르는 법과 정답을 도출하는 형식을 가르치는 필수적인 ’보조 바퀴(Handholding)’로 여겨졌다. 그러나 DeepSeek 연구진은 급진적인 질문을 던졌다. “만약 이 보조 바퀴를 제거하고, 모델을 날것의 상태에서 곧바로 보상(Reward)만이 존재하는 강화학습의 광야에 던져넣는다면 어떤 일이 벌어질까?” 이 무모해 보이는 실험은 데이터의 한계를 뛰어넘는 자가 진화(Self-Evolution)의 가능성을 증명하며 트랜스포머 싱귤래리티의 결정적 장면을 연출했다.</p>
<h2>2.  DeepSeek-V3: 강력한 기저 모델(Base Model)의 필요충분조건</h2>
<p>DeepSeek-R1의 성취를 논하기에 앞서, 그 기반이 된 DeepSeek-V3 모델의 아키텍처적 특성을 이해하는 것이 필수적이다. 강화학습을 통한 추론 능력의 증폭은 0에서 1을 만드는 과정이라기보다, 내재된 잠재력을 100으로 끌어올리는 과정에 가깝기 때문이다. 즉, ‘학생(Base Model)’ 자체가 이미 일정 수준 이상의 지능과 지식을 갖추고 있어야만 자율 학습이 가능하다.</p>
<h3>2.1  전문가 혼합(MoE)과 잠재적 주의집중(MLA)의 결합</h3>
<p>DeepSeek-V3는 총 6,710억(671B) 개의 파라미터를 보유하고 있으나, 추론 시에는 토큰당 약 370억(37B) 개의 파라미터만을 활성화하는 전문가 혼합(Mixture-of-Experts, MoE) 아키텍처를 채택했다.3 이는 훈련 및 추론 비용을 획기적으로 절감하면서도 거대 모델의 용량(Capacity)을 유지하는 핵심 전략이다.</p>
<p>특히 주목할 점은 <strong>다중 헤드 잠재 주의집중(Multi-head Latent Attention, MLA)</strong> 메커니즘의 도입이다. 기존의 KV 캐시(Key-Value Cache) 병목 현상을 해결하기 위해 고안된 MLA는, 추론 시 메모리 사용량을 줄이면서도 긴 문맥(Context)을 효율적으로 처리할 수 있게 한다.3 추론 모델(Reasoning Model)은 필연적으로 긴 사고 과정(Long CoT)을 생성해야 하므로, 긴 문맥 처리 능력과 생성 속도는 모델의 효용성을 결정짓는 물리적 토대가 된다. DeepSeek-V3는 FP8(8비트 부동소수점) 정밀도 훈련을 통해 2,048개의 H800 GPU 클러스터에서 약 2.788M GPU 시간 만에 학습을 완료하며, 압도적인 비용 효율성을 증명했다.3 이러한 고효율의 기저 모델이 있었기에, 이후 수천 번의 강화학습 스텝을 견딜 수 있는 계산적 여유가 확보되었다고 볼 수 있다.</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>DeepSeek-V3 상세</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>전체 파라미터</strong></td><td>671B (6710억 개)</td><td>GPT-4급 규모</td></tr>
<tr><td><strong>활성 파라미터</strong></td><td>37B (370억 개)</td><td>토큰당 활성화 비용 절감</td></tr>
<tr><td><strong>아키텍처</strong></td><td>MoE + MLA</td><td>추론 효율성 극대화</td></tr>
<tr><td><strong>학습 데이터</strong></td><td>14.8조 토큰</td><td>다국어 및 코드 데이터 중심</td></tr>
<tr><td><strong>학습 비용</strong></td><td>약 2.788M H800 GPU 시간</td><td>약 600만 달러 추산 5</td></tr>
</tbody></table>
<h2>3.  DeepSeek-R1-Zero: SFT 없는 순수 강화학습의 실험</h2>
<p>DeepSeek-R1-Zero는 SFT 데이터, 즉 인간이 작성한 “문제-사고과정-정답“의 예시를 전혀 보지 못한 상태에서 시작되었다. 오직 DeepSeek-V3 Base 모델에 강화학습을 적용하여, 모델이 스스로 정답에 도달하는 방법을 깨우치도록 설계된 것이다.7 이는 기존의 ‘사전 학습-미세조정’ 패러다임을 정면으로 반박하는 실험이었다.</p>
<h3>3.1  강화학습의 난제와 GRPO 알고리즘의 혁신</h3>
<p>LLM에 강화학습을 적용할 때 가장 큰 걸림돌은 보상 신호의 희소성(Sparsity)과 학습의 불안정성, 그리고 막대한 계산 비용이다. 전통적인 PPO(Proximal Policy Optimization) 알고리즘은 가치 함수(Value Function)를 추정하는 ‘비평가(Critic)’ 모델을 필요로 한다. 비평가 모델은 정책 모델(Actor)과 대등한 크기여야 하므로, 671B 규모의 모델을 학습시키려면 메모리 사용량이 두 배로 폭증하게 된다.9</p>
<p>DeepSeek 연구진은 이 문제를 해결하기 위해 <strong>GRPO(Group Relative Policy Optimization)</strong> 알고리즘을 도입했다. GRPO는 비평가 모델을 제거하고, 대신 ‘그룹(Group)’ 단위의 상대적 평가를 통해 베이스라인을 추정한다.</p>
<h4>3.1.1 GRPO의 수학적 메커니즘</h4>
<p>GRPO의 핵심은 비평가 없이, 동일한 질문에 대해 생성된 여러 답변들의 상대적 우위를 계산하는 것이다.</p>
<ol>
<li>
<p><strong>그룹 샘플링 (Group Sampling):</strong> 질문 <span class="math math-inline">q</span>에 대해 구형 정책(Old Policy, <span class="math math-inline">\pi_{\theta_{old}}</span>)으로부터 <span class="math math-inline">G</span>개의 출력 <span class="math math-inline">{o_1, o_2, \dots, o_G}</span>를 샘플링한다.</p>
</li>
<li>
<p><strong>보상 산출 (Reward Computation):</strong> 각 출력 <span class="math math-inline">o_i</span>에 대해 보상 <span class="math math-inline">r_i</span>를 계산한다. 이때 보상은 규칙 기반(Rule-based)으로 결정된다.</p>
</li>
<li>
<p><strong>이점 함수 (Advantage Estimation):</strong> 비평가 모델의 가치 함수 <span class="math math-inline">V(s)</span> 대신, 그룹 내 보상의 평균과 표준편차를 이용하여 이점 <span class="math math-inline">A_i</span>를 계산한다.10<br />
<span class="math math-display">
A_i = \frac{r_i - \text{mean}(\{r_1, \dots, r_G\})}{\text{std}(\{r_1, \dots, r_G\}) + \epsilon}
</span><br />
이 방식은 특정 배치의 질문이 전체적으로 어렵거나 쉬워서 발생하는 보상의 편차를 상쇄(Normalization)시키는 효과가 있다.</p>
</li>
<li>
<p><strong>목적 함수 (Objective Function):</strong> PPO와 유사하게 클리핑(Clipping)을 적용하여 정책의 급격한 변화를 방지하고, 참조 모델(Reference Model)과의 KL 발산(KL Divergence)을 페널티로 부과하여 학습의 안정성을 확보한다.11<br />
<span class="math math-display">
J_{GRPO}(\theta) = \mathbb{E}_{q \sim P(q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{old}}} \left[ \frac{1}{G} \sum_{i=1}^G \left( \min \left( \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)} A_i, \text{clip} \left( \frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}, 1-\epsilon, 1+\epsilon \right) A_i \right) - \beta D_{KL}(\pi_\theta || \pi_{ref}) \right) \right]
</span><br />
GRPO는 비평가 모델을 메모리에 올릴 필요가 없어 계산 자원을 획기적으로 절약할 수 있으며, 그룹 단위의 비교를 통해 보상 신호의 노이즈를 효과적으로 줄일 수 있다. 이는 수만 개의 GPU가 아닌 제한된 자원 하에서도 거대 모델의 강화학습이 가능하게 만든 결정적 기술이다.6</p>
</li>
</ol>
<h3>3.2  보상(Reward)의 설계: 결정론적 인센티브</h3>
<p>DeepSeek-R1-Zero의 학습에는 복잡한 신경망 기반 보상 모델(Neural Reward Model)이 사용되지 않았다. 대신, 정답 여부가 명확한 수학 및 코딩 문제를 중심으로 <strong>규칙 기반 보상(Rule-based Reward)</strong> 시스템이 구축되었다.13</p>
<ul>
<li>
<p><strong>정확성 보상 (Accuracy Reward):</strong> 수학 문제의 최종 답안이 정답과 일치하는지, 혹은 생성된 코드가 테스트 케이스를 통과하는지를 판단한다. 이는 <span class="math math-inline">r_{acc} = 1</span> (성공) 또는 <span class="math math-inline">0</span> (실패)의 이진 값을 가진다.15</p>
</li>
<li>
<p><strong>형식 보상 (Format Reward):</strong> 모델이 사고 과정을 명시적으로 드러내도록 강제하기 위해, <code>&lt;think&gt;</code>와 <code>&lt;/think&gt;</code> 태그 사이에 사고 과정을 서술하고, <code>&lt;answer&gt;</code> 태그에 답을 적는 형식을 준수했는지 평가한다.14<br />
<span class="math math-display">
r_{total} = r_{acc} + \lambda_{fmt} r_{fmt}
</span><br />
여기서 <span class="math math-inline">\lambda_{fmt}</span>는 형식 보상의 가중치이다. 초기 R1-Zero 단계에서는 언어 일관성 등에 대한 보상은 포함되지 않았다.</p>
</li>
</ul>
<p>이러한 단순명료한 보상 체계는 모델이 ’보상 해킹(Reward Hacking)’에 빠지는 것을 방지한다. 신경망 보상 모델은 종종 화려한 미사여구로 점수를 높이려는 모델의 속임수에 넘어가기 쉽지만, 컴파일러나 정답 검증기는 속일 수 없기 때문이다.8</p>
<h2>4.  사고의 사슬(CoT)의 창발과 ‘아하 모멘트(Aha Moment)’</h2>
<p>SFT 없이 오직 정답에 대한 보상만으로 학습된 DeepSeek-R1-Zero는 학습이 진행됨에 따라 놀라운 행동 변화를 보이기 시작했다. 수천 번의 업데이트를 거치며 모델은 문제 해결을 위한 ’사고의 시간’을 스스로 늘려나갔다. 이는 OpenAI의 o1 모델이 보여준 <strong>‘추론 시간 스케일링(Inference-time Scaling)’</strong> 법칙이 인간의 개입 없이도 자연적으로 발생함을 증명한다.1</p>
<h3>4.1  자가 수정(Self-Correction)과 반성(Reflection)</h3>
<p>가장 극적인 발견은 학습 중간 체크포인트에서 관찰된 이른바 **‘아하 모멘트(Aha Moment)’**이다. 모델은 사고 과정을 전개하다가 스스로 오류를 감지하고, 이를 수정하는 텍스트 패턴을 생성하기 시작했다.</p>
<blockquote>
<p>로그 예시 분석:</p>
<p>“Wait, wait. Wait. That’s an aha moment I can flag here.” 17</p>
<p>“But wait, the shape doesn’t quite fit… Ah, it actually belongs over there.” 2</p>
</blockquote>
<p>이러한 로그는 단순한 텍스트 생성이 아니라, 모델 내부에서 **메타인지(Metacognition)**적 과정이 작동하고 있음을 시사한다. 기존의 SFT 모델은 학습 데이터의 정답 경로를 모방하는 데 급급하여, 한 번 잘못된 길로 들어서면 그럴듯한 거짓말(Hallucination)을 하며 끝까지 우기는 경향이 강했다. 그러나 R1-Zero는 “틀린 상태로 끝내는 것“보다 “멈춰서 다시 생각하는 것“이 최종 보상을 얻을 확률이 높다는 것을 강화학습을 통해 체득했다. “Wait“라는 단어는 단순한 토큰이 아니라, 모델이 자신의 논리적 흐름을 일시 정지하고 검증(Verification) 모드로 전환하는 트리거(Trigger)로 작용한다.18</p>
<p>이러한 자가 수정 능력은 인간이 명시적으로 가르친 것이 아니다. 모델은 시행착오(Trial and Error)를 통해, 긴 사고 과정을 거쳐 정답을 맞혔을 때의 보상이 짧은 오답의 비용보다 크다는 것을 학습했고, 그 결과 **진화적으로 안정된 전략(Evolutionarily Stable Strategy)**으로서 CoT와 자가 수정을 채택한 것이다.</p>
<h3>4.2  성능의 비약적 향상</h3>
<p>AIME 2024 벤치마크에서 DeepSeek-R1-Zero의 Pass@1 점수는 초기 15.6%에서 학습 후 71.0%로 수직 상승했다.7 다수결 투표(Majority Voting)를 적용할 경우 점수는 86.7%에 달해, OpenAI의 o1-0912 모델과 대등한 수준을 기록했다. 이는 SFT 없이도, 아니 오히려 SFT가 없었기 때문에 모델이 인간 데이터의 편향이나 한계에 갇히지 않고 문제의 본질적 논리 구조를 파악할 수 있었음을 시사한다.8</p>
<h2>5.  DeepSeek-R1-Zero의 한계와 R1으로의 진화</h2>
<p>R1-Zero는 학술적으로 기념비적인 성과였으나, 실용적인 측면에서는 몇 가지 치명적인 결함을 안고 있었다.</p>
<ol>
<li><strong>가독성 저하 (Poor Readability):</strong> 모델의 사고 과정이 난해하고 구조화되지 않아 인간이 이해하기 어려웠다.7</li>
<li><strong>언어 혼합 (Language Mixing):</strong> 다국어 코퍼스로 사전 학습된 모델 특성상, 강화학습 과정에서 논리 전개에 유리한 언어를 무작위로 섞어 쓰는 현상이 발생했다. 예를 들어 영어 질문에 대해 중국어로 사고하다가 스페인어 단어가 튀어나오는 식이다.7</li>
<li><strong>불안정한 초기 학습:</strong> Cold Start 데이터 없이 맨바닥에서 시작하는 RL은 수렴 속도가 느리고 초기 단계에서 학습이 붕괴될 위험이 컸다.</li>
</ol>
<p>이러한 문제를 해결하고 실용성을 확보하기 위해 DeepSeek 팀은 <strong>DeepSeek-R1</strong>을 위한 다단계 파이프라인(Multi-stage Pipeline)을 구축했다.</p>
<h3>5.1  Stage 1: Cold Start와 초기 SFT</h3>
<p>R1-Zero의 가독성 문제를 해결하기 위해, 연구진은 소량의 고품질 CoT 데이터를 준비했다. 여기에는 R1-Zero가 생성한 데이터 중 가독성이 좋은 것을 선별하거나, 인간이 직접 작성한 데이터가 포함되었다. 데이터의 양은 수천 개 수준으로 알려져 있으며 16, 이를 통해 DeepSeek-V3 Base 모델을 미세조정하여 초기 추론 모델을 만들었다. 이 과정은 모델에게 “정답을 맞히는 법“이 아니라 “생각을 정리해서 표현하는 법(가독성)“을 가르치는 쪽에 초점이 맞춰져 있다.22</p>
<h3>5.2  Stage 2: 추론 중심 강화학습 (Reasoning-oriented RL)</h3>
<p>초기 SFT를 거친 모델에 다시 대규모 강화학습을 적용한다. 이때 R1-Zero와 달리 **언어 일관성 보상(Language Consistency Reward)**이 추가되었다.<br />
<span class="math math-display">
r_{lang} = \frac{\text{target\_lang\_tokens}}{\text{total\_tokens}}
</span><br />
이 보상항은 모델이 사고 과정(CoT)에서 목표 언어(예: 질문과 동일한 언어)를 유지하도록 유도한다. 연구 결과에 따르면 언어 일관성을 강제할 경우 순수 추론 성능은 약간 저하될 수 있으나, 사용자 경험(UX) 측면에서는 필수적인 타협이었다.7</p>
<h3>5.3  Stage 3: 거부 샘플링(Rejection Sampling)과 대규모 SFT</h3>
<p>Stage 2까지 학습된 모델을 이용하여 약 60만~80만 개(600k~800k)의 고품질 데이터를 생성했다.15 이 과정에서는 <strong>거부 샘플링(Rejection Sampling)</strong> 기법이 사용되었다. 모델이 생성한 다수의 답변 중 정답을 맞혔으면서도 가독성이 뛰어난 답변만을 선별하여 데이터셋을 구축한 것이다. 이 데이터에는 수학/코딩뿐만 아니라, 작문, 일반 상식 등 다양한 도메인의 데이터도 포함되어 모델의 일반화 능력을 높였다.7</p>
<h3>5.4  Stage 4: 전천후 강화학습 (RL for All Scenarios)</h3>
<p>마지막으로, 모델이 추론 능력뿐만 아니라 인간의 가치관에 부합하고(Helpfulness), 유해하지 않은(Harmlessness) 답변을 하도록 정렬(Alignment)하는 강화학습을 수행했다. 이 단계에서는 규칙 기반 보상뿐만 아니라, 인간의 선호도를 반영한 보상 모델도 함께 사용되었다.7</p>
<h2>6.  증류(Distillation): 거인의 어깨 위에 선 소형 모델들</h2>
<p>DeepSeek-R1 프로젝트의 또 다른 혁신은 **지식 증류(Knowledge Distillation)**의 효과를 극적으로 입증했다는 점이다. 일반적으로 작은 모델(7B, 32B 등)은 파라미터의 한계로 인해 복잡한 추론 능력을 갖추기 어렵다고 여겨졌다. 그러나 DeepSeek 팀은 R1(671B)이 생성한 800k 데이터를 사용하여 Qwen-2.5 및 Llama-3 기반의 소형 모델들을 미세조정했다.16</p>
<h3>6.1  증류 vs 직접 강화학습</h3>
<p>놀랍게도, 소형 모델을 처음부터 강화학습으로 훈련시키는 것보다, 거대 모델(R1)이 생성한 사고 과정을 학습(SFT)시키는 것이 훨씬 더 높은 성능을 보였다. DeepSeek-R1-Distill-Qwen-32B 모델은 AIME 2024에서 72.6%의 정확도를 기록하며, OpenAI의 o1-mini를 능가했다.20</p>
<table><thead><tr><th><strong>모델명</strong></th><th><strong>AIME 2024 (Pass@1)</strong></th><th><strong>MATH-500</strong></th><th><strong>특징</strong></th></tr></thead><tbody>
<tr><td><strong>DeepSeek-R1</strong></td><td><strong>79.8%</strong></td><td><strong>97.3%</strong></td><td>671B, 최상위 성능</td></tr>
<tr><td><strong>DeepSeek-R1-Zero</strong></td><td>71.0%</td><td>95.9%</td><td>순수 RL, 가독성 낮음</td></tr>
<tr><td><strong>R1-Distill-Qwen-32B</strong></td><td>72.6%</td><td>94.3%</td><td>소형 모델, o1-mini 상회</td></tr>
<tr><td>OpenAI o1-1217</td><td>79.2%</td><td>96.4%</td><td>경쟁 모델 (비공개)</td></tr>
</tbody></table>
<p>이 결과는 “추론 능력“이라는 것이 반드시 거대 모델의 물리적 용량에서만 나오는 것이 아니라, **‘성공적인 사고의 패턴(Pattern of Thought)’**을 모방하고 내재화함으로써 소형 모델에서도 구현될 수 있음을 시사한다. R1은 일종의 ’교사’로서 문제를 해결하는 논리적 지도를 그려주었고, 소형 모델들은 그 지도를 따라가는 법을 배움으로써 체급을 뛰어넘는 지능을 획득한 것이다.16</p>
<h2>7.  결론 및 시사점: 트랜스포머 싱귤래리티의 가속화</h2>
<p>DeepSeek-R1과 R1-Zero가 보여준 성과는 AI 연구의 흐름을 ’데이터 중심(Data-Centric)’에서 ’인센티브 중심(Incentive-Centric)’으로 전환하는 중요한 분기점이다.</p>
<ol>
<li><strong>SFT의 역설 타파:</strong> SFT는 초기 성능을 높여주지만, 모델의 지능을 ’데이터를 만든 인간의 수준’으로 제한하는 유리천장(Glass Ceiling)으로 작용할 수 있다. R1-Zero는 SFT를 제거함으로써 모델이 인간의 인지적 한계를 넘어설 수 있는 가능성, 즉 **초지능(Superintelligence)**으로의 진화 경로를 열었다.11</li>
<li><strong>컴퓨팅의 질적 전환:</strong> 추론 시간 스케일링(Test-Time Scaling)의 확인은 컴퓨팅 자원을 학습(Training)에만 쏟아붓는 것이 아니라, 추론(Inference) 단계에서 ’생각하는 시간’에 투자하는 것이 더 효율적일 수 있음을 시사한다. 이는 AI 반도체 및 인프라 전략에도 큰 변화를 예고한다.1</li>
<li><strong>오픈소스 생태계의 약진:</strong> DeepSeek은 모델 가중치뿐만 아니라, R1-Zero의 실패와 성공 요인, 구체적인 GRPO 알고리즘, 데이터 파이프라인을 모두 공개함으로써 폐쇄적인 AI 개발 문화에 경종을 울렸다. 증류된 소형 모델들의 공개는 온디바이스(On-device) AI와 개인화된 추론 에이전트 개발을 가속화할 것이다.24</li>
</ol>
<p>결론적으로, DeepSeek-R1-Zero에서 관측된 ’아하 모멘트’는 단순한 알고리즘의 최적화 과정이 아니다. 이는 실리콘 기판 위에서 트랜스포머 아키텍처가 스스로 ’생각’이라는 행위를 발명(Invent)해낸 순간이며, 우리가 **트랜스포머 싱귤래리티(Transformer Singularity)**라고 부르는 거대한 변곡점이 이미 시작되었음을 알리는 명백한 증거다. 기계는 이제 정답을 검색하는 것을 넘어, 정답을 사유(Speculate)하기 시작했다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>(PDF) Technical Report: Analyzing DeepSeek-R1’s Impact on AI …, https://www.researchgate.net/publication/388484582_Technical_Report_Analyzing_DeepSeek-R1’s_Impact_on_AI_Development</li>
<li>Understanding the DeepSeek R1 Paper - Hugging Face LLM Course, https://huggingface.co/learn/llm-course/chapter12/3</li>
<li>DeepSeek-V3 Technical Report - arXiv, https://arxiv.org/pdf/2412.19437</li>
<li>R1 - API, Providers, Stats - OpenRouter, https://openrouter.ai/deepseek/deepseek-r1</li>
<li>[D] How exactly did Deepseek R1 achieve massive training cost …, https://www.reddit.com/r/MachineLearning/comments/1ibijhg/d_how_exactly_did_deepseek_r1_achieve_massive/</li>
<li>What went into training DeepSeek-R1? - Epoch AI, https://epoch.ai/gradient-updates/what-went-into-training-deepseek-r1</li>
<li>DeepSeek-R1: Incentivizing Reasoning Capability in LLMs … - arXiv, https://arxiv.org/pdf/2501.12948</li>
<li>Enhancing Reasoning in LLMs with DeepSeek-R1 - Medium, https://medium.com/@galhyams/enhancing-reasoning-in-llms-with-deepseek-r1-a-technical-blogpost-reinforcement-learning-and-d76a61ffbd01</li>
<li>Why Reinforcement Learning Beats SFT with Limited Data - Predibase, https://predibase.com/blog/how-reinforcement-learning-beats-supervised-fine-tuning-when-data-is-scarce</li>
<li>Understanding the Math Behind GRPO — DeepSeek-R1-Zero, https://medium.com/yugen-ai-technology-blog/understanding-the-math-behind-grpo-deepseek-r1-zero-9fb15e103a0a</li>
<li>GRPO and DeepSeek-R1-Zero. Table of Contents | by Shakti …, https://pub.towardsai.net/grpo-and-deepseek-r1-zero-9e81f15c6ba2</li>
<li>Exploring DeepSeek’s R1 Training Process | Towards Data Science, https://towardsdatascience.com/exploring-deepseeks-r1-training-process-5036c42deeb1/</li>
<li>Can anybody explain how the RL portion of DeepSeek works?, https://www.reddit.com/r/learnmachinelearning/comments/1ichl3z/can_anybody_explain_how_the_rl_portion_of/</li>
<li>FareedKhan-dev/train-deepseek-r1 - GitHub, https://github.com/FareedKhan-dev/train-deepseek-r1</li>
<li>DeepSeek-R1 : internals made easy - DEV Community, https://dev.to/prathameshdevadiga/deepseek-r1-internals-made-easy-16ia</li>
<li>How DeepSeek-R1 Leverages Reinforcement Learning to Master …, https://huggingface.co/blog/NormalUhr/deepseek-r1-explained</li>
<li>Developers caught DeepSeek R1 having an ‘aha moment’ on its …, https://www.reddit.com/r/Futurology/comments/1ifd5r1/developers_caught_deepseek_r1_having_an_aha/</li>
<li>DeepSeek R-1 Model Overview and How it Ranks Against OpenAI’s …, https://www.prompthub.us/blog/deepseek-r-1-model-overview-and-how-it-ranks-against-openais-o1</li>
<li>Lessons on reproducing R1-like reasoning in small LLMs, https://developers.redhat.com/articles/2025/02/25/lessons-reproducing-r1-reasoning-small-llms</li>
<li>DeepSeek R1 Just Got Eyes with Fireworks AI Document Inlining, https://fireworks.ai/blog/deepseek-r1-got-eyes</li>
<li>DeepSeek-R1: Incentivizing Reasoning Capability in LLMs … - arXiv, https://arxiv.org/html/2501.12948v1</li>
<li>The Complete Guide to DeepSeek Models: V3, R1, V3.1, V3.2 and …, https://www.bentoml.com/blog/the-complete-guide-to-deepseek-models-from-v3-to-r1-and-beyond</li>
<li>DeepSeek: sorting through the hype - IBM, https://www.ibm.com/think/topics/deepseek</li>
<li>deepseek-ai/DeepSeek-R1 - Hugging Face, https://huggingface.co/deepseek-ai/DeepSeek-R1</li>
<li>DeepSeek-R1 - GitHub, https://github.com/deepseek-ai/DeepSeek-R1</li>
<li>DeepSeek-R1 Overview: Features, Capabilities, Parameters, https://fireworks.ai/blog/deepseek-r1-deepdive</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>