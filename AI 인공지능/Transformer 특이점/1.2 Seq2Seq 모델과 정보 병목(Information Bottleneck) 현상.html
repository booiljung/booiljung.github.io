<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.2 Seq2Seq 모델과 정보 병목(Information Bottleneck) 현상</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.2 Seq2Seq 모델과 정보 병목(Information Bottleneck) 현상</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>1.2 Seq2Seq 모델과 정보 병목(Information Bottleneck) 현상</span></nav>
                </div>
            </header>
            <article>
                <h1>1.2 Seq2Seq 모델과 정보 병목(Information Bottleneck) 현상</h1>
<p>2025-12-17, G30DR</p>
<p>인공지능과 자연어 처리(Natural Language Processing, NLP)의 역사에서 2014년은 분수령이 되는 해였다. 이전까지 기계 번역은 통계적 기계 번역(Statistical Machine Translation, SMT)의 지배하에 있었으며, 이는 수많은 언어학적 규칙과 확률 테이블, 그리고 복잡한 파이프라인에 의존하는 방식이었다. 그러나 일리야 수츠케버(Ilya Sutskever)와 조경현(Kyunghyun Cho) 등을 위시한 연구자들은 이러한 복잡한 공정을 하나의 거대한 신경망으로 대체하려는 대담한 시도를 감행했다. 이것이 바로 시퀀스-투-시퀀스(Sequence-to-Sequence, 이하 Seq2Seq) 모델의 탄생이다. Seq2Seq는 입력 시퀀스를 읽어들여 출력 시퀀스를 생성하는 ‘엔드-투-엔드(End-to-End)’ 학습의 가능성을 증명하며 딥러닝 번역의 시대를 열었다. 하지만 이 혁신적인 아키텍처는 그 태생적 구조로 인해 치명적인 한계를 내포하고 있었으니, 바로 ‘정보 병목(Information Bottleneck)’ 현상이다. 본 장에서는 Seq2Seq 모델의 수학적 원리와 작동 기제를 심층적으로 분석하고, 가변 길이의 정보를 고정된 크기의 벡터로 압축하려는 시도가 필연적으로 마주할 수밖에 없었던 한계와 그로 인한 성능 저하의 원인을 규명한다. 또한, 이 병목 현상을 완화하기 위해 당시 연구자들이 고안해낸 공학적 기법들과 그 한계점까지 포괄적으로 논의한다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "통계적 기계 번역 (SMT)"
        A1["입력 텍스트"] --&gt; B1["언어학적 규칙 적용"]
        B1 --&gt; C1["확률 테이블 조회"]
        C1 --&gt; D1["복잡한 파이프라인 처리"]
        D1 --&gt; E1["번역 결과"]
    end

    subgraph "Seq2Seq (Neural MT)"
        A2["입력 시퀀스"] --&gt; B2["거대한 단일 신경망 (Encoder-Decoder)"]
        B2 --&gt; C2["출력 시퀀스"]
    end

    style B2 fill:#f9f,stroke:#333,stroke-width:4px
    style D1 fill:#eee,stroke:#333,stroke-dasharray: 5 5
</code></pre>
<h2>1.  인코더-디코더(Encoder-Decoder) 아키텍처의 수학적 원리</h2>
<p>Seq2Seq 모델의 등장은 단순히 새로운 알고리즘의 제안을 넘어, 기계가 언어를 이해하고 생성하는 방식을 재정의한 사건이었다. 이 모델의 핵심은 두 개의 순환 신경망(Recurrent Neural Network, RNN)을 결합한 인코더-디코더(Encoder-Decoder) 구조에 있다.1 인코더는 입력 언어를 기계가 이해할 수 있는 추상적인 수학적 표현으로 변환하고, 디코더는 그 표현을 다시 타겟 언어로 복원해낸다. 이 과정은 인간이 타인의 말을 듣고(Encoding), 그 의미를 머릿속에서 정리한 뒤(Contextualizing), 자신의 언어로 다시 말하는(Decoding) 인지 과정과 유사하다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "인간의 인지 과정"
        H1["듣기 (Encoding)"] --&gt; H2["뇌: 의미 정리 (Contextualizing)"]
        H2 --&gt; H3["말하기 (Decoding)"]
    end

    subgraph "Seq2Seq 모델 구조"
        M1["입력 언어 (Source)"] --&gt; M2["인코더 RNN"]
        M2 --&gt; M3["문맥 벡터 c (수학적 추상화)"]
        M3 --&gt; M4["디코더 RNN"]
        M4 --&gt; M5["타겟 언어 (Target)"]
    end

    H1 -.-&gt; M2
    H2 -.-&gt; M3
    H3 -.-&gt; M4
    
    style M3 fill:#ff9,stroke:#333,stroke-width:2px
</code></pre>
<h3>1.1  인코더: 가변 길이 시퀀스의 압축</h3>
<p>인코더의 역할은 가변 길이의 입력 시퀀스 <span class="math math-inline">X = (x_1, x_2,..., x_T)</span>를 처리하여 그 의미를 고정된 차원의 벡터 공간에 투영하는 것이다. 여기서 <span class="math math-inline">x_t</span>는 텍스트 데이터의 최소 단위인 토큰(Token)을 의미하며, 일반적으로 원-핫 인코딩(One-hot Encoding)을 거쳐 워드 임베딩(Word Embedding) 벡터로 변환된 형태를 띤다. RNN 인코더는 각 시점(time step) <span class="math math-inline">t</span>마다 현재의 입력 <span class="math math-inline">x_t</span>와 이전 시점의 은닉 상태(hidden state) <span class="math math-inline">h_{t-1}</span>을 받아 현재의 은닉 상태 <span class="math math-inline">h_t</span>를 갱신한다.3</p>
<p>이를 수식으로 표현하면 다음과 같다:<br />
<span class="math math-display">
h_t = f(x_t, h_{t-1})
</span><br />
여기서 <span class="math math-inline">f</span>는 비선형 활성화 함수를 포함한 신경망 연산을 의미한다. 가장 기본적인 바닐라 RNN(Vanilla RNN)의 경우, 이 함수는 다음과 같이 정의된다:<br />
<span class="math math-display">
h_t = \tanh(W_{ih} x_t + b_{ih} + W_{hh} h_{t-1} + b_{hh})
</span><br />
이때 <span class="math math-inline">W_{ih}</span>는 입력 벡터를 은닉 상태 공간으로 변환하는 가중치 행렬이고, <span class="math math-inline">W_{hh}</span>는 이전 은닉 상태의 정보를 현재로 전달하는 순환 가중치 행렬이다.2 <span class="math math-inline">\tanh</span>는 -1과 1 사이의 값을 출력하여 그래디언트의 폭주를 제어하는 비선형 활성화 함수이다.</p>
<p>인코더는 시퀀스의 첫 번째 토큰 <span class="math math-inline">x_1</span>부터 마지막 토큰 <span class="math math-inline">x_T</span>까지 이 과정을 반복적으로 수행한다. 이 순차적 처리(Sequential Processing)의 결과로 생성되는 은닉 상태들의 시퀀스 <span class="math math-inline">(h_1, h_2,..., h_T)</span>는 입력 문장의 문맥적 흐름을 반영하게 된다. 특히, 마지막 시점의 은닉 상태 <span class="math math-inline">h_T</span>는 이론적으로 입력 시퀀스 전체의 정보를 요약하고 있는 것으로 간주된다. Seq2Seq 모델에서는 이 <span class="math math-inline">h_T</span>를 기반으로 <strong>문맥 벡터(Context Vector)</strong> <span class="math math-inline">c</span>를 생성한다.1<br />
<span class="math math-display">
c = q(h_1,..., h_T)
</span><br />
가장 단순한 형태의 Seq2Seq 모델, 예를 들어 수츠케버(Sutskever) 등이 제안한 모델에서는 <span class="math math-inline">q</span> 함수가 단순히 마지막 은닉 상태를 선택하는 함수로 정의된다. 즉, <span class="math math-inline">c = h_T</span>이다.5 조경현(Cho) 등의 모델에서도 유사하게 마지막 은닉 상태가 디코더의 초기 상태를 결정하거나 디코딩의 매 단계에 관여하는 방식으로 사용된다.6 이 문맥 벡터 <span class="math math-inline">c</span>는 가변 길이의 입력 문장이 지닌 의미론적(Semantic), 구문론적(Syntactic) 정보를 고정된 길이의 실수 벡터(Fixed-length real-valued vector) <span class="math math-inline">\mathbb{R}^d</span>로 압축한 결정체이다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "입력 시퀀스 처리 (Encoder)"
        X1["x_1"] --&gt; H1["h_1 = f(x_1, h_0)"]
        X2["x_2"] --&gt; H2["h_2 = f(x_2, h_1)"]
        X3["x_3"] --&gt; H3["h_3 = f(x_3, h_2)"]
        XT["... x_T"] --&gt; HT["h_T (마지막 은닉 상태)"]
        
        H1 --&gt; H2
        H2 --&gt; H3
        H3 -.-&gt; HT
    end

    subgraph "정보 압축"
        HT --&gt; C["문맥 벡터 c = q(h_1...h_T)"]
        C --&gt;|Fixed Size R^d| INFO["모든 문맥 정보가 압축됨"]
    end

    style C fill:#f96,stroke:#333,stroke-width:4px
</code></pre>
<h4>1.1.1  디코더: 조건부 확률 기반의 시퀀스 생성</h4>
<p>디코더는 인코더가 생성한 문맥 벡터 <span class="math math-inline">c</span>를 활용하여 타겟 시퀀스 <span class="math math-inline">Y = (y_1, y_2,..., y_{T&#39;})</span>를 생성하는 또 다른 RNN이다. 기계 번역의 관점에서 디코더의 목표는 입력 시퀀스 <span class="math math-inline">X</span>가 주어졌을 때, 타겟 시퀀스 <span class="math math-inline">Y</span>가 등장할 조건부 확률 <span class="math math-inline">P(Y|X)</span>를 최대화하는 것이다.3 이 확률은 연쇄 법칙(Chain Rule)에 의해 각 시점의 조건부 확률의 곱으로 분해될 수 있다.<br />
<span class="math math-display">
P(Y|X) = \prod_{i=1}^{T&#39;} P(y_i | y_1, y_2,..., y_{i-1}, c)
</span><br />
디코더 RNN은 매 시점 <span class="math math-inline">i</span>마다 이전 시점의 출력 <span class="math math-inline">y_{i-1}</span>, 이전 시점의 디코더 은닉 상태 <span class="math math-inline">s_{i-1}</span>, 그리고 문맥 벡터 <span class="math math-inline">c</span>를 입력으로 받아 현재의 은닉 상태 <span class="math math-inline">s_i</span>를 갱신하고, 이를 바탕으로 다음 단어 <span class="math math-inline">y_i</span>의 확률 분포를 예측한다.2<br />
<span class="math math-display">
s_i = g(y_{i-1}, s_{i-1}, c)
</span></p>
<p><span class="math math-display">
P(y_i | y_{&lt;i}, c) = \text{softmax}(W_{out} s_i + b_{out})
</span></p>
<p>여기서 <span class="math math-inline">g</span>는 디코더의 활성화 함수(LSTM 또는 GRU)이며, <span class="math math-inline">y_{&lt;i}</span>는 시점 <span class="math math-inline">i</span> 이전에 생성된 모든 단어들을 의미한다. 소프트맥스(Softmax) 함수는 디코더의 출력을 전체 어휘 집합(Vocabulary)에 대한 확률 분포로 변환하여, 가장 높은 확률을 가진 단어를 선택하거나 샘플링할 수 있게 한다.</p>
<p>디코딩 과정은 문장의 시작을 알리는 특수 토큰 <code>&lt;BOS&gt;</code>(Beginning of Sequence)가 입력되면서 시작되고, 문장의 끝을 알리는 <code>&lt;EOS&gt;</code>(End of Sequence) 토큰이 생성될 때까지 계속된다.9 훈련(Training) 시에는 ‘교사 강요(Teacher Forcing)’ 기법을 사용하여, 디코더의 입력으로 모델이 예측한 값이 아닌 정답(Ground Truth) 단어를 주입함으로써 학습 속도와 안정성을 높인다.2 반면 추론(Inference) 시에는 모델이 이전에 생성한 단어를 다음 단계의 입력으로 사용하는 자기회귀적(Autoregressive) 방식을 따른다.</p>
<p>이러한 인코더-디코더 구조는 입력과 출력의 길이가 달라도 처리가 가능하다는 엄청난 유연성을 제공했다. “I love you“라는 3단어 문장이 “나는 너를 사랑해“라는 4어절 문장으로 번역되거나, 긴 영어 문장이 더 짧은 한국어 문장으로 번역되는 것이 수학적으로 자연스럽게 모델링된 것이다. 그러나 이 우아한 구조의 이면에는 ’고정 길이 벡터’라는 제약 조건이 만들어낸 거대한 장벽이 존재했다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "디코더의 한 시점 (Time Step i)"
        Input1["이전 단어 y_{i-1}"] --&gt; G["g (LSTM/GRU Unit)"]
        Input2["이전 상태 s_{i-1}"] --&gt; G
        Input3["문맥 벡터 c"] --&gt; G
        
        G --&gt; Si["현재 은닉 상태 s_i"]
        Si --&gt; Linear["선형 변환 (W_out * s_i)"]
        Linear --&gt; Softmax["Softmax 함수"]
        Softmax --&gt; Prob["확률 분포 P(y_i | y_{&lt;i}, c)"]
        Prob --&gt; Sample["단어 선택/샘플링 (y_i)"]
    end
</code></pre>
<h3>1.2  정보 병목(Information Bottleneck) 현상의 본질</h3>
<p>Seq2Seq 모델이 직면한 가장 근본적인 문제는 **“모든 정보를 고정된 크기의 벡터에 압축해야 한다”**는 전제 그 자체였다. 이를 학계에서는 ‘정보 병목(Information Bottleneck)’ 현상이라 칭한다.11 이 현상은 단순히 모델의 성능을 제한하는 요소를 넘어, 심층 신경망이 언어와 같은 복잡한 시퀀스 데이터를 처리할 때 겪는 정보 이론적 한계를 드러낸다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Input Source (High Entropy)"
        I1["긴 문장"]
        I2["복잡한 수사 구조"]
        I3["미묘한 뉘앙스"]
        I4["지시 대명사 관계"]
    end

    I1 &amp; I2 &amp; I3 &amp; I4 --&gt; BOTTLENECK

    subgraph "Information Bottleneck"
        BOTTLENECK((("고정 길이 벡터 c\n(Fixed Capacity R^d)")))
    end

    BOTTLENECK --&gt; LOSS

    subgraph "Resulting Issues"
        LOSS["정보 손실 (Lossy Compression)"]
        LOSS --&gt; O1["의미의 편류"]
        LOSS --&gt; O2["세부 정보 소거"]
        LOSS --&gt; O3["성능 저하"]
    end

    style BOTTLENECK fill:#f00,color:#fff,stroke:#333,stroke-width:4px
</code></pre>
<h4>1.2.1  고정 용량 대 무한한 엔트로피</h4>
<p>정보 이론(Information Theory)의 관점에서 볼 때, 문장의 길이는 그 문장이 담을 수 있는 정보량, 즉 엔트로피(Entropy)와 양의 상관관계를 가진다. 짧은 인사말에는 적은 양의 정보가 담기지만, 긴 법률 문서나 문학 작품의 문장에는 단어의 표면적 의미뿐만 아니라 복잡한 수사 구조, 지시 대명사의 연결 관계, 시제, 뉘앙스 등 방대한 정보가 포함된다. 이론적으로 입력 문장 <span class="math math-inline">X</span>의 길이가 길어질수록, 이를 손실 없이 표현하기 위해 필요한 비트(bit) 수는 증가한다.</p>
<p>그러나 Seq2Seq 모델의 문맥 벡터 <span class="math math-inline">c</span>는 차원 <span class="math math-inline">d</span>가 고정된 벡터 공간 <span class="math math-inline">\mathbb{R}^d</span>에 속한다. 예를 들어, <span class="math math-inline">d=1000</span>인 경우, 모델은 5단어 문장이든 100단어 문장이든 상관없이 모든 정보를 1000개의 실수 값으로 표현해야 한다. 이는 가변적인 엔트로피를 가진 소스를 고정된 용량(Capacity)의 채널로 전송하려는 시도와 같다.11</p>
<p>문장이 짧을 때는 <span class="math math-inline">\mathbb{R}^d</span> 공간이 정보를 담기에 충분히 넓을 수 있다. 하지만 문장이 길어지면 벡터 공간 내에서 정보를 구별하는 해상도(Resolution)가 급격히 떨어진다. 서로 다른 의미를 가진 긴 문장들이 벡터 공간 상에서 매우 인접한 위치에 매핑되거나(Co-location), 중요한 세부 정보(예: 문장 초반에 등장한 주어의 성별이나 수)가 벡터화 과정에서 소거(Lossy Compression)되는 현상이 발생한다. 바다나우(Bahdanau) 등은 이를 두고 “고정 길이 벡터의 사용이 기본 인코더-디코더 구조의 성능 향상에 병목이 된다“고 명확히 지적했다.15</p>
<h4>1.2.2  그래디언트의 여정과 장기 의존성(Long-term Dependencies)</h4>
<p>정보 병목 현상은 학습 과정인 역전파(Backpropagation) 시에도 심각한 문제를 야기한다. 디코더가 문장을 생성하다가 오류를 범했을 때, 그 오류 신호(Error Signal)는 디코더의 타임 스텝을 거슬러 올라가 문맥 벡터 <span class="math math-inline">c</span>를 통과하고, 다시 인코더의 타임 스텝을 거슬러 입력 시퀀스의 해당 부분까지 도달해야 한다.<br />
<span class="math math-display">
\frac{\partial L}{\partial W} = \sum_{t} \frac{\partial L_t}{\partial y_t} \cdot \frac{\partial y_t}{\partial c} \cdot \frac{\partial c}{\partial h_{enc}} \cdot...
</span><br />
이 경로는 시퀀스의 길이가 길어질수록 기하급수적으로 길어진다. 수츠케버(Sutskever) 등의 연구에서도 지적되었듯이, RNN은 깊은 시간적 깊이(Temporal Depth)를 가질 때 ‘그래디언트 소실(Vanishing Gradient)’ 또는 ‘그래디언트 폭주(Exploding Gradient)’ 문제에 취약하다.5 비록 LSTM이나 GRU와 같은 게이트 구조가 이를 완화하기 위해 도입되었지만, 수십 단어 이상의 거리를 거쳐 문맥 벡터라는 좁은 통로(Bottleneck) 하나만을 통해 오류 신호를 전달하는 것은 여전히 난해한 최적화 문제로 남았다. 결과적으로 인코더의 앞부분에 위치한 정보일수록 업데이트가 제대로 이루어지지 않거나, 디코더가 이를 망각(Forget)하는 경향이 뚜렷해진다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Decoder (Error Signal Start)"
        Err["오류 발생 (Error L)"] --&gt; Dy["dy_t"]
        Dy --&gt; Ds["ds_t"]
    end

    Ds -.-&gt; |"Long Path Backwards"| C_VEC

    subgraph "The Bottleneck"
        C_VEC(("문맥 벡터 c"))
    end

    C_VEC -.-&gt; |"Weakened Gradient"| Enc_End

    subgraph "Encoder (Gradient Vanishing)"
        Enc_End["dh_T"] --&gt; Enc_Mid["..."]
        Enc_Mid --&gt; Enc_Start["dh_1 (업데이트 미미함)"]
    end

    style C_VEC fill:#f96,stroke:#333
    style Enc_Start fill:#ccc,color:#666
</code></pre>
<h3>1.3  실험적 증거: 문장 길이와 성능의 반비례 관계</h3>
<p>이러한 이론적 한계는 실제 기계 번역 실험 결과에서 명확한 데이터로 입증되었다. 2014년 조경현(Cho) 교수와 요슈아 벤지오(Yoshua Bengio) 교수 팀이 발표한 “On the Properties of Neural Machine Translation: Encoder–Decoder Approaches” 논문은 Seq2Seq 모델이 문장 길이에 따라 어떤 거동을 보이는지 정밀하게 분석했다.18</p>
<pre><code class="language-mermaid">graph TD
    subgraph "문장 길이 구간별 성능 (BLEU)"
        L1["10~20 단어"] --&gt; |"매우 높음 (SMT 상회)"| P1["Excellent"]
        L2["20~30 단어"] --&gt; |"높음 (유지)"| P2["Good"]
        L3["30~40 단어"] --&gt; |"하락 시작"| P3["Decline"]
        L4["40~50 단어"] --&gt; |"급격한 하락 (Bottleneck)"| P4["Rapid Degradation"]
        L5["50 단어 이상"] --&gt; |"매우 낮음 (실패)"| P5["Failure"]
    end
    
    style P4 fill:#f00,color:#fff
    style P5 fill:#000,color:#fff
</code></pre>
<h4>1.3.1  BLEU 점수의 급격한 하락</h4>
<p>연구진은 WMT’14 영어-프랑스어 번역 태스크를 통해 RNN 인코더-디코더(RNNenc) 모델의 성능을 평가했다. 그들은 테스트 데이터셋의 문장들을 길이별로 구간을 나누어 BLEU(Bilingual Evaluation Understudy) 점수를 측정했다. BLEU 점수는 기계 번역의 품질을 정량적으로 평가하는 지표로, 수치가 높을수록 인간의 번역과 유사함을 의미한다.</p>
<p>다음 표는 해당 연구 및 관련 연구들에서 관찰된 문장 길이별 성능 추이를 요약하여 재구성한 것이다16:</p>
<table><thead><tr><th><strong>문장 길이 (단어 수)</strong></th><th><strong>기존 SMT (Moses) 성능 추이</strong></th><th><strong>RNNenc (Seq2Seq) 성능 추이</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td>10 ~ 20 단어</td><td>높음 (안정적)</td><td><strong>매우 높음</strong> (SMT 상회 가능)</td><td>단문에서 Seq2Seq의 우수성 입증</td></tr>
<tr><td>20 ~ 30 단어</td><td>높음 (안정적)</td><td>높음 (유지)</td><td>LSTM/GRU의 효과적 정보 보존</td></tr>
<tr><td>30 ~ 40 단어</td><td>중간 (완만한 하락)</td><td><strong>하락 시작</strong></td><td>정보 병목의 영향 가시화</td></tr>
<tr><td>40 ~ 50 단어</td><td>중간 (완만한 하락)</td><td><strong>급격한 하락 (Rapid Degradation)</strong></td><td>벡터 용량 초과</td></tr>
<tr><td>50 단어 이상</td><td>낮음</td><td><strong>매우 낮음 (Translating Failure)</strong></td><td>문맥 정보 소실 심각</td></tr>
</tbody></table>
<p>분석 결과, 문장의 길이가 30단어 미만일 때는 Seq2Seq 모델이 기존의 통계적 번역 시스템(Moses 등)과 대등하거나 오히려 더 높은 유창성(Fluency)을 보여주었다. 이는 신경망이 단어 간의 국소적 관계와 문장 구조를 학습하는 데 탁월함을 시사한다. 그러나 문장 길이가 30단어를 넘어가면서부터 성능 그래프는 꺾이기 시작했고, 50단어 이상의 장문에서는 성능이 바닥으로 곤두박질치는 양상이 관찰되었다.16</p>
<p>그래프 상에서 RNNenc 모델의 곡선은 문장 길이가 길어질수록 우하향하는 기울기가 매우 가팔랐던 반면, 어텐션 메커니즘이 적용된 후속 모델(RNNsearch)은 길이 50 이상의 문장에서도 성능 저하가 거의 없이 수평선을 유지했다.16 이는 고정 길이 벡터가 명백한 성능의 병목임을 보여주는 결정적인 증거였다.</p>
<h4>1.3.2  질적 분석: 무엇을 잊어버리는가?</h4>
<p>정량적 수치뿐만 아니라, 실제 번역된 문장을 뜯어보면 정보 병목의 실체가 더 적나라하게 드러난다. 긴 문장을 번역할 때 Seq2Seq 모델은 다음과 같은 오류 패턴을 보였다15:</p>
<ol>
<li><strong>의미의 편류(Drift of Meaning):</strong> 문장의 초반부는 정확하게 번역하다가, 중반 이후부터 문맥을 잃고 횡설수설하거나 주제와 무관한 단어를 생성한다. 인코더가 초반부 정보를 벡터에 압축했으나, 후반부 정보를 처리하는 과정에서 덮어씌워지거나 희석되었기 때문이다.</li>
<li><strong>생략(Omission):</strong> 문장 내의 중요한 수식어나 부사구, 혹은 주어 자체가 번역 결과에서 통째로 사라진다. 고정된 벡터 공간이 ‘덜 중요하다고 판단된’ 정보를 버리는 과정(손실 압축)에서 발생한다.</li>
<li><strong>반복(Repetition):</strong> 디코더가 문맥을 잃어버렸을 때, 이전에 생성했던 단어를 반복하거나 특정 패턴을 무한 루프처럼 생성하는 현상이 나타난다.</li>
</ol>
<p>이는 모델이 긴 시퀀스의 전체적인 구조(Global Structure)와 세부적인 정보(Local Detail)를 동시에 유지하지 못하고 있음을 방증한다.</p>
<h3>1.4  병목을 극복하기 위한 초기 공학적 시도들</h3>
<p>Seq2Seq 모델의 창시자들은 이러한 한계를 인지하고 있었으며, 어텐션 메커니즘이라는 근본적인 해결책이 등장하기 전까지, 이 병목을 우회하기 위한 다양한 공학적 기법(Heuristics)들을 고안해냈다.</p>
<h4>1.4.1  소스 문장 뒤집기 (Reversing the Source Sentence)</h4>
<p>수츠케버(Sutskever) 등은 2014년 NIPS 논문에서 매우 간단하지만 놀라울 정도로 효과적인 ’트릭’을 소개했다. 바로 입력 문장의 단어 순서를 거꾸로 뒤집어서 인코더에 주입하는 것이다.5 예를 들어, 영어 문장 “A B C“를 프랑스어 “<span class="math math-inline">\alpha \beta \gamma</span>“로 번역한다고 할 때, 인코더에 “C B A” 순서로 입력하고 디코더가 “<span class="math math-inline">\alpha \beta \gamma</span>“를 생성하도록 학습시키는 것이다.</p>
<p>이 기법의 핵심 원리는 **‘최소 시간 지연(Minimal Time Lag)’**의 단축에 있다.24</p>
<ul>
<li><strong>정방향 입력 (A, B, C <span class="math math-inline">\rightarrow</span> <span class="math math-inline">\alpha, \beta, \gamma</span>):</strong> 소스 문장의 첫 단어 A는 인코더의 첫 번째 스텝에서 처리된다. 그러나 디코더가 이에 대응하는 첫 단어 <span class="math math-inline">\alpha</span>를 생성하려면 전체 입력 시퀀스(A, B, C)와 <code>&lt;EOS&gt;</code>까지 모두 처리된 후에야 비로소 시작된다. 즉, A와 <span class="math math-inline">\alpha</span> 사이의 거리가 멀어(Long Term Dependency), 그래디언트가 전달되기 어렵다.</li>
<li><strong>역방향 입력 (C, B, A <span class="math math-inline">\rightarrow</span> <span class="math math-inline">\alpha, \beta, \gamma</span>):</strong> 소스 문장의 마지막으로 입력되는 A는 디코더가 생성할 첫 단어 <span class="math math-inline">\alpha</span>와 시간적으로 바로 인접하게 된다. 즉, 인코더의 마지막 스텝(A 처리) 직후에 디코더의 첫 스텝(<span class="math math-inline">\alpha</span> 생성)이 이어진다.</li>
</ul>
<p>이렇게 하면 소스 문장의 앞부분(A)과 타겟 문장의 앞부분(<span class="math math-inline">\alpha</span>) 사이에 ’단기 의존성(Short-term Dependency)’이 형성된다. 수츠케버는 이를 두고 “소스와 타겟 문장 사이에 많은 단기 의존성을 도입함으로써 최적화 문제(Optimization Problem)를 훨씬 쉽게 만들었다“고 설명했다.5 실험 결과, 문장을 뒤집는 것만으로도 LSTM 모델의 BLEU 점수가 25.9에서 30.6으로 비약적으로 상승했으며, 긴 문장에 대한 처리 능력도 크게 개선되었다.23</p>
<p>이 발견은 흥미로운 시사점을 준다. 정보 병목 현상은 물리적인 벡터 크기의 한계뿐만 아니라, 최적화 과정에서 정보가 전달되는 ’경로(Path)’의 효율성 문제와도 깊게 연관되어 있다는 것이다. 역방향 입력은 병목(벡터 <span class="math math-inline">c</span>) 자체를 넓히지는 못했지만, 병목을 통과해야 하는 정보의 우선순위를 재배치하여 학습 효율을 극대화한 전략이었다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "정방향 입력 (A, B, C -&gt; a, b, c)"
        A1["In: A"] --&gt; B1["In: B"] --&gt; C1["In: C"] 
        C1 --&gt; V1(("Vector")) 
        V1 --&gt; Out_a1["Out: a"] --&gt; Out_b1["Out: b"]
        
        linkStyle 3 stroke-width:2px,fill:none,stroke:red;
        A1 -.-&gt; |"먼 거리 (Long Term Dependency)"| Out_a1
    end

    subgraph "역방향 입력 (C, B, A -&gt; a, b, c)"
        C2["In: C"] --&gt; B2["In: B"] --&gt; A2["In: A"]
        A2 --&gt; V2(("Vector"))
        V2 --&gt; Out_a2["Out: a"] --&gt; Out_b2["Out: b"]

        linkStyle 8 stroke-width:4px,fill:none,stroke:green;
        A2 -.-&gt; |"짧은 거리 (Direct Connection)"| Out_a2
    end
</code></pre>
<h4>1.4.2  LSTM과 GRU: 기억 용량의 확장</h4>
<p>기본적인 RNN이 가진 ‘기억력 감퇴’ 문제를 해결하기 위해 도입된 LSTM(Long Short-Term Memory)과 GRU(Gated Recurrent Unit) 역시 정보 병목 현상을 완화하는 데 중요한 역할을 했다.</p>
<ul>
<li><strong>LSTM:</strong> 1997년 호크라이터(Hochreiter)와 슈미트후버(Schmidhuber)가 제안한 LSTM은 셀 상태(Cell State)라는 별도의 정보 고속도로를 두어 그래디언트가 변질되지 않고 오래 흐를 수 있게 설계되었다.5 수츠케버의 모델은 4개의 층(Layer)을 쌓은 깊은 LSTM(Deep LSTM)을 사용하여 모델의 표현력과 기억 용량을 극대화했다. 층을 깊게 쌓을수록 모델은 더 추상적이고 고차원적인 정보를 벡터에 담을 수 있게 된다.</li>
<li><strong>GRU:</strong> 조경현 교수가 제안한 GRU는 LSTM의 복잡한 구조를 단순화하면서도 유사한 성능을 내도록 설계되었다.6 GRU는 업데이트 게이트(Update Gate)와 리셋 게이트(Reset Gate)를 통해 과거의 정보를 얼마나 유지할지, 새로운 정보를 얼마나 받아들일지를 동적으로 조절한다.</li>
</ul>
<p>이러한 게이트 기반 유닛들은 인코더가 문맥 벡터 <span class="math math-inline">c</span>를 생성할 때, 문장의 핵심 정보를 선별적으로 저장(Selective Memory)할 수 있게 도와주었다. 이는 제한된 벡터 공간을 효율적으로 활용하려는 시도였으며, 실제로 바닐라 RNN에 비해 월등히 긴 문장을 처리할 수 있게 해주었다. 하지만 이것이 ’무한한 길이’에 대한 해답이 될 수는 없었다. 문장이 일정 길이(약 50~80단어)를 넘어서면 LSTM의 셀 상태조차 포화(Saturation)되어 더 이상의 정보를 담을 수 없게 되기 때문이다.</p>
<h4>1.4.3  빔 서치(Beam Search) 디코딩</h4>
<p>학습 단계가 아닌 추론(Inference) 단계에서의 보완책으로는 빔 서치(Beam Search)가 사용되었다.21 디코더가 단어를 생성할 때, 매 시점 가장 높은 확률을 가진 단어 하나만 선택하는 그리디(Greedy) 방식은 한 번의 실수가 전체 번역을 망칠 위험이 있다. 특히 문맥 벡터의 정보가 불완전할 경우 초반의 예측 실수는 치명적이다.</p>
<p>빔 서치는 매 시점 상위 <span class="math math-inline">k</span>개(Beam Width)의 유력한 후보 시퀀스를 유지하며 끝까지 탐색하는 방식이다. 이는 인코더가 넘겨준 문맥 벡터 <span class="math math-inline">c</span>의 정보가 다소 모호하더라도, 디코더가 여러 가능성을 타진해보며 문맥적으로 가장 그럴듯한 전체 문장을 찾아내도록 돕는다. 이는 병목으로 인해 손실된 정보를 디코더의 언어 모델링 능력(Language Modeling Capability)으로 일부 보정하려는 시도로 볼 수 있다.</p>
<pre><code class="language-mermaid">graph TD
    Root(("Start")) --&gt; A["A (0.4)"]
    Root --&gt; B["B (0.5) - Keep"]
    Root --&gt; C["C (0.1)"]
    
    B --&gt; BA["B-&gt;A (0.2)"]
    B --&gt; BB["B-&gt;B (0.6) - Keep"]
    B --&gt; BC["B-&gt;C (0.2)"]

    BB --&gt; BBA["..."]
    BB --&gt; BBB["..."]

    style B fill:#bfb,stroke:#333
    style BB fill:#bfb,stroke:#333
    style A fill:#f99,stroke:none
    style C fill:#f99,stroke:none
</code></pre>
<h3>1.5  결론: 필연적이었던 어텐션(Attention)의 도래</h3>
<p>1.2절에서 살펴본 바와 같이, 초기 Seq2Seq 모델은 기계 번역의 패러다임을 혁명적으로 바꾸었으나, **‘고정 길이 문맥 벡터’**라는 구조적 족쇄로 인해 정보 병목 현상에서 자유로울 수 없었다. 수츠케버의 문장 뒤집기나 조경현의 GRU와 같은 기발한 아이디어들은 이 병목의 영향을 지연시키거나 완화했을 뿐, 근본적으로 해결하지는 못했다.</p>
<p>가변적인 인간의 언어를 고정된 기계의 그릇에 억지로 구겨 넣으려는 시도는, 정보의 손실을 동반할 수밖에 없는 ‘손실 압축(Lossy Compression)’ 과정이었다. 문장이 길어질수록, 정보가 풍부해질수록 이 압축의 대가는 커졌다. 결국 연구자들은 깨달았다. 인코더가 모든 짐을 짊어지고 단 하나의 벡터만을 디코더에 넘겨주는 방식은 지속 가능하지 않다는 것을. 디코더가 필요할 때마다 인코더의 기억(Hidden States)을 다시 열어볼 수 있는 권한, 즉 <strong>‘어텐션(Attention)’</strong> 메커니즘의 도입은 이러한 정보 병목의 고통 속에서 필연적으로 탄생할 수밖에 없었던 운명적인 해법이었다. 다음 절에서는 이 어텐션이 어떻게 병목을 깨뜨리고 트랜스포머 싱귤래리티의 초석을 다졌는지 살펴볼 것이다.</p>
<h2>2. 참고 자료</h2>
<ol>
<li>Seq2seq - Wikipedia, https://en.wikipedia.org/wiki/Seq2seq</li>
<li>seq2seq Model - GeeksforGeeks, https://www.geeksforgeeks.org/machine-learning/seq2seq-model-in-machine-learning/</li>
<li>Encoders-Decoders, Sequence to Sequence Architecture. | by Nadeem | Analytics Vidhya, https://medium.com/analytics-vidhya/encoders-decoders-sequence-to-sequence-architecture-5644efbb3392</li>
<li>Deep Learning Lab 12-1: Seq2Seq Learning &amp; Neural Machine Translation - GitHub Pages, https://nthu-datalab.github.io/ml/labs/12-1_Seq2Seq-Learning_Neural-Machine-Translation/12-1_Seq2Seq-Learning_Neural-Machine-Translation_slide.pdf</li>
<li>Sequence to Sequence Learning with Neural Networks - NIPS papers, http://papers.neurips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf</li>
<li>[1406.1078] Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation - arXiv, https://arxiv.org/abs/1406.1078</li>
<li>Multi-task Sequence to Sequence Learning - Google Research, https://research.google.com/pubs/archive/44928.pdf</li>
<li>Introduction to Seq2Seq Models - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2020/08/a-simple-introduction-to-sequence-to-sequence-models/</li>
<li>Write a Sequence to Sequence (seq2seq) Model — Chainer 7.8.0 documentation, https://docs.chainer.org/en/v7.8.0/examples/seq2seq.html</li>
<li>10.7. Sequence-to-Sequence Learning for Machine Translation - Dive into Deep Learning, https://d2l.ai/chapter_recurrent-modern/seq2seq.html</li>
<li>Attention-Based Sequence-to-Sequence Model for Time Series Imputation - MDPI, https://www.mdpi.com/1099-4300/24/12/1798</li>
<li>Understanding the attention mechanism in sequence models - Jeremy Jordan, https://www.jeremyjordan.me/attention/</li>
<li>Information Bottleneck: Theory and Applications in Deep Learning - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC7764901/</li>
<li>On the Information Bottleneck Problems: Models, Connections, Applications and Information Theoretic Views - MDPI, https://www.mdpi.com/1099-4300/22/2/151</li>
<li>Neural Machine Translation by Jointly Learning to Align and Translate, https://arxiv.org/abs/1409.0473</li>
<li>Neural machine translation by - arXiv, https://arxiv.org/pdf/1409.0473</li>
<li>Sequence to Sequence Learning with Neural Networks - arXiv, https://arxiv.org/pdf/1409.3215</li>
<li>On the properties of neural machine translation: encoder-decoder approaches - ACL Anthology, https://aclanthology.org/www.mt-archive.info/10/SSST-2014-Cho.pdf</li>
<li>On the Properties of Neural Machine Translation: Encoder-Decoder …, https://arxiv.org/abs/1409.1259</li>
<li>On the Properties of Neural Machine Translation: Encoder–Decoder Approaches - ar5iv, https://ar5iv.labs.arxiv.org/html/1409.1259</li>
<li>Neural Machine Translation by Jointly Learning to Align and Translate (Sep 2014) - Notes by Lex Toumbourou, https://notesbylex.com/neural-machine-translation-by-jointly-learning-to-align-and-translate-sep-2014</li>
<li>A Hierarchical Latent Variable Encoder-Decoder Model for Generating Dialogues - AAAI Publications, https://ojs.aaai.org/index.php/AAAI/article/view/10983/10842</li>
<li>[1409.3215] Sequence to Sequence Learning with Neural Networks - arXiv, https://arxiv.org/abs/1409.3215</li>
<li>Why does LSTM performs better when the source target is reversed? (Seq2seq), https://datascience.stackexchange.com/questions/18402/why-does-lstm-performs-better-when-the-source-target-is-reversed-seq2seq</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>