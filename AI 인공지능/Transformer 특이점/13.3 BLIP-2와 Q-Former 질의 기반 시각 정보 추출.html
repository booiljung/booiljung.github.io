<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:13.3 BLIP-2와 Q-Former 질의 기반 시각 정보 추출</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>13.3 BLIP-2와 Q-Former 질의 기반 시각 정보 추출</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>13.3 BLIP-2와 Q-Former 질의 기반 시각 정보 추출</span></nav>
                </div>
            </header>
            <article>
                <h1>13.3 BLIP-2와 Q-Former 질의 기반 시각 정보 추출</h1>
<p>2025-12-23, G30DR</p>
<h2>1.  서론: 시각-언어 모델링의 병목과 질의 기반 접근의 태동</h2>
<p>인공지능의 역사에서 2023년은 대규모 언어 모델(LLM)과 시각적 인지 능력이 결합하여 진정한 의미의 멀티모달(Multimodal) 지능으로 진화하기 시작한 ‘특이점(Singularity)’의 시기로 기록된다. 이 거대한 흐름 속에서 BLIP-2(Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models)는 기존의 엔드-투-엔드(End-to-End) 학습 패러다임을 전복시키고, 모듈형 아키텍처의 가능성을 증명한 기념비적인 연구이다. 특히 본 장에서 심도 있게 다루고자 하는 **Q-Former(Querying Transformer)**는 서로 다른 차원과 특성을 가진 시각 정보와 언어 정보를 매개하는 혁신적인 ‘질의 기반(Query-based)’ 인터페이스를 제시함으로써, 효율적이고 강력한 시각 정보 추출의 새로운 표준을 정립하였다.</p>
<p>과거의 시각-언어 모델(VLM)들은 거대한 이미지 인코더와 텍스트 인코더를 처음부터 학습시키거나, 전체를 미세 조정(Fine-tuning)하는 방식에 의존했다. CLIP이나 ALIGN과 같은 모델들이 이 시기를 대표했으나, 이러한 접근법은 모델의 규모가 커질수록 기하급수적으로 증가하는 계산 비용과 데이터 요구량을 감당하기 어렵다는 본질적인 한계를 지니고 있었다.1 더욱이, 이미 텍스트 도메인에서 인간 수준의 추론 능력을 갖춘 LLM과 시각 도메인에서 뛰어난 성능을 입증한 ViT(Vision Transformer)가 존재함에도 불구하고, 이들을 결합하기 위해 막대한 자원을 재투입하는 것은 비효율의 극치였다.</p>
<p>BLIP-2는 이러한 문제의식에서 출발하여, “거인의 어깨 위에 올라타는” 전략을 취했다. 즉, 사전에 학습된 강력한 단일 모달리티(Unimodal) 모델들을 ‘동결(Frozen)’된 상태로 유지하고, 그 사이를 연결하는 경량화된 모듈만을 학습시키는 방식이다.3 이때 시각 정보의 홍수 속에서 언어 모델이 필요로 하는 핵심 정보만을 선별하여 추출하는 역할을 수행하는 것이 바로 Q-Former이다. Q-Former는 정보 이론의 ‘정보 병목(Information Bottleneck)’ 원리를 구현하여, 시각적 불확실성을 언어적 명확성으로 변환하는 결정적인 역할을 수행한다.2</p>
<p>본 보고서는 서적 ’트랜스포머 싱귤래리티’의 13.3장 내용을 중심으로, BLIP-2의 아키텍처적 혁신과 Q-Former의 작동 원리, 그리고 이를 통해 구현되는 질의 기반 시각 정보 추출 메커니즘을 아주 상세하게 분석한다. 나아가 2025년 현재의 시점에서 바라본 Q-Former의 위상과 후속 모델들에 미친 영향, 그리고 여전히 해결되지 않은 과제들까지 포괄적으로 논의하고자 한다.</p>
<h2>2.  Q-Former 아키텍처의 구조적 해부와 설계 철학</h2>
<p>Q-Former는 BLIP-2 아키텍처의 심장부로서, 동결된 이미지 인코더와 동결된 LLM 사이의 임피던스 불일치(Impedance Mismatch)를 해결하는 가교 역할을 수행한다. 그 구조는 표면적으로는 트랜스포머(Transformer)를 따르고 있지만, 이질적인 두 모달리티를 융합하기 위해 매우 정교하게 설계된 변형들을 포함하고 있다.</p>
<h3>2.1  이중 트랜스포머 구조 (Dual Transformer Structure)와 파라미터 공유</h3>
<p>Q-Former의 가장 독창적인 특징 중 하나는 내부적으로 두 개의 하위 모듈, 즉 **이미지 트랜스포머(Image Transformer)**와 **텍스트 트랜스포머(Text Transformer)**로 구성되어 있으면서도, 이들이 <strong>자기 주의(Self-Attention) 계층을 공유</strong>한다는 점이다.6</p>
<ol>
<li><strong>이미지 트랜스포머:</strong> 시각적 특징 추출을 담당한다. 동결된 이미지 인코더(ViT)로부터 출력된 패치 임베딩들과 상호작용하며, 이 과정에서 <strong>교차 주의(Cross-Attention)</strong> 메커니즘이 활용된다. 여기서 주목할 점은 이미지 트랜스포머가 이미지 전체를 처리하는 것이 아니라, 학습 가능한 질의 벡터(Query Vectors)를 입력으로 받아 시각 정보를 조회(Querying)한다는 것이다.</li>
<li><strong>텍스트 트랜스포머:</strong> 텍스트 입력을 처리하며, 텍스트 인코더와 디코더의 기능을 모두 수행할 수 있다. 텍스트 트랜스포머는 이미지 인코더와 직접 연결되지 않으며, 오직 공유된 자기 주의 계층을 통해 이미지 트랜스포머가 추출한 정보(질의 벡터에 담긴 정보)를 간접적으로 참조한다.8</li>
</ol>
<p>이러한 파라미터 공유 구조는 모델의 크기를 획기적으로 줄이는 동시에(약 1억 8,800만 파라미터), 시각 정보와 언어 정보가 동일한 임베딩 공간 내에서 상호작용하도록 강제하여 멀티모달 정렬(Alignment)의 효율성을 극대화한다.2</p>
<h3>2.2  학습 가능한 질의 벡터 (Learnable Query Embeddings): 정보의 병목</h3>
<p>Q-Former의 입력으로 사용되는 것은 일반적인 이미지 패치 토큰이 아닌, **학습 가능한 질의 벡터(Learnable Queries)**이다.10</p>
<ul>
<li><strong>차원과 개수:</strong> BLIP-2의 실험적 설정에서 질의 벡터의 개수는 32개이며, 각 벡터의 차원은 768차원이다(BERT-base의 은닉 차원과 동일). 이를 수식으로 표현하면 <span class="math math-inline">Z \in \mathbb{R}^{32 \times 768}</span>이 된다.2</li>
<li><strong>병목(Bottleneck)으로서의 역할:</strong> 입력 이미지는 일반적으로 ViT-L/14의 경우 <span class="math math-inline">257 \times 1024</span> (또는 ViT-g/14의 경우 더 큰 차원)의 방대한 특징 맵을 생성한다. Q-Former는 이 수백, 수천 개의 벡터를 단 32개의 질의 벡터로 압축한다. 이 과정에서 질의 벡터들은 이미지의 모든 세부 사항을 보존하는 것이 아니라, 텍스트 생성을 위해 가장 “유용한(Most Useful)” 정보만을 선별적으로 추출하도록 강제된다.2</li>
<li><strong>초기화 전략:</strong> Q-Former의 가중치는 사전 학습된 BERT-base 모델로 초기화된다. 이는 Q-Former가 언어적 처리 능력을 어느 정도 갖춘 상태에서 시작하도록 돕는다. 단, BERT 아키텍처에는 존재하지 않는 교차 주의(Cross-Attention) 계층은 무작위로 초기화되어 학습된다.2</li>
</ul>
<h3>2.3  교차 주의 메커니즘 (Cross-Attention Mechanism)의 작동 원리</h3>
<p>Q-Former의 각 트랜스포머 블록에는 교차 주의 계층이 삽입되어 있다. 이 계층은 질의 벡터가 동결된 이미지 인코더의 출력과 만나는 유일한 통로이다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
여기서 <span class="math math-inline">Q</span>는 Q-Former의 내부 상태(질의 벡터에서 유래)이며, <span class="math math-inline">K</span>와 <span class="math math-inline">V</span>는 동결된 이미지 인코더(ViT)의 출력 특징이다.10 이 메커니즘을 통해 32개의 질의 벡터는 고정된 이미지 특징의 방대한 정보 중 필요한 부분에 가중치(Attention Score)를 부여하여 정보를 ’풀링(Pooling)’하거나 ’증류(Distillation)’한다. 이는 마치 인간이 복잡한 장면을 볼 때 특정 객체나 영역에 시선을 집중(Attention)하는 것과 유사한 기제이다.</p>
<h2>3.  1단계 사전 학습: 시각-언어 표현 학습 (Vision-Language Representation Learning)</h2>
<p>Q-Former 학습의 첫 번째 단계는 LLM 연결 없이, 시각 정보와 언어 정보를 정렬(Alignment)하는 데 집중한다. 이 단계의 목표는 Q-Former가 텍스트와 의미론적으로 관련된 시각적 특징을 추출하는 능력을 배양하는 것이다. 이를 위해 BLIP-2는 세 가지의 상호 보완적인 손실 함수(ITC, ITM, ITG)를 도입하고, 각 목표에 최적화된 독창적인 <strong>어텐션 마스킹(Attention Masking)</strong> 전략을 적용한다.1</p>
<h3>3.1  이미지-텍스트 대조 학습 (Image-Text Contrastive Learning, ITC)</h3>
<p>ITC는 시각적 표현과 텍스트 표현이 공유된 특징 공간에서 서로 가까워지도록 학습하여, 상호 의존 정보(Mutual Information)를 극대화하는 것을 목표로 한다.12</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>설명</strong></th></tr></thead><tbody>
<tr><td><strong>목표</strong></td><td>양성 쌍(Positive Pair)의 유사도 최대화, 음성 쌍(Negative Pair)의 유사도 최소화</td></tr>
<tr><td><strong>마스킹 전략</strong></td><td><strong>단일 모달 마스크 (Unimodal Mask)</strong></td></tr>
<tr><td><strong>작동 방식</strong></td><td>질의 벡터와 텍스트 토큰이 서로를 볼 수 없도록 차단(Attention=0). 질의는 질의끼리, 텍스트는 텍스트끼리만 참조 가능.</td></tr>
<tr><td><strong>이유</strong></td><td>정보 유출(Information Leakage) 방지. 질의가 텍스트를 미리 보면 이미지 정보 추출 없이 정답 유추 가능.</td></tr>
</tbody></table>
<p>ITC 단계에서 Q-Former의 출력 질의 벡터 <span class="math math-inline">Z</span>와 텍스트 트랜스포머의 토큰 출력 벡터 간의 유사도가 계산된다. BLIP-2는 32개의 질의 벡터 중 텍스트와 가장 높은 유사도를 보이는 벡터를 선택하여 대조 손실을 계산함으로써, 질의 벡터들이 서로 다른 시각적 측면을 포착하도록 유도한다.5</p>
<h3>3.2  이미지-텍스트 매칭 (Image-Text Matching, ITM)</h3>
<p>ITM은 모델이 주어진 이미지와 텍스트가 실제로 일치하는 쌍인지 아닌지를 판별하는 이진 분류(Binary Classification) 작업이다. 이는 ITC보다 더 정밀한(Fine-grained) 정렬을 가능하게 한다.8</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>설명</strong></th></tr></thead><tbody>
<tr><td><strong>목표</strong></td><td>이미지-텍스트 쌍의 일치 여부 예측 (Match vs. Unmatch)</td></tr>
<tr><td><strong>마스킹 전략</strong></td><td><strong>양방향 마스크 (Bi-directional Mask)</strong></td></tr>
<tr><td><strong>작동 방식</strong></td><td>모든 질의 벡터와 텍스트 토큰이 서로를 자유롭게 참조(Full Attention).</td></tr>
<tr><td><strong>이유</strong></td><td>질의 벡터가 텍스트 정보를 인지한 상태에서 이미지를 다시 조회하여, 미세한 불일치를 감지하기 위함.</td></tr>
</tbody></table>
<p>이 과정에서 <strong>하드 네거티브 마이닝(Hard Negative Mining)</strong> 기법이 적용된다. 단순히 무작위로 오답을 고르는 것이 아니라, ITC 단계에서 모델이 헷갈려했던(높은 유사도를 보였으나 오답인) 샘플들을 선별하여 학습에 사용함으로써, 모델의 변별력을 극대화한다.8 출력된 질의 벡터 <span class="math math-inline">Z</span>는 분류기(Classifier)를 거쳐 매칭 점수(Logits)로 변환되며, 이들의 평균값이 최종 예측에 사용된다.</p>
<h3>3.3  이미지 기반 텍스트 생성 (Image-Grounded Text Generation, ITG)</h3>
<p>ITG는 Q-Former가 주어진 이미지를 바탕으로 텍스트를 생성하도록 훈련시키는 과정이다. 이는 Q-Former 자체가 텍스트 생성 능력을 갖추게 함으로써, 향후 LLM과의 연결성을 강화한다.2</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>설명</strong></th></tr></thead><tbody>
<tr><td><strong>목표</strong></td><td>이미지를 조건(Condition)으로 텍스트 토큰 시퀀스 생성 (Autoregressive Generation)</td></tr>
<tr><td><strong>마스킹 전략</strong></td><td><strong>멀티모달 인과 마스크 (Multimodal Causal Mask)</strong></td></tr>
<tr><td><strong>작동 방식</strong></td><td>질의 <span class="math math-inline">\rightarrow</span> 텍스트 참조 불가. 텍스트 <span class="math math-inline">\rightarrow</span> 모든 질의 및 이전 텍스트 참조 가능.</td></tr>
<tr><td><strong>이유</strong></td><td>질의가 텍스트를 보지 못하게 하여 순수하게 시각 정보만을 추출하도록 강제하고, 텍스트는 추출된 시각 정보를 바탕으로 생성.</td></tr>
</tbody></table>
<p>이 단계에서는 텍스트 생성의 시작을 알리기 위해 토큰 대신 **** 토큰을 문장의 첫 번째 토큰으로 사용한다.1 ITG 손실 함수는 질의 벡터가 텍스트 생성에 필요한 정보를 얼마나 잘 포착하고 있는지를 직접적으로 평가하므로, 이미지-텍스트 검색(Retrieval) 성능 향상에도 크게 기여하는 것으로 알려져 있다.2</p>
<hr />
<h2>4.  2단계 사전 학습: 거대 언어 모델(LLM)과의 생성적 연결</h2>
<p>1단계 학습을 통해 Q-Former가 “텍스트와 관련된 시각 정보를 추출하는 눈“을 갖추었다면, 2단계 학습은 이 추출된 정보를 LLM이 이해할 수 있는 언어적 신호로 변환하는 “번역” 훈련 단계이다.9 이 단계에서 이미지 인코더와 LLM은 모두 동결(Frozen) 상태를 유지하며, 오직 Q-Former와 프로젝션 레이어만이 학습된다.2</p>
<h3>4.1  병목과 프로젝션 (Bottleneck and Projection)</h3>
<p>Q-Former에서 출력된 32개의 질의 벡터 <span class="math math-inline">Z</span>는 LLM의 입력 임베딩 공간(Embedding Space)과 차원이 일치하지 않는다. 따라서 이를 조정하기 위해 선형 프로젝션(Linear Projection) 계층이 도입된다.15<br />
<span class="math math-display">
\text{Input to LLM} =
</span><br />
변환된 질의 벡터들은 **소프트 비주얼 프롬프트(Soft Visual Prompts)**로서 기능한다. 즉, LLM 입장에서는 이 32개의 벡터가 마치 새로운 언어의 단어들처럼 인식되며, 텍스트 입력의 앞부분에 붙어(Prepend) 문맥(Context)을 형성한다.15 1단계에서 강력한 표현 학습을 거친 Q-Former는 이미 언어적 구조와 정렬된 시각 정보를 가지고 있으므로, 단순한 선형 변환만으로도 LLM이 해석 가능한 정보로 변환될 수 있다. 이는 “소프트 프롬프트“라는 개념을 통해 시각 정보를 자연스럽게 언어 모델의 추론 과정에 주입하는 방식이다.</p>
<h3>4.2  LLM 유형에 따른 학습 전략과 최적화</h3>
<p>BLIP-2는 다양한 종류의 LLM 아키텍처를 수용할 수 있도록 설계되었다.</p>
<ul>
<li><strong>디코더 기반 LLM (Decoder-only LLMs):</strong></li>
<li><strong>예시:</strong> Meta의 OPT(Open Pre-trained Transformer) 시리즈.</li>
<li><strong>학습 방식:</strong> 언어 모델링 손실(Language Modeling Loss)을 사용한다. LLM은 시각 프롬프트(Projected Z)를 선행 조건으로 받아 이어지는 텍스트를 생성하도록 훈련된다.</li>
<li><strong>프롬프트 예시:</strong> <code>[Visual Prompts] "A photo of a"</code> <span class="math math-inline">\rightarrow</span> <code>cat sitting on a mat</code></li>
<li><strong>인코더-디코더 기반 LLM (Encoder-Decoder LLMs):</strong></li>
<li><strong>예시:</strong> Google의 FlanT5.</li>
<li><strong>학습 방식:</strong> 접두사 언어 모델링(Prefix Language Modeling)을 사용한다. 시각 프롬프트와 텍스트 접두사(Prefix)가 인코더에 입력되고, 디코더가 텍스트 접미사(Suffix)를 생성한다.2</li>
</ul>
<h3>4.3  파라미터 효율성과 ’동결’의 미학</h3>
<p>2단계 학습 과정에서 전체 파라미터의 극히 일부(약 1-2% 미만)인 Q-Former와 프로젝션 레이어만 업데이트된다.9 예를 들어, 110억 개(11B) 파라미터를 가진 LLM과 거대 ViT를 결합하여 멀티모달 모델을 구축할 때, 단 1억 8,800만 개의 파라미터 학습만으로 충분하다.2 이는 기존의 엔드-투-엔드 학습 방식과 비교했을 때 연산 자원을 획기적으로 절약할 뿐만 아니라, 사전 학습된 모델들이 가진 일반화 능력을 훼손(Catastrophic Forgetting)하지 않고 그대로 활용할 수 있다는 장점이 있다. 이는 트랜스포머 싱귤래리티 시대에 모델을 효율적으로 확장하는 핵심 전략으로 자리 잡았다.</p>
<h2>5.  질의 기반 추출 메커니즘의 심층 분석 및 비교 (2025년 관점)</h2>
<p>BLIP-2와 Q-Former가 제시한 ’질의 기반 추출’은 이후 등장한 수많은 멀티모달 모델들의 설계에 지대한 영향을 미쳤다. 2025년의 시각에서 Q-Former의 메커니즘을 다른 접근 방식, 특히 MLP 프로젝터 방식과 비교 분석하는 것은 그 기술적 가치를 이해하는 데 필수적이다.</p>
<h3>5.1  Q-Former 대 MLP 프로젝터 (LLaVA와의 비교)</h3>
<p>LLaVA(Large Language and Vision Assistant)와 같은 후속 모델들은 Q-Former 대신 단순한 MLP(Multi-Layer Perceptron)를 사용하여 시각 특징을 LLM에 연결하는 방식을 채택했다.17</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>Q-Former (BLIP-2)</strong></th><th><strong>MLP Projector (LLaVA)</strong></th></tr></thead><tbody>
<tr><td><strong>연결 방식</strong></td><td>학습 가능한 질의를 통한 Cross-Attention</td><td>이미지 패치의 단순 선형 변환 및 투영</td></tr>
<tr><td><strong>토큰 수</strong></td><td><strong>고정 (예: 32개)</strong></td><td><strong>가변 (이미지 크기에 비례, 예: 576개)</strong></td></tr>
<tr><td><strong>정보 압축</strong></td><td>매우 높음 (정보 병목 발생)</td><td>낮음 (대부분의 시각 정보 보존)</td></tr>
<tr><td><strong>장점</strong></td><td>LLM 연산 부담 최소화, 추론 속도 빠름</td><td>구현 용이성, 시각적 세부 정보 보존 우수</td></tr>
<tr><td><strong>단점</strong></td><td>미세 정보(OCR 등) 소실 가능성, 학습 복잡도</td><td>LLM 입력 토큰 증가로 인한 연산 비용 증가</td></tr>
</tbody></table>
<p>Q-Former는 수천 개의 이미지 패치를 단 32개의 토큰으로 압축함으로써 LLM의 추론 속도를 비약적으로 높이고 메모리 효율성을 극대화한다. 반면, LLaVA의 MLP 방식은 원본 시각 정보를 거의 그대로 보존하므로 OCR(광학 문자 인식)이나 작은 객체 식별과 같은 세밀한 작업에서 강점을 보인다. 그러나 토큰 수가 많아질수록 LLM의 컨텍스트 윈도우(Context Window)를 많이 차지하고 연산 비용이 증가한다는 단점이 있다.20</p>
<p>최근의 연구 흐름인 Qwen-VL이나 DeepSeek-VL(2025) 등은 이 두 방식의 절충안을 모색하거나, 작업의 성격에 따라 선택적으로 사용하는 경향을 보인다. 예를 들어 Qwen2-VL은 C-Abstractor와 같은 변형된 구조를 사용하여 효율성과 성능의 균형을 맞추려 시도하고 있다.17</p>
<h3>5.2  질의 벡터의 의미론적 역할과 환각(Hallucination)</h3>
<p>연구 결과에 따르면, Q-Former의 학습된 질의 벡터들은 서로 다른 시각적 측면을 담당하도록 자연스럽게 분화된다. 어떤 질의는 이미지의 전경 객체(Foreground Objects)에 집중하고, 다른 질의는 배경(Background)이나 전반적인 분위기에 집중하는 경향을 보인다. 이는 1단계 학습의 ITM 및 ITG 손실 함수가 질의들에게 “텍스트를 생성하거나 매칭하기 위해 필요한 모든 정보를 빠짐없이 긁어모으라“고 압박하기 때문이다.2</p>
<p>그러나 Q-Former의 강력한 압축 능력은 ’환각(Hallucination)’이라는 부작용을 낳기도 한다. POPE(Polling on Object Existence)와 같은 환각 벤치마크에서, Q-Former 기반 모델들은 LLaVA와 같은 MLP 기반 모델에 비해 객체 환각 발생 빈도가 다소 높게 나타나는 경향이 있다.21 이는 Q-Former가 정보를 압축하는 과정에서 존재하지 않는 정보를 텍스트 문맥에 맞춰 ‘지어내거나’, 존재하는 정보를 누락할 가능성이 MLP 방식보다 높기 때문이다. 이는 정보 병목이 너무 좁을 때 발생하는 필연적인 현상으로, 향후 질의 토큰 수를 늘리거나(예: 32개 <span class="math math-inline">\rightarrow</span> 64개 이상) 동적인 토큰 할당 메커니즘을 통해 해결해야 할 과제로 남아 있다.</p>
<h3>5.3  2025년의 멀티모달 트렌드 속 Q-Former</h3>
<p>2025년 현재, Q-Former의 기본 아이디어는 여전히 유효하며 다양한 형태로 변주되고 있다.</p>
<ul>
<li><strong>비디오 이해(Video Understanding):</strong> 비디오는 이미지보다 정보량이 훨씬 많기 때문에, 시간적(Temporal) 정보를 압축하기 위해 Q-Former와 유사한 메커니즘이 필수적으로 사용된다. ’Video Q-Former’와 같은 연구들은 공간적 질의뿐만 아니라 시간적 질의를 도입하여 비디오의 시공간적 특징을 효율적으로 요약한다.23</li>
<li><strong>고해상도 이미지 처리:</strong> 이미지 해상도가 높아질수록 패치 수가 급증하므로, 이를 효율적으로 처리하기 위해 Q-Former를 사용하여 로컬 특징을 요약하는 ‘Abstractor’ 방식이 다시 주목받고 있다.25</li>
<li><strong>DeepSeek-VL 등의 최신 모델:</strong> DeepSeek-VL과 같은 2025년형 모델들은 Q-Former와 MLP의 하이브리드 전략을 취하거나, 시각적 적응(Visual Adaptor) 단계를 더욱 정교화하여 Q-Former의 유산(Legacy)을 계승하고 있다.26</li>
</ul>
<hr />
<h2>6.  결론: 트랜스포머 싱귤래리티 관점에서의 의의</h2>
<p>서적 ’트랜스포머 싱귤래리티’의 13.3장에서 다루는 BLIP-2와 Q-Former는 단순한 모델 아키텍처의 개선을 넘어, 인공지능 연구의 흐름을 바꾼 중요한 분기점이다.</p>
<p>첫째, <strong>모듈성(Modularity)의 승리</strong>를 선언했다. BLIP-2는 거대한 단일 모델을 처음부터 만드는 대신, 각 분야(Vision, Language)의 최고 성능 모델(SOTA)을 레고 블록처럼 조립하고, 그 사이를 지능적인 접착제(Q-Former)로 연결하는 방식이 더 효율적이고 강력할 수 있음을 증명했다. 이는 AI 개발의 민주화를 앞당겼으며, 누구나 적은 자원으로 최첨단 멀티모달 모델을 실험할 수 있는 길을 열어주었다.</p>
<p>둘째, **질의 기반 인터페이스(Query-based Interface)**의 가능성을 제시했다. 정적인 특징 맵(Feature Map)을 수동적으로 넘겨주는 것이 아니라, 능동적인 질의(Query)를 통해 필요한 정보를 ‘물어보고 가져오는’ 방식은 인간의 인지 과정(능동적 주의 집중)과 유사하다. 이는 향후 에이전트(Agent) 기반 시스템이나 능동적 비전(Active Vision) 시스템에서도 중요한 참조 모델이 될 것이다.</p>
<p>셋째, <strong>정보 병목(Information Bottleneck)의 전략적 활용</strong>을 보여주었다. 무조건 많은 정보를 전달하는 것이 능사가 아니라, 목적에 맞는 정보만을 선별하여 압축하는 것이 언어 모델의 추론을 돕고 환각을 줄이는 데(비록 완전하지는 않더라도) 기여할 수 있음을 시사했다.</p>
<p>결론적으로 BLIP-2의 Q-Former 메커니즘은 이질적인 인공지능 모듈 간의 소통을 가능케 하는 보편적인 인터페이스로서의 가능성을 제시했다. 비록 2025년 현재, LLaVA와 같은 단순한 연결 방식이나 더 발전된 형태의 융합 모델들이 경쟁하고 있지만, 정보 병목을 통한 효율적 압축과 의미론적 정렬이라는 Q-Former의 핵심 사상은 여전히 멀티모달 연구의 근간을 이루고 있다. 이는 트랜스포머 아키텍처가 언어를 넘어 시각, 그리고 그 이상의 모달리티를 통합하는 ’특이점(Singularity)’으로 나아가는 과정에서 필수적인 가교였음을 우리는 기억해야 한다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models - arXiv, https://arxiv.org/abs/2301.12597</li>
<li>BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models - The Nemati Lab, https://www.nematilab.info/bmijc/assets/081823_paper.pdf</li>
<li>BLIP-2 - Hugging Face, https://huggingface.co/docs/transformers/v4.36.1/model_doc/blip-2</li>
<li>BLIP-2 Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models | Qiang Zhang, https://zhangtemplar.github.io/blip2/</li>
<li>BLIP-2: A Multimodal Bridging Brilliance! | by Prashant Dandriyal | Medium, https://prashantdandriyal.medium.com/blip-2-a-multimodal-bridging-brilliance-c1f8cf4a7a1e</li>
<li>Q-Former. The ability to seamlessly integrate and… | by Abdulkader Helwan | Medium, https://abdulkaderhelwan.medium.com/q-former-1d83163975da</li>
<li>BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models - arXiv, https://arxiv.org/html/2301.12597</li>
<li>Papers Explained 155: BLIP 2 - Ritvik Rastogi - Medium, https://ritvik19.medium.com/papers-explained-155-blip-2-135fff70bf65</li>
<li>BLIP-2: Scalable Multimodal Pre-training Method - Salesforce, https://www.salesforce.com/blog/blip-2/</li>
<li>BLIP-2: A Breakthrough Approach in Vision-Language Pre-training | by Femiloye Oyerinde, https://medium.com/@femiloyeseun/blip-2-a-breakthrough-approach-in-vision-language-pre-training-1de47b54f13a</li>
<li>BLIP-2 : How Transformers Learn to ‘See’ and Understand Images | by Arnavbhatt, https://pub.towardsai.net/inside-blip-2-how-queries-extract-meaning-from-images-9a26cf4765f4</li>
<li>BLIP: Bootstrapping Language-Image Pre- training for Unified Vision, https://faculty.cc.gatech.edu/~zk15/teaching/AY2024_cs8803vlm_fall/slides/L11_BLIP.pdf</li>
<li>Multimodal Search Engine Agents Powered by BLIP-2 and Gemini | Towards Data Science, https://towardsdatascience.com/multimodal-search-engine-agents-powered-by-blip-2-and-gemini/</li>
<li>BLIP-2: A new Visual Language Model by Salesforce - Wandb, https://wandb.ai/gladiator/BLIP-2/reports/BLIP-2-A-new-Visual-Language-Model-by-Salesforce–VmlldzozNjM0NjYz</li>
<li>[23.01] BLIP-2 - DOCSAID, https://docsaid.org/en/papers/model-tuning/blip2/</li>
<li>LoRA-Tuned BLIP-2 Overview - Emergent Mind, https://www.emergentmind.com/topics/lora-tuned-blip-2</li>
<li>Inverse-LLaVA: Eliminating Alignment Pre-training Through Text-to-Vision Mapping - arXiv, https://arxiv.org/html/2508.12466v1</li>
<li>Intuition on Visual Projection · haotian-liu LLaVA · Discussion #817 - GitHub, https://github.com/haotian-liu/LLaVA/discussions/817</li>
<li>Vision Language Models | Rohit Bandaru, https://rohitbandaru.github.io/blog/Vision-Language-Models/</li>
<li>Honeybee: Locality-enhanced Projector for Multimodal LLM - arXiv, https://arxiv.org/html/2312.06742v2</li>
<li>Cure or Poison? Embedding Instructions Visually Alters Hallucination in Vision-Language Models - arXiv, https://arxiv.org/html/2508.01678v1</li>
<li>Can anyone tell me the performance of LLaVA vs BLIP? : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/170oi1d/can_anyone_tell_me_the_performance_of_llava_vs/</li>
<li>Pretrained Image-Text Models are Secretly Video Captioners - arXiv, https://arxiv.org/html/2502.13363v1</li>
<li>VIDEO Q-FORMER: MULTIMODAL LARGE LANGUAGE MODEL WITH SPATIO-TEMPORAL QUERYING TRANS - OpenReview, https://openreview.net/pdf/6a4b2bd8b1e48662f75e7fca3b2b64f4848d6d91.pdf</li>
<li>Design choices for Vision Language Models in 2024 - Hugging Face, https://huggingface.co/blog/gigant/vlm-design</li>
<li>DeepSeek AI Statistics 2025: Users, Benchmarks &amp; Enterprise Reach - SQ Magazine, https://sqmagazine.co.uk/deepseek-ai-statistics/</li>
<li>DeepSeek-VL: Towards Real-World Vision-Language Understanding - arXiv, https://arxiv.org/pdf/2403.05525</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>