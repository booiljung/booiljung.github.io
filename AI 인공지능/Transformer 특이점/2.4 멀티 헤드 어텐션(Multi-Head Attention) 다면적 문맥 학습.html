<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.4 멀티 헤드 어텐션(Multi-Head Attention) 다면적 문맥 학습</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.4 멀티 헤드 어텐션(Multi-Head Attention) 다면적 문맥 학습</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>2.4 멀티 헤드 어텐션(Multi-Head Attention) 다면적 문맥 학습</span></nav>
                </div>
            </header>
            <article>
                <h1>2.4 멀티 헤드 어텐션(Multi-Head Attention) 다면적 문맥 학습</h1>
<p>2025-12-18, G30DR</p>
<p>트랜스포머 아키텍처의 혁신성 중 가장 결정적인 요소는 어텐션 메커니즘을 단일 연산에 가두지 않고 병렬적 하위 공간으로 확장한 멀티 헤드 어텐션(Multi-Head Attention, MHA)에 있다. 이는 단순히 계산 효율성을 높이기 위한 병렬화 기법을 넘어, 언어의 복잡한 구조와 문맥적 중의성을 다면적으로 해석하기 위한 필수적인 지능적 장치로 작동한다.1 싱글 헤드 어텐션이 하나의 문장을 하나의 시각으로만 바라보는 ’독단적 관찰자’라면, 멀티 헤드 어텐션은 서로 다른 전문 지식을 가진 여러 명의 관찰자가 동시에 데이터를 분석하여 그 결과를 융합하는 ’집단 지성’의 원리를 모델링한다.2</p>
<pre><code class="language-mermaid">mindmap
  root("멀티 헤드 어텐션 (MHA)")
    ("단일 헤드 어텐션 (Single-Head)")
      ("독단적 관찰자")
      ("단일 시각")
      ("정보의 병목 현상")
      ("제로섬 게임 (Zero-sum)")
    ("멀티 헤드 어텐션 (Multi-Head)")
      ("집단 지성 (Group Intelligence)")
      ("다면적 해석")
      ("병렬적 하위 공간")
      ("배타적 집중")
    ("핵심 기능")
      ("문법적 구조 파악")
      ("의미적 연결 포착")
      ("위치 정보 보존")
      ("전역적 문맥 스캔")
</code></pre>
<h2>1.  단일 어텐션의 정보적 한계와 다면성 확보의 필요성</h2>
<p>셀프 어텐션(Self-Attention)의 핵심은 쿼리(Query)와 키(Key)의 상호작용을 통해 밸류(Value)의 가중 평균을 구하는 것이다.1 그러나 단일 헤드 구조에서는 모든 토큰 간의 관계를 하나의 가중치 행렬 세트(<span class="math math-inline">W^Q, W^K, W^V</span>)로만 표현해야 한다. 이러한 방식은 언어가 가진 다층적인 의존 관계를 포착하는 데 있어 필연적으로 ’정보의 병목 현상’을 초래한다.3</p>
<p>언어의 문맥은 결코 단일 차원에서 정의되지 않는다. 예를 들어, “The cat sat on the mat because it was tired“라는 문장에서 ’it’이라는 토큰은 두 가지 층위의 정보를 동시에 처리해야 한다. 첫째는 문법적 층위에서 ’it’이 주어 역할을 한다는 사실이며, 둘째는 의미적 층위에서 ’it’이 ’cat’을 지칭한다는 상호 참조(Coreference) 관계이다.6 만약 단일 헤드 어텐션이 문법적 관계에 강하게 집중한다면, 의미적 연결 고리를 포착하는 가중치는 상대적으로 약해질 수밖에 없다. 어텐션 스코어의 총합은 소프트맥스(Softmax) 함수에 의해 1로 정규화되기 때문에, 한 곳에 집중하면 다른 곳에 대한 집중력은 분산될 수밖에 없는 제로섬(Zero-sum) 게임의 논리가 지배하기 때문이다.1</p>
<p>멀티 헤드 어텐션은 이러한 제약을 수학적으로 우회한다. 모델의 전체 임베딩 공간을 여러 개의 독립적인 하위 공간(Subspaces)으로 분할함으로써, 각 헤드가 서로 다른 관계에 ‘배타적으로’ 집중할 수 있는 환경을 제공한다.1 이를 통해 모델은 동일한 시점에 문법, 의미, 거리상 먼 관계, 국소적 패턴 등을 동시에 학습할 수 있는 ‘다면적 문맥 학습’ 능력을 갖추게 된다.3</p>
<pre><code class="language-mermaid">graph TD
    subgraph "입력 문장 (Input Sentence)"
        InputText["The cat sat on the mat because it was tired"]
    end

    InputText --&gt; TokenFocus["토큰 'it'에 대한 어텐션 수행"]

    subgraph "멀티 헤드 처리 (Multi-Head Processing)"
        Head1["헤드 1: 문법적 층위 (Grammar)"]
        Head2["헤드 2: 의미적 층위 (Semantics)"]
        
        TokenFocus --&gt; Head1
        TokenFocus --&gt; Head2
        
        Head1 -- "주어(Subject) 역할 인식" --&gt; Rel1["'sat' (동사)와의 관계 포착"]
        Head2 -- "상호 참조(Coreference) 해결" --&gt; Rel2["'cat' (선행사)와의 관계 포착"]
    end

    subgraph "결과 통합 (Integration)"
        Rel1 --&gt; ContextFusion["문맥 융합"]
        Rel2 --&gt; ContextFusion
        ContextFusion --&gt; FinalUnderstanding["'it' = 'cat'이며 문장의 주어임"]
    end

    style Head1 fill:#f9f,stroke:#333,stroke-width:2px
    style Head2 fill:#bbf,stroke:#333,stroke-width:2px
    style FinalUnderstanding fill:#bfb,stroke:#333,stroke-width:2px
</code></pre>
<h2>2.  멀티 헤드 어텐션의 수학적 기제와 연산 프로세스</h2>
<p>멀티 헤드 어텐션의 연산 과정은 입력 데이터의 선형 투영(Linear Projection), 병렬적 어텐션 수행, 결과의 결합(Concatenation), 그리고 최종 선형 변환의 4단계로 구성된다.1 이 과정에서 가장 중요한 변수는 모델의 차원 <span class="math math-inline">d_{model}</span>과 헤드의 개수 <span class="math math-inline">h</span>이다.</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant Input as "입력 행렬 X&lt;br&gt;(d_model)"
    participant Proj as "선형 투영&lt;br&gt;(Linear Projection)"
    participant Heads as "어텐션 헤드들&lt;br&gt;(h개)"
    participant Concat as "결합&lt;br&gt;(Concatenation)"
    participant Linear as "최종 선형 변환&lt;br&gt;(W^O)"
    participant Output as "최종 출력&lt;br&gt;(Output)"

    Note over Input, Proj: "d_model = 512, h = 8"

    Input-&gt;&gt;Proj: "가중치 W^Q, W^K, W^V 적용"
    
    loop "8개의 병렬 하위 공간 (Parallel Subspaces)"
        Proj-&gt;&gt;Heads: "헤드별 쪼개기&lt;br&gt;(Split per Head)"
        Note right of Heads: "각 헤드 차원&lt;br&gt;d_k = 64"
        Heads-&gt;&gt;Heads: "스케일드 닷 프로덕트&lt;br&gt;어텐션 수행"
        Note right of Heads: "Softmax(QK^T / sqrt(d_k))V"
    end

    Heads-&gt;&gt;Concat: "개별 헤드 결과&lt;br&gt;(head_i) 전달"
    Concat-&gt;&gt;Concat: "모든 헤드 이어 붙이기&lt;br&gt;(Concatenate)"
    Note right of Concat: "차원 복원:&lt;br&gt;64 * 8 = 512"
    
    Concat-&gt;&gt;Linear: "통합된 행렬 전달"
    Linear-&gt;&gt;Output: "가중치 W^O 곱셈&lt;br&gt;(정보 정제)"
    Output--&gt;&gt;Input: "다음 레이어(FFN)로&lt;br&gt;전달"
</code></pre>
<h3>2.1  하위 공간으로의 선형 투영 (Linear Projection)</h3>
<p>입력 행렬 <span class="math math-inline">X</span>가 주어졌을 때, 멀티 헤드 어텐션은 이를 <span class="math math-inline">h</span>개의 헤드로 나누기 위해 각 헤드 <span class="math math-inline">i</span>에 대해 독립적인 학습 가중치 행렬 <span class="math math-inline">W_i^Q, W_i^K, W_i^V</span>를 적용한다.1 여기서 핵심적인 설계 원칙은 각 헤드가 다루는 벡터의 차원 <span class="math math-inline">d_k</span>를 전체 차원을 헤드 수로 나눈 값으로 설정한다는 점이다 (<span class="math math-inline">d_k = d_v = d_{model} / h</span>).13</p>
<p>예를 들어, <span class="math math-inline">d_{model} = 512</span>이고 <span class="math math-inline">h = 8</span>인 표준 트랜스포머 모델의 경우, 각 헤드는 64차원의 하위 공간에서 어텐션을 수행한다.5 이는 전체 512차원의 정보를 64차원씩 8개의 서로 다른 관점으로 쪼개어 분석하는 것과 같다. 수학적으로 각 헤드의 출력 <span class="math math-inline">head_i</span>는 다음과 같이 정의된다.</p>
<p><span class="math math-display">
head_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)
</span><br />
여기서 <span class="math math-inline">W_i^Q \in \mathbb{R}^{d_{model} \times d_k}, W_i^K \in \mathbb{R}^{d_{model} \times d_k}, W_i^V \in \mathbb{R}^{d_{model} \times d_v}</span>는 각각 쿼리, 키, 밸류를 하위 공간으로 투영하는 학습 가능한 파라미터이다.1</p>
<h3>2.2  병렬적 스케일드 닷 프로덕트 어텐션</h3>
<p>투영된 <span class="math math-inline">h</span>개의 쿼리, 키, 밸류 세트는 각각 독립적으로 어텐션 메커니즘을 통과한다. 이때 사용하는 방식은 ’스케일드 닷 프로덕트 어텐션(Scaled Dot-Product Attention)’이다.1</p>
<p><span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
<span class="math math-inline">\sqrt{d_k}</span>로 나누어주는 스케일링 과정은 차원이 커질수록 내적 값이 극단적으로 커져 소프트맥스 함수의 기울기가 소실되는 문제를 방지한다.14 각 헤드는 이 수식을 통해 자신만의 어텐션 맵(Attention Map)을 생성하며, 이는 특정 헤드가 어떤 토큰 관계를 중요하게 여기는지를 나타내는 ’관점의 지도’가 된다.4</p>
<h3>2.3  헤드 결합 및 최종 선형 변환 (Concatenation &amp; Output Projection)</h3>
<p>모든 헤드에서 계산된 결과물(<span class="math math-inline">head_1, \dots, head_h</span>)은 물리적으로 하나로 합쳐진다(Concatenate).1 8개의 64차원 벡터가 합쳐지면 다시 원래의 <span class="math math-inline">d_{model}</span>인 512차원으로 복원된다.4 마지막으로, 이 결합된 행렬에 최종 가중치 행렬 <span class="math math-inline">W^O \in \mathbb{R}^{d_{model} \times d_{model}}</span>를 곱하여 서로 다른 헤드로부터 수집된 다면적인 정보들을 융합하고 정제한다.1</p>
<p><span class="math math-display">
\text{MultiHead}(Q, K, V) = \text{Concat}(head_1, \dots, head_h)W^O
</span><br />
이 마지막 층은 여러 전문가(헤드)의 의견을 종합하여 최종적인 문맥적 의미를 도출하는 통합자의 역할을 수행하며, 이후 이어지는 피드포워드 네트워크(FFN)로 정보를 전달한다.4</p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>기호</strong></th><th><strong>전형적인 크기 (Base 모델 기준)</strong></th><th><strong>주요 역할</strong></th></tr></thead><tbody>
<tr><td>모델 차원</td><td><span class="math math-inline">d_{model}</span></td><td>512</td><td>전체 시스템의 정보 표현 용량</td></tr>
<tr><td>헤드 개수</td><td><span class="math math-inline">h</span></td><td>8</td><td>병렬적으로 운용되는 ’전문가’의 수</td></tr>
<tr><td>하위 공간 차원</td><td><span class="math math-inline">d_k, d_v</span></td><td>64</td><td>각 헤드가 집중하는 정보의 해상도</td></tr>
<tr><td>최종 출력 행렬</td><td><span class="math math-inline">W^O</span></td><td><span class="math math-inline">512 \times 512</span></td><td>다면적 정보를 단일 문맥으로 통합</td></tr>
</tbody></table>
<p>주: <span class="math math-inline">d_{model} = h \times d_k</span> 관계를 유지함으로써 전체 파라미터 수와 연산량을 싱글 헤드 어텐션과 유사한 수준으로 통제한다.13</p>
<h2>3.  하위 공간(Representation Subspaces)의 기하학적 의미와 전문화</h2>
<p>멀티 헤드 어텐션이 왜 ’다면적 학습’에 탁월한지는 ’하위 공간(Representation Subspaces)’이라는 개념을 통해 기하학적으로 해석할 수 있다. 입력 토큰 벡터가 <span class="math math-inline">d_{model}</span> 차원의 고차원 공간에 존재할 때, 각 헤드는 이 벡터를 저차원(<span class="math math-inline">d_k</span>) 공간으로 사영(Projection)한다.1 이때 각 사영 행렬(<span class="math math-inline">W_i</span>)은 데이터의 서로 다른 특징적 단면을 절단해내는 역할을 한다.4</p>
<p>기하학적 관점에서, 헤드 1은 단어 간의 거리를 기준으로 ’가까운 이웃’에 집중하는 공간으로 사영할 수 있고, 헤드 2는 문장의 통사적 구조(주어-동사-목적어)를 기준으로 멀리 떨어진 단어들을 가깝게 배치하는 공간으로 사영할 수 있다.4 이러한 투영 과정을 거치면 원본 공간에서는 유사했던 벡터들이 특정 하위 공간에서는 멀어지기도 하고, 반대로 멀었던 벡터들이 특정 하위 공간에서 매우 가까워지기도 한다.4 이는 모델이 데이터의 잠재적 관계를 다각도로 탐색할 수 있는 유연성을 부여한다.3</p>
<p>이러한 전문화는 학습 과정에서 자연스럽게 발생하며, 인간이 명시적으로 “헤드 1은 문법을 배우고 헤드 2는 의미를 배우라“고 지시할 필요가 없다.17 역전파(Backpropagation) 과정에서 모델은 손실 함수를 최소화하기 위해 가장 효율적인 정보 분담 체계를 스스로 구축하게 된다.5 결과적으로 각 헤드는 서로 다른 ’질문’을 던지고 서로 다른 ’답’을 내놓는 독립적인 정보 채널로 진화한다.4</p>
<pre><code class="language-mermaid">erDiagram
    MODEL_DIMENSION {
        int d_model "512 (전체 차원)"
        string role "정보 표현 용량"
    }
    
    HEAD_SUBSPACE {
        int d_k "64 (쿼리/키 차원)"
        int d_v "64 (밸류 차원)"
        int head_index "1 to 8"
        string role "특징적 단면 절단"
    }

    WEIGHT_MATRICES {
        matrix W_Q "Project to Subspace"
        matrix W_K "Project to Subspace"
        matrix W_V "Project to Subspace"
        matrix W_O "Output Projection"
    }

    ATTENTION_OUTPUT {
        vector context_vector "통합된 문맥"
    }

    MODEL_DIMENSION ||--|{ HEAD_SUBSPACE : "Splits into h heads"
    HEAD_SUBSPACE }|--|| WEIGHT_MATRICES : "Uses per head"
    HEAD_SUBSPACE ||--|| ATTENTION_OUTPUT : "Generates head_i"
    ATTENTION_OUTPUT }|--|| MODEL_DIMENSION : "Restores via Concat &amp; W_O"
</code></pre>
<h2>4.  어텐션 헤드의 언어학적 특화에 대한 실증적 분석</h2>
<p>멀티 헤드 어텐션의 다면적 학습 능력은 실제 대규모 모델들을 대상으로 한 분석 연구(Interpretability Analysis)를 통해 입증되었다. 특히 케빈 클락(Kevin Clark) 등의 연구인 “What Does BERT Look At?“은 트랜스포머의 어텐션 헤드들이 실제로 언어의 어떤 측면들을 포착하고 있는지 상세히 밝혀냈다.17</p>
<p><strong>어텐션 헤드의 역할 분담 (Role Specialization)</strong></p>
<pre><code class="language-mermaid">graph LR
    CenterNode(("Transformer Heads"))

    subgraph "문법 및 구조 (Syntax)"
        DirObj["직접 목적어 포착 (Direct Object)"]
        ModLink["명사-수식어 연결 (Noun Modifiers)"]
        PrepObj["전치사-목적어 연결"]
    end

    subgraph "의미 및 참조 (Semantics)"
        Corefs["상호 참조 해결 (Coreference)"]
        AntLink["대명사 -&gt; 선행사 연결"]
    end

    subgraph "시스템 기능 (Systemic)"
        SepToken["구분자([SEP]) 집중 (No-op/Memory Dump)"]
        LocTrack["상대적 위치 추적 (Next/Prev Token)"]
        GlobalScan["전역 문맥 스캔 (Global Context)"]
    end

    CenterNode --&gt; DirObj
    CenterNode --&gt; ModLink
    CenterNode --&gt; Corefs
    CenterNode --&gt; SepToken
    CenterNode --&gt; LocTrack
    CenterNode --&gt; GlobalScan

    style CenterNode fill:#ff9,stroke:#333,stroke-width:4px
    style SepToken fill:#eee,stroke:#999,stroke-dasharray: 5 5
</code></pre>
<h3>4.1  문법적 관계의 자동 학습</h3>
<p>분석 결과에 따르면, 특정 헤드들은 매우 높은 정확도로 특정한 언어학적 관계(Linguistic Relations)를 수행한다.17</p>
<ol>
<li><strong>직접 목적어 포착</strong>: 어떤 헤드는 동사가 주어졌을 때 그 동사의 목적어를 찾는 데 75% 이상의 정확도를 보인다.17</li>
<li><strong>명사 수식어 연결</strong>: 관사(Determiner)와 명사를 연결하거나, 전치사와 그 목적어를 연결하는 전용 헤드들이 발견되었다.17</li>
<li><strong>상호 참조(Coreference) 해결</strong>: 대명사가 가리키는 선행사(Antecedent)를 정확히 지목하는 헤드가 존재한다. 예를 들어 “she“라는 단어가 나타났을 때 이전 문장의 “Alice“에 강한 어텐션을 주는 식이다.17</li>
</ol>
<h3>4.2  문장 구조 및 특수 토큰의 역할</h3>
<p>모든 헤드가 언어적 의미만을 쫓는 것은 아니다. 일부 헤드는 시스템적인 기능을 수행하도록 최적화된다.17</p>
<ul>
<li><strong>구분자(Delimiter) 집중</strong>: 많은 헤드가 문장의 끝을 알리는 <code>토큰에 비정상적으로 높은 어텐션을 할당한다. 이는 모델이 문맥 정보를 처리할 때</code>를 일종의 ‘메모리 덤프’ 공간이나 정보 처리를 일단 멈추는 ‘정정보(No-op)’ 지점으로 활용하고 있음을 암시한다.17</li>
<li><strong>상대적 위치 추적</strong>: 특정 헤드들은 현재 토큰의 바로 다음 토큰이나 이전 토큰에만 일관되게 어텐션을 준다. 이는 트랜스포머가 RNN처럼 순차적 정보를 처리하지 않음에도 불구하고, 멀티 헤드 어텐션의 일부가 n-gram과 같은 국소적 문맥 정보를 보존하는 역할을 수행하고 있음을 의미한다.17</li>
<li><strong>전역적 문맥 파악</strong>: 일부 헤드는 문장 전체에 어텐션을 고르게 분산시켜 전체적인 주제나 정서를 파악하는 광역 스캐너 역할을 한다.17</li>
</ul>
<p>이러한 발견은 멀티 헤드 어텐션이 단순한 ’병렬 계산’을 넘어, 인간의 뇌가 언어를 처리할 때 여러 영역이 동시에 활성화되는 것과 유사한 ’분산적 정보 처리’를 수행하고 있음을 보여준다.5</p>
<h2>5.  정보 이론 관점에서의 멀티 헤드 어텐션: 정보 병목과 정규화</h2>
<p>멀티 헤드 어텐션의 설계는 정보 이론(Information Theory)적으로도 매우 정교한 구조를 띠고 있다. 정보 병목(Information Bottleneck, IB) 이론에 따르면, 학습의 목적은 입력 데이터 <span class="math math-inline">X</span>로부터 출력 <span class="math math-inline">Y</span>를 예측하는 데 필요한 최소한의 핵심 정보만을 추출하는 것이다.23</p>
<pre><code class="language-mermaid">quadrantChart
    title "헤드 차원(d_k) 크기에 따른 모델 특성"
    x-axis "차원 크기 (Small d_k &lt;---&gt; Large d_k)"
    y-axis "학습 위험도 (Low Risk &lt;---&gt; High Risk)"
    quadrant-1 "과적합 (Overfitting)"
    quadrant-2 "이상적 영역 (Optimal Balance)"
    quadrant-3 "저차원 병목 (Low-Rank Bottleneck)"
    quadrant-4 "표현력 부족 (Underfitting)"

    "헤드 차원 과다 (Noise 학습)" : [0.8, 0.8]
    "적절한 병목 (특징 선택 &amp; 정규화)" : [0.4, 0.6]
    "지나친 차원 축소 (자유도 부족)" : [0.2, 0.3]
    "단일 헤드 (모든 정보 혼재)" : [0.9, 0.9]
</code></pre>
<h3>5.1  저차원 투영을 통한 특징 선택</h3>
<p>각 헤드가 <span class="math math-inline">d_{model}</span> 전체를 사용하지 않고 <span class="math math-inline">d_k</span>라는 저차원 하위 공간으로 정보를 제한하는 것은 의도적인 ’병목’을 만드는 행위이다.4 만약 하나의 헤드가 너무 큰 차원을 가지면 데이터의 모든 잡음(Noise)까지 학습하려 하여 과적합(Overfitting)될 위험이 있다.12 반면, 차원을 작게 쪼개어 여러 헤드에 분산시키면 각 헤드는 자신이 맡은 하위 공간 내에서 가장 지배적인 특징(Feature)만을 포착하도록 강제된다.4 이는 결과적으로 모델이 데이터의 본질적인 구조를 더 잘 파악하게 만드는 정규화(Regularization) 효과를 낸다.5</p>
<h3>5.2  앙상블 효과와 견고성(Robustness)</h3>
<p>멀티 헤드 어텐션은 일종의 ‘앙상블 학습(Ensemble Learning)’ 시스템으로 볼 수 있다.5 여러 개의 헤드가 각자 다른 가중치로 학습됨으로써, 특정 헤드가 노이즈나 잘못된 관계에 빠지더라도 다른 헤드들이 제공하는 올바른 정보가 이를 보완한다.1 이러한 구조적 중복성(Redundancy)은 모델의 추론 결과에 대한 견고성을 높이며, 다양한 도메인의 데이터에 대해 더 나은 일반화 성능을 제공한다.12</p>
<h3>5.3  저차원 병목(Low-Rank Bottleneck)의 위험성</h3>
<p>그러나 최근 연구(Bhojanapalli et al., 2020)는 헤드 수 <span class="math math-inline">h</span>를 너무 늘려 헤드별 차원 <span class="math math-inline">d_k</span>가 지나치게 작아질 경우 발생하는 ‘저차원 병목’ 문제를 경고한다.24 어텐션 행렬의 랭크(Rank)는 <span class="math math-inline">d_k</span>에 의해 제한되는데, <span class="math math-inline">d_k</span>가 시퀀스 길이보다 너무 작으면 모든 복잡한 관계를 표현하기에 수학적 자유도가 부족해진다.24 따라서 최적의 <span class="math math-inline">d_k</span>와 <span class="math math-inline">h</span>를 찾는 것은 모델 설계의 핵심적인 하이퍼파라미터 튜닝 요소이며, 2025년의 최신 모델들은 이를 동적으로 조절하거나 고정된 헤드 크기를 유지하는 전략을 취하기도 한다.14</p>
<h2>6.  시스템 성능과 하드웨어 병렬화의 최적화</h2>
<p>트랜스포머 아키텍처가 RNN을 밀어내고 표준이 된 실질적인 이유는 멀티 헤드 어텐션의 하드웨어 친화적 구조에 있다.5 RNN은 이전 시점의 은닉 상태(Hidden State)가 계산되어야만 다음 시점을 계산할 수 있는 순차적 의존성 때문에 GPU의 병렬 처리 능력을 제대로 활용하지 못한다.14</p>
<h3>6.1  행렬 연산의 극대화</h3>
<p>멀티 헤드 어텐션은 모든 토큰과 모든 헤드의 연산을 거대한 행렬 곱셈(Matrix Multiplication)으로 통합할 수 있다.14 실제 구현에서는 <code>(Batch, Sequence, Head, Dimension)</code> 형태의 4차원 텐서를 사용하여 모든 헤드의 어텐션 스코어를 한 번에 계산한다.1 이는 GPU 내의 수천 개 코어가 동시에 연산을 수행하게 함으로써 학습 속도를 획기적으로 향상시킨다.5</p>
<h3>6.2  메모리 대역폭과 연산 강도</h3>
<p>현대 LLM 시스템에서 멀티 헤드 어텐션은 주로 ‘메모리 대역폭 제한(Memory-bound)’ 구간에 해당한다.25 특히 어텐션 맵을 생성할 때 발생하는 <span class="math math-inline">O(S^2)</span>의 메모리 복잡도는 긴 문장을 처리할 때 병목이 된다.14 이를 해결하기 위해 2025년 현재는 플래시 어텐션(Flash Attention)과 같은 하드웨어 가속 기법이나, 멀티 헤드 레이턴트 어텐션(Multi-head Latent Attention, MLA)과 같이 키-밸류 캐시 메모리 사용량을 획기적으로 줄이는 진화된 형태의 MHA가 사용되고 있다.14</p>
<h2>7.  2025년의 진화: 멀티모달 및 추론 모델에서의 MHA</h2>
<p>멀티 헤드 어텐션의 ‘다면적 문맥 학습’ 원리는 텍스트를 넘어 시각, 청각, 그리고 복합 추론의 영역으로 확장되었다.1</p>
<pre><code class="language-mermaid">mindmap
  root("MHA의 도메인별 확장 (2025)")
    ("LLM (텍스트)")
      ("통사/의미 분석")
      ("긴 문맥 처리")
      ("비유와 중의성 해결")
    ("ViT (비전)")
      ("헤드 A: 질감/윤곽선")
      ("헤드 B: 전역적 구도")
      ("동적 어텐션 범위")
    ("Multimodal (VLM)")
      ("교차 어텐션 (Cross-Attention)")
      ("텍스트(Query)-이미지(Key) 정렬")
      ("복합 추론")
    ("Speech (음성)")
      ("음소 분리")
      ("화자 식별")
      ("배경 소음 필터링")
</code></pre>
<h3>7.1  시각적 다면성: 비전 트랜스포머(ViT)</h3>
<p>비전 트랜스포머에서 각 어텐션 헤드는 이미지의 서로 다른 특징을 추출한다.1 어떤 헤드는 이미지의 전반적인 구도와 색감을 파악하고, 다른 헤드는 사물의 미세한 질감이나 윤곽선에 집중한다.26 이는 기존 CNN이 가진 고정된 커널(Kernel)의 한계를 넘어, 이미지의 내용에 따라 어텐션 범위를 동적으로 조절하는 유연한 시각 지능을 가능케 했다.26</p>
<h3>7.2  복합 추론 에이전트와 교차 어텐션</h3>
<p>멀티모달 에이전트에서는 텍스트 정보를 처리하는 헤드와 이미지 정보를 처리하는 헤드 간의 교차 어텐션(Cross-Attention)이 발생한다.1 예를 들어 사용자가 “이 사진에서 빨간 모자를 쓴 사람을 찾아줘“라고 요청했을 때, 모델은 텍스트의 ’빨간 모자’라는 쿼리를 이미지의 특정 픽셀 영역(키)과 정렬(Alignment)시키는 다면적 매핑 과정을 수행한다.1 이 과정에서 멀티 헤드 구조는 색상, 모양, 인물이라는 여러 단서를 동시에 추적하며 최적의 답을 찾아낸다.1</p>
<table><thead><tr><th><strong>모델 유형</strong></th><th><strong>멀티 헤드 어텐션의 역할</strong></th><th><strong>핵심 이점</strong></th></tr></thead><tbody>
<tr><td>언어 모델 (LLM)</td><td>통사, 의미, 상호 참조의 병렬 학습</td><td>복잡한 문맥과 비유의 정확한 이해</td></tr>
<tr><td>비전 모델 (ViT)</td><td>질감, 형태, 전역적 구도의 동시 포착</td><td>사물 인식의 정확도 및 견고성 향상</td></tr>
<tr><td>멀티모달 (VLM)</td><td>텍스트와 이미지 간의 의미적 정렬</td><td>매체 간 지식 전이 및 복합 추론 가능</td></tr>
<tr><td>음성 모델 (Speech)</td><td>음소, 억양, 배경 소음의 분리 처리</td><td>높은 인식률과 화자 분리 성능 확보</td></tr>
</tbody></table>
<p>주: 각 도메인에서 멀티 헤드 어텐션은 데이터의 고유한 ’차원’들을 분리하여 처리하는 범용적인 특징 추출기 역할을 수행한다.1</p>
<h2>8. 결론: 통합된 다면적 지능의 중추</h2>
<p>멀티 헤드 어텐션은 트랜스포머가 단순한 통계적 언어 모델을 넘어 ’이해’와 ’추론’의 단계로 도약하게 만든 결정적인 메커니즘이다.4 단일 시점의 한계를 깨고 하위 공간의 기하학적 유연성을 활용함으로써, 모델은 언어의 중의성을 해소하고 방대한 지식 체계를 다각도로 구조화할 수 있게 되었다.1</p>
<p>2.4절에서 살펴본 이 다면적 문맥 학습의 원리는 이후 제2장의 피드포워드 네트워크(2.5절)에서 정보를 비선형적으로 변형하고 증폭시키는 과정과 결합되어 트랜스포머 블록의 완성된 기능을 형성한다.19 결국 멀티 헤드 어텐션은 “무엇에 집중할 것인가“를 결정하는 지능의 선택적 필터이자, “어떻게 세상을 바라볼 것인가“를 정의하는 다면적 관찰자들의 집합체라 할 수 있다.2 이러한 다면성이야말로 2025년 인공지능이 인간의 사고방식을 가장 가깝게 모사하며 특이점을 향해 나아가게 하는 핵심 동력이다.5</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Multi-Head Attention Mechanism - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/multi-head-attention-mechanism/</li>
<li>Multi-Head Attention: The Power Behind Transformer | by Kamalmeet Singh | Nov, 2025, https://medium.com/@kamalmeet/multi-head-attention-the-power-behind-transformer-c163d368cc0d</li>
<li>How Does Multi-Head Attention Improve Transformer Models? - ProjectPro, https://www.projectpro.io/article/multi-head-attention-in-transformers/1166</li>
<li>Multi-headed Attention the mathematical meaning - DeepLearning.AI Community, https://community.deeplearning.ai/t/multi-headed-attention-the-mathematical-meaning/346228</li>
<li>Day 9: 21 Days of Building a Small Language Model: MultiHead Attention - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/1pon3oz/day_9_21_days_of_building_a_small_language_model/</li>
<li>“Attention is all you need” in plain English | by Ujwal Tickoo | Nov, 2025, https://medium.com/@ujwaltickoo/attention-is-all-you-need-in-plain-english-b176d1ad4ada</li>
<li>📌 Day 9: 21 Days of Building a Small Language Model: MultiHead Attention📌, https://devopslearning.medium.com/day-9-21-days-of-building-a-small-language-model-multihead-attention-dc668bd2dd3e</li>
<li>What is an attention mechanism? | IBM, https://www.ibm.com/think/topics/attention-mechanism</li>
<li>Understanding Multi-Head Attention in Transformers | DataCamp, https://www.datacamp.com/de/tutorial/multi-head-attention-transformers</li>
<li>Understanding Multi-Head Attention in Transformers | DataCamp, https://www.datacamp.com/es/tutorial/multi-head-attention-transformers</li>
<li>The Math Behind Multi-Head Attention in Transformers - Medium, https://medium.com/data-science/the-math-behind-multi-head-attention-in-transformers-c26cba15f625</li>
<li>Exploring Multi-Head Attention: Why More Heads Are Better Than One | by Hassaan Idrees, https://medium.com/@hassaanidrees7/exploring-multi-head-attention-why-more-heads-are-better-than-one-006a5823372b</li>
<li>Multi-head Attention is a Fancy Addition Machine | Towards Data Science, https://towardsdatascience.com/transformers-and-attention-are-just-fancy-addition-machines/</li>
<li>Demystifying the Heart of Transformers: A Deep Dive into Self-Attention, Multi Head Attention, and Masking | by Aydin Abedinia | Medium, https://medium.com/@abedinia.aydin/demystifying-the-heart-of-transformers-a-deep-dive-into-self-attention-multi-head-attention-and-baade77c4241</li>
<li>Multiheaded Attention - Number of heads and Dim of heads - DeepLearning.AI Community, https://community.deeplearning.ai/t/multiheaded-attention-number-of-heads-and-dim-of-heads/317195</li>
<li>Attention Is All You Need - Wikipedia, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need</li>
<li>What Does BERT Look at? An Analysis of BERT’s Attention - ACL Anthology, https://aclanthology.org/W19-4828.pdf</li>
<li>Transformers Explained Visually (Part 3): Multi-head Attention, deep …, https://towardsdatascience.com/transformers-explained-visually-part-3-multi-head-attention-deep-dive-1c1ff1024853/</li>
<li>The Math Behind Multi-Head Attention in Transformers | Towards Data Science, https://towardsdatascience.com/the-math-behind-multi-head-attention-in-transformers-c26cba15f625/</li>
<li>Multi-head in transformers : r/learnmachinelearning - Reddit, https://www.reddit.com/r/learnmachinelearning/comments/1apy9uf/multihead_in_transformers/</li>
<li>What Does BERT Look at? An Analysis of BERT’s Attention | Request PDF - ResearchGate, https://www.researchgate.net/publication/335778955_What_Does_BERT_Look_at_An_Analysis_of_BERT’s_Attention</li>
<li>What Does BERT Look At? An Analysis of BERT’s Attention | Request PDF - ResearchGate, https://www.researchgate.net/publication/333717618_What_Does_BERT_Look_At_An_Analysis_of_BERT’s_Attention</li>
<li>(PDF) Head information bottleneck (HIB): leveraging information bottleneck for efficient transformer head attribution and pruning - ResearchGate, https://www.researchgate.net/publication/393260332_Head_information_bottleneck_HIB_leveraging_information_bottleneck_for_efficient_transformer_head_attribution_and_pruning</li>
<li>Low-Rank Bottleneck in Multi-head Attention Models - Proceedings of Machine Learning Research, http://proceedings.mlr.press/v119/bhojanapalli20a/bhojanapalli20a.pdf</li>
<li>The New LLM Bottleneck: A Systems Perspective on Latent Attention and Mixture-of-Experts, Yun et al. 2025 - Reddit, https://www.reddit.com/r/mlscaling/comments/1n2axga/the_new_llm_bottleneck_a_systems_perspective_on/</li>
<li>Understanding Self-Attention and Multi-Head Attention in Deep Learning - DEV Community, https://dev.to/nareshnishad/understanding-self-attention-and-multi-head-attention-in-deep-learning-4jg4</li>
<li>LLM Transformer Model Visually Explained - Polo Club of Data Science, https://poloclub.github.io/transformer-explainer/</li>
<li>Transformer의 Multi-Head Attention과 Transformer에서 쓰인 다양한 기법 - 지그시, <a href="https://glanceyes.com/entry/Transformer%EC%9D%98-Multi-Head-Attention%EA%B3%BC-Transformer%EC%97%90%EC%84%9C-%EC%93%B0%EC%9D%B8-%EB%8B%A4%EC%96%91%ED%95%9C-%EA%B8%B0%EB%B2%95">https://glanceyes.com/entry/Transformer%EC%9D%98-Multi-Head-Attention%EA%B3%BC-Transformer%EC%97%90%EC%84%9C-%EC%93%B0%EC%9D%B8-%EB%8B%A4%EC%96%91%ED%95%9C-%EA%B8%B0%EB%B2%95</a></li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>