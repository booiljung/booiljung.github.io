<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.1 RNN과 LSTM이 지배하던 시대</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.1 RNN과 LSTM이 지배하던 시대</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>1.1 RNN과 LSTM이 지배하던 시대</span></nav>
                </div>
            </header>
            <article>
                <h1>1.1 RNN과 LSTM이 지배하던 시대</h1>
<p>2025-12-17, G30DR</p>
<h2>1.  서론: 신경망 르네상스와 시퀀스 모델링의 부상</h2>
<p>2017년, ’트랜스포머(Transformer)’라는 거대한 파도가 인공지능의 해안을 덮치기 직전, 자연어 처리(NLP)와 시퀀스 모델링(Sequence Modeling)의 세계는 이미 한 차례의 뜨거운 혁명을 겪고 있었다. 이 시기는 인공지능 역사에서 ’순환 신경망(Recurrent Neural Network, RNN)’과 그 진화형인 ’장단기 메모리(Long Short-Term Memory, LSTM)’가 절대적인 지배력을 행사하던 시대였다. 딥러닝(Deep Learning)이 이미지 인식 분야에서 알렉스넷(AlexNet, 2012)을 통해 화려하게 부활한 이후, 연구자들의 시선은 정적인 이미지를 넘어 동적인 ’시간(Time)’과 ’순서(Sequence)’가 존재하는 데이터로 빠르게 옮겨갔다. 언어, 음성, 주가 변동, DNA 서열과 같은 시퀀스 데이터는 이전까지 통계적 기법이나 마르코프 체인(Markov Chain)과 같은 고전적 알고리즘의 영역이었으나, RNN과 LSTM의 등장은 이 복잡한 시계열 데이터의 처리를 신경망의 영역으로 완전히 편입시키는 계기가 되었다.</p>
<p>이 장에서는 트랜스포머가 등장하기 전, 즉 2010년대 중반을 전후하여 딥러닝 기반의 자연어 처리가 어떻게 비약적으로 발전했는지, 그리고 그 중심에 있었던 RNN과 LSTM 아키텍처의 기술적 원리와 성과를 심도 있게 분석한다. 당시 구글(Google), 바이두(Baidu), 페이스북(Facebook) 등 글로벌 테크 거인들은 LSTM을 기반으로 한 기계 번역, 음성 인식, 이미지 캡셔닝 시스템을 경쟁적으로 발표하며 ’AI 대각성(The Great AI Awakening)’이라 불리는 시기를 주도했다.</p>
<p>그러나 빛이 밝을수록 그림자도 짙은 법이다. RNN과 LSTM이 이룩한 거대한 성과 이면에는 태생적인 구조적 한계, 즉 순차적 처리(Sequential Processing)로 인한 병렬화의 불가능성과 정보 압축의 병목 현상(Bottleneck)이 자리 잡고 있었다. 우리는 이 시대의 기술적 정점을 조망함과 동시에, 왜 결국 이들이 왕좌를 트랜스포머에게 내어줄 수밖에 없었는지에 대한 필연적인 인과관계를 파헤칠 것이다.</p>
<pre><code class="language-mermaid">graph TD
    A["전통적 알고리즘"] --&gt;|"한계: 기억 능력 부재"| B["신경망 르네상스 (2012 AlexNet 이후)"]
    B --&gt; C["시퀀스 모델링의 부상"]
    C --&gt; D["RNN (Recurrent Neural Network)"]
    D --&gt;|"진화"| E["LSTM (Long Short-Term Memory)"]
    E --&gt;|"주도"| F["AI 대각성 (The Great AI Awakening)"]
    F --&gt; G["주요 응용 분야"]
    G --&gt; H["기계 번역"]
    G --&gt; I["음성 인식"]
    G --&gt; J["이미지 캡셔닝"]
    E --&gt;|"구조적 한계 도달"| K["트랜스포머 (2017)"]
</code></pre>
<h2>2.  순환 신경망(RNN)의 이론적 토대와 메커니즘</h2>
<p>인간의 지능이 가진 가장 큰 특징 중 하나는 ’맥락(Context)’을 이해하는 능력이다. 우리가 문장을 읽을 때, 각 단어는 독립적으로 존재하는 것이 아니라 앞서 읽은 단어들의 기억 위에서 해석된다. “나는 사과를 먹었다“라는 문장에서 ’먹었다’라는 서술어는 ’사과’라는 목적어와의 관계 속에서 그 의미가 확정된다. 그러나 전통적인 피드포워드 신경망(Feed-Forward Neural Network, FNN)은 이러한 기억 능력이 결여되어 있었다. 입력은 독립적으로 처리되었고, 네트워크는 이전의 입력이 무엇이었는지 기억하지 못했다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "RNN의 구조 (Parameter Sharing)"
    X_t["입력(x_t)"] --&gt; H_t["은닉 상태(h_t)"]
    H_prev["이전 은닉 상태(h_t-1)"] --&gt; H_t
    H_t --&gt;|"순환(Loop)"| H_next["다음 은닉 상태(h_t+1)"]
    H_t --&gt; Y_t["출력(y_t)"]
    end

    subgraph "학습의 난제: BPTT와 야코비 행렬"
    Error["오차(Error)"] --&gt;|"역전파"| Grad["기울기 계산"]
    Grad --&gt;|"연쇄 법칙 적용"| Jacobian["야코비 행렬의 거듭제곱"]
    Jacobian --&gt;|"고유값 &lt; 1"| Vanishing["기울기 소실 (Vanishing Gradient)"]
    Jacobian --&gt;|"고유값 &gt; 1"| Exploding["기울기 폭주 (Exploding Gradient)"]
    Vanishing --&gt;|"결과"| Fail["장기 의존성 학습 실패"]
    Exploding --&gt;|"결과"| Unstable["학습 불안정 / NaN 발생"]
    end
</code></pre>
<h3>2.1 시퀀스 데이터와 기억의 필요성</h3>
<p>RNN은 이러한 피드포워드 신경망의 한계를 극복하기 위해 고안되었다. 1980년대 통계 역학(Statistical Mechanics)과 홉필드 네트워크(Hopfield Network) 등에서 영감을 받아 탄생한 RNN은 네트워크 내부에 순환 구조(Loop)를 도입하여 정보를 지속시킬 수 있는 메커니즘을 마련했다.1 이 순환 구조는 이전 단계의 출력이 현재 단계의 입력으로 다시 들어가는 형태로 구현되며, 이를 통해 네트워크는 ’은닉 상태(Hidden State)’라는 일종의 단기 기억을 유지하게 된다.</p>
<h3>2.2 바닐라 RNN의 수식적 정의와 순전파</h3>
<p>가장 기초적인 형태의 RNN, 즉 바닐라 RNN(Vanilla RNN)의 동작 원리는 다음과 같은 수식으로 정의된다. 시점 <span class="math math-inline">t</span>에서의 입력 벡터를 <span class="math math-inline">x_t</span>, 은닉 상태를 <span class="math math-inline">h_t</span>라고 할 때:<br />
<span class="math math-display">
h_t = \tanh(W_{xh} x_t + W_{hh} h_{t-1} + b_h)
</span></p>
<p><span class="math math-display">
y_t = W_{hy} h_t + b_y
</span></p>
<p>여기서 주목해야 할 점은 가중치 행렬 <span class="math math-inline">W_{xh}</span>(입력-은닉), <span class="math math-inline">W_{hh}</span>(은닉-은닉), <span class="math math-inline">W_{hy}</span>(은닉-출력)가 모든 시점 <span class="math math-inline">t</span>에서 동일하게 공유된다는 사실이다(Parameter Sharing).2 이는 RNN이 임의의 길이를 가진 시퀀스를 처리할 수 있게 하는 핵심 기제다. 10단어 문장이든 100단어 문장이든 동일한 파라미터 세트를 반복 사용하여 처리함으로써 모델의 크기를 시퀀스 길이에 독립적으로 유지할 수 있었다. 이 구조 덕분에 RNN은 이론적으로 튜링 완전(Turing Complete)하며, 어떤 시퀀스 패턴이라도 근사할 수 있는 잠재력을 가졌다.</p>
<h3>2.3 시간의 흐름에 따른 역전파(BPTT)와 야코비 행렬의 저주</h3>
<p>RNN의 학습은 일반적인 신경망과 달리 시간 차원을 고려해야 한다. 이를 위해 고안된 알고리즘이 ’시간의 흐름에 따른 역전파(Backpropagation Through Time, BPTT)’이다. BPTT는 순환 구조를 시간 순서대로 펼쳐(Unroll) 마치 아주 깊은 심층 신경망(Deep Neural Network)처럼 만든 후, 오차를 역전파하는 방식이다.3</p>
<p>시점 <span class="math math-inline">t</span>에서 발생한 오차 <span class="math math-inline">E_t</span>를 최소화하기 위해 가중치를 업데이트하려면, 손실 함수 <span class="math math-inline">L</span>에 대한 가중치 <span class="math math-inline">W</span>의 기울기(Gradient)를 계산해야 한다. 연쇄 법칙(Chain Rule)을 적용하면, 이는 과거의 모든 시점 <span class="math math-inline">k</span> (<span class="math math-inline">k &lt; t</span>)에 대한 미분값의 합으로 표현된다.<br />
<span class="math math-display">
\frac{\partial L}{\partial W} = \sum_{k=1}^{t} \frac{\partial L}{\partial h_t} \frac{\partial h_t}{\partial h_k} \frac{\partial h_k}{\partial W}
</span><br />
여기서 핵심적인 문제는 <span class="math math-inline">\frac{\partial h_t}{\partial h_k}</span> 항이다. 이 항은 시점 <span class="math math-inline">k</span>에서 <span class="math math-inline">t</span>까지의 은닉 상태 변화율을 나타내며, 이는 각 타임스텝의 야코비 행렬(Jacobian Matrix)들의 곱으로 분해된다.3<br />
<span class="math math-display">
\frac{\partial h_t}{\partial h_k} = \prod_{j=k+1}^{t} \frac{\partial h_j}{\partial h_{j-1}} = \prod_{j=k+1}^{t} W_{hh}^T \cdot \text{diag}(\sigma&#39;(z_j))
</span><br />
이 수식은 RNN 학습의 가장 치명적인 아킬레스건을 드러낸다. <span class="math math-inline">W_{hh}</span>의 거듭제곱이 식에 포함되어 있기 때문이다.</p>
<h3>2.4 기울기 소실과 폭주: 딥러닝의 겨울을 부른 난제</h3>
<p>만약 가중치 행렬 <span class="math math-inline">W_{hh}</span>의 가장 큰 고유값(Largest Eigenvalue)이 1보다 작다면, 시간 간격 <span class="math math-inline">t-k</span>가 커질수록 이 곱은 지수적으로 0에 수렴하게 된다. 이것이 바로 악명 높은 <strong>기울기 소실(Vanishing Gradient)</strong> 문제이다.6 기울기가 소실된다는 것은, 네트워크가 긴 시퀀스의 끝부분에서 발생한 오차를 통해 시퀀스 앞부분의 가중치를 수정할 수 없음을 의미한다. 즉, 문장의 마지막 단어를 보고 첫 단어를 수정해야 할 정보를 잃어버리는 것이다. 셉 호크라이터(Sepp Hochreiter)는 1991년 자신의 디플로마 논문에서 이 현상을 수학적으로 규명하였으며, 이는 RNN이 장기 의존성(Long-Term Dependency)을 학습하지 못하는 근본 원인이었다.1</p>
<p>반대로 고유값이 1보다 클 경우, 기울기는 지수적으로 발산하여 <strong>기울기 폭주(Exploding Gradient)</strong> 문제를 일으킨다. 이는 가중치를 비정상적으로 크게 업데이트하여 학습 과정을 불안정하게 만들고, 종종 컴퓨터 연산에서 NaN(Not a Number) 오버플로우를 발생시켰다. 기울기 클리핑(Gradient Clipping)과 같은 기법으로 폭주 문제는 어느 정도 제어할 수 있었으나, 소실 문제는 구조적인 해결책을 요구했다.3</p>
<table><thead><tr><th><strong>문제 유형</strong></th><th><strong>현상</strong></th><th><strong>수학적 원인</strong></th><th><strong>결과</strong></th><th><strong>해결책 (초기)</strong></th></tr></thead><tbody>
<tr><td><strong>기울기 소실</strong></td><td>역전파 시 기울기가 0에 가까워짐</td><td>야코비 행렬의 고유값 &lt; 1</td><td>장기 의존성 학습 실패, 초기 입력 무시</td><td>LSTM, GRU, ReLU</td></tr>
<tr><td><strong>기울기 폭주</strong></td><td>역전파 시 기울기가 무한대로 발산</td><td>야코비 행렬의 고유값 &gt; 1</td><td>가중치 발산, 학습 불안정, NaN 발생</td><td>기울기 클리핑(Gradient Clipping)</td></tr>
</tbody></table>
<h2>3.  장단기 메모리(LSTM): 기억의 지속을 위한 혁명적 설계</h2>
<p>RNN의 이론적 한계를 극복하고 딥러닝의 NLP 정복을 가능하게 한 것은 1997년 셉 호크라이터와 위르겐 슈미트후버(Jürgen Schmidhuber)가 제안한 **장단기 메모리(Long Short-Term Memory, LSTM)**였다.1 LSTM은 단순한 모델의 개선이 아니라, 기울기 소실 문제를 우회하기 위해 정교하게 설계된 ’기억 장치’였다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "LSTM 셀 내부 메커니즘"
    Prev_C["이전 셀 상태(C_t-1)"] --&gt;|"정보 고속도로"| Curr_C["현재 셀 상태(C_t)"]
    Prev_H["이전 은닉 상태(h_t-1)"] &amp; Input_X["입력(x_t)"] --&gt; Gates
    
    subgraph "게이트 제어 (Sigmoid)"
        Gates --&gt; Forget["망각 게이트(f_t): 불필요 정보 삭제"]
        Gates --&gt; Input["입력 게이트(i_t): 새 정보 추가"]
        Gates --&gt; Output["출력 게이트(o_t): 다음 은닉 상태 결정"]
    end

    Forget --&gt;|"곱하기 연산"| Prev_C
    Input --&gt;|"정보 생성"| New_Info["새로운 정보(~C_t)"]
    New_Info --&gt;|"더하기 연산 (기울기 보존)"| Curr_C
    Curr_C --&gt;|"Tanh &amp; 곱하기"| Output
    Output --&gt; Curr_H["현재 은닉 상태(h_t)"]
    end

    subgraph "CEC (Constant Error Carousel)"
    Curr_C -.-&gt;|"덧셈 연산으로 역전파"| Prev_C
    Note["기울기가 소실되지 않고 과거로 전달됨"]
    end
</code></pre>
<h3>3.1 LSTM 셀의 해부: 셀 상태와 게이트 메커니즘</h3>
<p>LSTM의 핵심 아이디어는 네트워크 내부에 **셀 상태(Cell State, <span class="math math-inline">C_t</span>)**라는 고속도로를 뚫어주는 것이다. 기존 RNN이 매 단계마다 활성화 함수(<span class="math math-inline">\tanh</span>)를 통과하며 정보를 변형시켰다면, LSTM의 셀 상태는 정보가 큰 간섭 없이 시간 축을 따라 흐를 수 있도록 보장한다. 그리고 이 흐름을 제어하기 위해 세 가지의 ’게이트(Gate)’를 도입했다.11 각 게이트는 시그모이드(<span class="math math-inline">\sigma</span>) 활성화 함수를 사용하여 0(완전 차단)과 1(완전 통과) 사이의 값을 출력, 정보의 흐름 양을 조절한다.</p>
<ol>
<li>
<p>망각 게이트(Forget Gate, <span class="math math-inline">f_t</span>): 과거의 기억(<span class="math math-inline">C_{t-1}</span>) 중 불필요한 정보를 얼마나 지울지 결정한다.<br />
<span class="math math-display">
f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)
</span><br />
입력 게이트(Input Gate, <span class="math math-inline">i_t</span>): 현재의 새로운 정보(<span class="math math-inline">\tilde{C}_t</span>)를 얼마나 기억에 추가할지 결정한다.<br />
<span class="math math-display">
i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)
</span></p>
<p><span class="math math-display">
\tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C)
</span></p>
</li>
</ol>
<p>출력 게이트(Output Gate, <span class="math math-inline">o_t</span>): 갱신된 셀 상태(<span class="math math-inline">C_t</span>)를 바탕으로 현재의 은닉 상태(<span class="math math-inline">h_t</span>)를 어떻게 출력할지 결정한다.<br />
<span class="math math-display">
   o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)
</span></p>
<p><span class="math math-display">
   h_t = o_t \cdot \tanh(C_t)
</span></p>
<p>상수 오차 회전목마(CEC)와 기울기 보존의 원리</p>
<p>LSTM이 기울기 소실 문제를 해결하는 비결은 셀 상태의 업데이트 식에 있다.7<br />
<span class="math math-display">
C_t = f_t \cdot C_{t-1} + i_t \cdot \tilde{C}_t
</span><br />
이 식에서 역전파를 수행할 때, 셀 상태 <span class="math math-inline">C_t</span>를 이전 셀 상태 <span class="math math-inline">C_{t-1}</span>로 미분하면 <span class="math math-inline">f_t</span>항이 남게 된다. 기존 RNN이 행렬 곱셈으로 연결되어 기울기가 급격히 변했던 것과 달리, LSTM은 **덧셈 연산(Additive Update)**을 통해 기울기를 전달한다. 만약 망각 게이트 <span class="math math-inline">f_t</span>가 1에 가깝게 설정된다면, 기울기는 시간의 흐름을 거슬러 과거로 거의 손실 없이 전달될 수 있다. 호크라이터는 이를 “상수 오차 회전목마(Constant Error Carousel, CEC)“라고 명명했다. 이는 마치 컨베이어 벨트처럼 오차 정보를 과거의 시점까지 안전하게 배달하는 역할을 수행했다.</p>
<h3>3.2 GRU(Gated Recurrent Unit): 효율성을 향한 경량화</h3>
<p>LSTM의 성공 이후, 2014년 조경현(Kyunghyun Cho) 등은 LSTM의 복잡한 구조를 단순화한 **GRU(Gated Recurrent Unit)**를 제안했다.11 GRU는 셀 상태와 은닉 상태를 하나로 합치고, 망각 게이트와 입력 게이트를 ‘업데이트 게이트(Update Gate)’ 하나로 통합했다.</p>
<ul>
<li><strong>리셋 게이트(Reset Gate, <span class="math math-inline">r_t</span>):</strong> 과거의 은닉 상태를 얼마나 무시할지 결정.</li>
<li><strong>업데이트 게이트(Update Gate, <span class="math math-inline">z_t</span>):</strong> 과거의 상태를 얼마나 유지할지 결정 (LSTM의 망각+입력 게이트 역할).</li>
</ul>
<p>GRU는 LSTM보다 파라미터 수가 적어 학습 속도가 빠르고, 데이터가 적은 경우에도 우수한 성능을 보여주었다. LSTM과 GRU는 상호 보완적인 관계를 형성하며 2010년대 중반 NLP 연구의 표준 블록이 되었다.</p>
<h2>4.  시퀀스-투-시퀀스(Seq2Seq)와 인코더-디코더 패러다임</h2>
<p>LSTM이 개별 시퀀스 처리에 강력함을 보였지만, 기계 번역과 같이 입력 시퀀스와 출력 시퀀스의 길이가 다르고 구조가 상이한 문제를 해결하기 위해서는 새로운 아키텍처가 필요했다. 2014년, 구글의 일리야 수츠케버(Ilya Sutskever)와 조경현 교수는 각각 <strong>Seq2Seq(Sequence-to-Sequence)</strong> 모델을 발표하며 NLP의 역사적 전환점을 마련했다.14</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Input as "입력 문장 ('I love AI')"
    participant Encoder as "인코더 (RNN/LSTM)"
    participant Context as "문맥 벡터 (Thought Vector)"
    participant Decoder as "디코더 (RNN/LSTM)"
    participant Output as "출력 문장 ('나는 AI를 사랑해')"

    Input-&gt;&gt;Encoder: "순차적 입력 (Step 1..N)"
    loop "정보 압축"
        Encoder-&gt;&gt;Encoder: "은닉 상태 업데이트"
    end
    Encoder-&gt;&gt;Context: "모든 정보를 고정 길이 벡터로 압축"
    Note over Context: "병목 구간 (Bottleneck)"
    Context-&gt;&gt;Decoder: "초기 상태로 전달"
    loop "순차적 생성"
        Decoder-&gt;&gt;Decoder: "이전 단어를 기반으로 다음 단어 예측"
    end
    Decoder-&gt;&gt;Output: "타겟 언어 생성"
</code></pre>
<h3>4.1 고정 길이 벡터로의 압축: 생각 벡터(Thought Vector)</h3>
<p>Seq2Seq 모델은 두 개의 독립적인 RNN(주로 LSTM 또는 GRU)을 결합한 <strong>인코더-디코더(Encoder-Decoder)</strong> 구조를 취한다.</p>
<ul>
<li><strong>인코더(Encoder):</strong> 입력 문장(예: 영어 “I love AI”)을 순차적으로 읽어들여, 문장의 모든 의미 정보를 담은 고정된 크기의 벡터인 **문맥 벡터(Context Vector)**로 압축한다. 제프리 힌튼은 이 벡터가 문장의 의미를 내포하고 있다 하여 ’생각 벡터(Thought Vector)’라고 불렀다.</li>
<li><strong>디코더(Decoder):</strong> 인코더가 생성한 문맥 벡터를 초기 상태로 받아, 타겟 언어(예: 한국어 “나는 AI를 사랑해”)를 단어 단위로 순차적으로 생성한다.</li>
</ul>
<p>이 구조는 입력과 출력의 길이가 달라도(Many-to-Many) 처리가 가능하며, 언어의 어순이 달라도 문맥 벡터라는 추상적 공간을 통해 매핑할 수 있다는 강력한 장점을 가졌다.</p>
<h3>4.2 통계적 기계 번역(SMT)에서 신경망 기계 번역(NMT)으로</h3>
<p>Seq2Seq의 등장은 기존의 <strong>통계적 기계 번역(Statistical Machine Translation, SMT)</strong> 패러다임을 종식시켰다. SMT는 언어학적 규칙에 기반한 복잡한 파이프라인(단어 정렬, 구문 번역, 언어 모델 등)을 개별적으로 튜닝해야 했다. 반면 Seq2Seq 기반의 **신경망 기계 번역(Neural Machine Translation, NMT)**은 입력 문장과 출력 문장 쌍만 있으면, 그 사이의 복잡한 번역 규칙을 하나의 거대한 신경망이 스스로 학습하는 <strong>End-to-End</strong> 방식을 채택했다.16 이는 시스템 구축의 복잡도를 획기적으로 낮추면서도 성능은 비약적으로 향상시키는 결과를 낳았다.</p>
<h2>5.  구글 신경망 기계 번역(GNMT): 상용화된 인공지능의 정점</h2>
<p>2016년 9월, 구글은 자사의 번역 서비스(Google Translate)를 기존의 SMT 방식에서 신경망 기반의 <strong>GNMT(Google Neural Machine Translation)</strong> 시스템으로 전면 교체한다고 발표했다.18 이는 RNN과 LSTM 기술이 실험실을 넘어 전 세계 수억 명이 사용하는 실제 서비스에 적용된 기념비적인 사건이었다.</p>
<pre><code class="language-mermaid">mindmap
  root(("GNMT 아키텍처"))
    ("모델 구조")
      ("인코더")
        ("첫 층: 양방향(Bidirectional) LSTM")
        ("나머지: 단방향 LSTM")
      ("디코더")
        ("8층 심층 LSTM (Deep LSTM)")
        ("어텐션 메커니즘 (Attention)")
      ("연결 방식")
        ("잔차 연결 (Residual Connection)")
        ("학습 수렴 가속화")
    ("데이터 처리")
      ("워드피스 (WordPiece)")
        ("서브워드 단위 분해")
        ("희귀 단어/Unknown 토큰 해결")
    ("하드웨어 &amp; 성능")
      ("TPU (Tensor Processing Unit)")
        ("전용 하드웨어 가속")
      ("낮은 정밀도 연산")
        ("추론 속도 향상")
    ("성과")
      ("번역 오류 60% 감소")
      ("인간 번역 수준 근접")
</code></pre>
<h3>5.1 GNMT 아키텍처의 심층 분석: 8층 LSTM과 잔차 연결</h3>
<p>GNMT는 당시 기술의 집약체였다. 단순한 Seq2Seq를 넘어, 성능과 속도를 극대화하기 위한 다양한 엔지니어링 기법이 적용되었다.17</p>
<ol>
<li><strong>심층 LSTM (Deep LSTM):</strong> 인코더와 디코더에 각각 8개의 LSTM 레이어를 쌓아 깊이를 더했다. 층이 깊어질수록 모델은 더 추상적이고 복잡한 언어적 특징을 학습할 수 있었다.</li>
<li><strong>양방향 인코더 (Bidirectional Encoder):</strong> 인코더의 첫 번째 층은 양방향 LSTM으로 구성하여, 문장의 앞뒤 문맥을 동시에 파악했다.</li>
<li><strong>잔차 연결 (Residual Connection):</strong> 8층이나 되는 깊은 신경망의 학습을 돕기 위해, 레즈넷(ResNet)에서 사용된 잔차 연결을 도입하여 기울기 소실 문제를 추가적으로 완화하고 수렴 속도를 높였다.</li>
<li><strong>어텐션 메커니즘 (Attention Mechanism):</strong> 디코더의 첫 번째 층과 인코더의 마지막 층을 연결하는 어텐션 모듈을 탑재하여 긴 문장 번역 성능을 보강했다.</li>
</ol>
<h3>5.2 하드웨어 가속과 TPU의 등장</h3>
<p>GNMT의 거대한 연산량을 감당하기 위해 구글은 자체 개발한 AI 전용 칩인 **TPU(Tensor Processing Unit)**를 전면에 내세웠다.18 또한, 추론(Inference) 단계에서는 낮은 정밀도(Low-precision) 연산을 사용하여 번역 속도를 가속화했다. 이는 딥러닝 알고리즘과 하드웨어의 공진화(Co-evolution)를 보여주는 대표적인 사례였다.</p>
<h3>5.3 워드피스(WordPiece) 모델과 희귀 단어 처리</h3>
<p>기존 NMT의 문제 중 하나는 학습 데이터에 없는 ’희귀 단어(Rare Word)’나 ’고유 명사’를 처리하지 못하고 ‘Unknown()’ 토큰으로 출력하는 것이었다. GNMT는 이를 해결하기 위해 단어를 더 작은 의미 단위인 **서브워드(Subword)**로 쪼개는 <strong>워드피스(WordPiece)</strong> 모델을 도입했다.17 예를 들어 “unhappiness“를 “un-”, “happy”, “-ness“로 분해하여 처리함으로써, 모르는 단어라도 그 구성 성분을 통해 의미를 유추하거나 번역할 수 있게 되었다.</p>
<h3>5.4 번역 품질의 비약적 상승과 ‘AI 대각성’</h3>
<p>GNMT의 도입 결과는 충격적이었다. 구글의 발표에 따르면, GNMT는 기존 구문 기반 시스템 대비 번역 오류를 평균 **60%**나 감소시켰다.18 영어-프랑스어, 영어-스페인어 등 주요 언어 쌍에서 GNMT는 인간 번역가의 수준에 근접하는 평가를 받았다. 뉴욕타임스는 이를 두고 “The Great A.I. Awakening(AI 대각성)“이라는 제목의 특집 기사를 다루며, 인공지능이 언어라는 인간 고유의 영역을 정복하기 시작했음을 알렸다.</p>
<table><thead><tr><th><strong>모델</strong></th><th><strong>BLEU 점수 (영어<span class="math math-inline">\rightarrow</span>프랑스어)</strong></th><th><strong>특징</strong></th></tr></thead><tbody>
<tr><td>기존 SMT (Phrase-based)</td><td>37.0</td><td>수작업 규칙, 통계적 정렬</td></tr>
<tr><td>GNMT (Single Model)</td><td><strong>38.95</strong></td><td>8층 LSTM, Residual, WordPiece</td></tr>
<tr><td>GNMT (Ensemble)</td><td><strong>41.16</strong></td><td>여러 모델의 결과 결합</td></tr>
<tr><td>인간 번역 (Human)</td><td>- (참조용)</td><td>뉘앙스와 완벽한 문맥 이해</td></tr>
</tbody></table>
<h2>6.  언어의 장벽을 넘어: 시각과 청각으로의 확장</h2>
<p>RNN과 LSTM의 지배력은 텍스트 처리에만 국한되지 않았다. 이들은 컴퓨터 비전과 음성 인식 분야로 융합되며 멀티모달(Multimodal) AI의 시대를 열었다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Show and Tell: 이미지 캡셔닝"
    Img["이미지 입력"] --&gt;|"CNN (Inception-v3)"| Feat["특징 벡터 추출"]
    Feat --&gt;|"초기 입력"| LSTM_Cap["LSTM 디코더"]
    LSTM_Cap --&gt;|"단어 생성"| Text_Out["문장 출력 ('사람들이 테이블에...')"]
    end

    subgraph "Deep Speech: End-to-End 음성 인식"
    Audio["오디오 스펙트로그램"] --&gt;|"Bi-RNN"| RNN_Speech["양방향 순환 신경망"]
    RNN_Speech --&gt;|"CTC 손실 함수"| Text_Speech["텍스트 출력"]
    end
</code></pre>
<h3>6.1 Show and Tell: 이미지를 캡션으로 번역하다</h3>
<p>2015년, 오리올 빈얄스(Oriol Vinyals) 등 구글 연구팀은 **“Show and Tell”**이라는 논문을 통해 이미지 캡셔닝(Image Captioning) 모델을 발표했다.21 이 연구의 핵심은 ’이미지를 문장으로 번역’한다는 발상의 전환이었다.</p>
<ul>
<li><strong>인코더:</strong> CNN(Convolutional Neural Network, 예: Inception-v3)을 사용하여 이미지를 고차원 특징 벡터로 변환한다.</li>
<li><strong>디코더:</strong> LSTM을 사용하여 CNN이 추출한 특징 벡터를 초기 입력으로 받아, 이미지를 묘사하는 문장을 생성한다.</li>
</ul>
<p>이 모델은 파스칼(Pascal) 데이터셋에서 기존 SOTA 모델(BLEU 25)을 압도하는 <strong>BLEU 59</strong>점을 기록하며 학계를 놀라게 했다.22 기계가 사진을 보고 “A group of people sitting at a table with food(사람들이 음식이 있는 테이블에 앉아 있다)“와 같은 정확한 문장을 생성해내는 모습은, LSTM이 시각 정보와 언어 정보를 연결하는 다리 역할을 완벽히 수행함을 증명했다.</p>
<h3>6.2 Deep Speech: 음성 인식의 End-to-End 혁명</h3>
<p>음성 인식 분야에서는 바이두(Baidu)의 앤드류 응 팀이 개발한 Deep Speech가 RNN의 위력을 보여주었다.25 기존의 음성 인식은 음소(Phoneme) 단위의 정렬과 복잡한 HMM-GMM(Hidden Markov Model - Gaussian Mixture Model) 파이프라인에 의존했다.</p>
<p>Deep Speech는 스펙트로그램(Spectrogram)을 입력으로 받아 양방향 RNN(Bi-RNN)을 통과시킨 후, CTC(Connectionist Temporal Classification) 손실 함수를 사용하여 직접 텍스트를 출력하는 End-to-End 방식을 채택했다. 이 방식은 잡음이 심한 환경에서도 기존 모델 대비 월등한 성능을 보였으며, 음성 인식 시스템 구축의 난이도를 대폭 낮추었다.27</p>
<h3>6.3 안드레 카파시와 ‘RNN의 불합리한 효율성’</h3>
<p>이 시기 RNN 열풍의 정점을 보여주는 상징적인 사건은 안드레 카파시(Andrej Karpathy)의 블로그 포스트 **“The Unreasonable Effectiveness of Recurrent Neural Networks (RNN의 불합리할 정도의 효율성)”**이었다.29 그는 문자(Character) 단위의 단순한 RNN 모델에 셰익스피어 희곡, 리눅스 소스 코드, 위키백과 문서 등을 학습시켰다.</p>
<p>놀랍게도 RNN은 단어의 개념조차 모른 채 문자들의 순서만을 학습하여, 셰익스피어 풍의 고어체 대사를 창작하고, 문법적으로 (거의) 올바른 C언어 코드를 생성해냈다.31 닫는 괄호 }를 정확한 위치에 배치하고, 변수를 선언하고 사용하는 패턴을 스스로 깨우친 RNN의 모습은 많은 연구자들에게 깊은 영감을 주었으며, 시퀀스 모델링이 가진 잠재력이 상상 이상임을 대중에게 각인시켰다.</p>
<h2>7.  제국의 균열: 고정 벡터의 병목과 순차 처리의 한계</h2>
<p>2016년 말, RNN과 LSTM은 자연어 처리의 왕좌에 앉아 있었지만, 그 견고해 보이는 성벽에는 이미 심각한 균열이 가고 있었다. 데이터셋이 거대해지고, 더 긴 문맥, 더 빠른 처리에 대한 요구가 빗발치면서 RNN 구조가 가진 태생적 한계가 드러나기 시작했다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Seq2Seq의 병목 현상"
    Long_Input["긴 입력 시퀀스 (100단어+)"] --&gt; Encoder
    Encoder --&gt;|"정보 압축 시도"| Vector["고정 길이 문맥 벡터"]
    Vector --&gt;|"정보 손실/희석"| Decoder
    Decoder --&gt;|"품질 저하"| Bad_Output["부정확한 긴 문장 번역"]
    end

    subgraph "RNN의 계산 복잡도 문제"
    Seq_Nature["순차적 속성 (Sequential Nature)"] --&gt;|"h_t는 h_t-1이 필요"| Dependency["시간적 의존성"]
    Dependency --&gt;|"병렬 처리 불가"| GPU_Idle["GPU 자원 활용도 저하"]
    GPU_Idle --&gt;|"학습 속도 저하"| Limit["대규모 데이터 학습의 한계"]
    end
    
    Limit --&gt;|"해결책 갈망"| Transformer["트랜스포머의 등장 (Attention Is All You Need)"]
</code></pre>
<h3>7.1 정보 압축의 딜레마: 병목 현상(Bottleneck)</h3>
<p>Seq2Seq 모델의 가장 치명적인 약점은 인코더가 생성하는 **고정 길이 문맥 벡터(Fixed-length Context Vector)**였다.32 인코더는 입력 문장의 길이가 10단어이든 100단어이든, 모든 정보를 동일한 크기의 벡터(예: 1024차원) 하나에 압축해 넣어야 했다. 이는 정보 이론적으로 명백한 손실을 야기했다. 긴 문장의 앞부분 정보는 인코딩 과정에서 희석되거나 소실되기 쉬웠으며, 이는 긴 문장 번역 품질의 급격한 저하로 이어졌다.14</p>
<h3>7.2 바다나우 어텐션(Bahdanau Attention): 트랜스포머의 전조</h3>
<p>이 병목 현상을 해결하기 위해 2014년, 요슈아 벤지오(Yoshua Bengio) 팀의 바다나우(Dzmitry Bahdanau) 등은 **어텐션 메커니즘(Attention Mechanism)**을 제안했다.34</p>
<p>어텐션의 핵심은 “디코더가 단어를 생성할 때마다, 인코더의 모든 은닉 상태를 다시 훑어보고(Search), 현재 예측해야 할 단어와 가장 연관성이 높은 부분에 집중(Attention)하자“는 것이었다.<br />
<span class="math math-display">
c_i = \sum_{j=1}^{T_x} \alpha_{ij} h_j
</span><br />
여기서 <span class="math math-inline">\alpha_{ij}</span>는 디코더의 <span class="math math-inline">i</span>번째 시점과 인코더의 <span class="math math-inline">j</span>번째 시점 사이의 연관성 가중치(Attention Score)이다. 이 기법은 고정 벡터의 병목을 뚫어주며 번역 성능을 크게 향상시켰다. 하지만 당시 어텐션은 어디까지나 RNN을 보조하는(Add-on) 모듈로 인식되었으며, RNN의 순차적 구조 자체를 대체하지는 못했다.35</p>
<h3>7.3 병렬화의 불가능성과 계산 복잡도의 벽</h3>
<p>RNN의 가장 본질적인 한계는 순차성(Sequential Nature) 그 자체였다.36 RNN은 시점 <span class="math math-inline">t</span>의 계산을 위해 반드시 시점 <span class="math math-inline">t-1</span>의 계산 결과(은닉 상태)가 필요하다.<br />
<span class="math math-display">
h_t = f(h_{t-1}, x_t)
</span><br />
이 의존성은 최신 GPU와 같은 병렬 연산 하드웨어의 이점을 활용하는 데 치명적인 걸림돌이었다. GPU는 수천 개의 코어를 동시에 사용하여 대규모 행렬 연산을 처리하는 데 특화되어 있지만, RNN은 한 번에 한 단계씩만 전진할 수 있었기에 GPU의 가용 자원을 대부분 놀려야 했다. 문장 길이가 <span class="math math-inline">N</span>일 때, RNN의 학습 시간은 <span class="math math-inline">O(N)</span>에 비례했다.38 데이터의 양이 기하급수적으로 늘어나는 빅데이터 시대에, 학습 속도를 높일 수 없다는 것은 모델의 스케일업(Scale-up)을 가로막는 결정적인 장벽이었다.</p>
<h3>7.4 장기 의존성 문제의 잔존</h3>
<p>LSTM과 GRU가 기울기 소실 문제를 완화시켰음에도 불구하고, 수천 토큰 이상의 매우 긴 시퀀스(예: 책 한 권, 긴 대화 로그)를 처리하는 데에는 여전히 한계가 있었다.39 정보가 순환 경로를 통과할 때마다 미세한 노이즈가 축적되거나 정보가 희석되는 현상은 완전히 사라지지 않았다. 연구자들은 “순환(Recurrence)을 없애고 싶다“는 근원적인 갈망을 느끼기 시작했다.</p>
<h2>8.  결론: 트랜스포머 싱귤래리티 직전의 풍경</h2>
<p>2016년까지 인공지능 학계는 RNN과 LSTM이라는 강력한 도구를 통해 ’인지(Perception)’를 넘어 ’생성(Generation)’과 ’이해(Understanding)’의 영역으로 진입했다. 기계는 번역하고, 보고, 듣고, 말하기 시작했다. GNMT와 같은 시스템은 상용 서비스의 품질을 인간 수준으로 끌어올렸으며, 딥러닝의 가능성에 대한 전 세계적인 확신을 심어주었다.</p>
<p>그러나 그 화려한 성공의 이면에서 연구자들은 벽에 부딪히고 있었다. 더 큰 데이터를 학습시키고 싶어도 RNN의 느린 속도가 발목을 잡았고, 더 긴 문맥을 이해시키고 싶어도 순환 구조의 한계가 명확했다. 어텐션 메커니즘은 병목 문제를 해결할 열쇠로 등장했지만, 여전히 RNN이라는 느린 숙주에 기생하고 있었다.</p>
<p>“과연 순환 구조(Recurrence)가 반드시 필요한가?”</p>
<p>“어텐션(Attention)만으로 시퀀스를 처리할 수는 없는가?”</p>
<p>이 질문들이 태동하던 바로 그 시점, 구글의 연구원들은 새로운 아키텍처를 구상하고 있었다. RNN과 LSTM이 지배하던 시대는 그 자체로 위대했으나, 동시에 자신의 한계를 통해 다음 세대의 혁명을 잉태하고 있었다. 바야흐로 2017년, **“Attention Is All You Need”**라는 도발적인 제목의 논문과 함께, 트랜스포머 싱귤래리티가 시작되려 하고 있었다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>History of artificial neural networks - Wikipedia, https://en.wikipedia.org/wiki/History_of_artificial_neural_networks</li>
<li>In-Depth Explanation Of Recurrent Neural Network - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2021/07/in-depth-explanation-of-recurrent-neural-network/</li>
<li>Understanding Gradient Clipping (and How It Can Fix Exploding Gradients Problem), https://neptune.ai/blog/understanding-gradient-clipping-and-how-it-can-fix-exploding-gradients-problem</li>
<li>9.7. Backpropagation Through Time — Dive into Deep Learning 1.0.3 documentation, https://d2l.ai/chapter_recurrent-neural-networks/bptt.html</li>
<li>How does LSTM prevent the vanishing gradient problem? - Cross Validated, https://stats.stackexchange.com/questions/185639/how-does-lstm-prevent-the-vanishing-gradient-problem</li>
<li>What is LSTM - Long Short Term Memory - GeeksforGeeks, https://www.geeksforgeeks.org/deep-learning/deep-learning-introduction-to-long-short-term-memory/</li>
<li>Prevent the Vanishing Gradient Problem with LSTM | Baeldung on Computer Science, https://www.baeldung.com/cs/lstm-vanishing-gradient-prevention</li>
<li>On the difficulty of training Recurrent Neural Networks - arXiv, https://arxiv.org/pdf/1211.5063</li>
<li>Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients - Denny’s Blog, https://dennybritz.com/posts/wildml/recurrent-neural-networks-tutorial-part-3/</li>
<li>Evolution of NLP: From Past Limitations to Modern Capabilities | by purpleSlate | Medium, https://medium.com/@social_65128/evolution-of-nlp-from-past-limitations-to-modern-capabilities-6dc1505faeb6</li>
<li>Recurrent Neural Network Guide: a Deep Dive in RNN - Neptune.ai, https://neptune.ai/blog/recurrent-neural-network-guide</li>
<li>How LSTMs Solve the Vanishing Gradient Problem in Sequential Data? | by Ravjot Singh, https://ravjot03.medium.com/how-lstms-solve-the-vanishing-gradient-problem-in-sequential-data-b786eec3966f</li>
<li>10.1. Long Short-Term Memory (LSTM) — Dive into Deep Learning …, https://d2l.ai/chapter_recurrent-modern/lstm.html</li>
<li>12월 17, 2025에 액세스, [https://en.wikipedia.org/wiki/Seq2seq#:<sub>:text=In%20the%20seq2seq%20as%20proposed,the%20fixed%2Dlength%20encoding%20vector.](https://en.wikipedia.org/wiki/Seq2seq#:</sub>:text=In the seq2seq as proposed, <a href="https://en.wikipedia.org/wiki/Seq2seq#:~:text=In%20the%20seq2seq%20as%20proposed,the%20fixed-length%20encoding%20vector.">https://en.wikipedia.org/wiki/Seq2seq#:~:text=In%20the%20seq2seq%20as%20proposed,the%20fixed%2Dlength%20encoding%20vector.</a></li>
<li>Seq2seq - Wikipedia, https://en.wikipedia.org/wiki/Seq2seq</li>
<li>Google Neural Machine Translation: End-to-End Learning Revolutionizes Translation - Interactive | Michael Brenndoerfer, https://mbrenndoerfer.com/writing/google-neural-machine-translation-end-to-end-learning-revolutionizes-translation</li>
<li>Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation - arXiv, https://arxiv.org/pdf/1609.08144</li>
<li>Google’s Neural Machine Translation System: Bridging the Gap …, https://arxiv.org/abs/1609.08144</li>
<li>Google Neural Machine Translation - Wikipedia, https://en.wikipedia.org/wiki/Google_Neural_Machine_Translation</li>
<li>Review — Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation (GNMT) - Sik-Ho Tsang, https://sh-tsang.medium.com/review-googles-neural-machine-translation-system-bridging-the-gap-between-human-and-machine-518595d87226</li>
<li>Show and Tell: A Neural Image Caption Generator - University of Illinois, https://courses.grainger.illinois.edu/ie534/fa2018/Final_report.pdf</li>
<li>Show and Tell: A Neural Image Caption Generator - The Computer Vision Foundation, https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vinyals_Show_and_Tell_2015_CVPR_paper.pdf</li>
<li>Review — Show and Tell: A Neural Image Caption Generator | by Sik-Ho Tsang | Medium, https://sh-tsang.medium.com/review-show-and-tell-a-neural-image-caption-generator-2d3928a90306</li>
<li>Show and Tell: Lessons learned from the 2015 MSCOCO Image Captioning Challenge - CMU School of Computer Science, https://www.cs.cmu.edu/~jeanoh/16-785/papers/vinyals-pami2016-show-tell.pdf</li>
<li>Arabic speech recognition model using Baidu’s deep and cluster learning - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC12444662/</li>
<li>Audio Deep Learning Made Simple: Automatic Speech Recognition (ASR), How it Works, https://medium.com/data-science/audio-deep-learning-made-simple-automatic-speech-recognition-asr-how-it-works-716cfce4c706</li>
<li>Deep Speech: Scaling up end-to-end speech recognition - arXiv, https://arxiv.org/pdf/1412.5567</li>
<li>A Comparative Analytic Study on the Gaussian Mixture and Context Dependent Deep Neural Network Hidden Markov Models - ISCA Archive, https://www.isca-archive.org/interspeech_2014/huang14d_interspeech.pdf</li>
<li>The Unreasonable Effectiveness of Recurrent Neural Networks - Andrej Karpathy blog, http://karpathy.github.io/2015/05/21/rnn-effectiveness/</li>
<li>Revisiting Karpathy’s ‘The Unreasonable Effectiveness of Recurrent Neural Networks’, https://www.gilesthomas.com/2025/10/revisiting-karpathy-unreasonable-effectiveness-rnns</li>
<li>Unreasonable Effectiveness of Recurrent Neural Networks | by Nitish Jain | Medium, https://medium.com/@nitishj_57176/unreasonable-effectiveness-of-recurrent-neural-networks-f5b64fdb097e</li>
<li>Encoder-Decoder and Attention Mechanism Theory - Kaggle, https://www.kaggle.com/code/amansherjadakhan/encoder-decoder-and-attention-mechanism-theory</li>
<li>The fixed length bottleneck and the feed forward network - Giles’ blog, https://www.gilesthomas.com/2025/08/the-fixed-length-bottleneck-and-the-feed-forward-network</li>
<li>Neural Machine Translation by Jointly Learning to Align and Translate - Semantic Scholar, https://www.semanticscholar.org/paper/Neural-Machine-Translation-by-Jointly-Learning-to-Bahdanau-Cho/fa72afa9b2cbc8f0d7b05d52548906610ffbb9c5</li>
<li>The Bahdanau Attention Mechanism - MachineLearningMastery.com, https://machinelearningmastery.com/the-bahdanau-attention-mechanism/</li>
<li>The Limitations of Recurrent Neural Networks (RNNs) and Why They Matter - Medium, https://medium.com/@yonasdesta2012/the-limitations-of-recurrent-neural-networks-rnns-and-why-they-matter-eb0a05c90b60</li>
<li>Transformer (deep learning) - Wikipedia, https://en.wikipedia.org/wiki/Transformer_(deep_learning)</li>
<li>Why does the transformer do better than RNN and LSTM in long-range context dependencies?, https://ai.stackexchange.com/questions/20075/why-does-the-transformer-do-better-than-rnn-and-lstm-in-long-range-context-depen</li>
<li>(PDF) DRAWBACKS OF LSTM ALGORITHM: A CASE STUDY - ResearchGate, https://www.researchgate.net/publication/398082802_DRAWBACKS_OF_LSTM_ALGORITHM_A_CASE_STUDY</li>
<li>Attention-Based Long Short-Term Memory Recurrent Neural Network for Capacity Degradation of Lithium-Ion Batteries - MDPI, https://www.mdpi.com/2313-0105/7/4/66</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>