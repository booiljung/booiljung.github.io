<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.2 BART 인코더-디코더의 재결합과 Denoising</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.2 BART 인코더-디코더의 재결합과 Denoising</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>5.2 BART 인코더-디코더의 재결합과 Denoising</span></nav>
                </div>
            </header>
            <article>
                <h1>5.2 BART 인코더-디코더의 재결합과 Denoising</h1>
<p>2025-12-20, G30DR</p>
<p>본 장에서는 2019년 페이스북 AI 리서치(FAIR)의 마이크 루이스(Mike Lewis)와 연구팀이 제안한 BART(Bidirectional and Auto-Regressive Transformers) 모델의 아키텍처적 혁신과 학습 방법론을 심층적으로 분석한다. 자연어 처리(NLP) 연구의 흐름에서 BART는 BERT의 양방향 인코더(Bidirectional Encoder)가 가진 이해 능력과 GPT의 자기회귀 디코더(Auto-Regressive Decoder)가 가진 생성 능력을 단일 시퀀스-투-시퀀스(Sequence-to-Sequence) 모델로 통합하려는 시도로 등장했다. 특히, BART가 채택한 ’Denoising Autoencoder’로서의 정체성과 이를 구현하기 위해 고안된 다양한 텍스트 훼손(Corruption) 및 복원 기법들은 현대 거대 언어 모델(LLM)의 사전 학습 전략에 중요한 이론적 토대를 제공했다. 본고에서는 BART의 구조적 재결합(Recombination) 원리, 수학적 배경, 5가지 핵심 노이즈 기법의 작동 원리, 그리고 이들이 다운스트림 태스크 성능에 미치는 영향을 포괄적으로 다룬다.</p>
<h2>1.  인코더-디코더 이분법의 통합과 구조적 일반화</h2>
<p>BART가 등장하기 전, NLP 사전 학습 모델의 지형은 크게 두 가지 진영으로 나뉘어 있었다. 하나는 BERT(Devlin et al., 2019)로 대표되는 인코더 기반의 마스크드 언어 모델(Masked Language Model, MLM)이고, 다른 하나는 GPT(Radford et al., 2018)로 대표되는 디코더 기반의 언어 모델(Causal Language Model, CLM)이다.1 이 두 아키텍처는 각기 다른 장단점을 내포하고 있어, 통합적인 언어 처리를 위해서는 상호 보완적인 접근이 필수적이었다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "BERT (Bidirectional Encoder)"
        A1["양방향 문맥 이해"]
        A2["Masked LM (MLM)"]
        A3["NLU 태스크 강점 (분류, QA)"]
        A1 --&gt; A3
        A2 --&gt; A3
    end

    subgraph "GPT (Auto-Regressive Decoder)"
        B1["단방향 순차 생성 (Left-to-Right)"]
        B2["Causal LM (CLM)"]
        B3["NLG 태스크 강점 (생성)"]
        B1 --&gt; B3
        B2 --&gt; B3
    end

    subgraph "BART (Denoising Autoencoder)"
        C1["구조적 재결합 (Recombination)"]
        C2["인코더: 양방향 이해"]
        C3["디코더: 자기회귀 생성"]
        C4["일반화된 모델 (NLU &amp; NLG)"]
        
        A3 -.-&gt; C1
        B3 -.-&gt; C1
        C1 --&gt; C2
        C1 --&gt; C3
        C2 -- "Cross-Attention" --&gt; C3
        C3 --&gt; C4
    end
</code></pre>
<h3>1.1  양방향성과 자기회귀성의 딜레마</h3>
<p>BERT의 양방향 인코더는 문장 내의 모든 토큰이 서로를 동시에 참조(Self-Attention)할 수 있도록 설계되었다. 이는 문맥의 깊은 이해와 모호성 해소에 탁월한 성능을 발휘하여 분류(Classification)나 추출적 질의응답(Extractive QA)과 같은 NLU(Natural Language Understanding) 태스크에서 혁명적인 성과를 거두었다. 그러나 BERT는 토큰을 독립적으로 예측하도록 학습되기 때문에, 여러 토큰을 연속적으로 생성해야 하는 요약이나 번역 같은 생성(NLG) 태스크에는 적합하지 않다는 구조적 한계가 존재했다.3</p>
<p>반면, GPT 계열의 자기회귀 디코더는 왼쪽에서 오른쪽으로(Left-to-Right) 순차적으로 단어를 예측하며 생성하는 데 특화되어 있다. 이는 텍스트 생성에는 자연스럽지만, 미래의 정보를 참조할 수 없다는 단방향(Unidirectional) 제약으로 인해 문맥 이해의 깊이가 상대적으로 얕다는 단점이 있다.5 BART는 이 두 가지 상반된 패러다임을 하나의 모델 안에서 ’재결합’함으로써, 이해와 생성을 모두 아우르는 일반화된(Generalizing) 아키텍처를 제시했다.</p>
<h3>1.2  BART 아키텍처의 상세 설계</h3>
<p>BART는 표준적인 트랜스포머(Transformer) 기반의 기계 번역 아키텍처를 채택하고 있다. 그러나 세부적인 구성 요소에서 BERT와 GPT의 특성을 혼합하고 개선한 형태를 띤다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "입력 처리"
        Input["원본 텍스트"] --&gt; Noise["노이즈 함수 g(x)"]
        Noise --&gt; Corrupted["손상된 텍스트 (Corrupted Text)"]
    end

    subgraph "BART Model Architecture"
        direction TB
        subgraph "Bidirectional Encoder"
            EncInput["입력: 손상된 텍스트"]
            BiAttn["Self-Attention (All-to-All)"]
            EncHidden["Encoder Hidden States"]
            EncInput --&gt; BiAttn --&gt; EncHidden
        end

        subgraph "Auto-Regressive Decoder"
            DecInput["입력: 이전 시점 토큰 (Shifted Right)"]
            MaskedAttn["Masked Self-Attention (Look-behind only)"]
            CrossAttn["Cross-Attention (Encoder Output 참조)"]
            DecOutput["Decoder Hidden States"]
            
            DecInput --&gt; MaskedAttn
            MaskedAttn --&gt; CrossAttn
            EncHidden -- "전체 문맥 정보 전달" --&gt; CrossAttn
            CrossAttn --&gt; DecOutput
        end
    end

    subgraph "출력 및 학습"
        DecOutput --&gt; GeLU["활성화 함수: GeLU"]
        GeLU --&gt; Linear["Linear Layer (No FFN before prediction)"]
        Linear --&gt; Softmax["Softmax"]
        Softmax --&gt; Recon["복원된 텍스트"]
        Recon -- "손실 계산 (Cross Entropy)" --&gt; Loss["Loss Function"]
    end
</code></pre>
<ol>
<li>양방향 인코더 (Bidirectional Encoder):</li>
</ol>
<p>BART의 인코더는 BERT와 유사하게 입력 시퀀스의 모든 토큰 간 상호작용을 허용한다. 이는 손상된 입력 텍스트(Corrupted Text)를 받아 그 의미적 표현을 고차원 벡터 공간으로 매핑하는 역할을 수행한다. BERT와의 차이점은 토큰에 대한 의존도를 줄이고, 디코더와의 교차 어텐션(Cross-Attention)을 위해 전체 시퀀스의 은닉 상태(Hidden States)를 최적화한다는 점이다.7</p>
<ol start="2">
<li>자기회귀 디코더 (Auto-Regressive Decoder):</li>
</ol>
<p>디코더는 GPT와 유사하게 마스킹된 어텐션(Masked Self-Attention)을 사용하여 현재 시점 이전의 토큰들만 참조한다. 동시에, 인코더의 최종 은닉 상태와 연결되는 교차 어텐션 레이어를 통해 입력 텍스트의 문맥 정보를 획득한다. 이를 통해 디코더는 입력된 손상 텍스트의 복원된 버전을 순차적으로 생성한다.9</p>
<ol start="3">
<li>활성화 함수 및 초기화 (Activation &amp; Initialization):</li>
</ol>
<p>BART는 GPT의 설계를 따라 활성화 함수로 ReLU 대신 GeLU(Gaussian Error Linear Units)를 사용한다. 파라미터 초기화는 정규분포 <span class="math math-inline">\mathcal{N}(0, 0.02)</span>를 따른다. 이러한 설정은 모델의 비선형성을 부드럽게 하고 학습 초기 단계의 안정성을 높이는 데 기여한다.11</p>
<ol start="4">
<li>피드포워드 네트워크의 구조적 차이:</li>
</ol>
<p>BERT는 단어 예측 직전에 별도의 피드포워드 네트워크(Feed-Forward Network)를 추가하여 표현력을 높였으나, BART는 이를 제거했다. 이는 모델의 파라미터 효율성을 높이기 위한 선택이었으나, 인코더와 디코더를 모두 포함하는 구조적 특성상 동일한 레이어 수를 가진 BERT 모델 대비 약 10% 더 많은 파라미터 수를 가지게 된다.11</p>
<p>아래 [표 5.2.1]은 BERT, GPT, 그리고 BART의 구조적 특징을 비교 분석한 것이다.</p>
<p><strong>[표 5.2.1] 주요 트랜스포머 모델 아키텍처 비교</strong></p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>BERT (Encoder-only)</strong></th><th><strong>GPT (Decoder-only)</strong></th><th><strong>BART (Encoder-Decoder)</strong></th></tr></thead><tbody>
<tr><td><strong>문맥 참조 방식</strong></td><td>양방향 (Bidirectional)</td><td>단방향 (Left-to-Right)</td><td>인코더: 양방향 / 디코더: 단방향</td></tr>
<tr><td><strong>사전 학습 목표</strong></td><td>Masked LM (MLM)</td><td>Causal LM (Next Token Prediction)</td><td>Denoising Autoencoder (텍스트 복원)</td></tr>
<tr><td><strong>주요 태스크</strong></td><td>분류, 추출적 QA (NLU)</td><td>텍스트 생성 (NLG)</td><td>요약, 번역, 생성 및 이해 (NLU &amp; NLG)</td></tr>
<tr><td><strong>구조적 연결</strong></td><td>없음 (단일 스택)</td><td>없음 (단일 스택)</td><td>Cross-Attention을 통한 인코더-디코더 연결</td></tr>
<tr><td><strong>활성화 함수</strong></td><td>GeLU (일부 변형 존재)</td><td>GeLU</td><td>GeLU</td></tr>
<tr><td><strong>위치 임베딩</strong></td><td>절대적 위치 (Absolute)</td><td>절대적 위치 (Absolute)</td><td>절대적 위치 (Absolute)</td></tr>
</tbody></table>
<p>이러한 구조적 재결합을 통해 BART는 손상된 입력의 전체 문맥을 인코더로 파악하고(BERT의 장점), 이를 바탕으로 디코더가 유창한 문장을 생성해내는(GPT의 장점) 시너지 효과를 창출한다.</p>
<h2>2.  Denoising Autoencoder로서의 수학적 모델링</h2>
<p>BART의 학습 철학은 근본적으로 ’Denoising Autoencoder’이다. 이는 입력 데이터에 인위적인 노이즈를 주입하고, 모델이 이를 제거하여 원본 데이터를 복원하도록 학습시키는 비지도 학습 방법론이다. 이미지 처리 분야에서 주로 사용되던 이 개념을 텍스트 시퀀스에 적용함으로써, BART는 단순한 단어 예측을 넘어 문장 구조와 의미적 일관성을 학습하게 된다.1</p>
<p><strong>Denoising Autoencoder 학습 프로세스</strong></p>
<pre><code class="language-mermaid">graph TD    
    Step1["원본 시퀀스: x"] --&gt; Step2["노이즈 주입: x_tilde = g(x)"]
    Step2 -- "임의의 노이즈 함수 허용" --&gt; Step3["모델 입력: x_tilde"]
    
    Step3 --&gt; Step4["파라미터 theta로 조건부 확률 학습"]
    Step4 --&gt; Eq["P(x | x_tilde; theta)"]
    
    Eq --&gt; Step5["목적 함수: 음의 로그 우도 최소화"]
    Step5 --&gt; Formula["Sum[ -log P(x_t | x_lt_t, x_tilde) ]"]
    
    Formula --&gt; Goal["원본 x 복원 및 결합 확률 모델링"]
</code></pre>
<h3>2.1  손실 함수와 학습 목표</h3>
<p>수학적으로 BART의 학습 과정은 다음과 같이 정의된다. 원본 텍스트 시퀀스를 <span class="math math-inline">x</span>라고 할 때, 임의의 노이즈 함수 <span class="math math-inline">g</span>를 적용하여 손상된 텍스트 <span class="math math-inline">\tilde{x} = g(x)</span>를 생성한다. BART 모델은 파라미터 <span class="math math-inline">\theta</span>를 통해 <span class="math math-inline">\tilde{x}</span>를 입력받아 원본 <span class="math math-inline">x</span>를 복원하는 조건부 확률 분포 <span class="math math-inline">P(x|\tilde{x}; \theta)</span>를 학습한다.</p>
<p>학습의 목표는 원본 시퀀스에 대한 음의 로그 우도(Negative Log-Likelihood)를 최소화하는 것이다.7<br />
<span class="math math-display">
\mathcal{L}_{BART} = - \sum_{t=1}^{T} \log P(x_t | x_{&lt;t}, \tilde{x}; \theta)
</span><br />
여기서:</p>
<ul>
<li><span class="math math-inline">T</span>는 원본 시퀀스 <span class="math math-inline">x</span>의 총 길이이다.</li>
<li><span class="math math-inline">x_t</span>는 시점 <span class="math math-inline">t</span>에서의 타겟 토큰이다.</li>
<li><span class="math math-inline">x_{&lt;t}</span>는 디코더가 시점 <span class="math math-inline">t</span> 이전에 생성한 토큰들의 시퀀스이다.</li>
<li><span class="math math-inline">\tilde{x}</span>는 인코더에 입력된 전체 손상된 텍스트이다.</li>
</ul>
<p>이 수식은 BART가 디코더를 통해 자기회귀적으로(Autoregressively) 토큰을 생성함을 보여준다. 즉, 각 시점의 토큰 예측은 인코더가 처리한 손상된 텍스트의 문맥 정보(<span class="math math-inline">\tilde{x}</span>)와 디코더가 지금까지 생성한 문맥(<span class="math math-inline">x_{&lt;t}</span>)에 모두 의존한다. 이는 BERT의 독립적인 마스킹 예측과는 근본적으로 다르며, 텍스트의 전체적인 결합 확률(Joint Probability)을 모델링한다는 점에서 더 강력한 생성 능력을 부여한다.</p>
<h3>2.2  임의적 노이즈(Arbitrary Noise)의 허용</h3>
<p>기존의 Denoising Autoencoder들이 특정 유형의 노이즈(예: 가우시안 노이즈, 단순 마스킹)에 최적화된 구조를 가졌던 것과 달리, BART는 <strong>어떠한 형태의 노이즈 함수 <span class="math math-inline">g</span>도 적용 가능하다</strong>는 특징을 가진다.2 이는 입력 텍스트의 길이를 변경하거나(삭제, 인필링), 순서를 뒤바꾸는(순열, 회전) 등의 급격한 구조적 변형까지도 모델이 학습할 수 있게 한다. 이러한 유연성은 BART가 단순한 언어 모델이 아니라, 텍스트 변환(Text Transformation) 및 재구성(Reconstruction) 시스템으로 기능하게 하는 핵심 요인이다.</p>
<h2>3.  5대 노이즈 주입 기법 (Noising Techniques) 심층 분석</h2>
<p>BART의 성능은 어떤 노이즈 함수 <span class="math math-inline">g(x)</span>를 사용하여 데이터를 손상시키느냐에 따라 결정적으로 달라진다. 루이스와 연구진은 모델이 언어의 다양한 측면(어휘, 구문, 담화 구조)을 학습하도록 유도하기 위해 5가지 주요 노이즈 기법을 제안하고 실험했다.12 이 기법들은 단독으로 사용되거나 조합되어 시너지 효과를 발휘한다.</p>
<p><strong>BART의 5가지 노이즈 기법 (Noising Techniques)</strong></p>
<pre><code class="language-mermaid">graph TB

    Center(("BART Noise&lt;br&gt;Function&lt;br&gt;g(x)"))

    subgraph "Token Masking"
        M1["Token&lt;br&gt;Masking"]
        M_Ex["BART is a&lt;br&gt;[MASK] model"]
        M_Effect["국소적&lt;br&gt;의존성&lt;br&gt;학습"]
        Center --&gt; M1 --&gt; M_Ex --&gt; M_Effect
    end

    subgraph "Token Deletion"
        D1["Token&lt;br&gt;Deletion"]
        D_Ex["BART a&lt;br&gt;powerful model"]
        D_Effect["위치(Position) 판단 및&lt;br&gt;문법 오류 감지"]
        Center --&gt; D1 --&gt; D_Ex --&gt; D_Effect
    end

    subgraph "Text Infilling (Key)"
        I1["Text&lt;br&gt;Infilling"]
        I_Ex["BART is&lt;br&gt;[MASK] objectives"]
        I_Note["여러 토큰 -&gt;&lt;br&gt;단일 [MASK]"]
        I_Effect["빠진 단어 개수&lt;br&gt; (Planning)"]
        Center --&gt; I1 --&gt; I_Ex --&gt; I_Note --&gt; I_Effect
    end

    subgraph "Sentence Permutation"
        P1["Sentence&lt;br&gt;Permutation"]
        P_Ex["Sentence C.&lt;br&gt;Sentence A. Sentence B."]
        P_Effect["문장 간 논리적&lt;br&gt;연결 및 인과 관계"]
        Center --&gt; P1 --&gt; P_Ex --&gt; P_Effect
    end

    subgraph "Document Rotation"
        R1["Document&lt;br&gt;Rotation"]
        R_Ex["transformers.&lt;br&gt;It is ... BART uses"]
        R_Effect["문서의 시작점 식별"]
        Center --&gt; R1 --&gt; R_Ex --&gt; R_Effect
    end
</code></pre>
<h3>3.1  토큰 마스킹 (Token Masking)</h3>
<p>가장 기초적인 기법으로 BERT의 MLM과 동일하다. 입력 시퀀스에서 무작위로 토큰을 샘플링하여 <code>[MASK]</code> 토큰으로 대체한다.</p>
<ul>
<li><strong>변환 예시:</strong> “BART is a powerful model” <span class="math math-inline">\rightarrow</span> “BART is a <code>[MASK]</code> model”</li>
<li><strong>학습 원리:</strong> 모델은 <code>[MASK]</code> 토큰 주변의 문맥을 파악하여 해당 위치에 들어갈 적절한 어휘를 추론해야 한다. 이는 단어 간의 국소적 의존성(Local Dependency)을 학습하는 데 유효하다. 그러나 BART는 이를 단순 분류가 아닌 생성 과정을 통해 복원해야 하므로, 디코더의 언어 생성 능력을 기초부터 다지는 역할을 한다.10</li>
</ul>
<h3>3.2  토큰 삭제 (Token Deletion)</h3>
<p>임력 시퀀스에서 무작위로 토큰을 완전히 삭제한다. 마스킹과 달리 삭제된 위치에 어떠한 표시도 남지 않는다.</p>
<ul>
<li><strong>변환 예시:</strong> “BART is a powerful model” <span class="math math-inline">\rightarrow</span> “BART a powerful model”</li>
<li><strong>학습 원리:</strong> 모델은 문장을 읽고 문법적으로 어색한 부분을 감지해야 하며, **어느 위치(Position)**에 단어가 누락되었는지를 스스로 판단해야 한다. 이는 단순히 빈칸을 채우는 것을 넘어, 문장의 통사적 구조(Syntactic Structure)와 완전성(Completeness)을 학습하게 한다. 모델은 삭제된 위치를 찾아내고 적절한 단어를 삽입하여 문장을 재구성해야 하므로 난이도가 더 높다.12</li>
</ul>
<h3>3.3  텍스트 인필링 (Text Infilling): BART의 핵심 기법</h3>
<p>BART의 성능 향상에 가장 크게 기여한 독창적인 기법이다. SpanBERT(Joshi et al., 2019)에서 영감을 받았으나, BART의 인필링 방식은 생성 모델에 맞게 수정되었다.2</p>
<ul>
<li><strong>작동 메커니즘:</strong></li>
</ul>
<ol>
<li>텍스트 내에서 복수의 스팬(Span)을 샘플링한다. 스팬의 길이는 **푸아송 분포(Poisson Distribution, <span class="math math-inline">\lambda=3</span>)**를 따른다. 즉, 평균적으로 3개의 토큰이 하나의 스팬으로 묶여 선택된다.</li>
<li>선택된 스팬은 <strong>단 하나의 <code>[MASK]</code> 토큰</strong>으로 대체된다.</li>
<li>길이가 0인 스팬이 선택될 경우, 해당 위치에 <code>[MASK]</code> 토큰이 단순히 삽입된다.</li>
</ol>
<ul>
<li><strong>변환 예시:</strong> “BART is trained using denoising objectives” <span class="math math-inline">\rightarrow</span> “BART is <code>[MASK]</code> denoising objectives” (여기서 “trained using“이라는 2개의 토큰이 1개의 마스크로 대체됨)</li>
<li><strong>SpanBERT와의 결정적 차이:</strong> SpanBERT는 지워진 스팬의 길이만큼 <code>토큰을 배치한다 (예:</code>). 이는 모델에게 몇 개의 단어를 복원해야 하는지 힌트를 준다. 반면, BART는 스팬의 길이에 상관없이 무조건 1개의 <code>[MASK]</code> 토큰으로 대체한다.</li>
<li><strong>학습 원리:</strong> BART 모델은 해당 <code>[MASK]</code> 위치가 **몇 개의 단어로 복원되어야 하는지(How many tokens)**를 예측해야 한다. 이는 모델이 단어의 의미뿐만 아니라, 문장 성분의 길이와 구조적 확장성을 학습하게 만든다. 특히 입력과 출력의 길이가 달라지는 요약이나 번역 태스크에서 필수적인 능력이다.12</li>
</ul>
<p><strong>텍스트 인필링 작동 원리</strong></p>
<pre><code class="language-mermaid">graph TD

    Start["원본 텍스트"] --&gt; Poisson["스팬 길이 샘플링 (푸아송 분포 lambda=3)"]
    Poisson --&gt; SpanSelect["텍스트 내 스팬 선택 (평균 3토큰)"]
    
    SpanSelect --&gt; CheckLen{"스팬 길이 확인"}
    
    CheckLen -- "길이 &gt; 0" --&gt; Replace["해당 스팬을 단 하나의 [MASK] 토큰으로 대체"]
    CheckLen -- "길이 = 0" --&gt; Insert["해당 위치에 [MASK] 토큰 삽입"]
    
    Replace --&gt; Comparison["SpanBERT와 차이점"]
    Insert --&gt; Comparison
    
    Comparison -- "SpanBERT" --&gt; SB["지워진 개수만큼 [MASK] 배치 (힌트 제공)"]
    Comparison -- "BART" --&gt; BB["무조건 1개의 [MASK] 배치 (길이 예측 필요)"]
    
    BB --&gt; Result["모델이 누락된 단어의 '개수'와 '내용'을 모두 예측하도록 학습"]
</code></pre>
<h3>3.4  문장 순서 섞기 (Sentence Permutation)</h3>
<p>문서를 문장 단위로 분할(마침표 기준)한 뒤, 이들의 순서를 무작위로 섞는다.</p>
<ul>
<li><strong>변환 예시:</strong> “Sentence A. Sentence B. Sentence C.” <span class="math math-inline">\rightarrow</span> “Sentence C. Sentence A. Sentence B.”</li>
<li><strong>학습 원리:</strong> 모델은 문장 간의 논리적 연결 고리와 인과 관계를 파악하여 원래의 순서를 재배열해야 한다. 이는 긴 텍스트의 일관성(Coherence)을 유지하고 담화(Discourse) 수준의 문맥을 이해하는 데 중요한 역할을 한다. 특히 여러 문장에서 정보를 종합해야 하는 요약 태스크에서 유용하다.12</li>
</ul>
<h3>3.5  문서 회전 (Document Rotation)</h3>
<p>문서 내의 임의의 토큰을 선택하고, 그 토큰이 문서의 시작이 되도록 전체 문서를 회전시킨다.</p>
<ul>
<li><strong>변환 예시:</strong> “BART uses transformers. It is powerful.” <span class="math math-inline">\rightarrow</span> “transformers. It is powerful. BART uses”</li>
<li><strong>학습 원리:</strong> 모델은 문맥을 통해 문서의 진정한 **시작점(Start of the Document)**을 식별하고 순서를 복원해야 한다. 이는 모델이 텍스트의 기승전결 구조를 파악하고, 문맥 독립적으로 텍스트의 도입부를 인지하도록 훈련시킨다.10</li>
</ul>
<p>이 5가지 기법은 BART가 단순한 언어 모델링을 넘어 구조적 추론과 논리적 재구성을 수행하도록 돕는다. [표 5.2.2]는 각 노이즈 기법의 특징과 주요 학습 효과를 요약한다.</p>
<p><strong>[표 5.2.2] BART의 노이즈 주입 기법 및 학습 효과 요약</strong></p>
<table><thead><tr><th><strong>기법</strong></th><th><strong>변환 방식</strong></th><th><strong>주요 학습 효과</strong></th><th><strong>관련 태스크</strong></th></tr></thead><tbody>
<tr><td><strong>Token Masking</strong></td><td>임의 토큰 <span class="math math-inline">\rightarrow</span> <code>[MASK]</code></td><td>국소적 의미 추론, 어휘 복원</td><td>NLU, 기본 생성</td></tr>
<tr><td><strong>Token Deletion</strong></td><td>임의 토큰 삭제</td><td>문법적 오류 감지, 위치 추론</td><td>문법 교정, 생성</td></tr>
<tr><td><strong>Text Infilling</strong></td><td>스팬(Poisson <span class="math math-inline">\lambda=3</span>) <span class="math math-inline">\rightarrow</span> 단일 <code>[MASK]</code></td><td>스팬 길이 예측, 구문 복원</td><td>요약, 번역, 생성</td></tr>
<tr><td><strong>Sentence Permutation</strong></td><td>문장 순서 셔플</td><td>문장 간 논리, 일관성 파악</td><td>요약, 긴 글 생성</td></tr>
<tr><td><strong>Document Rotation</strong></td><td>시작 토큰 기준 회전</td><td>문서 구조 파악, 시작점 식별</td><td>담화 분석</td></tr>
</tbody></table>
<h2>4.  사전 학습 목표의 비교 및 절삭 실험 (Ablation Study)</h2>
<p>BART의 연구진은 다양한 노이즈 기법의 효용성을 검증하기 위해 광범위한 절삭 실험(Ablation Study)을 수행했다. 이 실험 결과는 특정 노이즈 기법이 모든 태스크에 만능이 아니며, 태스크의 성격에 따라 최적의 사전 학습 전략이 다름을 시사한다.2</p>
<p><strong>사전 학습 목표에 따른 성능 계층 (Performance Hierarchy)</strong></p>
<pre><code class="language-mermaid">graph TD
    subgraph "Low Performance"
        L1["Document Rotation 단독"]
        L2["Sentence Permutation 단독"]
        L3["이유: 거시적 구조만 학습, 미시적(단어) 학습 부족"]
        L1 --- L2 --&gt; L3
    end

    subgraph "Medium Performance"
        M1["Language Model (GPT Style)"]
        M2["Masked LM (BERT Style)"]
        M3["특정 태스크(생성 or 이해)에만 편향됨"]
        M1 --- M2 --&gt; M3
    end

    subgraph "High Performance (BART Final)"
        H1["Text Infilling 단독"]
        H_Reason1["생성 및 이해 모두 우수"]
        H2["Text Infilling + Sentence Shuffling"]
        H_Reason2["Best Model: 미시적 복원 + 거시적 논리 결합"]
        
        H1 --&gt; H_Reason1
        H1 --&gt; H2 --&gt; H_Reason2
    end

    L3 --&gt; M1
    M3 --&gt; H1
</code></pre>
<h3>4.1  단일 기법의 한계와 텍스트 인필링의 우위</h3>
<p>실험 결과에 따르면, **문장 순서 섞기(Sentence Permutation)**나 **문서 회전(Document Rotation)**만을 단독으로 사용할 경우 모델의 성능은 매우 저조했다. 이러한 거시적 변환은 문단 수준의 구조 학습에는 도움이 되지만, 단어 단위의 정교한 의미 파악이나 문법 학습에는 불충분하기 때문이다. 예를 들어, 문장 순서만 섞인 데이터로 학습한 모델은 개별 문장 내의 마스킹된 단어를 채우는 능력이 떨어졌다.15</p>
<p>반면, **텍스트 인필링(Text Infilling)**은 단독으로 사용되었을 때도 가장 일관되게 우수한 성능을 보였다. 이는 인필링이 국소적인 단어 예측(마스킹의 특성)과 구조적인 길이 예측(삭제/복원)의 특성을 동시에 가지고 있어, 언어 모델의 기본기라 할 수 있는 어휘력과 구문력을 모두 강화하기 때문이다. 인필링을 사용한 BART 모델은 BERT와 유사하거나 더 나은 성능을 보이면서도 생성 능력까지 갖출 수 있었다.</p>
<h3>4.2  최적의 조합: 텍스트 인필링 + 문장 순서 섞기</h3>
<p>BART의 최종 모델은 단일 기법 대신 <strong>텍스트 인필링</strong>과 <strong>문장 순서 섞기</strong>를 결합하여 사전 학습되었다.1 이 조합은 미시적 차원(단어 및 구문 복원)과 거시적 차원(문장 배열 및 논리 복원)의 학습 목표를 동시에 달성하게 한다.</p>
<ol>
<li><strong>미시적 차원:</strong> 인필링된 마스크를 복원하며 모델은 단어의 의미와 문법적 정확성을 학습한다.</li>
<li><strong>거시적 차원:</strong> 뒤섞인 문장을 재배열하며 모델은 문단 전체의 논리적 흐름과 일관성을 학습한다.</li>
</ol>
<p>[표 5.2.3]은 SQuAD(질의응답), MNLI(자연어 추론), XSum(요약) 등 다양한 태스크에서 노이즈 기법에 따른 성능 변화를 보여준다. 텍스트 인필링과 문장 섞기를 결합했을 때, 특히 요약 태스크(XSum)에서의 성능 향상이 두드러짐을 확인할 수 있다.</p>
<p><strong>[표 5.2.3] 사전 학습 목표에 따른 BART 성능 비교 (Ablation Study)</strong> (참조: 15 Table 1 재구성)</p>
<table><thead><tr><th><strong>사전 학습 목표</strong></th><th><strong>SQuAD (F1)</strong></th><th><strong>MNLI (Acc)</strong></th><th><strong>XSum (ROUGE-L)</strong></th><th><strong>특징</strong></th></tr></thead><tbody>
<tr><td>Language Model (GPT style)</td><td>76.5</td><td>80.1</td><td>21.0</td><td>생성에 유리하나 NLU 약함</td></tr>
<tr><td>Masked LM (BERT style)</td><td>88.0</td><td>84.0</td><td>22.0</td><td>NLU 강함, 생성 약함</td></tr>
<tr><td>Document Rotation</td><td>77.2</td><td>75.3</td><td>19.87</td><td>단독 사용 시 성능 저조</td></tr>
<tr><td>Sentence Shuffling</td><td>85.4</td><td>82.5</td><td>21.3</td><td>NLU는 준수하나 생성 한계</td></tr>
<tr><td><strong>Text Infilling</strong></td><td><strong>90.3</strong></td><td><strong>84.3</strong></td><td><strong>24.10</strong></td><td><strong>전반적으로 우수</strong></td></tr>
<tr><td><strong>Text Infilling + Shuffling</strong></td><td><strong>90.8</strong></td><td><strong>84.5</strong></td><td><strong>24.17</strong></td><td><strong>최종 선정 모델 (Best)</strong></td></tr>
</tbody></table>
<p>이 데이터는 BART가 복합적인 노이즈를 해결하는 과정에서 단순한 언어 모델링 이상의 추론 능력을 획득했음을 증명한다. 특히 텍스트 인필링은 BERT의 MLM보다 생성 태스크에서 월등한 성능을 보였는데, 이는 모델이 텍스트를 생성할 때 필요한 ‘계획(Planning)’ 능력—다음에 올 단어의 개수와 내용을 미리 예측하는 능력—을 길러주기 때문이다.</p>
<h2>5.  Fine-tuning 및 다운스트림 태스크 적용 전략</h2>
<p>BART의 “재결합과 Denoising” 전략은 사전 학습 단계에만 머무르지 않고, 실제 다운스트림 태스크(Downstream Tasks)에 적용될 때 아키텍처의 유연성을 통해 빛을 발한다. BART는 구조 변경 없이도 분류, 생성, 번역 등 다양한 태스크에 적용될 수 있다.10</p>
<p><strong>BART의 다운스트림 태스크 적용 방식</strong></p>
<pre><code class="language-mermaid">graph TD

    Root["Pre-trained BART"] --&gt; Task1["Sequence Classification (분류)"]
    Root --&gt; Task2["Sequence Generation (요약, QA)"]
    Root --&gt; Task3["Machine Translation (번역)"]

    subgraph "분류 태스크 전략"
        Task1 --&gt; C_Input["입력: 전체 텍스트 (인코더+디코더)"]
        C_Input --&gt; C_Token["디코더의 마지막 토큰"]
        C_Token -- "전체 입력 정보 요약" --&gt; C_Classifier["Linear Classifier"]
        C_Classifier --&gt; C_Label["클래스 라벨"]
    end

    subgraph "생성 태스크 전략"
        Task2 --&gt; G_Input["인코더: 원본 문서"]
        G_Input --&gt; G_Dec["디코더: 요약/답변 생성"]
        G_Dec --&gt; G_Out["타겟 텍스트"]
    end

    subgraph "번역 태스크 전략"
        Task3 --&gt; T_New["새로운 인코더 레이어 추가"]
        T_New --&gt; T_Step1["Step 1: 기존 BART 동결, 새 인코더만 학습"]
        T_Step1 --&gt; T_Step2["Step 2: 전체 모델 미세 조정"]
        T_Step2 -- "외국어 -&gt; 영어 매핑" --&gt; T_Out["번역 결과"]
    end
</code></pre>
<h3>5.1  시퀀스 분류 (Sequence Classification)</h3>
<p>분류 태스크에서 BART는 BERT와는 다른 독특한 접근 방식을 취한다. BERT는 토큰의 인코더 출력을 분류기에 입력하지만, BART는 입력 텍스트 전체를 인코더와 디코더에 모두 주입한다. 그리고 디코더의 마지막 토큰 위치에서 나오는 최종 은닉 상태(Final Hidden State)를 분류기의 입력으로 사용한다.12</p>
<ul>
<li><strong>작동 원리:</strong> 디코더의 마지막 토큰은 자기회귀적 특성상 이전의 모든 입력 정보와 인코더의 문맥 정보를 통합하고 있다. 따라서 이 위치의 벡터는 입력 시퀀스 전체에 대한 가장 포괄적인 요약 정보를 담고 있다고 볼 수 있다. 이를 통해 BART는 GLUE 벤치마크에서 RoBERTa와 대등한 성능을 기록했다.1</li>
</ul>
<h3>5.2  시퀀스 생성 (Sequence Generation): 요약 및 질의응답</h3>
<p>BART의 구조는 시퀀스 생성 태스크에 가장 자연스럽게 부합한다. 요약(Summarization)이나 추상적 질의응답(Abstractive QA)에서 입력 텍스트는 인코더로 들어가고, 디코더는 요약문이나 답변을 생성한다.</p>
<ul>
<li><strong>연관성:</strong> 사전 학습 시 수행했던 ‘노이즈 제거 및 원본 복원’ 과정은 본질적으로 요약 태스크와 유사하다. 요약은 원본 텍스트의 불필요한 정보(노이즈)를 제거하고 핵심 의미를 재구성(복원)하는 과정으로 해석될 수 있기 때문이다. 실제로 BART는 XSum 데이터셋에서 기존 SOTA 모델 대비 ROUGE 점수를 최대 6점까지 향상시키는 압도적인 성능을 보였다.2</li>
</ul>
<h3>5.3  기계 번역 (Machine Translation): 새로운 인코더 전략</h3>
<p>BART는 기계 번역, 특히 영어가 아닌 언어(Source Language)에서 영어(Target Language)로의 번역 성능을 극대화하기 위해 독창적인 미세 조정(Fine-tuning) 전략을 사용한다. BART는 기본적으로 영어 텍스트로 사전 학습되었으므로, 다른 언어의 입력에 대해서는 취약할 수 있다. 이를 해결하기 위해 **새로운 인코더 파라미터(New Randomly Initialized Encoder)**를 도입한다.2</p>
<ol>
<li><strong>아키텍처 변경:</strong> 기존 BART 인코더의 임베딩 레이어를 새로운 인코더로 교체한다. 이 새로운 인코더는 외국어(예: 루마니아어) 단어를 BART가 학습한 영어 벡터 공간으로 매핑하는 역할을 담당한다.</li>
<li><strong>2단계 학습 (Two-step Training):</strong></li>
</ol>
<ul>
<li><strong>1단계:</strong> BART의 기존 파라미터(디코더 및 인코더의 상위 레이어)를 모두 동결(Freeze)한다. 오직 새로 추가된 인코더와 위치 임베딩, 그리고 첫 번째 인코더 레이어의 투영 행렬(Projection Matrix)만 학습시킨다. 이는 기존 BART 모델의 언어 생성 능력을 훼손하지 않으면서 외국어 입력을 적응시키는 과정이다.</li>
<li><strong>2단계:</strong> 모든 파라미터의 동결을 해제하고, 소수의 반복(Iteration) 동안 전체 모델을 미세 조정한다.</li>
</ul>
<p>이 전략은 BART를 강력한 “영어 생성 엔진“으로 활용하고, 그 앞단에 “외국어 해석기“를 부착하는 것과 유사하다. 실험 결과, 이 방식은 별도의 대규모 병렬 코퍼스 없이도 역번역(Back-translation) 시스템 대비 1.1 BLEU 점수 향상을 기록하며 그 효율성을 입증했다.1</p>
<h2>6.  경쟁 모델과의 비교: BERT, RoBERTa, 그리고 T5</h2>
<p>BART의 위치를 명확히 하기 위해서는 당대의 경쟁 모델인 BERT/RoBERTa(인코더 기반) 및 T5(Text-to-Text Transfer Transformer)와의 비교가 필수적이다.</p>
<h3>6.1  BART vs. RoBERTa (NLU 성능)</h3>
<p>BART는 생성 모델임에도 불구하고, GLUE나 SQuAD와 같은 이해(NLU) 중심의 태스크에서 RoBERTa와 대등한 성능을 보인다. 이는 양방향 인코더를 유지했기 때문에 가능했다. 생성 능력을 추가했음에도 이해 능력이 저하되지 않았다는 점은 BART가 진정한 의미의 ‘일반화된’ 모델임을 시사한다.1</p>
<h3>6.2  BART vs. T5 (생성 성능 및 구조)</h3>
<p>구글의 T5 역시 인코더-디코더 구조를 채택하고 스팬 오염(Span Corruption)이라는 유사한 노이즈 기법을 사용하지만, BART와는 몇 가지 중요한 차이점이 있다.5</p>
<ul>
<li><strong>스팬 처리 방식:</strong> T5는 마스킹된 스팬을 유니크한 센티널 토큰(Sentinel Token, 예: <code>&lt;extra_id_0&gt;</code>)으로 대체하고, 디코더는 이 센티널과 복원된 텍스트를 쌍으로 출력한다. 반면 BART는 단일 `` 토큰을 사용하고 원본 텍스트 전체를 복원한다.</li>
<li><strong>위치 임베딩:</strong> T5는 상대적 위치 임베딩(Relative Position Embedding)을 사용하는 반면, BART는 절대적 위치 임베딩(Absolute Position Embedding)을 사용한다.</li>
<li><strong>성능:</strong> 실험 결과, 요약(Summarization)과 같은 생성 태스크에서 BART는 T5와 유사하거나 일부 데이터셋(CNN/DailyMail, XSum)에서 더 우수한 성능을 보였다. 특히 BART의 텍스트 인필링 방식이 생성문의 유창성(Fluency)과 구조적 완결성 측면에서 강점을 가진 것으로 분석된다.20</li>
</ul>
<h2>7.  BART의 유산과 현대적 응용 (2024-2025)</h2>
<p>2020년 발표된 BART의 재결합 아키텍처와 Denoising 전략은 이후의 NLP 모델 발전에 지대한 영향을 미쳤으며, 2025년 현재까지도 다양한 도메인 특화 모델의 기반이 되고 있다.</p>
<h3>7.1  도메인 특화 모델로의 확장</h3>
<p>BART의 유연한 구조는 생물학, 프로그래밍 코드 등 특수 도메인 언어 모델의 베이스라인으로 널리 채택되었다.</p>
<ul>
<li><strong>BioBART &amp; ClinicalBART:</strong> 생의학 문헌이나 임상 기록을 요약하고 분석하는 데 BART 아키텍처가 사용된다. 2024년 연구들에서도 BioBART는 복잡한 의학 용어의 관계를 추론하고 평이한 언어로 요약(Lay Summarization)하는 태스크에서 여전히 강력한 성능을 발휘하고 있다.21</li>
<li><strong>PLBART &amp; CodeT5:</strong> 프로그래밍 언어 처리 분야에서도 BART는 중요한 역할을 했다. PLBART(Program and Language BART)는 코드와 자연어 설명을 동시에 학습하여 코드 생성 및 요약에 사용된다. 텍스트 인필링 기법은 코드의 누락된 로직을 채우는 코드 완성(Code Completion) 태스크와 논리적으로 완벽하게 일치한다.23</li>
</ul>
<h3>7.2  레거시(Legacy) 시스템에서의 지속적 가치</h3>
<p>2025년 현재, GPT-4나 Claude와 같은 초거대 언어 모델(LLM)이 등장했음에도 불구하고, BART는 여전히 실용적인 가치를 지닌다. 수천 억 개의 파라미터를 가진 LLM에 비해, BART(Base/Large)는 훨씬 적은 연산 자원으로도 특정 태스크(특히 요약 및 문법 교정)에서 준수한 성능을 낸다. 기업 내부의 온프레미스(On-premise) 환경이나 실시간 처리가 필요한 레거시 시스템의 현대화(Legacy Code Modernization) 작업에서 BART는 비용 효율적인 대안으로 자리 잡고 있다.26</p>
<h2>8.  결론: Denoising을 통한 언어 지능의 통합</h2>
<p>BART가 NLP 역사에 남긴 가장 큰 의의는 **“인위적인 노이즈를 스스로 극복하는 과정에서 언어의 본질을 깨닫는다”**는 Denoising Autoencoder의 철학을 시퀀스 생성의 영역으로 확장하고 완성했다는 점이다. 인코더와 디코더의 재결합은 단순한 기술적 병합이 아니라, 텍스트를 ‘읽는(Reading)’ 행위와 ‘쓰는(Writing)’ 행위를 하나의 인지 과정으로 통합한 시도였다.</p>
<p>BART가 제안한 텍스트 인필링을 비롯한 다양한 노이즈 기법들은 모델에게 단어의 의미뿐만 아니라 문장의 길이, 순서, 논리적 구조를 포괄적으로 학습할 수 있는 길을 열어주었다. 이는 결과적으로 BART가 NLU와 NLG의 경계를 허물고, 번역, 요약, 문법 교정, 질의응답 등 NLP의 거의 모든 태스크에서 SOTA 성능을 달성하게 만든 원동력이 되었다. 비록 모델의 규모 경쟁에서는 후속 LLM들에게 자리를 내어주었으나, BART가 정립한 아키텍처와 학습 방법론은 현대 AI가 언어를 이해하고 생성하는 방식의 근간을 이루고 있다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension - ACL Anthology, https://aclanthology.org/2020.acl-main.703/</li>
<li>arXiv:1910.13461v1 [cs.CL] 29 Oct 2019, https://arxiv.org/pdf/1910.13461</li>
<li>A Comparative Analysis of LLMs like BERT, BART, and T5 | by Zain ul Abideen - Medium, https://medium.com/@zaiinn440/a-comparative-analysis-of-llms-like-bert-bart-and-t5-a4a873251ff</li>
<li>Simple Instruction-Tuning Enables BERT-like Masked Language Models As Generative Classifiers - arXiv, https://arxiv.org/html/2502.03793v1</li>
<li>Encoder-decoder models - Harold Benoit, https://haroldbenoit.com/notes/ml/llms/architecture/encoder-decoder-models</li>
<li>The Evolution of LLMs: From T5 and GPT to Mixtral, o1, Claude 3.7, and Grok 3.5 — A Journey Through Completion, Reasoning, and First Principles | by Roberto Infante | Medium, https://medium.com/@roberto.g.infante/the-evolution-of-llms-from-t5-and-gpt-to-mixtral-o1-claude-3-7-8b93bb0240fd</li>
<li>Transformers BART Model Explained for Text Summarization - ProjectPro, https://www.projectpro.io/article/transformers-bart-model-explained/553</li>
<li>Choosing the Right Transformer Model for Your Task: BERT, GPT-2, or BART? - Medium, https://medium.com/researchify/choosing-the-right-transformer-model-for-your-task-bert-gpt-2-or-bart-9283023c1ccd</li>
<li>Guide to BART (Bidirectional &amp; Autoregressive Transformer) - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2024/11/bart-model/</li>
<li>Papers Explained 09: BART. BART is a denoising autoencoder built… | by Ritvik Rastogi | DAIR.AI | Medium, https://medium.com/dair-ai/papers-explained-09-bart-7f56138175bd</li>
<li>[1910.13461] BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension - ar5iv, https://ar5iv.labs.arxiv.org/html/1910.13461</li>
<li>Understanding the BART Model for Accurate Text Summarization - DigitalOcean, https://www.digitalocean.com/community/tutorials/bart-model-for-text-summarization-part1</li>
<li>Mike Lewis et. al., https://ysu1989.github.io/courses/au20/cse5539/BART.pdf</li>
<li>Adapter Based Fine Tuning BART And T5-Flan-XXL For Single Word Spell Correction, https://smashinggradient.com/2023/05/11/tinkering-with-peft-bart-t5-flan-for-spell-correction/</li>
<li>BART: Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension - ACL Anthology, https://aclanthology.org/2020.acl-main.703.pdf</li>
<li>BART example does not produce expected masks · Issue #18890 · huggingface/transformers - GitHub, https://github.com/huggingface/transformers/issues/18890</li>
<li>AUTOMATIC TEXT SUMMARIZATION USING BART - IJCRT.org, https://www.ijcrt.org/papers/IJCRT2402277.pdf</li>
<li>RoBERTa: Advancing NLP Beyond BERT | by HIYA CHATTERJEE | Medium, https://hiya31.medium.com/roberta-advancing-nlp-beyond-bert-bbea93228923</li>
<li>What are differences between T5 and Bart? - Stack Overflow, https://stackoverflow.com/questions/77732511/what-are-differences-between-t5-and-bart</li>
<li>A Comparative Study of PEGASUS, BART, and T5 for Text Summarization Across Diverse Datasets - MDPI, https://www.mdpi.com/1999-5903/17/9/389</li>
<li>HULAT-UC3M at BiolaySumm: Adaptation of BioBART and Longformer models to summarizing biomedical documents - ACL Anthology, https://aclanthology.org/2024.bionlp-1.71.pdf</li>
<li>BioBART: Pretraining and Evaluation of A Biomedical Generative Language Model | Request PDF - ResearchGate, https://www.researchgate.net/publication/361056286_BioBART_Pretraining_and_Evaluation_of_A_Biomedical_Generative_Language_Model</li>
<li>An Empirical Comparison of Pre-Trained Models of Source Code - arXiv, https://arxiv.org/pdf/2302.04026</li>
<li>Appendix: A Survey on Large Language Models for Software Engineering - arXiv, https://arxiv.org/html/2312.15223v2</li>
<li>Cracking the Code LLMs | Towards Data Science, https://towardsdatascience.com/cracking-the-code-llms-354505c53295/</li>
<li>Comprehensive Analysis of Transparency and Accessibility of ChatGPT, DeepSeek, and other SoTA Large Language Models - arXiv, https://arxiv.org/html/2502.18505v1</li>
<li>[2411.14971] Leveraging LLMs for Legacy Code Modernization: Challenges and Opportunities for LLM-Generated Documentation - arXiv, https://arxiv.org/abs/2411.14971</li>
<li>What GenAI and LLMs Bring to Legacy Tech - Reworked, https://www.reworked.co/digital-workplace/what-genai-and-llms-bring-to-legacy-tech/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>