<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:10.1 투기적 디코딩(Speculative Decoding) - 초안 모델과 검증 모델의 협업</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>10.1 투기적 디코딩(Speculative Decoding) - 초안 모델과 검증 모델의 협업</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">트랜스포머 싱귤래리티 (The Transformer Singularity)</a> / <span>10.1 투기적 디코딩(Speculative Decoding) - 초안 모델과 검증 모델의 협업</span></nav>
                </div>
            </header>
            <article>
                <h1>10.1 투기적 디코딩(Speculative Decoding) - 초안 모델과 검증 모델의 협업</h1>
<p>2025-12-22, G30DR</p>
<h2>1.  서론: 오토리그레시브 생성의 물리적 병목과 협업의 필연성</h2>
<p>트랜스포머(Transformer) 아키텍처의 등장은 인공지능 역사에 ’싱귤래리티’를 예고하는 사건이었으나, 아이러니하게도 그 거대함은 추론(Inference) 단계에서 물리적 한계에 봉착하게 만들었다. 대규모 언어 모델(Large Language Model, LLM)의 텍스트 생성 과정은 본질적으로 오토리그레시브(Autoregressive)한 성격을 띤다. 즉, 시퀀스의 <span class="math math-inline">t</span>번째 토큰을 생성하기 위해서는 <span class="math math-inline">1</span>부터 <span class="math math-inline">t-1</span>까지의 모든 토큰이 결정되어야 하며, 이 의존성으로 인해 병렬 처리가 불가능한 순차적 실행(Sequential Execution)이 강제된다.1</p>
<p>이러한 순차적 생성 방식은 현대 가속기 하드웨어, 특히 GPU의 설계 철학과 정면으로 배치된다. 현대 GPU는 대량의 데이터를 병렬로 처리할 때 최적의 성능을 발휘하도록 설계되었으나, LLM 추론, 특히 디코딩 단계에서는 한 번에 하나의 토큰만을 생성하기 위해 거대한 모델 파라미터 전체를 메모리에서 연산 유닛으로 이동시켜야 한다. 여기서 발생하는 것이 바로 악명 높은 ‘메모리 대역폭 병목(Memory Bandwidth Bottleneck)’ 현상이다.4</p>
<h3>1.1  산술 강도(Arithmetic Intensity)와 루프라인(Roofline) 모델 분석</h3>
<p>이 문제를 공학적으로 이해하기 위해서는 ’산술 강도(Arithmetic Intensity)’라는 개념을 도입해야 한다. 산술 강도는 프로세서가 메모리로부터 가져온 데이터 1바이트(Byte)당 수행하는 부동소수점 연산(FLOPs)의 횟수를 의미한다.<br />
<span class="math math-display">
\text{Arithmetic Intensity} = \frac{\text{Total FLOPs}}{\text{Total Bytes Accessed}}
</span><br />
NVIDIA A100이나 H100과 같은 최신 GPU는 초당 수백 테라플롭스(TFLOPS)의 연산 능력을 갖추고 있지만, 메모리 대역폭은 수 테라바이트(TB/s) 수준에 머무른다. 루프라인 모델(Roofline Model)에 따르면, 알고리즘의 산술 강도가 특정 임계점(Ridge Point, A100의 경우 약 100~150 FLOPs/Byte)보다 낮으면 시스템의 성능은 연산 속도가 아닌 메모리 전송 속도에 의해 제한된다.5</p>
<p>전형적인 오토리그레시브 디코딩(배치 크기 1)의 경우, 모델의 모든 가중치를 로드하여 단 하나의 토큰에 대한 로짓(Logit) 벡터를 계산하므로 산술 강도는 약 1 FLOP/Byte 내외에 불과하다. 이는 하드웨어의 임계점보다 훨씬 낮은 수치로, 값비싼 GPU 연산 코어(SRAM)가 데이터가 HBM(High Bandwidth Memory)에서 도착하기를 기다리며 99%의 시간을 유휴(Idle) 상태로 보낸다는 것을 의미한다.4</p>
<h3>1.2  협업을 통한 패러다임 전환</h3>
<p>이러한 물리적 병목을 하드웨어 증설만으로 해결하는 것은 비경제적이며 한계가 명확하다. 이에 대한 소프트웨어적 해법으로 등장한 것이 **투기적 디코딩(Speculative Decoding)**이다. 투기적 디코딩은 단일 모델이 모든 연산을 독점하는 기존 방식에서 탈피하여, ’속도’를 담당하는 초안 모델(Draft Model, Proposer)과 ’정확도’를 담당하는 검증 모델(Target Model, Verifier) 간의 <strong>협업(Collaboration)</strong> 체계를 구축한다.9</p>
<p>이 협업의 핵심은 ’메모리 대역폭에 묶여 놀고 있는 연산 자원’을 활용하는 데 있다. 검증 모델이 한 번의 메모리 로드로 하나의 토큰만 검사하는 대신, 초안 모델이 제안한 <span class="math math-inline">K</span>개의 토큰 시퀀스를 한꺼번에 병렬로 검증(Parallel Verification)한다면, 메모리 접근 비용은 그대로 유지한 채 유효 연산량을 <span class="math math-inline">K</span>배 가까이 늘릴 수 있다. 이는 작업의 성격을 메모리 바운드(Memory Bound)에서 컴퓨트 바운드(Compute Bound) 영역으로 이동시켜 하드웨어 효율성을 극대화하는 전략이다.11</p>
<p>본 장에서는 단순한 가속 기법을 넘어, 초안 모델과 검증 모델이 어떻게 확률 분포를 교환하고, 메모리 자원(KV Cache)을 공유하며, 수학적으로 무손실(Lossless) 생성을 보장하는지 그 정교한 협업 메커니즘을 심층 분석한다.</p>
<h2>2.  협업의 이론적 토대: 기각 샘플링과 무손실 보장</h2>
<p>초안 모델과 검증 모델의 협업이 신뢰를 얻을 수 있는 근본적인 이유는, 이 과정이 근사(Approximation)가 아닌 <strong>수학적 무손실(Lossless) 알고리즘</strong>이라는 점에 있다. 즉, 투기적 디코딩을 통해 생성된 텍스트는 검증 모델(Target Model) 단독으로 생성했을 때와 통계적으로 완전히 동일한 분포를 따른다. 이 섹션에서는 두 모델 간의 신뢰 프로토콜인 기각 샘플링(Rejection Sampling)과 잔여 분포 보정의 수학적 원리를 상세히 다룬다.</p>
<h3>2.1  표준화된 협업 프로토콜</h3>
<p>Leviathan et al.(2023)과 Chen et al.(2023)에 의해 정립된 표준 투기적 디코딩 알고리즘은 다음과 같은 단계로 진행된다.9</p>
<ol>
<li><strong>제안(Speculation):</strong> 초안 모델 <span class="math math-inline">M_q</span>가 현재 시점 <span class="math math-inline">t</span>에서 <span class="math math-inline">K</span>개의 미래 토큰 시퀀스 <span class="math math-inline">\tilde{x}*{t+1}, \dots, \tilde{x}*{t+K}</span>를 오토리그레시브하게 생성한다. 이때 각 토큰의 생성 확률 <span class="math math-inline">q(x)</span>도 함께 계산된다.</li>
<li><strong>검증(Verification):</strong> 검증 모델 <span class="math math-inline">M_p</span>는 제안된 시퀀스와 (실패할 경우를 대비한) 추가적인 한 토큰을 포함한 입력을 받아, 한 번의 병렬 포워드 패스로 모든 위치에서의 조건부 확률 <span class="math math-inline">p(x)</span>를 계산한다.</li>
<li><strong>결정(Decision):</strong> 각 위치 <span class="math math-inline">i</span> (<span class="math math-inline">1 \le i \le K</span>)에 대해 기각 샘플링을 수행하여 제안된 토큰을 수락할지 결정한다. 최초로 기각된 위치 <span class="math math-inline">j</span>가 나오면 그 이후의 제안은 모두 폐기하고, <span class="math math-inline">j</span> 위치의 토큰을 재샘플링하여 시퀀스를 확정한다.</li>
</ol>
<h3>2.2  기각 샘플링(Rejection Sampling)의 수학</h3>
<p>협업의 핵심은 초안 모델이 제안한 토큰 <span class="math math-inline">x</span>를 검증 모델이 어떤 기준으로 받아들이느냐에 있다. 단순히 <span class="math math-inline">p(x)</span>가 가장 높은 토큰을 선택하는 그리디 디코딩(Greedy Decoding)의 경우 <span class="math math-inline">x_{draft} == x_{target}</span> 여부만 확인하면 되지만, 다양성을 위한 확률적 샘플링(Nucleus Sampling 등) 상황에서는 분포 간의 보정이 필수적이다.15</p>
<p>초안 모델이 확률 <span class="math math-inline">q(x)</span>로 생성한 토큰 <span class="math math-inline">x</span>에 대해, 검증 모델의 수락 확률(Acceptance Probability) <span class="math math-inline">r(x)</span>는 다음과 같이 정의된다:<br />
<span class="math math-display">
r(x) = \min\left(1, \frac{p(x)}{q(x)}\right)
</span><br />
이 수식은 두 모델 간 권력 관계를 명확히 보여준다.</p>
<ul>
<li><strong><span class="math math-inline">p(x) \ge q(x)</span>인 경우:</strong> 검증 모델이 해당 토큰을 초안 모델보다 더, 혹은 동등하게 지지한다. 수락 확률은 1이 되며, 토큰은 즉시 채택된다. 이는 초안 모델이 검증 모델의 의도를 잘 파악했거나, 오히려 과소평가했음을 의미한다.</li>
<li><strong><span class="math math-inline">p(x) &lt; q(x)</span>인 경우:</strong> 초안 모델이 해당 토큰이 나올 확률을 검증 모델보다 과대평가했다(hallucination 가능성). 이 경우 <span class="math math-inline">p(x)/q(x)</span>의 확률로만 채택된다. 차이가 클수록(<span class="math math-inline">p(x)</span>가 작을수록) 기각될 확률이 높아진다.</li>
</ul>
<p>이 메커니즘은 초안 모델의 출력을 검증 모델의 분포 <span class="math math-inline">p(x)</span>로 ’재조정(Reweighting)’하는 필터 역할을 한다. 이를 통해 사용자는 빠른 모델을 거쳤음에도 불구하고, 결과적으로는 느린 모델에서 직접 샘플링한 것과 동일한 확률적 결과를 얻게 된다.18</p>
<h3>2.3  잔여 분포(Residual Distribution)와 복구 메커니즘</h3>
<p>협업의 정교함은 ‘기각(Rejection)’ 이후의 처리 과정에서 극명하게 드러난다. 토큰이 기각되었다는 것은 초안 모델의 추론이 검증 모델의 기준에 미치지 못했다는 신호다. 이때 시스템은 단순히 멈추는 것이 아니라, **잔여 분포(Residual Distribution)**에서 새로운 토큰을 샘플링하여 궤도를 수정한다.15</p>
<p>기각된 위치에서의 새로운 샘플링 분포 <span class="math math-inline">p&#39;(x)</span>는 다음과 같이 정의된다:<br />
<span class="math math-display">
p&#39;(x) = \text{norm}\left(\max(0, p(x) - q(x))\right)
</span><br />
여기서 <span class="math math-inline">\text{norm}</span>은 정규화 상수이다. 이 수식의 함의는 깊다.</p>
<ol>
<li><strong>중복 방지:</strong> 초안 모델이 과대평가했던(<span class="math math-inline">p &lt; q</span>) 토큰들은 이미 기각 테스트를 거쳤으므로, 잔여 분포에서는 확률이 0(또는 매우 낮음)이 된다. 이는 기각된 오답을 다시 뽑지 않도록 보장한다.</li>
<li><strong>새로운 탐색:</strong> 반면, 초안 모델이 놓쳤거나 과소평가했던(<span class="math math-inline">p &gt; q</span>) 토큰들은 잔여 분포에서 확률이 증폭된다. 즉, 검증 모델은 초안 모델이 ‘보지 못한’ 영역, 혹은 ‘자신만이 아는’ 영역에서 올바른 토큰을 찾아내게 된다.22</li>
</ol>
<p>이러한 잔여 분포 메커니즘은 두 모델이 서로 다른 지식(Knowledge)을 가지고 있더라도, 검증 모델이 최종 권한(Final Authority)을 행사하여 오류를 수정하고 자신의 분포를 관철시키는 안전장치로 작용한다.</p>
<h2>3.  초안 모델(The Drafter): 설계 철학과 유형별 협업 전략</h2>
<p>투기적 디코딩 시스템의 전체 성능은 초안 모델의 ’속도(Latency)’와 ‘수락률(Acceptance Rate)’ 사이의 균형에 달려 있다. 초안 모델이 너무 느리면 가속 효과가 없고, 너무 부정확하면 검증 오버헤드만 가중된다.23 연구자들은 이 딜레마를 해결하기 위해 다양한 형태의 초안 모델 아키텍처를 고안해냈다.</p>
<h3>3.1  독립적 소형 모델 (Independent Small Models)</h3>
<p>가장 초기 형태이자 직관적인 접근법은 검증 모델(Target Model)과 동일한 아키텍처를 가지되 크기만 줄인 별도의 소형 모델을 사용하는 것이다.</p>
<ul>
<li><strong>구조:</strong> 예컨대 70B 파라미터의 LLaMA-2 모델을 가속하기 위해 115M 파라미터의 LLaMA-2-Tiny 모델을 초안 모델로 쓴다.9</li>
<li><strong>협업 방식:</strong> 두 모델은 ’토큰 ID’라는 공통 언어로만 소통한다. 완전히 독립된 메모리 공간과 파라미터를 가지므로 구현이 쉽고(Plug-and-play), 기존에 공개된 경량 모델을 즉시 활용할 수 있다.</li>
<li><strong>한계:</strong></li>
<li><strong>분포 불일치(Distribution Shift):</strong> 작은 모델은 큰 모델만큼 문맥을 깊이 이해하지 못하므로, 문장이 복잡해질수록 수락률이 급격히 떨어진다. 이를 완화하기 위해 지식 증류(Distillation)나 Sequence-Level Knowledge Distillation(SeqKD)을 통해 작은 모델을 큰 모델에 맞게 미세 조정(Fine-tuning)하는 연구가 진행되었다.14</li>
<li><strong>메모리 오버헤드:</strong> 별도의 모델을 VRAM에 로드해야 하므로, 메모리 용량이 부족한 엣지 디바이스 등에서는 부담이 될 수 있다.</li>
</ul>
<h3>3.2  자기 투기(Self-Speculation)와 레이어 건너뛰기(Layer Skipping)</h3>
<p>추가적인 모델을 로드하는 부담을 없애기 위해, 검증 모델 자신을 초안 모델로 활용하는 기법들이 등장했다. 이른바 **자기 투기(Self-Speculation)**다.</p>
<ul>
<li><strong>메커니즘:</strong> 거대 모델은 보통 수십 개의 레이어로 구성되는데, 초기 레이어들만 통과해도 어느 정도 그럴듯한 다음 토큰 예측이 가능하다는 점에 착안했다. SWIFT나 LayerSkip 같은 알고리즘은 모델의 중간 레이어(예: 80개 중 40개)를 건너뛰고(Skip), 앞단 레이어의 출력을 바로 LM Head로 보내 초안을 생성한다.27</li>
<li><strong>기술적 난제와 해결:</strong> 원래 모델의 LM Head는 모든 레이어를 거친 고차원 특징을 입력받도록 훈련되었기 때문에, 중간 레이어의 출력을 바로 받으면 성능이 떨어진다. 이를 해결하기 위해 훈련 단계에서 ’Early Exit Loss’를 추가하거나, 중간 레이어 출력을 LM Head에 맞게 변환해주는 가벼운 어댑터(Adapter)를 부착한다.30</li>
<li><strong>협업의 이점:</strong> 별도의 모델 가중치를 로드할 필요가 없어 메모리 효율적이며, 검증 모델의 파라미터를 공유하기 때문에 분포 일치도가 상대적으로 높다.</li>
</ul>
<h3>3.3  비(非)오토리그레시브 헤드: Medusa 아키텍처</h3>
<p>Medusa는 초안 생성의 속도를 극대화하기 위해, 기존의 오토리그레시브(순차적) 초안 방식을 버리고 병렬적 예측을 도입했다.31</p>
<ul>
<li><strong>아키텍처:</strong> 검증 모델의 마지막 레이어 위에 <span class="math math-inline">K</span>개의 추가적인 ’디코딩 헤드(Decoding Head)’를 부착한다. 이 헤드들은 단순한 MLP(Multi-Layer Perceptron) 계층으로 구성된다.</li>
<li>Head 1: 현재 히든 스테이트 <span class="math math-inline">h_t</span>로부터 <span class="math math-inline">t+1</span>번째 토큰 예측.</li>
<li>Head 2: 현재 히든 스테이트 <span class="math math-inline">h_t</span>로부터 <span class="math math-inline">t+2</span>번째 토큰 예측.</li>
<li>…</li>
<li><strong>협업 혁신:</strong> 이 방식은 초안 생성에 드는 비용을 거의 ’0’에 수렴시킨다. 검증 모델이 현재 토큰을 생성하면서 만든 히든 스테이트를 재활용하여, 추가적인 트랜스포머 연산 없이 MLP 통과만으로 미래 토큰들을 쏟아내기 때문이다.34</li>
<li><strong>트리 어텐션(Tree Attention):</strong> Medusa 헤드들은 서로 독립적으로 동작하므로(Non-autoregressive), 조건부 확률을 완벽히 계산하지 못한다. 이를 보완하기 위해 여러 후보를 동시에 제안하여 ’후보 트리(Candidate Tree)’를 만들고, 검증 모델이 이를 한꺼번에 검증하는 ‘트리 어텐션’ 메커니즘을 사용한다.33</li>
</ul>
<h3>3.4  특징 외삽(Feature Extrapolation) 기반: EAGLE</h3>
<p>EAGLE(Extrapolation Algorithm for Greater Language-model Efficiency)은 Medusa의 접근법을 한 단계 더 심화시켜, 토큰 레벨이 아닌 ’특징(Feature) 레벨’에서의 협업을 제안한다.35</p>
<ul>
<li><strong>기본 철학:</strong> 텍스트 토큰은 이산적(Discrete)이라 예측이 어렵지만, 신경망 내부의 특징 벡터(Hidden State)는 연속적이고 부드럽게 변하므로 예측이 더 쉽다.</li>
<li><strong>구조적 통합:</strong> EAGLE은 아주 가벼운 1개의 트랜스포머 레이어(Draft Head)를 사용하여, 현재의 특징 벡터를 바탕으로 다음 시점의 특징 벡터를 예측한다. 그리고 검증 모델의 ’LM Head’를 그대로 가져와서 이 예측된 특징 벡터를 토큰으로 변환한다.37</li>
<li><strong>성능:</strong> 초안 모델이 검증 모델의 ‘뇌’(특징 공간)와 ‘입’(LM Head)을 공유하므로, 별도 모델을 쓸 때보다 훨씬 높은 정확도로 검증 모델의 거동을 모사한다. 이는 수락률을 비약적으로 높여 3x 이상의 가속을 가능하게 한다.39</li>
</ul>
<h3>3.5  비(非)모델 접근: 룩어헤드 디코딩(Lookahead Decoding)</h3>
<p>모든 협업 파트너가 반드시 신경망일 필요는 없다. 룩어헤드 디코딩은 별도의 학습된 가중치 없이, 알고리즘적 기법만으로 초안을 생성한다.40</p>
<ul>
<li><strong>야코비 반복(Jacobi Iteration):</strong> 비선형 방정식의 해를 구하는 수치해석 기법인 야코비 반복법을 언어 모델링에 적용했다. 검증 모델 자체가 ’고정점 반복 연산자’가 되어, 다소 부정확한 초기 추측값(Initial Guess)을 병렬로 수정해 나간다.</li>
<li><strong>N-gram 풀(Pool):</strong> 과거에 생성했던 패턴(N-gram)을 기록해 두었다가, 현재 문맥과 매칭되면 이를 미래 토큰의 초안으로 제안한다.</li>
<li><strong>의의:</strong> 추가적인 훈련이나 메모리가 전혀 필요 없는 ‘Zero-overhead’ 방식이며, 모델이 스스로 제안하고 스스로 검증하는 형태의 내부적 협업을 구현한다.42</li>
</ul>
<h2>4.  검증 모델(The Verifier): 병렬 처리와 자원 관리</h2>
<p>검증 모델은 시스템의 ’병목’이자 ’최종 권위자’이다. 초안 모델이 아무리 빨리 토큰을 제안해도, 검증 모델이 이를 효율적으로 처리하지 못하면 전체 시스템은 느려진다. 따라서 검증 모델은 반드시 **병렬 검증(Parallel Verification)**과 효율적인 <strong>메모리 관리</strong> 능력을 갖춰야 한다.</p>
<h3>4.1  병렬 검증 메커니즘과 인과적 마스킹(Causal Masking)</h3>
<p>검증 모델은 초안 모델이 제안한 토큰 시퀀스 <span class="math math-inline">[\tilde{x}*{t+1}, \tilde{x}*{t+2}, \dots, \tilde{x}_{t+K}]</span>를 입력으로 받는다. 일반적인 디코딩이라면 이들을 하나씩 순차적으로 처리했겠지만, 투기적 디코딩에서는 이 시퀀스 전체를 하나의 입력으로 간주하여 단 한 번의 포워드 패스를 수행한다.9</p>
<p>이때 핵심은 트랜스포머의 <strong>어텐션 마스크(Attention Mask)</strong> 조작이다.</p>
<ul>
<li>검증 모델은 <span class="math math-inline">i</span>번째 토큰 <span class="math math-inline">\tilde{x}_{t+i}</span>에 대한 검증 결과를 내놓기 위해, <span class="math math-inline">1</span>부터 <span class="math math-inline">i-1</span>까지의 제안된 토큰들과 기존의 문맥(Prompt)을 모두 참조할 수 있어야 한다.</li>
<li>동시에, <span class="math math-inline">i</span>번째 토큰의 검증이 미래의 토큰 <span class="math math-inline">\tilde{x}_{t+i+1}</span> 정보에 오염되어서는 안 된다(Cheating 방지).</li>
<li>따라서 표준적인 ‘Causal Mask’ (삼각 행렬 형태)를 적용하여, 한 번의 행렬 연산만으로 <span class="math math-inline">K</span>개의 모든 위치에 대한 조건부 확률 <span class="math math-inline">p(x_{t+i} | x_{t}, \dots, x_{t+i-1})</span>을 동시에 계산한다.</li>
</ul>
<h3>4.2  트리 어텐션(Tree Attention)과 위상학적 검증</h3>
<p>Medusa나 EAGLE 같은 최신 기법들은 단일 시퀀스가 아니라 ‘가지치기된 트리(Tree)’ 형태의 후보군을 제안한다. 예를 들어 “The cat is” 뒤에 [“black”, “cute”] 두 가지를 동시에 제안하고, 그 뒤에 다시 각각의 후속 토큰을 붙이는 식이다.44</p>
<p>이 경우 검증 모델의 어텐션 마스크는 단순한 삼각형이 아니라 복잡한 트리 위상(Topology)을 반영해야 한다.</p>
<ul>
<li><strong>트리 마스크 구성:</strong> 각 노드(토큰)는 자신의 조상 노드들(Ancestors)에게만 어텐션을 줄 수 있고, 형제 노드(Siblings)나 타 분기(Branch)의 노드는 볼 수 없도록 마스크를 구성한다.</li>
<li><strong>병렬성의 극대화:</strong> 검증 모델은 <span class="math math-inline">K</span>개의 토큰이 일렬로 있든, 트리 형태로 퍼져 있든 상관없이, 총 토큰 수만큼의 병렬 연산만 수행하면 된다. 즉, 트리의 깊이(Depth)가 얕더라도 너비(Width)를 넓혀서 한 번에 수십 개의 후보를 검증함으로써, 단 한 번의 GPU 호출로 여러 개의 정답 토큰을 찾아낼 확률(기대 수락 길이)을 높인다.33</li>
</ul>
<h3>4.3  KV 캐시(KV Cache) 관리와 메모리 공유</h3>
<p>협업의 효율성은 메모리 관리, 특히 <strong>KV 캐시</strong>의 처리에서 결정된다.</p>
<ul>
<li><strong>재사용(Reuse):</strong> 검증 과정에서 계산된 <span class="math math-inline">K</span>개 토큰의 Key, Value 벡터들은 만약 해당 토큰이 수락된다면 다음 단계 추론을 위해 그대로 보존되어야 한다. 이는 중복 연산을 방지하는 핵심이다.</li>
<li><strong>폐기(Discard):</strong> 반면 기각된 토큰들에 대한 KV 캐시는 즉시 메모리에서 해제되거나 덮어씌워져야 한다.</li>
<li><strong>구현의 난점:</strong> 트리 구조의 후보를 검증할 때는, 어떤 가지(Branch)가 선택될지 모르기 때문에 모든 분기의 KV 캐시를 임시로 저장해야 한다. vLLM과 같은 고성능 추론 엔진은 <strong>PagedAttention</strong> 기술을 활용하여, 비연속적인 물리 메모리 공간에 트리 구조의 KV 캐시를 동적으로 할당하고 매핑함으로써 이 문제를 해결한다. 이를 통해 메모리 파편화(Fragmentation)를 막고 초안 검증의 오버헤드를 최소화한다.2</li>
</ul>
<h2>5.  심화된 협업 아키텍처 비교 분석 (Case Studies)</h2>
<p>투기적 디코딩의 기본 원리는 같지만, 초안 모델과 검증 모델이 ‘무엇을’ 공유하고 ‘어떻게’ 상호작용하느냐에 따라 다양한 아키텍처로 분화한다. 여기서는 가장 대표적인 세 가지 접근법인 Medusa, EAGLE, 그리고 DeepSeek-V3의 방식을 비교 분석한다.</p>
<h3>5.1  Medusa: 다중 헤드를 통한 트리 기반 협업</h3>
<p>Medusa는 “별도의 모델은 필요 없다, 헤드만 추가하라“는 철학을 따른다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Medusa 접근법</strong></th></tr></thead><tbody>
<tr><td><strong>초안 생성 주체</strong></td><td>검증 모델 마지막 층에 부착된 3~5개의 독립적인 MLP 헤드</td></tr>
<tr><td><strong>공유 자원</strong></td><td>검증 모델의 백본(Backbone) 전체와 히든 스테이트</td></tr>
<tr><td><strong>협업 프로토콜</strong></td><td><strong>Top-k 후보 생성 + 트리 어텐션 검증.</strong> 각 헤드가 상위 <span class="math math-inline">k</span>개 후보를 내놓으면, 이들의 조합(Cartesian Product)으로 트리를 구성하여 검증 모델에 전달.</td></tr>
<tr><td><strong>장점</strong></td><td>초안 생성 비용이 거의 0에 가까움(Zero-cost drafting). 파라미터 효율적.</td></tr>
<tr><td><strong>단점</strong></td><td>헤드들이 서로 독립적이라 문맥 의존성이 약함. 이를 보완하기 위해 트리 검증 필수.</td></tr>
</tbody></table>
<p>Medusa의 혁신은 초안 생성 단계를 검증 모델의 포워드 패스에 기생(Parasitic)시키는 방식이다. 즉, 검증 모델이 <span class="math math-inline">t</span>번째 토큰을 생성할 때, 부산물로 <span class="math math-inline">t+1, \dots, t+K</span>번째 토큰 예측값까지 얻어낸다.33</p>
<h3>5.2  EAGLE: 특징(Feature) 레벨의 심층 통합</h3>
<p>EAGLE은 “검증 모델의 뇌를 모방하라“는 철학을 따른다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>EAGLE 접근법</strong></th></tr></thead><tbody>
<tr><td><strong>초안 생성 주체</strong></td><td>1개의 경량 트랜스포머 레이어 (Auto-regressive)</td></tr>
<tr><td><strong>공유 자원</strong></td><td>검증 모델의 <strong>임베딩 레이어</strong>와 <strong>LM Head (분류기)</strong></td></tr>
<tr><td><strong>협업 프로토콜</strong></td><td><strong>특징 외삽(Feature Extrapolation).</strong> 초안 모델은 토큰 ID가 아니라 ’특징 벡터’를 예측하고, 검증 모델의 LM Head를 빌려 토큰으로 변환.</td></tr>
<tr><td><strong>장점</strong></td><td>검증 모델의 잠재 공간(Latent Space)을 공유하므로 수락률이 매우 높음.</td></tr>
<tr><td><strong>단점</strong></td><td>별도의 초안 레이어(비록 작지만)를 훈련해야 함.</td></tr>
</tbody></table>
<p>EAGLE은 검증 모델의 가장 중요한 부분인 ’의미 해석(Embedding)’과 ‘의사 결정(LM Head)’ 모듈을 공유함으로써, 초안 모델과 검증 모델의 ’싱크로율’을 극대화했다. 이는 특히 70B 이상의 거대 모델에서 높은 가속 성능을 보여준다.35</p>
<h3>5.3  DeepSeek-V3: 훈련과 추론의 일체화 (MTP)</h3>
<p>DeepSeek-V3는 투기적 디코딩을 위한 모듈을 아예 <strong>사전 훈련(Pre-training)</strong> 단계부터 내재화시켰다.47</p>
<ul>
<li><strong>Multi-Token Prediction (MTP):</strong> 모델을 훈련할 때, 단순히 다음 토큰(<span class="math math-inline">t+1</span>) 하나만 예측하는 것이 아니라, <span class="math math-inline">t+2, t+3</span> 토큰까지 예측하는 보조 모듈(MTP Module)을 함께 훈련한다.</li>
<li><strong>협업의 진화:</strong> 추론 시 이 MTP 모듈은 자연스럽게 ‘초안 모델’ 역할을 수행한다. 별도로 훈련된 Medusa 헤드나 EAGLE 레이어를 붙이는 것이 아니라, 모델 자체가 태생적으로 미래를 예측하는 능력을 가지고 태어나는 셈이다.</li>
<li><strong>효과:</strong> 훈련 목표(Objective)와 추론 전략(Strategy)이 일치되면서, 추가적인 튜닝 없이도 높은 성능의 투기적 디코딩이 가능해졌다. 또한 MTP 훈련 자체가 모델의 전반적인 언어 이해력을 높이는 효과도 있음이 입증되었다.49</li>
</ul>
<h2>6.  성능 분석: 속도와 비용의 트레이드오프</h2>
<p>투기적 디코딩이 항상 이득인 것은 아니다. 초안 모델과 검증 모델의 협업에는 비용이 따르며, 특정 조건에서는 오히려 기본 디코딩보다 느려질 수 있다. 이를 분석하기 위해 속도 향상(Speedup) 비율 <span class="math math-inline">S</span>에 대한 이론적 모델을 살펴본다.23</p>
<h3>6.1  가속의 수학적 조건</h3>
<p>투기적 디코딩의 기대 속도 향상 <span class="math math-inline">E</span>는 다음과 같이 근사할 수 있다:<br />
<span class="math math-display">
E = \frac{1 - \alpha^{K+1}}{(1 - \alpha)(c \cdot K + 1)}
</span></p>
<ul>
<li><span class="math math-inline">\alpha</span>: 평균 수락률 (Acceptance Rate). <span class="math math-inline">0 \le \alpha \le 1</span>.</li>
<li><span class="math math-inline">K</span>: 초안 생성 길이 (Number of drafted tokens).</li>
<li><span class="math math-inline">c</span>: 검증 모델 대비 초안 모델의 비용 비율 (Cost Ratio). <span class="math math-inline">c \approx 0</span>일수록 좋다.</li>
</ul>
<p>이 수식은 협업의 성공 조건을 명확히 제시한다.</p>
<ol>
<li><strong>수락률 <span class="math math-inline">\alpha</span>가 높아야 한다:</strong> 초안 모델이 정확해야 한다. <span class="math math-inline">\alpha</span>가 낮으면 분자가 작아져 가속 효과가 사라진다.</li>
<li><strong>비용 비율 <span class="math math-inline">c</span>가 낮아야 한다:</strong> 초안 모델은 검증 모델보다 훨씬 가벼워야 한다.</li>
<li><strong>최적의 <span class="math math-inline">K</span>:</strong> <span class="math math-inline">\alpha</span>가 높으면 <span class="math math-inline">K</span>를 늘려도 되지만, <span class="math math-inline">\alpha</span>가 낮을 때 <span class="math math-inline">K</span>를 늘리면 검증 오버헤드만 커져 성능이 하락한다.</li>
</ol>
<h3>6.2  오버헤드와 위험 관리</h3>
<ul>
<li><strong>배치 크기(Batch Size)와의 관계:</strong> 투기적 디코딩은 배치 크기가 작을 때(Memory Bound) 가장 효과적이다. 하지만 배치 크기가 커져서 이미 GPU 가동률이 100%에 육박하는(Compute Bound) 상황이라면, 추가적인 투기 연산은 전체 처리량(Throughput)을 저하시킬 수 있다. vLLM과 같은 시스템은 트래픽이 몰릴 때는 투기적 디코딩을 끄고, 여유가 있을 때만 켜는 동적 스케줄링을 지원한다.52</li>
<li><strong>도메인 시프트(Domain Shift):</strong> 코딩이나 수학 문제처럼 논리적 비약이 심하거나 정형화되지 않은 텍스트에서는 초안 모델의 예측력이 급감하여 <span class="math math-inline">\alpha</span>가 떨어진다. 이 경우 투기적 디코딩은 오히려 ’짐’이 된다. 이를 방지하기 위해 최근 연구들은 실시간으로 <span class="math math-inline">\alpha</span>를 모니터링하며 초안 길이 <span class="math math-inline">K</span>를 동적으로 조절하는 적응형(Adaptive) 기법을 사용한다.29</li>
</ul>
<h2>7.  결론: 협업의 경제학과 미래 전망</h2>
<p>투기적 디코딩에서 초안 모델과 검증 모델의 협업은 단순한 기술적 기교를 넘어, 컴퓨팅 자원의 효율적 배분이라는 경제학적 원리를 내포하고 있다.</p>
<ul>
<li><strong>희소 자원의 절약:</strong> 가장 비싼 자원인 ’검증 모델의 메모리 접근 권한’을 아껴 쓰고, 상대적으로 저렴한 ’연산 능력’과 ’작은 모델의 추론’을 투입하여 전체 가치를 높인다.</li>
<li><strong>싱귤래리티의 가속:</strong> 이 협업 구조는 모델이 커질수록 더욱 중요해진다. 모델이 커질수록 메모리 병목은 심해지고, 반대로 작은 초안 모델과의 성능 격차(용량 대비 성능비)는 커지기 때문이다.</li>
<li><strong>미래의 아키텍처:</strong> DeepSeek-V3의 사례에서 보듯, 향후 LLM 아키텍처는 ’생성’과 ‘검증’ 기능이 분리되지 않고 융합되는 방향으로 진화할 것이다. 이는 인간의 사고 과정—빠른 직관(System 1, 초안)과 느린 논리(System 2, 검증)의 상호작용—과도 닮아 있다.</li>
</ul>
<p>결론적으로 초안 모델과 검증 모델은 ’속도’와 ’정확성’이라는 상충되는 가치를 조화시키기 위해, 확률론적 프로토콜(기각 샘플링)과 하드웨어적 최적화(병렬 검증, KV 캐시 공유)를 통해 긴밀하게 결합된 하나의 유기체처럼 동작한다. 이제 투기적 디코딩은 선택 옵션이 아니라, 초거대 모델을 실용적인 속도로 구동하기 위한 필수 엔진으로 자리 잡았다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Transformer Inference: Techniques for Faster AI Models, https://www.premai.io/blog/transformer-inference-techniques-for-faster-ai-models</li>
<li>Accelerating Large Language Models: A Deep Dive into Speculative Decoding and its vLLM Implementation | by Abhinaykrishna | Medium, https://medium.com/@abhinaykrishna/accelerating-large-language-models-a-deep-dive-into-speculative-decoding-and-its-vllm-9208e8e6e6c6</li>
<li>A Theoretical Perspective for Speculative Decoding Algorithm - arXiv, https://arxiv.org/pdf/2411.00841</li>
<li>Speculative Decoding - philkrav, https://philkrav.com/posts/speculative/</li>
<li>Making LLMs Faster: My Deep Dive into Speculative Decoding | Subhadip Mitra, https://subhadipmitra.com/blog/2025/making-llm-faster/</li>
<li>[D] Understanding Optimal Batch Size Calculation - Arithmetic Intensity : r/MachineLearning, https://www.reddit.com/r/MachineLearning/comments/1lrc7vh/d_understanding_optimal_batch_size_calculation/</li>
<li>Transformer Inference Estimations: Arithmetic Intensity, Throughput and Cost Optimization, https://www.yadavsaurabh.com/transformer-inference-arithmetic-intensity-cost-and-optimization/</li>
<li>A guide to LLM inference and performance - Baseten, https://www.baseten.co/blog/llm-transformer-inference-guide/</li>
<li>[PDF] Fast Inference from Transformers via Speculative Decoding - Semantic Scholar, https://www.semanticscholar.org/paper/d8e9f8c8a37cb4cd26b92ad0d942d641cd512644</li>
<li>Fast Inference from Transformers via Speculative Decoding - OpenReview, https://openreview.net/pdf?id=C9NEblP8vS</li>
<li>Behind the Stack, Ep. 13 - Faster Inference: Speculative Decoding for Batched Workloads, https://www.youtube.com/watch?v=uSlRNBu6fug</li>
<li>Speculative decoding for high-throughput long-context inference - Together AI, https://www.together.ai/blog/speculative-decoding-for-high-throughput-long-context-inference</li>
<li>LLM Inference Series: 5. Dissecting model performance | by Pierre Lienhart | Medium, https://medium.com/@plienhar/llm-inference-series-5-dissecting-model-performance-6144aa93168f</li>
<li>hemingkx/SpeculativeDecodingPapers: Must-read papers and blogs on Speculative Decoding ⚡️ - GitHub, https://github.com/hemingkx/SpeculativeDecodingPapers</li>
<li>(PDF) Fast Inference from Transformers via Speculative Decoding - ResearchGate, https://www.researchgate.net/publication/365889265_Fast_Inference_from_Transformers_via_Speculative_Decoding</li>
<li>Looking back at speculative decoding - Google Research, https://research.google/blog/looking-back-at-speculative-decoding/</li>
<li>OmniDraft: A cross-vocabulary, online adaptive drafter for on-device speculative decoding - OpenReview, https://openreview.net/pdf?id=RALtozQipi</li>
<li>Lossless Speculative Decoding - Emergent Mind, https://www.emergentmind.com/topics/lossless-speculative-decoding</li>
<li>Speculative Speculative Decoding | OpenReview, https://openreview.net/forum?id=aL1Wnml9Ef</li>
<li>Multi-Candidate Speculative Decoding - arXiv, https://arxiv.org/html/2401.06706v1</li>
<li>SpecHub: Provable Acceleration to Multi-Draft Speculative Decoding - ACL Anthology, https://aclanthology.org/2024.emnlp-main.1148.pdf</li>
<li>SpecTr: Fast Speculative Decoding via Optimal Transport, https://proceedings.neurips.cc/paper_files/paper/2023/file/6034a661584af6c28fd97a6f23e56c0a-Paper-Conference.pdf</li>
<li>Optimizing Speculative Decoding for Serving Large Language Models Using Goodput, https://arxiv.org/html/2406.14066v2</li>
<li>Fastest Speculative Decoding in vLLM with Arctic Inference and Arctic Training - Snowflake, https://www.snowflake.com/en/engineering-blog/fast-speculative-decoding-vllm-arctic/</li>
<li>arXiv:2211.17192v2 [cs.LG] 18 May 2023, https://arxiv.org/pdf/2211.17192</li>
<li>OmniDraft: A Cross-vocabulary, Online Adaptive Drafter for On-device Speculative Decoding - arXiv, <a href="https://arxiv.org/pdf/2507.02659">https://arxiv.org/pdf/2507.02659?</a></li>
<li>SWIFT: On-the-Fly Self-Speculative Decoding for LLM Inference Acceleration | OpenReview, https://openreview.net/forum?id=EKJhH5D5wA</li>
<li>[2505.24196] CLaSp: In-Context Layer Skip for Self-Speculative Decoding - arXiv, https://arxiv.org/abs/2505.24196</li>
<li>\scalerel* \method: On-the-Fly Self-Speculative Decoding for LLM Inference Acceleration - arXiv, https://arxiv.org/html/2410.06916v1</li>
<li>Faster Text Generation with Self-Speculative Decoding - Hugging Face, https://huggingface.co/blog/layerskip</li>
<li>New way to speed up inference! Easier than speculative decoding : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/16g27s0/new_way_to_speed_up_inference_easier_than/</li>
<li>Achieve ~2x speed-up in LLM inference with Medusa-1 on Amazon SageMaker AI - AWS, https://aws.amazon.com/blogs/machine-learning/achieve-2x-speed-up-in-llm-inference-with-medusa-1-on-amazon-sagemaker-ai/</li>
<li>Medusa: Simple framework for accelerating LLM generation with multiple decoding heads, https://www.together.ai/blog/medusa</li>
<li>(“”)Medusa: Simple LLM Inference Acceleration Framework with Multiple Decoding Heads - arXiv, https://arxiv.org/html/2401.10774v1</li>
<li>An Introduction to Speculative Decoding for Reducing Latency in AI Inference, https://developer.nvidia.com/blog/an-introduction-to-speculative-decoding-for-reducing-latency-in-ai-inference/</li>
<li>EAGLE-3: Scaling up Inference Acceleration of Large Language Models via Training-Time Test - arXiv, https://arxiv.org/html/2503.01840v1</li>
<li>EAGLE: Extrapolation Algorithm for Greater Language-model Efficiency - Google Sites, https://sites.google.com/view/eagle-llm</li>
<li>arXiv:2502.14856v2 [cs.CL] 11 Mar 2025, https://arxiv.org/pdf/2502.14856</li>
<li>Gumiho: A New Paradigm for Speculative Decoding — Earlier Tokens in a Draft Sequence Matter More - ROCm™ Blogs, https://rocm.blogs.amd.com/software-tools-optimization/gumiho/README.html</li>
<li>Ngram Prompt Lookup Decoding - Aphrodite Engine, https://aphrodite.pygmalion.chat/spec-decoding/ngram/</li>
<li>Break the Sequential Dependency of LLM Inference Using Lookahead Decoding - arXiv, https://arxiv.org/html/2402.02057v1</li>
<li>Break the Sequential Dependency of LLM Inference Using Lookahead Decoding - GitHub, https://raw.githubusercontent.com/mlresearch/v235/main/assets/fu24a/fu24a.pdf</li>
<li>[R] Break the Sequential Dependency of LLM Inference Using Lookahead Decoding, https://www.reddit.com/r/MachineLearning/comments/181z1cf/r_break_the_sequential_dependency_of_llm/</li>
<li>Exploring Medusa and Multi-Token Prediction | by Matthew Gunton | TDS Archive | Medium, https://medium.com/data-science/exploring-medusa-and-multi-token-prediction-de7f8312e4a7</li>
<li>How Medusa Works - YouTube, https://www.youtube.com/watch?v=Jjjn-J9SJ1s</li>
<li>How we built production-ready speculative decoding with TensorRT-LLM - Baseten, https://www.baseten.co/blog/how-we-built-production-ready-speculative-decoding-with-tensorrt-llm/</li>
<li>Accelerating DeepSeek-V3 inference using multi-token prediction in SGLang, https://rocm.docs.amd.com/projects/ai-developer-hub/en/latest/notebooks/inference/mtp.html</li>
<li>deepseek-ai/DeepSeek-V3 - Hugging Face, https://huggingface.co/deepseek-ai/DeepSeek-V3</li>
<li>Four unique takeaways from Deepseek v3 - AWS Builder Center, https://builder.aws.com/content/2rJj1WkztSfYwVfsIibhWxeqMf1/four-unique-takeaways-from-deepseek-v3</li>
<li>DeepSeek-V3 Technical Report - arXiv, https://arxiv.org/html/2412.19437v1</li>
<li>Draft &amp; Verify: Lossless Large Language Model Acceleration via Self-Speculative Decoding - ACL Anthology, https://aclanthology.org/2024.acl-long.607.pdf</li>
<li>How Speculative Decoding Boosts vLLM Performance by up to 2.8x, https://blog.vllm.ai/2024/10/17/spec-decode.html</li>
<li>Efficient LLM Inference: Bandwidth, Compute, Synchronization, and Capacity are all you need - arXiv, https://arxiv.org/html/2507.14397v1</li>
<li>Inference economics of language models - arXiv, https://arxiv.org/html/2506.04645v1</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>