<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:VINE 성공 및 실패 데모를 활용한 Hierarchiical VLA 모델 (2025-12-03)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>VINE 성공 및 실패 데모를 활용한 Hierarchiical VLA 모델 (2025-12-03)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">Vision-Language-Action(VLA) 모델</a> / <span>VINE 성공 및 실패 데모를 활용한 Hierarchiical VLA 모델 (2025-12-03)</span></nav>
                </div>
            </header>
            <article>
                <h1>VINE 성공 및 실패 데모를 활용한 Hierarchiical VLA 모델 (2025-12-03)</h1>
<p>2025-12-07, G30DR</p>
<h2>1.  서론: 로봇 학습의 패러다임 전환과 VINE의 등장</h2>
<h3>1.1  체화된 인공지능(Embodied AI)과 VLA 모델의 부상</h3>
<p>최근 인공지능 분야는 거대 언어 모델(Large Language Model, LLM)의 비약적인 발전에 힘입어, 텍스트와 이미지를 넘어 물리적 세계와 상호작용하는 체화된 인공지능(Embodied AI)으로 그 영역을 급격히 확장하고 있다. 이러한 흐름의 중심에는 시각-언어-행동(Vision-Language-Action, VLA) 모델이 자리 잡고 있다. VLA 모델은 시각적 인식(Perception)과 언어적 이해(Understanding)를 로봇의 물리적 제어(Control)와 결합하여, 자연어 명령을 통해 로봇이 복잡한 작업을 수행하도록 만드는 것을 목표로 한다.1</p>
<p>기존의 로봇 제어 시스템이 명시적인 상태 추정이나 경로 계획 알고리즘에 의존했던 것과 달리, VLA 모델은 대규모 데이터를 기반으로 입력(이미지, 텍스트)과 출력(로봇 행동) 사이의 매핑을 학습하는 ‘End-to-End’ 방식을 취한다. 구글 딥마인드의 RT-2(Robotic Transformer 2)나 OpenVLA와 같은 선도적인 연구들은 인터넷 규모의 비전-언어 데이터셋으로 사전 학습된 모델을 로봇 데이터에 미세 조정(Fine-tuning)함으로써, 로봇이 이전에 보지 못한 물체나 지시어에 대해서도 일반화된 조작 능력을 보여줄 수 있음을 증명했다.1 이는 로봇 공학의 오랜 난제였던 ‘일반화(Generalization)’ 문제에 대한 새로운 해법을 제시한 것으로 평가받는다.</p>
<h3>1.2  성공 편향(Success Bias)의 한계와 데이터 효율성 문제</h3>
<p>그러나 현재의 VLA 모델들은 근본적인 한계에 직면해 있다. 가장 치명적인 문제는 학습 데이터의 ’성공 편향’이다. 대부분의 VLA 모델은 전문가(사람)가 원격 조작(Teleoperation)을 통해 수집한 ’성공적인 데모(Successful Demonstrations)’만을 학습 데이터로 활용한다.3 데이터 수집 과정에서 필연적으로 발생하는 수많은 실패 사례들—물건을 떨어뜨리거나, 목표 위치를 벗어나거나, 안전하지 않은 경로로 이동하는 경우 등—은 노이즈로 간주되어 폐기되거나 학습에서 배제된다.</p>
<p>이러한 접근법은 두 가지 심각한 문제를 야기한다. 첫째, 데이터의 비효율성이다. 로봇 데이터 수집은 물리적인 시간이 소요되는 고비용 작업이다. 수집된 데이터의 상당 부분을 차지하는 실패 데이터를 버리는 것은 자원의 낭비일 뿐만 아니라, 로봇이 학습할 수 있는 정보의 양을 스스로 제한하는 행위이다. 둘째, 강인성(Robustness)의 결여다. 성공 데이터만으로 학습된 정책(Policy)은 ‘정답 경로’ 근처의 분포(Distribution) 내에서는 잘 작동하지만, 예기치 않은 외란이나 오차로 인해 분포를 벗어난 상태(Out-of-Distribution, OOD)에 진입했을 때 회복하는 방법을 모른다.5 로봇은 ’무엇을 해야 하는지’는 배웠지만, ’무엇을 해서는 안 되는지’에 대한 경계 조건(Boundary Conditions)을 학습하지 못했기 때문이다. 이는 복잡하고 장기적인 계획이 필요한 작업에서 로봇이 쉽게 취약한 상태(Brittle State)에 빠지게 만든다.</p>
<h3>1.3  VINE 모델의 제안과 연구의 목적</h3>
<p>본 보고서에서 심층 분석할 **VINE(Vision-Language-Action model Integrating Negative Experience)**은 이러한 배경에서 등장한 혁신적인 프레임워크이다. Jeongeun Park(고려대학교), Jihwan Yoon(고려대학교), Sangdoo Yun(NAVER AI Lab), Sungjoon Choi(고려대학교) 등 연구진이 제안한 VINE은 실패 데이터를 단순한 오류가 아닌, 정책의 취약점을 보완하고 실행 가능한 영역을 정의하는 핵심 자원으로 재해석한다.6</p>
<p>VINE은 성공과 실패 데모를 모두 활용하여 로봇의 행동 강인성을 높이는 계층적(Hierarchical) VLA 모델이다. 이 모델은 인간의 인지 처리 과정을 모사한 이중 시스템(Dual System) 아키텍처를 채택하여, 직관적이고 빠른 행동 실행(System 1)과 신중하고 논리적인 계획 수립(System 2)을 분리하면서도 유기적으로 결합한다.5 특히 시스템 2는 실패 경험을 바탕으로 계획의 타당성(Feasibility)을 평가하고, 위험한 경로를 사전에 가지치기(Pruning)하는 역할을 수행한다.</p>
<p>본 보고서는 VINE 모델의 이론적 배경, 기술적 아키텍처, 학습 방법론, 그리고 실험적 검증 결과를 포괄적으로 분석한다. 특히 실패 데이터가 어떻게 수학적으로 모델링되어 학습에 기여하는지, 그리고 장면 그래프(Scene Graph)와 같은 상태 추상화 기법이 계획 단계에서 어떤 이점을 제공하는지를 중점적으로 다룬다. 이를 통해 VINE이 제시하는 로봇 학습의 새로운 패러다임을 조망하고, 향후 체화된 인공지능 연구에 미칠 시사점을 도출하고자 한다.</p>
<h2>2.  이론적 배경: 계층적 강화 학습과 인지 아키텍처</h2>
<p>VINE 모델을 깊이 있게 이해하기 위해서는 그 기반이 되는 이론적 프레임워크인 계층적 강화 학습(Hierarchical Reinforcement Learning, HRL)과 인지 과학의 이중 시스템 이론, 그리고 최신 VLA 모델의 기술적 동향을 살펴볼 필요가 있다.</p>
<h3>2.1  계층적 강화 학습 (HRL)과 옵션 프레임워크</h3>
<p>복잡한 작업을 단일 정책으로 해결하려는 시도는 차원의 저주(Curse of Dimensionality)와 희소 보상(Sparse Reward) 문제로 인해 학습 효율이 극도로 낮아지는 경향이 있다. 계층적 강화 학습(HRL)은 이러한 문제를 해결하기 위해, 거대한 문제를 시간적 추상화(Temporal Abstraction)를 통해 계층적인 하위 문제들로 분해한다.6</p>
<p>VINE은 Sutton 등이 제안한 **옵션 프레임워크(Options Framework)**를 채택하여 문제를 정식화한다.6 이 프레임워크에서 로봇의 행동은 다음과 같은 요소들로 구성된 ‘옵션(Option)’ 단위로 관리된다.</p>
<ul>
<li><strong>시작 조건(Initiation Set, <span class="math math-inline">\mathcal{I}</span>):</strong> 해당 옵션을 실행할 수 있는 상태들의 집합.</li>
<li><strong>내부 정책(Intra-option Policy, <span class="math math-inline">\pi</span>):</strong> 옵션이 실행되는 동안 행동을 결정하는 저수준 정책.</li>
<li><strong>종료 조건(Termination Condition, <span class="math math-inline">\beta</span>):</strong> 옵션의 실행을 멈추고 상위 레벨로 제어권을 반환할 확률.</li>
</ul>
<p>VINE에서 상위 레벨의 시스템(System 2)은 현재 상태에서 어떤 옵션(하위 목표)을 선택할지를 결정하는 메타 컨트롤러(Meta-controller) 역할을 하며, 하위 레벨의 시스템(System 1)은 선택된 옵션 내에서 구체적인 모터 제어를 수행하는 내부 정책 역할을 한다. 이는 연속적인 시간의 흐름을 이산적인 의사결정 단계로 변환하는 반-마르코프 결정 과정(Semi-Markov Decision Process, SMDP)을 형성한다.6 이러한 계층적 구조는 장기적인 계획(Long-horizon Planning)을 가능하게 하며, 실패가 발생했을 때 그 원인이 상위 레벨의 잘못된 계획인지 하위 레벨의 실행 오류인지를 구분하여 학습할 수 있는 구조적 토대를 제공한다.</p>
<h3>2.2  인지 과학적 모티브: 시스템 1과 시스템 2</h3>
<p>VINE의 설계 철학은 노벨 경제학상 수상자 다니엘 카너먼이 *생각에 관한 생각(Thinking, Fast and Slow)*에서 제시한 이중 프로세스 이론(Dual Process Theory)과 맞닿아 있다.5</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>시스템 1 (직관적 사고)</strong></th><th><strong>시스템 2 (분석적 사고)</strong></th></tr></thead><tbody>
<tr><td><strong>속도</strong></td><td>빠름 (Fast)</td><td>느림 (Slow)</td></tr>
<tr><td><strong>의식</strong></td><td>무의식적, 자동적</td><td>의식적, 의도적</td></tr>
<tr><td><strong>기능</strong></td><td>숙련된 기술의 즉각적 실행</td><td>복잡한 계산, 계획, 추론</td></tr>
<tr><td><strong>비용</strong></td><td>낮은 인지 비용</td><td>높은 인지 비용</td></tr>
<tr><td><strong>로봇 공학적 대응</strong></td><td><strong>System 1 (Action Modeling):</strong> 이미지와 언어를 입력받아 즉각적인 관절 제어 명령(Action)을 생성.</td><td><strong>System 2 (Reasoning &amp; Planning):</strong> 미래 상태를 예측하고 실패 가능성을 계산하여 최적의 경로를 탐색.</td></tr>
</tbody></table>
<p>기존의 많은 VLA 모델들은 사실상 시스템 1에만 의존해왔다. 즉, 현재의 관측에 대해 반사적으로 행동을 생성하는 방식이었다. 반면 VINE은 시스템 2를 명시적으로 도입하여, 로봇이 행동하기 전에 “생각(Think)“하게 만든다.5 특히 이 “생각“의 과정에 실패 경험을 통합함으로써, 로봇은 자신의 행동이 초래할 수 있는 부정적 결과를 사전에 시뮬레이션하고 회피할 수 있게 된다. 이는 인간이 과거의 실수를 반추하여 미래의 행동을 교정하는 과정과 유사하다.</p>
<h3>2.3  최신 VLA 모델의 기술적 토대</h3>
<p>VINE은 완전히 새로운 모델이라기보다는, 최신의 VLA 기술들을 계층적으로 재구성한 프레임워크이다. VINE의 백본(Backbone)은 <span class="math math-inline">\pi_0</span>와 PaliGemma와 같은 최신 VLA 모델에서 파생되었다.3</p>
<ul>
<li><strong><span class="math math-inline">\pi_0</span> (Pi-zero):</strong> Physical Intelligence 등이 개발한 모델로, 대규모 로봇 데이터와 비전-언어 데이터를 결합하여 강력한 기초 모델(Foundation Model) 성능을 보여준다.1</li>
<li><strong>PaliGemma:</strong> 구글의 PaLI(Pathways Language and Image) 아키텍처를 기반으로 한 경량화된 VLM으로, 시각적 이해와 텍스트 생성에 탁월하다.</li>
</ul>
<p>VINE은 이러한 강력한 사전 학습 모델을 활용하되, 이를 시스템 1과 시스템 2의 공통 백본으로 사용하여 시각-언어적 표현(Representation)을 공유한다. 이는 별도의 무거운 모델을 두 개 사용하는 대신, 효율적인 파라미터 공유와 LoRA(Low-Rank Adaptation) 어댑터를 통해 두 시스템을 동시에 최적화하는 전략을 취한다.7</p>
<hr />
<h2>3.  VINE 모델 아키텍처: 실패를 통한 강인한 계획과 실행</h2>
<p>VINE의 아키텍처는 크게 상위 레벨의 **시스템 2 (Reasoning and Planning)**와 하위 레벨의 **시스템 1 (Action Modeling)**으로 구성된다. 이 두 시스템은 상호보완적으로 작동하며, 특히 실패 데이터의 활용 방식에서 큰 차이를 보인다.</p>
<h3>3.1  시스템 2: 실패 인지 추론 및 계획 (Meta-Controller)</h3>
<p>시스템 2는 로봇의 ’두뇌’에 해당하며, 현재 상태에서 최종 목표(Reach)를 달성하기 위해 거쳐야 할 중간 단계(Subgoal)들을 계획한다. 시스템 2의 핵심 혁신은 <strong>장면 그래프 기반의 상태 추상화</strong>와 **실패 인지 가치 평가(Failure-Aware Value Estimation)**이다.5</p>
<h4>3.1.1  장면 그래프(Scene Graph)를 통한 상태 추상화</h4>
<p>복잡한 비정형 환경에서 픽셀 단위의 이미지로 직접 계획을 수립하는 것은 계산적으로 매우 비효율적이며, 불필요한 시각적 정보(조명 변화, 배경 잡음 등)에 민감할 수 있다. VINE은 이를 해결하기 위해 2D 장면 그래프를 상태 표현(<span class="math math-inline">n = \phi(s)</span>)으로 사용한다.5</p>
<ul>
<li><strong>생성 파이프라인:</strong></li>
</ul>
<ol>
<li><strong>객체 탐지 (Object Detection):</strong> Grounding DINO와 같은 개방형 어휘(Open-vocabulary) 객체 탐지기를 사용하여, 입력 이미지에서 지시어와 관련된 객체들의 바운딩 박스를 추출한다.6</li>
<li><strong>관계 추출 (Relation Extraction):</strong> VLM(예: Gemini-2.5-Flash 등)을 활용하여 탐지된 객체들 사이의 의미론적 관계(예: “inside”, “on top of”, “next to”)를 텍스트 형태의 그래프로 변환한다.6</li>
</ol>
<ul>
<li><strong>이점:</strong> 이러한 상징적(Symbolic) 표현은 고차원의 시각 정보를 저차원의 구조화된 데이터로 압축한다. 이는 계획 단계에서 탐색 공간(Search Space)을 획기적으로 줄여주며, 계획의 과정을 인간이 이해할 수 있는 형태(Interpretability)로 제공한다.</li>
</ul>
<h4>3.1.2  자기회귀적 노드 및 엣지 생성 (Node and Edge Generation)</h4>
<p>시스템 2는 현재의 장면 그래프(<span class="math math-inline">n_k</span>)와 과거의 문맥(<span class="math math-inline">z_{0:k-1}</span>)을 입력받아, 다음 단계의 장면 그래프(<span class="math math-inline">n_{k+1}</span>)와 이를 달성하기 위한 하위 목표(<span class="math math-inline">e_k</span>)를 생성한다. 이 과정은 자기회귀 언어 모델링(Autoregressive LM) 헤드를 통해 수행된다.7</p>
<ul>
<li><strong>생성 방식:</strong> <span class="math math-inline">\hat{P}*{\theta}(n*{k+1}, e_k | n_k, \dots)</span>의 확률 분포를 학습하며, 추론 시에는 토큰 단위의 빔 서치(Beam Search)를 통해 가장 그럴듯한 미래 상태와 행동 지시어를 생성한다.</li>
<li><strong>일관성 검증:</strong> 생성된 텍스트가 문법적으로 올바른지, 그리고 장면 그래프의 논리적 구조(예: A가 B 위에 있으면서 동시에 B가 A 위에 있을 수 없음)를 위반하지 않는지 확인하는 필터링 과정을 거친다.</li>
</ul>
<h4>3.1.3  실패 인지 가치 평가기 (Failure-Aware Value Estimator)</h4>
<p>VINE의 가장 독창적인 구성 요소이다. 일반적인 강화 학습의 가치 함수가 ’성공할 확률’이나 ’기대 보상’만을 예측한다면, VINE의 가치 함수(<span class="math math-inline">V_{\theta}</span>)는 <strong>실패 데이터</strong>를 적극적으로 활용하여 학습된다.6</p>
<ul>
<li><strong>역할:</strong> 시스템 2가 생성한 후보 계획(노드와 엣지)에 대해 성공 확률을 스칼라 값으로 예측한다.</li>
<li><strong>학습 데이터:</strong> 성공 궤적(<span class="math math-inline">\mathcal{G}</span>)뿐만 아니라, 실패 궤적(<span class="math math-inline">\mathcal{F}</span>)도 학습에 포함된다.</li>
<li>성공 궤적의 상태: 목표 값 <span class="math math-inline">y_k = 1</span>.</li>
<li>실패 궤적의 상태: 목표 값 <span class="math math-inline">y_k = 0</span>.</li>
<li>중간 상태: <span class="math math-inline">y_k = \gamma V_{\theta&#39;}(n_{k+1})</span> (부트스트래핑).</li>
<li><strong>의의:</strong> 이를 통해 시스템 2는 단순히 “어떤 행동이 좋은지“뿐만 아니라, “어떤 상태가 위험한지“를 명시적으로 학습한다. 탐색 트리에서 실패 확률이 높은(가치 값이 낮은) 분기는 사전에 가지치기(Pruning)되어, 하위 시스템인 시스템 1이 실행 불가능하거나 위험한 명령을 받는 것을 방지한다.6</li>
</ul>
<h4>3.1.4  트리 탐색 (Tree Search) 및 계획 수립</h4>
<p>추론 단계에서 시스템 2는 MCTS(Monte Carlo Tree Search)와 유사한 방식의 탐색을 수행한다.</p>
<ol>
<li>현재 상태에서 가능한 여러 하위 목표(<span class="math math-inline">e</span>)와 그 결과 상태(<span class="math math-inline">n</span>)를 제안한다(Expansion).</li>
<li>실패 인지 가치 평가기를 통해 각 후보의 성공 확률을 평가한다(Evaluation).</li>
<li>성공 확률이 가장 높은 경로를 선택하여 시스템 1에게 전달한다(Selection).</li>
</ol>
<p>이러한 ’Look-ahead Planning’은 로봇이 근시안적인(Short-sighted) 행동을 하는 것을 막고, 전체 작업의 성공률을 극대화하는 전략적 의사결정을 가능하게 한다.6</p>
<h3>3.2  시스템 1: 실행 및 행동 모델링 (Action Modeling)</h3>
<p>시스템 1은 시스템 2가 결정한 ’무엇을 할지(Plan)’를 ’어떻게 할지(Control)’로 변환하는 실행자이다. 시스템 1은 로봇의 구체적인 관절 속도나 위치를 제어하며, 시스템 2와 달리 <strong>오직 성공한 데모 데이터</strong>만을 사용하여 학습된다.5 이는 기본적인 동작 기술(Core Skills) 자체는 올바른 예시를 통해 배워야 하기 때문이다.</p>
<h4>3.2.1  플로우 매칭(Flow Matching) 기반 행동 전문가</h4>
<p>시스템 1의 정책 네트워크(<span class="math math-inline">\pi_{\theta}</span>)는 최신 생성 모델 기법인 **플로우 매칭(Flow Matching)**을 기반으로 한다.7</p>
<ul>
<li><strong>플로우 매칭이란?</strong> 확산 모델(Diffusion Model)의 대안으로 부상한 기술로, 노이즈 분포를 데이터 분포로 매핑하는 벡터 필드(Vector Field)를 학습한다. 이는 확산 모델보다 학습과 추론이 빠르고 안정적이며, 연속적인 궤적 생성에 유리하다.10</li>
<li><strong>동작:</strong> 현재 관측(<span class="math math-inline">s_t</span>)과 시스템 2가 전달한 하위 목표(<span class="math math-inline">e_k</span>)를 조건(Condition)으로 받아, 짧은 시간 단위의 행동 덩어리(Action Chunk, <span class="math math-inline">A_t</span>)를 생성한다. 이 행동 덩어리는 로봇이 즉각적으로 실행할 일련의 제어 명령이다.</li>
</ul>
<h4>3.2.2  종료 전문가 (Done Expert)</h4>
<p>시스템 1은 언제 현재의 하위 목표가 달성되었는지를 스스로 판단해야 한다. 이를 위해 종료 예측 네트워크(<span class="math math-inline">\beta_{\theta}</span>)가 작동한다.7</p>
<ul>
<li><strong>기능:</strong> 매 시간 단계(Time Step)마다 현재 상태가 하위 목표(<span class="math math-inline">e_k</span>)를 만족시켰는지 확률적으로 계산한다(<span class="math math-inline">p_{\text{done}}</span>).</li>
<li><strong>상호작용:</strong> <span class="math math-inline">p_{\text{done}}</span>이 특정 임계값을 넘으면, 시스템 1은 제어권을 시스템 2로 반환하고, 시스템 2는 다음 하위 목표를 계획하거나 전체 작업의 완료를 선언한다.</li>
</ul>
<hr />
<h2>4.  데이터셋 구축 및 학습 방법론</h2>
<p>VINE의 성능은 데이터의 질과 이를 처리하는 학습 전략에 크게 의존한다. 특히 ’오프라인 학습’과 ’부정적 경험의 통합’이라는 두 가지 키워드가 핵심이다.</p>
<h3>4.1  데이터셋: 성공과 실패의 이분법을 넘어</h3>
<p>VINE 학습을 위해 연구진은 텔레오퍼레이션을 통해 수집된 대규모 데이터셋을 활용한다. 이 데이터셋은 명확하게 라벨링된 두 종류의 궤적을 포함한다.12</p>
<ol>
<li><strong>성공 궤적 (Success Trajectories):</strong> 지시된 작업을 완수하고 목표 상태에 도달한 경우. 시스템 1(행동 생성)과 시스템 2(계획 및 가치 평가) 모두의 학습에 사용된다.</li>
<li><strong>실패 궤적 (Failure Trajectories):</strong> 지시 사항을 위반했거나, 물리적으로 복구 불가능한 상태(예: 로봇 팔이 꼬임, 물체가 닿을 수 없는 곳으로 떨어짐)에 도달한 경우. <strong>오직 시스템 2의 가치 함수 학습에만 사용된다.</strong></li>
</ol>
<p>이러한 데이터 분리 전략은 매우 중요하다. 만약 시스템 1(행동)을 실패 데이터로 학습시킨다면, 로봇은 실패하는 동작 자체를 모방하게 될 위험이 있다. 반면, 시스템 2(계획)에 실패 데이터를 주입함으로써, 로봇은 “이런 상황은 피해야 한다“는 상위 레벨의 지혜를 얻게 된다.6</p>
<h3>4.2  오프라인 학습과 비대칭 기대 손실 (Asymmetric Expectile Loss)</h3>
<p>VINE은 온라인 환경에서의 상호작용 없이, 전적으로 오프라인 데이터만으로 학습된다(Offline RL). 이는 로봇 학습의 안전성을 보장하지만, 분포 밖(OOD) 데이터에 대한 가치 함수의 과대평가(Overestimation) 문제를 야기할 수 있다. 로봇이 가보지 않은 위험한 상태를 “좋은 상태“로 잘못 판단할 수 있기 때문이다.</p>
<p>이를 해결하기 위해 VINE은 <strong>비대칭 기대 손실(Asymmetric Expectile Loss)</strong> 함수를 도입하여 가치 함수를 학습한다.7</p>
<p><span class="math math-display">
\mathcal{L}*{\text{val}} = \mathbb{E}*{\mathcal{D}*{\text{sys2}}}[\mathcal{L}*{\tau_e^2}(y_k - V_{\theta}(n_k | z_{0:k-1}, \ell, s_0))]
</span><br />
여기서 <span class="math math-inline">\mathcal{L}_{\tau_e^2}(u) = |\tau_e - \mathbb{1}(u &lt; 0)| u^2</span> 이다.</p>
<ul>
<li><strong>수학적 의미:</strong> 이 손실 함수는 예측 오차(Error)가 양수일 때와 음수일 때 서로 다른 가중치(<span class="math math-inline">\tau_e</span>)를 부여한다. VINE에서는 <span class="math math-inline">\tau_e = 0.7</span> 등으로 설정하여7, 가치 함수가 실제 값보다 낮게 예측하는 것(보수적 추정)은 상대적으로 허용하되, 실제 값보다 높게 예측하는 것(과대평가)은 강력하게 페널티를 준다.</li>
<li><strong>효과:</strong> 이는 IQL(Implicit Q-Learning) 등의 오프라인 강화 학습 알고리즘에서 검증된 기법으로, 데이터에 없는 불확실한 상태에 대해 로봇이 낙관적인 판단을 내리는 것을 방지하고 안전한 경로를 선호하도록 유도한다.12</li>
</ul>
<h3>4.3  시스템 1의 학습: 포컬 손실 (Focal Loss)</h3>
<p>시스템 1의 종료 전문가(<span class="math math-inline">\beta_{\theta}</span>)를 학습할 때는 데이터 불균형 문제를 해결하기 위해 **포컬 손실(Focal Loss)**을 사용한다.7</p>
<p><span class="math math-display"> \mathcal{L}{\text{done}} = \mathbb{E}{\mathcal{D}{\text{sys1}}}[-\alpha_d (1 - p{\text{done},\theta})^{\gamma_d} \log p_{\text{done},\theta}] </span></p>
<p>대부분의 시간 단계에서 로봇은 작업 ’수행 중’이며, ‘종료’ 시점은 매우 드물다. 포컬 손실은 모델이 맞추기 쉬운 샘플(수행 중)에 대한 가중치를 줄이고, 맞추기 어려운 샘플(종료 시점)에 집중하게 하여 종료 타이밍의 정확도를 높인다.</p>
<h2>5. 실험 평가 및 결과 분석</h2>
<p>VINE의 성능은 정교한 조작이 요구되는 다양한 시뮬레이션 및 실제 로봇 과제에서 검증되었다.</p>
<h3>5.1 실험 환경 및 과제 (Tasks)</h3>
<p>연구진은 WidowX 로봇을 활용한 Simpler 시뮬레이션 환경과 실제 하드웨어 환경에서 실험을 수행했다.6 과제들은 “Reach-Avoid” 목표를 가진 지시어 기반 조작 작업으로 구성되었다.</p>
<ul>
<li><strong>플러그 삽입 (Plug Insertion):</strong> 정밀한 위치 제어가 필요하며, 잘못된 각도로 접근 시 실패하기 쉬움.</li>
<li><strong>서랍 정리 (Drawer Packing):</strong> 물체를 서랍 안에 넣어야 하며, 서랍 가장자리에 부딪히거나 물체를 놓치는 실패 상황이 빈번함.</li>
<li><strong>기타 과제:</strong> 당근을 접시에 놓기(Carrot), 가지를 바구니에 넣기(Eggplant), 블록 쌓기(Cube), 숟가락을 수건 위에 놓기(Spoon) 등.6</li>
</ul>
<h3>5.2 비교 대상 (Baselines)</h3>
<p>VINE의 성능을 객관적으로 평가하기 위해 다음과 같은 베이스라인 모델들과 비교하였다.6</p>
<ol>
<li><strong>VLM-as-Planner:</strong> 거대 언어 모델(VLM)을 사용하여 계획을 수립하지만, 로봇의 실패 데이터를 학습하지 않고 일반적인 상식에 의존하는 모델. (예: SayCan 스타일의 접근).</li>
<li><strong>VINE-Chain:</strong> VINE 아키텍처를 사용하지만, 트리 탐색(분기) 없이 단일 경로만 생성하는 모델. 또한 실패 데이터를 학습하지 않음.</li>
<li><strong>VINE-Tree:</strong> 트리 탐색을 수행하지만, 가치 함수가 실패 데이터 없이 성공 데이터의 신뢰도(Confidence)만을 학습한 모델.</li>
<li><strong>OpenVLA / Octo 등:</strong> 최신 범용 VLA 모델들 (직접적인 비교보다는 VINE의 백본 성능 및 일반화 능력의 참조점으로 활용).3</li>
</ol>
<h3>5.3 주요 실험 결과: 정량적 분석</h3>
<p>실험 결과는 VINE의 우수성을 명확하게 보여준다.</p>
<table><thead><tr><th><strong>모델</strong></th><th><strong>성공률 향상 (상대적)</strong></th><th><strong>실패 회피 능력</strong></th></tr></thead><tbody>
<tr><td><strong>VINE (Proposed)</strong></td><td><strong>Baseline 대비 +17.4%</strong> 15</td><td><strong>최상 (실패 데이터 학습)</strong></td></tr>
<tr><td>VINE-Tree</td><td>중간</td><td>중간 (낙관적 오류 발생)</td></tr>
<tr><td>VINE-Chain</td><td>낮음</td><td>낮음 (단일 경로 고착)</td></tr>
<tr><td>VLM-as-Planner</td><td>기준점 (Baseline)</td><td>낮음 (물리적 실행 불가능 계획 생성)</td></tr>
</tbody></table>
<h4>5.3.1 17.4%의 성능 향상과 그 의미</h4>
<p>VINE은 보지 못한 시뮬레이션 과제(Unseen Tasks)에서 VLM 기반 계획기 대비 <strong>17.4% 향상된 성공률</strong>을 기록했다.15 이는 단순한 수치적 개선을 넘어, 실패 데이터를 학습한 시스템 2가 실행 불가능한 계획을 효과적으로 필터링했음을 의미한다. VLM-as-Planner는 언어적으로는 그럴듯하지만 로봇의 기구학적 제약이나 환경의 물리적 특성을 고려하지 않은 계획을 내놓는 경우가 많았으나, VINE은 “이러면 실패한다“는 데이터를 통해 이를 사전에 차단했다.</p>
<h4>5.3.2 구성 요소 분석 (Ablation Study)</h4>
<ul>
<li><strong>VINE-Tree vs VINE-Full:</strong> 실패 데이터 없이 트리 탐색만 수행한 VINE-Tree는 VINE-Full보다 성능이 낮았다.6 이는 탐색(Search) 자체도 중요하지만, 탐색을 이끄는 가치 함수(Value Function)의 품질이 결정적임을 보여준다. 실패 데이터가 없으면 가치 함수는 모든 경로를 지나치게 낙관적으로 평가하여, 위험한 경로를 선택하게 된다.</li>
<li><strong>트리 탐색의 효과:</strong> VINE-Chain(탐색 없음) 대비 VINE-Tree(탐색 있음)의 성능 향상은 ’Look-ahead’의 중요성을 입증한다. 미래 상태를 예측해보는 것만으로도 근시안적인 실수를 줄일 수 있다.</li>
</ul>
<h4>5.3.3 강인성(Robustness)과 일반화(Generalization)</h4>
<p>VINE은 훈련 데이터에 없던 새로운 물체 배치나 지시어에 대해서도 높은 강인성을 보였다. 특히 서랍 정리 과제에서 불확실성이 높은 상황이 발생했을 때, 시스템 2가 재계획(Replanning)을 수행하여 대안 경로를 찾아내는 능력이 관찰되었다.7 이는 VINE이 단순한 암기가 아니라, 작업의 구조적 인과관계를 학습했음을 시사한다.</p>
<h2>6. 고찰 및 결론: 로봇 학습의 미래를 향하여</h2>
<h3>6.1 연구의 핵심 기여와 시사점</h3>
<p>본 보고서를 통해 분석한 VINE 모델은 로봇 학습 분야에 다음과 같은 중요한 시사점을 던진다.</p>
<ol>
<li><strong>실패 데이터의 자산화 (Turning Trash into Treasure):</strong> 지금까지 로봇 학습에서 실패 데이터는 ‘쓰레기’ 취급을 받았다. VINE은 이를 귀중한 ’자산’으로 변환했다. 이는 데이터 수집 비용을 획기적으로 낮출 뿐만 아니라(실패해도 데이터가 되므로), 인간의 학습 방식과 유사한 ‘시행착오(Trial and Error)’ 기반의 학습을 가능하게 한다.</li>
<li><strong>시스템 1과 2의 성공적인 결합:</strong> 빠른 직관(VLA의 행동 생성)과 느린 숙고(실패 인지 계획)를 결합한 하이브리드 아키텍처는 로봇 지능의 새로운 표준이 될 가능성이 높다. 특히 VINE은 이 두 시스템을 별개의 모델이 아닌, 공유된 백본 위에서 효율적으로 구현함으로써 실용성을 확보했다.</li>
<li><strong>오프라인 학습의 안전성 확보:</strong> 비대칭 기대 손실을 활용한 오프라인 학습 전략은 실제 로봇을 위험에 빠뜨리지 않으면서도, 보수적이고 안전한 정책을 학습할 수 있는 강력한 수학적 도구를 제공한다.</li>
</ol>
<h3>6.2 한계점 및 향후 연구 방향</h3>
<p>물론 VINE에도 한계는 존재한다.</p>
<ul>
<li><strong>장면 그래프의 의존성:</strong> VINE의 계획 능력은 장면 그래프의 정확도에 비례한다. 객체 탐지기가 실패하거나(Occlusion 등), VLM이 관계를 잘못 추출하면 계획 전체가 무너질 수 있다. 향후 3D 장면 그래프나, 신경망 내부의 암묵적 표현(Implicit Representation)을 활용하여 이를 보완하는 연구가 필요하다.7</li>
<li><strong>실시간 추론 비용:</strong> 트리 탐색은 계산 비용이 많이 든다. 매우 빠른 반응이 필요한 동적인 환경(예: 날아오는 공 잡기)에서는 시스템 2의 개입이 병목이 될 수 있다. 시스템 1과 2의 개입 빈도를 동적으로 조절하거나, 시스템 2의 추론을 가속화(Distillation 등)하는 연구가 요구된다.</li>
</ul>
<h3>6.3 결론</h3>
<p>Jeongeun Park, Jihwan Yoon, Sangdoo Yun, Sungjoon Choi 등의 연구진이 제안한 <strong>VINE</strong>은 시각-언어-행동 모델의 한계를 극복하기 위해 ’실패’라는 부정적 경험을 긍정적인 학습 신호로 승화시킨 획기적인 연구이다.6 계층적 구조와 정교한 손실 함수 설계를 통해 로봇의 조작 성능을 17.4% 향상시킨 이 결과는, 향후 체화된 인공지능이 나아가야 할 방향—<strong>단순한 모방을 넘어, 실패를 성찰하고 스스로 계획하는 지능</strong>—을 명확히 제시하고 있다.</p>
<p>VINE 모델은 자율 주행, 가사 로봇, 산업 자동화 등 신뢰성과 안전성이 최우선시되는 모든 로봇 응용 분야에서 핵심적인 기술로 자리 잡을 잠재력을 가지고 있다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>Vision-language-action model - Wikipedia, 12월 7, 2025에 액세스, https://en.wikipedia.org/wiki/Vision-language-action_model</li>
<li>Pure Vision Language Action (VLA) Models: A Comprehensive Survey - arXiv, 12월 7, 2025에 액세스, https://arxiv.org/html/2509.19012v1</li>
<li>π₀: A Vision-Language-Action Flow Model for General Robot Control - ResearchGate, 12월 7, 2025에 액세스, https://www.researchgate.net/publication/395364425_p_A_Vision-Language-Action_Flow_Model_for_General_Robot_Control</li>
<li>Octo: An Open-Source Generalist Robot Policy - ResearchGate, 12월 7, 2025에 액세스, https://www.researchgate.net/publication/380730391_Octo_An_Open-Source_Generalist_Robot_Policy</li>
<li>Hierarchical Vision Language Action Model Using Success and Failure Demonstrations, 12월 7, 2025에 액세스, https://chatpaper.com/paper/215821</li>
<li>Hierarchical Vision Language Action Model Using Success and Failure Demonstrations, 12월 7, 2025에 액세스, https://arxiv.org/html/2512.03913v1</li>
<li>[Literature Review] Hierarchical Vision Language Action Model Using Success and Failure Demonstrations - Moonlight, 12월 7, 2025에 액세스, https://www.themoonlight.io/en/review/hierarchical-vision-language-action-model-using-success-and-failure-demonstrations</li>
<li>Full article: The impact of working memory capacity on intuitive decision-making in sport, 12월 7, 2025에 액세스, https://www.tandfonline.com/doi/full/10.1080/1612197X.2025.2468672</li>
<li>Register Any Point: Scaling 3D Point Cloud Registration by Flow Matching - arXiv, 12월 7, 2025에 액세스, https://arxiv.org/html/2512.01850v1</li>
<li>[Literature Review] Riemannian Flow Matching Policy for Robot Motion Learning, 12월 7, 2025에 액세스, https://www.themoonlight.io/en/review/riemannian-flow-matching-policy-for-robot-motion-learning</li>
<li>FLARE: Robot Learning with Implicit World Modeling - GitHub, 12월 7, 2025에 액세스, https://raw.githubusercontent.com/mlresearch/v305/main/assets/zheng25a/zheng25a.pdf</li>
<li>(PDF) Hierarchical Vision Language Action Model Using Success and Failure Demonstrations - ResearchGate, 12월 7, 2025에 액세스, https://www.researchgate.net/publication/398313119_Hierarchical_Vision_Language_Action_Model_Using_Success_and_Failure_Demonstrations</li>
<li>[Revue de papier] Hierarchical Vision Language Action Model Using Success and Failure Demonstrations - Moonlight, 12월 7, 2025에 액세스, https://www.themoonlight.io/fr/review/hierarchical-vision-language-action-model-using-success-and-failure-demonstrations</li>
<li>From Static to Dynamic: Enhancing Offline-to-Online Reinforcement Learning via Energy-Guided Diffusion Stratification - ResearchGate, 12월 7, 2025에 액세스, https://www.researchgate.net/publication/397366071_From_Static_to_Dynamic_Enhancing_Offline-to-Online_Reinforcement_Learning_via_Energy-Guided_Diffusion_Stratification</li>
<li>Hierarchical Vision Language Action Model Using Success and Failure Demonstrations | alphaXiv, 12월 7, 2025에 액세스, https://www.alphaxiv.org/zh/overview/2512.03913v1</li>
<li>robotics - alphaXiv, 12월 7, 2025에 액세스, https://www.alphaxiv.org/?subcategories=robotics</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>