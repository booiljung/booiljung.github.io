<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:VINE 실패 데이터를 활용해 로봇의 강건성을 향상시킨 VLA 모델</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>VINE 실패 데이터를 활용해 로봇의 강건성을 향상시킨 VLA 모델</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">Vision-Language-Action(VLA) 모델</a> / <span>VINE 실패 데이터를 활용해 로봇의 강건성을 향상시킨 VLA 모델</span></nav>
                </div>
            </header>
            <article>
                <h1>VINE 실패 데이터를 활용해 로봇의 강건성을 향상시킨 VLA 모델</h1>
<p>2025-12-07, G30DR</p>
<h2>1.  서론: 로봇 학습 패러다임의 전환과 부정적 경험의 가치</h2>
<p>인공지능과 로봇 공학의 융합은 지난 수년간 비약적인 발전을 거듭해 왔다. 특히 대규모 언어 모델(LLM)의 성공에 힘입어 등장한 시각-언어-행동(Vision-Language-Action, VLA) 모델은 로봇이 복잡한 자연어 명령을 이해하고 이를 물리적 행동으로 변환하는 데 있어 혁신적인 가능성을 제시했다. RT-X, OpenVLA, <span class="math math-inline">\pi_0</span>와 같은 최신 모델들은 인터넷 규모의 방대한 데이터와 다양한 로봇 형태(Embodiment)를 아우르는 학습을 통해, 과거에는 불가능했던 범용적인 조작 능력을 보여주기 시작했다.1 그러나 이러한 성공 이면에는 데이터 효율성과 학습 방법론에 대한 근본적인 비효율성이 존재한다.</p>
<p>기존의 VLA 모델 학습 방식은 전적으로 ’성공한 데모(Successful Demonstrations)’에 의존한다. 로봇을 원격으로 조작(Teleoperation)하여 데이터를 수집하는 과정에서 필연적으로 발생하는 수많은 실패 사례—물체를 떨어뜨리거나, 충돌하거나, 잘못된 순서로 작업을 수행하는 경우—는 단순히 ’노이즈’로 간주되어 폐기되거나 학습 데이터셋에서 배제되어 왔다.2 이는 데이터 수집 비용을 증가시킬 뿐만 아니라, 모델이 ’무엇을 해야 하는지(What to do)’는 배우지만 ’무엇을 해서는 안 되는지(What not to do)’에 대한 결정적인 정보를 습득하지 못하게 하는 결과를 초래한다.</p>
<p>본 보고서에서 심층적으로 분석할 VINE(Vision-Language-Action model Integrating Negative Experience)은 이러한 기존 관행에 정면으로 도전하며 새로운 학습 패러다임을 제시한다. VINE의 핵심 철학은 “실패 데이터는 단순한 노이즈가 아니라, 정책(Policy)이 취약해지는 경계(Boundary)와 불가능한 영역에 대한 정보를 인코딩하고 있는 고가치의 자산“이라는 것이다.2 실패를 회피해야 할 대상이 아닌, 적극적으로 학습하고 분석해야 할 신호로 재정의함으로써, VINE은 로봇이 단순한 행동 모방을 넘어 상황에 따른 실행 가능성(Feasibility)을 추론하고, 위험을 사전에 회피하는 고차원적인 지능을 갖추도록 설계되었다.</p>
<p>VINE은 인간의 인지과학적 모델인 이중 프로세스 이론(Dual Process Theory)에 기반하여, 빠르고 직관적인 행동을 담당하는 ’시스템 1(System 1)’과 느리지만 신중한 계획을 담당하는 ’시스템 2(System 2)’의 계층적 구조를 채택한다.1 본 보고서는 VINE의 이론적 배경부터 아키텍처의 세부 사항, 수학적 정식화, 그리고 실제 로봇 실험을 통한 검증 결과까지 포괄적으로 분석한다. 특히, 실패 데이터가 로봇의 강건성(Robustness)과 일반화(Generalization) 능력에 미치는 영향을 정량적, 정성적으로 규명하고, 이것이 향후 로봇 공학 및 임바디드 AI(Embodied AI) 분야에 미칠 파급력을 논의한다.</p>
<h2>2.  이론적 배경 및 문제의 재정의</h2>
<h3>2.1  기존 VLA 모델의 한계와 데이터의 비대칭성</h3>
<p>기존의 VLA 모델들은 이미지와 텍스트를 입력받아 로봇의 관절 제어 신호를 직접 출력하는 엔드-투-엔드(End-to-End) 방식을 주로 사용한다. 이러한 방식은 데이터의 양이 충분할 경우 강력한 성능을 발휘하지만, ’성공 궤적’이라는 양의 예시(Positive Example)만을 학습하기 때문에 결정 경계(Decision Boundary)가 명확하지 않다는 단점이 있다.</p>
<p>성공 데이터만으로 학습된 모델은 학습 분포 내(In-Distribution)의 상황에서는 잘 작동하지만, 조금이라도 벗어난 상황(Out-of-Distribution)에 직면하면 복구 불가능한 상태로 빠지거나, 물리적으로 불가능한 행동을 반복하는 경향이 있다. 이는 모델이 실패를 경험해보지 못했기 때문에, 현재의 상태가 실패로 이어지는 전조(Precursor)임을 인지하지 못하기 때문이다. 데이터 수집 과정에서 발생하는 실패 데이터는 이러한 ’음의 영역(Negative Space)’에 대한 정보를 풍부하게 담고 있음에도 불구하고, 기존 방법론에서는 이를 활용할 적절한 메커니즘이 부재했다.</p>
<h3>2.2  계층적 강화 학습(HRL)의 도입</h3>
<p>VINE은 이러한 문제를 해결하기 위해 계층적 강화 학습(Hierarchical Reinforcement Learning, HRL) 프레임워크를 도입한다. 로봇의 작업을 단일한 긴 시퀀스로 보지 않고, 상위 레벨의 의사결정과 하위 레벨의 실행으로 분리하는 것이다.</p>
<p>문제는 마르코프 결정 과정(Markov Decision Process, MDP) <span class="math math-inline">\mathcal{M} = (\mathcal{S}, \mathcal{A}, \mathcal{T}, \rho)</span>으로 정의된다.2</p>
<ul>
<li><span class="math math-inline">\mathcal{S}</span>: 상태 공간 (이미지, 로봇 상태 등)</li>
<li><span class="math math-inline">\mathcal{A}</span>: 행동 공간 (관절 토크, 위치 제어 등)</li>
<li><span class="math math-inline">\mathcal{T}</span>: 전이 확률 (환경의 물리적 법칙)</li>
<li><span class="math math-inline">\rho</span>: 초기 상태 분포</li>
</ul>
<p>VINE은 이 MDP 위에 상위 레벨의 추상화된 상태 공간을 정의한다. 이를 위해 2D 장면 그래프(Scene Graph)를 도입하여, 연속적인 픽셀 공간 <span class="math math-inline">\mathcal{S}</span>를 이산적인 노드 집합 <span class="math math-inline">\mathcal{N}</span>으로 매핑한다.2 여기서 노드 <span class="math math-inline">n \in \mathcal{N}</span>은 객체들의 관계를 나타내는 상징적 상태이며, 엣지 <span class="math math-inline">e \in \mathcal{E}</span>는 한 상태에서 다른 상태로 전이하기 위한 서브골(Subgoal) 또는 옵션(Option)을 의미한다.</p>
<p>이러한 계층적 구조는 Sutton 등이 제안한 옵션 프레임워크(Option Framework)를 따른다.1 각 옵션 <span class="math math-inline">o_e</span>는 다음과 같이 구성된다:</p>
<ul>
<li><span class="math math-inline">\mathcal{IN}_e \subseteq \mathcal{S}</span>: 옵션이 시작될 수 있는 상태 집합 (Initiation Set)</li>
<li><span class="math math-inline">\pi_e(a | s, \ell)</span>: 옵션을 실행하는 내부 정책 (Intra-option Policy)</li>
<li>$\beta_e: \mathcal{S} \rightarrow $: 옵션의 종료 여부를 판단하는 종료 함수 (Termination Function)</li>
<li><span class="math math-inline">\Pi_e: \mathcal{S} \rightarrow \mathcal{N}</span>: 물리적 상태를 다시 상위 레벨 노드로 매핑하는 투영 함수</li>
</ul>
<p>이 구조의 핵심 이점은 ’실패’를 상위 레벨의 계획 단계에서 처리할 수 있다는 점이다. 하위 레벨의 제어기는 단순히 명령을 수행하는 기계적인 역할을 하고, 상위 레벨의 플래너가 “이 행동을 하면 실패할 확률이 높다“는 것을 판단하게 함으로써, 전체 시스템의 안정성을 확보한다.</p>
<h2>3.  VINE 아키텍처: 이중 시스템(Dual-System) 설계</h2>
<p>VINE의 아키텍처는 인지과학에서 제시하는 인간의 사고 체계, 즉 시스템 1(직관적 사고)과 시스템 2(분석적 사고)의 협력 모델을 공학적으로 구현한 것이다.2</p>
<h3>3.1  시스템 2: 추론 및 계획 (Reasoning and Planning)</h3>
<p>시스템 2는 VINE의 두뇌에 해당하며, 복잡한 장기 계획을 수립하고 행동의 실행 가능성을 평가한다.</p>
<h4>3.1.1  2D 장면 그래프를 통한 추상화</h4>
<p>시스템 2는 고차원의 이미지 데이터를 직접 처리하는 대신, 이를 의미론적인 2D 장면 그래프로 추상화하여 처리한다. 이 그래프는 객체의 종류, 위치, 그리고 객체 간의 공간적 관계(예: “컵이 테이블 위에 있다”, “로봇 손이 컵 가까이에 있다”)를 노드로 표현한다.2 이러한 추상화는 두 가지 이점을 제공한다. 첫째, 계획 공간을 획기적으로 줄여주어 탐색 효율성을 높인다. 둘째, 시각적 노이즈(조명 변화, 텍스처 변화 등)에 강건한 계획 수립이 가능하다.</p>
<h4>3.1.2  실패 인식 가치 함수 (Failure-Aware Value Function)</h4>
<p>시스템 2의 가장 중요한 구성 요소는 가치 함수(Value Function)이다. 이 함수는 현재 상태와 계획된 행동이 주어졌을 때, 최종적으로 목표 <span class="math math-inline">\mathcal{G}</span>에 도달할 성공 확률을 예측한다. 기존 모델과 달리, VINE의 가치 함수는 성공 데이터와 실패 데이터를 모두 사용하여 학습된다.1</p>
<p>시스템 2는 Reach-Avoid 목표를 최적화한다. 즉, 목표 집합 <span class="math math-inline">\mathcal{G}</span>에는 도달(Reach)하고, 실패 집합 <span class="math math-inline">\mathcal{F}</span>는 회피(Avoid)하는 것이다. 실패 데이터는 <span class="math math-inline">\mathcal{F}</span>에 도달하는 경로에 대한 명시적인 부정적 보상 신호를 제공함으로써, 플래너가 위험한 경로를 식별하고 배제할 수 있도록 가르친다.</p>
<h4>3.1.3  실행 가능성 유도 트리 탐색 (Feasibility-Guided Tree Search)</h4>
<p>학습된 가치 함수를 활용하여 시스템 2는 실행 전 트리 탐색(Tree Search)을 수행한다.</p>
<ol>
<li><strong>후보 생성:</strong> 현재 노드에서 가능한 다음 서브골(엣지)들을 제안한다.</li>
<li><strong>평가:</strong> 제안된 각 서브골에 대해 가치 함수를 통해 성공 확률을 예측한다.</li>
<li><strong>가지치기 (Pruning):</strong> 성공 확률이 임계값 이하인 경로, 즉 실패할 가능성이 높은 경로는 트리에서 제거한다.3</li>
<li><strong>선택:</strong> 가장 높은 성공 확률(실행 가능성)을 가진 경로를 선택하여 시스템 1에 전달한다.</li>
</ol>
<p>이 과정은 로봇이 실제로 행동하기 전에 머릿속으로 시뮬레이션을 돌려보고, 위험한 행동을 미리 걸러내는 과정과 유사하다.1</p>
<h3>3.2  시스템 1: 행동 모델링 (Action Modeling)</h3>
<p>시스템 1은 시스템 2가 수립한 계획을 구체적인 물리적 행동으로 옮기는 역할을 한다.</p>
<h4>3.2.1  성공 데이터 기반의 저수준 제어</h4>
<p>주목할 점은 시스템 1은 <strong>오직 성공한 데모 데이터로만 학습</strong>된다는 것이다.1 하위 레벨의 제어 정책(Policy)에 실패 데이터를 섞을 경우, 로봇의 동작 자체가 불안정해지거나 의도치 않은 떨림 등이 발생할 수 있다. 따라서 VINE은 “무엇을 할지(계획)“는 실패를 통해 배우되, “어떻게 움직일지(제어)“는 성공적인 동작만을 모방하도록 철저히 분리한다. 이는 VINE이 기존의 고성능 VLA 모델(예: <span class="math math-inline">\pi_0</span>)의 운동 능력을 그대로 보존하면서, 상위 레벨의 지능만을 강화하는 전략을 취하고 있음을 보여준다.</p>
<h4>3.2.2  플로우 매칭(Flow Matching) 기반 실행</h4>
<p>시스템 1은 연속적인 행동 공간에서의 정밀한 제어를 위해 플로우 매칭(Flow Matching) 기법을 사용한다.2 이는 최근 생성 모델에서 각광받는 기술로, 노이즈로부터 유효한 행동 궤적을 빠르고 안정적으로 생성해낸다. 시스템 1은 주어진 서브골 <span class="math math-inline">e_k</span>를 달성하기 위해 필요한 관절의 속도와 위치를 실시간으로 계산하여 로봇을 제어한다.</p>
<hr />
<table><thead><tr><th><strong>구분</strong></th><th><strong>시스템 1 (Action Modeling)</strong></th><th><strong>시스템 2 (Reasoning &amp; Planning)</strong></th></tr></thead><tbody>
<tr><td><strong>역할</strong></td><td>저수준 제어, 물리적 행동 실행</td><td>고수준 계획, 의사결정, 가치 판단</td></tr>
<tr><td><strong>입력</strong></td><td>서브골, 현재 상태(이미지/관절)</td><td>2D 장면 그래프, 자연어 명령, 히스토리</td></tr>
<tr><td><strong>출력</strong></td><td>관절 토크/위치/속도 (Continuous)</td><td>서브골 시퀀스, 다음 상태 노드 (Discrete)</td></tr>
<tr><td><strong>학습 데이터</strong></td><td><strong>성공 데모만 사용</strong></td><td><strong>성공 및 실패 데모 모두 사용</strong></td></tr>
<tr><td><strong>핵심 기술</strong></td><td>Flow Matching, Diffusion Policy</td><td>Tree Search, LLM, Value Estimation</td></tr>
<tr><td><strong>비유</strong></td><td>직관적 반사 신경 (Fast)</td><td>신중한 사고 및 시뮬레이션 (Slow)</td></tr>
</tbody></table>
<hr />
<h2>4.  학습 방법론 및 데이터 전략</h2>
<p>VINE의 학습 프로세스는 오프라인 텔레오퍼레이션 데이터만을 활용하며, 온라인 상호작용 없이 이루어진다는 점에서 안전성과 효율성을 극대화한다.1</p>
<h3>4.1  데이터셋 구성: 혼합 품질 데이터의 활용</h3>
<p>VINE의 학습 데이터셋 <span class="math math-inline">\mathcal{D}</span>는 성공적인 궤적 <span class="math math-inline">\mathcal{D}{succ}</span>와 실패한 궤적 <span class="math math-inline">\mathcal{D}{fail}</span>의 합집합으로 구성된다.</p>
<p><span class="math math-display">
\mathcal{D} = \mathcal{D}_{succ} \cup \mathcal{D}_{fail}
</span><br />
기존 연구들이 <span class="math math-inline">\mathcal{D}_{fail}</span>을 버렸던 것과 달리, VINE은 이를 시스템 2의 가치 함수 학습에 적극적으로 활용한다. 실패 데이터는 로봇이 특정 상태에서 어떤 행동을 취했을 때 목표 달성에 실패했는지를 명확히 보여주는 ‘반면교사’ 역할을 한다.</p>
<h3>4.2  시스템 2의 손실 함수</h3>
<p>시스템 2는 언어 모델링 능력과 가치 추정 능력을 동시에 학습한다.</p>
<h4>4.2.1  언어 모델링 손실 (<span class="math math-inline">\mathcal{L}_{\text{LM}}</span>)</h4>
<p>다음 상태(노드)와 서브골(엣지)을 생성하기 위해 자기회귀(Autoregressive) 손실을 사용한다.2</p>
<p><span class="math math-display">
 \mathcal{L}{\text{LM}} = -\mathbb{E}{\mathcal{D}{\text{sys2}}}[\log \hat{P}{\theta}(n_k | z_{0:k-1}, \ell, s_0) + \log \hat{P}{\theta}(e_k | n_k, z{0:k-1}, \ell, s_0)] 
</span></p>
<p>이 손실 함수는 로봇이 현재 상황과 명령어를 이해하고, 논리적으로 타당한 다음 단계를 언어적/상징적으로 생성하도록 훈련시킨다.</p>
<h4>4.2.2  가치 추정 손실: 비대칭 익스펙타일 (<span class="math math-inline">\mathcal{L}_{\text{val}}</span>)</h4>
<p>실패 데이터를 학습할 때 가장 중요한 것은 가치 추정의 정확성이다. 특히 오프라인 강화학습에서는 분포 밖의 행동에 대해 가치를 과대평가(Overestimation)하는 문제가 빈번하다. VINE은 이를 방지하기 위해 비대칭 익스펙타일 손실(Asymmetric Expectile Loss)을 도입한다.2</p>
<p><span class="math math-display">
\mathcal{L}{\text{val}} = \mathbb{E}{\mathcal{D}{\text{sys2}}}[\mathcal{L}{\tau_e^2}(y_k - V_{\theta}(n_k | z_{0:k-1}, \ell, s_0))]
</span><br />
여기서 <span class="math math-inline">\mathcal{L}_{\tau_e^2}(u) = (\tau_e - \mathbb{1}(u &lt; 0)) u^2</span>이며, <span class="math math-inline">\tau_e</span>는 0.7로 설정된다.</p>
<p>이 손실 함수는 예측 오차에 대해 비대칭적인 페널티를 부여한다. <span class="math math-inline">\tau_e</span>가 0.5보다 크다는 것은 과소평가보다는 과대평가를 더 강하게 억제하거나, 혹은 성공 가능성이 있는 경로에 대해 더 보수적인 추정을 하도록 유도하는 수학적 장치이다.</p>
<p>학습 타겟 <span class="math math-inline">y_k</span>는 성공 시 1, 실패 시 0의 보상을 부여하는 희소 보상(Sparse Reward) 구조를 가진다.</p>
<p><span class="math math-display">
y_k = \begin{cases} 1, &amp; \text{terminal in } \mathcal{G} \ 0, &amp; \text{terminal in } \mathcal{F} \ \gamma V_{\theta&#39;}(\dots), &amp; \text{otherwise} \end{cases}
</span><br />
이 구조를 통해 시스템 2는 실패로 이어지는 경로의 가치를 0에 가깝게 학습하게 되며, 결과적으로 계획 단계에서 이러한 경로를 선택하지 않게 된다.</p>
<h3>4.3  시스템 1의 손실 함수</h3>
<p>시스템 1은 행동의 실행과 종료를 학습한다.</p>
<h4>4.3.1  행동 전문가 손실 (<span class="math math-inline">\mathcal{L}_{\text{act}}</span>)</h4>
<p>행동 생성은 플로우 매칭을 통해 학습되며, 오라클 속도 <span class="math math-inline">u</span>와의 차이를 최소화한다.2</p>
<p><span class="math math-display">
\mathcal{L}{\text{act}} = \mathbb{E}{\mathcal{D}{\text{sys1}}}[\left| \dot{A}{\theta}(A_t^{\tau}, s_t, \ell, e_k, n_{k+1}) - u(A_t^{\tau} | A_t) \right|_2^2]
</span><br />
이는 노이즈가 섞인 행동 <span class="math math-inline">A_t^{\tau}</span>로부터 원래의 행동 <span class="math math-inline">A_t</span>를 복원하는 벡터 필드를 학습하는 과정이다.</p>
<h4>4.3.2  종료 전문가 손실 (<span class="math math-inline">\mathcal{L}_{\text{done}}</span>)</h4>
<p>서브골의 달성 여부를 판단하기 위해 포컬 손실(Focal Loss)을 사용한다.2</p>
<p><span class="math math-display">
\mathcal{L}{\text{done}} = \mathbb{E}{\mathcal{D}{\text{sys1}}}[-\alpha_d (1 - p{\text{done},\theta})^{\gamma_d} \log p_{\text{done},\theta}]
</span><br />
포컬 손실은 데이터 불균형 문제(대부분의 타임스텝은 ’종료 아님’이고 극히 일부만 ’종료’임)를 해결하여, 종료 시점을 정확하게 포착하도록 돕는다.</p>
<h2>5.  실험 및 검증</h2>
<p>VINE의 유효성을 검증하기 위해 연구진은 시뮬레이션과 실제 로봇 환경에서 다양한 난이도의 조작 작업을 수행했다. 비교 대상으로는 최신 VLA 모델들과 LLM 기반 플래너들이 포함되었다.</p>
<h3>5.1  실험 환경 설정</h3>
<h4>5.1.1  시뮬레이션 (MuJoCo)</h4>
<p>Custom MuJoCo 환경에서 물리적 상호작용이 중요한 두 가지 작업을 수행했다.2</p>
<ol>
<li><strong>플러그 삽입 (Plug Insertion):</strong> 소켓과 플러그 사이의 정밀한 정렬과 힘 조절이 필요한 작업. 실패 시 플러그가 튕겨 나가거나 소켓에 걸리는 현상이 발생한다.</li>
<li><strong>서랍 정리 (Drawer Packing):</strong> 여러 물체를 집어 서랍 안의 지정된 위치에 넣는 작업. 물체 간의 간섭이나 서랍 벽과의 충돌을 피해야 하는 공간적 추론이 요구된다.</li>
</ol>
<h4>5.1.2  실제 로봇 (Real-World)</h4>
<p>6자유도(6-DoF)를 가진 WidowX 로봇 팔을 사용하여 실제 환경에서의 성능을 평가했다.1</p>
<ol>
<li><strong>스펀지 포장 (Sponge Packing):</strong> 스펀지는 형태가 변하는 비강체(Deformable Object)이므로, 집는 위치나 힘에 따라 모양이 변해 조작이 까다롭다.</li>
<li><strong>수건 포장 (Towel Packing):</strong> 수건을 개거나 상자에 넣는 작업은 고도의 유연성과 예측 능력을 필요로 한다.2</li>
</ol>
<h3>5.2  실험 결과 분석</h3>
<p>실험 결과는 VINE이 실패 데이터를 활용함으로써 얻는 이득이 명확함을 보여주었다. 특히 학습 데이터에 포함되지 않은 새로운 환경(Unseen Scenarios)에서의 성능 격차가 두드러졌다.</p>
<h4>5.2.1  정량적 성능 비교 (성공률)</h4>
<table><thead><tr><th><strong>작업 (Task)</strong></th><th><strong>환경</strong></th><th><strong>모델</strong></th><th><strong>성공률 (Success Rate)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>Plug Insertion</strong></td><td>Simulation (Unseen)</td><td><span class="math math-inline">\pi_0</span> (Baseline)</td><td>0.267</td><td>기존 VLA SOTA</td></tr>
<tr><td></td><td></td><td>GPT-4o Planner</td><td>0.333</td><td>LLM 기반 계획</td></tr>
<tr><td></td><td></td><td><strong>VINE (Ours)</strong></td><td><strong>0.422</strong></td><td><strong>SOTA 대비 약 1.5배 향상</strong></td></tr>
<tr><td><strong>Sponge Packing</strong></td><td>Real-World (Unseen)</td><td><span class="math math-inline">\pi_0</span> (Baseline)</td><td>0.55</td><td></td></tr>
<tr><td></td><td></td><td><strong>VINE (Ours)</strong></td><td><strong>0.65</strong></td><td><strong>10%p 향상</strong></td></tr>
<tr><td><strong>Drawer Packing</strong></td><td>Simulation</td><td>OpenVLA-OFT</td><td>0.485</td><td></td></tr>
<tr><td></td><td></td><td>GR00T N1.5</td><td>0.669</td><td></td></tr>
<tr><td></td><td></td><td><span class="math math-inline">\pi_0</span></td><td>0.675</td><td></td></tr>
<tr><td></td><td></td><td><strong>VINE</strong></td><td><strong>0.735</strong></td><td>불확실성 재계획 적용 시</td></tr>
</tbody></table>
<p>1의 데이터를 종합하면, VINE은 모든 작업에서 베이스라인 모델들을 상회하는 성능을 기록했다. 특히 플러그 삽입과 같이 미세한 조작이 실패로 이어지기 쉬운 작업에서 그 격차가 컸는데, 이는 VINE의 시스템 2가 ’실패하기 쉬운 접근 각도’나 ’위험한 힘 조절’을 사전에 계획 단계에서 배제했기 때문으로 해석된다.</p>
<p>수건 포장(Towel Packing) 작업에서도 VINE은 구체적인 수치는 명시되지 않았으나, 베이스라인 대비 특히 보지 못한 시나리오에서 “더 높은 성공률“을 기록하며 일반화 능력을 입증했다.2 이는 비정형 물체를 다룰 때 발생하는 다양한 실패 케이스(예: 수건이 펼쳐지지 않음, 뭉침 등)를 학습한 효과로 볼 수 있다.</p>
<h4>5.2.2  절제 연구 (Ablation Study)</h4>
<p>VINE의 성능 향상 요인을 분해하기 위한 실험 결과는 다음과 같다.2</p>
<ol>
<li><strong>VINE-Chain (No Failure Data):</strong> 실패 데이터를 제거하고 성공 데이터만으로 학습한 경우, 복잡한 작업에서의 성공률이 현저히 떨어졌다. 이는 VINE의 아키텍처적 우수성(계층적 구조)뿐만 아니라, **데이터 자체(부정적 경험)**가 핵심적인 기여를 하고 있음을 증명한다.</li>
<li><strong>VINE-Tree (No Tree Search):</strong> 트리 탐색 없이 단일 경로만 예측할 경우, 불확실한 상황에서 최적의 경로를 선택하지 못해 성능이 하락했다. 이는 가치 함수를 이용한 탐색 과정이 필수적임을 시사한다.</li>
<li><strong>VINE-Full:</strong> 실패 데이터 학습과 트리 탐색을 모두 적용했을 때 가장 높은 성능을 보였다.</li>
</ol>
<h3>5.3  불확실성 기반 재계획 (Replanning)의 효과</h3>
<p>VINE은 실행 도중 불확실성이 감지되면 계획을 수정하는 재계획(Replanning) 모듈을 탑재할 수 있다. 서랍 정리 실험에서 이 기능을 활성화했을 때 성공률이 0.675( <span class="math math-inline">\pi_0</span> 수준)에서 0.735로 상승했다.1 이는 시스템 2가 단순히 초기 계획만 내놓는 것이 아니라, 상황 변화에 따라 유연하게 대처할 수 있는 ’적응형 지능’을 갖추고 있음을 보여준다. 실패 데이터를 학습한 가치 함수는 현재 상태가 ’예상치 못한 실패 궤적’으로 진입하고 있음을 조기에 감지하는 센서 역할을 하여, 로봇이 즉시 멈추거나 다른 대안을 찾도록 유도한다.</p>
<h2>6.  논의: VINE이 제시하는 로봇 공학의 미래</h2>
<h3>6.1  ’실패’의 자산화 (Turning Failure into an Asset)</h3>
<p>VINE 연구의 가장 큰 의의는 로봇 학습 데이터의 가치 평가 기준을 재정립했다는 점이다. 지금까지 로봇 연구자들은 텔레오퍼레이션 중 실수가 발생하면 해당 데이터를 삭제하고 다시 녹화했다. 이는 시간과 비용의 낭비였다. 그러나 VINE은 “실패한 데이터도 성공한 데이터만큼, 혹은 그 이상으로 중요하다“는 것을 입증했다. 이는 향후 로봇 데이터셋 구축 시, 실패 사례를 체계적으로 수집하고 태깅(Tagging)하는 새로운 프로토콜이 필요함을 시사한다. 실패는 더 이상 부끄러운 기록이 아니라, 강건한 인공지능을 만들기 위한 필수 영양분이다.</p>
<h3>6.2  하이브리드 아키텍처의 승리</h3>
<p>VINE은 순수 학습 기반(Learning-based) 모델과 고전적인 계획(Planning) 알고리즘을 성공적으로 결합했다. 시스템 1의 신경망 정책은 유연하고 자연스러운 동작을 생성하고, 시스템 2의 트리 탐색은 논리적이고 안전한 의사결정을 보장한다. 이러한 하이브리드 접근법은 거대 모델의 환각(Hallucination) 문제를 제어하고, 물리적 제약 조건을 준수해야 하는 임바디드 AI 분야에서 표준적인 아키텍처로 자리 잡을 가능성이 높다.</p>
<h3>6.3  안전 필수(Safety-Critical) 시스템으로의 확장</h3>
<p>오프라인 데이터만을 사용하여 안전하게 정책을 학습하고, 실행 전에 위험을 시뮬레이션(트리 탐색)하여 배제하는 VINE의 방식은 산업용 로봇이나 자율주행차와 같이 안전이 최우선시되는 분야에 큰 시사점을 준다. 실세계에서의 시행착오는 비용이 크고 위험하지만, VINE과 같은 모델은 가상의 사고 과정을 통해 수천 번의 실패를 미리 경험하고, 실제 세계에서는 검증된 안전한 행동만을 수행할 수 있게 한다.</p>
<h2>7.  결론</h2>
<p>본 보고서는 실패 경험을 학습의 핵심 동력으로 삼는 계층적 시각-언어-행동 모델 VINE을 심층 분석했다. VINE은 2D 장면 그래프를 통한 상태 추상화, 시스템 1과 시스템 2의 이중 구조, 그리고 실패 데이터를 활용한 비대칭 가치 함수 학습을 통해 기존 VLA 모델의 한계를 극복했다.</p>
<p>실험 결과, VINE은 플러그 삽입, 스펀지 포장 등 고난도 조작 작업에서 SOTA 모델들을 능가하는 성능을 보였으며, 특히 미지의 환경에서의 강건성이 획기적으로 향상되었다. 이는 “성공은 길을 보여주지만, 실패는 경계를 보여준다“는 직관을 공학적으로 완벽하게 구현해낸 결과라 할 수 있다.</p>
<p>VINE은 로봇이 단순히 인간의 행동을 흉내 내는 것을 넘어, 자신의 행동이 초래할 결과를 예측하고, 위험을 스스로 회피하는 진정한 의미의 ’지능형 에이전트’로 진화하는 중요한 이정표를 제시했다. 향후 연구에서는 이러한 프레임워크가 더 다양한 로봇 플랫폼과 더 복잡한 사회적 상호작용 환경으로 확장되어, 인간과 안전하게 공존하는 로봇 기술의 토대가 되기를 기대한다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Hierarchical Vision Language Action Model Using Success and Failure Demonstrations, https://arxiv.org/html/2512.03913v1</li>
<li>[Literature Review] Hierarchical Vision Language Action Model …, https://www.themoonlight.io/en/review/hierarchical-vision-language-action-model-using-success-and-failure-demonstrations</li>
<li>Hierarchical Vision Language Action Model Using Success and …, https://chatpaper.com/paper/215821</li>
<li>[2512.03913] Hierarchical Vision Language Action Model Using Success and Failure Demonstrations - arXiv, https://www.arxiv.org/abs/2512.03913</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>