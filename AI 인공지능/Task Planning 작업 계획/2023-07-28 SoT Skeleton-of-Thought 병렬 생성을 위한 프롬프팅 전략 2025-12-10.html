<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:SoT Skeleton-of-Thought 병렬 생성을 위한 프롬프팅 전략 (2023-07-28)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>SoT Skeleton-of-Thought 병렬 생성을 위한 프롬프팅 전략 (2023-07-28)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">작업 계획 (Task Planning)</a> / <span>SoT Skeleton-of-Thought 병렬 생성을 위한 프롬프팅 전략 (2023-07-28)</span></nav>
                </div>
            </header>
            <article>
                <h1>SoT Skeleton-of-Thought 병렬 생성을 위한 프롬프팅 전략 (2023-07-28)</h1>
<p>2025-12-10, G30DR</p>
<h2>1.  서론: 대규모 언어 모델의 추론 지연과 효율성 난제</h2>
<h3>1.1  현대 AI 시스템의 병목 현상: 순차적 디코딩의 한계</h3>
<p>최근 몇 년간 인공지능 분야는 대규모 언어 모델(Large Language Models, LLM)의 비약적인 발전을 목격했다. GPT-4, Claude, LLaMA와 같은 모델들은 인간 수준의 텍스트 생성 능력을 보여주며 다양한 산업 분야에 혁신을 가져왔다. 그러나 이러한 모델들이 실시간 챗봇, 코파일럿, 자율 에이전트 등 실제 애플리케이션에 통합될 때 가장 치명적인 문제로 대두되는 것이 바로 ’추론 지연(Inference Latency)’이다.1</p>
<p>현재 최신 LLM의 표준 아키텍처인 트랜스포머(Transformer)는 텍스트를 생성할 때 본질적으로 순차적(Sequential)인 방식을 따른다. 이를 자기회귀적 디코딩(Auto-regressive Decoding)이라 한다. 이 방식에서 모델은 시점 <span class="math math-inline">t</span>의 토큰을 생성하기 위해 시점 <span class="math math-inline">1</span>부터 <span class="math math-inline">t-1</span>까지의 모든 이전 토큰을 참조해야 한다. 즉, <span class="math math-inline">N</span>개의 토큰으로 구성된 문장을 생성하기 위해서는 모델의 가중치(Weight) 전체를 <span class="math math-inline">N</span>번 메모리에서 연산 장치(GPU 코어 등)로 로드해야 한다.3</p>
<p>이러한 순차적 처리 방식은 하드웨어 관점에서 매우 비효율적이다. 현대의 GPU(예: NVIDIA A100, H100)는 대규모 병렬 연산에 최적화되어 있으나, 한 번에 하나의 토큰만 생성하는 디코딩 단계에서는 GPU의 연산 능력(Compute Capability)보다는 메모리 대역폭(Memory Bandwidth)이 병목이 되는 ‘메모리 바운드(Memory-bound)’ 상태에 빠지게 된다.2 결과적으로, 생성해야 할 텍스트의 길이가 길어질수록 사용자가 체감하는 대기 시간(Latency)은 선형적으로 증가하며, 하드웨어 자원은 유휴 상태(Idle)로 낭비되는 이중고를 겪게 된다.</p>
<h3>1.2  기존 가속화 접근법의 한계와 새로운 패러다임의 필요성</h3>
<p>이러한 문제를 해결하기 위해 학계와 산업계는 다양한 가속화 기술을 연구해 왔다. 대표적으로 모델의 크기를 줄이는 양자화(Quantization) 및 가지치기(Pruning), 더 작은 모델이 토큰을 예측하고 큰 모델이 검증하는 추측 디코딩(Speculative Decoding), 그리고 하드웨어 수준의 최적화 등이 있다.1</p>
<p>하지만 이러한 ‘모델 중심(Model-centric)’ 또는 ‘시스템 중심(System-centric)’ 접근법은 명확한 한계를 지닌다.</p>
<ol>
<li><strong>배포의 어려움:</strong> 모델 아키텍처를 수정하거나 가중치를 재학습해야 하므로, 이미 배포된 상용 모델이나 API 형태로만 접근 가능한 ‘블랙박스(Black-box)’ 모델(예: GPT-4)에는 적용하기 어렵다.1</li>
<li><strong>구현 복잡성:</strong> 추측 디코딩과 같은 기법은 별도의 초안 모델(Draft Model)을 유지 관리해야 하므로 시스템 복잡도가 증가한다.5</li>
</ol>
<p>이러한 배경에서 Microsoft Research와 칭화대학교 연구진이 제안한 **“Skeleton-of-Thought (SoT)”**는 기존의 기술적 난제를 우회하는 획기적인 접근법을 제시한다. SoT는 모델 내부나 하드웨어를 건드리지 않고, 오직 입력 데이터(프롬프트)의 구조를 변경함으로써 LLM의 생성 프로세스를 혁신한다. 이는 ’데이터 중심 효율성 최적화(Data-centric Efficiency Optimization)’라는 새로운 영역을 개척한 시도로 평가받는다.2</p>
<h3>1.3  인간 인지 과정의 모방: 구조적 사고와 병렬 집필</h3>
<p>SoT의 핵심 아이디어는 인간이 복잡한 질문에 답하거나 긴 글을 쓸 때의 사고방식에서 영감을 받았다. 숙련된 인간 작가나 전문가는 첫 문장부터 끝 문장까지 순서대로 글을 쓰지 않는다. 대신 먼저 전체적인 개요(Skeleton)를 구상하여 핵심 논점을 정리한 뒤, 각 논점의 세부 내용을 독립적으로 확장하여 글을 완성한다.2</p>
<p>이러한 인간의 ‘기획 후 집필’ 프로세스를 LLM에 적용하면, 순차적 디코딩의 제약을 깨고 병렬 생성(Parallel Generation)이 가능해진다. 뼈대가 완성되면 각 뼈대에 해당하는 살을 붙이는 작업은 서로 독립적인 작업이 되므로, 동시에 수행할 수 있기 때문이다. 본 보고서는 SoT 방법론의 메커니즘, 성능, 한계, 그리고 미래의 가능성을 심층적으로 분석한다.</p>
<h2>2.  Skeleton-of-Thought (SoT) 방법론의 심층 분석</h2>
<p>SoT 프레임워크는 LLM의 생성 과정을 단일 패스에서 ’스켈레톤 단계(Skeleton Stage)’와 ’포인트 확장 단계(Point-Expanding Stage)’라는 2단계 파이프라인으로 재구성한다. 이 단순한 구조적 변화가 어떻게 극적인 속도 향상을 이끌어내는지 상세히 살펴본다.</p>
<h3>2.1  1단계: 스켈레톤 생성 (The Skeleton Stage) - 전략적 기획</h3>
<p>첫 번째 단계는 LLM에게 답변의 상세 내용을 생성하지 말고, 답변의 골격이 되는 핵심 포인트만을 나열하도록 지시하는 과정이다. 이 단계의 성공 여부는 얼마나 간결하고 명확한 뼈대를 추출하느냐에 달려 있다.</p>
<h4>2.1.1  프롬프트 엔지니어링의 정교함</h4>
<p>연구진은 LLM이 불필요한 서론이나 장황한 설명을 배제하고 구조화된 데이터만을 출력하도록 매우 구체적인 프롬프트 템플릿을 설계했다.3</p>
<blockquote>
<hr />
<p>“You’re an organizer responsible for only giving the skeleton (not the full content)…”</p>
<ol>
<li><strong>페르소나 부여 (Organizer):</strong> 모델에게 ’답변자’가 아닌 ’조직자’라는 역할을 부여함으로써 상세 내용 생성 욕구를 억제한다.</li>
<li><strong>형식 제약 (Numbered List):</strong> “1., 2., 3.” 형태의 리스트 포맷을 강제하여 후속 단계에서 정규표현식(Regex) 등을 이용해 각 포인트를 쉽게 파싱(Parsing)할 수 있도록 한다.</li>
<li><strong>길이 제약 (Strict Constraints):</strong> “3~5 words”, “3~10 points“와 같이 매우 구체적인 수치 제약을 둔다. 이는 스켈레톤 생성 자체가 또 다른 지연 시간이 되는 것을 방지하기 위함이다.3</li>
</ol>
</blockquote>
<p>예를 들어, “탄소 배출을 줄이는 개인적인 방법은?“이라는 질문에 대해 LLM은 다음과 같은 뼈대를 생성한다.</p>
<ul>
<li>
<ol>
<li>대중교통 및 카풀 이용</li>
</ol>
</li>
<li>
<ol>
<li>에너지 효율 높은 가전제품 사용</li>
</ol>
</li>
<li>
<ol>
<li>육류 소비 줄이기 및 식단 조절</li>
</ol>
</li>
<li>
<ol>
<li>재활용 및 폐기물 감소 실천</li>
</ol>
</li>
</ul>
<p>이 과정은 매우 짧은 토큰 수만을 생성하므로 순차적 디코딩으로 수행되더라도 전체 지연 시간에 미치는 영향은 미미하다.</p>
<h3>2.2  2단계: 포인트 확장 (The Point-Expanding Stage) - 병렬 실행</h3>
<p>SoT의 핵심 가치는 이 두 번째 단계에서 발현된다. 1단계에서 생성된 <span class="math math-inline">B</span>개의 포인트는 각각 독립적인 쿼리로 변환되어 LLM에 입력된다.</p>
<h4>2.2.1  포인트 확장 프롬프트의 구조</h4>
<p>각 포인트를 확장하기 위한 프롬프트는 문맥(Context)을 유지하면서도 독립성을 확보해야 하는 이중적인 목표를 가진다.3</p>
<blockquote>
<p>“You’re responsible for continuing the writing of one and only one point… The skeleton of the answer is {skeleton}… Continue and only continue the writing of point {point index}…”</p>
</blockquote>
<ul>
<li><strong>문맥 주입:</strong> 전체 질문과 전체 스켈레톤을 프롬프트에 포함시킴으로써, LLM이 현재 확장해야 할 포인트가 전체 논리 구조에서 어떤 위치를 차지하는지 인지하게 한다. 이는 답변의 일관성을 유지하는 데 필수적이다.</li>
<li><strong>범위 제한:</strong> “only continue point {index}”, “Write it very shortly in 1~2 sentence” 등의 강력한 제약을 통해 모델이 다른 포인트의 내용을 침범하거나 불필요하게 길어지는 것을 방지한다.2</li>
</ul>
<h4>2.2.2  병렬 처리의 기술적 구현 (API vs. Local GPU)</h4>
<p>포인트 확장 단계는 실행 환경에 따라 두 가지 상이한 방식으로 병렬화를 달성한다.3</p>
<table><thead><tr><th><strong>실행 환경</strong></th><th><strong>병렬화 메커니즘</strong></th><th><strong>상세 기술 분석</strong></th></tr></thead><tbody>
<tr><td><strong>오픈소스 모델 (Local GPU)</strong></td><td><strong>배치 디코딩 (Batched Decoding)</strong></td><td>가장 효율적인 방식이다. <span class="math math-inline">B</span>개의 확장 프롬프트를 하나의 배치(Batch)로 묶어 GPU에 전송한다. GPU는 수천 개의 코어를 가진 병렬 프로세서이므로, 배치 크기가 커져도 처리 시간은 선형적으로 증가하지 않는다. 즉, 1개의 문장을 생성하는 시간과 <span class="math math-inline">B</span>개의 문장을 생성하는 시간이 거의 비슷하다(메모리 대역폭이 허용하는 한). 이는 하드웨어 활용률(Utilization)을 극대화한다.</td></tr>
<tr><td><strong>API 기반 모델 (GPT-4 등)</strong></td><td><strong>비동기 API 호출 (Async Calls)</strong></td><td>클라이언트 측에서 여러 개의 API 요청을 동시에(Concurrent) 발송한다. 서버 측의 인프라가 충분하다면 이 요청들은 서로 다른 인스턴스에서 병렬로 처리된다. 사용자는 가장 늦게 도착하는 응답 시간만큼만 기다리면 된다. 단, API 호출 수 증가에 따른 비용 문제가 발생할 수 있다.2</td></tr>
</tbody></table>
<h3>2.3  최종 통합 (Aggregation)</h3>
<p>모든 포인트에 대한 확장이 완료되면, 시스템은 각 부분 답변을 원래의 순서대로 결합(Concatenation)하여 최종 답변을 생성한다. 이 과정은 단순한 문자열 결합이므로 연산 비용이 거의 없다.2</p>
<h2>3.  이론적 성능 분석: 왜 SoT는 빠른가?</h2>
<p>SoT의 성능 향상을 이해하기 위해서는 LLM 추론의 시간 복잡도와 하드웨어 특성을 분석해야 한다.</p>
<h3>3.1  Amdahl의 법칙과 SoT의 가속비</h3>
<p>전체 작업 중 병렬화가 가능한 부분의 비율이 전체 성능 향상을 결정한다는 암달의 법칙(Amdahl’s Law)을 적용해보자. 기존 순차 생성 방식의 총 소요 시간을 <span class="math math-inline">T_{seq}</span>라고 할 때, 이는 생성해야 할 총 토큰 수 <span class="math math-inline">N</span>에 비례한다.</p>
<p>SoT 방식의 소요 시간 <span class="math math-inline">T_{SoT}</span>는 다음과 같이 구성된다:<br />
<span class="math math-display">
T_{SoT} = T_{skel} + T_{expand\_max} + T_{overhead}
</span></p>
<ul>
<li><span class="math math-inline">T_{skel}</span>: 스켈레톤을 생성하는 시간 (순차적이지만 매우 짧음).</li>
<li><span class="math math-inline">T_{expand\_max}</span>: 병렬로 실행된 확장 작업 중 가장 오래 걸리는 작업의 시간. 이상적인 경우 <span class="math math-inline">T_{seq} / B</span> (여기서 <span class="math math-inline">B</span>는 포인트 개수).</li>
<li><span class="math math-inline">T_{overhead}</span>: 프롬프트 처리(Prefilling) 증가 및 시스템 오버헤드.</li>
</ul>
<p>일반적으로 <span class="math math-inline">T_{expand_max}</span>는 <span class="math math-inline">T_{seq}</span>에 비해 훨씬 작다. 예를 들어, 1000 토큰짜리 답변을 생성할 때, 순차 방식은 1000번의 디코딩 스텝이 필요하지만, SoT가 이를 5개의 포인트(각 200토큰)로 나누어 병렬 처리한다면, 이론적으로 사용자 대기 시간은 약 200 토큰 생성 시간 + 알파로 줄어든다. 이는 최대 <span class="math math-inline">B</span>배에 가까운 가속을 의미한다.7</p>
<h3>3.2  지연 시간 분해 (Latency Breakdown): 프리필 대 디코딩</h3>
<p>LLM 추론은 ‘프리필(Prefilling)’ 단계와 ‘디코딩(Decoding)’ 단계로 나뉜다.</p>
<ul>
<li><strong>프리필 단계:</strong> 입력된 프롬프트를 한 번에 처리하여 KV Cache(Key-Value Cache)를 생성한다. 이 단계는 병렬 연산이 가능하여 GPU 효율이 매우 높다.</li>
<li><strong>디코딩 단계:</strong> 토큰을 하나씩 생성하며 KV Cache를 갱신한다. 이 단계는 메모리 대역폭에 의존하며 매우 느리다.</li>
</ul>
<p>SoT는 포인트 확장 단계에서 각 포인트마다 긴 프롬프트(질문+스켈레톤)를 입력해야 하므로 ‘프리필’ 연산량은 기존 방식보다 증가한다. 그러나 프리필은 GPU에서 매우 빠르게 처리되므로 전체 지연 시간에 미치는 영향은 적다. 반면, 가장 느린 ‘디코딩’ 단계의 횟수(순차적 루프의 길이)를 획기적으로 줄임으로써 전체적인 지연 시간을 단축한다.3</p>
<h2>4.  실증적 성능 평가 및 데이터 분석</h2>
<p>연구진은 Vicuna-80 및 WizardLM 벤치마크를 활용하여 12개의 최신 LLM(9개의 오픈소스, 3개의 API 기반)에 대해 SoT의 성능을 광범위하게 검증했다.1</p>
<h3>4.1  가속도(Speed-up) 측정 결과</h3>
<p>실험 결과는 SoT가 다양한 모델 아키텍처와 크기에 걸쳐 일관된 성능 향상을 제공함을 보여준다.</p>
<table><thead><tr><th><strong>모델 유형</strong></th><th><strong>모델명</strong></th><th><strong>가속비 (Speed-up)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>API 모델</strong></td><td>GPT-4</td><td><strong>~2.00x</strong></td><td>병렬 API 호출 효과 1</td></tr>
<tr><td></td><td>GPT-3.5</td><td><strong>~2.00x</strong></td><td></td></tr>
<tr><td></td><td>Claude</td><td><strong>&gt;1.50x</strong></td><td></td></tr>
<tr><td><strong>오픈소스 (Local)</strong></td><td>LLaMA-2-7b</td><td><strong>최대 3.72x</strong></td><td>배치 디코딩 최적화 시 극적인 효과 7</td></tr>
<tr><td></td><td>Vicuna-33B</td><td><strong>&gt;2.00x</strong></td><td>대형 모델에서도 유효함 7</td></tr>
<tr><td></td><td>StableVicuna-13B</td><td><strong>미미함 (~1.0x)</strong></td><td>지시사항 불이행(Instruction Following 실패)으로 인한 성능 저하 11</td></tr>
</tbody></table>
<ul>
<li><strong>종합 분석:</strong> 테스트된 12개 모델 중 8개 모델에서 2배 이상의 속도 향상을 기록했다.7 가속비의 범위는 1.13배에서 2.39배에 이르며, 이는 사용자 경험(UX) 측면에서 대기 시간을 절반 이하로 줄이는 획기적인 결과다.</li>
<li><strong>실패 사례 분석:</strong> StableVicuna-13B의 경우, “짧게 답하라“는 제약 조건을 무시하고 스켈레톤 포인트를 과도하게 많이 생성하거나 각 포인트를 길게 작성하는 경향을 보였다. 이는 SoT가 모델의 지시 따르기(Instruction Following) 능력에 의존함을 시사한다.11</li>
</ul>
<h3>4.2  답변 품질(Quality) 평가: 속도와 품질의 트레이드오프</h3>
<p>속도가 빨라져도 답변 품질이 훼손된다면 의미가 없다. 연구진은 GPT-4를 심판(Judge)으로 사용하여 기존 순차 생성 답변과 SoT 답변을 블라인드 비교했다.</p>
<h4>4.2.1  승률 분석 (Win/Tie/Lose Rate)</h4>
<ul>
<li><strong>종합 평가:</strong> 약 60% 이상의 케이스에서 SoT의 답변이 기존 방식보다 좋거나 대등한 품질을 보였다.7</li>
<li><strong>FastChat 메트릭:</strong> SoT 승(29.5%) + 무승부(29.3%) = 58.8%</li>
<li><strong>LLMZoo 메트릭:</strong> SoT 승(45.8%) + 무승부(19.6%) = 65.4%</li>
</ul>
<h4>4.2.2  품질의 4차원 분석</h4>
<p>품질을 세부 지표별로 분해해 보면 SoT의 특성이 명확히 드러난다.</p>
<ol>
<li><strong>다양성(Diversity) - 향상:</strong> SoT는 스켈레톤 단계에서 답변의 전체 구조를 미리 계획하므로, 다양한 관점을 포괄하는 답변을 생성하는 경향이 있다. 순차 생성 모델이 초반의 문맥에 갇혀 한 방향으로만 서술하는 것과 대조적이다.</li>
<li><strong>관련성(Relevance) - 향상:</strong> “핵심 포인트“를 먼저 정의하고 확장하기 때문에, 질문의 요지에서 벗어난 잡담(Hallucination or Chitchat)이 줄어들고 주제 집중도가 높아진다.</li>
<li><strong>일관성(Coherence) - 하락 가능성:</strong> 각 포인트가 독립적으로 생성되므로, 문단 간의 연결이 부자연스럽거나 앞뒤 문맥이 매끄럽게 이어지지 않는 경우가 발생한다. 이는 SoT의 구조적 한계점이다.</li>
<li><strong>몰입감(Immersion) - 하락 가능성:</strong> 기계적인 리스트 형식의 답변이 주를 이루다 보니, 인간적인 어조나 흐름(Flow)이 부족할 수 있다.</li>
</ol>
<h3>4.3  카테고리별 적합성 분석 (Vicuna-80 Breakdown)</h3>
<p>Vicuna-80 데이터셋의 9개 카테고리에 대한 분석 결과, SoT의 적용 성패는 질문의 유형에 따라 극명하게 갈렸다.2</p>
<table><thead><tr><th><strong>카테고리</strong></th><th><strong>적합성</strong></th><th><strong>분석</strong></th></tr></thead><tbody>
<tr><td><strong>지식 설명 / 일반 (Generic)</strong></td><td><strong>매우 높음</strong></td><td>“마케팅 전략 5가지를 알려줘“와 같이 항목별 나열이 자연스러운 질문에서 최고의 성능을 발휘한다.</td></tr>
<tr><td><strong>요약 / 작문 (Writing)</strong></td><td><strong>보통</strong></td><td>전체적인 개요 잡기에는 유리하나, 글의 유기적인 흐름이 중요한 에세이 등에서는 품질이 떨어질 수 있다.</td></tr>
<tr><td><strong>수학 (Math)</strong></td><td><strong>매우 낮음</strong></td><td><span class="math math-inline">A</span>를 구해야 <span class="math math-inline">B</span>를 구할 수 있는 단계적 추론(Step-by-step Reasoning) 문제에서 SoT는 실패한다. 병렬 처리는 이전 단계의 결과를 참조할 수 없기 때문이다.10</td></tr>
<tr><td><strong>코딩 (Coding)</strong></td><td><strong>매우 낮음</strong></td><td>변수 정의, 라이브러리 임포트 등 상위 코드의 의존성이 하위 코드에 필수적이다. SoT로 코드를 분할 생성하면 실행 불가능한 코드가 나올 확률이 높다.4</td></tr>
</tbody></table>
<h2>5.  한계 극복을 위한 진화: SoT-R (SoT with Router)</h2>
<p>SoT가 수학이나 코딩 문제에서 취약하다는 점은 범용 시스템으로서의 치명적인 약점이 될 수 있다. 이를 보완하기 위해 연구진은 <strong>SoT-R (SoT with Router)</strong> 아키텍처를 제안했다.7</p>
<h3>5.1  적응형 라우팅(Adaptive Routing) 메커니즘</h3>
<p>SoT-R은 모든 질문을 무조건 SoT로 처리하는 대신, ’라우터(Router)’라는 판단 모듈을 앞단에 배치한다.</p>
<ol>
<li><strong>입력 분석:</strong> 사용자의 질문이 들어오면 라우터가 이를 분석한다.</li>
<li><strong>경로 선택:</strong></li>
</ol>
<ul>
<li>질문이 병렬 구조화에 적합하다면(예: 설명, 리스트, 브레인스토밍) -&gt; <strong>SoT 모드</strong>로 분기.</li>
<li>질문이 순차적 논리가 필요하다면(예: 수학 풀이, 코드 작성) -&gt; <strong>일반 순차 디코딩</strong>으로 분기.</li>
</ul>
<h3>5.2  라우터 구현 전략 비교</h3>
<p>연구진은 라우터를 구현하는 두 가지 방법을 제시하고 비교했다.</p>
<ul>
<li><strong>프롬프팅 라우터 (Prompting Router):</strong> LLM(예: GPT-4)에게 “이 질문이 스켈레톤 생성에 적합한가?“라고 묻는 프롬프트를 사용한다. 별도의 학습이 필요 없어 구현이 간편하지만, 라우팅 자체에 비용과 시간이 소요된다.</li>
<li><strong>학습된 라우터 (Trained Router):</strong> RoBERTa와 같은 소형 언어 모델(BERT 계열)을 이진 분류기(Binary Classifier)로 학습시킨다. LIMA 데이터셋 등으로 훈련시켰으며, 연산 비용이 매우 낮고 빠르다.</li>
</ul>
<h3>5.3  SoT-R의 성능</h3>
<p>실험 결과, SoT-R은 수학/코딩 문제에서의 품질 저하를 완벽하게 방어하면서도, 전체적인 시스템의 평균 속도 향상을 유지했다. 라우팅 오버헤드와 순차 디코딩으로의 전환(Fallback) 때문에 순수 SoT보다는 평균 가속비가 낮아지지만, 여전히 대부분의 모델에서 1배 이상의 유의미한 속도 향상을 기록했다.4 흥미로운 점은 데이터셋에 따라 학습된 라우터가 더 나을 수도, 프롬프팅 라우터가 더 나을 수도 있다는 점인데, 이는 라우터의 정확도가 전체 시스템 효율성에 미치는 민감도를 보여준다.14</p>
<h2>6.  비교 분석 및 학술적 논의</h2>
<h3>6.1  SoT 대 추측 디코딩 (Speculative Decoding)</h3>
<p>SoT는 종종 추측 디코딩과 비교되지만, 두 기술은 근본적으로 다른 계층(Layer)에서 작동한다.5</p>
<ul>
<li><strong>추측 디코딩 (Micro-level):</strong> “다음 토큰은 무엇인가?“에 집중한다. 작고 빠른 모델(Draft Model)이 토큰열을 미리 예측하고, 큰 모델이 이를 검증한다. 확률론적 접근이며, 모델 아키텍처에 대한 깊은 이해와 시스템 통합이 필요하다.</li>
<li><strong>SoT (Macro-level):</strong> “답변의 내용은 무엇인가?“에 집중한다. 답변의 의미적 구조(Semantic Structure)를 파악하여 병렬화한다. 블랙박스 모델에도 적용 가능한 프롬프트 기반 접근이다.</li>
</ul>
<p><strong>통찰(Insight):</strong> 이 두 기술은 상호 배타적이지 않다. 즉, SoT로 나눈 각 포인트를 확장할 때 추측 디코딩을 적용한다면, ’구조적 병렬화’와 ’토큰 수준 가속’의 이점을 동시에 누리는 하이브리드 가속이 가능할 것이다.1</p>
<h3>6.2  데이터 중심 효율화의 의의</h3>
<p>기존의 AI 효율화 연구가 ‘어떻게 모델을 작게 만들까’ 또는 ’어떻게 하드웨어를 쥐어짤까’에 집중했다면, SoT는 ’어떻게 모델에게 일을 효율적으로 시킬까’라는 질문을 던졌다. 이는 LLM의 능력이 고도화될수록 모델 스스로 자신의 작업을 최적화할 수 있는 메타 인지적(Meta-cognitive) 능력을 활용할 수 있음을 시사한다.7</p>
<h3>6.3  비용과 에너지 효율성 (Cost &amp; Energy)</h3>
<p>SoT는 사용자 대기 시간을 줄여주지만, 총 연산량(Total Compute)은 증가시킨다. 스켈레톤 생성과 반복되는 프롬프트 입력으로 인해 처리해야 할 총 토큰 수는 늘어나기 때문이다.</p>
<ul>
<li><strong>API 비용:</strong> 입력 토큰 당 과금하는 API 모델 사용 시 비용이 증가할 수 있다.2</li>
<li><strong>에너지:</strong> GPU가 유휴 상태일 때 소모하는 전력을 고려하면, 배치 처리를 통해 단시간에 GPU를 풀로 가동하고 빨리 끝내는 것이 에너지 효율 면에서 더 나을 수도 있다. 이는 시스템의 전력 프로파일에 따라 달라질 수 있는 복잡한 문제다.</li>
</ul>
<h2>7.  결론 및 미래 전망</h2>
<h3>7.1  연구 요약</h3>
<p>Skeleton-of-Thought(SoT)는 인간의 사고 과정을 모방하여 LLM의 본질적인 순차성을 극복한 혁신적인 프롬프팅 기법이다. 최대 2.39배의 속도 향상과 함께 다양성과 관련성이 향상된 답변을 제공하며, 특히 모델 수정 없이 즉시 적용 가능하다는 실용성이 돋보인다. 수학 및 코딩 분야의 약점은 SoT-R과 같은 적응형 시스템을 통해 효과적으로 보완될 수 있다.</p>
<h3>7.2  향후 연구 방향</h3>
<ol>
<li><strong>그래프 사고(Graph-of-Thought)로의 확장:</strong> 현재의 선형적 리스트 구조를 넘어, 포인트 간의 의존성을 그래프 형태로 정의하고 병렬화 가능한 부분만 위상 정렬(Topological Sort)하여 실행하는 더욱 정교한 구조화가 가능할 것이다.7</li>
<li><strong>에이전트 워크플로우의 표준:</strong> 미래의 AI 에이전트는 복잡한 작업을 받으면 스스로 이를 하위 작업(Sub-tasks)으로 분해하고, 여러 개의 모델 인스턴스를 병렬로 띄워 작업을 수행한 뒤 통합하는 ‘관리자(Manager)’ 역할을 수행하게 될 것이다. SoT는 이러한 에이전트적 작업 방식의 시초(Proto-type)로 볼 수 있다.</li>
<li><strong>학습을 통한 내재화:</strong> 프롬프팅에 의존하는 대신, 모델 자체가 훈련 단계에서부터 “먼저 계획하고 병렬로 생성하는” 방식을 학습한다면, 프롬프트 오버헤드 없이도 SoT의 이점을 내재화한 차세대 아키텍처가 등장할 수 있다.1</li>
</ol>
<p>결론적으로 SoT는 단순한 속도 개선 기술을 넘어, 거대 언어 모델을 다루는 방식 자체를 ’순차적 생성’에서 ’구조적 기획 및 병렬 생산’으로 전환하는 패러다임 시프트를 제시했다. 이는 향후 등장할 초거대 모델들의 효율적인 활용을 위한 필수적인 운영 원리로 자리 잡을 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Skeleton-of-Thought: Prompting LLMs for Efficient Parallel Generation | OpenReview, https://openreview.net/forum?id=mqVgBbNCm9</li>
<li>Skeleton-of-Thought - Google Sites, https://sites.google.com/view/sot-llm</li>
<li>Skeleton-of-Thought: Prompting LLMs for Efficient Parallel Generation, https://iclr.cc/media/iclr-2024/Slides/17880.pdf</li>
<li>Skeleton-of-Thought: Prompting LLMs for Efficient Parallel Generation - arXiv, https://arxiv.org/html/2307.15337v3</li>
<li>Chain of Draft: Thinking Faster by Writing Less - arXiv, https://arxiv.org/html/2502.18600v2</li>
<li>Speeding up LLM inference with parallelism - MIT CSAIL, https://www.csail.mit.edu/news/speeding-llm-inference-parallelism</li>
<li>Skeleton-of-Thought: Parallel decoding speeds up and improves LLM output - Microsoft, https://www.microsoft.com/en-us/research/blog/skeleton-of-thought-parallel-decoding-speeds-up-and-improves-llm-output/</li>
<li>[2307.15337] Skeleton-of-Thought: Prompting LLMs for Efficient Parallel Generation - arXiv, https://arxiv.org/abs/2307.15337</li>
<li>Skeleton-of-Thought Prompting: Faster and Efficient Response Generation, https://learnprompting.org/docs/advanced/decomposition/skeleton_of_thoughts</li>
<li>Reducing Latency with Skeleton of Thought Prompting - PromptHub, https://www.prompthub.us/blog/reducing-latency-with-skeleton-of-thought-prompting</li>
<li>Paper Review: Skeleton-of-Thought: Large Language Models Can Do Parallel Decoding, https://artgor.medium.com/paper-review-skeleton-of-thought-large-language-models-can-do-parallel-decoding-a86b4e249e83</li>
<li>SKELETON-OF-THOUGHT: PROMPTING LLMS FOR EFFICIENT PARALLEL GENERATION - NICS-EFC, https://nicsefc.ee.tsinghua.edu.cn/%2Fnics_file%2Fpdf%2F22c6dabe-eabc-4811-80e7-85a56800397d.pdf</li>
<li>Aman’s AI Journal • Primers • Prompt Engineering, https://aman.ai/primers/ai/prompt-engineering/</li>
<li>12월 10, 2025에 액세스, <a href="https://arxiv.org/html/2307.15337v3#:~:text=(2)%20SoT-R%20with,%20%5Bhttps://arxiv.org/html/2307.15337v3#:~:text=(2)%20SoT%2DR%20with,17">https://arxiv.org/html/2307.15337v3#:~:text=(2)%20SoT%2DR%20with,17).</a>.](https://arxiv.org/html/2307.15337v3#:~:text=(2)%20SoT-R%20with,17).)</li>
<li>Accelerating LLMs with Skeleton-of-Thought Prompting - Portkey, https://portkey.ai/blog/skeleton-of-thought-prompting/</li>
<li>Plato: Plan to Efficiently Decode for Large Language Model Inference - arXiv, https://arxiv.org/html/2402.12280v2</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>