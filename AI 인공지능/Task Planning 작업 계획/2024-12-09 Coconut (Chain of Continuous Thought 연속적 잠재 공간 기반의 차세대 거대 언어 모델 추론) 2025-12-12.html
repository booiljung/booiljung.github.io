<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Coconut (Chain of Continuous Thought, 연속적 잠재 공간 기반의 차세대 거대 언어 모델 추론, 2024-12-09)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Coconut (Chain of Continuous Thought, 연속적 잠재 공간 기반의 차세대 거대 언어 모델 추론, 2024-12-09)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">작업 계획 (Task Planning)</a> / <span>Coconut (Chain of Continuous Thought, 연속적 잠재 공간 기반의 차세대 거대 언어 모델 추론, 2024-12-09)</span></nav>
                </div>
            </header>
            <article>
                <h1>Coconut (Chain of Continuous Thought, 연속적 잠재 공간 기반의 차세대 거대 언어 모델 추론, 2024-12-09)</h1>
<p>2025-12-12, G30DR</p>
<h2>1.  서론: 언어적 사고의 한계와 잠재적 추론의 여명</h2>
<h3>1.1  거대 언어 모델의 현주소와 추론의 병목 현상</h3>
<p>인공지능 연구의 역사는 기계에게 인간의 지능을 이식하려는 시도의 연속이었다. 최근 몇 년간 트랜스포머(Transformer) 아키텍처를 기반으로 한 거대 언어 모델(Large Language Models, LLM)의 비약적인 발전은 이러한 목표에 한 걸음 다가선 듯한 인상을 주었다. 특히 GPT-4, Claude, Gemini와 같은 모델들은 방대한 텍스트 데이터를 학습하여 인간 수준의 유창한 텍스트를 생성하고, 복잡한 지시사항을 이행하며, 심지어 코드를 작성하거나 수학 문제를 해결하는 능력을 보여주었다. 이러한 성취의 중심에는 ’다음 토큰 예측(Next Token Prediction)’이라는 단순하지만 강력한 학습 목표가 자리 잡고 있다. 모델은 주어진 문맥(Context)을 바탕으로 통계적으로 가장 개연성 높은 다음 단어(Token)를 예측함으로써 언어의 구문론적, 의미론적 구조를 습득한다.</p>
<p>그러나 모델의 규모가 커지고 다루는 문제의 난이도가 높아짐에 따라, 기존의 패러다임이 가진 근본적인 한계가 드러나기 시작했다. 가장 두드러진 문제는 바로 ’언어 공간(Language Space)’이라는 제약이다. 인간은 언어를 통해 소통하지만, 사고의 과정 전체가 반드시 언어로 이루어지는 것은 아니다. 우리는 직관, 이미지, 혹은 형용할 수 없는 추상적인 개념의 조작을 통해 복잡한 문제를 해결하기도 한다. 반면, 현재의 LLM은 모든 사고 과정을 ’언어 토큰’이라는 이산적(Discrete) 심볼로 구체화해야만 한다.</p>
<h3>1.2  생각의 사슬(Chain-of-Thought)과 그 한계</h3>
<p>Wei et al. (2022)이 제안한 ‘생각의 사슬(Chain-of-Thought, CoT)’ 프롬프팅은 이러한 언어 모델의 추론 능력을 획기적으로 향상시킨 기법이다. 모델에게 “정답을 바로 말하라“고 하는 대신, “단계별로 생각하라(Let’s think step by step)“고 지시함으로써, 모델은 중간 추론 과정을 텍스트로 생성하게 된다. 이는 복잡한 문제를 하위 문제로 분해하고, 논리적 연결 고리를 강화하여 정답률을 높이는 데 크게 기여했다.</p>
<p>하지만 CoT 역시 언어 공간의 제약에서 자유롭지 못하다. 첫째, **조기 확정(Premature Commitment)**의 문제다. 모델이 추론의 첫 단계에서 특정 단어를 선택하여 내뱉는 순간, 그 이후의 모든 가능성은 해당 단어가 형성한 문맥 안에 갇히게 된다. 만약 첫 단추가 잘못 끼워졌다면, 모델은 스스로 오류를 수정하기보다는 그 오류를 정당화하는 방향으로(Hallucination) 추론을 이어갈 확률이 높다.1 둘째, <strong>정보의 병목(Information Bottleneck)</strong> 현상이다. 모델의 내부 상태(Hidden States)는 수천 차원의 고해상도 벡터 공간에 존재하며 풍부한 정보를 담고 있다. 그러나 이를 어휘 집합(Vocabulary) 내의 단일 토큰으로 변환(Decoding)하는 과정에서 막대한 정보 손실이 발생한다. 복잡한 계획(Planning)이나 다각적인 고려가 필요한 문제에서 이러한 손실은 치명적일 수 있다.</p>
<h3>1.3  Coconut: 연속적 사고의 사슬</h3>
<p>이러한 배경 속에서 메타(Meta)와 UC 샌디에이고(UCSD) 연구진이 제안한 **Coconut(Chain of Continuous Thought)**은 패러다임의 전환을 시사한다. Coconut은 추론의 중간 과정을 굳이 인간의 언어로 번역하지 않는다. 대신, 모델의 마지막 은닉 상태(Last Hidden State)를 ’연속적 사고(Continuous Thought)’라는 벡터 형태로 유지하고, 이를 다음 단계의 입력으로 직접 주입한다.3</p>
<p>이는 마치 인간이 머릿속으로 복잡한 수를 계산할 때, 중간 과정을 일일이 말로 내뱉지 않고 뇌의 신경 활동 상태를 유지하며 다음 단계로 넘어가는 것과 유사하다. 언어라는 제약 없는 ’잠재 공간(Latent Space)’에서의 추론은 모델에게 무한한 자유도를 부여한다. 본 보고서는 Coconut 아키텍처의 설계 원리, 학습 방법론, 그리고 이로 인해 발현되는 창발적(Emergent) 특성인 ’중첩에 의한 추론(Reasoning by Superposition)’과 ‘너비 우선 탐색(BFS)’ 현상을 심층적으로 분석한다. 또한, 기존 CoT와의 비교 실험 결과와 구현상의 난점, 그리고 향후 인공지능이 나아가야 할 방향성으로서의 잠재적 추론의 의미를 포괄적으로 고찰한다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Legacy_LLM"
        A["입력 (Input)"] --&gt; B["언어 모델 (Black Box)"]
        B --&gt; C["단순 다음 토큰 예측 (Next Token Prediction)"]
        C --&gt; D["빠른 정답 도출 (직관적 오류 가능성)"]
    end
    style Legacy_LLM fill:#f9f9f9,stroke:#333,stroke-width:2px
</code></pre>
<pre><code class="language-mermaid">graph TD

    subgraph "CoT_Paradigm"
        E["입력 (Input)"] --&gt; F["프롬프트: 단계별로 생각하라"]
        F --&gt; G["언어 공간 내 추론 (Reasoning in Language Space)"]
        G --&gt; H{"언어적 병목 (Bottleneck)"}
        H --&gt;|"조기 확정 (Premature Commitment)"| I["경로 고착화 (오류 수정 불가)"]
        H --&gt;|"정보 손실 (Information Loss)"| J["고차원 벡터 -&gt; 이산적 토큰"]
        I --&gt; K["최종 답변"]
        J --&gt; K
    end

    style CoT_Paradigm fill:#fff0f0,stroke:#f66,stroke-width:2px
</code></pre>
<pre><code class="language-mermaid">graph TD

    subgraph "Coconut_Paradigm"
        L["입력 (Input)"] --&gt; M["&lt; bot &gt; (Begin of Thought)"]
        M --&gt; N["잠재 공간 내 추론 (Reasoning in Latent Space)"]
        N --&gt; O["연속적 사고 (Continuous Thought)"]
        O --&gt; P{"중첩 상태 (Superposition)"}
        P --&gt;|"너비 우선 탐색 (BFS)"| Q["다중 경로 동시 고려"]
        Q --&gt; R["&lt; eot &gt; (End of Thought)"]
        R --&gt; S["최종 답변 (언어 모드 복귀)"]
    end

    style Coconut_Paradigm fill:#e6f3ff,stroke:#33f,stroke-width:2px
</code></pre>
<h2>2.  이론적 배경: 이산성(Discreteness) 대 연속성(Continuity)</h2>
<h3>2.1  언어 모델의 이산적 본성</h3>
<p>전통적인 언어 모델은 이산적인 기호 시스템 위에서 작동한다. 텍스트는 토큰(Token)이라는 최소 단위로 쪼개지며, 각 토큰은 고정된 정수 인덱스에 매핑된다. 모델의 출력은 전체 어휘 집합에 대한 확률 분포(Softmax)이며, 샘플링 과정을 통해 하나의 토큰이 선택된다. 이러한 이산성은 해석 가능성(Interpretability)을 제공한다. 우리는 모델이 “1 더하기 1은 2이다“라고 출력할 때, 그 과정과 결과를 명확히 이해할 수 있다.</p>
<p>그러나 계산적 관점에서 이산성은 ’미분 불가능(Non-differentiable)’하다는 단점을 가진다. 경사 하강법(Gradient Descent)을 통해 모델을 최적화하려면 오차가 역전파(Backpropagation)되어야 하는데, 토큰을 선택하는 샘플링 과정은 미분이 불가능하여 강화학습(RL)과 같은 우회적인 방법을 사용해야 한다. 또한, 이산적 상태 공간은 탐색 효율성이 떨어진다. A에서 B로 가는 경로가 명확한 단어로 정의되어야 하므로, 여러 가능성을 동시에 고려하는 ’중첩 상태’를 표현하기 어렵다.</p>
<h3>2.2  연속적 잠재 공간의 위상학적 이점</h3>
<p>Coconut이 활용하는 잠재 공간은 고차원 실수 벡터 공간(<span class="math math-inline">\mathbb{R}^d</span>)이다. 이곳에서의 연산은 연속적이며 완전히 미분 가능하다(Fully Differentiable).2 이는 모델의 초기 생각부터 최종 답변에 이르기까지 전체 추론 과정을 하나의 거대한 계산 그래프로 연결할 수 있음을 의미한다.</p>
<p>연속적 공간의 가장 큰 특징은 <strong>정보의 밀도</strong>와 <strong>표현력</strong>이다. 4096차원의 벡터는 5만 개의 단어 중 하나를 선택하는 것보다 훨씬 더 많은 뉘앙스와 정보를 담을 수 있다. 더 중요한 것은 벡터의 ’방향성’과 ’거리’를 통해 개념 간의 관계를 유연하게 조작할 수 있다는 점이다. 예를 들어, ’왕’이라는 벡터에서 ’남자’를 빼고 ’여자’를 더하면 ’여왕’과 유사한 벡터가 되는 것과 같은 연산이 추론 과정 전체에 걸쳐 일어날 수 있다. Coconut은 이러한 벡터 연산을 언어로 구체화(Collapse)하지 않고 유지함으로써, 결정되지 않은 모호한 상태를 통해 복잡한 탐색을 수행한다.</p>
<h3>2.3  내재화(Internalization) 이론</h3>
<p>심리학자 비고츠키(Vygotsky)는 인간의 사고 발달 과정에서 ’내적 언어(Inner Speech)’의 중요성을 강조했다. 어린아이는 처음에는 소리 내어 말하며 문제를 해결하지만(Egocentric Speech), 성장하면서 이 과정은 소리 없는 내적 사고로 내재화된다. Coconut의 학습 과정은 이러한 인간의 인지 발달 과정을 모사한다. 초기에는 모든 단계를 언어로 표현하다가(CoT), 점차 중간 단계를 잠재적 벡터로 대체하며(Continuous Thought), 최종적으로는 직관적이고 빠른 사고 능력을 갖추게 된다. 이는 덩(Deng) 등이 제안한 “생각의 내재화” 개념과 맞닿아 있으며, Coconut은 이를 공학적으로 구현한 실체라 할 수 있다.1</p>
<pre><code class="language-mermaid">graph TD
    subgraph "Human_Cognition"
        direction TB
        A["초기 단계: 자기중심적 언어 (Egocentric Speech)"] --&gt;|"소리 내어 말하며 문제 해결"| B["과도기: 중얼거림 (Muttering)"]
        B --&gt;|"발성 기관의 억제"| C["성숙 단계: 내적 언어 (Inner Speech)"]
        C --&gt;|"언어 없는 순수 사고"| D["직관적 사고 (Intuition)"]
    end

    subgraph "Coconut_Learning"
        direction TB
        E["Stage 0: 표준 CoT (Standard CoT)"] --&gt;|"모든 추론 과정을 토큰으로 생성"| F["Stage k: 부분적 잠재화 (Partial Latent)"]
        F --&gt;|"중간 단계를 벡터로 대체"| G["Stage N: 완전한 잠재 사고 (Continuous Thought)"]
        G --&gt;|"토큰 생성 없이 내부 연산 처리"| H["즉각적 답변 (Instant Answer)"]
    end

    A -.-&gt;|"이론적 모델링 (Modeling)"| E
    C -.-&gt;|"공학적 구현 (Implementation)"| G
    
    style Human_Cognition fill:#fffbf0,stroke:#d4a017,stroke-width:2px
    style Coconut_Learning fill:#f0f8ff,stroke:#4682b4,stroke-width:2px
</code></pre>
<h2>3.  Coconut 아키텍처 및 핵심 메커니즘</h2>
<p>Coconut의 아키텍처는 기존 트랜스포머(Transformer) 모델을 기반으로 하되, 입력과 출력의 인터페이스를 혁신적으로 재설계하였다. 핵심은 ‘이중 모드(Dual Mode)’ 운용과 ‘입력 임베딩 대체(Input Embedding Replacement)’ 기술이다.</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant User as "사용자&lt;br&gt;(Input)"
    participant LLM as "언어 모드&lt;br&gt;(Transformer)"
    participant Latent as "잠재 모드&lt;br&gt;(Continuous Thought)"
    
    Note over User, LLM: "3.1 이중 모드 스위칭 &amp;&lt;br&gt;3.2 입력 임베딩 대체"

    User-&gt;&gt;LLM: "텍스트 토큰 입력&lt;br&gt;(x_1...x_i)"
    activate LLM
    LLM-&gt;&gt;LLM: "일반적 언어 처리"
    LLM-&gt;&gt;Latent: "전환 토큰 &lt; bot &gt; 생성"
    deactivate LLM
    
    activate Latent
    Note right of Latent: "토큰화 우회&lt;br&gt;(Bypassing Tokenization)"
    loop "연속적 사고 (Recursive Thinking)"
        Latent-&gt;&gt;Latent: "이전 은닉 상태(h_t-1)를&lt;br&gt;입력(E_t)으로 사용"
        Note right of Latent: "언어적 제약 없는&lt;br&gt;고차원 벡터 연산"
    end
    Latent-&gt;&gt;LLM: "전환 토큰 &lt; eot &gt; 생성"
    deactivate Latent

    activate LLM
    Note left of LLM: "결정된 사고(Collapsed Thought)를&lt;br&gt;언어로 변환"
    LLM-&gt;&gt;User: "최종 답변 생성 및 출력"
    deactivate LLM
</code></pre>
<h3>3.1  이중 모드 스위칭: 언어 모드와 잠재 모드</h3>
<p>Coconut 모델은 추론 과정에서 두 가지 모드를 유연하게 오간다.5</p>
<ol>
<li><strong>언어 모드 (Language Mode):</strong> 표준 LLM과 동일하게 작동한다. 이전 토큰들을 입력받아 다음 토큰의 확률 분포를 계산하고, 실제 단어를 생성한다.</li>
<li><strong>잠재 모드 (Latent Mode):</strong> 언어 생성을 중단하고 순수한 사고(Reasoning)만을 수행하는 단계다.</li>
</ol>
<p>이 두 모드 간의 전환을 제어하기 위해 두 개의 특수 제어 토큰(Control Tokens)이 도입되었다.</p>
<ul>
<li><strong><code>&lt;bot&gt;</code> (Begin of Thought):</strong> 이 토큰이 생성되면 모델은 잠재 모드로 진입한다. 이후의 단계에서는 단어가 아닌 ’생각 벡터’가 생성된다.</li>
<li><strong><code>&lt;eot&gt;</code> (End of Thought):</strong> 잠재적 사고가 충분히 이루어졌다고 판단되거나, 사전 설정된 단계가 끝나면 이 토큰을 통해 다시 언어 모드로 복귀한다. 이후 모델은 축적된 잠재적 사고를 바탕으로 최종 답변을 언어로 생성한다.6</li>
</ul>
<h3>3.2  입력 임베딩 대체 메커니즘 (Input Embedding Replacement)</h3>
<p>Coconut의 기술적 정수는 잠재 모드에서 입력 임베딩을 처리하는 방식에 있다. 일반적인 트랜스포머에서 시점 <span class="math math-inline">t</span>의 입력 벡터 <span class="math math-inline">E_t</span>는 해당 시점의 단어 토큰 <span class="math math-inline">x_t</span>를 임베딩 행렬(Lookup Table)에서 찾은 값이다.<br />
<span class="math math-display">
E_t = \text{Embedding}(x_t)
</span><br />
그러나 Coconut이 잠재 모드(<span class="math math-inline">i &lt; t &lt; j</span>)에 있을 때, 모델은 외부에서 주어지는 토큰 대신 자신의 직전 상태를 입력으로 사용한다.<br />
<span class="math math-display">
E_t = h_{t-1}
</span><br />
여기서 <span class="math math-inline">h_{t-1}</span>은 이전 시점 <span class="math math-inline">t-1</span>에서 트랜스포머의 마지막 레이어를 통과한 은닉 상태 벡터(Output Hidden State)이다.5</p>
<p>이 메커니즘이 갖는 함의는 심오하다.</p>
<ul>
<li><strong>재귀적 사고(Recursive Thinking):</strong> 모델은 자신이 방금 생각한 내용(<span class="math math-inline">h_{t-1}</span>)을 다음 생각의 재료(<span class="math math-inline">E_t</span>)로 삼는다. 이는 순환 신경망(RNN)의 구조를 닮았지만, 트랜스포머의 어텐션 메커니즘을 통해 과거의 모든 문맥(KV Cache)을 동시에 참조하면서 현재의 생각을 갱신한다는 점에서 훨씬 강력하다.</li>
<li><strong>토큰화 우회(Bypassing Tokenization):</strong> <span class="math math-inline">h_{t-1}</span>은 어휘 집합(Vocabulary) 크기에 제한되지 않는 연속 벡터다. 따라서 언어로 표현하기 힘든 미묘한 중간 계산 결과나, 여러 가능성이 혼재된 상태 정보를 손실 없이 다음 단계로 전달할 수 있다.</li>
<li><strong>연산 효율성:</strong> 별도의 디코딩(Decoding)이나 인코딩(Encoding) 과정 없이, 행렬 연산의 결과가 그대로 다음 입력이 되므로 계산 그래프가 끊기지 않고 이어진다.</li>
</ul>
<h3>3.3  아키텍처 다이어그램 및 흐름</h3>
<p>Coconut의 데이터 처리 흐름을 도식화하면 다음과 같다.</p>
<table><thead><tr><th><strong>단계</strong></th><th><strong>모드</strong></th><th><strong>입력 (Input)</strong></th><th><strong>처리 (Process)</strong></th><th><strong>출력 (Output)</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><span class="math math-inline">t=1 \dots i</span></td><td>언어</td><td>텍스트 토큰</td><td>Transformer</td><td>다음 토큰 예측</td><td>일반적 처리</td></tr>
<tr><td><span class="math math-inline">t=i+1</span></td><td>전환</td><td><code>&lt;bot&gt;</code></td><td>Transformer</td><td><span class="math math-inline">h_{i+1}</span> (잠재 벡터)</td><td>잠재 모드 진입</td></tr>
<tr><td><span class="math math-inline">t=i+2 \dots j-1</span></td><td><strong>잠재</strong></td><td><strong><span class="math math-inline">h_{t-1}</span> (이전 생각)</strong></td><td><strong>Transformer</strong></td><td><strong><span class="math math-inline">h_t</span> (갱신된 생각)</strong></td><td><strong>Coconut의 핵심</strong></td></tr>
<tr><td><span class="math math-inline">t=j</span></td><td>전환</td><td><span class="math math-inline">h_{j-1}</span></td><td>Transformer</td><td><code>&lt;eot&gt;</code> 예측</td><td>언어 모드 복귀</td></tr>
<tr><td><span class="math math-inline">t=j+1 \dots end</span></td><td>언어</td><td>텍스트/답변</td><td>Transformer</td><td>최종 답변 생성</td><td>결정된 사고 출력</td></tr>
</tbody></table>
<p>5</p>
<h2>4.  중첩에 의한 추론 (Reasoning by Superposition): 이론적 심층 분석</h2>
<p>Coconut이 단순한 최적화 기법을 넘어 새로운 추론 패러다임을 제시한다고 평가받는 이유는 <strong>‘중첩(Superposition)’</strong> 현상 때문이다. Zhu et al. (2025)과 Hao et al. (2024)의 연구는 Coconut이 잠재 공간에서 수행하는 연산이 양자 역학의 중첩 상태와 유사함을 수학적으로, 그리고 실험적으로 증명하였다.1</p>
<pre><code class="language-mermaid">mindmap
  root(("추론 전략 비교
  (4. 중첩에 의한 추론)"))
    ("이산적 CoT (DFS 방식)"))
      ("단일 경로 선택")
        ("A -&gt; B 선택 시 C, D 배제")
        ("조기 확정 (Premature Commitment)")
      ("한계점")
        ("되돌아가기(Backtracking) 불가")
        ("잘못된 경로 진입 시 환각(Hallucination) 발생")
        ("상태 붕괴 (State Collapse)")
    ("연속적 Coconut (BFS 방식)"))
      ("상태 중첩 (Superposition)")
        ("벡터 h = αA + βB + γC")
        ("여러 가능성의 선형 결합")
      ("이점")
        ("다중 경로 동시 탐색")
        ("그래프 지름(D) 만큼의 단계로 도달 가능")
        ("미분 가능한 사고 과정")
</code></pre>
<h3>4.1  이산적 CoT의 한계: 붕괴된 상태 (Collapsed State)</h3>
<p>기존 CoT 방식은 각 단계마다 하나의 구체적인 단어를 선택해야 한다. 그래프 탐색 문제(예: A에서 F로 가는 경로 찾기)를 예로 들어보자.</p>
<ul>
<li>CoT 모델: “A는 B와 연결되어 있다.” (선택 1) -&gt; “B는 C와 연결되어 있다.” (선택 2)…</li>
</ul>
<p>이 과정에서 모델은 ’B’라는 경로를 선택함으로써 ’D’나 ’E’와 같은 다른 가능성을 배제한다. 이는 파동 함수가 관측에 의해 하나의 상태로 붕괴(Collapse)되는 것과 같다. 만약 B가 막힌 길이라면(Dead end), 모델은 다시 돌아와야 하는데(Backtracking), 자기회귀(Autoregressive) 생성 모델은 본질적으로 되돌아가는 능력이 부족하다. 따라서 모델은 없는 길을 만들어내거나(Hallucination), 틀린 답을 고집하게 된다.</p>
<h3>4.2  연속적 사고의 힘: 다중 경로의 공존</h3>
<p>반면, Coconut의 잠재 벡터 <span class="math math-inline">h</span>는 여러 상태의 선형 결합(Linear Combination)을 표현할 수 있다.<br />
<span class="math math-display">
h_t \approx \alpha \cdot \text{State}(B) + \beta \cdot \text{State}(D) + \gamma \cdot \text{State}(E)
</span><br />
여기서 <span class="math math-inline">\alpha, \beta, \gamma</span>는 각 경로의 유망함(Promisingness)을 나타내는 가중치다. 모델은 특정 경로를 선택하여 확정 짓지 않고, 여러 가능성을 동시에 품은 채로 다음 연산을 수행한다. 이는 **너비 우선 탐색(BFS)**과 본질적으로 동일하다. 한 번의 연산으로 다수의 경로를 동시에 탐색하며, 다음 단계의 벡터 <span class="math math-inline">h_{t+1}</span>은 이들 경로에서 뻗어나가는 새로운 가능성들의 중첩 상태가 된다.9</p>
<h3>4.3  그래프 도달 가능성(Graph Reachability) 증명</h3>
<p>Zhu et al. (2025)은 그래프 이론을 통해 Coconut의 우월성을 증명했다.</p>
<ul>
<li><strong>문제:</strong> 노드 <span class="math math-inline">n</span>개로 이루어진 그래프에서 시작점 <span class="math math-inline">S</span>와 끝점 <span class="math math-inline">T</span>가 연결되어 있는지 판별하라.</li>
<li><strong>이산적 CoT (DFS 방식):</strong> 최악의 경우 <span class="math math-inline">O(n^2)</span>의 단계가 필요하거나, 잘못된 경로로 인해 영원히 정답에 도달하지 못할 수 있다.</li>
<li><strong>연속적 Coconut (BFS 방식):</strong> 그래프의 지름(Diameter)을 <span class="math math-inline">D</span>라고 할 때, Coconut은 단 <span class="math math-inline">D</span>번의 연속적 사고 단계(Latent Steps)만으로 <span class="math math-inline">T</span>에 도달할 수 있음을 보였다. <span class="math math-inline">k</span>번째 잠재 벡터는 시작점 <span class="math math-inline">S</span>로부터 거리 <span class="math math-inline">k</span> 이내에 있는 모든 노드의 정보를 중첩 상태로 포함하고 있기 때문이다.12</li>
</ul>
<p>이 이론적 결과는 Coconut이 단순히 “말을 안 해서 빠른” 것이 아니라, **“연산의 구조 자체가 병렬적이고 효율적으로 변화”**했음을 시사한다. 이는 트랜스포머가 가진 병렬 연산 능력을 시퀀스 생성이라는 직렬적 작업에서 해방시켜, 내부적인 사고의 병렬화로 전환시킨 것으로 해석할 수 있다.</p>
<h2>5.  학습 방법론: 다단계 커리큘럼 (Multi-stage Curriculum Learning)</h2>
<p>Coconut과 같은 잠재 추론 모델을 학습시키는 것은 매우 까다롭다. 인간의 언어 데이터에는 ’잠재적 사고’에 대한 정답 레이블(Ground Truth)이 존재하지 않기 때문이다. 따라서 연구진은 기존의 CoT 데이터를 활용하되, 점진적으로 사고를 내재화시키는 커리큘럼 학습 전략을 채택했다.1</p>
<h3>5.1  단계적 내재화 프로세스</h3>
<p>학습은 추론의 단계 수 <span class="math math-inline">k</span>를 기준으로 진행된다. 여기서 <span class="math math-inline">k</span>는 잠재 공간에서 처리될 추론 단계(Thought Steps)의 수를 의미한다.</p>
<ol>
<li><strong>Stage 0 (<span class="math math-inline">k=0</span>):</strong> 표준 CoT 학습이다. 모든 추론 과정이 언어 토큰으로 생성된다. 모델은 먼저 문제 해결의 논리적 구조를 언어적으로 습득한다.</li>
<li><strong>Stage 1 (<span class="math math-inline">k=1</span>):</strong> 추론의 첫 번째 문장(Step)을 제거하고, 이를 <code>&lt;bot&gt;</code>과 <code>&lt;eot&gt;</code> 사이의 1개의 잠재 벡터로 대체하여 학습한다. 모델은 첫 번째 문장이 담고 있던 의미 정보를 잠재 벡터에 압축하여 다음 문장 생성에 활용해야 한다.</li>
<li><strong>Stage Increment (<span class="math math-inline">k \to k+1</span>):</strong> 점진적으로 잠재 벡터로 대체하는 단계를 늘려간다. <span class="math math-inline">k=2, 3, \dots, N</span>까지 확장하며, 최종적으로는 모든 중간 추론 과정이 잠재 공간으로 숨겨지고, 모델은 질문(Question) 직후에 잠재적 숙고(Contemplation)를 거쳐 바로 정답(Answer)을 출력하게 된다.8</li>
</ol>
<h3>5.2  망각 방지와 안정화 전략: 혼합 비율(Mixing Ratio)</h3>
<p>단계를 높여갈 때 모델이 이전 단계에서 배운 언어적 논리 구조를 잊어버리는 ’파국적 망각(Catastrophic Forgetting)’이 발생할 수 있다. 이를 방지하기 위해 각 단계의 학습 데이터에는 현재 단계(<span class="math math-inline">k</span>)의 데이터뿐만 아니라, 이전 단계나 무작위 단계의 데이터를 일정 비율(<span class="math math-inline">p=0.3</span>)로 섞어서 제공한다.8</p>
<ul>
<li><strong>효과:</strong> 이 혼합 전략(Mixing Strategy)은 모델이 언어적 추론 능력과 잠재적 추론 능력을 동시에 유지하게 해 준다. 또한, 필요에 따라 추론 과정을 언어로 설명하거나(Explainability), 빠르게 잠재적으로 처리하는(Efficiency) 유연성을 부여한다.</li>
<li><strong>불안정성 관리:</strong> 실험 결과, <span class="math math-inline">k</span>를 한 번에 급격하게 늘리는 것(예: <span class="math math-inline">k=1 \to k=4</span>)은 학습 손실(Loss)의 급격한 스파이크를 유발하고 모델을 불안정하게 만들었다.14 따라서 <span class="math math-inline">k</span>를 1씩 천천히 증가시키거나, 데이터 혼합 비율을 조절하여 스무딩(Smoothing)하는 것이 필수적이다.</li>
</ul>
<h2>6.  실험적 평가 및 결과 분석</h2>
<p>Coconut의 성능을 검증하기 위해 연구진은 논리적 계획 능력을 평가하는 <strong>ProsQA</strong>, <strong>ProntoQA</strong>와 수학적 추론 능력을 평가하는 <strong>GSM8k</strong> 데이터셋을 활용했다.</p>
<pre><code class="language-mermaid">quadrantChart
    title "작업 유형별 Coconut 성능 및 특성 분석 (6. 실험적 평가)"
    x-axis "낮은 성능 (엄밀성 요구)" --&gt; "높은 성능 (탐색/계획 요구)"
    y-axis "낮은 효율성 (많은 토큰)" --&gt; "높은 효율성 (적은 토큰)"
    
    quadrant-1 "Coconut의 Sweet Spot (ProsQA)"
    quadrant-2 "잠재적 가치 존재"
    quadrant-3 "기존 CoT가 더 유리 (GSM8k)"
    quadrant-4 "비효율적 영역"

    "논리적 계획 (Planning)": [0.9, 0.9]
    "그래프 탐색 (Search)": [0.85, 0.85]
    "단순 산술 (Arithmetic)": [0.2, 0.6]
    "엄밀한 기호 조작 (Symbolic)": [0.3, 0.5]
    "ProntoQA": [0.8, 0.8]
    "GSM8k (수학)": [0.35, 0.6]
</code></pre>
<h3>6.1  ProsQA 및 ProntoQA: 논리적 탐색과 계획</h3>
<p>ProsQA는 “Alex의 자녀는 누구인가?“와 같이 그래프상의 관계를 추적해야 하는 문제들로 구성된다. 이 문제는 명시적인 탐색과 계획(Planning) 능력을 요구한다.</p>
<table><thead><tr><th><strong>모델 (Method)</strong></th><th><strong>ProsQA 정확도</strong></th><th><strong>ProntoQA 정확도</strong></th><th><strong>특징</strong></th></tr></thead><tbody>
<tr><td><strong>Standard CoT</strong></td><td>30% 대 (낮음)</td><td>90% 대 (높음)</td><td>경로 환각(Hallucination) 빈번 발생</td></tr>
<tr><td><strong>No-CoT</strong></td><td>매우 낮음</td><td>50% 대</td><td>추론 능력 부재</td></tr>
<tr><td><strong>Pause Token</strong></td><td>낮음</td><td>-</td><td>시간만 지연될 뿐 정보 처리 미흡</td></tr>
<tr><td><strong>Coconut (<span class="math math-inline">k=N</span>)</strong></td><td><strong>최상 (압도적)</strong></td><td><strong>99.8%</strong></td><td><strong>BFS 형태의 효율적 탐색</strong></td></tr>
</tbody></table>
<p>1</p>
<ul>
<li><strong>분석:</strong> ProsQA에서 Coconut은 CoT를 압도했다. CoT는 “A-&gt;B“라는 잘못된 엣지를 생성하면 그 오류에 갇혀버렸지만, Coconut은 잠재 공간에서 여러 경로를 동시에 탐색(BFS)하며 막다른 길을 소거(Pruning)하고 정답 경로를 찾아냈다.2 이는 Coconut이 계획(Planning) 및 탐색(Search) 문제에 특화되어 있음을 보여준다.</li>
</ul>
<h3>6.2  GSM8k: 수학적 추론의 명암</h3>
<p>수학 문제 해결에 있어서는 다소 복합적인 결과가 나타났다.</p>
<table><thead><tr><th><strong>모델</strong></th><th><strong>GSM8k 정확도</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td>Standard CoT</td><td><strong>34.1% ± 1.5</strong></td><td>언어적 엄밀성이 중요함</td></tr>
<tr><td><strong>Coconut (<span class="math math-inline">k=N</span>)</strong></td><td>34.1% ± 1.5</td><td>CoT와 유사하거나 다소 낮음</td></tr>
<tr><td>Coconut (No Curriculum)</td><td>14.4%</td><td>커리큘럼 학습 없이는 실패</td></tr>
<tr><td>Pause Token</td><td>16.4%</td><td>단순 대기 토큰은 효과 없음</td></tr>
</tbody></table>
<p>8</p>
<ul>
<li><strong>분석:</strong> Coconut은 기존 CoT와 유사한 성능을 보였지만, 압도적인 우위를 점하지는 못했다. 오히려 <span class="math math-inline">k</span>값이 커질수록(즉, 잠재적 사고가 길어질수록) 성능이 떨어지거나 불안정해지는 경향이 있었다.14</li>
<li><strong>원인:</strong> 수학은 <span class="math math-inline">1+1=2</span>와 같이 각 단계가 매우 엄밀하게 정의되어야 한다. 잠재 공간의 ’중첩’과 ’모호성’은 창의적 탐색에는 유리하지만, 정확한 숫자 계산이나 기호 조작(Symbolic Manipulation)에서는 오히려 노이즈(Noise)로 작용할 수 있다. 이는 신경망적 직관(Neural Intuition)과 기호적 논리(Symbolic Logic) 사이의 트레이드오프를 보여준다.</li>
</ul>
<pre><code class="language-mermaid">mindmap
  root(("Coconut의 트레이드오프
  (8. 한계점 및 고찰)"))
    ("긍정적 측면 (Pros)")
      ("효율성 (Efficiency)")
        ("토큰 생성 비용 절감")
        ("빠른 추론 속도")
      ("탐색 능력 (Search)")
        ("너비 우선 탐색 (BFS)")
        ("막다른 길(Dead End) 회피")
        ("계획(Planning) 능력 우수")
    ("부정적 측면 (Cons)")
      ("해석 불가능성 (Black Box)")
        ("사고 과정 검증 불가")
        ("안전성(Safety) 리스크")
      ("정확성 이슈 (Precision)")
        ("수학적 엄밀성 부족")
        ("상태 모호성으로 인한 노이즈")
      ("구현 난이도")
        ("커리큘럼 학습의 복잡성")
        ("최적의 k값(사고 길이) 탐색 어려움")
</code></pre>
<h3>6.3  효율성 비교: 토큰 경제학</h3>
<p>Coconut의 또 다른 강력한 장점은 추론 효율성이다. CoT는 모든 추론 과정을 토큰으로 생성해야 하므로 출력 길이가 매우 길어지고, 이는 지연 시간(Latency)과 비용 증가로 이어진다. 반면, Coconut은 중간 과정을 벡터 연산으로 대체하므로 생성해야 할 토큰 수가 획기적으로 줄어든다. ProsQA 실험에서 Coconut은 CoT 대비 수분의 1 수준의 토큰만으로 더 높은 정확도를 달성했다.1 이는 상용 서비스 관점에서 매우 중요한 경제적 이점이다.</p>
<h2>7.  구현 이슈 및 기술적 난제</h2>
<p>GitHub 저장소(OpenCoconut 등)와 관련 논문16에서 드러난 실제 구현상의 이슈들을 분석해보면, Coconut 패러다임이 아직 연구 단계에 있음을 알 수 있다.</p>
<pre><code class="language-mermaid">graph TD
   
    Input["입력 텍스트 (Input)"] --&gt; Enc["인코딩 (Encoding)"]
    Enc --&gt; Bot["&lt; bot &gt; 토큰 진입"]
    
    subgraph "Latent_Reasoning_Process"
        direction TB
        H1["은닉 상태 h_t (Hidden State)"]
        Filter["활성화 억제/정규화 (Suppression/Norm)"]
        Next["다음 입력 E_t+1 = Filter(h_t)"]
        H1 --&gt; Filter --&gt; Next
        Next --&gt;|"반복 (Recurrent)"| H1
    end
    
    Bot --&gt; Latent_Reasoning_Process
    Latent_Reasoning_Process --&gt; Eot["&lt; eot &gt; 토큰 생성"]
    
    subgraph "Loss_Calculation"
        Target["정답 텍스트 (Ground Truth)"]
        Pred["생성된 답변 (Prediction)"]
        Loss["손실 함수 (NTP Loss + SEQ-VCR)"]
        Target --&gt; Loss
        Eot --&gt; Pred --&gt; Loss
    end
    
    Loss --&gt;|"BPTT (시간을 거스른 역전파)"| Latent_Reasoning_Process
    Note["잠재 구간에는 정답 토큰이 없으므로\n최종 답변의 오차가 사고 과정 전체를 수정함"] -.-&gt; Latent_Reasoning_Process

    style Latent_Reasoning_Process fill:#f3e5f5,stroke:#8e24aa,stroke-width:2px
</code></pre>
<h3>7.1  은닉 상태 주입의 최적 위치</h3>
<p>단순히 마지막 은닉 상태(<span class="math math-inline">h_{last}</span>)를 다음 입력으로 넣는 것이 최선인가에 대한 논의가 있다.</p>
<ul>
<li><strong>Suppressed Activations:</strong> 일부 구현에서는 활성화 값을 억제(Suppress)하거나 정규화하여 주입하는 것이 성능이 더 좋았다.16 이는 은닉 상태의 스케일(Scale)이 임베딩 벡터와 다르기 때문에 발생하는 분포 불일치(Distribution Shift) 문제를 완화하기 위함이다.</li>
<li><strong>Layer Selection:</strong> 마지막 레이어 대신 뒤에서 두 번째 레이어(<span class="math math-inline">h_{-2}</span>)를 사용하는 것이 더 효과적이라는 보고도 있다. 마지막 레이어는 다음 토큰 예측을 위해 지나치게 특화되어 있어, 순수한 의미 정보를 담기에는 이전 레이어가 더 적합할 수 있기 때문이다.</li>
</ul>
<h3>7.2  손실 함수의 설계</h3>
<p>Coconut은 기본적으로 다음 토큰 예측 손실(<span class="math math-inline">\mathcal{L}_{NTP}</span>)을 사용하지만, 잠재 사고 구간에서는 타겟 토큰이 없다. 따라서 잠재 사고가 끝난 후 생성되는 텍스트에 대한 손실이 역전파되어 잠재 벡터들을 학습시켜야 한다. 이 과정에서 <strong>SEQ-VCR Loss</strong>와 같은 보조 손실 함수를 도입하여 잠재 벡터의 표현력을 높이고 해석 가능성을 확보하려는 시도도 이루어지고 있다.16</p>
<h2>8.  한계점 및 비판적 고찰</h2>
<pre><code class="language-mermaid">graph TD

    Start(("사용자 질문")) --&gt; MetaCog{"메타 인지 판단\n(Meta-cognition)"}
    
    MetaCog -- "안전/검증 필요 (Safety Critical)" --&gt; ModeA["언어 모드 (Standard CoT)"]
    MetaCog -- "복잡한 탐색/직관 필요 (Complex Search)" --&gt; ModeB["잠재 모드 (Coconut Latent)"]
    
    subgraph "Execution_Path"
        ModeA --&gt; ProcessA["단계별 텍스트 생성"]
        ModeA --&gt; Explain["해석 가능성 확보 (Interpretability)"]
        
        ModeB --&gt; ProcessB["고차원 벡터 연산 (BFS)"]
        ModeB --&gt; Speed["효율성 및 정답률 확보 (Efficiency)"]
    end
    
    ProcessA --&gt; Output(("최종 답변"))
    ProcessB --&gt; Output
    
    Explain -.-&gt;|"인간 피드백 (RLHF)"| MetaCog
    Speed -.-&gt;|"성공 여부 피드백"| MetaCog
</code></pre>
<h3>8.1  해석 가능성의 상실 (The Black Box Problem)</h3>
<p>Coconut에 대한 가장 큰 비판은 ’설명 가능성’의 부재다.18 CoT는 모델이 왜 그런 결론을 내렸는지 텍스트로 보여주기 때문에 인간이 검증(Verify)할 수 있다. 그러나 Coconut의 ’연속적 사고’는 숫자로 이루어진 벡터일 뿐이다. 모델이 잠재 공간에서 편향된 논리를 전개하거나, 위험한 사고를 하더라도 우리는 최종 결과가 나오기 전까지 이를 감지할 수 없다. 이는 AI 안전성(Safety) 및 정렬(Alignment) 연구에 있어 심각한 도전 과제다.</p>
<h3>8.2  범용성 및 데이터 의존성</h3>
<p>현재 Coconut은 특정 태스크(ProsQA, GSM8k)에 대해 특화된 파인 튜닝(Fine-tuning)을 통해 학습된다. 범용 LLM(Foundation Model)에 바로 적용하여, 처음 보는 문제에 대해서도 스스로 ’잠재 모드’를 켜고 사고하게 만드는 것은 아직 미지의 영역이다.20 데이터셋마다 최적의 <span class="math math-inline">k</span>값이 다르고, 커리큘럼 설계가 복잡하다는 점은 실용화의 걸림돌이다.</p>
<h2>9.  향후 전망 및 제언</h2>
<h3>9.1  잠재 공간 사전 학습 (Latent Space Pre-training)</h3>
<p>연구진은 Coconut을 단순한 파인 튜닝 기법이 아니라, 모델의 사전 학습(Pre-training) 단계부터 적용해야 한다고 제안한다.14 인터넷상의 텍스트 데이터뿐만 아니라, 인위적으로 생성된 ’잠재적 사고 시퀀스’를 학습 데이터에 포함시킨다면, 모델은 언어 습득 이전의 원초적 추론 능력을 배양할 수 있을 것이다. 이는 인간이 언어를 배우기 전 세상을 이해하는 방식과 유사한 접근이다.</p>
<h3>9.2  하이브리드 추론 시스템 (Hybrid Reasoning Systems)</h3>
<p>해석 가능성과 효율성 사이의 균형을 맞추기 위해, 하이브리드 시스템이 대안이 될 것이다.</p>
<ul>
<li>
<p><strong>Critical Thinking:</strong> 안전과 검증이 중요한 단계에서는 언어 모드(CoT)로 출력하여 인간의 피드백을 받는다.</p>
</li>
<li>
<p>Intuitive Leap: 빠르고 복잡한 탐색이 필요한 구간에서는 잠재 모드(Coconut)로 전환하여 효율을 극대화한다.</p>
</li>
</ul>
<p>이러한 동적 모드 전환(Dynamic Mode Switching)을 모델이 스스로 판단하게 하는 메타 인지(Meta-cognition) 연구가 뒤따를 것이다.</p>
<h3>9.3  양자 인지 과학(Quantum Cognitive Science)과의 융합</h3>
<p>Coconut에서 발견된 ’중첩에 의한 추론’은 인공지능이 고전적 확률론을 넘어 양자적 확률론의 특성을 보일 수 있음을 시사한다. 이는 인지과학에서 인간의 비합리적 의사결정을 설명하기 위해 도입된 ‘양자 인지(Quantum Cognition)’ 모델과 유사하다. 향후 AI 연구가 물리학 및 인지과학과 깊게 교류하며 새로운 이론적 토대를 마련할 것으로 기대된다.</p>
<h2>10.  결론</h2>
<p>Coconut(Chain of Continuous Thought)은 거대 언어 모델이 맞닥뜨린 ’언어의 장벽’을 넘어서려는 대담하고 혁신적인 시도다. 이산적 토큰의 연쇄를 연속적 벡터의 흐름으로 치환함으로써, Coconut은 모델에게 **‘말하지 않고 생각하는 능력’**을 부여했다.</p>
<p>본 보고서의 분석을 통해 우리는 Coconut이 단순한 효율성 개선 도구가 아님을 확인했다. 그것은 모델 내부에서 **너비 우선 탐색(BFS)**과 **상태 중첩(Superposition)**이라는, 기존 언어 모델에서는 볼 수 없었던 고차원적인 인지 과정이 창발적으로 나타나게 하는 촉매제다. 비록 해석 가능성의 문제와 수학적 엄밀성의 한계가 여전히 과제로 남아있지만, Coconut이 제시한 **‘잠재 공간에서의 자유로운 추론’**이라는 비전은 향후 인공지능이 AGI(일반 인공지능)로 나아가는 데 있어 필수적인 진화의 단계가 될 것임이 분명하다. 우리는 이제 기계가 인간의 언어를 흉내 내는 단계를 지나, 기계만의 방식으로 사유(思惟)하는 시대로 진입하고 있다.</p>
<h2>11. 참고 자료</h2>
<ol>
<li>Training Large Language Models to Reason in a Continuous Latent Space - arXiv, https://arxiv.org/html/2412.06769v3</li>
<li>Coconut by Meta AI – Better LLM Reasoning With Chain of CONTINUOUS Thought?, https://aipapersacademy.com/chain-of-continuous-thought/</li>
<li>Meta Introduces Chain of Continuous Thought (Coconut) to Improve Next-Token Prediction, https://www.deeplearning.ai/the-batch/meta-introduces-chain-of-continuous-thought-coconut-to-improve-next-token-prediction/</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space - arXiv, https://arxiv.org/abs/2412.06769</li>
<li>Chain of Continuous Thought: novel paradigm with enhanced LLM …, https://medium.com/@techsachin/chain-of-continuous-thought-novel-paradigm-with-enhanced-llm-reasoning-in-continuous-latent-space-e9461d427c40</li>
<li>Coconut: A Framework for Latent Reasoning in LLMs | Towards …, https://towardsdatascience.com/coconut-a-framework-for-latent-reasoning-in-llms/</li>
<li>Meta’s COCONUT: Better alternate than Chain Of Thoughts for LLM reasoning - Medium, https://medium.com/data-science-in-your-pocket/metas-coconut-better-alternate-than-chain-of-thoughts-for-llm-reasoning-9634f9a070eb</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space - arXiv, https://arxiv.org/html/2412.06769v1</li>
<li>Reasoning by Superposition: A Theoretical Perspective on Chain of Continuous Thought, https://arxiv.org/html/2505.12514v1</li>
<li>Emergence of Superposition: Unveiling the Training Dynamics of Chain of Continuous Thought | alphaXiv, https://www.alphaxiv.org/overview/2509.23365v2</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space | alphaXiv, https://www.alphaxiv.org/overview/2412.06769v1</li>
<li>Reasoning by Superposition: A Theoretical Perspective on Chain of Continuous Thought, <a href="https://openreview.net/forum?id=UdOEZgWJLc&amp;referrer=%5Bthe+profile+of+Jiantao+Jiao%5D(/profile?id%3D~Jiantao_Jiao1)">https://openreview.net/forum?id=UdOEZgWJLc&amp;referrer=%5Bthe%20profile%20of%20Jiantao%20Jiao%5D(%2Fprofile%3Fid%3D~Jiantao_Jiao1)</a></li>
<li>Paper Review: Training Large Language Models to Reason in a …, https://andlukyane.com/blog/paper-review-coconut</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space - arXiv, https://arxiv.org/pdf/2412.06769</li>
<li>Article Overview: Training Large Language Models to Reason in a Continuous Latent Space | by Aleksandr Golovin | Medium, https://medium.com/@axegggl/article-overview-training-large-language-models-to-reason-in-a-continuous-latent-space-f2c5e090f0fb</li>
<li>wassname/coconut: Training Large Language Model to Reason in a Continuous Latent Space - GitHub, https://github.com/wassname/coconut</li>
<li>OpenCoconut implements a latent reasoning paradigm where we generate thoughts before decoding. - GitHub, https://github.com/casper-hansen/OpenCoconut</li>
<li>Worries about latent reasoning in LLMs — EA Forum, https://forum.effectivealtruism.org/posts/sNkua636jSni6Jftt/worries-about-latent-reasoning-in-llms</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space - Hugging Face, https://huggingface.co/papers/2412.06769</li>
<li>Training Large Language Models to Reason in a Continuous Latent Space - OpenReview, https://openreview.net/forum?id=Itxz7S4Ip3</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>