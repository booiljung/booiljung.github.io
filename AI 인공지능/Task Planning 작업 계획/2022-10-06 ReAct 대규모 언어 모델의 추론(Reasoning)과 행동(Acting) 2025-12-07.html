<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ReAct 대규모 언어 모델의 추론(Reasoning)과 행동(Acting) (2022-10-06)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ReAct 대규모 언어 모델의 추론(Reasoning)과 행동(Acting) (2022-10-06)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">작업 계획 (Task Planning)</a> / <span>ReAct 대규모 언어 모델의 추론(Reasoning)과 행동(Acting) (2022-10-06)</span></nav>
                </div>
            </header>
            <article>
                <h1>ReAct 대규모 언어 모델의 추론(Reasoning)과 행동(Acting) (2022-10-06)</h1>
<p>2025-12-07, G30DR</p>
<h2>1.  서론: 인공지능의 패러다임 전환과 ReAct의 등장이 갖는 함의</h2>
<p>인공지능(AI), 특히 대규모 언어 모델(Large Language Models, LLMs)의 발전은 자연어 처리(NLP) 분야를 넘어 범용 문제 해결 능력(General Purpose Problem Solving)을 갖춘 시스템으로 진화하고 있다. GPT-3, PaLM과 같은 초기 거대 모델들은 방대한 텍스트 데이터를 학습하여 뛰어난 언어 이해 및 생성 능력을 보여주었으나, 근본적인 한계점 또한 명확히 드러냈다. 이러한 모델들은 학습 데이터에 포함된 지식에만 의존하는 ’정적(Static)’인 특성을 가지며, 외부 세계의 실시간 정보에 접근하거나 물리적/디지털 환경과 상호작용하는 ‘행동(Acting)’ 능력이 결여되어 있었다.1 또한 복잡한 다단계 추론이 필요한 과제에서 논리적 비약이나 사실이 아닌 정보를 진실인 것처럼 생성하는 환각(Hallucination) 현상이 빈번하게 발생하였다.3</p>
<p>이러한 정적 모델의 한계를 극복하고, 모델이 스스로 사고하고 행동하는 ’에이전트(Agent)’로 진화하기 위한 핵심적인 방법론으로 등장한 것이 바로 ReAct(Reasoning + Acting) 프레임워크이다. Yao 등(2023)에 의해 제안된 ReAct는 인간 지능의 고유한 특성인 ’내적 발화(Inner Speech)’와 ’행동 수행’의 긴밀한 상호작용에 착안하였다.4 인간은 문제 해결 과정에서 단순히 행동만을 수행하는 것이 아니라, 행동 이전에 계획을 수립하고(Reasoning), 행동을 수행한 후(Acting), 그 결과를 관찰하여(Observation) 지식을 갱신하고 다음 계획을 수정한다. ReAct는 이러한 인지 과정을 LLM에 도입하여, 모델이 추론(Thought)과 행동(Action)을 인터리빙(Interleaving)하는 방식으로 문제를 해결하도록 설계되었다.5</p>
<p>본 보고서는 ReAct 프레임워크의 이론적 배경, 작동 메커니즘, 기존 방법론(Chain-of-Thought, Act-only)과의 비교 우위, 벤치마크 성능, 그리고 실제 구현을 위한 프레임워크(LangChain, LlamaIndex) 활용법까지 포괄적으로 다룬다. 특히 단순한 개념 설명을 넘어, 에이전트 시스템에서 발생하는 오류 전파(Error Propagation)의 문제와 이를 해결하기 위한 확장된 아키텍처(Reflexion, Tree of Thoughts)와의 관계를 심층적으로 분석함으로써, ReAct가 현대 에이전트 AI 시스템의 표준으로 자리 잡게 된 이유와 향후 발전 방향을 제시한다.</p>
<h2>2.  이론적 배경 및 인지과학적 기초</h2>
<h3>2.1  인간 인지와 내적 발화(Inner Speech)의 모델링</h3>
<p>ReAct 프레임워크의 설계 철학은 인지과학 및 심리학에서 논의되는 인간의 문제 해결 과정과 깊이 연관되어 있다. Vygotsky(1987)와 Luria(1965) 등의 연구에 따르면, 언어는 단순히 의사소통의 도구가 아니라 사고를 조절하고 구조화하는 인지적 도구로서 기능한다.4 인간은 복잡한 과업을 수행할 때 ’내적 발화(Inner Speech)’를 통해 현재 상황을 언어적으로 정의하고, 목표를 달성하기 위한 하위 목표를 설정하며, 행동의 결과를 예측한다.</p>
<p>기존의 강화학습(Reinforcement Learning, RL)이나 행동 복제(Imitation Learning) 기반의 에이전트들은 주로 관찰(Input)과 행동(Output) 간의 매핑을 학습하는 데 집중하여, 이러한 ’사고 과정’이 블랙박스로 남아 있었다. 반면, Chain-of-Thought(CoT) 프롬프팅은 추론 과정을 언어로 생성하게 함으로써 모델의 논리력을 향상시켰으나, 이는 외부 세계와의 상호작용이 배제된 고립된 사고에 불과했다.</p>
<p>ReAct는 이 두 가지 접근법을 통합한다. ReAct 에이전트는 행동을 취하기 전에 명시적인 ’생각(Thought)’을 생성함으로써 행동의 근거를 마련하고(Self-regulation), 행동의 결과인 ’관찰(Observation)’을 통해 자신의 내부 상태를 외부 현실에 맞게 조정(Working Memory Maintenance)한다. 이는 LLM이 단순히 텍스트를 생성하는 기계가 아니라, 환경과 상호작용하며 학습하고 적응하는 능동적 주체로 기능하게 한다.1</p>
<h3>2.2  ReAct 루프의 형식적 정의 (Formalization)</h3>
<p>ReAct의 작동 원리는 시계열적인 의사결정 과정으로 형식화할 수 있다. 시점 <span class="math math-inline">t</span>에서의 에이전트의 상태는 문맥(Context, <span class="math math-inline">c_t</span>)으로 정의되며, 에이전트는 이를 바탕으로 추론(Thought, <span class="math math-inline">\tau_t</span>)과 행동(Action, <span class="math math-inline">a_t</span>)을 생성하고, 환경으로부터 관찰(Observation, <span class="math math-inline">o_t</span>)을 획득한다.</p>
<p>ReAct의 핵심 루프는 다음과 같은 순서로 진행된다:</p>
<ol>
<li><strong>추론 생성 (<span class="math math-inline">\tau_t \sim \pi(c_t)</span>):</strong> 모델은 현재 문맥 <span class="math math-inline">c_t</span>를 바탕으로 자연어 형태의 추론 <span class="math math-inline">\tau_t</span>를 생성한다. 이 추론은 문제 분해, 정보 추출, 상식적 판단, 계획 수립 등을 포함한다. <span class="math math-inline">\tau_t</span>는 외부 환경에 직접적인 영향을 미치지 않지만, 모델의 내부 상태를 정리하고 다음에 취할 행동 <span class="math math-inline">a_t</span>의 근거를 제공한다.6</li>
<li><strong>행동 생성 (<span class="math math-inline">a_t \sim \pi(c_t, \tau_t)</span>):</strong> 생성된 추론 <span class="math math-inline">\tau_t</span>를 바탕으로 구체적인 행동 <span class="math math-inline">a_t</span>를 결정한다. 행동은 <code>Search[Query]</code>, <code>Click</code>, <code>Calculator[Formula]</code>와 같이 사전에 정의된 도구(Tool) API를 호출하는 형식을 띤다. 이는 모델 내부의 언어 공간을 벗어나 외부 환경(Environment)과 상호작용하는 단계이다.5</li>
<li><strong>환경 관찰 (<span class="math math-inline">o_t = Env(a_t)</span>):</strong> 행동 <span class="math math-inline">a_t</span>가 실행된 후, 환경은 그 결과값인 <span class="math math-inline">o_t</span>를 반환한다. 이는 검색 엔진의 검색 결과(Snippet), 계산기의 수치적 결과, 또는 시스템의 오류 메시지일 수 있다.</li>
<li><strong>문맥 갱신 (<span class="math math-inline">c_{t+1} = c_t \cup \{\tau_t, a_t, o_t\}</span>):</strong> 추론, 행동, 관찰의 삼중항(Triplet)이 기존 문맥에 추가된다. 모델은 갱신된 문맥 <span class="math math-inline">c_{t+1}</span>을 바탕으로 다시 새로운 추론 <span class="math math-inline">\tau_{t+1}</span>을 시작한다.</li>
</ol>
<p>이러한 <span class="math math-inline">(Thought \rightarrow Action \rightarrow Observation)</span> 사이클은 에이전트가 종료 조건(예: <code>Final Answer</code> 도출)을 만족하거나 사전 설정된 최대 턴(Turn) 수에 도달할 때까지 반복된다.8</p>
<h3>2.3  기존 방법론과의 비교 분석</h3>
<p>ReAct의 독창성과 우수성은 기존의 주요 패러다임인 Chain-of-Thought(CoT)와 Act-only 방법론의 한계를 상호 보완적으로 해결한다는 점에서 명확해진다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Chain-of-Thought (CoT)</strong></th><th><strong>Act-only (WebGPT 등)</strong></th><th><strong>ReAct (Reasoning + Acting)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 메커니즘</strong></td><td>연속적인 추론 단계(Thoughts)만 생성</td><td>환경에 대한 행동(Actions)만 생성</td><td>추론과 행동을 번갈아 생성(Interleaving)</td></tr>
<tr><td><strong>외부 정보 접근</strong></td><td>불가능 (내부 파라미터 지식에 의존)</td><td>가능 (검색, API 호출 등)</td><td>가능 (추론에 기반한 능동적 탐색)</td></tr>
<tr><td><strong>주요 한계점</strong></td><td>사실 환각(Hallucination), 오류 전파</td><td>상위 수준 계획 부재, 비효율적 탐색</td><td>긴 문맥 길이, 추론 비용 증가</td></tr>
<tr><td><strong>정보 업데이트</strong></td><td>불가능 (정적 추론)</td><td>가능 (관찰값 획득)</td><td>실시간으로 추론 및 계획 수정 가능</td></tr>
<tr><td><strong>해석 가능성</strong></td><td>높음 (사고 과정이 드러남)</td><td>낮음 (행동의 의도 파악 어려움)</td><td>매우 높음 (행동의 의도와 근거가 명시됨)</td></tr>
<tr><td><strong>적용 분야</strong></td><td>수학 문제, 상식 추론</td><td>웹 브라우징, 단순 정보 검색</td><td>다단계 질의응답, 복잡한 의사결정 에이전트</td></tr>
</tbody></table>
<ul>
<li><strong>CoT 대비 우위:</strong> CoT는 모델이 “생각“을 하도록 유도하지만, 그 생각의 재료가 모델의 내부 지식(Parametric Knowledge)에 한정된다. 따라서 모델이 모르는 사실에 대해 추론할 때 그럴듯한 거짓말을 만들어내는 환각 문제가 발생한다. ReAct는 외부 검색을 통해 획득한 관찰(<span class="math math-inline">o_t</span>)을 추론의 근거로 사용(Grounding)함으로써 사실적 정확성을 획기적으로 높인다.1</li>
<li><strong>Act-only 대비 우위:</strong> 행동 중심 모델은 검색이나 클릭은 할 수 있지만, “왜” 그 행동을 해야 하는지에 대한 명시적인 계획이 없다. 복잡한 목표(예: “펩시와 코카콜라의 1990년 매출을 비교하라”)가 주어졌을 때, Act-only 모델은 무작위적인 검색을 하거나 불필요한 행동을 반복할 위험이 크다. ReAct는 행동 이전에 “먼저 펩시의 매출을 찾고, 그 다음 코카콜라를 찾아야겠다“는 추론을 생성함으로써 행동의 효율성과 목표 지향성을 강화한다.11</li>
</ul>
<h2>3.  벤치마크 성능 및 실증적 효용성 분석</h2>
<p>ReAct의 성능은 지식 집약적 작업(Knowledge-Intensive Tasks)과 상호작용형 의사결정 작업(Decision-Making Tasks) 모두에서 검증되었다. Yao 등(2022)의 연구는 네 가지 주요 벤치마크(HotpotQA, FEVER, ALFWorld, WebShop)를 통해 ReAct의 효용성을 입증했다.</p>
<h3>3.1  지식 집약적 추론: HotpotQA와 FEVER</h3>
<p>HotpotQA는 여러 문서에 걸친 정보를 종합해야 답을 얻을 수 있는 다단계 질의응답(Multi-hop QA) 데이터셋이며, FEVER는 사실 검증(Fact Verification) 데이터셋이다.</p>
<ul>
<li><strong>사실 환각의 극복:</strong> 실험 결과, CoT 방식은 모델이 내부적으로 잘못 기억하고 있는 정보를 바탕으로 추론을 전개하여 오답을 내는 경우가 많았다. 반면 ReAct는 위키피디아 검색 API를 통해 실시간으로 팩트를 확인하고, 그 결과를 바탕으로 다음 사고 단계를 조정했다. 예를 들어, FEVER 데이터셋에서 ReAct는 기존 CoT 방식 대비 더 높은 정확도를 기록했으며, 특히 검색된 증거가 추론을 지지하는 구조 덕분에 결과의 신뢰성(Trustworthiness)이 크게 향상되었다.2</li>
<li><strong>검색과 추론의 시너지:</strong> HotpotQA 초기 실험에서 ReAct는 CoT보다 일부 낮은 점수를 기록하기도 했는데, 이는 과도한 검색 결과가 문맥을 오염시키거나 추론의 흐름을 방해했기 때문이다. 연구진은 이를 해결하기 위해 ReAct와 CoT를 결합한 전략(ReAct + CoT)을 제안했다. 모델이 내부 지식으로 충분히 답할 수 있을 때는 CoT를, 외부 정보가 필요할 때는 ReAct를 사용하도록 하거나, ReAct 과정 중 추론이 막힐 때 CoT로 전환하는 방식을 통해 두 벤치마크 모두에서 최고 성능(SOTA)을 달성했다.8</li>
</ul>
<h3>3.2  상호작용형 의사결정: ALFWorld와 WebShop</h3>
<p>ReAct의 진가는 정적인 텍스트 처리를 넘어, 환경 상태가 변화하는 상호작용형 환경에서 더욱 두드러진다.</p>
<ul>
<li><strong>ALFWorld (텍스트 기반 게임):</strong> 텍스트 명령으로 집안일(예: “거실 탁자 위의 리모컨을 찾아 소파에 두어라”)을 수행하는 시뮬레이션 환경이다. 여기서 ReAct는 행동 복제(Imitation Learning)나 강화학습(Reinforcement Learning) 기반의 베이스라인보다 압도적인 성공률을 보였다. 단 1~2개의 퓨샷(Few-shot) 예시만으로도 수만 개의 데이터로 학습된 모델보다 뛰어난 성과(성공률 34% 절대 향상)를 달성했다.7 이는 ReAct가 예외 상황(예: 찾는 물건이 원래 위치에 없는 경우)에서 “여기 없으니 다른 곳을 찾아보자“라는 식의 유연한 대처가 가능하기 때문이다.</li>
<li><strong>WebShop (웹 쇼핑 시뮬레이션):</strong> 사용자의 자연어 지시에 맞춰 상품을 검색하고 옵션을 선택하여 구매하는 과제이다. Act-only 모델은 수천 개의 상품 페이지 속에서 길을 잃기 쉬우나, ReAct는 “상품 설명에 ’USB 3.0’이 포함된 것을 선택해야 한다“와 같은 명시적 추론을 통해 탐색 공간을 효율적으로 좁혔다. 그 결과 Act-only 모델 대비 10% 더 높은 성공률을 기록했다.7</li>
</ul>
<h2>4.  ReAct 구현 아키텍처 및 메커니즘 심층 분석</h2>
<p>ReAct를 실제 어플리케이션으로 구현하기 위해서는 LLM, 프롬프트 템플릿, 도구(Tool) 인터페이스, 그리고 실행 루프(Loop) 관리자가 유기적으로 결합되어야 한다. 이 섹션에서는 ReAct 에이전트의 내부 구조를 상세히 분해한다.</p>
<h3>4.1  프롬프트 엔지니어링과 퓨샷(Few-shot) 예시</h3>
<p>ReAct 에이전트의 ’지능’은 프롬프트 템플릿에서 시작된다. 프롬프트는 모델에게 역할(Role)을 부여하고, 사용 가능한 도구를 정의하며, ReAct 특유의 출력 형식을 강제해야 한다.5</p>
<p><strong>표준 ReAct 프롬프트 구조:</strong></p>
<ol>
<li><strong>시스템 지시문(Instruction):</strong> 에이전트의 목적과 행동 수칙을 정의한다.</li>
<li><strong>도구 설명(Tool Descriptions):</strong> 사용할 수 있는 도구의 이름과 기능, 입력 형식을 명시한다. LLM은 이 설명을 읽고 어떤 상황에 어떤 도구를 쓸지 판단한다.</li>
<li><strong>퓨샷 예시(Few-shot Trajectories):</strong> <span class="math math-inline">(Thought, Action, Observation)</span> 패턴이 포함된 문제 해결 예시를 제공하여 모델이 인컨텍스트 러닝(In-context Learning)을 할 수 있게 한다.</li>
<li><strong>현재 과제(Current Task):</strong> 사용자의 입력 질문을 배치한다.</li>
</ol>
<p><strong>HotpotQA 퓨샷 예시 (재구성):</strong></p>
<blockquote>
<p>Question: “잡지 ’Arthur’s Magazine’과 ’First for Women’은 같은 시기에 창간되었는가?”</p>
<p>Thought 1: “Arthur’s Magazine“과 “First for Women“의 창간 연도를 각각 찾아야 비교할 수 있다. 먼저 “Arthur’s Magazine“을 검색하자.</p>
<p>Action 1: Search[“Arthur’s Magazine”]</p>
<p>Observation 1: “Arthur’s Magazine (1844–1846)은 19세기 필라델피아의 문학 잡지였다.”</p>
<p>Thought 2: “Arthur’s Magazine“은 1844년에 창간되었다. 이제 “First for Women“을 검색해야 한다.</p>
<p>Action 2: Search</p>
<p>Observation 2: “First for Women은 Bauer Media Group에서 발행하는 여성 잡지이다. 1989년에 시작되었다.”</p>
<p>Thought 3: “Arthur’s Magazine“은 1844년, “First for Women“은 1989년에 창간되었다. 1844년과 1989년은 같은 시기가 아니다.</p>
<p>Action 3: Finish</p>
</blockquote>
<p>이러한 예시는 모델에게 “필요한 정보를 순차적으로 검색하고, 얻은 정보를 종합하여 논리적으로 판단하라“는 메타 전략을 학습시킨다.6</p>
<h3>4.2  실행 루프(Execution Loop)와 파싱 로직</h3>
<p>ReAct의 실행은 LLM과 Python 런타임 간의 탁구(Ping-pong)와 같다.</p>
<ol>
<li><strong>생성 단계:</strong> 사용자의 질문이 포함된 프롬프트가 LLM에 전달된다. LLM은 <code>Thought</code>와 <code>Action</code>을 생성한다.</li>
<li><strong>정지 및 파싱(Stop &amp; Parse):</strong> LLM이 <code>Observation</code>까지 스스로 생성(환각)하지 못하도록, <code>Action</code> 생성 직후 생성을 멈추게 하는 ‘Stop Sequence’(예: <code>\nObservation:</code>) 설정이 필수적이다. 런타임은 생성된 텍스트에서 도구 이름과 인자를 정규표현식 등으로 파싱한다.</li>
<li><strong>도구 실행(Tool Execution):</strong> 파싱된 도구(예: <code>Search</code>)를 실제 Python 함수로 호출하여 결과값을 얻는다.</li>
<li><strong>관찰 주입(Observation Injection):</strong> 도구 실행 결과를 <code>Observation:</code> 뒤에 텍스트로 붙여 프롬프트를 업데이트한다.</li>
<li><strong>반복:</strong> 업데이트된 프롬프트로 다시 LLM을 호출하여 다음 <code>Thought</code>를 생성한다.</li>
</ol>
<p>이 과정에서 파싱 에러가 발생하거나 도구 실행이 실패할 경우, 해당 에러 메시지(“Invalid Tool Name” 등)를 관찰 값으로 주입하여 모델이 스스로 수정(Self-correction)할 기회를 주는 것이 중요하다.14</p>
<h2>5.  주요 구현 프레임워크 상세 분석: LangChain vs. LlamaIndex</h2>
<p>ReAct 패턴을 밑바닥부터 구현하는 것은 복잡하므로, 대부분의 개발자는 LangChain이나 LlamaIndex와 같은 오케스트레이션 프레임워크를 사용한다. 두 프레임워크는 ReAct를 구현하는 철학적 접근과 코드 구조에서 뚜렷한 차이를 보인다.</p>
<h3>5.1  LangChain: 범용 에이전트 및 그래프 기반 제어</h3>
<p>LangChain은 에이전트 구축을 위한 가장 유연하고 포괄적인 도구 세트를 제공한다.</p>
<ul>
<li><strong>구조적 특징:</strong> 핵심 컴포넌트는 <code>AgentExecutor</code>이다. 이는 에이전트(LLM + 프롬프트)와 도구(Tools) 리스트를 받아 실행 루프를 관리한다. 최근에는 <code>LangGraph</code>가 도입되면서, 에이전트의 상태(State)를 노드와 엣지로 구성된 그래프로 관리하는 방식으로 진화했다.</li>
<li><strong>구현 상세:</strong></li>
<li><code>create_react_agent</code>: LLM, 도구, 프롬프트를 결합하여 <code>Runnable</code> 객체를 생성한다.</li>
<li><strong>도구 정의:</strong> <code>@tool</code> 데코레이터를 사용하여 파이썬 함수를 도구로 변환하며, 이때 함수의 docstring은 LLM이 도구 사용 여부를 판단하는 핵심 단서가 된다.14</li>
<li><strong>메모리 관리:</strong> LangGraph를 사용할 경우, 모든 대화 이력을 단순히 문맥에 쌓는 대신 <code>AgentState</code> 객체에 구조화하여 저장함으로써 토큰 효율성을 제어할 수 있다. 이는 ReAct의 고질적인 문제인 토큰 폭증(Token Bloat)을 완화하는 데 효과적이다.16</li>
</ul>
<h3>5.2  LlamaIndex: 데이터 중심(Data-Centric) 에이전트</h3>
<p>LlamaIndex는 방대한 데이터 소스에 대한 검색 및 질의응답(RAG)을 에이전트의 핵심 능력으로 통합하는 데 강점이 있다.</p>
<ul>
<li><strong>구조적 특징:</strong> <code>ReActAgent</code> 클래스가 중심이 된다. LangChain과 달리 데이터 인덱스(Vector Store)를 조회하는 <code>QueryEngine</code>을 하나의 도구(<code>QueryEngineTool</code>)로 캡슐화하여 에이전트에게 제공하는 패턴이 일반적이다.18</li>
<li><strong>구현 상세:</strong></li>
<li><strong>객체 지향적 설계:</strong> <code>ReActAgent.from_tools(tools, llm=..., verbose=True)</code>와 같이 직관적인 API를 제공한다.</li>
<li><strong>컨텍스트 관리:</strong> <code>Context</code> 객체를 통해 대화 기록(Chat History)을 관리하며, 이를 통해 에이전트가 이전 턴의 대화 내용을 기억하고 문맥을 유지한다.19</li>
<li><strong>스트리밍 지원:</strong> <code>agent.stream_chat</code> 또는 <code>agent.run(..., streaming=True)</code> 메서드를 통해 ReAct의 각 단계(생각-행동-관찰)가 생성되는 과정을 실시간으로 사용자에게 보여줄 수 있다. 이는 사용자가 에이전트의 사고 과정을 투명하게 지켜볼 수 있게 하여 UX 측면에서 유리하다.20</li>
</ul>
<h3>5.3  비교 요약</h3>
<table><thead><tr><th><strong>특성</strong></th><th><strong>LangChain (LangGraph)</strong></th><th><strong>LlamaIndex</strong></th></tr></thead><tbody>
<tr><td><strong>주요 철학</strong></td><td>워크플로우 제어, 그래프 기반 상태 관리</td><td>데이터 검색 및 RAG 통합 최적화</td></tr>
<tr><td><strong>핵심 클래스</strong></td><td><code>AgentExecutor</code>, <code>StateGraph</code></td><td><code>ReActAgent</code>, <code>AgentRunner</code></td></tr>
<tr><td><strong>도구 통합</strong></td><td>범용 함수, API 래퍼 중심</td><td><code>QueryEngine</code>, <code>Retriever</code> 등 데이터 파이프라인 중심</td></tr>
<tr><td><strong>복잡성</strong></td><td>높음 (세밀한 제어 가능)</td><td>중간 (빠른 구축 용이)</td></tr>
<tr><td><strong>상태 관리</strong></td><td>메시지 히스토리 + 커스텀 상태 객체</td><td><code>Context</code> 및 메모리 버퍼</td></tr>
</tbody></table>
<p>21의 분석에 따르면, 복잡한 비즈니스 로직과 다양한 API 제어가 필요하다면 LangChain이, 문서 기반의 질의응답과 데이터 분석이 주 목적이라면 LlamaIndex가 더 적합한 선택이 될 수 있다.</p>
<h2>6.  실패 분석(Failure Analysis)과 오류 전파(Error Propagation)</h2>
<p>ReAct 에이전트는 강력하지만, 실제 운영 환경에서는 다양한 실패 모드를 보인다. Stanford 대학 등의 연구23에 따르면, 에이전트의 실패는 단일 원인보다는 여러 단계에 걸친 오류의 연쇄 작용(Cascading Errors)에 기인하는 경우가 많다.</p>
<h3>6.1  오류 전파의 메커니즘</h3>
<p>ReAct의 순차적 특성상 초기 단계의 작은 오류는 치명적인 결과를 초래한다.</p>
<ul>
<li><strong>초기 검색 실패:</strong> 첫 번째 <code>Thought</code>에서 검색 키워드를 잘못 선정하거나, <code>Action</code> 결과로 무의미한 정보(Null result)가 반환되면, 모델은 이 잘못된 <code>Observation</code>을 사실로 받아들인다. 이후의 모든 <code>Thought</code>는 이 오염된 정보를 바탕으로 진행되므로, 논리적으로는 타당해 보일지라도 결과적으로는 환각이나 오답으로 이어진다.15</li>
<li><strong>잘못된 도구 선택:</strong> 도구 설명(Docstring)이 모호하거나 모델의 이해력이 부족할 경우, 적절하지 않은 도구를 선택하거나 도구의 인자(Argument) 형식을 틀리는 오류가 발생한다.</li>
</ul>
<h3>6.2  주요 실패 유형 (Taxonomy of Failures)</h3>
<ol>
<li><strong>환각적 행동(Hallucinated Action):</strong> 존재하지 않는 도구를 호출하거나, 도구가 제공하지 않는 기능을 요청하는 경우이다. 예를 들어 <code>Search</code> 도구만 있는데 <code>EmailSender</code>를 호출하려 시도하는 상황이다.</li>
<li><strong>루프 및 고착(Looping &amp; Getting Stuck):</strong> 모델이 동일한 <code>Thought</code>와 <code>Action</code>을 반복하는 현상이다. “정보를 찾지 못했다“는 관찰을 받고도 계속해서 같은 검색어를 입력하는 무한 루프에 빠지는 경우가 빈번하다. 이를 방지하기 위해 최대 반복 횟수(<code>max_iterations</code>) 제한이나, 이전 행동과 동일한 행동을 감지하여 페널티를 주는 로직이 필요하다.14</li>
<li><strong>문맥 윈도우 초과(Context Overflow):</strong> 관찰 결과(예: 웹 페이지 전체 텍스트)가 너무 길어 LLM의 입력 토큰 한도를 초과하는 경우이다. 이 경우 프롬프트의 앞부분(시스템 지시문이나 퓨샷 예시)이 잘려나가면서 에이전트가 자신의 역할이나 출력 포맷을 망각(Catastrophic Forgetting)하게 된다. 이는 에이전트가 갑자기 JSON 형식을 깨뜨리거나 횡설수설하는 원인이 된다.15</li>
<li><strong>포맷 준수 실패:</strong> 모델이 <code>Action:...</code> 형식을 지키지 않고 일반 대화체로 답변하거나, 파싱할 수 없는 형태의 텍스트를 생성하여 런타임 에러를 유발한다.</li>
</ol>
<h2>7.  ReAct의 확장과 미래 전망: Reflexion과 Tree of Thoughts</h2>
<p>ReAct의 한계를 극복하기 위해 더 고차원적인 인지 아키텍처들이 연구되고 있다.</p>
<h3>7.1  Reflexion: 자기 성찰을 통한 메타 인지</h3>
<p>Reflexion은 ReAct 루프 위에 ’평가(Evaluator)’와 ‘자기 성찰(Self-Reflection)’ 단계를 추가한 프레임워크이다. ReAct 에이전트가 과제 수행에 실패했을 때, Reflexion 에이전트는 단순히 종료하는 대신 실패의 원인을 분석한다.</p>
<ul>
<li><strong>작동 방식:</strong> “왜 정답을 찾지 못했지?“라는 질문에 대해 “검색어가 너무 구체적이어서 결과가 없었다“라는 언어적 피드백(Verbal Feedback)을 생성한다.</li>
<li><strong>메모리 활용:</strong> 이 피드백은 장기 기억(Long-term Memory)에 저장되어, 다음 시도(Next Episode) 때 문맥에 추가된다. 에이전트는 “지난번에 검색어가 문제였으니 이번에는 더 포괄적으로 검색하자“라고 전략을 수정하게 된다. 이는 ReAct의 오류 전파 문제를 사후 교정으로 해결하는 강력한 방법론이다.27</li>
</ul>
<h3>7.2  Tree of Thoughts (ToT): 비선형적 탐색</h3>
<p>ReAct가 하나의 사고 흐름(Chain)을 따라가는 선형적 구조라면, Tree of Thoughts(ToT)는 가능한 여러 개의 사고 경로를 트리 형태로 확장하고 탐색한다.</p>
<ul>
<li><strong>전략적 탐색:</strong> 각 단계에서 모델은 여러 개의 가능한 다음 단계(Candidates)를 생성하고, 각 후보의 유망함(Promisingness)을 평가한다. 만약 특정 경로가 가망이 없다고 판단되면, 이전 단계로 돌아가(Backtracking) 다른 경로를 탐색한다.</li>
<li><strong>비용과 성능의 트레이드오프:</strong> ToT는 ReAct보다 훨씬 더 복잡하고 창의적인 문제 해결이 가능하지만, 추론 비용(토큰 사용량)이 기하급수적으로 증가한다는 단점이 있다.29</li>
</ul>
<h3>7.3  파인튜닝(Fine-tuning)과 소형 모델의 에이전트화</h3>
<p>GPT-4와 같은 거대 모델은 프롬프트만으로 ReAct를 잘 수행하지만, 소형 모델(7B, 13B 파라미터)은 추론 능력이 부족하여 ReAct 패턴을 따르기 어렵다. 이를 해결하기 위해 FireAct나 Toolformer와 같은 연구는 고성능 모델이 생성한 ReAct 궤적(Trajectory) 데이터를 사용하여 소형 모델을 미세조정(Fine-tuning)한다. 이를 통해 소형 모델도 퓨샷 예시 없이(Zero-shot) 도구를 능숙하게 사용하고 추론을 수행할 수 있게 되며, 운영 비용과 지연 시간을 획기적으로 줄일 수 있다.8</p>
<h2>8.  결론</h2>
<p>ReAct 프레임워크는 대규모 언어 모델을 정적인 지식 창고에서 동적인 문제 해결의 주체로 격상시킨 AI 기술의 중요한 이정표이다. 인간의 인지 과정인 추론과 행동의 결합을 모방함으로써, ReAct는 모델이 스스로 부족한 정보를 탐색하고(Grounding), 복잡한 계획을 수립하며(Planning), 변화하는 환경에 적응(Adaptation)할 수 있는 길을 열었다.</p>
<p>본 보고서의 분석 결과, ReAct는 기존의 CoT나 Act-only 접근법 대비 사실적 정확성과 행동의 효율성 면에서 탁월한 성능을 보였으며, LangChain과 LlamaIndex와 같은 현대적 프레임워크의 근간이 되었다. 그러나 토큰 비용 증가, 지연 시간, 오류 전파와 같은 현실적인 과제들도 여전히 존재한다. 향후 에이전트 기술의 발전은 ReAct를 기반으로 하여, 실패로부터 배우는 Reflexion, 다각적 탐색을 수행하는 ToT, 그리고 효율성을 극대화하는 미세조정 기술들이 결합되는 방향으로 나아갈 것이다. ReAct는 단순한 프롬프팅 기법을 넘어, 인공지능이 인간과 협업하고 물리/디지털 세계에서 실질적인 가치를 창출하는 범용 에이전트(AGI)로 진화하는 데 있어 필수 불가결한 아키텍처로 평가된다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>ReAct: Synergizing Reasoning and Acting in Language Models - GitHub Pages, https://astrocvijo.github.io/react_reproduction/react_reproduction.pdf</li>
<li>[2210.03629] ReAct: Synergizing Reasoning and Acting in Language Models - arXiv, https://arxiv.org/abs/2210.03629</li>
<li>ReAct-Based Action Strategy - Emergent Mind, https://www.emergentmind.com/topics/react-based-action-strategy</li>
<li>ReAct: Synergizing Reasoning and Acting in Language Models - arXiv, https://arxiv.org/pdf/2210.03629</li>
<li>ReAct: The Power of Reasoning and Acting in LLM Agents | by Sangeethasaravanan, https://medium.com/@sangeethasaravanan/react-the-power-of-reasoning-and-acting-in-llm-agents-3332c95b1e25</li>
<li>ReAct prompting in LLM : Redefining AI with Synergized Reasoning and Acting - Medium, https://medium.com/@sahin.samia/react-prompting-in-llm-redefining-ai-with-synergized-reasoning-and-acting-c19640fa6b73</li>
<li>REACT: SYNERGIZING REASONING AND ACTING IN LANGUAGE MODELS, https://collaborate.princeton.edu/en/publications/react-synergizing-reasoning-and-acting-in-language-models/</li>
<li>ReAct: Synergizing Reasoning and Acting in Language Models - Google Research, https://research.google/blog/react-synergizing-reasoning-and-acting-in-language-models/</li>
<li>How does LangChain actually implement the ReAct pattern on a high level? - Reddit, https://www.reddit.com/r/LangChain/comments/17puzw9/how_does_langchain_actually_implement_the_react/</li>
<li>ReAct: Synergizing Reasoning and Acting in Language Models - ResearchGate, https://www.researchgate.net/publication/364290390_ReAct_Synergizing_Reasoning_and_Acting_in_Language_Models</li>
<li>ReAct: Synergizing Reasoning and Acting in Language Models, https://react-lm.github.io/</li>
<li>ReAct: Merging Reasoning and Action to Elevate AI Task Solving - Oct 28, 2024 - Neradot, https://www.neradot.com/post/react</li>
<li>How Does The ReAct Prompting Technique Work? - - God of Prompt, https://www.godofprompt.ai/blog/how-does-the-react-prompting-technique-work</li>
<li>LangChain ReAct Agent: Complete Implementation Guide + …, https://latenode.com/blog/ai-frameworks-technical-infrastructure/langchain-setup-tools-agents-memory/langchain-react-agent-complete-implementation-guide-working-examples-2025</li>
<li>Exploring Autonomous Agents: A Closer Look at Why They Fail When Completing Tasks, https://arxiv.org/html/2508.13143v1</li>
<li>Fixed LangGraph ReAct agent issues: token bloat and non-deterministic LLM behavior, https://www.reddit.com/r/learnpython/comments/1lj4oru/fixed_langgraph_react_agent_issues_token_bloat/</li>
<li>Solved two major LangGraph ReAct agent problems: token bloat and lazy LLMs - Reddit, https://www.reddit.com/r/LangChain/comments/1lj4mq7/solved_two_major_langgraph_react_agent_problems/</li>
<li>Learn how to build a ReAct AI Agent using LlamaIndex, https://www.gettingstarted.ai/llamaindex-ai-agent/</li>
<li>ReActAgent - A Simple Intro with Calculator Tools | LlamaIndex …, https://developers.llamaindex.ai/python/examples/agent/react_agent/</li>
<li>Workflow for a ReAct Agent | LlamaIndex Python Documentation, https://developers.llamaindex.ai/python/examples/workflow/react_agent/</li>
<li>LlamaIndex vs LangChain: Which Framework Is Best for Agentic AI Workflows? - ZenML, https://www.zenml.io/blog/llamaindex-vs-langchain</li>
<li>What Is The Difference Between LlamaIndex vs LangChain? How To Choose?, https://www.designveloper.com/blog/llamaindex-vs-langchain/</li>
<li>Why AI Agents Fail: The Hidden Pattern Behind Catastrophic Breakdowns - Medium, https://medium.com/@mohamedelhaddioui99/why-ai-agents-fail-the-hidden-pattern-behind-catastrophic-breakdowns-6e5fa5ec1d9a</li>
<li>7 AI Agent Failure Modes and How To Fix Them | Galileo, https://galileo.ai/blog/agent-failure-modes-guide</li>
<li>Exploring LLM-based Agents for Root Cause Analysis - arXiv, https://arxiv.org/html/2403.04123v1</li>
<li>Using LLM with ReAct Agent. Introduction | by Nisarg Mehta | Medium, https://medium.com/@nisargmehta1406/using-llm-with-react-agent-8b25db6e87cb</li>
<li>Agentic Reasoning Patterns Explained: ReAct, Reflexion, Plan-and-Execute &amp; Tree of Thoughts - Services Ground, https://servicesground.com/blog/agentic-reasoning-patterns/</li>
<li>Reflexion | Prompt Engineering Guide, https://www.promptingguide.ai/techniques/reflexion</li>
<li>Comparing Reasoning Frameworks: ReAct, Chain-of-Thought, and Tree-of-Thoughts | by allglenn | Stackademic, https://blog.stackademic.com/comparing-reasoning-frameworks-react-chain-of-thought-and-tree-of-thoughts-b4eb9cdde54f</li>
<li>Prompt Engineering: From Zero-Shot to Advanced AI Reasoning - Bluetick Consultants Inc., https://www.bluetickconsultants.com/the-evolution-of-prompt-engineering/</li>
<li>LLM Agents - Prompt Engineering Guide, https://www.promptingguide.ai/research/llm-agents</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>