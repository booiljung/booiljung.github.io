<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:GoT (Graph-of-Thoughts, 사고의 그래프, 2023-08-18)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>GoT (Graph-of-Thoughts, 사고의 그래프, 2023-08-18)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">작업 계획 (Task Planning)</a> / <span>GoT (Graph-of-Thoughts, 사고의 그래프, 2023-08-18)</span></nav>
                </div>
            </header>
            <article>
                <h1>GoT (Graph-of-Thoughts, 사고의 그래프, 2023-08-18)</h1>
<h2>1.  서론: 인공지능 추론의 패러다임 전환</h2>
<h3>1.1  대규모 언어 모델의 현주소와 한계</h3>
<p>현대 인공지능 연구의 최전선에서 대규모 언어 모델(Large Language Models, LLMs)은 텍스트 생성, 번역, 요약 등 다양한 자연어 처리(NLP) 과제에서 인간에 필적하거나 이를 상회하는 성능을 입증하고 있다. GPT-4, PaLM, LLaMA와 같은 모델들은 수십억 개 이상의 파라미터를 통해 방대한 지식을 학습하고, 이를 바탕으로 유창한 언어적 반응을 생성한다.1 그러나 이러한 모델들의 눈부신 성과 이면에는 근본적인 아키텍처적 한계가 존재한다. 바로 ‘자기회귀적(autoregressive)’ 텍스트 생성 메커니즘이다.</p>
<p>기본적으로 LLM은 이전에 생성된 토큰들을 기반으로 다음 토큰을 확률적으로 예측하여 순차적으로 텍스트를 생성한다. 이는 본질적으로 ‘왼쪽에서 오른쪽으로(left-to-right)’ 진행되는 선형적 과정이다. 이러한 선형성은 인간의 언어 생성 방식을 모사하는 데에는 효과적일지 모르나, 인간의 복잡한 ‘사고(thinking)’ 과정을 담아내기에는 구조적으로 불충분하다.1 인간이 난해한 문제에 직면했을 때 보이는 인지 과정은 결코 단선적이지 않다. 인간은 직관적으로 아이디어를 떠올리고(Generation), 그 아이디어를 논리적으로 전개하다가(Chain), 오류를 발견하면 즉시 이전 단계로 되돌아가 수정하며(Backtracking), 서로 관련 없어 보이던 두 가지 이상의 아이디어를 결합하여(Aggregation) 새로운 통찰을 얻는다. 때로는 하나의 생각을 끊임없이 다듬고 정제하는 순환적 사고(Recurrence)를 거치기도 한다.1</p>
<p>기존의 LLM 활용 방식인 입출력(Input-Output, IO) 프롬프팅은 이러한 복잡한 인지 과정을 모델 내부의 ’블랙박스’에 전적으로 의존한다. 모델이 한 번의 시도(pass)로 완벽한 답을 내놓기를 기대하는 것이다. 이는 마치 수학 문제를 풀 때 연습장에 중간 계산 과정을 적지 않고 암산으로만 답을 내려는 것과 같다. 쉬운 문제라면 가능하겠지만, 복잡한 논리나 알고리즘적 사고가 필요한 문제에서는 실패할 확률이 급격히 높아진다. 이러한 한계를 극복하기 위해 등장한 것이 바로 프롬프트 엔지니어링(Prompt Engineering)의 구조적 진화이다.5</p>
<h3>1.2  프롬프트 엔지니어링의 진화: 사슬에서 트리로</h3>
<pre><code class="language-mermaid">graph TD
    subgraph Graph_of_Thoughts_GoT[Graph of Thoughts, GoT]
        GoT_1["Thought A"] --&gt; GoT_2["Thought B"]
        GoT_1 --&gt; GoT_3["Thought C"]
        GoT_2 --&gt; GoT_4["Aggregation (B+C)"]
        GoT_3 --&gt; GoT_4
        GoT_4 --&gt; GoT_4["Refinement Loop"]
        GoT_4 --&gt; GoT_Out["Final Thought"]
        style GoT_1 fill:#f9f,stroke:#333
        style GoT_4 fill:#9ff,stroke:#333
    end
    
    subgraph Tree_of_Thoughts_ToT[Tree-of-Thoughts, ToT]
        ToT_Root["Root"] --&gt; ToT_B1["Branch A"]
        ToT_Root --&gt; ToT_B2["Branch B"]
        ToT_B1 --&gt; ToT_L1["Leaf A1"]
        ToT_B1 --&gt; ToT_L2["Leaf A2"]
        ToT_B2 --&gt; ToT_L3["Leaf B1"]
        style ToT_Root fill:#f9f,stroke:#333
    end

    subgraph Chain_of_Thought_CoT[Chain-of-Thought, CoT]
        CoT_1["Thought 1"] --&gt; CoT_2["Thought 2"]
        CoT_2 --&gt; CoT_3["Thought 3"]
        CoT_3 --&gt; CoT_Out["Output"]
        style CoT_1 fill:#f9f,stroke:#333
    end

    subgraph IO_Prompting[IO Prompting]
        IO_In["Input"] --&gt; IO_Out["Output"]
        style IO_In fill:#f9f,stroke:#333
        style IO_Out fill:#9f9,stroke:#333
    end
</code></pre>
<p>프롬프트 엔지니어링은 단순히 모델에게 질문하는 방식을 바꾸는 기법을 넘어, 모델의 잠재된 추론 능력을 이끌어내는 인지적 비계(scaffolding)를 설계하는 학문으로 발전했다.</p>
<p>가장 먼저 주목받은 혁신은 **사슬형 사고(Chain-of-Thought, CoT)**였다. CoT는 “단계별로 생각해 보자(Let’s think step by step)“라는 단순한 유도나 중간 추론 과정을 예시로 보여줌으로써, 모델이 최종 답변을 내리기 전에 논리적 근거를 생성하도록 만든다.6 이는 LLM의 성능을 수학적 추론과 상식 추론 영역에서 획기적으로 향상시켰다. 그러나 CoT는 여전히 선형적인 ‘사슬’ 구조에 갇혀 있다. 한 번 생성된 생각의 사슬은 수정될 수 없으며, 초기에 잘못된 논리 단계가 발생하면 그 오류가 사슬의 끝까지 전파되어 잘못된 결론에 도달하는 ‘오류 전파(error propagation)’ 문제에 취약하다.7 또한, 여러 가지 가능성을 동시에 고려하거나 비교할 수 있는 유연성이 부족하다.</p>
<p>이러한 선형성을 극복하기 위해 **트리형 사고(Tree-of-Thoughts, ToT)**가 제안되었다. ToT는 추론 과정을 트리 구조로 모델링하여, 각 단계에서 하나의 생각만이 아니라 여러 개의 대안적 생각(multiple reasoning paths)을 생성하고 탐색한다.3 ToT는 너비 우선 탐색(BFS)이나 깊이 우선 탐색(DFS)과 같은 고전적인 탐색 알고리즘을 LLM의 추론 과정에 접목시켰다. 이를 통해 모델은 유망하지 않은 경로를 가지치기(pruning)하거나, 막다른 길에 다다랐을 때 이전 상태로 되돌아가(backtracking) 다른 경로를 탐색할 수 있는 능력을 갖게 되었다. ToT는 ’24 게임(Game of 24)’이나 창의적 글쓰기와 같은 과제에서 CoT를 압도하는 성능을 보여주었다.</p>
<p>하지만 ToT 역시 한계를 드러낸다. 트리는 계층적 구조를 강제하므로, 서로 다른 가지(branch)에서 파생된 유용한 정보들을 수평적으로 연결하거나 통합하는 것이 불가능하다.1 예를 들어, 문제의 절반은 A 경로에서, 나머지 절반은 B 경로에서 잘 해결했다면, 인간은 이 둘을 합쳐 완벽한 답을 만들어낸다. 그러나 ToT 구조에서는 A 경로와 B 경로는 서로의 존재를 알지 못하며, 독립적으로 최종 잎(leaf) 노드를 향해 나아갈 뿐이다. 또한, 트리는 본질적으로 비순환적(acyclic)이어서, 특정 생각을 반복적으로 개선하는 순환적 사고를 자연스럽게 표현하기 어렵다. 이는 곧 탐색 공간의 비효율적 사용과 높은 비용으로 이어진다.8</p>
<h3>1.3  사고의 그래프(Graph-of-Thoughts)의 제안</h3>
<p>이러한 배경 속에서 Besta et al. (2024)은 인간의 사고 과정과 뇌의 신경망 구조, 그리고 알고리즘의 데이터 흐름이 모두 복잡한 네트워크 형태를 띤다는 점에 착안하여 **사고의 그래프(Graph-of-Thoughts, GoT)**를 제안하였다.1 GoT는 LLM의 추론 단위를 그래프의 정점(vertex)으로, 정점 간의 의존 관계를 간선(edge)으로 정의함으로써, 추론 과정을 <strong>임의의 그래프(Arbitrary Graph)</strong> 구조로 모델링한다.</p>
<p>GoT는 기존 CoT와 ToT가 가진 구조적 제약을 완전히 철폐한다. 방향성 비순환 그래프(DAG)는 물론, 순환(Cycle) 구조까지 포용함으로써 다음과 같은 혁신적인 추론 패턴을 가능하게 한다:</p>
<ol>
<li><strong>정보의 통합(Aggregation):</strong> 서로 다른 추론 경로에서 생성된 정보들을 하나의 정점으로 모아 시너지를 창출한다.</li>
<li><strong>순환적 정제(Refinement):</strong> 피드백 루프를 통해 특정 생각을 반복적으로 수정하고 개선한다.</li>
<li><strong>유연한 구조 변경:</strong> 작업의 성격에 따라 그래프의 위상(topology)을 동적으로 구성한다.</li>
</ol>
<p>본 보고서는 GoT 프레임워크의 이론적 배경부터 시스템 아키텍처, 구체적인 구현 방법론, 그리고 다양한 벤치마크에서의 성능 평가까지 포괄적으로 분석한다. 특히 GoT가 어떻게 기존 방법론들의 비용 비효율성을 극복하고 ’생각의 부피(Volume of a Thought)’라는 새로운 차원의 가치를 창출하는지에 대해 심층적으로 논의할 것이다. 이는 단순한 기술적 분석을 넘어, LLM을 인간 수준의 문제 해결 능력을 갖춘 지능형 에이전트로 진화시키는 데 필요한 청사진을 제시하는 것을 목표로 한다.</p>
<h2>2.  이론적 배경 및 개념 정의</h2>
<p>GoT를 깊이 이해하기 위해서는 이를 뒷받침하는 수학적 모델과 그래프 이론적 개념들을 명확히 정립할 필요가 있다. GoT는 단순한 비유가 아니라, LLM의 추론 과정을 그래프 연산(Graph Operations)으로 환원하여 해석하는 엄밀한 프레임워크이다.</p>
<h3>2.1  GoT의 수학적 모델링</h3>
<p>Besta et al.은 GoT를 4개의 요소로 구성된 튜플 <span class="math math-inline">(G, T, E, R)</span>로 정의한다.4</p>
<ul>
<li><strong><span class="math math-inline">G</span> (LLM Reasoning Process):</strong> <span class="math math-inline">G = (V, E)</span>는 추론 과정을 나타내는 유향 그래프(Directed Graph)이다.</li>
<li><strong>정점 (<span class="math math-inline">V</span>, Vertices):</strong> 각 정점 <span class="math math-inline">v \in V</span>는 LLM이 생성한 ’생각(Thought)’을 나타낸다. 여기서 ’생각’이란 문제 해결 과정에서의 중간 단계 결과물, 문장, 방정식, 코드 조각 등 정보의 단위이다.</li>
<li><strong>간선 (<span class="math math-inline">E</span>, Edges):</strong> 각 간선 <span class="math math-inline">(u, v) \in E</span>는 생각 <span class="math math-inline">u</span>가 생각 <span class="math math-inline">v</span>를 생성하는 데 직접적인 입력으로 사용되었음을 의미하는 의존 관계(dependency)를 나타낸다. 즉, <span class="math math-inline">v</span>는 <span class="math math-inline">u</span>를 기반으로 파생된 생각이다.</li>
<li><strong><span class="math math-inline">T</span> (Potential Thought Transformations):</strong> <span class="math math-inline">T</span>는 기존의 생각들을 변형하여 새로운 생각을 생성하는 연산들의 집합이다. 예를 들어, 통합(Aggregation), 정제(Refinement), 생성(Generation) 등이 여기에 포함된다. <span class="math math-inline">T</span>는 그래프 <span class="math math-inline">G</span>의 구조를 동적으로 확장하는 규칙이다.</li>
<li><strong><span class="math math-inline">E</span> (Evaluator Function):</strong> <span class="math math-inline">E(v, G)</span>는 특정 생각 <span class="math math-inline">v</span>의 품질이나 유효성을 평가하여 점수를 부여하는 함수이다. 이 점수는 그래프 탐색 과정에서 어떤 경로를 유지하고 어떤 경로를 폐기할지 결정하는 기준이 된다. GoT에서는 주로 LLM 자체를 평가자로 활용한다.</li>
<li><strong><span class="math math-inline">R</span> (Ranking Function):</strong> <span class="math math-inline">R(G, E)</span>는 평가 함수 <span class="math math-inline">E</span>의 결과를 바탕으로 가장 유망한 생각들을 선택하거나 정렬하는 함수이다.</li>
</ul>
<pre><code class="language-mermaid">mindmap
  root(("GoT 프레임워크"))
    ("G: 추론 과정 (Reasoning Process)")
      ("V: 정점 (Vertices) - 생각의 단위")
      ("E: 간선 (Edges) - 의존 관계")
    ("T: 생각 변환 (Transformations)")
      ("통합 (Aggregation)")
      ("정제 (Refinement)")
      ("생성 (Generation)")
    ("E: 평가 함수 (Evaluator Function)")
      ("생각의 점수 부여")
      ("유효성 검증")
    ("R: 순위 함수 (Ranking Function)")
      ("유망한 생각 선택")
      ("탐색 경로 결정")
</code></pre>
<pre><code class="language-mermaid">graph TD
    Process("G: 추론 과정 (Graph)")
    Trans("T: 변환 규칙 (Transformations)")
    Eval("E: 평가 함수 (Evaluator)")
    Rank("R: 순위 함수 (Ranking)")
    
    Trans -- "새로운 정점/간선 생성" --&gt; Process
    Process -- "현재 그래프 상태 제공" --&gt; Eval
    Eval -- "점수(Scores) 부여" --&gt; Process
    Process -- "점수화된 생각들 제공" --&gt; Rank
    Rank -- "가장 유망한 경로 선택" --&gt; Trans
    
    subgraph "순환적 진화 (Cycle)"
    Process
    end
    
    style Process fill:#bbdefb,stroke:#1e88e5
    style Trans fill:#fff9c4
    style Eval fill:#f8bbd0
    style Rank fill:#d1c4e9
</code></pre>
<h3>2.2  위상학적 관점에서의 비교</h3>
<p>기존 프롬프트 전략들은 GoT의 특수한 하위 집합(subset)으로 해석될 수 있다. 위상학적(topological) 관점에서 이를 비교하면 GoT의 확장성을 명확히 이해할 수 있다.1</p>
<table><thead><tr><th><strong>프롬프트 전략</strong></th><th><strong>그래프 구조 (Topology)</strong></th><th><strong>특징 및 한계</strong></th></tr></thead><tbody>
<tr><td><strong>입출력 (IO)</strong></td><td>단일 노드 (Single Node)</td><td><span class="math math-inline">V=\{v_{in}, v_{out}\}</span>, <span class="math math-inline">E=\{(v_{in}, v_{out})\}</span> 중간 추론 과정이 전무함.</td></tr>
<tr><td><strong>CoT (Chain-of-Thought)</strong></td><td>선형 사슬 (Line)</td><td>각 노드는 정확히 하나의 부모와 하나의 자식을 가짐 (시작/끝 제외). 분기(Branching)나 병합(Merging)이 불가능함.</td></tr>
<tr><td><strong>CoT-SC (Self-Consistency)</strong></td><td>분절된 사슬들의 집합 (Disjoint Lines)</td><td>여러 개의 CoT를 독립적으로 실행한 후, 최종 결과만 다수결로 투표. 실행 중간에 정보 교환이 없음.</td></tr>
<tr><td><strong>ToT (Tree-of-Thoughts)</strong></td><td>트리 (Tree)</td><td>하나의 부모가 여러 자식을 가질 수 있음(분기). 그러나 자식이 여러 부모를 가질 수 없음(병합 불가). 순환(Cycle)이 불가능함.</td></tr>
<tr><td><strong>GoT (Graph-of-Thoughts)</strong></td><td><strong>임의의 그래프 (Arbitrary Graph)</strong></td><td><strong>다수의 부모를 가진 노드 허용 (병합/통합).</strong> <strong>순환 허용 (반복적 정제).</strong> <strong>비연결 성분 허용 (독립적 사고 후 연결).</strong></td></tr>
</tbody></table>
<p>이 비교표에서 알 수 있듯이, GoT는 그래프의 연결성(connectivity)에 제한을 두지 않음으로써 가장 높은 자유도를 제공한다. 이는 문제 해결 과정에서 필요한 모든 종류의 정보 흐름을 모델링할 수 있음을 의미한다. 특히 ’다수의 부모(multiple parents)’를 가질 수 있다는 점은 GoT가 ToT와 구별되는 결정적인 차별점이다. 이는 정보의 수렴(convergence)을 가능하게 하며, 이는 분할 정복(Divide and Conquer) 알고리즘이나 변증법적 추론(정-반-합)을 구현하는 데 필수적이다.1</p>
<h3>2.3  인간 사고와 뇌 메커니즘의 모방</h3>
<p>GoT의 설계 철학은 인간의 인지 과학 및 뇌과학과 깊이 연관되어 있다. Besta et al.은 인간의 뇌가 복잡한 네트워크 구조를 형성하며, 특히 ’재귀(Recurrence)’와 같은 그래프적 패턴을 통해 사고한다는 점을 강조한다.1 인간이 글을 쓸 때를 예로 들어보자. 우리는 초안을 작성하고(Generation), 이를 다시 읽으며 수정하고(Refinement Loop), 다른 자료에서 읽은 내용을 가져와 합치기도 한다(Aggregation). 이러한 과정은 결코 한 방향으로만 흐르는 사슬이나 가지치기만 하는 트리가 아니다. 아이디어들은 서로 얽히고설키며, 뒤로 돌아가기도 하고, 합쳐지기도 하는 복잡한 그래프를 형성한다. GoT는 LLM에게 이러한 ‘인간적인’ 사고의 자유를 부여함으로써, 단순히 텍스트를 생성하는 기계가 아니라 사고하는 주체로서의 가능성을 열어준다.</p>
<h2>3.  GoT 시스템 아키텍처 및 구현</h2>
<p>이론적으로 정립된 GoT를 실제 소프트웨어로 구현하기 위해서는 정교한 시스템 아키텍처가 필요하다. Besta et al.은 모듈화된 설계를 통해 LLM의 추론 과정을 세밀하게 제어하고 확장 가능성을 확보하였다. GoT 프레임워크는 크게 <strong>컨트롤러(Controller)</strong>, <strong>작업 그래프(Graph of Operations, GoO)</strong>, <strong>그래프 추론 상태(Graph Reasoning State, GRS)</strong>, <strong>프롬프터(Prompter)</strong>, <strong>파서(Parser)</strong>, **채점 모듈(Scoring Module)**로 구성된다.1</p>
<pre><code class="language-mermaid">graph LR
    GoT_Model(("GoT Framework"))

    subgraph G_Reasoning_Process[G Reasoning Process]
        G["Graph G = (V, E)"]
        V["Vertices (V): Thoughts/States"]
        E_edge["Edges (E): Dependencies"]
        G --- V
        G --- E_edge
    end

    subgraph T_Transformations[T Transformations]
        T["Transformations (T)"]
        Agg["Aggregation (Merger)"]
        Ref["Refinement (Loop)"]
        Gen["Generation (Expansion)"]
        T --- Agg
        T --- Ref
        T --- Gen
    end

    subgraph E_Evaluator[E Evaluator]
        E_func["Evaluator Function (E)"]
        Score["Score Validity/Quality"]
        E_func --- Score
    end

    subgraph R_Ranking[R Ranking]
        R_func["Ranking Function (R)"]
        Select["Select Top Thoughts"]
        R_func --- Select
    end

    GoT_Model --&gt; G
    GoT_Model --&gt; T
    GoT_Model --&gt; E_func
    GoT_Model --&gt; R_func
</code></pre>
<h3>3.1  핵심 모듈 상세 분석</h3>
<pre><code class="language-mermaid">graph TD
    Start(("시작 (Start)")) --&gt; Init["GRS 및 GoO 초기화"]
    Init --&gt; CheckState{"목표 달성 여부 확인"}
    
    CheckState -- "달성 (Yes)" --&gt; Finish(("종료 및 결과 반환"))
    CheckState -- "미달성 (No)" --&gt; SelectTrans["GoO에서 다음 변환(Transformation) 선택"]
    
    SelectTrans --&gt; ExecuteTrans["프롬프터: LLM 호출 (Generate/Agg/Refine)"]
    ExecuteTrans --&gt; Parser["파서: 결과 추출 및 GRS 업데이트"]
    
    Parser --&gt; Score{"평가 (Scoring)"}
    
    Score -- "점수 미달 (Low Score)" --&gt; DecideFix{"수정 전략 결정"}
    DecideFix -- "폐기 (Prune)" --&gt; PruneNode["경로 삭제 (Pruning)"]
    DecideFix -- "재시도 (Retry)" --&gt; Refine["정제 연산 (Refinement) 추가"]
    
    Score -- "점수 통과 (Pass)" --&gt; Keep["GRS에 정점 확정"]
    
    PruneNode --&gt; CheckState
    Refine --&gt; ExecuteTrans
    Keep --&gt; CheckState

    style Start fill:#f9f,stroke:#333
    style Finish fill:#f9f,stroke:#333
    style Score fill:#fff9c4,stroke:#fbc02d
</code></pre>
<h4>3.1.1  컨트롤러 (Controller): 중앙 제어 장치</h4>
<p>컨트롤러는 GoT 시스템의 두뇌에 해당한다. 전체적인 추론 프로세스를 조율하고, 현재의 진행 상황(GRS)을 모니터링하며, 다음에 수행할 연산(Transformation)을 결정한다. 컨트롤러는 사용자가 정의한 실행 계획(GoO)을 기반으로 LLM과 상호작용하며, 각 단계에서 어떤 모듈을 호출할지 결정하는 스케줄러 역할을 수행한다.11</p>
<h4>3.1.2  작업 그래프 (Graph of Operations, GoO): 추론의 청사진</h4>
<p>GoO는 특정 문제를 해결하기 위한 전략을 그래프 형태로 정의한 것이다. 이는 실행 전에 정적으로 정의될 수도 있고, 실행 중에 동적으로 변경될 수도 있다. GoO는 LLM이 수행해야 할 사고의 변환 과정(Thought Transformations)과 그 순서를 명시한다. 예를 들어, 정렬 문제를 위한 GoO는 “입력 리스트를 분할(Generate) -&gt; 하위 리스트 정렬(Generate) -&gt; 정렬된 리스트 병합(Aggregate)“과 같은 일련의 연산 노드들로 구성된다.1 이는 프로그래밍에서의 ’함수 호출 그래프’나 워크플로우 엔진의 ’DAG’와 유사한 개념이다.</p>
<h4>3.1.3  그래프 추론 상태 (Graph Reasoning State, GRS): 동적 지식 베이스</h4>
<p>GRS는 추론이 진행됨에 따라 실시간으로 업데이트되는 데이터 구조이다. 여기에는 생성된 모든 생각(정점)들의 내용, 정점 간의 연결 관계(간선), 각 생각의 점수(Score), 그리고 각 생각이 유효한지 여부 등의 메타데이터가 저장된다. 컨트롤러는 GRS를 참조하여 중복 계산을 방지하고, 이전 단계의 생각들을 불러와 다음 단계의 프롬프트에 맥락(Context)으로 제공한다. GRS는 LLM의 ’단기 기억(Short-term Memory)’을 구조화하여 관리하는 저장소라 할 수 있다.1</p>
<h4>3.1.4  프롬프터 (Prompter)와 파서 (Parser): 인터페이스 계층</h4>
<ul>
<li><strong>프롬프터 (Prompter):</strong> 그래프 구조 내의 정보를 LLM이 이해할 수 있는 자연어 텍스트로 변환한다. 단순히 질문을 던지는 것을 넘어, “이전 단계에서 생성된 이 두 가지 생각을 고려하여 하나로 합쳐라“와 같이 구체적인 지시 사항을 포함한다. 프롬프터는 또한 퓨샷(Few-shot) 예제를 동적으로 삽입하여 LLM의 문맥 파악을 돕는다.11</li>
<li><strong>파서 (Parser):</strong> LLM이 생성한 비정형 텍스트 출력에서 핵심 정보를 추출하여 GRS에 저장할 수 있는 정형 데이터로 변환한다. 예를 들어, LLM이 “정렬된 리스트는 입니다.“라고 출력하면, 파서는 여기서 ``이라는 리스트 객체만을 추출해낸다. 이는 자동화된 추론 파이프라인을 유지하는 데 필수적이다.11</li>
</ul>
<h4>3.1.5  채점 모듈 (Scoring Module): 품질 보증</h4>
<p>채점 모듈은 생성된 생각의 가치를 평가한다. GoT는 외부의 정답 데이터 없이도 작동해야 하므로, 주로 LLM 자체를 평가자로 활용한다. “위의 해결책이 문제의 요구사항을 얼마나 잘 충족하는지 1부터 10까지 점수를 매기고 그 이유를 설명하라“는 식의 프롬프트를 통해 각 정점에 점수를 부여한다. 이 점수는 탐색 알고리즘이 유망한 경로를 선택하고, 그렇지 않은 경로를 폐기하는(가지치기) 기준이 된다.1</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant User as 사용자&lt;br&gt;(User)
    participant Controller as 컨트롤러&lt;br&gt;(Controller)
    participant GoO as 작업 그래프&lt;br&gt;(GoO)
    participant GRS as 그래프 추론 상태&lt;br&gt;(GRS)
    participant Prompter as 프롬프터&lt;br&gt;(Prompter)
    participant LLM as LLM&lt;br&gt;(Model)
    participant Parser as 파서&lt;br&gt;(Parser)
    participant Scorer as 채점 모듈&lt;br&gt;(Scoring)

    User-&gt;&gt;Controller: "복잡한 문제 입력"
    Controller-&gt;&gt;GoO: "실행 계획(청사진) 로드"
    
    loop "추론 단계 반복 (Reasoning Loop)"
        Controller-&gt;&gt;GRS: "현재 상태 확인 및 문맥 조회"
        GRS--&gt;&gt;Controller: "이전 생각(Nodes) 데이터"
        
        Controller-&gt;&gt;Prompter: "변환(Transformation) 요청"
        Prompter-&gt;&gt;LLM: "구조화된 프롬프트 전송"
        LLM--&gt;&gt;Prompter: "자연어 응답 생성"
        
        Prompter-&gt;&gt;Parser: "응답 전달"
        Parser-&gt;&gt;Parser: "핵심 정보 추출"
        Parser-&gt;&gt;GRS: "새로운 생각(Vertex) 저장"
        
        Controller-&gt;&gt;Scorer: "생성된 생각 평가 요청"
        Scorer-&gt;&gt;LLM: "평가 프롬프트 수행"
        LLM--&gt;&gt;Scorer: "점수/피드백 반환"
        Scorer-&gt;&gt;GRS: "점수 업데이트 &amp; 가지치기 결정"
    end

    Controller-&gt;&gt;User: "최종 결과 반환"
</code></pre>
<h3>3.2  시스템 작동 흐름 예시</h3>
<p>사용자가 “이 복잡한 텍스트를 요약하고 주요 키워드를 추출해줘“라고 요청했을 때의 시스템 작동 흐름은 다음과 같다:</p>
<ol>
<li><strong>초기화:</strong> 컨트롤러가 해당 작업에 맞는 GoO(예: 분할-요약-병합 패턴)를 로드하고 GRS를 초기화한다.</li>
<li><strong>분할 (Generate):</strong> 프롬프터가 입력 텍스트를 여러 문단으로 나누는 프롬프트를 생성하고, LLM이 이를 수행한다. 파서는 결과를 파싱하여 GRS에 여러 개의 ’문단 노드’를 생성한다.</li>
<li><strong>개별 요약 (Generate):</strong> 컨트롤러는 각 문단 노드에 대해 요약 명령을 내린다. LLM이 병렬적(혹은 순차적)으로 요약본을 생성하고, 이는 GRS에 ’요약 노드’들로 추가된다.</li>
<li><strong>평가 (Score):</strong> 채점 모듈이 각 요약본의 품질을 검증한다. 점수가 낮은 요약본은 다시 생성(Refine)하도록 루프를 돌린다.</li>
<li><strong>병합 (Aggregate):</strong> 컨트롤러가 모든 유효한 요약 노드들을 부모로 하는 ‘통합 노드’ 생성을 지시한다. 프롬프터는 “다음 요약본들을 종합하여 하나의 글을 작성하라“는 프롬프트를 보낸다.</li>
<li><strong>최종 출력:</strong> 파서가 최종 결과를 추출하여 사용자에게 반환한다.</li>
</ol>
<pre><code class="language-mermaid">graph TD
    User["User Task"] --&gt; Controller

    subgraph "GoT Architecture"
        Controller["Controller (Central Scheduling)"]
        GoO["Graph of Operations (GoO)\n(Static/Dynamic Plan)"]
        GRS["Graph Reasoning State (GRS)\n(History, Scores, Topology)"]
        
        subgraph "LLM Interface Layer"
            Prompter["Prompter\n(Graph to Text)"]
            Parser["Parser\n(Text to Graph State)"]
            LLM["Large Language Model\n(Reasoning/Scoring)"]
        end
        
        Controller -- "Reads Plan" --&gt; GoO
        Controller -- "Reads/Writes State" --&gt; GRS
        Controller -- "Sends Instructions" --&gt; Prompter
        Prompter -- "Prompt Context" --&gt; LLM
        LLM -- "Raw Response" --&gt; Parser
        Parser -- "Extracted Thought" --&gt; Controller
    end
    
    Controller -- "Final Answer" --&gt; Output["System Output"]
</code></pre>
<h2>4.  핵심 그래프 연산 및 사고 변환 (Thought Transformations)</h2>
<p>GoT의 진정한 위력은 그래프 구조 위에서 수행되는 다양한 ‘사고 변환(Thought Transformations)’ 연산에서 나온다. Besta et al.은 이를 통해 LLM의 추론을 마치 레고 블록을 조립하듯 유연하게 구성할 수 있음을 보여주었다.1</p>
<pre><code class="language-mermaid">graph LR
    subgraph "생성 (Generation / 1-to-N)"
        Gen1("생각 V1") --&gt; Gen2("생각 V2")
        Gen1 --&gt; Gen3("생각 V3")
        Gen1 --&gt; Gen4("생각 V4")
        style Gen1 fill:#e1f5fe
    end

    subgraph "통합 (Aggregation / N-to-1)"
        Agg1("생각 A") --&gt; AggResult("통합된 생각 C")
        Agg2("생각 B") --&gt; AggResult
        style AggResult fill:#fff9c4,stroke:#fbc02d,stroke-width:2px
    end

    subgraph "정제 (Refinement / Loop)"
        Ref1("초안 V") --&gt; Ref2("수정 V'")
        Ref2 --&gt; RefCheck{"평가 (Score)"}
        RefCheck -- "불충분" --&gt; Ref2
        RefCheck -- "충분" --&gt; Ref3("완성 V''")
        style Ref2 fill:#fce4ec
    end
</code></pre>
<h3>4.1  통합 (Aggregation): 시너지의 창출</h3>
<p>통합은 GoT를 ToT와 구분 짓는 가장 결정적인 연산이다. ToT는 오직 ‘일대다(One-to-Many)’ 분기만 가능하지만, GoT는 ‘다대일(Many-to-One)’ 연결을 지원한다.</p>
<ul>
<li><strong>작동 원리:</strong> 두 개 이상의 서로 다른 생각(정점)을 입력으로 받아, 이들의 정보를 결합한 새로운 생각(정점)을 생성한다.</li>
<li><strong>활용:</strong></li>
<li><strong>병합(Merge):</strong> 여러 문서의 내용을 하나로 합치거나, 정렬된 부분 리스트들을 병합할 때 사용된다.</li>
<li><strong>종합(Synthesize):</strong> 서로 다른 관점의 주장들을 종합하여 결론을 도출하거나, 여러 가지 해결책의 장점만을 취합하여 최적해를 만들 때 사용된다.</li>
<li><strong>함의:</strong> 이는 독립적인 사고의 흐름들이 서로 고립되지 않고 상호작용할 수 있음을 의미한다. 부분적으로만 정답인 두 개의 불완전한 해답이 만나 완벽한 해답으로 진화하는 과정은 통합 연산 없이는 불가능하다.1</li>
</ul>
<h3>4.2  정제 (Refinement): 순환을 통한 자기 개선</h3>
<p>정제는 그래프 내의 순환(Loop)을 형성하는 연산이다. 현재의 생각(정점)을 다시 입력으로 사용하여 개선된 버전을 생성한다.</p>
<ul>
<li><strong>작동 원리:</strong> 정점 <span class="math math-inline">v</span>에 대해 <span class="math math-inline">v</span> 자신을 참고하는 간선을 생성하거나, <span class="math math-inline">v</span>를 입력으로 받아 <span class="math math-inline">v&#39;</span>를 생성하고 이를 다시 평가하는 과정을 반복한다.</li>
<li><strong>활용:</strong></li>
<li><strong>오류 수정:</strong> 코드 작성 중 버그가 발견되면 해당 부분을 수정하는 프롬프트를 반복적으로 수행한다.</li>
<li><strong>품질 향상:</strong> 글의 초안을 작성한 후, “더 간결하게 다듬어라”, “논리적 비약을 수정하라“와 같은 지시를 통해 점진적으로 텍스트의 품질을 높인다.</li>
<li><strong>함의:</strong> 기존 CoT는 한 번 뱉은 말을 주워담을 수 없었지만, GoT의 정제 연산은 인간이 퇴고(revising)를 거치듯 사고를 숙성시키는 과정을 구현한다.1</li>
</ul>
<h3>4.3  생성 (Generation): 탐색 공간의 확장</h3>
<p>생성은 하나의 정점에서 하나 이상의 새로운 정점을 파생시키는 연산으로, ToT의 ’Expand’와 유사하다.</p>
<ul>
<li><strong>활용:</strong> 문제의 새로운 해결 방안을 브레인스토밍하거나, 하나의 복잡한 문제를 여러 개의 하위 문제로 분할(Decomposition)할 때 사용된다.</li>
</ul>
<h3>4.4  평가 및 선택 (Evaluation &amp; Selection)</h3>
<p>GoT는 무한히 확장되는 그래프를 제어하기 위해 엄격한 평가 및 선택 메커니즘을 둔다.</p>
<ul>
<li><strong>KeepBest(N):</strong> 생성된 여러 자식 노드들 중 점수가 가장 높은 <span class="math math-inline">N</span>개만을 유지하고 나머지는 폐기한다. 이는 빔 서치(Beam Search)와 유사하게 작동하며 메모리와 계산 비용을 절약한다.1</li>
<li><strong>Backtracking:</strong> 현재 경로의 점수가 임계치 이하로 떨어지면, 즉시 탐색을 중단하고 이전 분기점으로 돌아가 다른 경로를 탐색한다.</li>
</ul>
<h2>5.  상세 사용 사례 및 벤치마크 분석</h2>
<p>Besta et al.은 GoT의 효용성을 증명하기 위해 정렬(Sorting), 집합 교집합(Set Intersection), 키워드 계산(Keyword Counting), 문서 병합(Document Merging) 등 4가지 대표적인 과제에서 실험을 수행하였다. 이 과제들은 단순한 지식 검색이 아니라 복잡한 논리적 조작과 계획 수립을 요구하기 때문에 LLM의 추론 능력을 평가하기에 적합하다.</p>
<h3>5.1  숫자 정렬 (Sorting): GoT의 압도적 우위</h3>
<p>정렬은 LLM이 가장 어려워하는 작업 중 하나이다. 숫자의 크기를 비교하고 순서를 재배열하는 과정에서 논리적 비약이 발생하기 쉽기 때문이다.</p>
<ul>
<li><strong>실험 설정:</strong> 32개, 64개, 128개의 무작위 숫자로 구성된 리스트를 정렬하는 과제를 수행했다.16</li>
<li><strong>GoT 전략 (병합 정렬 방식):</strong></li>
</ul>
<ol>
<li><strong>분할:</strong> 입력 리스트를 여러 개의 하위 리스트(예: 4개의 16개 요소 리스트)로 쪼갠다.</li>
<li><strong>개별 정렬:</strong> 각 하위 리스트를 LLM에게 정렬시킨다. 이때 오류가 발생하면 정제(Refinement) 연산을 통해 수정한다.</li>
<li><strong>병합 (Aggregation):</strong> 정렬된 하위 리스트들을 두 개씩 짝지어 병합하는 과정을 반복한다. LLM에게 “이미 정렬된 두 리스트를 합쳐서 하나의 정렬된 리스트로 만들어라“고 지시하는 것은 무작위 리스트를 정렬하는 것보다 훨씬 쉽다.1</li>
</ol>
<ul>
<li><strong>결과 분석:</strong></li>
<li><strong>정확도:</strong> 64개 요소 정렬에서 GoT는 ToT 대비 <strong>62% 더 높은 품질</strong>의 결과를 달성했다. ToT는 하나의 실수만 있어도 전체 결과가 망가지지만, GoT는 부분적으로 완성된 결과들을 병합하는 방식이므로 오류 내성이 훨씬 강하다.1</li>
<li><strong>비용:</strong> 놀랍게도 비용은 ToT 대비 <strong>31% 이상 감소</strong>했다. ToT는 오류가 발생하면 처음부터 다시 탐색하거나 막대한 수의 가지를 뻗어야 하지만, GoT는 효율적인 병합과 정제를 통해 불필요한 재생성을 최소화했기 때문이다.1</li>
</ul>
<pre><code class="language-mermaid">graph TD
    Input("입력: 무작위 숫자 리스트 [64개]") --&gt; Split1("분할 (Generation): 4개의 하위 리스트")
    
    subgraph "개별 정렬 (Local Sorting)"
        Split1 --&gt; Sub1("리스트 1 정렬")
        Split1 --&gt; Sub2("리스트 2 정렬")
        Split1 --&gt; Sub3("리스트 3 정렬")
        Split1 --&gt; Sub4("리스트 4 정렬")
    end

    subgraph "오류 수정 (Refinement Loop)"
        Sub1 --&gt; Check{"검증"}
        Check -- "오류" --&gt; Sub1
        Check -- "통과" --&gt; Valid1("정렬됨 1")
    end

    subgraph "병합 (Aggregation)"
        Valid1 &amp; Sub2 --&gt; Merge1("병합 1 (1+2)")
        Sub3 &amp; Sub4 --&gt; Merge2("병합 2 (3+4)")
        Merge1 &amp; Merge2 --&gt; FinalMerge("최종 병합")
    end

    FinalMerge --&gt; Output("출력: 완벽히 정렬된 리스트")
    
    style FinalMerge fill:#ffe0b2,stroke:#ef6c00,stroke-width:2px
</code></pre>
<h3>5.2  집합 교집합 (Set Intersection)</h3>
<p>두 개의 집합에서 공통된 원소를 찾아내는 과제이다. 집합의 크기가 커질수록 LLM은 원소를 빠뜨리거나 없는 원소를 지어내는 환각(Hallucination)을 일으키기 쉽다.</p>
<ul>
<li><strong>GoT 전략:</strong></li>
</ul>
<ol>
<li>집합 A는 그대로 두고, 집합 B를 여러 개의 작은 부분 집합(<span class="math math-inline">B_1, B_2,...</span>)으로 나눈다.</li>
<li>각 <span class="math math-inline">B_i</span>와 A의 교집합을 구한다(Generation). 작은 집합 간의 비교이므로 LLM의 정확도가 높다.</li>
<li>구해진 교집합들을 모두 합친다(Aggregation).1</li>
</ol>
<ul>
<li><strong>결과 분석:</strong> 원소 수가 64개, 128개로 늘어날수록 GoT와 타 방법론(CoT, ToT) 간의 성능 격차는 극명하게 벌어졌다. GoT는 복잡한 문제를 관리 가능한 단위로 쪼개고 다시 합치는 구조적 접근을 통해 긴 문맥(context)에서의 정보 손실 문제를 해결했다.1</li>
</ul>
<pre><code class="language-mermaid">graph TD
    Input("입력: 집합 A (대형), 집합 B (대형)") --&gt; SplitB("집합 B 분할 (Decomposition)")
    
    subgraph "병렬 비교 (Generation)"
        SplitB --&gt; B1("부분집합 B_1")
        SplitB --&gt; B2("부분집합 B_2")
        SplitB --&gt; B3("부분집합 B_n")
        
        B1 -.-&gt; Comp1("A ∩ B_1 연산")
        B2 -.-&gt; Comp2("A ∩ B_2 연산")
        B3 -.-&gt; Comp3("A ∩ B_n 연산")
        
        Input -.-&gt; Comp1
        Input -.-&gt; Comp2
        Input -.-&gt; Comp3
    end
    
    subgraph "결과 통합 (Aggregation)"
        Comp1 --&gt; Res1("결과 1")
        Comp2 --&gt; Res2("결과 2")
        Comp3 --&gt; Res3("결과 3")
        
        Res1 &amp; Res2 &amp; Res3 --&gt; Union("합집합 연산 (Union of Intersections)")
    end
    
    Union --&gt; Final("최종 교집합 결과")

    style Input fill:#e1f5fe
    style Union fill:#ffe0b2,stroke:#ef6c00
</code></pre>
<h3>5.3  키워드 계산 (Keyword Counting)</h3>
<p>주어진 긴 텍스트에서 특정 카테고리(예: 국가 이름)에 속하는 단어들이 몇 번 등장하는지 세는 과제이다.</p>
<ul>
<li><strong>GoT 전략:</strong> 텍스트를 문단 단위로 분할하고, 각 문단에서 키워드 빈도를 계산한 뒤, 이를 최종적으로 합산(Summation Aggregation)하는 방식을 취했다.4</li>
<li><strong>결과 분석:</strong> CoT는 텍스트가 길어지면 앞부분의 내용을 잊어버리거나 숫자를 잘못 세는 경우가 빈번했으나, GoT는 작업을 독립적인 단위로 격리(isolate)함으로써 높은 정확도를 유지했다.</li>
</ul>
<pre><code class="language-mermaid">graph TD
    Doc("입력: 긴 문서 (Long Document)") --&gt; Split("문단 단위 분할 (Generation)")
    
    Split --&gt; P1("문단 1")
    Split --&gt; P2("문단 2")
    Split --&gt; P3("문단 3")
    
    subgraph "독립적 카운팅 (Isolation)"
        P1 --&gt; C1("빈도 계산 1")
        P2 --&gt; C2("빈도 계산 2")
        P3 --&gt; C3("빈도 계산 3")
    end
    
    subgraph "검증 및 합산 (Score &amp; Aggregate)"
        C1 &amp; C2 &amp; C3 --&gt; Check{"각 결과 검증"}
        Check --&gt; Sum("단순 합산 (Summation)")
    end
    
    Sum --&gt; Result("최종 빈도수 출력")
    
    style Split fill:#f3e5f5
    style Sum fill:#e1bee7,stroke:#8e24aa
</code></pre>
<h3>5.4  벤치마크 결과 요약표</h3>
<table><thead><tr><th><strong>과제 (Task)</strong></th><th><strong>지표 (Metric)</strong></th><th><strong>성능 향상 (vs ToT/CoT)</strong></th><th><strong>핵심 성공 요인 (Key Drivers)</strong></th></tr></thead><tbody>
<tr><td><strong>정렬 (Sorting)</strong></td><td>정렬 품질 (Quality)</td><td><strong>+62%</strong> (vs ToT)</td><td>병합(Aggregation) 기반의 분할 정복 알고리즘 구현</td></tr>
<tr><td></td><td>비용 (Cost)</td><td><strong>-31%</strong> (vs ToT)</td><td>오류 발생 시 전체 재생성 대신 부분 정제(Refinement) 활용</td></tr>
<tr><td><strong>집합 교집합</strong></td><td>정확도 (Accuracy)</td><td>ToT 상회</td><td>대규모 입력을 소규모 단위로 분할 처리 후 통합</td></tr>
<tr><td><strong>키워드 계산</strong></td><td>정확도 (Accuracy)</td><td>CoT/ToT 상회</td><td>문맥 길이 제한 극복을 위한 병렬 처리 및 합산</td></tr>
<tr><td><strong>문서 병합</strong></td><td>일관성 (Coherence)</td><td>지표 상승</td><td>여러 소스 정보의 유기적 결합</td></tr>
</tbody></table>
<p>1</p>
<h2>6.  비용 효율성과 새로운 지표: ‘생각의 부피(Volume of a Thought)’</h2>
<p>GoT 연구의 또 다른 중요한 기여는 프롬프트 전략의 효율성을 정량적으로 측정할 수 있는 새로운 지표인 **‘생각의 부피(Volume of a Thought)’**를 제안한 것이다. 이는 기존의 단순히 ‘몇 번의 단계를 거쳤는가(Depth)’ 혹은 ’몇 개의 후보를 생성했는가(Breadth)’만으로는 설명할 수 없는 정보의 밀도를 측정한다.1</p>
<pre><code class="language-mermaid">graph TD

    subgraph "GoT 구조 (높은 부피 &amp; 재사용)"
        G1("입력") --&gt; G2("경로 A") &amp; G3("경로 B")
        G2 --&gt; G4("중간 생각")
        G3 --&gt; G4
        G4 --&gt; G5("정제 루프")
        G5 --&gt; G5
        G5 --&gt; G6("최종 결론 (높은 정보 밀도)")
        
        %% 재사용성 표현
        G2 --&gt; G7("다른 경로로 재사용")
        
        style G6 fill:#c8e6c9,stroke:#2e7d32,stroke-width:4px
    end

    subgraph "트리 구조 (중간 부피)"
        T1("ToT 루트") --&gt; T2("가지 1") &amp; T3("가지 2")
        T2 --&gt; T4("잎 1")
        T3 --&gt; T5("잎 2")
        style T4 stroke-dasharray: 5 5
    end

    subgraph "단선적 구조 (낮은 부피)"
        L1("CoT 노드 1") --&gt; L2("CoT 노드 2") --&gt; L3("CoT 노드 3")
        style L3 stroke-dasharray: 5 5
    end    
</code></pre>
<h3>6.1  생각의 부피 (Volume of a Thought) 정의 및 의의</h3>
<p>어떤 생각(정점) <span class="math math-inline">v</span>의 부피 <span class="math math-inline">Vol(v)</span>는 그래프 상에서 <span class="math math-inline">v</span>에 도달할 수 있는 모든 선행 생각(LLM thoughts)의 개수로 정의된다. 수식으로 표현하면, <span class="math math-inline">Vol(v) = |\{u \in V | \exists \text{ path } u \to v\}|</span> 이다.</p>
<ul>
<li><strong>의미:</strong> 부피가 크다는 것은 해당 결론 <span class="math math-inline">v</span>가 도출되기까지 많은 정보가 고려되고 통합되었음을 의미한다. 즉, 정보의 풍부함과 추론의 깊이를 나타내는 척도이다.</li>
<li><strong>비교:</strong></li>
<li><strong>CoT:</strong> 선형 구조이므로 부피는 깊이(Depth)와 비례하여 선형적으로 증가한다(<span class="math math-inline">O(N)</span>). 부피를 늘리려면 단계 수를 무작정 늘려야 하는데, 이는 비용 증가와 문맥 희석을 초래한다.</li>
<li><strong>ToT:</strong> 트리 구조이므로 특정 잎 노드의 부피는 그 경로의 길이에 불과하다. 다른 가지에서 생성된 수많은 생각들은 최종 결과의 부피에 기여하지 못한다.</li>
<li><strong>GoT:</strong> 통합(Aggregation) 연산을 통해 기하급수적으로 부피를 늘릴 수 있다. 두 개의 긴 사슬을 병합하는 순간, 병합된 노드의 부피는 두 사슬의 노드 수를 합친 것이 된다. 따라서 적은 비용(단계)으로도 매우 높은 부피(정보량)를 가진 고품질의 생각을 만들어낼 수 있다.2</li>
</ul>
<h3>6.2  비용 절감의 역설</h3>
<p>일반적으로 “더 복잡한 그래프 구조를 사용하면 비용이 더 들지 않을까?“라고 생각하기 쉽다. 그러나 GoT는 다음과 같은 메커니즘을 통해 오히려 비용을 절감한다.1</p>
<ol>
<li><strong>재사용성 (Reusability):</strong> 한 번 생성된 생각은 그래프 내의 여러 지점에서 참조되고 재사용될 수 있다. ToT에서는 다른 가지에 있는 유사한 정보를 다시 생성해야 한다.</li>
<li><strong>조기 오류 수정:</strong> 순환적 정제(Refinement)를 통해 오류가 발견된 지점에서 즉시 수정이 이루어진다. 전체 프로세스를 처음부터 다시 시작할 필요가 없다.</li>
<li><strong>탐색 공간의 축소:</strong> 통합(Aggregation)은 여러 가능성을 하나로 수렴시킨다. 이는 발산하기만 하는 트리 구조와 달리, 탐색해야 할 공간을 효과적으로 줄여준다.</li>
</ol>
<pre><code class="language-mermaid">graph TD
    subgraph "선형 구조 (CoT) - 낮은 부피"
        C1("생각 1") --&gt; C2("생각 2")
        C2 --&gt; C3("생각 3")
        C3 --&gt; C4("최종 생각 V")
        style C4 stroke-width:2px,stroke:#333
        NoteCoT["Vol(V) = 4 (선형적 증가)"]
    end

    subgraph "그래프 구조 (GoT) - 높은 부피"
        G_A1("경로 A-1") --&gt; G_A2("경로 A-2")
        G_B1("경로 B-1") --&gt; G_B2("경로 B-2")
        G_C1("경로 C-1") --&gt; G_C2("경로 C-2")
        
        G_A2 --&gt; G_Agg("통합 노드 V")
        G_B2 --&gt; G_Agg
        G_C2 --&gt; G_Agg
        
        style G_Agg fill:#c8e6c9,stroke:#2e7d32,stroke-width:4px
        NoteGoT["Vol(V) = 7 (모든 조상 노드의 합)"]
    end
    
    NoteCoT -.-&gt; C4
    NoteGoT -.-&gt; G_Agg
</code></pre>
<h2>7.  타 프레임워크와의 심층 비교 및 관련 연구</h2>
<p>학계에는 ’Graph of Thoughts’라는 유사한 명칭을 사용하거나 그래프 구조를 차용하는 다른 연구들이 존재한다. 이들과 Besta et al.의 GoT를 명확히 구분하는 것은 매우 중요하다.21</p>
<h3>7.1  Besta et al. vs. Yao et al. vs. 기타 접근법</h3>
<ul>
<li><strong>Besta et al. (본 보고서의 대상):</strong> ’임의의 그래프 구조’와 ’사고 변환(통합, 정제)’에 초점을 맞춘다. 컨트롤러와 GoO라는 명시적인 아키텍처를 제안하며, 주로 알고리즘적 문제 해결(정렬, 집합 등)에 집중한다. 시스템적 관점이 강하다.1</li>
<li><strong>Yao et al. (ToT 저자):</strong> Yao 등은 ToT 이후 연구에서 GSM8K와 같은 수학적 추론 벤치마크나 ScienceQA에서 그래프 구조를 활용하는 실험을 진행했다. 그러나 Besta의 연구만큼 명시적인 ‘통합’ 연산을 시스템화하기보다는, 추론 경로의 다양성을 확보하고 검증하는 데 더 중점을 둔다.10</li>
<li><strong>Lei et al. / 기타:</strong> 일부 연구에서는 ’Graph of Thoughts’라는 용어를 사용하여 24 게임이나 다항식 해결 등을 시도했다. 이들은 각기 다른 구현체와 벤치마크를 사용하므로 직접적인 비교에는 주의가 필요하다.14</li>
</ul>
<h3>7.2  종합 비교 분석</h3>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Chain-of-Thought (CoT)</strong></th><th><strong>Tree-of-Thoughts (ToT)</strong></th><th><strong>Graph-of-Thoughts (GoT)</strong></th></tr></thead><tbody>
<tr><td><strong>기본 구조</strong></td><td>선형 사슬 (Line)</td><td>트리 (Tree)</td><td><strong>임의의 그래프 (Arbitrary Graph)</strong></td></tr>
<tr><td><strong>핵심 연산</strong></td><td>생성 (Generate)</td><td>생성, 탐색 (Search), 백트래킹</td><td><strong>생성, 통합(Agg), 정제(Refine), 순환</strong></td></tr>
<tr><td><strong>정보 흐름</strong></td><td>단방향 (1 Parent, 1 Child)</td><td>발산형 (1 Parent, N Children)</td><td><strong>수렴 및 발산 (N Parents, M Children)</strong></td></tr>
<tr><td><strong>오류 수정</strong></td><td>불가능 (재시작 필요)</td><td>백트래킹 (경로 변경)</td><td><strong>순환적 정제 (자체 수정) 및 통합</strong></td></tr>
<tr><td><strong>장점</strong></td><td>구현 용이, 낮은 레이턴시</td><td>다중 경로 탐색, 전역적 최적화</td><td><strong>정보 결합, 높은 비용 효율성, 복잡한 논리 구현</strong></td></tr>
<tr><td><strong>단점</strong></td><td>오류 전파, 단순 문제만 해결 가능</td><td>높은 비용, 가지 간 정보 공유 불가</td><td><strong>설계 복잡성, 적절한 GoO 정의 필요</strong></td></tr>
</tbody></table>
<p>1</p>
<h2>8.  한계점, 도전 과제 및 향후 전망</h2>
<p>GoT는 분명 혁신적인 프레임워크이지만, 만능은 아니다. 현실 세계에 적용하기 위해서는 몇 가지 해결해야 할 과제들이 남아 있다.</p>
<h3>8.1  구현 및 설계의 복잡성</h3>
<p>GoT를 사용하기 위해서는 해결하고자 하는 문제에 맞는 그래프 구조(GoO)를 설계해야 한다. 정렬이나 집합 문제처럼 알고리즘적으로 명확히 분해되는 문제는 쉽지만, 창의적인 글쓰기나 법률 자문과 같이 구조화하기 어려운 문제(ill-structured problems)에 대해서는 어떤 그래프 구조가 최적일지 결정하기 어렵다. 이를 자동화하기 위한 메타-컨트롤러(Meta-Controller) 연구가 필요하다.1</p>
<h3>8.2  지연 시간(Latency)과 실시간성</h3>
<p>그래프가 복잡해지고 정제 루프가 많이 돌면, 필연적으로 최종 응답 시간은 길어진다. 병렬 처리가 가능한 부분(예: 분할된 텍스트의 동시 요약)을 적극적으로 활용하여 지연 시간을 줄이는 엔지니어링적 노력이 필수적이다.</p>
<h3>8.3  컨텍스트 윈도우(Context Window)의 제약</h3>
<p>GoT는 많은 중간 생각들을 GRS에 저장하고 이를 프롬프트에 포함시킨다. 그래프가 커질수록 LLM의 컨텍스트 윈도우 한계에 부딪힐 수 있다. 효과적인 메모리 관리 기법이나 RAG(Retrieval-Augmented Generation)와의 결합이 요구된다.23</p>
<h3>8.4  향후 전망: 자율 에이전트와 뉴로심볼릭 AI</h3>
<p>GoT는 단순한 프롬프팅 기법을 넘어, **자율 에이전트(Autonomous Agents)**의 추론 엔진으로 발전할 잠재력이 크다. 에이전트가 복잡한 환경에서 목표를 달성하기 위해 계획(Plan)을 수립하고, 실행 결과를 관찰하여 계획을 수정(Refine)하며, 여러 도구의 출력을 종합(Aggregate)하는 과정은 GoT의 구조와 정확히 일치한다. 또한, GoT는 신경망 모델(LLM)과 기호적 논리(Graph)를 결합한 **뉴로심볼릭 AI(Neuro-symbolic AI)**의 실용적인 구현체로서, AI의 설명 가능성과 신뢰성을 높이는 데 기여할 것이다.24</p>
<pre><code class="language-mermaid">mindmap
  root(("GoT의 미래 (Future)"))
    ("자율 에이전트 (Autonomous Agents)")
      ("계획 수립 (Planning)")
      ("도구 사용 결과 통합 (Aggregation)")
      ("오류 자가 수정 (Refinement)")
    ("뉴로심볼릭 AI (Neuro-symbolic AI)")
      ("신경망 (LLM) + 기호 논리 (Graph)")
      ("설명 가능한 AI (XAI)")
      ("신뢰성 향상")
    ("해결 과제 (Challenges)")
      ("GoO 설계 자동화 (Meta-Controller)")
      ("실시간성 (Latency)")
      ("컨텍스트 윈도우 관리 (RAG 결합)")
</code></pre>
<h2>9.  결론</h2>
<p>사고의 그래프(Graph-of-Thoughts, GoT)는 대규모 언어 모델의 추론 능력을 인간 수준으로 끌어올리기 위한 중대한 도약이다. GoT는 LLM에게 ‘생각을 조립하고, 스스로 교정하며, 복잡하게 연결하는’ 자유를 부여함으로써, 기존의 선형적 사고 모델이 가진 한계를 뛰어넘었다.</p>
<p>본 보고서의 분석 결과, GoT는 다음과 같은 측면에서 독보적인 가치를 입증하였다.</p>
<ol>
<li><strong>구조적 혁신:</strong> 통합(Aggregation)과 정제(Refinement)라는 새로운 연산을 통해 정보 처리의 효율성과 품질을 동시에 극대화하였다.</li>
<li><strong>성능과 효율의 조화:</strong> 정렬 과제에서 ToT 대비 62%의 품질 향상과 31%의 비용 절감을 동시에 달성함으로써, ’고성능은 고비용’이라는 통념을 깼다.</li>
<li><strong>인간 인지의 모방:</strong> 뇌의 신경망적 특성과 순환적 사고 패턴을 반영하여, 더욱 자연스럽고 강력한 문제 해결 방식을 제시하였다.</li>
</ol>
<p>물론 최적의 그래프 구조를 자동으로 찾아내는 문제나 실시간성 확보 등 해결해야 할 과제들은 남아 있다. 그러나 GoT가 제시한 ’네트워크형 추론’의 패러다임은 향후 LLM이 단순한 언어 처리기를 넘어, 복잡한 현실 세계의 문제를 해결하는 진정한 의미의 **‘추론 엔진(Reasoning Engine)’**으로 진화하는 데 있어 핵심적인 청사진이 될 것이다. 연구자와 엔지니어들은 GoT 프레임워크를 기반으로 더욱 정교하고 자율적인 AI 시스템을 구축할 수 있을 것이며, 이는 인공지능 기술의 지평을 넓히는 중요한 이정표가 될 것으로 전망한다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>Graph of Thoughts: Solving Elaborate Problems with Large Language Models, https://ojs.aaai.org/index.php/AAAI/article/view/29720/31236</li>
<li>arXiv:2308.09687v2 [cs.CL] 21 Aug 2023, https://storage.prod.researchhub.com/uploads/papers/2023/08/23/2308.09687.pdf</li>
<li>Tree of Thoughts: Deliberate Problem Solving with Large Language Models - arXiv, https://arxiv.org/pdf/2305.10601</li>
<li>arXiv:2308.09687v4 [cs.CL] 6 Feb 2024, https://arxiv.org/pdf/2308.09687</li>
<li>Something-of-Thought in LLM Prompting: An Overview of Structured LLM Reasoning, https://towardsdatascience.com/something-of-thought-in-llm-prompting-an-overview-of-structured-llm-reasoning-70302752b390/</li>
<li>Review of “Graph of Thoughts: Solving Elaborate Problems with Large Language Models” - Temple CIS, <a href="https://cis.temple.edu/tagit/presentations/Review%20of%20Besta23.pdf">https://cis.temple.edu/tagit/presentations/Review%20of%20Besta23.pdf</a></li>
<li>Advanced Reasoning Frameworks in Large Language Models: Chain, Tree, and Graph of Thoughts | by Devansh Sinha | Medium, https://medium.com/@dewanshsinha71/advanced-reasoning-frameworks-in-large-language-models-chain-tree-and-graph-of-thoughts-bafbfd028575</li>
<li>Before You Read “Graph of Thoughts” | by Naif Ganadily | Medium, https://medium.com/@ganadilynaif/before-you-read-graph-of-thoughts-3631a9e42dc9</li>
<li>Demystifying Chains, Trees, and Graphs of Thoughts - Torsten Hoefler, http://aegjcef.unixer.de/publications/img/besta-topologies.pdf</li>
<li>[2308.09687] Graph of Thoughts: Solving Elaborate Problems with Large Language Models, https://arxiv.org/abs/2308.09687</li>
<li>Graph of Thoughts: Solving Elaborate Problems with Large Language Models - DemoGPT, https://demogpt.medium.com/graph-of-thoughts-solving-elaborate-problems-with-large-language-models-78985558345</li>
<li>Paper page - Graph of Thoughts: Solving Elaborate Problems with Large Language Models, https://huggingface.co/papers/2308.09687</li>
<li>spcl/graph-of-thoughts: Official Implementation of “Graph of … - GitHub, https://github.com/spcl/graph-of-thoughts</li>
<li>Demystifying Chains, Trees, and Graphs of Thoughts - arXiv, https://arxiv.org/html/2401.14295v3</li>
<li>On the Diagram of Thought - arXiv, https://arxiv.org/html/2409.10038v2</li>
<li>Graph of Thoughts: Solving Elaborate Problems With Large Language Models - Scribd, https://www.scribd.com/document/668584849/2308-09687</li>
<li>Tree of Problems: Improving structured problem solving with compositionality - arXiv, https://arxiv.org/html/2410.06634v1</li>
<li>Tree of Problems: Improving structured problem solving with compositionality - ACL Anthology, https://aclanthology.org/2024.emnlp-main.1001.pdf</li>
<li>[Quick Review] Graph of Thoughts: Solving Elaborate Problems with, https://liner.com/review/graph-thoughts-solving-elaborate-problems-with-large-language-models</li>
<li>Graph of Thoughts | PDF - Scribd, https://www.scribd.com/document/775630962/graph-of-thoughts</li>
<li>[1] Graph of Thoughts (Besta Et Al., AAAI 2024) | PDF - Scribd, https://www.scribd.com/document/942182119/1-Graph-of-Thoughts-Besta-Et-Al-AAAI-2024</li>
<li>Graph of Thoughts: Solving Elaborate Problems with Large Language Models | Request PDF - ResearchGate, https://www.researchgate.net/publication/379296666_Graph_of_Thoughts_Solving_Elaborate_Problems_with_Large_Language_Models</li>
<li>An LLM Using a Knowledge Graph to Reason - ETH Zurich Research Collection, https://www.research-collection.ethz.ch/bitstreams/a03fe1a6-16b6-456c-83f2-c91296eda847/download</li>
<li>Graph of Thoughts: A New Paradigm for Elaborate Problem-Solving in Large Language Models - KDnuggets, https://www.kdnuggets.com/graph-of-thoughts-a-new-paradigm-for-elaborate-problem-solving-in-large-language-models</li>
<li>Beyond Tree of Thoughts for LLMs: Graph of Thoughts : r/singularity - Reddit, https://www.reddit.com/r/singularity/comments/15za94g/beyond_tree_of_thoughts_for_llms_graph_of_thoughts/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>