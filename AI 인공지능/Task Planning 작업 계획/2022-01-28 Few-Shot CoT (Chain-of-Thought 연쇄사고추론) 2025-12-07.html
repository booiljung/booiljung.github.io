<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Few-Shot CoT (Chain-of-Thought, 연쇄사고추론, 2022-01-28)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Few-Shot CoT (Chain-of-Thought, 연쇄사고추론, 2022-01-28)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">작업 계획 (Task Planning)</a> / <span>Few-Shot CoT (Chain-of-Thought, 연쇄사고추론, 2022-01-28)</span></nav>
                </div>
            </header>
            <article>
                <h1>Few-Shot CoT (Chain-of-Thought, 연쇄사고추론, 2022-01-28)</h1>
<p>2025-12-07, G30DR</p>
<h2>1.  서론: 인공지능 추론의 새로운 지평</h2>
<p>최근 몇 년간 자연어 처리(NLP) 분야는 트랜스포머(Transformer) 아키텍처의 도입과 대규모 언어 모델(Large Language Models, LLMs)의 비약적인 성장을 통해 전례 없는 변혁기를 맞이했다. GPT-3, PaLM, Llama와 같은 거대 모델들은 텍스트 생성, 번역, 요약 등 단순 언어 처리 작업에서 인간을 능가하거나 대등한 수준의 유창성을 보여주었다.1 그러나 이러한 성과에도 불구하고, 모델이 다단계 논리적 사고나 복잡한 산술 연산, 상식적 인과 관계 추론(Commonsense Reasoning)을 수행해야 하는 영역에서는 여전히 명확한 한계를 드러냈다. 이는 모델이 단순히 훈련 데이터 내의 통계적 패턴을 학습하여 다음 단어를 예측하는 방식(Next Token Prediction)으로 작동하기 때문이며, 문제를 해결하기 위해 필수적인 ’중간 사고 과정’이 결여되어 있었기 때문이다.3</p>
<p>이러한 배경 속에서 2022년 Jason Wei 등이 제안한 <strong>Chain-of-Thought (CoT)</strong> 프롬프팅은 LLM의 추론 능력을 획기적으로 향상시키는 새로운 패러다임을 제시하였다.1 CoT는 인간이 복잡한 문제를 해결할 때 직관적으로 수행하는 사고의 흐름, 즉 문제를 작은 단위로 분해하고 논리적 단계를 거쳐 결론에 도달하는 과정을 모델에게 명시적으로 유도하는 기법이다. 특히 소수의 예제를 통해 모델의 행동을 제어하는 <strong>Few-Shot CoT</strong> 방식은 모델의 파라미터를 업데이트하지 않고도(Fine-tuning 없이) 추론 성능을 비약적으로 끌어올릴 수 있음을 입증하며 학계와 산업계의 주목을 받았다.2</p>
<p>본 보고서는 Few-Shot CoT의 이론적 배경과 작동 메커니즘, Zero-Shot 방식과의 비교, 모델 규모에 따른 창발적 특성(Emergent Abilities), 그리고 Tree of Thoughts(ToT)나 Program of Thoughts(PoT)와 같은 파생 기술들을 심도 있게 분석한다. 또한, CoT가 단순한 성능 향상 도구를 넘어 인공지능이 인간의 사고 과정을 모방하는 방식과 그 한계점(비용, 신뢰성, 소형 모델 적용 문제)에 대해 방대한 문헌과 실험 결과를 바탕으로 고찰한다.</p>
<h2>2.  Chain-of-Thought (CoT) 프롬프팅의 이론적 토대와 작동 원리</h2>
<h3>2.1  표준 프롬프팅의 한계와 CoT의 등장 배경</h3>
<p>전통적인 <strong>표준 프롬프팅(Standard Prompting)</strong> 방식은 모델에게 입력(<span class="math math-inline">Input</span>)과 정답(<span class="math math-inline">Output</span>)의 쌍만을 예시로 제공하거나, 단순히 질문을 던지고 즉각적인 답을 요구하는 형태였다. 이를 수식화하면 모델은 <span class="math math-inline">P(Output | Input)</span>의 확률을 최대화하는 방향으로 텍스트를 생성한다.3</p>
<p>예를 들어, “로저는 테니스 공 5개를 가지고 있다. 3개짜리 캔 2개를 더 샀다. 지금 공은 몇 개인가?“라는 질문에 대해 표준 프롬프팅은 모델이 즉시 “11개“라는 답을 내놓기를 기대한다. 인간에게는 간단한 이 산술 연산이 LLM에게는 매우 어려운 과제인데, 그 이유는 모델이 입력된 텍스트의 표면적인 통계적 연관성만으로 내부 연산을 수행하고 ’한 번의 패스’로 정답을 도출해야 하는 부담을 안기 때문이다.3 복잡한 추론을 수행하기 위해서는 중간 계산 결과를 잠시 기억해둘 ’메모리 버퍼’나 ’스크래치패드’가 필요하지만, 표준 프롬프팅은 이를 허용하지 않는다.</p>
<p><strong>Chain-of-Thought (CoT)</strong> 프롬프팅은 입력과 출력 사이에 **‘일련의 중간 추론 단계(Chain of Thought)’**를 삽입함으로써 이 문제를 해결한다. 즉, 모델은 <span class="math math-inline">P(Output | Input, Reasoning\ Chain)</span>의 확률 분포를 학습하게 된다.2</p>
<ul>
<li><strong>표준 프롬프팅:</strong> <span class="math math-inline">Input \rightarrow Answer</span></li>
<li><strong>CoT 프롬프팅:</strong> <span class="math math-inline">Input \rightarrow Chain\ of\ Thought\ (Rationales) \rightarrow Answer</span></li>
</ul>
<p>이러한 구조적 변화는 모델에게 ’생각할 시간(Time to think)’을 부여하는 것과 같다. 모델은 최종 답을 생성하기 전에 논리적 근거를 먼저 토큰 단위로 생성하면서, 이전 단계의 생성 결과가 다음 단계의 추론을 돕는 자기 회귀적(Auto-regressive) 이점을 활용하게 된다. 이는 복잡한 문제를 개별적으로 해결 가능한 하위 문제로 분해(Decomposition)하여 연산 부하를 분산시키는 효과를 낳는다.5</p>
<h3>2.2  Few-Shot CoT의 구성 및 In-Context Learning 메커니즘</h3>
<p>Few-Shot CoT는 대규모 언어 모델의 <strong>In-Context Learning (ICL)</strong> 능력을 활용한다. ICL은 모델의 가중치를 수정하지 않고, 프롬프트(입력 컨텍스트) 내에 제공된 자연어 지시사항이나 예시를 통해 모델이 새로운 작업의 수행 방식을 즉석에서 학습하는 능력이다.8</p>
<p>Few-Shot CoT 프롬프트는 크게 세 부분으로 구성된다.</p>
<ol>
<li><strong>지시문 (Instruction):</strong> 선택적으로 사용되며, 작업의 성격을 규정한다.</li>
<li><strong>예시 (Exemplars/Demonstrations):</strong> &lt;질문, 사고 과정(CoT), 정답&gt;으로 이루어진 <span class="math math-inline">k</span>개의 예제. (<span class="math math-inline">k</span>-shot)</li>
<li><strong>타겟 질문 (Target Question):</strong> 실제로 모델이 풀어야 할 새로운 문제.</li>
</ol>
<p><strong>[표 1] 표준 Few-Shot 프롬프팅과 Few-Shot CoT 프롬프팅 비교 (GSM8K 예시 재구성)</strong> 3</p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>표준 Few-Shot 프롬프팅 (Standard)</strong></th><th><strong>Few-Shot CoT 프롬프팅</strong></th></tr></thead><tbody>
<tr><td><strong>예시 (Exemplar)</strong></td><td><strong>질문:</strong> 로저는 공 5개를 가지고 있다. 3개입 캔 2개를 더 샀다. 몇 개인가? <strong>정답:</strong> 11개</td><td><strong>질문:</strong> 로저는 공 5개를 가지고 있다. 3개입 캔 2개를 더 샀다. 몇 개인가? <strong>정답:</strong> 로저는 처음에 5개의 공이 있었다. 3개씩 든 캔 2개는 3 * 2 = 6개의 공이다. 5 + 6 = 11이다. 따라서 정답은 11이다.</td></tr>
<tr><td><strong>타겟 질문 (Target)</strong></td><td><strong>질문:</strong> 식당에 사과 23개가 있었다. 점심에 20개를 쓰고 6개를 더 샀다. 몇 개 남았나?</td><td><strong>질문:</strong> 식당에 사과 23개가 있었다. 점심에 20개를 쓰고 6개를 더 샀다. 몇 개 남았나?</td></tr>
<tr><td><strong>모델 출력 (Output)</strong></td><td><strong>정답:</strong> 27개 (오답 - 단순히 숫자들을 더하는 오류 발생 빈번)</td><td><strong>정답:</strong> 식당에는 처음에 23개의 사과가 있었다. 점심에 20개를 썼으므로 23 - 20 = 3개 남았다. 그 후 6개를 더 샀으므로 3 + 6 = 9개이다. 따라서 정답은 9이다. (정답)</td></tr>
</tbody></table>
<p>위의 표에서 볼 수 있듯, Few-Shot CoT는 예시를 통해 모델에게 “답을 내기 전에 계산 과정을 서술하라“는 암묵적인 지시를 전달한다. 모델은 예시의 패턴(Pattern)을 모방하여 타겟 질문에 대해서도 유사한 구조의 논리적 서술을 생성한다. 이는 모델이 문제의 문맥을 더 깊이 이해하고, 중간 단계에서의 오류를 스스로 수정하거나 논리적 비약을 방지하는 데 기여한다.4</p>
<h3>2.3  CoT의 성공 요인: 인지과학적 해석</h3>
<p>CoT의 효과는 인지심리학의 **이중 과정 이론(Dual Process Theory)**으로 설명되기도 한다.7</p>
<ul>
<li><strong>시스템 1 (System 1):</strong> 직관적이고 빠르며 무의식적인 사고. 표준 프롬프팅이 이에 해당하며, 즉각적인 패턴 매칭에 의존한다.</li>
<li><strong>시스템 2 (System 2):</strong> 분석적이고 느리며 의식적인 사고. CoT 프롬프팅은 모델에게 시스템 2와 유사한 순차적 추론을 강제함으로써, 복잡한 문제 해결 능력을 활성화한다.</li>
</ul>
<p>모델이 생성하는 중간 사고 과정은 인간의 ’내적 독백(Inner Monologue)’을 텍스트로 표출한(Externalized) 것으로 볼 수 있으며, 이는 모델의 해석 가능성(Interpretability)을 높여 사용자가 모델이 왜 그런 결론에 도달했는지 추적(Debugging)할 수 있게 한다.4</p>
<h2>3.  Few-Shot CoT와 Zero-Shot CoT: 심층 비교 분석</h2>
<p>CoT 기법은 예제를 제공하느냐에 따라 Few-Shot과 Zero-Shot으로 구분된다. 이 두 방식은 단순히 예제 수의 차이를 넘어, 모델의 사전 지식을 활용하는 방식과 제어 가능성 측면에서 근본적인 차이를 보인다.</p>
<h3>3.1  Zero-Shot CoT: “단계별로 생각해보자 (Let’s think step by step)”</h3>
<p>2022년 Kojima 등이 제안한 Zero-Shot CoT는 별도의 예제 작성 없이, 단순히 프롬프트 끝에 **“Let’s think step by step”**이라는 마법의 문구(Trigger Sentence)를 추가하는 것만으로 CoT 효과를 유발한다.11</p>
<ul>
<li><strong>메커니즘:</strong> 이 문구는 모델이 거대 데이터셋에서 학습한 논리적 서술 패턴을 조건부 확률적으로 활성화한다. 모델은 이 지시를 받으면 즉답 대신 “First,… Then,… Therefore,…“와 같은 순차적 구조를 생성할 확률이 높아진다.13</li>
<li><strong>장점:</strong> 도메인 특화 예제를 만들 필요가 없어 유연성(Flexibility)이 매우 높다. 데이터가 전혀 없는 새로운 유형의 작업에도 즉시 적용 가능하다.</li>
<li><strong>한계:</strong> Few-Shot 방식에 비해 추론의 형식이 일정하지 않고, 모델이 불필요한 말을 길게 늘어놓거나 논리가 삼천포로 빠질 위험이 있다. 또한, 매우 복잡한 포맷(예: 특정 JSON 형식으로 중간 과정을 기술)을 요구하는 경우에는 성능이 떨어진다.15</li>
</ul>
<h3>3.2  Few-Shot CoT: 예시를 통한 정교한 제어와 성능 극대화</h3>
<p>Few-Shot CoT는 사용자가 원하는 추론의 깊이, 스타일, 포맷을 정확히 반영한 예시를 <span class="math math-inline">k</span>개 제공한다.</p>
<ul>
<li><strong>메커니즘:</strong> 모델은 제공된 예시들과의 유사도(Similarity)에 기반하여 타겟 문제에 대한 답변을 생성한다. 예시가 논리적으로 엄밀하면 모델도 엄밀하게, 예시가 간결하면 모델도 간결하게 반응한다. 이는 모델의 출력을 사용자의 의도에 맞게 정렬(Alignment)하는 데 핵심적인 역할을 한다.16</li>
<li><strong>장점:</strong> Zero-Shot보다 일반적으로 성능이 우수하다. 특히 GSM8K와 같은 벤치마크에서 SOTA를 달성하기 위해서는 양질의 Few-Shot 예시가 필수적이다.2 또한, 출력 형식을 고정할 수 있어 후처리(Parsing)가 용이하다.</li>
<li><strong>단점:</strong> 고품질의 예시를 작성하는 데 인간의 노력이 필요하며(Prompt Engineering Cost), 예시의 질이나 순서에 따라 성능 편차가 발생할 수 있다. 잘못된 논리가 포함된 예시를 주면 모델도 그 오류를 모방할 수 있다.17</li>
</ul>
<p><strong>[표 2] Zero-Shot CoT와 Few-Shot CoT의 상세 비교</strong> 11</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Zero-Shot CoT</strong></th><th><strong>Few-Shot CoT</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 트리거</strong></td><td>“Let’s think step by step” 문구 추가</td><td>&lt;문제, 사고과정, 정답&gt;으로 구성된 예시 제공</td></tr>
<tr><td><strong>데이터 의존성</strong></td><td>낮음 (사전 학습된 지식에 전적으로 의존)</td><td>높음 (Task-Specific한 예시 데이터 필요)</td></tr>
<tr><td><strong>성능 (대형 모델)</strong></td><td>표준 프롬프팅 대비 우수, Few-Shot보다 다소 낮음</td><td>가장 우수한 성능 (SOTA), 높은 정확도</td></tr>
<tr><td><strong>출력 일관성</strong></td><td>낮음 (형식 제어 어려움)</td><td>높음 (예시의 형식을 모방)</td></tr>
<tr><td><strong>주요 사용 사례</strong></td><td>빠른 프로토타이핑, 낯선 도메인, 데이터 부족 시</td><td>고성능 요구 작업, 복잡한 포맷, 프로덕션 환경</td></tr>
<tr><td><strong>최신 트렌드</strong></td><td>Qwen2.5, DeepSeek-R1 등 최신 모델은 Zero-Shot으로도 강력한 성능 발휘</td><td>예시의 역할이 ’추론 능력 향상’보다 ’형식 맞춤’으로 이동하는 경향 16</td></tr>
</tbody></table>
<p>최근 연구(2025년 arXiv 자료 등)에 따르면, 모델이 더욱 고도화됨에 따라 Zero-Shot CoT의 성능이 비약적으로 향상되었으며, 일부 경우 Few-Shot 예시가 추론 자체의 질을 높이기보다는 출력 형식을 인간의 기대에 맞추는 역할에 그친다는 분석도 제기되었다.16</p>
<h2>4.  모델 규모의 법칙(Scaling Laws)과 창발적 능력(Emergent Abilities)</h2>
<p>CoT의 효용성은 모델의 파라미터 수(Model Scale)와 비선형적인 상관관계를 보인다. Wei 등의 초기 연구는 CoT가 특정 규모 이상의 모델에서만 발현되는 **‘창발적 능력(Emergent Ability)’**이라고 정의했다.2</p>
<h3>4.1  100B 파라미터 임계점과 성능의 도약</h3>
<p>실험 결과에 따르면, CoT는 약 1,000억(100B) 개 이상의 파라미터를 가진 모델(예: GPT-3 175B, PaLM 540B, LaMDA 137B)에서만 유의미한 성능 향상을 보인다.5</p>
<ul>
<li><strong>소형 모델 (&lt;10B):</strong> CoT를 적용해도 성능이 향상되지 않거나, 오히려 표준 프롬프팅보다 성능이 하락하는 현상이 관찰된다. 소형 모델은 유창한 문장을 생성할 수는 있으나, 긴 추론 사슬을 논리적으로 일관되게 유지할 역량이 부족하다. 이들은 종종 중간 단계에서 **환각(Hallucination)**을 일으키거나, 논리가 꼬여 엉뚱한 결론에 도달한다.4</li>
<li><strong>대형 모델 (&gt;100B):</strong> 모델 크기가 임계점을 넘어서면 CoT 적용 시 성능이 로그 선형적(Log-linear) 추세선을 넘어 급격히(Phase transition) 상승한다. PaLM 540B 모델의 경우, GSM8K 수학 벤치마크에서 CoT 적용 시 표준 프롬프팅 대비 압도적인 성능 향상을 보이며, 미세 조정된 GPT-3 모델을 능가하는 결과를 보여주었다.2</li>
</ul>
<h3>4.2  “신기루(Mirage)” 논쟁: 창발성은 측정의 착시인가?</h3>
<p>그러나 2023-2024년 학계 일각에서는 이러한 ’창발적 능력’이 측정 지표(Metric) 선택에 따른 착시일 수 있다는 <strong>“신기루(Mirage)” 가설</strong>을 제기했다.20</p>
<ul>
<li><strong>비선형 지표의 함정:</strong> ’정확도(Accuracy)’와 같이 맞으면 1, 틀리면 0인 비선형 지표를 사용할 경우, 모델의 능력이 특정 임계점에서 갑자기 나타나는 것처럼 보인다. 예를 들어, 5단계 추론 문제에서 모델이 4단계까지 맞추고 마지막에 틀리면 정확도는 0이지만, 실제 능력은 80%일 수 있다. 모델 성능이 조금만 향상되어 5단계를 모두 맞추게 되면 정확도는 0에서 1로 급격히 뛴다.</li>
<li><strong>연속적 개선:</strong> 반면, 토큰 예측 확률(Perplexity)과 같은 선형적이고 연속적인 지표를 사용하면, 모델의 성능은 규모에 따라 부드럽게(Smoothly) 향상되는 것으로 나타난다. 즉, 추론 능력은 갑자기 생겨나는 것이 아니라 규모에 따라 점진적으로 개선되지만, 우리가 ’정답’이라는 엄격한 잣대로 평가할 때만 급격한 변화처럼 보인다는 것이다.20</li>
</ul>
<p>또한, CoT 능력이 훈련 데이터 분포 내(In-Distribution)에서만 유효하며, 분포를 벗어난(Out-of-Distribution) 데이터에 대해서는 “깨지기 쉬운 신기루“처럼 사라진다는 연구 결과도 있다.22 이는 CoT가 진정한 의미의 범용 추론이 아니라, 훈련 데이터에 존재하는 추론 패턴을 정교하게 모방하는 것일 수 있음을 시사한다.</p>
<h2>5.  진보된 CoT 변형 기법: ToT, PoT, Active-Prompt</h2>
<p>기본적인 CoT의 한계를 극복하고 추론의 정확도를 높이기 위해 다양한 파생 기법들이 개발되었다.</p>
<h3>5.1  Tree of Thoughts (ToT): 선형적 사고를 넘어선 탐색</h3>
<p>CoT는 하나의 사고 흐름만을 따라가는 선형적(Linear) 방식이다. 그러나 인간은 어려운 문제를 풀 때 여러 가지 가능성을 고려하고, 막히면 되돌아가 다른 방법을 시도한다. **Tree of Thoughts (ToT)**는 이러한 인간의 시행착오 및 탐색 과정을 모델링한다.24</p>
<ul>
<li><strong>구조:</strong> 문제 해결 과정을 트리 구조로 시각화한다. 각 노드(Node)는 중간 생각(Thought)을 나타내며, 가지(Branch)는 다음 단계로의 진행을 의미한다.</li>
<li><strong>알고리즘:</strong> 너비 우선 탐색(BFS)이나 깊이 우선 탐색(DFS)과 같은 탐색 알고리즘을 결합하여, 모델이 각 단계에서 여러 대안을 생성하고 스스로 평가(Self-Evaluation)하여 최적의 경로를 선택하게 한다.</li>
<li><strong>성능:</strong> “24 게임(Game of 24)“이나 “창의적 글쓰기“와 같이 전략적인 탐색과 백트래킹(Backtracking)이 필요한 과제에서 CoT보다 월등한 성능을 보인다. CoT가 4%의 성공률을 보인 과제에서 ToT는 74%의 성공률을 기록하기도 했다.24</li>
</ul>
<p><strong>[표 3] Chain of Thought (CoT)와 Tree of Thoughts (ToT) 비교</strong> 25</p>
<table><thead><tr><th><strong>특성</strong></th><th><strong>Chain of Thought (CoT)</strong></th><th><strong>Tree of Thoughts (ToT)</strong></th></tr></thead><tbody>
<tr><td><strong>구조</strong></td><td>선형적 (Linear Sequence)</td><td>계층적 트리 (Hierarchical Tree)</td></tr>
<tr><td><strong>탐색 방식</strong></td><td>단일 경로 (Greedy Decoding)</td><td>다중 경로 탐색 (BFS, DFS)</td></tr>
<tr><td><strong>의사결정</strong></td><td>이전 토큰에 기반한 다음 토큰 예측</td><td>여러 대안을 비교 평가(Self-Reflection) 후 선택</td></tr>
<tr><td><strong>비용</strong></td><td>낮음 (한 번의 생성)</td><td>높음 (여러 번의 생성 및 평가 필요)</td></tr>
<tr><td><strong>적합 분야</strong></td><td>수학 문제, 상식 추론, 단계적 설명</td><td>퍼즐, 전략 게임, 계획 수립(Planning), 복합 창의성</td></tr>
</tbody></table>
<h3>5.2  Program of Thoughts (PoT): 계산과 추론의 분리</h3>
<p>LLM은 논리적 흐름을 잡는 데는 뛰어나지만, 7자리 숫자의 곱셈이나 복잡한 다항식 계산 등 정밀한 연산에서는 오류를 범하기 쉽다. **Program of Thoughts (PoT)**는 이러한 약점을 보완하기 위해 연산 부분을 프로그래밍 언어(주로 Python)로 생성하고, 실제 계산은 외부 인터프리터(Code Interpreter)에게 위임한다.27</p>
<ul>
<li><strong>메커니즘:</strong> 모델은 자연어로 논리를 전개하다가 계산이 필요한 순간 Python 코드를 생성한다. 예를 들어 “사과 30개를 5명이 나누면?“이라는 질문에 “30 / 5 = 6“이라고 텍스트로 쓰는 대신 <code>print(30/5)</code>라는 코드를 생성한다. 이 코드는 실행되어 정확한 결과값을 반환하고, 모델은 이를 받아 답변을 완성한다.</li>
<li><strong>효과:</strong> 수치 계산의 정확도가 100% 보장되므로, 금융 데이터 분석이나 과학적 계산이 포함된 문제에서 CoT보다 훨씬 높은 신뢰성을 제공한다. 실험 결과 Zero-Shot PoT가 Few-Shot CoT보다 성능이 우수하다는 결과도 있다.27</li>
</ul>
<h3>5.3  Active-Prompt: 불확실성에 기반한 능동적 학습</h3>
<p>Few-Shot CoT의 성능은 어떤 예시를 선택하느냐에 크게 좌우된다. <strong>Active-Prompt</strong>는 인간이 어떤 예시를 가르칠지 고민하는 과정을 자동화한 기법이다.17</p>
<ul>
<li><strong>방법:</strong> 모델에게 학습 데이터의 여러 질문을 풀게 한 뒤, 모델이 가장 확신하지 못하거나(Low Confidence), 여러 번 풀었을 때 답이 갈리는(High Disagreement) 질문들을 선별한다. 이 ‘어려운’ 질문들에 대해 인간이 정확한 CoT 주석을 달아 프롬프트 예시로 사용한다.</li>
<li><strong>결과:</strong> 무작위로 예시를 선택하는 것보다 훨씬 효율적으로 모델의 약점을 보완할 수 있으며, GSM8K 등의 벤치마크에서 CoT의 성능을 약 7% 이상 향상시킨다.</li>
</ul>
<h2>6.  CoT의 한계와 실무적 과제</h2>
<p>CoT는 강력하지만 만능은 아니며, 실제 서비스에 적용하기 위해서는 명확한 한계점들을 고려해야 한다.</p>
<h3>6.1  계산 비용과 지연 시간 (Latency &amp; Cost)</h3>
<p>CoT의 가장 큰 단점은 출력량이 많다는 것이다. 단순히 “정답: 5“라고 출력하는 대신, 수백 토큰에 달하는 추론 과정을 생성해야 하므로 추론 시간과 API 비용이 급격히 증가한다.29 실시간 응답이 중요한 챗봇(Chatbot)이나 음성 비서 서비스에서는 이러한 지연(Latency)이 사용자 경험을 해칠 수 있다. 이를 해결하기 위해 성능 저하를 최소화하며 추론 길이를 줄이는 ‘Concise CoT’ 연구가 진행되고 있다.30</p>
<h3>6.2  충실성(Faithfulness)과 환각(Hallucination)</h3>
<p>모델이 출력한 사고 과정이 실제 모델 내부의 결정 메커니즘과 일치한다는 보장이 없다. 이를 <strong>충실성 문제</strong>라고 한다. 모델은 때때로 정답을 맞혔지만 설명은 틀리게 하거나, 설명은 그럴싸하지만 정답은 틀리는 경우가 있다.29 또한, 모델이 추론 과정 중에 사실이 아닌 정보를 지어내는 환각 현상이 발생하면, 이 오류가 다음 단계로 전파(Error Propagation)되어 전체 논리를 무너뜨릴 수 있다. 이는 의료나 법률과 같이 높은 신뢰성이 요구되는 분야에서 CoT 도입을 주저하게 만드는 요인이다.21</p>
<h3>6.3  소형 모델(SLM)에서의 적용 난이도</h3>
<p>앞서 논의했듯 CoT는 거대 모델에서만 효과적이다. 그러나 온디바이스 AI(On-device AI)나 비용 절감을 위해 소형 모델(SLM)을 사용해야 하는 환경에서는 CoT를 적용하기 어렵다. 최근에는 GPT-4와 같은 거대 모델이 생성한 고품질 CoT 데이터를 소형 모델에 학습시키는 **지식 증류(Knowledge Distillation)**나 <strong>Fine-tuning</strong> 기법을 통해, 10B 이하의 모델에서도 CoT 능력을 이식하려는 시도가 활발하다.31 2024-2025년 연구들은 이러한 ’Solution Guidance’를 통해 소형 모델이 거대 모델의 추론 능력을 상당 부분 모방할 수 있음을 보여준다.</p>
<h2>7.  주요 벤치마크 실험 결과 분석</h2>
<p>CoT의 효과는 다양한 추론 벤치마크에서 입증되었다.</p>
<ol>
<li><strong>GSM8K (초등학교 수준 수학 문제):</strong></li>
</ol>
<ul>
<li>CoT가 가장 큰 효과를 발휘하는 영역이다. PaLM 540B 모델은 CoT 적용 시 정답률이 17.9%에서 58.1%로 3배 이상 급등했다.5 이는 모델이 문제를 수식으로 변환하고 계산하는 과정을 언어적으로 풀어나가는 데 CoT가 결정적임을 보여준다.</li>
</ul>
<ol start="2">
<li><strong>CommonsenseQA (상식 추론):</strong></li>
</ol>
<ul>
<li>“강을 건너려면 무엇이 필요한가?“와 같이 배경 지식이 필요한 문제에서도 CoT는 단계적 논리를 통해 정답률을 높인다. 다만, 산술 문제만큼의 드라마틱한 향상보다는 점진적인 개선을 보인다.12</li>
</ul>
<ol start="3">
<li><strong>Symbolic Reasoning (심볼릭 추론):</strong></li>
</ol>
<ul>
<li>“동전 뒤집기“나 “문자열 조작“과 같이 엄밀한 규칙을 따라야 하는 과제에서, CoT 없이는 거의 랜덤에 가까운 성능을 보이던 모델들이 CoT 적용 후 90% 이상의 정확도를 달성하기도 한다.4</li>
</ul>
<h2>8.  결론 및 미래 전망</h2>
<p>Few-Shot Chain-of-Thought (CoT) 프롬프팅은 대규모 언어 모델이 단순한 통계적 앵무새를 넘어, 논리적 사고를 흉내 낼 수 있는 ’추론 기계(Reasoning Engine)’로 진화하는 데 결정적인 역할을 했다. 예시를 통해 사고의 과정을 보여주는 직관적인 방법론은 복잡한 수학 문제, 상식 추론, 심볼릭 연산 등에서 모델의 성능을 비약적으로 향상시켰다.</p>
<p>그러나 CoT가 보여주는 추론 능력이 진정한 의미의 ’지능’인지, 아니면 거대 데이터와 파라미터가 만들어낸 ’통계적 신기루’인지에 대한 논쟁은 여전하다. 또한 높은 비용과 환각 문제는 해결해야 할 과제이다.</p>
<p>향후 AI 연구는 다음과 같은 방향으로 전개될 것으로 전망된다.</p>
<ol>
<li><strong>내재화된 추론 (Internalized Reasoning):</strong> 겉으로 텍스트를 뱉어내지 않고도 내부 히든 스테이트(Hidden State) 상에서 추론을 수행하도록 모델을 훈련시키는 연구.</li>
<li><strong>시스템 2의 강화:</strong> ToT나 PoT처럼 모델이 스스로의 사고를 검증하고, 외부 도구를 적극적으로 활용하여 신뢰성을 담보하는 하이브리드 아키텍처의 발전.</li>
<li><strong>데이터 효율성:</strong> 소수의 예시조차 필요 없는 강력한 Zero-Shot 추론 모델의 등장과, 소형 모델로의 효율적인 능력 전이(Distillation).</li>
</ol>
<p>결론적으로, CoT는 현재의 생성형 AI가 가진 한계를 돌파하는 강력한 도구이며, 향후 AGI(일반 인공지능)로 나아가는 과정에서 모델의 ’사고 과정’을 이해하고 제어하는 핵심적인 인터페이스로 자리 잡을 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models - Summary, https://portkey.ai/blog/chain-of-thought-prompting-elicits-reasoning-in-large-language-models-summary/</li>
<li>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models - arXiv, https://arxiv.org/abs/2201.11903</li>
<li>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models - OpenReview, https://openreview.net/pdf?id=_VjQlMeSB_J</li>
<li>Chain-of-Thought Prompting, https://learnprompting.org/docs/intermediate/chain_of_thought</li>
<li>Language Models Perform Reasoning via Chain of Thought - Google Research, https://research.google/blog/language-models-perform-reasoning-via-chain-of-thought/</li>
<li>Chain-of-Thought Prompting Elicits Reasoning in Large Language Models - arXiv, https://arxiv.org/pdf/2201.11903</li>
<li>What is chain of thought (CoT) prompting? - IBM, https://www.ibm.com/think/topics/chain-of-thoughts</li>
<li>Few-Shot &amp; Chain-of-Thought Prompting - Emergent Mind, https://www.emergentmind.com/topics/few-shot-and-chain-of-thought-prompting</li>
<li>Comprehensive Guide to Chain-of-Thought Prompting - Mercity AI, https://www.mercity.ai/blog-post/guide-to-chain-of-thought-prompting</li>
<li>Chain-of-thought, tree-of-thought, and graph-of-thought: Prompting techniques explained, https://wandb.ai/sauravmaheshkar/prompting-techniques/reports/Chain-of-thought-tree-of-thought-and-graph-of-thought-Prompting-techniques-explained—Vmlldzo4MzQwNjMx</li>
<li>What is zero-shot prompting? - IBM, https://www.ibm.com/think/topics/zero-shot-prompting</li>
<li>Chain-of-Thought Prompting | Prompt Engineering Guide, https://www.promptingguide.ai/techniques/cot</li>
<li>Zero-Shot vs. Few-Shot Prompting: Key Differences - Shelf.io, https://shelf.io/blog/zero-shot-and-few-shot-prompting/</li>
<li>Unpacking chain-of-thought prompting: a new paradigm in AI reasoning - Toloka AI, https://toloka.ai/blog/unpacking-chain-of-thought-prompting-a-new-paradigm-in-ai-reasoning/</li>
<li>AI Prompting (2/10): Chain-of-Thought Prompting—4 Methods for Better Reasoning - Reddit, https://www.reddit.com/r/ChatGPTPromptGenius/comments/1if2dai/ai_prompting_210_chainofthought_prompting4/</li>
<li>Revisiting Chain-of-Thought Prompting: Zero-shot Can Be Stronger than Few-shot - arXiv, https://arxiv.org/html/2506.14641</li>
<li>Source code for the paper “Active Prompting with Chain-of-Thought for Large Language Models” - GitHub, https://github.com/shizhediao/active-prompt</li>
<li>Emergent Abilities in Large Language Models: A Survey - arXiv, https://arxiv.org/html/2503.05788v1</li>
<li>Think step by step with a chain of thought | by Pakhapoom Sarapat | Medium, https://pakhapoomsarapat.medium.com/think-step-by-step-with-a-chain-of-thought-df813a0113d2</li>
<li>[2304.15004] Are Emergent Abilities of Large Language Models a Mirage? - arXiv, https://arxiv.org/abs/2304.15004</li>
<li>Emergent Abilities in Large Language Models: An Explainer - CSET Georgetown, https://cset.georgetown.edu/article/emergent-abilities-in-large-language-models-an-explainer/</li>
<li>Is Chain-of-Thought Reasoning of LLMs a Mirage? A Data Distribution Lens - arXiv, https://arxiv.org/html/2508.01191v2</li>
<li>Is Chain-of-Thought Reasoning of LLMs a Mirage? A Data Distribution Lens - arXiv, https://arxiv.org/html/2508.01191v3</li>
<li>Tree of Thoughts (ToT) - Prompt Engineering Guide, https://www.promptingguide.ai/techniques/tot</li>
<li>What is Tree Of Thoughts Prompting? - IBM, https://www.ibm.com/think/topics/tree-of-thoughts</li>
<li>Chain of Thoughts vs Tree of Thoughts for Language Learning Models (LLMs) - Medium, https://medium.com/@sonal.sareen/chain-of-thoughts-vs-tree-of-thoughts-for-language-learning-models-llms-fc11efbd20ab</li>
<li>Program of Thoughts Prompting: Enhancing Accuracy in Reasoning and Computation, https://learnprompting.org/docs/advanced/decomposition/program_of_thoughts</li>
<li>Program of Thoughts Prompting Guide - PromptHub, https://www.prompthub.us/blog/program-of-thoughts-prompting-guide</li>
<li>Chain-of-thought (CoT) prompting: Complete overview [2025] | SuperAnnotate, https://www.superannotate.com/blog/chain-of-thought-cot-prompting</li>
<li>The Benefits of a Concise Chain of Thought on Problem-Solving in Large Language Models, https://arxiv.org/html/2401.05618v1</li>
<li>Aligning Large and Small Language Models via Chain-of-Thought Reasoning - ACL Anthology, https://aclanthology.org/2024.eacl-long.109/</li>
<li>[2412.09906] Enhancing the Reasoning Capabilities of Small Language Models via Solution Guidance Fine-Tuning - arXiv, https://arxiv.org/abs/2412.09906</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>