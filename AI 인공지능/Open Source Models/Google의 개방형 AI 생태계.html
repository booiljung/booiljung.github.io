<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Google의 개방형 AI 생태계</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Google의 개방형 AI 생태계</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">오픈 소스 AI 모델</a> / <span>Google의 개방형 AI 생태계</span></nav>
                </div>
            </header>
            <article>
                <h1>Google의 개방형 AI 생태계</h1>
<h2>1. 서론: Google AI와 오픈소스의 공진화(共進化)</h2>
<p>Google의 인공지능(AI) 발전사는 단순한 내부 기술 개발의 연대기를 넘어, 전 세계 개발자 및 연구자 커뮤니티와의 적극적인 상호작용을 통해 형성된 공진화(共進化)의 기록이라 할 수 있다. Google은 초기 머신러닝 연구 단계부터 대규모 머신러닝의 대중화를 이끈 TensorFlow 프레임워크를 시작으로, 자연어 처리(NLP)의 패러다임을 바꾼 Transformer 아키텍처, BERT, T5와 같은 핵심 기술들을 연이어 오픈소스 형태로 공개하며 AI 생태계의 기술적 표준을 정립하고 그 발전을 주도해왔다.1 본 안내서는 Google이 구축해 온 개방형 AI 생태계의 역사를 기술적 진보와 전략적 선택이라는 두 가지 축을 중심으로 심층적으로 분석하고, 각 기술이 AI 분야에 미친 영향과 그 이면에 담긴 의미를 탐구하고자 한다.</p>
<p>안내서의 분석을 명확히 하기 위해, 먼저 핵심 용어인 ’오픈소스’와 ’오픈 모델’을 구분하여 정의한다. 본 안내서에서 ’오픈소스(Open-Source)’는 TensorFlow나 BERT와 같이 Apache 2.0 라이선스 하에 배포되어 소스 코드, 사전 훈련된 가중치, 관련 데이터 등 모든 구성 요소가 상업적 목적을 포함하여 어떠한 제약 없이 자유롭게 사용, 수정, 재배포될 수 있는 경우를 지칭한다.3 이는 오픈소스 이니셔티브(OSI)가 제시하는 정의에 부합하는 가장 넓은 의미의 개방성을 의미한다. 반면, ‘오픈 모델(Open Models)’ 또는 ’오픈 웨이트(Open Weights)’는 Gemma 모델군과 같이 모델의 가중치(weights)에 대한 접근은 허용되지만, 특정 상업적 사용에 대한 제한이나 유해 콘텐츠 생성 금지와 같은 독자적인 사용 약관(Terms of Use)이 적용되는 경우로 한정한다.5 이 두 개념의 구분은 Google의 개방형 AI 전략이 시대의 흐름과 기술의 발전에 따라 어떻게 변화해왔는지를 이해하는 데 핵심적인 분석틀을 제공한다.</p>
<p>본 안내서는 총 4개의 장으로 구성된다. 제1장에서는 현대 AI 시대의 기술적 초석이 된 TensorFlow 프레임워크와 Transformer 아키텍처의 핵심 개념과 의의를 분석한다. 제2장에서는 NLP 분야에 전이 학습(transfer learning) 패러다임을 확립한 기념비적인 사전 훈련 모델 BERT와 T5의 아키텍처와 훈련 방식을 심층적으로 탐구한다. 제3장에서는 Google의 최신 개방형 모델 전략을 대표하는 Gemma 모델군을 상세히 분석하며, 그 기술적 특징과 Gemini 모델과의 관계, 그리고 라이선스 정책의 변화가 갖는 전략적 의미를 고찰한다. 마지막으로 제4장에서는 객관적인 벤치마크 데이터를 기반으로 Gemma와 주요 경쟁 모델들의 성능을 비교 분석하고, 이를 통해 소형 언어 모델 시장의 경쟁 구도를 조망한다. 결론에서는 이 모든 분석을 종합하여 Google 개방형 AI 전략의 현재를 평가하고 미래를 전망하며 개발자와 연구자를 위한 제언을 제시한다.</p>
<h3>1.1 핵심 테이블 1: Google 주요 개방형 AI 자산 요약</h3>
<table><thead><tr><th>자산명</th><th>최초 공개</th><th>핵심 아키텍처/개념</th><th>라이선스</th><th>주요 기여</th></tr></thead><tbody>
<tr><td><strong>TensorFlow</strong></td><td>2015년 11월 1</td><td>텐서(Tensor) &amp; 연산 그래프(Graph)</td><td>Apache 2.0 8</td><td>대규모 머신러NING의 대중화 및 표준 프레임워크 제공</td></tr>
<tr><td><strong>Transformer</strong></td><td>2017년 6월 9</td><td>Self-Attention Mechanism</td><td>- (연구 논문)</td><td>순환(Recurrence) 구조를 탈피한 병렬 처리 가능한 NLP 아키텍처 제시</td></tr>
<tr><td><strong>BERT</strong></td><td>2018년 10월 4</td><td>양방향 Transformer 인코더</td><td>Apache 2.0 4</td><td>MLM &amp; NSP를 통한 깊은 양방향 문맥 이해, 전이 학습의 표준화</td></tr>
<tr><td><strong>T5</strong></td><td>2019년 10월 11</td><td>Text-to-Text Transformer (인코더-디코더)</td><td>Apache 2.0 11</td><td>모든 NLP 과업을 단일 프레임워크로 통합, 전이 학습의 한계 탐구</td></tr>
<tr><td><strong>Gemma</strong></td><td>2024년 2월 2</td><td>Gemini 기반 경량 Transformer 디코더</td><td>Gemma Terms of Use 12</td><td>고성능 경량 모델의 접근성 확대 및 책임감 있는 AI 개발 지원</td></tr>
</tbody></table>
<h2>2.  모든 것의 기반 - TensorFlow와 Transformer 아키텍처</h2>
<p>현대 AI 기술의 눈부신 발전은 두 가지 핵심적인 기술적 기반 위에 세워졌다. 하나는 대규모 데이터를 효율적으로 처리하고 복잡한 모델을 훈련시킬 수 있는 소프트웨어 프레임워크이며, 다른 하나는 병렬 처리를 통해 계산 효율성을 극대화한 신경망 아키텍처이다. Google은 이 두 영역 모두에서 결정적인 기여를 했는데, 바로 TensorFlow 프레임워크와 Transformer 아키텍처의 제시다. 이 장에서는 이 두 가지 기술적 초석의 핵심 개념을 심층적으로 분석하고, 이들이 어떻게 상호작용하며 AI 시대의 문을 열었는지 탐구한다.</p>
<h3>2.1  TensorFlow: 머신러닝의 민주화</h3>
<p>2015년 Google Brain 팀에 의해 공개된 TensorFlow는 복잡하고 계산 집약적인 머신러닝 모델 개발을 전 세계 개발자 누구나 접근 가능하게 만들며 ’머신러닝의 민주화’를 이끈 주역이다.7 그 성공의 중심에는 텐서(Tensor)와 연산 그래프(Computational Graph)라는 두 가지 핵심 개념이 자리 잡고 있다.</p>
<h4>2.1.1 핵심 개념: 텐서(Tensor)와 연산 그래프(Computational Graph)</h4>
<p>**텐서(Tensor)**는 TensorFlow에서 사용되는 기본 데이터 구조로, 균일한 데이터 타입(<code>dtype</code>)을 갖는 다차원 배열을 의미한다.14 이는 수치 데이터를 체계적으로 표현하는 가장 효율적인 방식으로, 스칼라(0차원), 벡터(1차원), 행렬(2차원)뿐만 아니라 임의의 고차원 데이터까지 포괄한다. 개념적으로 NumPy의</p>
<p><code>ndarray</code>와 유사하지만, 텐서는 GPU(Graphics Processing Unit)나 Google이 자체 개발한 TPU(Tensor Processing Unit)와 같은 하드웨어 가속기에서의 병렬 연산에 고도로 최적화되어 있어 대규모 딥러닝 모델의 훈련을 가능하게 하는 핵심 요소이다.13</p>
<p>**연산 그래프(Computational Graph)**는 TensorFlow의 작동 원리를 설명하는 추상적인 개념이다. 모든 수학적 연산은 그래프의 노드(node)로, 연산 간에 흐르는 다차원 데이터 배열, 즉 텐서는 엣지(edge)로 표현된다.13 개발자가 모델 코드를 작성하면, TensorFlow는 이를 즉시 실행하는 대신 먼저 연산 그래프를 구축한다. 이 ‘지연 실행(deferred execution)’ 방식은 여러 가지 중요한 장점을 제공한다. 첫째, 전체 계산 과정을 한눈에 파악하고 최적화할 수 있어 연산 효율성을 극대화한다. 둘째, 그래프는 특정 플랫폼에 종속되지 않는 추상적인 표현이므로, 한 번 정의된 모델을 CPU, GPU, TPU, 모바일 기기 등 다양한 환경에 코드 수정 없이 배포할 수 있는 이식성(portability)을 보장한다.13 셋째, 모델의 모든 파라미터에 대한 그래디언트(gradient)를 자동으로 계산하는 ‘자동 미분(automatic differentiation)’ 과정을 체계적으로 관리하여, 복잡한 신경망의 역전파(backpropagation) 알고리즘을 효율적으로 수행하게 한다.13 TensorFlow 2.x 버전부터는 개발 편의성을 위해 즉시 실행 방식인 ’Eager Execution’이 기본으로 채택되었으나, 여전히 <code>@tf.function</code> 데코레이터를 통해 Python 코드를 고성능의 최적화된 연산 그래프로 변환하여 성능과 이식성의 이점을 누릴 수 있다.16</p>
<h4>2.1.2 TensorFlow 생태계와 Apache 2.0 라이선스의 의의</h4>
<p>TensorFlow는 단순한 계산 라이브러리를 넘어, 데이터 준비(<code>tf.data</code>), 모델 설계 및 훈련(Keras), 프로덕션 환경 배포(TensorFlow Serving, TFX), 모바일 및 엣지 디바이스 최적화(LiteRT, 이전 TensorFlow Lite)에 이르는 머신러닝 개발의 전 과정을 지원하는 포괄적인 엔드투엔드(end-to-end) 플랫폼으로 발전했다.17 특히, TensorFlow의 핵심 고수준 API로 통합된 Keras는 직관적이고 사용자 친화적인 인터페이스를 제공하여, 복잡한 딥러닝 모델을 레고 블록처럼 쉽게 조립할 수 있게 함으로써 모델 구축의 진입 장벽을 획기적으로 낮췄다.14</p>
<p>이러한 기술적 우수성과 더불어 TensorFlow의 폭발적인 확산을 가능하게 한 가장 중요한 요인은 바로 <strong>Apache 2.0 라이선스</strong> 정책이었다. Apache 2.0은 특허권의 명시적 허용을 포함하며, 상업적 활용, 수정, 재배포 등 거의 모든 형태의 사용을 허용하는 매우 관대한 오픈소스 라이선스이다.3 Google은 이 라이선스 정책을 통해 TensorFlow를 전 세계에 무료로 공개함으로써, 특정 기업에 종속되지 않는 거대한 개발자 및 연구자 생태계를 구축했다. 이는 TensorFlow를 머신러닝 분야의 사실상 표준(de facto standard)으로 자리매김하게 했으며, AI 기술의 민주화를 통해 장기적으로 Google의 AI 플랫폼 영향력을 강화하려는 초기 전략을 명확하게 보여주는 사례이다.8</p>
<h3>2.2  Transformer: NLP의 혁명</h3>
<p>TensorFlow가 머신러닝의 ’방법론’을 대중화했다면, 2017년 Google 연구진이 발표한 논문 **“Attention Is All You Need”**는 자연어 처리(NLP)의 ’아키텍처’를 근본적으로 바꾸는 혁명을 일으켰다.9 이 논문에서 제안된 ‘Transformer’ 아키텍처는 기존 NLP 모델들의 고질적인 한계였던 순차적 데이터 처리를 완전히 배제하고, ’어텐션(Attention)’이라는 단일 메커니즘에만 의존하여 문장의 의미를 이해하는 새로운 패러다임을 제시했다.22</p>
<h4>2.2.1 Self-Attention 메커니즘과 아키텍처 구성 요소</h4>
<p>Transformer의 심장이라 할 수 있는 <strong>Self-Attention</strong> 메커니즘은 문장 내의 모든 단어 쌍 간의 연관성을 직접적으로, 그리고 동시에 계산한다. 이를 통해 각 단어의 의미를 문장 전체의 문맥 속에서 파악한다. 예를 들어, “그는 강둑(bank)에 앉아 은행(bank) 계좌를 확인했다“라는 문장에서, Self-Attention은 첫 번째 ’bank’가 ’강둑’과, 두 번째 ’bank’가 ’계좌’와 더 높은 연관성을 가짐을 계산하여 두 단어의 의미를 구별해낸다. 이 방식은 두 가지 혁신적인 장점을 가져왔다. 첫째, 단어 간의 거리에 상관없이 의존성을 포착할 수 있어 기존의 순환 신경망(RNN)이나 LSTM이 어려움을 겪었던 장거리 의존성(long-range dependency) 문제를 효과적으로 해결했다. 둘째, 모든 계산이 행렬 연산을 통해 병렬적으로 처리될 수 있어, 순차적으로 단어를 처리해야 했던 RNN 계열 모델에 비해 훈련 시간을 획기적으로 단축시켰다.10 Scaled Dot-Product Attention의 계산식은 다음과 같이 표현된다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
위 식에서 Q(Query), K(Key), V(Value)는 동일한 입력 시퀀스로부터 선형 변환을 통해 생성된 행렬들이며, dk는 Key 벡터의 차원을 나타내는 스케일링 인자이다.9</p>
<p>Transformer 아키텍처는 Self-Attention 외에도 몇 가지 중요한 구성 요소를 포함한다. <strong>Multi-Head Attention</strong>은 단일 어텐션 연산을 여러 개의 ’헤드(head)’로 나누어 병렬적으로 수행하는 기법으로, 모델이 각기 다른 관점(representation subspace)에서 단어 간의 다양한 관계를 동시에 학습할 수 있게 한다.9 또한, 순서 개념이 없는 Self-Attention에 단어의 위치 정보를 부여하기 위해, 사인(sine)과 코사인(cosine) 함수를 이용한 고유한 값인 <strong>Positional Encoding</strong>을 단어 임베딩에 더해준다.9 전체적으로 Transformer는 입력 시퀀스의 문맥적 표현을 생성하는 <strong>인코더(Encoder)</strong> 스택과, 인코더의 출력을 바탕으로 목표 시퀀스를 생성하는 <strong>디코더(Decoder)</strong> 스택으로 구성된 표준적인 시퀀스-투-시퀀스(sequence-to-sequence) 구조를 따른다.22</p>
<h4>2.2.2 기술적 인과관계의 분석</h4>
<p>Transformer 아키텍처의 등장은 독립적인 사건이 아니라, 당시 성숙기에 접어든 기술적 환경과의 필연적인 상호작용의 결과물이었다. 기존 RNN/LSTM 모델의 근본적인 한계는 순차적 처리 방식에서 비롯된 병렬화의 어려움이었다. 아무리 많은 계산 자원이 있어도, 문장의 첫 단어부터 마지막 단어까지 순서대로 계산해야 했기에 훈련 속도를 높이는 데 명백한 한계가 존재했다. “Attention Is All You Need” 논문은 이 문제를 정면으로 돌파하기 위해 ‘순환(recurrence)’ 구조 자체를 완전히 제거하는 과감한 선택을 했다.21</p>
<p>Self-Attention 메커니즘은 모든 토큰 쌍의 관계를 단 한 번의 행렬 곱셈으로 계산할 수 있어, 본질적으로 대규모 병렬 처리에 완벽하게 부합하는 구조이다. 이러한 아키텍처의 잠재력은 TensorFlow와 같은 병렬 컴퓨팅 프레임워크와 TPU와 같은 전용 하드웨어가 제공하는 대규모 분산 컴퓨팅 능력과 결합되었을 때 비로소 폭발적으로 발현될 수 있었다.1 즉, 대규모 병렬 연산이 가능한 **인프라(TensorFlow/TPU)**의 존재는 병렬 처리에 최적화된 **아키텍처(Transformer)**의 탄생을 위한 ’필요조건’이었으며, 역으로 Transformer의 등장은 TensorFlow 생태계와 TPU의 활용도를 극대화하며 AI 모델의 스케일업 경쟁을 촉발하는 ’충분조건’이 되었다. 이는 하드웨어, 소프트웨어 프레임워크, 그리고 모델 아키텍처가 서로를 자극하며 발전하는 선순환 구조를 형성했음을 명확히 보여준다.</p>
<h2>3.  사전 훈련 모델의 시대 - BERT와 T5</h2>
<p>Transformer 아키텍처의 등장은 자연어 처리(NLP) 분야에 새로운 가능성을 열었지만, 그 잠재력을 완전히 끌어낸 것은 ’사전 훈련(pre-training)’과 ’미세 조정(fine-tuning)’이라는 새로운 패러다임이었다. Google은 이 패러다임을 주도하며 BERT와 T5라는 두 개의 기념비적인 모델을 연이어 발표했다. 이 모델들은 대규모의 레이블 없는 텍스트 데이터로부터 언어 자체에 대한 깊은 이해를 학습한 후, 소량의 특정 과업 데이터로 미세 조정하여 다양한 NLP 문제에서 전례 없는 성능을 달성했다. 이 장에서는 NLP의 지형을 바꾼 두 거인, BERT와 T5의 핵심 철학과 기술적 특징을 심층 비교 분석한다.</p>
<h3>3.1  BERT (Bidirectional Encoder Representations from Transformers)</h3>
<p>2018년에 발표된 BERT는 ’양방향성(bidirectionality)’이라는 개념을 NLP에 본격적으로 도입하며 패러다임의 전환을 이끌었다. 이전의 언어 모델들이 문맥을 이해할 때 주로 왼쪽에서 오른쪽(GPT 계열)으로만 보거나, 양방향을 고려하더라도 그 깊이가 얕았던(ELMo) 반면, BERT는 Transformer의 인코더 구조만을 활용하여 문장 내 모든 단어의 왼쪽과 오른쪽 문맥을 처음부터 끝까지, 모든 계층에서 ‘동시에’ 고려하는 깊은 양방향(deeply bidirectional) 표현을 학습하는 데 성공했다.23</p>
<h4>3.1.1 핵심 사전 훈련(Pre-training) 방식</h4>
<p>BERT의 혁신적인 양방향 학습은 두 가지 독창적인 사전 훈련 과업을 통해 구현되었다.</p>
<ol>
<li><strong>Masked Language Model (MLM):</strong> 이 방식은 마치 빈칸 채우기 문제를 푸는 것과 같다. 입력 문장에서 무작위로 15%의 토큰을 선택한 뒤, 이 중 80%는 특수한 <code>토큰으로 바꾸고, 10%는 다른 무작위 토큰으로, 나머지 10%는 원래 토큰을 그대로 둔다. 모델은 이렇게 손상된 문장을 보고,</code> 위치에 원래 어떤 단어가 있었는지를 주변 문맥 전체를 활용하여 예측하도록 훈련된다.23 이 과정을 통해 모델은 단어의 의미를 양쪽 문맥 속에서 깊이 있게 파악하는 능력을 기르게 된다.</li>
<li><strong>Next Sentence Prediction (NSP):</strong> 이 과업은 모델이 두 문장 사이의 논리적 관계를 이해하도록 훈련시킨다. 훈련 데이터에서 연속된 두 문장 A와 B를 가져와 50%의 확률로 그대로 사용하고(‘IsNext’ 레이블), 나머지 50%는 B를 전혀 상관없는 다른 문장으로 교체한다(‘NotNext’ 레이블). 모델은 주어진 문장 쌍이 원래 연속된 문장이었는지를 맞추는 이진 분류 문제를 풀게 된다. 이를 통해 BERT는 단순한 단어 의미를 넘어 담화 수준의 일관성(coherence)이나 인과 관계(causality)와 같은 문장 간의 관계를 학습하게 된다.24</li>
</ol>
<h4>3.1.2 아키텍처 및 활용</h4>
<p>BERT는 기본적으로 Transformer 인코더를 여러 층으로 쌓은 구조이다. Google은 두 가지 크기의 모델을 공개했는데, <code>BERT_BASE</code>는 12개의 인코더 층과 1억 1천만 개의 파라미터를, <code>BERT_LARGE</code>는 24개의 인코더 층과 3억 4천만 개의 파라미터를 가진다.25</p>
<p>BERT의 가장 큰 기여는 NLP 분야에 전이 학습(transfer learning) 패러다임을 성공적으로 정착시킨 점이다. 대규모 코퍼스(BookCorpus, Wikipedia)로 사전 훈련된 BERT 모델은 그 자체로 강력한 범용 언어 이해 능력을 갖추고 있다. 따라서 감성 분석, 질의응답, 개체명 인식과 같은 다양한 다운스트림(downstream) 과업을 수행할 때, 복잡한 모델을 처음부터 설계할 필요 없이 사전 훈련된 BERT 모델의 최상단에 간단한 분류 레이어 하나만 추가하여 해당 과업의 데이터로 미세 조정(fine-tuning)하는 것만으로도 당시의 최첨단(State-of-the-Art, SOTA) 성능을 손쉽게 달성할 수 있었다.24 이 방식은 NLP 모델 개발에 필요한 데이터와 컴퓨팅 자원을 획기적으로 줄여주었으며, TensorFlow와 마찬가지로 <strong>Apache 2.0 라이선스</strong>로 공개되어 학계와 산업계 전반에 빠르게 확산되었다.4</p>
<h3>3.2  T5 (Text-to-Text Transfer Transformer)</h3>
<p>BERT가 언어 ‘이해(understanding)’ 능력에 초점을 맞추었다면, 2019년에 등장한 T5는 한 걸음 더 나아가 모든 NLP 과업을 언어 ’생성(generation)’의 관점에서 재해석하는 통합적인 프레임워크를 제시했다. T5라는 이름은 “Text-to-Text Transfer Transformer“의 약자로, 그 핵심 철학을 명확하게 보여준다.28</p>
<h4>3.2.1 통합적 접근법: “Text-to-Text” 프레임워크</h4>
<p>T5의 가장 큰 혁신은 번역, 요약, 분류, 질의응답 등 각기 다른 형태를 가진 모든 NLP 과업을 “텍스트 입력“을 받아 “텍스트 출력“을 생성하는 단일한 형식으로 통일한 것이다.11 이는 각 과업에 맞는 별도의 모델 아키텍처나 출력 레이어를 설계할 필요 없이, 동일한 모델을 사용하여 모든 문제를 풀 수 있음을 의미한다. 모델은 수행해야 할 과업을 입력 텍스트에 포함된 ’접두사(prefix)’를 통해 구분한다. 예를 들어,</p>
<ul>
<li><strong>번역:</strong> <code>translate English to German: That is good.</code> → <code>Das ist gut.</code></li>
<li><strong>요약:</strong> <code>summarize: state authorities dispatched emergency crews...</code> → <code>emergency crews dispatched to scene.</code></li>
<li><strong>문법성 판단(분류):</strong> <code>cola sentence: The course is jumping well.</code> → <code>not acceptable</code></li>
</ul>
<p>이러한 접근 방식은 연구와 개발의 복잡성을 극도로 단순화시켰고, 모델이 다양한 과업 간의 지식을 전이하는 능력을 극대화했다.30</p>
<h4>3.2.2 아키텍처 및 사전 훈련</h4>
<p>이러한 Text-to-Text 프레임워크를 구현하기 위해, T5는 Transformer의 표준적인 <strong>인코더-디코더(Encoder-Decoder)</strong> 구조를 채택했다.11 인코더는 접두사를 포함한 입력 텍스트 전체의 문맥을 이해하여 풍부한 표현(representation)을 생성하고, 디코더는 이 표현을 바탕으로 목표 텍스트를 자기회귀적(auto-regressive)으로 생성한다. 이는 BERT와 달리 디코더를 포함하고 있어, 번역이나 요약과 같은 자유로운 텍스트 생성 과업에 자연스럽게 적용될 수 있다.</p>
<p>T5의 사전 훈련 목표는 ’denoising objective(노이즈 제거 목표)’로 요약된다. 이는 원본 텍스트의 일부를 의도적으로 손상(corrupt)시킨 후, 모델이 원래의 깨끗한 텍스트를 복원하도록 학습시키는 방식이다. T5는 특히 연속된 단어 그룹(span)을 단 하나의 특수 마스크 토큰으로 대체하고, 디코더가 이 마스크된 단어들을 순서대로 생성하도록 하는 <strong>‘Span Corruption’</strong> 방식을 주로 사용했다.32</p>
<h4>3.2.3 규모와 데이터, 그리고 라이선스</h4>
<p>T5 프로젝트는 “Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer“라는 논문과 함께 발표되었으며, 이 논문은 모델 크기, 훈련 데이터의 종류와 양, 사전 훈련 방식 등 다양한 변수들이 전이 학습 성능에 미치는 영향을 체계적으로 탐구한 대규모 실험 안내서의 성격을 띤다.33 이 연구를 위해 Google은 웹 크롤링 데이터인 Common Crawl을 정제하여 약 750GB에 달하는 **C4(Colossal Clean Crawled Corpus)**라는 방대한 데이터셋을 구축했다.11 모델은 Small 버전부터 최대 110억 개의 파라미터를 가진 버전까지 다양한 크기로 실험 및 공개되었다.11 BERT와 마찬가지로 T5 역시 <strong>Apache 2.0 라이선스</strong>로 배포되어 자유로운 연구와 상업적 활용을 장려했으며, 그 코드베이스는 이후 JAX 기반의 고성능 프레임워크인 T5X로 계승 및 발전되었다.11</p>
<h3>3.3 핵심 테이블 2: BERT와 T5의 아키텍처 및 사전 훈련 방식 비교</h3>
<table><thead><tr><th>구분</th><th><strong>BERT (Bidirectional Encoder Representations from Transformers)</strong></th><th><strong>T5 (Text-to-Text Transfer Transformer)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 철학</strong></td><td>깊은 양방향 문맥 <strong>표현(Representation)</strong> 학습</td><td>모든 NLP 과업의 <strong>텍스트-to-텍스트</strong> 통합</td></tr>
<tr><td><strong>아키텍처</strong></td><td>Transformer 인코더 (Encoder-only)</td><td>Transformer 인코더-디코더 (Encoder-Decoder)</td></tr>
<tr><td><strong>사전 훈련 목표</strong></td><td>1. Masked Language Model (MLM) 2. Next Sentence Prediction (NSP)</td><td>Denoising Objective (주로 Span Corruption)</td></tr>
<tr><td><strong>입/출력 형태</strong></td><td>입력: 문장 쌍 출력: 각 토큰의 문맥적 임베딩, `` 토큰 임베딩</td><td>입력: 과업 접두사가 포함된 텍스트 출력: 생성된 텍스트</td></tr>
<tr><td><strong>주요 활용 분야</strong></td><td>문장 분류, 개체명 인식, 질의응답 등 <strong>이해(NLU)</strong> 기반 과업</td><td>번역, 요약, 질의응답 등 <strong>생성(NLG)</strong> 및 이해 과업 모두</td></tr>
<tr><td><strong>참조</strong></td><td>23</td><td>11</td></tr>
</tbody></table>
<h2>4.  새로운 세대의 개방성 - Gemma 모델군</h2>
<p>BERT와 T5가 NLP 분야의 기술적 표준을 확립한 이후, AI 시장은 OpenAI의 GPT 시리즈와 Meta의 Llama 시리즈가 주도하는 초거대 언어 모델(LLM) 경쟁 시대로 접어들었다. 이러한 환경 속에서 Google은 2024년, 자사의 최첨단 상용 모델인 Gemini의 기술력을 바탕으로 한 새로운 ‘오픈 모델’ 제품군, Gemma를 선보였다. Gemma의 등장은 단순한 신규 모델 출시를 넘어, 변화된 AI 시장 환경에 대응하는 Google의 정교한 전략과 ’개방성’에 대한 재정의를 담고 있다. 이 장에서는 Gemma의 개발 배경, 아키텍처, 확장된 생태계, 그리고 라이선스 정책의 변화를 심층적으로 분석한다.</p>
<h3>4.1  개발 배경 및 Gemini와의 관계</h3>
<p>Gemma는 Google의 가장 강력하고 진보된 상용 AI 모델인 Gemini와 동일한 연구 기반 및 기술을 공유하며 개발된 경량(lightweight) 오픈 모델 제품군이다.2 라틴어로 ’보석’을 의미하는 이름에서 알 수 있듯이, Gemma는 Gemini의 핵심 기술을 계승하면서도 더 작고 효율적인 형태로 다듬어져 개발자 및 연구자 커뮤니티가 더 쉽게 접근하고 활용할 수 있도록 설계되었다.</p>
<p>이러한 출시는 AI 시장에서 Google이 구사하는 정교한 <strong>이원화(Dual-Track) 전략</strong>의 발현으로 해석될 수 있다. AI 모델 경쟁의 최전선에서는 OpenAI의 GPT-4o와 같은 모델과 직접적으로 경쟁하기 위해 막대한 자본과 데이터를 투입한 초거대 상용 모델, 즉 Gemini(예: Gemini 2.5 Pro)를 API 형태로 제공하며 기술적 우위를 과시하고 수익을 창출한다.39 이러한 최첨단 모델들은 그 자체로 핵심적인 상업 자산이므로, 가중치를 포함한 모든 것을 공개하기는 어렵다.</p>
<p>동시에, AI 생태계의 주도권을 장악하기 위해서는 전 세계 개발자들의 광범위한 채택과 참여가 필수적이다. 개발자들은 자유롭게 실험하고, 자신의 목적에 맞게 미세 조정하며, 로컬 하드웨어나 자체 인프라에서 직접 실행할 수 있는 모델을 선호한다. 바로 이 지점에서 Gemma가 역할을 수행한다. Google은 Gemini의 기술력을 바탕으로 한 고성능 경량 모델 Gemma를 ‘오픈 모델’ 형태로 공개함으로써, Meta의 Llama나 Mistral AI와 같은 경쟁자들과 오픈소스 커뮤니티의 지지를 놓고 경쟁한다. ’Gemini 기술 기반’이라는 점을 적극적으로 강조하는 것은 2, 비록 경량 모델이지만 최첨단 기술의 DNA를 품고 있다는 점을 어필하여 개발자들에게 매력도를 높이는 효과적인 브랜딩 전략이기도 하다. 결국, Gemma의 출시는 Google이 AI 시장에서 **최첨단 성능 경쟁(Gemini)**과 **생태계 주도권 경쟁(Gemma)**이라는 두 마리 토끼를 동시에 잡으려는 전략적 포석인 것이다.</p>
<h3>4.2  아키텍처 심층 분석</h3>
<p>Gemma는 현대적인 LLM의 표준 아키텍처인 <strong>Transformer의 디코더-온리(decoder-only)</strong> 구조를 기반으로 한다.12 이는 입력된 프롬프트(prompt)를 바탕으로 다음 단어를 순차적으로 예측하여 텍스트를 생성하는 데 최적화된 구조이다. Gemma는 여기에 더해, 지난 몇 년간의 연구를 통해 검증된 다양한 최신 아키텍처 개선 사항들을 적극적으로 채택하여 성능과 효율성을 극대화했다.</p>
<ul>
<li><strong>Multi-Query / Grouped-Query Attention:</strong> 전통적인 Multi-Head Attention(MHA)은 모든 어텐션 헤드가 독립적인 Key(K)와 Value(V) 행렬을 가지는 반면, **Multi-Query Attention(MQA)**은 모든 헤드가 단 하나의 K, V 행렬을 공유한다. 이는 추론 시 메모리 대역폭 요구량을 크게 줄여 속도를 향상시키는 효과가 있다. Gemma 1세대 2B 모델은 이 MQA를 채택하여 효율성을 높였다.43 이후 등장한 **Grouped-Query Attention(GQA)**은 MHA와 MQA의 절충안으로, 여러 헤드가 그룹을 지어 K, V 행렬을 공유한다. 이는 MQA의 효율성을 상당 부분 유지하면서 MHA의 성능 저하를 최소화하는 방식으로, Gemma 3 모델군에 적용되었다.45</li>
<li><strong>RoPE (Rotary Positional Embeddings):</strong> 기존의 절대 위치 임베딩 방식과 달리, RoPE는 각 토큰의 위치 정보를 임베딩 벡터를 특정 각도로 ’회전’시키는 방식으로 주입한다. 이는 모델이 토큰 간의 상대적인 위치 관계를 더 잘 학습하게 하여, 특히 훈련 시 보았던 것보다 긴 시퀀스를 처리해야 할 때(extrapolation) 더 강건한 성능을 보인다.43</li>
<li><strong>GeGLU Activations:</strong> Transformer 블록 내의 Feed-Forward Network에서 사용되는 활성화 함수로, 표준적인 ReLU 대신 GeGLU(Gated Linear Unit의 변형)를 사용했다. GeGLU는 입력에 따라 활성화 경로를 동적으로 조절하는 ‘게이팅(gating)’ 메커니즘을 포함하여, 모델의 표현력을 높이는 데 기여하는 것으로 알려져 있다.42</li>
<li><strong>RMSNorm:</strong> 각 Transformer 서브레이어(어텐션, FFN)의 입력에 적용되는 정규화 기법으로, 기존의 LayerNorm보다 계산이 간단하면서도 안정적인 훈련을 가능하게 한다.44</li>
</ul>
<h3>4.3  모델 생태계 확장</h3>
<p>Google은 Gemma를 단일 모델이 아닌, 다양한 규모와 목적에 맞게 특화된 모델 ’가족(family)’으로 출시하여 광범위한 개발자 수요에 대응하고 있다.46</p>
<ul>
<li><strong>세대별 진화 (Gemma 1, 2, 3):</strong> Gemma는 세대를 거듭하며 빠르게 진화하고 있다. 초기 2B, 7B 모델에서 시작하여 9B, 27B 등 더 다양한 파라미터 크기를 제공하게 되었다. 특히 <strong>Gemma 3</strong>부터는 텍스트뿐만 아니라 이미지도 입력으로 받을 수 있는 <strong>멀티모달(multimodal)</strong> 기능을 지원하며, 컨텍스트 처리 길이를 128,000 토큰까지 대폭 확장하여 한 번에 방대한 양의 정보를 처리할 수 있게 되었다.40</li>
<li><strong>도메인 특화 모델:</strong> 범용 모델을 넘어, 특정 분야에 최적화된 파생 모델들을 지속적으로 출시하며 생태계를 확장하고 있다.</li>
<li><strong>CodeGemma:</strong> 코드 생성, 완성, 디버깅 등 프로그래밍 과업에 특화된 모델이다.42</li>
<li><strong>PaliGemma:</strong> 이미지 캡셔닝, 시각적 질의응답(VQA) 등 이미지와 텍스트를 함께 다루는 Vision-Language Model(VLM)이다.42</li>
<li><strong>MedGemma:</strong> 의료 분야의 텍스트와 이미지(X-ray, 병리 슬라이드 등)를 이해하고 분석하는 데 특화된 모델로, 헬스케어 AI 애플리케이션 개발을 가속화한다.46</li>
<li><strong>RecurrentGemma:</strong> Transformer의 어텐션 메커니즘과 RNN의 순환 구조를 결합한 새로운 ‘Griffin’ 아키텍처를 기반으로 한다. 이는 긴 시퀀스를 생성할 때 메모리 사용량을 줄이고 추론 속도를 높이는 것을 목표로 한다.46</li>
</ul>
<p>이러한 다각화된 모델 생태계는 개발자들이 각자의 도메인 문제에 가장 적합한 모델을 선택하여 활용할 수 있도록 지원한다. 또한, Kaggle, Google Colab, Vertex AI 등 Google의 자체 플랫폼과의 긴밀한 통합을 통해 개발자들이 손쉽게 Gemma 모델을 실험하고 배포할 수 있는 환경을 제공함으로써, Google AI 생태계로의 자연스러운 유입과 락인(lock-in) 효과를 동시에 추구하고 있다.2</p>
<h3>4.4  라이선스와 사용 제약</h3>
<p>Gemma의 라이선스 정책은 Google의 변화된 전략을 가장 명확하게 보여주는 부분이다. TensorFlow나 BERT가 채택했던 전통적인 오픈소스 라이선스인 Apache 2.0 대신, Gemma는 별도의 **‘Gemma Terms of Use’**를 따른다.12 이 약관은 규모에 상관없이 모든 조직의 책임감 있는 상업적 사용과 배포를 허용하지만 54, 동시에 유해하거나 불법적인 목적으로 모델을 사용하는 것을 명시적으로 금지하는 조항을 포함하고 있다.6</p>
<p>이는 AI 기술의 발전과 함께 ’개방성’의 개념이 어떻게 진화하고 있는지를 보여주는 중요한 사례이다. 초기 AI 모델들은 그 자체로 직접적인 사회적 위협을 가할 가능성이 낮았고, 기술 확산과 생태계 구축이 최우선 과제였기에 가장 허용적인 Apache 2.0 라이선스가 전략적으로 유리했다. 그러나 LLM의 능력이 비약적으로 발전하면서, 모델이 생성하는 콘텐츠의 유해성, 편향성, 악용 가능성에 대한 사회적, 법적 책임 문제가 중요한 화두로 떠올랐다.</p>
<p>완전한 오픈소스 라이선스는 모델이 어떻게 사용될지에 대한 통제권을 개발사가 사실상 포기함을 의미하며, 이는 예측 불가능한 법적, 윤리적 리스크를 야기할 수 있다. 따라서 Google은 모델 가중치와 코드를 공개하여 ’개방성’이 주는 이점(빠른 기술 전파, 개발자 커뮤니티의 기여, 생태계 확장)은 그대로 취하면서도, ’사용 약관’이라는 법적 장치를 통해 최소한의 안전장치와 통제권(유해 사용 금지)을 확보하는 절충안을 선택한 것이다. 이는 ’오픈소스’의 순수성보다는 ’책임감 있는 AI(Responsible AI)’라는 명분을 내세운 전략적 선택이며, Meta의 Llama 라이선스와 유사한 흐름을 따르는, 현대 LLM 시대의 새로운 ’조건부 개방성’이라 할 수 있다.</p>
<h3>4.5 핵심 테이블 3: Gemma 모델군 상세 제원 비교</h3>
<table><thead><tr><th>모델명</th><th>파라미터</th><th>컨텍스트 길이</th><th>모달리티</th><th>주요 아키텍처 특징</th></tr></thead><tbody>
<tr><td><strong>Gemma 1 (7B)</strong></td><td>7B</td><td>8K</td><td>텍스트</td><td>MHA, RoPE, GeGLU, RMSNorm</td></tr>
<tr><td><strong>Gemma 1 (2B)</strong></td><td>2B</td><td>8K</td><td>텍스트</td><td>MQA, RoPE, GeGLU, RMSNorm</td></tr>
<tr><td><strong>Gemma 2 (27B)</strong></td><td>27B</td><td>8K</td><td>텍스트</td><td>아키텍처 개선, 증류(distillation) 학습 적용</td></tr>
<tr><td><strong>Gemma 2 (9B)</strong></td><td>9B</td><td>8K</td><td>텍스트</td><td>아키텍처 개선, 증류(distillation) 학습 적용</td></tr>
<tr><td><strong>Gemma 3 (27B)</strong></td><td>27B</td><td>128K</td><td>이미지, 텍스트</td><td>GQA, Local/Global Attention 혼합, Pan &amp; Scan</td></tr>
<tr><td><strong>Gemma 3 (12B)</strong></td><td>12B</td><td>128K</td><td>이미지, 텍스트</td><td>GQA, Local/Global Attention 혼합, Pan &amp; Scan</td></tr>
<tr><td><strong>Gemma 3 (4B)</strong></td><td>4B</td><td>128K</td><td>이미지, 텍스트</td><td>GQA, Local/Global Attention 혼합, Pan &amp; Scan</td></tr>
<tr><td><strong>RecurrentGemma (9B)</strong></td><td>9B</td><td>-</td><td>텍스트</td><td>Griffin 아키텍처 (Local Attention + Linear Recurrence)</td></tr>
</tbody></table>
<p>참조: 12</p>
<h2>5.  생태계 내 경쟁 구도 및 성능 분석</h2>
<p>Gemma의 출시는 특히 7B~10B 파라미터 규모의 소형 언어 모델(Small Language Model, SLM) 시장에서 Meta의 Llama 3와 Mistral AI의 Mistral 7B와 같은 강력한 경쟁자들과의 직접적인 대결을 의미한다. 이들 SLM은 비교적 적은 컴퓨팅 자원으로도 구동이 가능하여, 연구, 프로토타이핑, 특정 애플리케이션 배포 등 다양한 분야에서 활용도가 높기 때문에 개발자 커뮤니티의 주도권을 잡기 위한 핵심 격전지이다. 이 장에서는 표준화된 벤치마크를 통해 이들 주요 모델의 성능을 객관적으로 비교하고, 그 결과가 시사하는 전략적 의미를 분석한다.</p>
<h3>5.1 주요 벤치마크를 통한 객관적 성능 평가</h3>
<p>SLM의 성능은 주로 다음과 같은 표준화된 벤치마크들을 통해 다각적으로 평가된다.56</p>
<ul>
<li><strong>MMLU (Massive Multi-Task Language Understanding):</strong> 57개의 다양한 주제(초등 수학, 미국사, 컴퓨터 과학, 법률 등)에 대한 다지선다형 질문을 통해 모델의 광범위한 지식과 문제 해결 능력을 종합적으로 평가한다.</li>
<li><strong>GSM8K (Grade School Math 8K):</strong> 여러 단계의 추론이 필요한 초등학교 수준의 수학 응용 문제를 푸는 능력을 평가하여, 모델의 기본적인 수학적, 논리적 추론 능력을 측정한다.</li>
<li><strong>MATH:</strong> 대수학, 기하학, 미적분 등 더 높은 수준의 수학 문제를 해결하는 능력을 평가한다.</li>
<li><strong>HumanEval:</strong> 주어진 함수 설명(docstring)에 따라 올바른 Python 코드를 생성하는 능력을 평가하여, 모델의 코딩 능력을 측정한다.</li>
</ul>
<h3>5.2 Gemma vs. Llama 3 vs. Mistral 7B 심층 비교</h3>
<p>최신 벤치마크 결과들을 종합하면, 각 모델은 특정 영역에서 두각을 나타내며 뚜렷한 강점과 약점을 보인다.</p>
<ul>
<li><strong>MMLU (일반 지식 및 추론):</strong> 이 벤치마크에서는 <strong>Gemma 2 9B</strong>가 71.3%의 점수를 기록하며, 66.7%를 기록한 Llama 3.1 8B를 눈에 띄게 앞섰다.57 이는 Gemma 모델군이 Google의 방대한 웹 데이터 기반 학습을 통해 광범위한 주제에 대한 일반 지식과 다중작업 추론 능력에서 강점을 가질 수 있음을 시사한다. Mistral 7B는 이들보다 다소 낮은 약 54%대의 성능을 보이는 것으로 평가된다.58</li>
<li><strong>MATH (고등 수학):</strong> 수학 문제 해결 능력에서는 <strong>Llama 3.1 8B</strong>가 51.9%(0-shot)의 점수로 36.6%(4-shot)를 기록한 Gemma 2 9B보다 월등히 높은 성능을 보였다.57 이는 Meta가 Llama 3 개발 과정에서 수학적 추론 및 코딩 능력 향상에 전략적으로 집중했음을 보여주는 결과이다. GSM8K와 HumanEval 벤치마크에서도 Llama 3의 대형 모델(70B)이 경쟁 모델들을 압도하는 경향이 나타나는데 56, 이러한 특성이 8B 모델에도 일부 반영된 것으로 분석된다.</li>
</ul>
<p>이러한 벤치마크 점수의 차이는 단순히 어떤 모델이 전반적으로 더 우수하다고 결론 내리기보다는, 각 모델이 어떤 능력에 특화되도록 ’전략적으로 튜닝되었는가’의 문제로 해석해야 한다. LLM의 최종 성능은 아키텍처뿐만 아니라, 사전 훈련 데이터의 구성 비율과 미세 조정에 사용된 데이터의 종류 및 품질에 의해 결정적인 영향을 받는다. Gemma는 “웹 문서, 수학, 코드“를 훈련 데이터로 사용했다고 명시했으며 43, Llama 3는 이전 세대보다 코드 데이터의 비중을 높였다고 알려져 있다.61</p>
<p>Gemma 2 9B가 MMLU(일반 지식)에서, Llama 3.1 8B가 MATH(수학)에서 각각 강점을 보이는 결과는 57, 두 회사가 훈련 데이터셋의 구성과 후속 튜닝 과정에서 서로 다른 강점을 목표로 삼았음을 시사한다. Google은 자사의 핵심 자산인 방대한 웹 데이터를 기반으로 한 범용적인 지식(Knowledge)과 추론(Reasoning) 능력 강화에, Meta는 개발자 커뮤니티의 수요가 높은 수학 및 코딩(Math &amp; Code) 능력 강화에 더 많은 리소스를 투입했을 가능성이 있다. 따라서 사용자는 단일 벤치마크 점수에 의존하기보다는, 자신의 주된 사용 사례(예: 정보 검색 및 요약을 위한 챗봇 vs. 코드 생성을 위한 개발 도우미)에 가장 부합하는 벤치마크 결과를 중심으로 모델을 선택하는 것이 합리적이다. 즉, SLM 시장의 경쟁은 절대적인 성능 우위를 가리는 경쟁이 아니라, 각기 다른 필요를 가진 사용자 그룹을 공략하기 위한 전략적 트레이드오프의 결과물이라 할 수 있다.</p>
<h3>5.3 핵심 테이블 4: 소형 LLM 벤치마크 성능 비교</h3>
<table><thead><tr><th>벤치마크</th><th><strong>Gemma 2 (9B)</strong></th><th><strong>Llama 3.1 (8B)</strong></th><th><strong>Mistral (7B)</strong></th><th>비고</th></tr></thead><tbody>
<tr><td><strong>MMLU (5-shot)</strong></td><td><strong>71.3%</strong> 57</td><td>66.7% 57</td><td>~54.0% 58</td><td>일반 지식 및 추론 능력</td></tr>
<tr><td><strong>GSM8K</strong></td><td>-</td><td>-</td><td>-</td><td>초등 수학 추론 (데이터 부족, Llama 대형 모델이 강세)</td></tr>
<tr><td><strong>MATH</strong></td><td>36.6% (4-shot) 57</td><td><strong>51.9%</strong> (0-shot) 57</td><td>-</td><td>고등 수학 문제 해결</td></tr>
<tr><td><strong>HumanEval (pass@1)</strong></td><td>40.2% 57</td><td>-</td><td>-</td><td>코드 생성 능력 (데이터 부족, Llama 대형 모델이 강세)</td></tr>
<tr><td><strong>HellaSwag (10-shot)</strong></td><td><strong>81.9%</strong> 57</td><td>-</td><td>-</td><td>상식 추론</td></tr>
</tbody></table>
<h2>6. 결론: Google 오픈소스 AI의 현재와 미래</h2>
<p>Google의 개방형 AI 생태계는 지난 10여 년간 뚜렷한 기술적, 전략적 궤적을 그리며 발전해왔다. 그 여정은 대규모 병렬 연산을 위한 **프레임워크(TensorFlow)**를 제공하여 AI 개발의 기틀을 마련하는 것에서 출발했다. 이를 기반으로 순환 구조의 한계를 극복한 병렬 처리 **아키텍처(Transformer)**를 발명했으며, 이 아키텍처를 활용하여 언어에 대한 깊은 이해를 담은 **사전 훈련 모델(BERT, T5)**을 탄생시켜 전이 학습 시대를 열었다. 그리고 마침내, 최첨단 상용 기술을 경량화하여 개발자 커뮤니티의 접근성을 높인 **전략적 오픈 모델(Gemma)**을 출시하며 현재에 이르렀다.</p>
<p>Google의 현재 전략은 Gemini라는 폐쇄형 상용 모델과 Gemma라는 개방형 모델을 축으로 하는 <strong>이원화 전략</strong>으로 요약된다. 이 전략은 AI 기술의 최전선에서 상업적 이익을 극대화하는 동시에, 개발자 생태계의 주도권을 확보하려는 효과적인 접근법이다. 단기적으로는 수익 창출과 생태계 확장을 동시에 꾀할 수 있으나, 장기적으로는 ’Gemma Terms of Use’와 같은 조건부 개방성이 커뮤니티의 완전한 신뢰를 얻는 데 어떤 영향을 미칠지, 그리고 ’책임감 있는 AI’라는 가치와 ‘완전한 개방성’ 사이에서 어떻게 균형을 맞출 것인지에 대한 지속적인 고민이 요구될 것이다.</p>
<p>이러한 분석을 바탕으로, 개발자와 연구자들은 AI 모델을 선택할 때 다음과 같은 다각적인 고려를 해야 한다.</p>
<ol>
<li><strong>라이선스 제약:</strong> 프로젝트의 최종 목표가 완전한 상업적 자유를 요구한다면 Apache 2.0 라이선스가 적용된 T5나 BERT의 파생 모델들을 고려해야 한다. 반면, Google이 제시하는 사용 약관 범위 내에서의 활용이 가능하다면 최신 성능을 제공하는 Gemma가 더 나은 선택일 수 있다.</li>
<li><strong>과업 특화성:</strong> 벤치마크 분석에서 나타났듯이, 모델들은 특정 영역에 강점을 보인다. 광범위한 지식 기반의 자연어 이해(NLU) 과업이 중심이라면 MMLU에서 강세를 보인 Gemma가, 수학적 추론이나 코드 생성 관련 과업이 중요하다면 MATH 벤치마크에서 우위를 보인 Llama가 더 나은 출발점이 될 수 있다.</li>
<li><strong>생태계 및 인프라 호환성:</strong> TensorFlow, JAX, 그리고 Vertex AI와 같은 Google Cloud 플랫폼에 익숙한 개발자에게는 Gemma를 비롯한 Google의 모델들이 더 높은 생산성을 제공할 수 있다. 반면, Hugging Face를 중심으로 한 PyTorch 생태계에서는 모든 주요 모델들이 활발하게 지원되고 있어 선택의 폭이 넓다.</li>
</ol>
<p>향후 AI 모델의 경쟁은 단순히 파라미터 크기를 늘리는 경쟁을 넘어, MedGemma와 같이 특정 도메인에 고도로 특화된 소형 모델이나, RecurrentGemma처럼 더 적은 컴퓨팅 자원으로 더 높은 효율을 내는 새로운 아키텍처를 탐구하는 방향으로 다각화될 것이다. Google의 개방형 AI 전략 역시 이러한 흐름에 발맞춰 더욱 세분화되고 정교하게 진화할 것으로 전망된다. 결국, Google이 지난 10년간 쌓아온 개방형 AI 생태계는 미래 AI 기술의 향방을 결정하는 데 있어 여전히 중요한 역할을 수행할 것이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Our AI journey and milestones - Google AI, https://ai.google/our-ai-journey/</li>
<li>Gemma: Introducing new state-of-the-art open models - The Keyword, https://blog.google/technology/developers/gemma-open-models/</li>
<li>License - tensorflow/examples - GitHub, https://github.com/tensorflow/examples/blob/master/LICENSE</li>
<li>BERT (language model) - Wikipedia, https://en.wikipedia.org/wiki/BERT_(language_model)</li>
<li>[기획브리핑] 생성형 AI와 오픈소스 : 주요 모델의 OSAID 1.0 기준 분석 - 공개SW 포털, https://www.oss.kr/oss_guide/show/c183d6f6-7530-4097-bc23-cc1c43d5a3fe</li>
<li>Open Source AI | Google Cloud, https://cloud.google.com/use-cases/open-source-ai</li>
<li>TensorFlow - Wikipedia, https://en.wikipedia.org/wiki/TensorFlow</li>
<li>tensorflow/tensorflow: An Open Source Machine Learning Framework for Everyone - GitHub, https://github.com/tensorflow/tensorflow</li>
<li>Attention Is All You Need - Wikipedia, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need</li>
<li>Attention Is All You Need https://arxiv.org/abs/1706.03762 It’s from 2017 but I … | Hacker News, https://news.ycombinator.com/item?id=25351357</li>
<li>T5 (language model) - Wikipedia, https://en.wikipedia.org/wiki/T5_(language_model)</li>
<li>google/gemma-7b - Hugging Face, https://huggingface.co/google/gemma-7b</li>
<li>What Is TensorFlow? | NVIDIA Glossary, https://www.nvidia.com/en-us/glossary/tensorflow/</li>
<li>Introduction to TensorFlow and Keras - Development Seed, https://developmentseed.org/servir-amazonia-ml/docs/Lesson1b_Intro_TensorFlow_Keras.html</li>
<li>Introduction to TensorFlow - GeeksforGeeks, https://www.geeksforgeeks.org/python/introduction-to-tensorflow/</li>
<li>Guide | TensorFlow Core, https://www.tensorflow.org/guide</li>
<li>What Is TensorFlow? Definition, Use Cases, and More - Coursera, https://www.coursera.org/articles/what-is-tensorflow</li>
<li>Introduction to TensorFlow, https://www.tensorflow.org/learn</li>
<li>TensorFlow, https://www.tensorflow.org/</li>
<li>LICENSE - external/github.com/tensorflow/tensorflow - Git at Google, https://chromium.googlesource.com/external/github.com/tensorflow/tensorflow/+/r0.10/LICENSE</li>
<li>Attention is All you Need - NIPS, https://papers.nips.cc/paper/7181-attention-is-all-you-need</li>
<li>Attention Is All You Need - arXiv, https://arxiv.org/html/1706.03762v7</li>
<li>What Is BERT Language Model? Its Advantages And Applications - Neurond AI, https://www.neurond.com/blog/what-is-bert</li>
<li>BERT Model - NLP - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/explanation-of-bert-model-nlp/</li>
<li>BERT Architecture Explained for Beginners - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2022/11/comprehensive-guide-to-bert/</li>
<li>BERT 101 - State Of The Art NLP Model Explained - Hugging Face, https://huggingface.co/blog/bert-101</li>
<li>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding, https://research.google/pubs/bert-pre-training-of-deep-bidirectional-transformers-for-language-understanding/</li>
<li>huggingface.co, <a href="https://huggingface.co/docs/transformers/en/model_doc/t5#:~:text=T5%20is%20a%20encoder-decoder,into%20a%20text%20generation%20task.">https://huggingface.co/docs/transformers/en/model_doc/t5#:~:text=T5%20is%20a%20encoder%2Ddecoder,into%20a%20text%20generation%20task.</a></li>
<li>T5 (Text-to-Text Transfer Transformer) - GeeksforGeeks, https://www.geeksforgeeks.org/nlp/t5-text-to-text-transfer-transformer/</li>
<li>Summary of Text To Text Transfer Transformer — T5 | by Gundluru Chadrasekhar | Scavs.ai, https://medium.com/scavs-ai/summing-up-dl-2-t5-text-to-text-transfer-transformer-eedf1c0bc63b</li>
<li>T5 - Hugging Face, https://huggingface.co/docs/transformers/model_doc/t5</li>
<li>A Unified Text-to-Text Framework for NLP Tasks: An Overview of T5 Model, https://blog.paperspace.com/flan-t5-architecture/</li>
<li>Exploring Transfer Learning with T5 : the Text-To-Text Transfer Transformer (2) - 끄적끄적, https://soundprovider.tistory.com/entry/Exploring-Transfer-Learning-with-T5-the-Text-To-Text-Transfer-Transformer-2</li>
<li>Exploring Transfer Learning with T5: the Text-To-Text Transfer Transformer, https://research.google/blog/exploring-transfer-learning-with-t5-the-text-to-text-transfer-transformer/</li>
<li>google-research/text-to-text-transfer-transformer: Code for the paper “Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer” - GitHub, https://github.com/google-research/text-to-text-transfer-transformer</li>
<li>google-research/t5x - GitHub, https://github.com/google-research/t5x</li>
<li>Models - Google DeepMind, https://deepmind.google/models/</li>
<li>Gemma - Google DeepMind, https://deepmind.google/models/gemma/</li>
<li>Gemini 모델 | Gemini API | Google AI for Developers, https://ai.google.dev/gemini-api/docs/models?hl=ko</li>
<li>Google 모델 | Generative AI on Vertex AI, https://cloud.google.com/vertex-ai/generative-ai/docs/models?hl=ko</li>
<li>2025년 최고의 10대 대규모 언어 모델LLMs - Botpress, https://botpress.com/ko/blog/best-large-language-models</li>
<li>Gemma explained: An overview of Gemma model family architectures - Google Developers Blog, https://developers.googleblog.com/gemma-explained-overview-gemma-model-family-architectures</li>
<li>Gemma | Prompt Engineering Guide, https://www.promptingguide.ai/models/gemma</li>
<li>Gemma: Open Models Based on Gemini Research and Technology - arXiv, https://arxiv.org/html/2403.08295v1</li>
<li>(PDF) Gemma 3 Technical Report - ResearchGate, https://www.researchgate.net/publication/390175982_Gemma_3_Technical_Report</li>
<li>Google - Hugging Face, https://huggingface.co/google</li>
<li>What Is Google Gemma? | IBM, https://www.ibm.com/think/topics/google-gemma</li>
<li>Gemma 3 model overview | Google AI for Developers, https://ai.google.dev/gemma/docs/core</li>
<li>google/gemma-3-27b-it - Hugging Face, https://huggingface.co/google/gemma-3-27b-it</li>
<li>[2503.19786] Gemma 3 Technical Report - arXiv, https://arxiv.org/abs/2503.19786</li>
<li>google/medgemma-4b-it - Hugging Face, https://huggingface.co/google/medgemma-4b-it</li>
<li>Google-Health/medgemma - GitHub, https://github.com/Google-Health/medgemma</li>
<li>google-deepmind/recurrentgemma: Open weights language model from Google DeepMind, based on Griffin. - GitHub, https://github.com/google-deepmind/recurrentgemma</li>
<li>How to run open source model Gemma on Dify? - Dify Blog, https://dify.ai/blog/how-to-run-open-source-model-gemma-on-dify</li>
<li>google/gemma-2b-it-pytorch - Hugging Face, https://huggingface.co/google/gemma-2b-it-pytorch</li>
<li>Mistral 7B vs. Llama 3 70B vs. Gemma 2 9B: A Comprehensive Benchmark Showdown | by Samir Sengupta | Medium, https://medium.com/@samir20/mistral-7b-vs-llama-3-70b-vs-gemma-2-9b-a-comprehensive-benchmark-showdown-9c3128f24b23</li>
<li>Gemma 2 9B vs Llama 3.1 8B Instruct | AIModels.fyi, https://www.aimodels.fyi/compare/gemma-2-9b-vs-llama-3-1-8b-instruct</li>
<li>Benchmarks for Gemma 7B seem to be in the ballpark of Mistral 7B +———––+… | Hacker News, https://news.ycombinator.com/item?id=39453780</li>
<li>Gemma 2 vs Llama 3: Which Model Is Better for You in 2024? - Novita AI Blog, https://blogs.novita.ai/gemma-2-vs-llama-3-which-model-is-better-for-you-in-2024/</li>
<li>Why to choose Gemma as an open AI model | by Georgios Soloupis | Google for Developers EMEA | Medium, https://medium.com/googledeveloperseurope/why-to-choose-gemma-as-an-open-ai-model-37385f8cd20a</li>
<li>Llama 3 8B vs Mistral 7B: Small LLM Pricing Considerations - Vantage, https://www.vantage.sh/blog/best-small-llm-llama-3-8b-vs-mistral-7b-cost</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>