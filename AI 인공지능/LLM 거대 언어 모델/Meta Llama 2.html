<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Meta Llama 2 (2023-07-18)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Meta Llama 2 (2023-07-18)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">거대 언어 모델 (LLM, Large Language Models)</a> / <span>Meta Llama 2 (2023-07-18)</span></nav>
                </div>
            </header>
            <article>
                <h1>Meta Llama 2 (2023-07-18)</h1>
<h2>1. 서론</h2>
<p>2023년 7월 18일, Meta는 Microsoft와의 파트너십을 통해 차세대 대규모 언어 모델(LLM)인 Llama 2를 발표하며 인공지능(AI) 생태계에 중대한 전환점을 제시했다.1 Llama 2는 이전 세대인 Llama 1이 비상업적 라이선스 하에 연구자에게만 제한적으로 제공되었던 것과 달리, 연구 및 상업적 목적으로 무료로 제공되어 고성능 LLM에 대한 접근성을 획기적으로 개선했다.4 이러한 개방 정책은 고성능 모델 개발이 소수의 대기업에 의해 독점되는 폐쇄형 생태계에 대한 강력한 대안을 제시했으며, 이미지 생성 분야에서 Stable Diffusion이 미친 영향력에 비견될 만한 파급력을 지닌다.1</p>
<p>Llama 2는 70억(7B), 130억(13B), 700억(70B)의 세 가지 매개변수 크기로 구성된 모델 제품군으로, 광범위한 데이터로 사전 훈련된 기본 모델(Foundation Model)과 대화형 작업에 특화되어 미세 조정된 Llama 2-Chat 모델로 나뉜다.1 Llama 2의 핵심 목표는 최첨단에 근접하는 성능을 유지하면서도, 모델 가중치를 포함한 핵심 결과물을 공개함으로써 AI 연구와 상용화의 문턱을 낮추는 데 있다. 이는 단순히 기술을 공개하는 것을 넘어, 책임감 있는 AI 혁신 생태계를 조성하려는 Meta의 전략적 의도를 반영한다.7</p>
<p>Llama 2의 출시는 단순한 기술적 업데이트를 넘어선다. Llama 1이 학계에 기여하는 ’연구 도구’로서의 성격이 강했다면, Llama 2는 Microsoft Azure, Amazon Web Services (AWS), Google Cloud와 같은 주요 클라우드 플랫폼과의 협력을 통해 상업적 활용을 전면에 내세운 ’생태계 촉진자’로서의 역할을 지향한다.2 이는 API 중심의 폐쇄형 모델이 지배하던 시장 구도에 직접적으로 도전하며, 스타트업과 기업들이 Meta의 기술을 기반으로 새로운 가치를 창출하도록 유도하는 전략적 전환이다.11 이 안내서는 Llama 2의 기술적 구조, 훈련 방법론, 성능 평가, 그리고 AI 생태계에 미치는 영향을 다각도로 심층 분석하고자 한다.</p>
<h2>2.  Llama 2 아키텍처 심층 분석</h2>
<p>Llama 2는 이전 세대의 검증된 구조를 계승하면서도 핵심적인 개선을 통해 성능과 효율성을 한 단계 끌어올렸다. 그 기반은 널리 사용되는 트랜스포머(Transformer) 아키텍처에 두지만, 몇 가지 중요한 수정을 가했다.</p>
<h3>2.1 기반: 수정된 트랜스포머 디코더 아키텍처</h3>
<p>Llama 2는 GPT 시리즈와 마찬가지로 자동 회귀(autoregressive) 방식의 디코더-온리(decoder-only) 트랜스포머 아키텍처를 채택했다.1 이 구조는 입력된 텍스트 시퀀스를 바탕으로 다음에 올 토큰을 순차적으로 예측하는 방식으로 작동하며, 텍스트 생성 작업에 매우 효과적이다.4 Llama 2는 Llama 1의 아키텍처를 대부분 그대로 계승했는데, 이는 급진적인 구조 변경보다는 안정성과 검증된 성능을 바탕으로 점진적인 개선을 추구했음을 시사한다.1</p>
<h3>2.2 핵심 구성 요소</h3>
<p>Llama 2는 표준 트랜스포머 아키텍처 대비 세 가지 주요한 수정 사항을 적용하여 효율성과 성능을 개선했다.</p>
<ul>
<li><strong>RMSNorm 사전 정규화 (Pre-normalization):</strong> 기존의 Layer Normalization 대신 Root Mean Square Normalization (RMSNorm)을 적용했다. RMSNorm은 계산 복잡도를 줄이면서도 훈련 안정성을 확보하는 데 효과적이어서, 모델의 학습 효율을 높이는 데 기여한다.1</li>
<li><strong>SwiGLU 활성화 함수 (Activation Function):</strong> 일반적인 ReLU나 GeLU 활성화 함수 대신 SwiGLU (Swish-Gated Linear Unit)를 사용했다. SwiGLU는 게이팅 메커니즘을 통해 정보의 흐름을 더 효과적으로 제어함으로써 모델의 표현력을 향상시키는 것으로 알려져 있다.1</li>
<li><strong>회전 위치 임베딩 (Rotary Positional Embeddings, RoPE):</strong> 토큰의 절대적 위치를 학습하는 대신, RoPE를 사용하여 토큰 간의 상대적 위치 정보를 인코딩했다. 이 방식은 시퀀스가 길어지더라도 모델이 위치 정보를 효과적으로 일반화할 수 있도록 도와, 특히 긴 컨텍스트 처리 능력을 향상시킨다.1</li>
</ul>
<h3>2.3 Llama 1 대비 주요 개선점</h3>
<p>Llama 2는 아키텍처의 근간을 유지하면서도 두 가지 핵심적인 측면에서 Llama 1을 크게 능가한다.</p>
<ul>
<li><strong>컨텍스트 길이 확장:</strong> Llama 1의 컨텍스트 길이는 2048 토큰이었으나, Llama 2에서는 이를 두 배인 4096 토큰으로 확장했다.4 이 확장은 모델이 더 긴 문서를 한 번에 이해하고, 여러 턴에 걸친 복잡한 대화의 맥락을 놓치지 않으며, 정교한 요약 작업을 수행하는 능력을 비약적으로 향상시킨다.4</li>
<li><strong>훈련 데이터 확장:</strong> Llama 1 대비 40% 더 많은, 총 2조 개의 토큰으로 사전 훈련을 수행했다.1 이 방대한 데이터는 모델의 지식 기반을 넓히고 언어의 미묘한 뉘앙스에 대한 이해도를 심화시키는 데 결정적인 역할을 했다.</li>
</ul>
<table><thead><tr><th>모델 (Model)</th><th>매개변수 (Parameters)</th><th>은닉 차원 (Dim)</th><th>레이어 수 (Layers)</th><th>어텐션 헤드 수 (Heads)</th><th>GQA 그룹 수 (GQA Groups)</th><th>어휘 크기 (Vocab Size)</th><th>컨텍스트 길이 (Context Length)</th></tr></thead><tbody>
<tr><td>Llama-2-7B</td><td>7B</td><td>4096</td><td>32</td><td>32</td><td>해당 없음</td><td>32000</td><td>4096</td></tr>
<tr><td>Llama-2-13B</td><td>13B</td><td>5120</td><td>40</td><td>40</td><td>해당 없음</td><td>32000</td><td>4096</td></tr>
<tr><td>Llama-2-70B</td><td>70B</td><td>8192</td><td>80</td><td>64</td><td>8</td><td>32000</td><td>4096</td></tr>
</tbody></table>
<h2>3.  그룹화 쿼리 어텐션 (Grouped-Query Attention, GQA): 추론 효율성 혁신</h2>
<p>Llama 2의 가장 중요한 아키텍처 혁신 중 하나는 대규모 모델의 추론 효율성을 극대화하기 위해 도입된 그룹화 쿼리 어텐션(GQA)이다. 이는 실용적인 배포를 염두에 둔 정교한 엔지니어링의 결과물이다.</p>
<h3>3.1 기존 Multi-Head Attention (MHA)의 한계</h3>
<p>표준 트랜스포머 아키텍처에 사용되는 다중 헤드 어텐션(Multi-Head Attention, MHA)은 각 어텐션 헤드가 독립적인 쿼리(Query, Q), 키(Key, K), 값(Value, V) 프로젝션을 가진다. 자동 회귀 방식의 디코딩 과정에서, 모델은 이전에 생성된 모든 토큰의 K와 V 값을 캐시(KV Cache)에 저장하여 다음 토큰을 예측할 때 재사용한다. 하지만 모델의 컨텍스트 길이가 길어지거나 배치 크기가 커질수록 이 KV 캐시의 크기가 기하급수적으로 증가하여 메모리 대역폭에 심각한 부담을 주게 된다. 이는 특히 대규모 모델의 추론 속도를 저하하는 주요 병목 현상으로 작용한다.14</p>
<h3>3.2 대안: MQA와 GQA</h3>
<p>이러한 MHA의 한계를 극복하기 위해 두 가지 대안적 어텐션 메커니즘이 제안되었다.</p>
<ul>
<li><strong>Multi-Query Attention (MQA):</strong> 모든 쿼리 헤드가 단 하나의 K, V 헤드 쌍을 공유하는 극단적인 형태의 최적화 방식이다. KV 캐시의 크기를 획기적으로 줄여 메모리 대역폭 부담을 최소화하고 추론 속도를 크게 향상시킬 수 있다. 그러나 이러한 구조는 모델의 표현력을 일부 희생시켜 품질 저하와 훈련 불안정성을 초래할 수 있다.18</li>
<li><strong>Grouped-Query Attention (GQA):</strong> MHA와 MQA의 장점을 절충한 방식이다. 전체 쿼리 헤드를 여러 그룹으로 나누고, 각 그룹 내의 쿼리 헤드들이 하나의 K, V 헤드 쌍을 공유한다. 이를 통해 MQA에 근접하는 높은 추론 속도와 메모리 효율성을 달성하면서도, MHA와 거의 동등한 수준의 모델 품질을 유지할 수 있다.7</li>
</ul>
<h3>3.3 Llama 2에서의 GQA 적용</h3>
<p>Meta는 Llama 2의 70B 모델에 GQA를 선택적으로 적용했다.13 이는 모든 모델에 최신 기술을 일괄적으로 적용하는 대신, 실제 병목 현상이 가장 심각하게 발생하는 지점을 정확히 파악하고 그에 맞는 해결책을 제시한 실용적인 엔지니어링 접근 방식을 보여준다. 즉, 7B나 13B와 같은 소형 모델에서는 MHA의 메모리 부담이 상대적으로 적기 때문에 기존 구조를 유지하고, KV 캐시 문제가 추론 성능에 결정적인 영향을 미치는 70B 모델에만 GQA를 적용하여 효율성을 극대화한 것이다. Meta가 수행한 자체 절제 연구(ablation study)에서도 GQA가 MQA보다 우수한 성능을 보이며 MHA와 거의 동등한 품질을 달성함이 확인되었다.7 이는 GQA가 대규모 모델의 추론 확장성을 확보하기 위한 최적의 선택이었음을 뒷받침한다.</p>
<table><thead><tr><th>메커니즘 (Mechanism)</th><th>K/V 헤드 구조 (K/V Head Structure)</th><th>KV 캐시 크기 (KV Cache Size)</th><th>추론 처리량 (Inference Throughput)</th><th>모델 품질 (Model Quality)</th></tr></thead><tbody>
<tr><td>Multi-Head Attention (MHA)</td><td>각 쿼리 헤드가 독립적인 K, V 헤드를 가짐</td><td>큼</td><td>낮음</td><td>높음 (기준)</td></tr>
<tr><td>Multi-Query Attention (MQA)</td><td>모든 쿼리 헤드가 단일 K, V 헤드를 공유</td><td>매우 작음</td><td>매우 높음</td><td>저하 가능성 있음</td></tr>
<tr><td>Grouped-Query Attention (GQA)</td><td>쿼리 헤드 그룹이 K, V 헤드를 공유</td><td>작음</td><td>높음</td><td>MHA와 유사</td></tr>
</tbody></table>
<h2>4.  훈련 방법론: 사전 훈련부터 미세 조정까지</h2>
<p>Llama 2는 방대한 데이터로 언어의 통계적 패턴을 학습하는 사전 훈련 단계와, 인간의 의도에 맞게 모델의 행동을 교정하는 미세 조정 단계를 거쳐 완성된다. 각 단계는 뚜렷한 목표와 정교한 전략을 기반으로 설계되었다.</p>
<h3>4.1 사전 훈련 (Pre-training)</h3>
<ul>
<li><strong>데이터셋 구성:</strong> Llama 2는 총 2조 개의 토큰으로 구성된 대규모 데이터셋으로 사전 훈련되었다. 이 데이터는 모두 공개적으로 접근 가능한 온라인 소스에서 수집되었으며, Meta의 사용자 데이터는 일절 포함되지 않았다. 또한, 개인정보가 다량 포함된 것으로 알려진 특정 사이트의 데이터는 의도적으로 제거하려는 노력을 기울였다.9 특히 모델의 지식 함양 능력을 강화하고 사실과 다른 정보를 생성하는 환각(hallucination) 현상을 줄이기 위해, 신뢰도 높은 사실적 정보 소스의 데이터 비중을 높이는 업샘플링(up-sampling) 전략을 사용했다.14</li>
<li><strong>훈련 하이퍼파라미터:</strong> 훈련에는 AdamW 옵티마이저가 사용되었으며, 하이퍼파라미터는 <code>latex</code>\beta_1=0.9<code> </code>, <code>latex</code>\beta_2=0.95<code> </code>, <code>latex</code>\text{eps}=10^{-5}<code> </code>로 설정되었다. 학습률은 코사인 스케줄(cosine learning rate schedule)을 따라 점진적으로 감소하며, 초기 2000 스텝 동안은 웜업(warm-up) 기간을 가졌다. 이 외에도 0.1의 가중치 감소(weight decay)와 1.0의 기울기 클리핑(gradient clipping)을 적용하여 안정적인 학습을 도모했다.13</li>
<li><strong>토크나이저:</strong> Llama 1과 동일한 SentencePiece 기반의 바이트 쌍 인코딩(Byte-Pair Encoding, BPE) 토크나이저를 사용했으며, 총 어휘 크기는 32,000개다.13</li>
</ul>
<h3>4.2 미세 조정: Llama 2-Chat</h3>
<p>사전 훈련된 Llama 2 기본 모델은 방대한 지식을 갖추고 있지만, 인간과 자연스럽게 대화하거나 특정 지시를 따르는 능력은 부족하다. Llama 2-Chat은 이러한 능력을 부여하기 위해 다단계 정렬(alignment) 프로세스를 거친다.4</p>
<ul>
<li>1단계: 지도 학습 미세 조정 (Supervised Fine-Tuning, SFT):</li>
</ul>
<p>이 단계는 모델이 대화 형식을 학습하고 지시를 따르는 기본 능력을 갖추도록 하는 초기 정렬 과정이다. Meta는 이 과정에서 ‘양보다 질’ 전략을 채택했다. 수백만 개에 달하는 공개된 명령어 데이터셋 중 상당수가 품질과 다양성 측면에서 부족하다고 판단하고, 대신 자체적으로 수집한 약 27,540개의 고품질 (프롬프트, 응답) 쌍 데이터에 집중했다. 이처럼 잘 정제된 소규모 데이터셋을 활용한 결과, 훨씬 더 우수한 초기 모델을 얻을 수 있었다.14 이는 SFT 단계의 핵심이 새로운 지식 주입이 아니라, 바람직한 상호작용의 ’형식’과 ’스타일’을 학습시키는 것임을 시사한다. 깨끗한 데이터는 모델이 불필요한 노이즈나 바람직하지 않은 행동 패턴을 학습하는 것을 방지하여, 후속 RLHF 단계의 효율성을 높이는 기반이 된다. 훈련 시에는 사용자 프롬프트 부분의 손실(loss)을 0으로 처리하여, 모델이 오직 정답 응답을 생성하는 데에만 집중하도록 했다.14</p>
<ul>
<li>2단계: 인간 피드백 기반 강화 학습 (Reinforcement Learning from Human Feedback, RLHF):</li>
</ul>
<p>SFT를 거친 모델을 인간의 복잡하고 미묘한 선호도에 더욱 정밀하게 맞추기 위해 RLHF 기법을 적용했다.5 이 과정은 Llama 2-Chat의 유용성과 안전성을 최종적으로 완성하는 핵심 단계로, 모델이 단순히 ’정답’을 생성하는 것을 넘어 ‘더 나은’ 응답을 생성하도록 학습시킨다.8</p>
<h2>5.  인간 피드백 기반 강화 학습 (RLHF) 프로세스 해부</h2>
<p>RLHF는 Llama 2-Chat을 단순한 언어 생성기를 넘어 유용하고 안전한 AI 비서로 만드는 핵심 공정이다. 이 과정은 인간의 가치 판단을 데이터화하고, 이를 모델이 학습 가능한 보상 신호로 변환하여 정책을 최적화하는 세 단계로 구성된다.</p>
<h3>5.1 단계: 인간 선호도 데이터 수집</h3>
<p>RLHF의 첫 단계는 인간의 선호도를 담은 데이터를 구축하는 것이다. Meta는 인간 주석가에게 특정 프롬프트에 대한 두 개의 모델 응답을 제시하고, 어느 쪽이 더 나은지를 선택하게 하는 이진 비교(binary comparison) 방식을 채택했다.14 이 방식은 주석가에게 부담이 적으면서도 다양한 프롬프트에 대한 선호도를 효율적으로 수집할 수 있게 한다. 주석은 ’유용성(Helpfulness)’과 ’안전성(Safety)’이라는 두 가지 핵심 기준을 중심으로 이루어졌으며, 이 과정을 통해 총 100만 개 이상의 대규모 선호도 데이터 쌍을 수집했다.10</p>
<h3>5.2 단계: 보상 모델(Reward Model, RM) 훈련</h3>
<p>수집된 인간 선호도 데이터는 LLM이 직접 학습할 수 없다. 따라서 이 데이터를 바탕으로, 특정 (프롬프트, 응답) 쌍이 주어졌을 때 인간이 얼마나 선호할지를 예측하는 ’보상 모델’을 훈련한다.9 보상 모델은 주어진 응답에 대해 스칼라 점수(reward score)를 출력한다.</p>
<p>여기서 Meta의 중요한 설계 결정이 드러난다. 유용성과 안전성이라는 두 목표는 때때로 상충할 수 있다. 예를 들어, 유해한 질문에 대해 지나치게 유용한 답변을 하는 것은 안전성을 해칠 수 있고, 반대로 지나치게 안전을 추구하면 모델이 유용성을 잃고 회피적인 답변만 내놓을 수 있다. 이러한 상충 관계를 효과적으로 제어하기 위해, Meta는 단일 보상 모델 대신 ’유용성 보상 모델’과 ’안전성 보상 모델’을 별도로 훈련했다.7 이처럼 목표를 분리함으로써 각 목표에 특화된 데이터로 모델을 학습시키고, 최종 최적화 단계에서 두 보상 점수를 조합하여 유용성과 안전성 간의 균형을 더 정밀하게 조절할 수 있었다. 보상 모델의 훈련에는 선택된 응답(‘yw‘)의 점수가 거부된 응답(‘yl‘)보다 높도록 유도하는 이진 순위 손실 함수(binary ranking loss)가 사용되었다.14 손실 함수는 다음과 같이 표현된다:<br />
<span class="math math-display">
\mathcal{L}_{\text{ranking}} = -\mathbb{E}_{(x, y_w, y_l) \sim D} \left[ \log(\sigma(r_\theta(x, y_w) - r_\theta(x, y_l))) \right]
</span></p>
<h3>5.3 단계: 반복적 정책 최적화</h3>
<p>훈련된 보상 모델은 이제 강화 학습 환경에서 보상 함수 역할을 한다. SFT를 거친 모델을 ’정책(policy)’으로 삼아, 보상 모델로부터 더 높은 점수를 받는 방향으로 정책을 업데이트한다. 이 과정에서 두 가지 주요 알고리즘이 활용되었다.14</p>
<ul>
<li><strong>Rejection Sampling:</strong> 모델로부터 K개의 응답 후보를 생성한 후, 보상 모델을 사용해 각 후보의 점수를 매긴다. 이 중 가장 높은 점수를 받은 응답을 최종 결과로 채택하고, 이러한 ’최고의 응답’들로 구성된 데이터셋을 만들어 모델을 추가로 미세 조정한다. 이 방식은 주로 가장 큰 모델인 70B 모델에 적용되었다.10</li>
<li><strong>Proximal Policy Optimization (PPO):</strong> 보상 점수를 최대화하도록 정책(LLM)을 직접 업데이트하는 강화 학습 알고리즘이다. 다만, 최적화 과정에서 모델이 보상 모델의 허점을 파고들어 비정상적인 텍스트를 생성하는 것을 방지하고, 원래 SFT 모델의 언어 능력을 유지하기 위해 KL 발산(KL-divergence) 페널티 항을 목적 함수에 추가한다. 이 페널티 항은 업데이트된 정책이 원래 SFT 정책에서 너무 멀리 벗어나지 않도록 규제하는 역할을 한다.24 PPO의 목적 함수는 다음과 같다:</li>
</ul>
<p><span class="math math-display">
\text{objective}(\phi) = \mathbb{E}_{(x,y) \sim D_{\pi_\phi^{\text{RL}}}}
</span></p>
<h3>5.4 고스트 어텐션 (Ghost Attention, GAtt)</h3>
<p>긴 대화가 이어질 때 모델이 “너는 항상 간결하게 답변해야 해“와 같은 초기 지시사항을 잊어버리는 문제가 종종 발생한다. 이를 해결하기 위해 Meta는 ’고스트 어텐션(GAtt)’이라는 독창적인 기법을 도입했다.7 GAtt는 미세 조정 데이터셋을 가공하는 간단한 방법이다. 다중 턴 대화 데이터에서, 모든 사용자 메시지 앞에 초기 시스템 지시사항을 인위적으로 복사하여 붙여넣는다. 이렇게 조작된 데이터로 모델을 훈련시키면, 모델은 매 턴마다 초기 지시사항을 다시 상기하는 것과 같은 효과를 학습하게 되어, 긴 대화에서도 일관성을 유지하는 능력이 크게 향상된다.14</p>
<h2>6.  성능 평가 및 벤치마크 분석</h2>
<p>Llama 2의 성능은 다양한 표준 벤치마크와 인간 평가를 통해 종합적으로 측정되었다. 특히, 기존 오픈 소스 모델 및 업계 최고 수준의 폐쇄형 모델과의 비교는 Llama 2의 경쟁력을 가늠하는 중요한 척도가 된다.</p>
<h3>6.1 학술 벤치마크 결과</h3>
<p>Llama 2는 코드 생성(HumanEval), 상식 추론(HellaSwag), 독해 능력(SQuAD), 일반 지식 및 문제 해결(MMLU) 등 광범위한 외부 벤치마크에서 기존의 주요 오픈 소스 모델인 MPT와 Falcon을 압도하는 성능을 기록했다.7 이는 Llama 2가 오픈 소스 LLM 생태계에서 새로운 성능 기준을 제시했음을 의미한다.</p>
<h3>6.2 핵심 경쟁 모델과의 비교: Llama 2 vs. GPT-4</h3>
<p>가장 큰 관심사는 업계 선두주자인 OpenAI의 GPT-4와의 성능 비교이다. Meta는 공식적으로 Llama 2가 GPT-4와 같은 최첨단 폐쇄형 모델에는 여전히 뒤처진다고 인정하면서도 27, 특정 영역에서는 매우 경쟁력 있는 성능을 보여주었다.</p>
<ul>
<li><strong>사실적 정확성 및 요약:</strong> 뉴스 기사 요약문의 사실적 불일치를 탐지하는 작업에서, Llama-2-70B 모델은 81.7%의 정확도를 기록했다. 이는 인간 평가자 수준(84%)에 근접하며, GPT-4의 85.5%와 거의 대등한 결과이다. 특히, 동일 작업에서 67%의 정확도에 그친 GPT-3.5-turbo를 크게 앞질렀다.28 이는 Llama 2가 높은 신뢰도가 요구되는 정보 요약과 같은 작업에서 GPT-4의 강력한 대안이 될 수 있음을 시사한다.</li>
<li><strong>코딩 능력:</strong> 프로그래밍 능력 평가 벤치마크인 HumanEval에서, 기본 Llama-2-70B 모델은 29.9%의 정답률을 보여 67.0%를 기록한 GPT-4에 비해 상당한 격차를 보였다. 하지만 이후 출시된 코드 생성에 특화된 파생 모델인 Code Llama는 추가적인 미세 조정을 통해 GPT-4를 능가하는 성능을 달성하기도 했다.27 이는 기본 모델의 범용 능력에는 한계가 있지만, 특정 도메인에 대한 미세 조정을 통해 최고 수준의 성능을 이끌어낼 수 있는 잠재력을 보여준다.</li>
<li><strong>창의성:</strong> 시(poem) 창작과 같은 창의적인 글쓰기 영역에서는 GPT-4가 더 정교하고 풍부한 어휘와 표현력을 보여주며 우위를 점했다. Llama 2의 창작물은 상대적으로 기본적인 수준에 머무는 경향이 있었다.29</li>
<li><strong>비용 효율성:</strong> Llama 2의 가장 큰 강점 중 하나는 비용이다. API를 통해 사용량에 따라 과금되는 GPT-4와 달리, Llama 2는 자체 인프라에 직접 배포하여 사용할 수 있다. 한 연구에 따르면, 요약 작업에서 GPT-4와 동등한 수준의 사실적 정확도를 달성하는 데 드는 비용이 Llama-2-70B를 사용할 경우 최대 30배 저렴할 수 있다.27</li>
</ul>
<table><thead><tr><th>벤치마크 (Benchmark)</th><th>Llama-2-70B</th><th>GPT-4</th><th>설명 (Description)</th></tr></thead><tbody>
<tr><td>MMLU (5-shot)</td><td>68.9%</td><td>86.4%</td><td>57개 주제에 대한 다지선다형 질문으로 구성된 종합 지식 및 문제 해결 능력 평가 27</td></tr>
<tr><td>HumanEval (0-shot)</td><td>29.9%</td><td>67.0%</td><td>프로그래밍 문제 해결 및 코드 생성 능력 평가 27</td></tr>
<tr><td>Factual Summarization Accuracy</td><td>81.7%</td><td>85.5%</td><td>요약문의 사실적 불일치 탐지 정확도 평가 28</td></tr>
<tr><td>HellaSwag (10-shot)</td><td>85.3%</td><td>95.3%</td><td>문장의 다음 내용을 예측하는 상식 추론 능력 평가 27</td></tr>
<tr><td>WinoGrande (5-shot)</td><td>80.2%</td><td>87.5%</td><td>대명사가 가리키는 대상을 파악하는 상식 추론 능력 평가 27</td></tr>
</tbody></table>
<h2>7.  안전성 및 책임감 있는 AI 전략</h2>
<p>Meta는 강력한 성능의 LLM을 개방하면서 발생할 수 있는 잠재적 위험을 완화하기 위해, 모델 개발 전 과정에 걸쳐 다층적인 안전성 전략을 통합했다. 이는 안전성을 부가 기능이 아닌 핵심 설계 원칙으로 간주했음을 보여준다.</p>
<h3>7.1 사전 훈련 데이터의 안전성</h3>
<p>안전성 확보는 데이터 수집 단계에서부터 시작되었다. Meta는 훈련 데이터에서 자사 사용자 데이터를 전면 배제했으며, 대량의 개인정보를 포함한 것으로 알려진 웹사이트의 데이터를 제거하기 위해 노력했다.14 또한, HateBERT와 같은 분류기를 사용하여 훈련 데이터의 독성(toxicity) 수준을 정량적으로 측정하고, 성별 대명사의 분포를 분석하여 데이터에 내재된 잠재적 편향을 사전에 평가했다.14</p>
<h3>7.2 안전성 특화 미세 조정</h3>
<p>Llama 2-Chat은 일반적인 유용성 향상 미세 조정 외에, 안전성에만 초점을 맞춘 별도의 미세 조정 단계를 거쳤다. 이 과정은 모델이 유해한 요청을 인식하고 적절하게 거부하도록 훈련시키는 것을 목표로 한다.</p>
<ul>
<li><strong>Safety SFT:</strong> 인간 주석가들이 의도적으로 유해하거나 비윤리적인 응답을 유도하는 ’적대적 프롬프트(adversarial prompts)’를 직접 생성했다. 그리고 이러한 프롬프트에 대해 모델이 따라야 할 ’안전한 응답’의 모범 사례를 작성하여 지도 학습 데이터셋을 구축했다. 이 데이터로 모델을 훈련시켜 유해 콘텐츠 생성에 대한 방어 능력을 길렀다.14</li>
<li><strong>Safety RLHF:</strong> 유용성 보상 모델과 완전히 분리된 ’안전성 보상 모델’을 훈련했다. 주석가들은 적대적 프롬프트에 대한 여러 모델 응답 중 가장 안전하다고 판단되는 응답을 선택하여 선호도 데이터를 구축했으며, 이 데이터를 기반으로 안전성 보상 모델을 학습시켰다. 이 모델은 이후 RLHF 최적화 과정에서 모델이 안전한 방향으로 행동을 수정하도록 유도하는 강력한 신호로 사용되었다.7</li>
</ul>
<h3>7.3 적대적 테스트: 레드팀(Red Teaming)</h3>
<p>내부적인 노력만으로는 모델의 모든 취약점을 발견하기 어렵다는 인식하에, Meta는 광범위한 ‘레드팀(Red Teaming)’ 활동을 수행했다. 사이버 보안, 법률, 윤리, 선거 개입 등 다양한 분야의 외부 전문가를 포함한 350명 이상의 인력이 참여하여, 실제 발생할 수 있는 공격 시나리오를 시뮬레이션하고 모델의 잠재적 허점을 공격적으로 탐색했다.14 레드팀 활동을 통해 발견된 위험 사례(예: 범죄 계획 유도, 혐오 발언 생성)들은 단순히 안내서로 끝나는 것이 아니라, 모델의 안전성을 강화하기 위한 새로운 미세 조정 데이터로 직접 활용되었다. 이처럼 ’테스트-피드백-재훈련’으로 이어지는 반복적인 개선 루프는 Llama 2의 안전성을 지속적으로 강화하는 핵심 동력이 되었다. 이 다층적이고 선제적인 접근 방식은 강력한 AI 모델을 책임감 있게 공개하기 위한 정교한 전략의 결과물이다.</p>
<h2>8.  라이선스, ‘오픈 소스’ 논쟁 및 상업적 사용</h2>
<p>Llama 2의 라이선스 정책은 기술적 성과만큼이나 AI 커뮤니티에 큰 논쟁과 논의를 불러일으켰다. 이는 ’개방성’의 정의와 그 전략적 함의에 대한 근본적인 질문을 던진다.</p>
<h3>8.1 Llama 2 커뮤니티 라이선스</h3>
<p>Llama 2는 연구 및 상업적 목적으로 무료로 사용할 수 있도록 제공되지만, 이는 오픈소스 이니셔티브(OSI)가 승인한 표준 라이선스가 아닌 Meta가 직접 만든 맞춤형(bespoke) ’Llama 2 커뮤니티 라이선스’에 따라 배포된다.10</p>
<h3>8.2 ‘오픈 소스’ 논쟁</h3>
<p>Meta는 Llama 2를 ’오픈 소스’라고 적극적으로 홍보하고 있지만 10, 이 라이선스는 OSI가 정의하는 오픈 소스 정의(Open Source Definition, OSD)의 핵심 원칙 몇 가지를 충족하지 못한다는 비판을 받고 있다.34</p>
<ul>
<li><strong>OSD 위반 사항:</strong></li>
</ul>
<ol>
<li><strong>사용 분야에 대한 차별 금지 (No Discrimination Against Fields of Endeavor):</strong> OSD는 특정 분야에서의 소프트웨어 사용을 제한해서는 안 된다고 규정한다. 그러나 Llama 2 라이선스는 모델의 출력물을 사용하여 Llama 2 또는 그 파생 모델을 제외한 다른 대규모 언어 모델을 개선하는 행위를 명시적으로 금지한다.33</li>
<li><strong>개인이나 그룹에 대한 차별 금지 (No Discrimination Against Persons or Groups):</strong> Llama 2 출시일 기준으로 월간 활성 사용자(Monthly Active Users, MAU)가 7억 명을 초과하는 기업은 Llama 2를 사용하기 위해 Meta에 별도의 라이선스를 요청해야 한다.34 이는 특정 대규모 기업을 차별하는 조항으로 해석될 수 있다.</li>
</ol>
<p>이러한 제한 조항들은 Meta가 Llama 2를 ’오픈 소스’가 아닌 ‘오픈 액세스’ 또는 ‘소스 어베일러블’ 형태로 공개했음을 시사한다. 이는 순수한 오픈 소스의 철학을 따르기보다는, 생태계 활성화라는 개방성의 이점을 누리면서도 핵심 경쟁자들이 자사의 기술을 직접적으로 활용해 더 우월한 모델을 만드는 것을 방지하려는 전략적 의도로 분석된다. 즉, 이 라이선스는 수많은 중소 개발자와 스타트업이 Llama 생태계에 참여하도록 장려하여 커뮤니티 기반의 혁신을 촉진하는 동시에, Google이나 OpenAI와 같은 거대 경쟁자에게는 기술적 방어벽을 치는 이중적 효과를 노린 것이다.</p>
<h3>8.3 상업적 사용의 조건 및 제한</h3>
<p>위의 제한 사항에도 불구하고, Llama 2는 대다수의 기업과 개발자에게 매우 관대한 상업적 사용 권한을 부여한다.</p>
<ul>
<li>7억 MAU 미만의 모든 기업은 별도의 비용 없이 Llama 2를 자사 제품이나 서비스에 통합하여 상업적으로 활용할 수 있다.</li>
<li>Llama 2를 기반으로 구축된 제품이나 서비스에는 “Built with Llama“라는 문구를 웹사이트, 사용자 인터페이스, 또는 관련 문서에 명확히 표시해야 한다.33</li>
<li>라이선스와 함께 제공되는 ’허용 가능한 사용 정책(Acceptable Use Policy, AUP)’은 국가 핵심 인프라 운영, 불법 무기 개발, 국제무기거래규정(ITAR)의 적용을 받는 활동 등 특정 금지된 사용 사례를 명시하고 있다.33</li>
</ul>
<h2>9.  결론: Llama 2의 의의와 미래 전망</h2>
<p>Meta의 Llama 2는 단순한 LLM 출시를 넘어 AI 기술의 개발, 배포, 그리고 경쟁 패러다임에 근본적인 변화를 가져온 사건으로 평가된다. 이 안내서에서 분석한 아키텍처, 훈련 방법론, 성능 및 라이선스 정책은 Llama 2의 다층적인 의의를 명확히 보여준다.</p>
<p>Llama 2의 가장 큰 의의는 고성능 LLM에 대한 접근성을 민주화하여, 소수의 기업이 주도하던 폐쇄형 모델 생태계에 강력하고 실용적인 대안을 제시했다는 점이다. 이는 수많은 연구자, 스타트업, 기업들이 이전에는 불가능했던 규모의 AI 기술을 직접 활용하고 혁신할 수 있는 길을 열었다. 기술적으로는 GQA와 같은 실용적인 엔지니어링 혁신을 통해 대규모 모델의 추론 효율성을 개선하고, 고품질 데이터 중심의 SFT와 다층적 안전성 전략을 통해 효과적인 모델 정렬 방법론을 제시했다.</p>
<p>또한, Llama 2는 ’전략적 개방’이라는 새로운 모델 배포 패러다임을 확립했다. 이는 순수한 오픈 소스의 철학과는 거리가 있지만, 생태계를 활성화하여 커뮤니티의 집단 지성을 활용하면서도 핵심 경쟁자로부터 기술적 우위를 보호하려는 정교한 전략이다. 이 모델은 AI 산업의 경쟁 구도를 재편하고, 향후 기술 리더십이 단순히 모델 성능뿐만 아니라 생태계 구축 능력에 의해 좌우될 수 있음을 시사한다.</p>
<p>앞으로 Llama 2를 기반으로 한 수많은 파생 모델과 특화 애플리케이션의 등장은 더욱 가속화될 것이다.11 개방형 모델의 성능이 폐쇄형 모델과의 격차를 얼마나 빠르게 좁힐 수 있을지, 그리고 Llama 2가 구축하려는 개방형 생태계가 지속 가능한 혁신을 이끌어낼 수 있을지가 향후 AI 시장의 중요한 관전 포인트가 될 것이다. 마지막으로, Llama 2가 촉발한 ’오픈 소스 AI’의 정의와 책임 있는 AI 배포에 대한 논의는 기술 커뮤니티와 사회 전반에 걸쳐 계속해서 중요한 의제로 남을 것이다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>Llama (language model) - Wikipedia, https://en.wikipedia.org/wiki/Llama_(language_model)</li>
<li>Meta and Microsoft Introduce the Next Generation of Llama, https://about.fb.com/news/2023/07/llama-2/</li>
<li>Llama 2 – Vertex AI - Google Cloud Console, https://console.cloud.google.com/vertex-ai/publishers/meta/model-garden/llama2</li>
<li>What Is Llama 2? | IBM, https://www.ibm.com/think/topics/llama-2</li>
<li>Comparative Analysis: Llama vs. Llama2 Performance - GoML, https://www.goml.io/blog/comparative-analysis-llama-vs-llama2-performance</li>
<li>Llama 2 is here - get it on Hugging Face, https://huggingface.co/blog/llama2</li>
<li>Llama 2: The Next Revolution in AI Language Models - Viso Suite, https://viso.ai/deep-learning/llama-2/</li>
<li>Llama 2: A Comprehensive Guide - Simform, https://www.simform.com/blog/llama-2-comprehensive-guide/</li>
<li>A Complete Beginner’s Guide to Llama 2 | Build Generative AI Applications With SingleStoreDB, https://www.singlestore.com/blog/a-complete-beginners-guide-to-llama2/</li>
<li>Meta Llama 2, https://www.llama.com/llama2/</li>
<li>The Llama Ecosystem: Past, Present, and Future - AI at Meta, https://ai.meta.com/blog/llama-2-updates-connect-2023/</li>
<li>Introduction to Llama2 : Part-1 Architectural Analysis | by Utsavtiwari - Medium, https://medium.com/@utsavtiwari9936/introduction-to-llama2-part-1-architectural-analysis-3e335e7b1104</li>
<li>Brief Introduction to Llama 2 - Medium, https://medium.com/@florian_algo/brief-introduction-to-llama-2-cec2d59fc13f</li>
<li>Llama 2: Open Foundation and Fine-Tuned Chat Models, https://arxiv.org/pdf/2307.09288</li>
<li>Llama 2 vs Llama 1 vs GPT-4: Who Will Trample Who? - Bito AI, https://bito.ai/blog/llama2-vs-llama1-vs-gpt4/</li>
<li>Llama vs Llama 2. Comparison, Differences, Features | Apps4Rent, https://www.apps4rent.com/blog/llama-vs-llama-2/</li>
<li>5 Steps to Getting Started with Llama 2 - AI at Meta, https://ai.meta.com/blog/5-steps-to-getting-started-with-llama-2/</li>
<li>Grouped Query Attention (GQA) vs. Multi Head Attention (MHA): LLM Inference Serving Acceleration - FriendliAI, https://friendli.ai/blog/gqa-vs-mha</li>
<li>Demystifying GQA — Grouped Query Attention for Efficient LLM Pre-training, https://bhavinjawade.github.io/post/gqa/</li>
<li>Grouped Query Attention (GQA) explained with code | by Max Shap - Medium, https://medium.com/@maxshapp/grouped-query-attention-gqa-explained-with-code-e56ee2a1df5a</li>
<li>Fine-tune Llama 2 for text generation on Amazon SageMaker JumpStart - AWS, https://aws.amazon.com/blogs/machine-learning/fine-tune-llama-2-for-text-generation-on-amazon-sagemaker-jumpstart/</li>
<li>LLAMA 2 Paper and Model Deep Dive — The GenAI Guidebook - Ravin Kumar, https://ravinkumar.com/GenAiGuidebook/deepdive/llama2.html</li>
<li>Reinforcement learning with human feedback (RLHF) for LLMs - SuperAnnotate, https://www.superannotate.com/blog/rlhf-for-llm</li>
<li>RLHF: Reinforcement Learning from Human Feedback - Chip Huyen, https://huyenchip.com/2023/05/02/rlhf.html</li>
<li>Reinforcement learning from human feedback - Wikipedia, https://en.wikipedia.org/wiki/Reinforcement_learning_from_human_feedback</li>
<li>Llama 2: Open Foundation and Fine-Tuned Chat Models - Hugging Face, https://huggingface.co/papers/2307.09288</li>
<li>Llama vs GPT: Comparing Open-Source Versus Closed-Source AI Development - Netguru, https://www.netguru.com/blog/gpt-4-vs-llama-2</li>
<li>Llama 2 vs GPT-4: Which AI Model to Choose for Your Project? - phospho, https://blog.phospho.ai/llama-2-vs-gpt-4-when-to-choose-which/</li>
<li>How Does Llama-2 Compare to GPT-4/3.5 and Other AI Language Models, https://promptengineering.org/how-does-llama-2-compare-to-gpt-and-other-ai-language-models/</li>
<li>Llama 2 is about as factually accurate as GPT-4 for summaries and is 30X cheaper, https://www.anyscale.com/blog/llama-2-is-about-as-factually-accurate-as-gpt-4-for-summaries-and-is-30x-cheaper</li>
<li>Llama 2 vs GPT 4: Key Differences Explained - Labellerr, https://www.labellerr.com/blog/9-key-differences-between-gpt4-and-llama2-you-should-know/</li>
<li>Meta Llama 2 vs. OpenAI GPT-4: A Detailed Comparison - Talentelgia Technologies, https://www.talentelgia.com/blog/meta-llama-2-vs-openai-gpt-4/</li>
<li>Llama FAQs, https://www.llama.com/faq/</li>
<li>Is Llama 2 open source? No - and perhaps we need a new definition of open, https://opensourceconnections.com/blog/2023/07/19/is-llama-2-open-source-no-and-perhaps-we-need-a-new-definition-of-open/</li>
<li>Meta’s LLaMa license is still not Open Source, https://opensource.org/blog/metas-llama-license-is-still-not-open-source</li>
<li>Meta announces Llama 2; “open sources” it for commercial use - LessWrong, https://www.lesswrong.com/posts/9rdpdDerangjYeQGW/meta-announces-llama-2-open-sources-it-for-commercial-use</li>
<li>meta-llama/Llama-2-7b-chat-hf - Hugging Face, https://huggingface.co/meta-llama/Llama-2-7b-chat-hf</li>
<li>Llama 2. A significant milestone in the world of AI - deepsense.ai, https://deepsense.ai/blog/llama-2-a-significant-milestone-in-the-world-of-ai/</li>
<li>meta-llama/Llama-2-7b - Hugging Face, https://huggingface.co/meta-llama/Llama-2-7b</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>