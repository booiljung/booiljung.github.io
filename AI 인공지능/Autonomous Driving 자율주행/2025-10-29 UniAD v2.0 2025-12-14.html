<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:UniAD v2.0 (2025-10-29)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>UniAD v2.0 (2025-10-29)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">자율주행 (Autonomous Driving)</a> / <span>UniAD v2.0 (2025-10-29)</span></nav>
                </div>
            </header>
            <article>
                <h1>UniAD v2.0 (2025-10-29)</h1>
<p>2025-12-14</p>
<h2>1.  서론: 엔드투엔드 자율 주행의 새로운 지평</h2>
<p>자율 주행 기술의 발전사는 인지(Perception), 예측(Prediction), 계획(Planning)이라는 일련의 과정들을 어떻게 효율적으로 결합하고 최적화할 것인가에 대한 끊임없는 탐구의 역사라 할 수 있다. 초기 자율 주행 시스템은 각 기능이 독립적인 모듈로 분리되어 개발되었고, 이들은 각각의 제한된 입력과 출력만을 처리하도록 설계되었다. 그러나 이러한 모듈형 아키텍처(Modular Architecture)는 상위 모듈에서 발생한 미세한 오차가 하위 모듈로 전파되며 증폭되는 소위 ‘오차 전파(Error Propagation)’ 문제에서 자유로울 수 없었다. 또한, 각 모듈이 개별적인 목적 함수를 가지고 최적화되기에, 전체 시스템의 궁극적인 목표인 ’안전하고 효율적인 주행 계획 수립’과는 괴리되는 현상이 발생하곤 했다.1</p>
<pre><code class="language-mermaid">timeline
    title "UniAD Evolution History &amp; Future Roadmap"
    section "Early Stage"
        "Modular Architecture" : "Independent Modules" : "Error Propagation Issues"
        "Goal-oriented" : "Simple Navigation" : "Renamed to Planning-oriented"
    section "UniAD v1.0 (2023)"
        "CVPR 2023" : "Best Paper Award"
        "Concept Proof" : "Perception for Planning"
        "Limitations" : "Old Framework" : "Reproducibility Issues"
    section "Maintenance"
        "Mid-2023" : "Stage 1 Training Fix"
        "Aug 2023" : "Planner X-axis Fix"
    section "UniAD v2.0 (Oct 2025)"
        "Official Release" : "PyTorch 2.0 / CUDA 11.8"
        "New Benchmarks" : "nuPlan &amp; NAVSIM Integration"
        "Optimization" : "Memory Efficient"
    section "Future"
        "World Models" : "Vista, GenAD Integration"
        "Generative AI" : "Predictive Autonomous Driving"
</code></pre>
<p>이러한 배경 속에서 등장한 UniAD(Unified Autonomous Driving)는 “Perception for Planning(계획을 위한 인지)“이라는 철학을 바탕으로 자율 주행의 패러다임을 근본적으로 재정의하고자 했다. 2023년 CVPR(Computer Vision and Pattern Recognition) 학술대회에서 Best Paper Award를 수상하며 그 혁신성을 인정받은 UniAD는, 단순히 모든 모듈을 하나의 신경망으로 합치는 것을 넘어, 각 모듈이 유기적으로 정보를 교환하고 상호 보완하며 최종적으로 주행 계획을 최적화하는 구조를 제안했다.3</p>
<p>2025년 10월 29일, OpenDriveLab은 UniAD의 차세대 버전인 v2.0을 공식 릴리스하였다.5 이는 단순한 성능 개선이나 버그 수정을 넘어선, 자율 주행 연구 및 개발 생태계의 변화를 반영한 대규모 업데이트이다. UniAD v2.0은 최신 딥러닝 프레임워크로의 전면적인 마이그레이션, 차세대 벤치마크인 NAVSIM 및 nuPlan의 통합, 그리고 실질적인 폐루프(Closed-loop) 평가 시스템의 도입을 포함하고 있다.5</p>
<p>본 보고서는 UniAD v2.0의 아키텍처적 특성, v1.0 대비 기술적 진보, 주요 벤치마크에서의 성능, 그리고 이것이 자율 주행 산업에 시사하는 바를 총 15,000 단어 분량으로 심층적으로 분석한다. 보고서의 모든 서술은 객관적인 데이터와 기술적 사실에 기반하며, 자율 주행 분야의 전문가들을 위한 심도 있는 통찰을 제공하는 것을 목표로 한다.</p>
<pre><code class="language-mermaid">graph LR
    subgraph "기존: 모듈형 아키텍처 (Modular Architecture)"
        direction TB
        A1["입력 (Input)"] --&gt; B1["인지 (Perception)"]
        B1 --"오차 전파 (Error Propagation)"--&gt; C1["예측 (Prediction)"]
        C1 --"오차 증폭"--&gt; D1["계획 (Planning)"]
        B1 -.-&gt; E1["개별 최적화 (Isolated Opt)"]
        C1 -.-&gt; E1
        D1 -.-&gt; E1
    end

    subgraph "UniAD: 통합형 아키텍처 (Unified Architecture)"
        direction TB
        A2["입력 (Input)"] --&gt; B2["백본 &amp; BEV 인코더"]
        B2 --&gt; C2["인지 &amp; 예측 모듈"]
        C2 --"쿼리 (Query) 기반 정보 공유"--&gt; D2["플래너 (Planner)"]
        D2 --"안전/계획 중심 최적화"--&gt; E2["전체 파이프라인 학습"]
        E2 -.-&gt; C2
        E2 -.-&gt; B2
    end
</code></pre>
<h2>2.  UniAD의 철학적 기반과 핵심 아키텍처</h2>
<pre><code class="language-mermaid">mindmap
  root((UniAD v2.0))
    ("TrackFormer")
      ::icon(fa fa-car)
      "동적 객체 검출 및 추적"
      ["트랙 쿼리 생성 (위치, 속도, 외형)"]
      "시간적 연속성 유지"
    ("MapFormer")
      ::icon(fa fa-map)
      ["정적 도로 요소 인식 (차선 등)"]
      "맵 쿼리 생성"
      "자차 위치 및 주행 가능 영역 제공"
    ("MotionFormer")
      ::icon(fa fa-arrows-turn-right)
      ["객체 간 상호작용 모델링 (Agent-Agent)"]
      ["객체-지도 상호작용 (Agent-Map)"]
      "미래 12프레임 궤적 예측"
    ("OccFormer")
      ::icon(fa fa-cube)
      "픽셀 수준 점유 그리드 예측"
      "비정형 물체/장애물 파악"
      "인스턴스 수준 점유 결합"
    ("Planner")
      ::icon(fa fa-route)
      "최종 궤적 생성"
      "뉴턴 방법 기반 비선형 최적화"
      "안전, 규정 준수, 승차감 고려"
</code></pre>
<h3>2.1  기획 중심(Planning-Oriented) 철학의 이론적 배경</h3>
<p>UniAD의 가장 큰 특징은 그 이름에서 알 수 있듯이 ’통합(Unified)’과 ’기획 중심(Planning-oriented)’이라는 두 가지 키워드로 요약된다. 초기 연구 단계에서 “Goal-oriented“라는 명칭이 고려되었으나, 로봇 공학 분야에서 단순히 특정 좌표로 이동하는 ’Goal-point Navigation’과의 혼동을 피하기 위해 “Planning-oriented“로 명칭이 변경되었다.5 이는 자율 주행이 단순히 목적지 도달을 위한 경로 생성을 넘어, 주변 환경의 동적 변화를 예측하고, 잠재적인 위험 요소를 회피하며, 교통 법규와 승차감을 고려한 최적의 궤적(Trajectory)을 생성하는 복합적인 과정임을 강조한다.</p>
<p>기존의 다중 태스크 학습(Multi-Task Learning, MTL) 모델들은 인지, 예측, 계획을 하나의 네트워크 안에서 수행하더라도, 각 태스크 헤드(Head)가 독립적인 손실 함수(Loss Function)를 가지고 병렬적으로 학습되는 경우가 많았다. 이 경우, 인지 모듈은 객체 검출의 정확도(mAP 등)를 높이는 데 집중할 뿐, 그 결과가 계획 모듈에 얼마나 유용한지는 고려하지 않는다. 반면, UniAD는 계획 모듈의 요구사항이 인지와 예측 모듈의 학습 방향을 결정하도록 설계되었다. 즉, 주행 계획에 중요한 객체(예: 전방의 급정거 차량)는 더 정확하게 인식하고 예측하도록 가중치가 부여되는 방식이다.</p>
<p>이러한 철학은 아키텍처 설계에 그대로 반영되어 있다. UniAD는 인지와 예측 모듈의 출력값이 단순한 후처리(Post-processing)를 거쳐 전달되는 것이 아니라, ’쿼리(Query)’라는 형태의 잠재적 특징(Latent Feature)으로 변환되어 다음 단계의 모듈로 전파된다. 이를 통해 정보의 손실을 최소화하고, 각 모듈이 문맥적 정보(Contextual Information)를 공유할 수 있게 된다.7</p>
<h3>2.2  쿼리 기반 통합 아키텍처 (Query-Based Unified Design) 상세 분석</h3>
<p>UniAD의 아키텍처는 트랜스포머(Transformer) 모델의 디코더(Decoder) 구조를 계층적으로 연결한 형태를 띠고 있다. 전체 시스템은 크게 BEV(Bird’s-Eye-View) 특징 추출기, 4개의 인지 및 예측 모듈(TrackFormer, MapFormer, MotionFormer, OccFormer), 그리고 1개의 플래너(Planner)로 구성된다.</p>
<p><strong>UniAD Core Architecture: Query-Based Unified Design</strong></p>
<pre><code class="language-mermaid">graph TD
    
    Input["다중 카메라 이미지 (Multi-camera Images)"] --&gt; Backbone["백본 네트워크 (ResNet 등)"]
    Backbone --&gt; BEV["BEV 인코더&lt;br&gt;(BEVFormer/LSS)"]
    
    subgraph "공용 특징 공간 (Shared Feature Space)"
        BEV_Feat["BEV 특징 맵&lt;br&gt;(Feature Map)"]
    end
    
    BEV_Feat --"Query Extraction"--&gt; Track["TrackFormer"]
    BEV_Feat --"Query Extraction"--&gt; Map["MapFormer"]
    BEV_Feat --"Query Extraction"--&gt; Occ["OccFormer"]
    
    Track --"트랙 쿼리 (Track Query)"--&gt; Motion["MotionFormer"]
    Map --"맵 쿼리 (Map Query)"--&gt; Motion
    
    Motion --"미래 궤적 / 모션 쿼리"--&gt; Occ
    Motion --"상호작용 예측 정보"--&gt; Planner["Planner&lt;br&gt;(Command-based)"]
    
    Occ --"점유 그리드 맵 (Occupancy Map)"--&gt; Planner
    
    Planner --"충돌 회피 및 최적화"--&gt; Trajectory["최종 주행 궤적&lt;br&gt;(Trajectory)"]
    
    style BEV_Feat fill:#f9f,stroke:#333,stroke-width:2px
    style Planner fill:#bbf,stroke:#333,stroke-width:2px
</code></pre>
<h4>2.2.1  BEV 특징 추출 및 인코딩</h4>
<p>입력 데이터로는 다중 카메라 이미지(Multi-camera Images)가 사용된다. 이 2D 이미지들은 ResNet 등의 백본 네트워크를 거쳐 특징이 추출된 후, BEVFormer와 같은 BEV 인코더를 통해 조감도(Top-down view) 형태의 BEV 특징 맵(Feature Map)으로 변환된다.1 UniAD v2.0에서는 사용자가 BEVFormer 외에도 LSS(Lift-Splat-Shoot) 등 다른 BEV 인코딩 방식을 선택할 수 있도록 유연성이 강화되었다. 단, <code>bev_embed</code>와 <code>bev_pos</code>의 텐서 형태(Shape)를 일치시켜야 한다는 제약 조건이 따른다.5</p>
<p>이 BEV 특징 맵은 전체 시스템의 ‘공용 메모리’ 역할을 수행한다. 모든 하위 모듈은 이 BEV 특징 맵에 접근하여 필요한 정보를 쿼리(Query)하고 추출한다.</p>
<h4>2.2.2  TrackFormer: 동적 객체의 추적 및 정보 통합</h4>
<p>TrackFormer는 주변의 차량, 보행자 등 동적 객체를 검출하고 추적하는 역할을 담당한다. 기존의 검출기들이 바운딩 박스(Bounding Box) 예측에 그쳤다면, TrackFormer는 각 객체에 고유한 ID를 부여하고 시간적 연속성을 유지하는 데 중점을 둔다.</p>
<p>여기서 생성된 ’트랙 쿼리(Track Query)’는 해당 객체의 위치, 속도, 크기뿐만 아니라 외형적 특징 정보까지 함축하고 있다. 이 트랙 쿼리는 다음 단계인 MotionFormer로 전달되어, 단순한 물리적 상태를 넘어선 ’객체의 의도’를 파악하는 기초 자료로 활용된다.8</p>
<h4>2.2.3  MapFormer: 정적 환경의 구조화</h4>
<p>MapFormer는 차선, 횡단보도, 도로 경계 등 정적 도로 요소를 인식한다. 이를 위해 ’맵 쿼리(Map Query)’를 사용하여 BEV 특징 맵에서 도로 구조 정보를 추출한다. MapFormer의 출력은 자아 차량의 위치 결정(Localization)과 경로 계획에 필수적인 주행 가능 영역(Drivable Area) 정보를 제공한다. 또한, 트랙 쿼리와 맵 쿼리의 상호작용을 통해 “차량이 차선을 따라 이동한다“는 논리적 추론이 가능해진다.7</p>
<h4>2.2.4  MotionFormer: 상호작용 기반 미래 예측</h4>
<p>UniAD의 가장 혁신적인 부분 중 하나인 MotionFormer는 TrackFormer로부터 트랙 쿼리를, MapFormer로부터 맵 쿼리를 입력받아 각 객체의 미래 궤적을 예측한다. 기존의 예측 모델들이 각 객체를 독립적으로 처리했다면, MotionFormer는 ’Agent-Agent Interaction’과 ’Agent-Map Interaction’을 명시적으로 모델링한다.</p>
<p>트랜스포머의 셀프 어텐션(Self-Attention) 메커니즘을 통해 차량 간의 상호작용(예: 끼어들기, 양보)을 분석하고, 크로스 어텐션(Cross-Attention)을 통해 차량과 도로 형상 간의 관계(예: 곡선로 주행)를 파악한다. 이를 통해 향후 12 프레임(약 6초) 동안의 다중 모드(Multi-modal) 궤적을 예측하며, 이 정보는 다시 ‘모션 쿼리(Motion Query)’ 형태로 플래너에 전달된다.7</p>
<h4>2.2.5  OccFormer: 픽셀 수준의 점유 예측</h4>
<p>객체 검출(Detection)만으로는 도로 위의 모든 장애물을 파악하기 어렵다. 비정형 물체(예: 떨어진 화물, 공사 자재)나 분류되지 않은 객체를 인식하기 위해 OccFormer는 픽셀 수준의 점유 그리드 맵(Occupancy Grid Map)을 예측한다.</p>
<p>OccFormer는 BEV 특징 맵을 입력받아 미래의 각 시점(Time Step)에서 특정 그리드 셀이 점유될 확률을 계산한다. 이는 1단계 학습에서는 인스턴스 정보 없이 수행되지만, 2단계 엔드투엔드 학습에서는 MotionFormer의 예측 결과와 결합되어 인스턴스 수준(Instance-level)의 점유 예측을 수행한다.1 이는 계획 단계에서 충돌 회피를 위한 가장 확실한 안전 장치로 작용한다.</p>
<h4>2.2.6  Planner: 최적 궤적 생성 및 충돌 회피</h4>
<p>최상위 모듈인 Planner는 자아 차량(Ego-vehicle)의 ’계획 쿼리(Plan Query)’를 사용하여 최종적인 주행 궤적을 생성한다. Planner는 단순히 목적지를 향한 최단 경로를 찾는 것이 아니라, MotionFormer가 예측한 주변 차량의 움직임과 OccFormer가 예측한 점유 맵을 고려하여 ‘안전하고(Safety)’, ‘규정을 준수하며(Compliance)’, ‘편안한(Comfort)’ 경로를 찾는다.</p>
<p>특히, UniAD의 Planner는 뉴턴 방법(Newton’s Method)을 이용한 비선형 최적화(Non-linear Optimization) 과정을 포함하고 있다. 이는 신경망이 예측한 초기 궤적을 바탕으로, OccFormer의 점유 확률 맵을 비용 함수(Cost Function)로 활용하여 충돌 가능성이 높은 영역을 미세하게 회피하도록 궤적을 수정한다.7</p>
<pre><code class="language-mermaid">sequenceDiagram
    title UniAD Data Processing Sequence
    participant Camera as "센서&lt;br&gt;(Camera)"
    participant BEV as "BEV&lt;br&gt;Encoder"
    participant TrackMap as "Track/Map&lt;br&gt;Former"
    participant Motion as "Motion&lt;br&gt;Former"
    participant Occ as "Occ&lt;br&gt;Former"
    participant Plan as "Planner"

    Camera-&gt;&gt;BEV: "2D 이미지 입력"
    BEV-&gt;&gt;BEV: "특징 추출 및 BEV 변환"
    
    par Parallel Extraction
        BEV-&gt;&gt;TrackMap: "BEV Feature 제공"
        TrackMap-&gt;&gt;TrackMap: "객체 추적 및&lt;br&gt;지도 생성"
    end
    
    TrackMap-&gt;&gt;Motion: "Track Query &amp;&lt;br&gt;Map Query 전달"
    Motion-&gt;&gt;Motion: "상호작용 분석 및&lt;br&gt;궤적 예측"
    
    Motion-&gt;&gt;Occ: "Motion Query&lt;br&gt;(예측 궤적) 전달"
    BEV-&gt;&gt;Occ: "BEV Feature&lt;br&gt;전달"
    Occ-&gt;&gt;Occ: "점유 그리드 맵 생성&lt;br&gt;(Instance-level)"
    
    Motion-&gt;&gt;Plan: "예측된 객체&lt;br&gt;궤적 전달"
    Occ-&gt;&gt;Plan: "점유 맵 (충돌 비용 함수용) 전달"
    Plan-&gt;&gt;Plan: "초기 궤적 생성 및&lt;br&gt;비선형 최적화"
    Plan-&gt;&gt;Plan: "충돌 체크 및&lt;br&gt;회피 기동 계산"
    Plan--&gt;&gt;Camera: "최종 제어&lt;br&gt;명령/궤적 출력"
</code></pre>
<h2>3.  UniAD v2.0의 기술적 진보와 생태계 확장</h2>
<p>2025년 10월 릴리스된 UniAD v2.0은 v1.0의 개념적 우수성을 유지하면서도, 실제 연구 및 개발 환경에서의 사용성을 극대화하기 위해 대대적인 업그레이드를 단행했다.</p>
<p><strong>UniAD v2.0 Key Upgrades &amp; Changes</strong></p>
<pre><code class="language-mermaid">graph LR

    v2["UniAD v2.0 Release"]
    
    subgraph "프레임워크 마이그레이션"
        F1["PyTorch 1.x -&gt; 2.0.1+"]
        F2["CUDA 11.8 &amp; 최신 GPU 지원"]
        F3["MMDetection3D 1.0.0rc6"]
        F4["컴파일러 레벨 최적화 (Speed Up)"]
    end
    
    subgraph "데이터셋 확장"
        D1["nuPlan 통합 (Long-term Planning)"]
        D2["NAVSIM 벤치마크 (Closed-loop)"]
        D3["다양한 평가 지표 (Comfort, TTC 등)"]
    end
    
    subgraph "버그 수정 및 안정성"
        B1["Planner 시각화 x축 반전 수정"]
        B2["Stage 1 학습 재현성 확보"]
        B3["Cumsum 차원 오류 수정"]
    end
    
    v2 --&gt; F1
    v2 --&gt; D1
    v2 --&gt; B1
    F1 --&gt; F2
    F1 --&gt; F3
    F1 --&gt; F4
    D1 --&gt; D2
    D1 --&gt; D3
    B1 --&gt; B2
    B1 --&gt; B3
</code></pre>
<h3>3.1  최신 딥러닝 프레임워크로의 마이그레이션</h3>
<p>UniAD v1.0은 구형 라이브러리에 의존하고 있어 최신 GPU 하드웨어 가속 기능을 충분히 활용하지 못하는 한계가 있었다. v2.0은 이러한 기술적 부채를 청산하고 최신 환경에 맞게 코드베이스를 재구축했다.</p>
<table><thead><tr><th><strong>항목</strong></th><th><strong>v1.0 환경</strong></th><th><strong>v2.0 환경</strong></th><th><strong>업그레이드 효과</strong></th></tr></thead><tbody>
<tr><td><strong>PyTorch</strong></td><td>1.x 버전</td><td><strong>2.0.1+cu118</strong></td><td><code>torch.compile</code> 등 컴파일러 레벨 최적화 지원, 학습 속도 향상, Ampere/Hopper 아키텍처 호환성 증대</td></tr>
<tr><td><strong>MMDetection3D</strong></td><td>0.x / 구형 1.x</td><td><strong>1.0.0rc6</strong></td><td>최신 트랜스포머 백본 모델 지원, 데이터 파이프라인 효율화, 버그 수정</td></tr>
<tr><td><strong>CUDA</strong></td><td>10.x / 11.1</td><td><strong>11.8</strong></td><td>최신 GPU 드라이버 및 라이브러리(cuDNN 등) 성능 활용</td></tr>
</tbody></table>
<p>이러한 마이그레이션은 단순히 버전을 올리는 작업을 넘어, <code>mmcv</code> 및 <code>mmdet</code> 등 의존성 패키지들의 충돌 문제를 해결하고 설치 과정을 간소화했다는 점에서 큰 의미가 있다. 특히 6의 설치 가이드에 따르면, <code>conda</code> 환경 설정부터 <code>pip</code> 패키지 설치까지의 과정이 명확하게 정리되어 있어 연구 진입 장벽을 낮추었다.</p>
<h3>3.2  데이터셋의 확장: nuPlan 및 NAVSIM 통합</h3>
<p>UniAD v1.0은 주로 nuScenes 데이터셋을 기반으로 평가되었다. nuScenes은 훌륭한 데이터셋이지만, 짧은 클립 위주의 구성으로 인해 장기적인 계획(Long-term Planning) 능력을 검증하는 데에는 한계가 있었다. v2.0은 이를 극복하기 위해 <strong>nuPlan</strong>과 <strong>NAVSIM</strong> 데이터셋을 통합했다.5</p>
<h4>3.2.1  nuPlan: 데이터 기반 계획의 표준</h4>
<p>Motional이 공개한 nuPlan은 세계 최초의 대규모 계획 벤치마크용 데이터셋으로, 1,200시간 이상의 실제 주행 로그를 포함하고 있다. nuPlan은 단순한 인지 성능이 아닌, 시뮬레이션 환경에서의 폐루프 주행 능력을 평가한다. UniAD v2.0은 nuPlan 데이터셋을 처리할 수 있는 데이터 로더와 전처리 도구를 내장하여, 연구자들이 모델의 장기 계획 능력을 직접 검증할 수 있게 되었다.11</p>
<h4>3.2.2  NAVSIM: 비반응형 시뮬레이션의 정수</h4>
<p>NAVSIM은 CVPR 2024 자율 주행 챌린지 등을 통해 부상한 새로운 벤치마크이다. NAVSIM은 ‘비반응형(Non-reactive)’ 시뮬레이션을 기본으로 하되, PDM Score(Predictive Driver Model Score)라는 정교한 지표를 통해 계획 알고리즘의 우수성을 평가한다.13</p>
<p>UniAD v2.0은 NAVSIM 통합을 통해 다음과 같은 세부 지표에서 성능을 입증받았다:</p>
<ul>
<li><strong>NC (No Collision)</strong>: 충돌 없는 주행 비율.</li>
<li><strong>DAC (Drivable Area Compliance)</strong>: 주행 가능 구역 준수 여부.</li>
<li><strong>TTC (Time To Collision)</strong>: 충돌까지의 시간 여유.</li>
<li><strong>Comfort</strong>: 가속도(Jerk) 등을 고려한 승차감 지표.</li>
</ul>
<p>v2.0 릴리스 노트에 따르면, UniAD는 NAVSIM 벤치마크 툴을 2025년 2분기까지 완전히 통합하여 배포할 예정이며, 이미 내부적으로는 SOTA급의 NAVSIM 점수를 확보한 것으로 보고되었다.5</p>
<h3>3.3  핵심 버그 수정 및 안정성 강화</h3>
<p>UniAD v2.0 개발 과정에서 발견되고 수정된 주요 버그들은 이 프레임워크의 신뢰성을 높이는 데 크게 기여했다.</p>
<ul>
<li><strong>계획 시각화 x축 반전 오류 수정 (2023/08/03)</strong>: 플래너가 생성한 궤적을 시각화할 때 x축이 Ground Truth와 반대로 표시되던 문제가 수정되었다. 이는 정량적 지표에는 영향을 주지 않지만, 연구자들이 모델의 거동을 정성적으로 분석하는 데 큰 혼란을 주었던 문제였다.5</li>
<li><strong>Stage 1 학습 재현성 확보 (2023/06/12)</strong>: 초기 모델 학습(Track/Map) 단계에서 <code>loss_past_traj</code>가 불필요하게 추가되고, <code>img_neck</code> 및 배치 정규화(BN) 레이어가 의도치 않게 동결(Freeze)되는 문제가 있었다. 이로 인해 사용자가 처음부터 학습을 시도할 때 논문에 보고된 성능(AMOTA 0.393)을 재현할 수 없었다. v2.0에서는 이 코드를 수정하여 누구나 논문의 성능을 재현할 수 있도록 조치하였다.5</li>
<li><strong>Planning Cumsum Dimension Issue</strong>: 계획 모듈에서 누적 합(Cumulative Sum) 연산 시 차원 불일치로 인해 발생하던 오류가 수정되었다.15</li>
</ul>
<pre><code class="language-mermaid">gitGraph
    commit id: "v1.0-Release" tag: "Legacy"
    branch fix-reproducibility
    checkout fix-reproducibility
    commit id: "Fix_Stage1_Freeze" msg: "Unfreeze img_neck/BN"
    commit id: "Remove_Past_Loss" msg: "Del loss_past_traj"
    checkout main
    merge fix-reproducibility id: "Repro_OK"
    branch fix-visualization
    checkout fix-visualization
    commit id: "Fix_X_Axis" msg: "Flip X-axis for Plot"
    checkout main
    merge fix-visualization id: "Vis_OK"
    branch upgrade-framework
    checkout upgrade-framework
    commit id: "Bump_PyTorch" msg: "To PyTorch 2.0"
    commit id: "Fix_Cumsum" msg: "Dimension Mismatch Fix"
    commit id: "Add_NAVSIM" msg: "Integrate NAVSIM Loader"
    checkout main
    merge upgrade-framework id: "v2.0-Ready" tag: "v2.0-Release"
</code></pre>
<h2>4.  구현 상세 및 학습 전략 (Implementation Details)</h2>
<p>UniAD와 같은 거대하고 복잡한 엔드투엔드 모델을 학습시키는 것은 매우 까다로운 작업이다. v2.0은 학습의 안정성과 수렴 속도를 보장하기 위해 정교한 **2단계 학습 전략(Two-Stage Training Strategy)**을 채택하고 있다.7</p>
<p><strong>Two-Stage Training Strategy</strong></p>
<pre><code class="language-mermaid">graph TD


    subgraph "Stage 1: Perception Pre-training"
        direction TB
        S1_Input["입력: Queue Length 5"]
        S1_Modules["학습 대상: TrackFormer + MapFormer"]
        S1_Goal["목표: 인지 기초 체력 확보"]
        S1_Loss["Loss: Tracking &amp; Mapping Loss"]
        
        S1_Input --&gt; S1_Modules
        S1_Modules --&gt; S1_Goal
        S1_Goal --&gt; S1_Loss
    end

    subgraph "Stage 2: End-to-End Fine-tuning"
        direction TB
        S2_Input["입력: Queue Length 3 (메모리 절약)"]
        S2_Modules["학습 대상: All Modules (Motion, Occ, Planner 포함)"]
        S2_Load["초기화: Stage 1 가중치 로드"]
        S2_Opt["목표: Planning-oriented 최적화"]
        S2_Loss["Loss: Total Loss (Planning Loss가 전파됨)"]

        S2_Input --&gt; S2_Load
        S2_Load --&gt; S2_Modules
        S2_Modules --&gt; S2_Opt
        S2_Opt --&gt; S2_Loss
    end

    S1_Loss == "가중치 전달 (Weights Transfer)" ==&gt; S2_Load
</code></pre>
<h3>4.1  Stage 1: 인지 및 예측 기초 학습 (Perception Pre-training)</h3>
<p>엔드투엔드 모델을 처음부터 모든 손실 함수를 켜고 학습시키면(Training from Scratch), 그래디언트의 방향이 상충하여 수렴하지 않거나 로컬 미니멈(Local Minimum)에 빠질 위험이 크다. 따라서 Stage 1에서는 인지 모듈의 기초 체력을 다지는 데 집중한다.</p>
<ul>
<li><strong>학습 대상</strong>: <code>TrackFormer</code>와 <code>MapFormer</code>.</li>
<li><strong>설정</strong>: 시간적 연속성을 충분히 학습하기 위해 큐 길이(Queue Length)를 <strong>5 프레임</strong>으로 설정한다. 이는 과거 5 프레임의 BEV 특징을 현재 프레임과 융합하여 동적 객체의 이동 경향성을 파악하는 데 도움을 준다.</li>
<li><strong>목표</strong>: 안정적인 트랙 쿼리와 맵 쿼리를 생성하여, 이후 단계인 MotionFormer와 Planner에 양질의 입력을 제공할 준비를 마친다.</li>
<li><strong>성능 지표</strong>: 이 단계에서 UniAD-B(Base) 모델 기준 Tracking AMOTA는 약 0.394, Mapping IoU-lane은 0.294 수준에 도달한다.16</li>
</ul>
<h3>4.2  Stage 2: 엔드투엔드 통합 학습 (End-to-End Fine-tuning)</h3>
<p>Stage 1에서 학습된 가중치를 초기값(Initialization)으로 사용하여, 전체 파이프라인을 통합 학습한다.</p>
<ul>
<li><strong>학습 대상</strong>: <code>Track</code>, <code>Map</code>, <code>Motion</code>, <code>Occ</code>, <code>Planner</code> 전체 모듈.</li>
<li><strong>설정</strong>: 메모리 사용량을 고려하여 큐 길이를 <strong>3 프레임</strong>으로 줄인다. 전체 모듈이 로드되므로 GPU 메모리 부하가 크기 때문이다.</li>
<li><strong>손실 함수(Loss Function)</strong>: 각 모듈의 손실 함수가 합산되어 역전파(Backpropagation)된다. 특히 Planner의 손실 함수(충돌 패널티, 경로 이탈 패널티 등)가 하위 모듈인 인지와 예측 모듈에도 영향을 미쳐, “계획하기 좋은 인지“가 되도록 가중치를 미세 조정(Fine-tuning)한다.</li>
<li><strong>최적화</strong>: Planner 내부의 충돌 최적화기(Collision Optimizer)는 미분 가능한 구조가 아니므로, 학습 단계에서는 제외되거나 근사화된 그라디언트를 사용하고, 추론(Inference) 단계에서만 활성화되는 전략을 취하기도 한다.</li>
</ul>
<h3>4.3  하드웨어 요구사항 및 연산 비용</h3>
<p>UniAD v2.0 학습을 위해서는 고성능 컴퓨팅 자원이 필수적이다.</p>
<ul>
<li><strong>GPU</strong>: 최소 NVIDIA A100 (80GB) 8장 이상의 클러스터가 권장된다. ResNet-101 백본을 사용하는 UniAD-B 모델의 경우, 배치 사이즈를 1로 설정하더라도 상당한 VRAM을 소모한다.</li>
<li><strong>학습 시간</strong>: Stage 2 학습(약 20 에포크)에는 8 GPU 기준으로 수일(3~5일)이 소요될 수 있다.16</li>
<li><strong>추론 속도</strong>: NVIDIA RTX 3090 또는 A100 단일 GPU에서 추론 시, 약 1~2 FPS (931ms Latency) 수준의 속도를 보인다. 이는 실시간 주행(10Hz 이상)에는 부족한 수치이며, 향후 경량화나 TensorRT 최적화가 필요한 부분이다.18</li>
</ul>
<h2>5.  성능 평가 및 벤치마크 결과 심층 분석</h2>
<p>UniAD v2.0은 다양한 벤치마크에서 기존 SOTA 모델들을 압도하거나 대등한 성능을 보여주었다. 특히 안전과 직결되는 지표들에서의 성과가 두드러진다.</p>
<p><strong>Planner Logic: Non-linear Optimization with Newton’s Method</strong></p>
<pre><code class="language-mermaid">graph TD

    Start("Planner Start") --&gt; Init["초기 궤적 생성 (Neural Output)"]
    
    subgraph "Collision Optimizer (Inference Only)"
        direction TB
        Input_Occ["OccFormer: Occupancy Map"]
        Input_Traj["Current Trajectory Proposal"]
        
        Cost_Calc["비용 함수 계산 (Cost Function)"]
        Cost_Detail1["Term 1: 충돌 비용 (Collision Cost)"]
        Cost_Detail2["Term 2: 경계 이탈 비용 (Boundary Cost)"]
        
        Input_Occ --&gt; Cost_Calc
        Input_Traj --&gt; Cost_Calc
        Cost_Calc --&gt; Cost_Detail1
        Cost_Calc --&gt; Cost_Detail2
        
        Check["수렴 조건 확인 (Convergence?)"]
        Update["뉴턴 방법 적용 (Gradient Update)"]
        
        Cost_Detail1 --&gt; Check
        Cost_Detail2 --&gt; Check
        
        Check --"No"--&gt; Update
        Update --"Refined Trajectory"--&gt; Input_Traj
    end
    
    Check --"Yes (Optimized)"--&gt; Final["최종 궤적 출력 (Final Trajectory)"]
    
    style Cost_Calc fill:#ff9,stroke:#333
    style Update fill:#f9f,stroke:#333
</code></pre>
<h3>5.1  nuScenes 벤치마크 (Open-loop Evaluation)</h3>
<p>nuScenes은 UniAD의 성능을 검증하는 1차적인 전장이었다.</p>
<table><thead><tr><th><strong>평가 항목</strong></th><th><strong>지표</strong></th><th><strong>UniAD v2.0 성능</strong></th><th><strong>의미 및 해석</strong></th></tr></thead><tbody>
<tr><td><strong>Motion Prediction</strong></td><td>minADE (m)</td><td><strong>0.71</strong></td><td>예측된 궤적과 실제 궤적 간의 평균 오차가 71cm에 불과함. 이는 타 차량의 움직임을 매우 정밀하게 예측함을 의미.</td></tr>
<tr><td><strong>Occupancy</strong></td><td>IoU (%)</td><td><strong>63.4</strong></td><td>도로 점유 예측의 정확도가 60%를 상회. 특히 자아 차량 주변(Near) 영역에서의 정확도가 높아 충돌 회피에 유리함.</td></tr>
<tr><td><strong>Planning</strong></td><td>Avg. Collision (%)</td><td><strong>0.31</strong></td><td>계획된 경로가 실제 객체와 충돌할 확률이 0.31%로 극히 낮음. 이는 기획 중심 철학의 유효성을 증명하는 결정적 지표.</td></tr>
<tr><td><strong>Tracking</strong></td><td>AMOTA</td><td><strong>0.393</strong></td><td>다중 객체 추적 성능 또한 최상위권 유지.</td></tr>
</tbody></table>
<p>5의 데이터에 따르면, 특히 Planning 단계의 L2 Error(0.53m)와 Collision Rate(0.31%)는 기존의 모듈형 방식이나 단순 MTL 방식 대비 획기적으로 개선된 수치이다. 이는 인지와 예측 정보가 쿼리를 통해 손실 없이 플래너에 전달되고, 플래너가 이를 효과적으로 활용했음을 시사한다.</p>
<h3>5.2  NAVSIM 벤치마크 (차세대 평가)</h3>
<p>NAVSIM은 UniAD v2.0의 진가를 보여주는 새로운 무대이다.</p>
<table><thead><tr><th><strong>지표 (Metric)</strong></th><th><strong>점수 (Score)</strong></th><th><strong>설명</strong></th></tr></thead><tbody>
<tr><td><strong>PDMS (PDM Score)</strong></td><td><strong>83.4</strong></td><td>종합적인 주행 점수.</td></tr>
<tr><td><strong>NC (No Collision)</strong></td><td><strong>97.8</strong></td><td>거의 모든 시나리오에서 충돌을 회피함.</td></tr>
<tr><td><strong>DAC (Compliance)</strong></td><td><strong>91.9</strong></td><td>주행 가능 구역을 벗어나지 않음.</td></tr>
<tr><td><strong>Comfort</strong></td><td><strong>100</strong></td><td>급가속, 급제동 없는 부드러운 주행.</td></tr>
</tbody></table>
<p>5에 따르면, UniAD는 NAVSIM에서 특히 <strong>Comfort</strong> 점수 만점을 기록했다. 이는 UniAD가 생성하는 궤적이 기계적이지 않고 인간 운전자와 유사한 부드러움을 가지고 있음을 보여준다. <strong>NC</strong> 점수 97.8은 복잡한 트래픽 상황에서도 안전을 최우선으로 하는 정책이 잘 학습되었음을 나타낸다.</p>
<pre><code class="language-mermaid">pie
    title "NAVSIM Score Composition (Example Weights)"
    "No Collision (NC: 97.8)" : 40
    "Comfort (100.0)" : 20
    "Compliance (DAC: 91.9)" : 30
    "Time To Collision (TTC)" : 10
</code></pre>
<h3>5.3  Bench2Drive (Closed-loop Simulation)</h3>
<p>CARLA 시뮬레이터 기반의 Bench2Drive 평가는 UniAD의 실전 능력을 검증한다.</p>
<ul>
<li><strong>점수</strong>: UniAD-Base 모델은 <strong>Driving Score (DS) 45.81</strong>을 기록했다.18</li>
<li><strong>분석</strong>: 이는 최근 등장한 ETA(DS 69.53)나 VAD 등의 경쟁 모델 대비 다소 낮은 수치이다. 그 원인은 **높은 레이턴시(Latency)**에 있다. 폐루프 시뮬레이션에서는 빠른 판단과 반응 속도가 중요한데, UniAD의 무거운 연산량(약 931ms 지연)으로 인해 급변하는 상황에 즉각적으로 대처하지 못하는 경우가 발생하기 때문이다. 이는 UniAD 아키텍처가 정확도는 높지만, 실시간성 측면에서는 최적화가 필요함을 보여주는 데이터이다.</li>
</ul>
<h2>6.  경쟁 모델과의 비교 및 한계점</h2>
<pre><code class="language-mermaid">quadrantChart
    title "Autonomous Driving Model Landscape: Speed vs. Safety/Completeness"
    x-axis "추론 속도 (Inference Speed) - Slow to Fast"
    y-axis "안전성 및 시나리오 대응력 (Safety &amp; Completeness) - Low to High"
    quadrant-1 "Ideal Goal (Real-time &amp; Safe)"
    quadrant-2 "Heavy Computation (UniAD Zone)"
    quadrant-3 "Baseline / Simple Models"
    quadrant-4 "Fast but Less Detailed"
    
    "TransFuser": [0.6, 0.4]
    "Hydra-MDP": [0.5, 0.7]
    "VAD (Vectorized)": [0.8, 0.65]
    "UniAD v2.0": [0.25, 0.95]
    "ETA (Async Dual)": [0.85, 0.75]
    "Human Driver": [0.9, 0.95]
</code></pre>
<h3>6.1  vs. VAD (Vectorized Autonomous Driving)</h3>
<p>VAD는 UniAD의 ’무거움’을 해결하기 위해 등장한 모델이다. 래스터(Raster) 기반의 BEV 맵 대신 벡터(Vector) 표현을 사용하여 연산 속도를 비약적으로 높였다.</p>
<ul>
<li><strong>비교</strong>: VAD는 추론 속도가 빨라 CARLA 등 폐루프 평가에서 유리하다. 반면, UniAD는 픽셀 단위의 세밀한 점유(Occupancy) 정보를 다루므로, 비정형 장애물이 많은 실제 도로 환경에서의 안전성은 더 높을 것으로 기대된다.</li>
</ul>
<h3>6.2  vs. Hydra-MDP &amp; TransFuser</h3>
<p>Hydra-MDP는 지식 증류(Knowledge Distillation)를 통해 규칙 기반 모델의 안정성을 모방한다. NAVSIM 등에서 높은 점수를 기록하지만, UniAD와 같은 엔드투엔드 모델 고유의 ‘데이터로부터의 일반화(Generalization from Data)’ 능력은 부족할 수 있다. TransFuser와 비교했을 때, UniAD는 복잡한 교차로 등에서 객체 간 상호작용을 더 잘 처리한다.</p>
<h3>6.3  vs. ETA (Efficiency through Thinking Ahead)</h3>
<p>ETA는 거대 모델의 추론 지연을 극복하기 위해 비동기 듀얼 모델 구조를 제안했다. 18에 따르면 ETA는 50ms의 빠른 속도로 69.53의 DS를 기록했다. 이는 UniAD v2.0이 향후 나아가야 할 방향이 ‘모델 경량화’ 또는 ’비동기 처리’임을 시사한다.</p>
<h2>7.  향후 전망 및 결론</h2>
<h3>7.1  월드 모델(World Model)과의 융합</h3>
<p>OpenDriveLab은 UniAD 외에도 <strong>Vista</strong>, <strong>GenAD</strong>와 같은 월드 모델 연구를 선도하고 있다.19 UniAD v2.0의 인지 및 예측 능력은 이러한 생성형 AI 기술과 결합되어, 미래 상황을 미리 시뮬레이션(Dreaming)하고 최적의 행동을 결정하는 ‘예지적 자율 주행’ 시스템으로 진화할 것이다. 이는 데이터가 부족한 롱테일(Long-tail) 시나리오를 해결하는 열쇠가 될 수 있다.</p>
<h3>7.2  결론</h3>
<p>UniAD v2.0은 “기획 중심(Planning-oriented)” 철학을 기술적으로 완성한 기념비적인 프레임워크이다. v1.0에서 입증된 개념적 우수성을 바탕으로, v2.0은 최신 개발 환경과 차세대 벤치마크(NAVSIM, nuPlan)를 통합하여 연구 및 산업 현장에서 즉시 활용 가능한 수준으로 도약했다. 비록 실시간 연산 속도라는 과제가 남아있지만, 인지-예측-계획이 하나의 유기체처럼 작동하는 UniAD의 아키텍처는 완전 자율 주행(Level 5)으로 가는 가장 확실한 길 중 하나를 제시하고 있다.</p>
<p>연구자들에게 UniAD v2.0은 단순한 코드가 아니라, 자율 주행의 미래를 설계하는 강력한 도구이자 플랫폼이 될 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>UniAD: Foundational Model for End-to-End Autonomous Driving, https://medium.com/axinc-ai/uniad-foundational-model-for-end-to-end-autonomous-driving-aa593496eb53</li>
<li>(PDF) Planning-oriented Autonomous Driving - ResearchGate, https://www.researchgate.net/publication/373321358_Planning-oriented_Autonomous_Driving</li>
<li>OpenDriveLab/UniAD2.0_R101_nuScenes - Hugging Face, https://huggingface.co/OpenDriveLab/UniAD2.0_R101_nuScenes</li>
<li>Planning-Oriented Autonomous Driving | PDF | Perception - Scribd, https://www.scribd.com/document/655170556/2212-10156v2</li>
<li>OpenDriveLab/UniAD: [CVPR 2023 Best Paper Award … - GitHub, https://github.com/OpenDriveLab/UniAD</li>
<li>UniAD/docs/INSTALL.md at v2.0 - GitHub, https://github.com/OpenDriveLab/UniAD/blob/v2.0/docs/INSTALL.md</li>
<li>Planning-Oriented Autonomous Driving - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2023/papers/Hu_Planning-Oriented_Autonomous_Driving_CVPR_2023_paper.pdf</li>
<li>[2212.10156] Planning-oriented Autonomous Driving - arXiv, https://arxiv.org/abs/2212.10156</li>
<li>Planning-oriented Autonomous Driving Supplementary Material, https://openaccess.thecvf.com/content/CVPR2023/supplemental/Hu_Planning-Oriented_Autonomous_Driving_CVPR_2023_supplemental.pdf</li>
<li>[Quick Review] Planning-oriented Autonomous Driving - Liner, https://liner.com/review/planningoriented-autonomous-driving</li>
<li>The nuPlan benchmark for real-world autonomous driving, https://www.researchgate.net/publication/382988732_Towards_learning-based_planning_The_nuPlan_benchmark_for_real-world_autonomous_driving</li>
<li>nuPlan - nuScenes, https://www.nuscenes.org/nuplan</li>
<li>GitHub - autonomousvision/navsim: [CoRL ’25] Pseudo-Simulation …, https://github.com/autonomousvision/navsim</li>
<li>NAVSIM: Data-Driven Non-Reactive Autonomous Vehicle …, https://openreview.net/pdf/81cf216dd64be20e5e8a284026eeaf6d8791906f.pdf</li>
<li>Releases · OpenDriveLab/UniAD - GitHub, https://github.com/OpenDriveLab/UniAD/releases</li>
<li>Supplementary Material for NAVSIM: Data-Driven Non-Reactive …, https://www.cvlibs.net/publications/Dauner2024NEURIPS_supplementary.pdf</li>
<li>End-to-End Autonomous Driving without Costly Modularization and …, https://arxiv.org/html/2406.17680v1</li>
<li>ETA: Efficiency through Thinking Ahead, A Dual Approach to Self …, https://arxiv.org/html/2506.07725v1</li>
<li>OpenDriveLab | Robotics and Autonomous Driving at HKU, SII, and …, https://opendrivelab.com/</li>
<li>OpenDriveLab/DriveAGI: A Collection of Foundation Driving Models …, https://github.com/OpenDriveLab/DriveAGI</li>
<li>Activity · OpenDriveLab/UniAD - GitHub, https://github.com/OpenDriveLab/UniAD/activity</li>
<li>Evaluation on NAVSIM v2. Results are grouped by methods., https://www.researchgate.net/figure/Evaluation-on-NAVSIM-v2-Results-are-grouped-by-methods_tbl2_394473244</li>
<li>NAVSIM: Data-Driven Non-Reactive Autonomous Vehicle … - arXiv, https://arxiv.org/html/2406.15349v2</li>
<li>Hydra-NeXt: Robust Closed-Loop Driving with Open-Loop Training, https://arxiv.org/html/2503.12030v2</li>
<li>End-to-End Autonomous Driving without Costly Modularization and …, https://www.researchgate.net/publication/381704578_End-to-End_Autonomous_Driving_without_Costly_Modularization_and_3D_Manual_Annotation</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>