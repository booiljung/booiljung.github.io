<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Hydra-MDP (2024-06-11) 및 Hydra-MDP++ (2025-03-17)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Hydra-MDP (2024-06-11) 및 Hydra-MDP++ (2025-03-17)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">자율주행 (Autonomous Driving)</a> / <span>Hydra-MDP (2024-06-11) 및 Hydra-MDP++ (2025-03-17)</span></nav>
                </div>
            </header>
            <article>
                <h1>Hydra-MDP (2024-06-11) 및 Hydra-MDP++ (2025-03-17)</h1>
<p>2025-12-14, G30DR</p>
<h2>1.  서론: 자율주행 패러다임의 전환과 엔드투엔드 모델의 진화</h2>
<p>자율주행 기술의 발전사는 인지(Perception), 예측(Prediction), 계획(Planning), 제어(Control)로 이어지는 순차적 모듈형(Modular) 파이프라인에서, 센서 입력으로부터 제어 신호를 직접 산출하는 엔드투엔드(End-to-End, E2E) 학습 방식으로의 급격한 패러다임 전환을 겪고 있다.1 초기 모듈형 접근법은 각 단계의 명확한 해석 가능성을 제공했으나, 상위 모듈의 오차가 하위 모듈로 누적되는 오차 전파(Error Propagation) 문제와, 모듈 간 인터페이스 설계 시 발생하는 불가피한 정보 손실이라는 구조적 한계에 봉착했다. 이에 반해 E2E 방식은 전체 파이프라인을 하나의 거대한 신경망으로 통합하여 최적화함으로써 이러한 문제를 근본적으로 해결하고, 대규모 데이터셋을 활용한 확장성(Scalability)을 극대화할 수 있는 잠재력을 입증해 왔다.1</p>
<p>그러나 초기 E2E 모델, 특히 순수 모방 학습(Imitation Learning, IL)에 기반한 모델들은 인간 운전자의 평균적인 거동을 모사하는 데에는 성공했으나, ‘안전(Safety)’, ‘승차감(Comfort)’, ’교통 법규 준수(Rule Compliance)’와 같은 자율주행의 다면적이고 필수적인 목표들을 명시적으로 보장하지 못하는 치명적인 한계를 드러냈다.1 이는 주로 모델의 학습 및 평가가 개방형 루프(Open-loop) 환경에서의 변위 오차(Displacement Error) 최소화에 집중되었기 때문이다.4 인간의 주행 데이터를 단순히 평균적으로 따라가는 것은 사고 회피나 복잡한 상호작용 상황에서의 인과적 추론(Causal Reasoning) 능력을 담보하지 못하며, 시뮬레이터와 현실 간의 도메인 격차(Sim-to-Real Gap) 또한 실차 적용을 가로막는 주요 장벽으로 작용했다.1</p>
<p>이러한 기술적 난제 속에서 NVIDIA 연구진과 학계의 협업으로 탄생한 <strong>Hydra-MDP</strong>와 그 발전형인 **Hydra-MDP++**는 규칙 기반(Rule-based) 계획기의 논리적 견고함과 신경망 기반(Neural) 계획기의 데이터 기반 유연성을 결합한 혁신적인 하이브리드 프레임워크를 제시했다.1 이 시스템은 인간의 주행 데몬스트레이션(Demonstration)뿐만 아니라, 명시적인 안전 규칙과 평가 지표를 따르는 “규칙 기반 전문가(Rule-based Experts)“의 지식을 **하이드라 증류(Hydra-Distillation)**라는 독창적인 기법을 통해 학생(Student) 네트워크에 주입한다.1</p>
<p>본 보고서는 Hydra-MDP 및 Hydra-MDP++ 프레임워크의 아키텍처, 학습 방법론, 실험 결과, 그리고 자율주행 연구 분야에 미치는 함의를 포괄적이고 심층적으로 분석한다. 특히, 다중 교사(Multi-Teacher) 지식 증류 메커니즘, 궤적 어휘(Trajectory Vocabulary) 기반의 다중 모달 계획 전략, 그리고 NAVSIM 벤치마크에서의 압도적인 성과를 상세히 기술하며, 최근 공개된 Hydra-NeXt로 이어지는 기술적 진보의 흐름까지 조망한다.</p>
<h2>2.  자율주행 계획(Planning)의 기술적 배경과 문제 정의</h2>
<h3>2.1  모방 학습(Imitation Learning)의 한계와 개방형 루프 평가의 맹점</h3>
<p>전통적인 E2E 자율주행 연구는 주로 인간 전문가의 주행 궤적을 지도 학습(Supervised Learning)으로 모방하는 방식(Behavioral Cloning, BC)에 의존해 왔다. 이 방식은 수학적으로 모델 <span class="math math-inline">f</span>가 센서 입력 <span class="math math-inline">X</span>를 받아 전문가 궤적 <span class="math math-inline">Y</span>와의 차이(주로 L2 손실)를 최소화하도록 파라미터 <span class="math math-inline">\theta</span>를 최적화하는 과정으로 정의된다:</p>
<p>$$ \theta^* = \arg\min_{\theta} \sum_{i} |</p>
<p>| f(X_i; \theta) - Y_i ||^2 $$</p>
<p>그러나 이러한 단순 모방 학습은 자율주행의 본질적 복잡성을 다루는 데 있어 다음과 같은 세 가지 결정적인 문제를 안고 있다.</p>
<ol>
<li><strong>다중 모달성(Multimodality)의 간과와 모드 붕괴(Mode Collapse):</strong> 주행 환경에서 유효한 궤적은 단 하나가 아니다. 예를 들어, 전방에 장애물이 있을 때 좌측 회피와 우측 회피가 모두 가능할 수 있다. 그러나 단일 정답(Ground Truth)만을 학습하는 결정론적 모델은 두 경로의 평균인 “장애물로 돌진하는” 경로를 학습하는 모드 붕괴 현상을 겪을 수 있다.3 이는 주행의 다양성을 훼손하고 치명적인 사고를 유발할 수 있다.</li>
<li><strong>인과적 혼란(Causal Confusion):</strong> 신경망은 종종 주행 결정의 진정한 ’원인(신호등의 색상, 보행자의 유무)’보다는 화면상의 ’상관관계(주변 차량의 정지 상태, 가로수의 위치)’에 과도하게 의존하는 경향이 있다. 이로 인해 훈련 데이터 분포를 벗어난 낯선 환경에서의 일반화(Generalization) 성능이 급격히 저하된다.1</li>
<li><strong>안전 보장의 부재와 데이터 불균형:</strong> 인간의 주행 데이터는 대부분 안전하고 평범한 상황으로 구성되어 있다. 사고 임박 상황이나 극한의 회피 기동 데이터는 극히 드물다(Long-tail distribution). 따라서 순수 모방 학습 모델은 훈련 데이터에 없는 위험 상황에 직면했을 때 물리적으로 불가능하거나 매우 위험한 거동을 보일 가능성이 크다.1</li>
</ol>
<p>특히, 최근 자율주행 벤치마크 연구들, 그중에서도 NAVSIM 1은 개방형 루프 변위 오차(ADE/FDE)가 실제 주행 성능(Closed-loop performance)과 매우 낮은 상관관계를 보임을 통계적으로 입증했다. 인간 궤적을 30cm 오차로 정밀하게 따라가는 것보다, 50cm 오차가 있더라도 교통 법규를 준수하고 충돌하지 않는 궤적을 생성하는 것이 자율주행의 본질적인 목표에 부합한다. 이는 기존의 평가 지표가 자율주행 시스템의 안전성을 담보하지 못함을 시사하며, 새로운 평가 체계와 학습 방법론의 필요성을 역설한다.</p>
<h3>2.2  규칙 기반 계획기(Rule-Based Planner)의 역할과 딜레마</h3>
<p>이러한 신경망 기반 접근법의 불안정성을 보완하기 위해, 산업계에서는 여전히 규칙 기반(Rule-based) 시스템이 널리 사용된다. 대표적으로 nuPlan 벤치마크에서 사용되는 PDM-Planner(Predictive Driver Model) 1는 IDM(Intelligent Driver Model)과 같은 명시적 알고리즘을 사용하여 안전 거리를 유지하고 법규를 준수한다.</p>
<p>규칙 기반 계획기는 해석 가능성(Interpretability)이 높고 설계된 시나리오 내에서 안전성이 보장된다는 강력한 장점이 있다. 그러나 이들은 인지(Perception) 모듈의 출력값에 전적으로 의존한다. 만약 인지 모듈이 객체의 위치나 속도를 잘못 추정하거나, 비정형 물체를 인식하지 못할 경우(Imperfect Perception), 규칙 기반 로직은 잘못된 전제 하에 잘못된 판단을 내리게 된다.1 또한, 무수히 많은 예외 상황(Corner Cases)에 대해 일일이 규칙을 하드코딩하는 것은 불가능에 가까워 확장성에 한계가 있다.</p>
<p><strong>Hydra-MDP</strong>는 이 두 패러다임의 딜레마를 정면으로 돌파하기 위해 제안되었다. 신경망의 강력한 인지 능력 및 일반화 능력(Perception &amp; Generalization)과, 규칙 기반 시스템의 검증된 안전성 및 논리적 결정력(Safety &amp; Logic)을 결합하는 것이 이 프레임워크의 핵심 철학이다.</p>
<h2>3.  Hydra-MDP 프레임워크 아키텍처 심층 분석</h2>
<p>Hydra-MDP(Multi-modal Planning with Multi-target Hydra-distillation)는 크게 **인지 네트워크(Perception Network)**와 **궤적 디코더(Trajectory Decoder)**로 구성되며, 학습 과정에서 다중 교사(Multi-Teacher)로부터 지식을 증류받는 독창적인 구조를 취한다.1</p>
<h3>3.1  인지 네트워크 (Perception Network): 효율성과 성능의 조화</h3>
<p>Hydra-MDP의 입력부는 다중 카메라 이미지와(선택적으로) 라이다(LiDAR) 센서 데이터를 처리하여 주행 환경의 고차원적이고 의미론적(Semantic) 특징을 추출한다.</p>
<ul>
<li><strong>백본(Backbone) 아키텍처:</strong> 초기 버전과 경량화 버전인 Hydra-MDP++에서는 <strong>ResNet-34</strong>를 백본으로 채택했다.1 최근 트랜스포머 기반의 거대 모델이 유행하는 추세임에도 불구하고, ResNet-34를 통해 SOTA(State-of-the-Art) 성능을 달성한 것은 Hydra-MDP의 학습 프레임워크가 얼마나 효율적인지를 방증한다. 고성능을 목표로 하는 확장 모델의 경우 <strong>ViT-L (Vision Transformer)</strong> 또는 **V2-99 (VoVNet)**과 같은 대규모 백본을 사용하여 특징 추출 능력을 극대화한다.1</li>
<li><strong>시간적 융합(Temporal Fusion):</strong> 자율주행에서 단일 프레임 정보만으로는 주변 차량의 속도, 가속도, 이동 방향과 같은 동적 상태를 파악하기 어렵다. Hydra-MDP는 이를 해결하기 위해 <strong>시간적 Squeeze-and-Excitation (SE)</strong> 네트워크를 도입했다.1 이 모듈은 과거 프레임의 특징 맵(Feature Map)과 현재 시점의 특징 맵을 채널 단위로 융합(Attention)하여 시간적 맥락을 포착한다. 이는 순환 신경망(RNN)이나 LSTM을 사용하는 방식보다 병렬 처리에 유리하며, 3D Conv나 Transformer 기반의 융합보다 계산 비용이 저렴하여 실시간성을 확보하는 데 기여한다.</li>
<li><strong>특징 변환:</strong> 추출된 멀티뷰 이미지 특징은 Transformer Encoder를 거쳐 조감도(Bird’s Eye View, BEV) 형태 혹은 객체 중심의 환경 토큰(Environment Tokens, <span class="math math-inline">F_{env}</span>)으로 변환되어 계획 모듈에 전달된다.2 이 과정에서 센서 간의 기하학적 정합과 정보 융합이 이루어진다.</li>
</ul>
<h3>3.2  궤적 디코더 (Trajectory Decoder) 및 궤적 어휘 (Trajectory Vocabulary)</h3>
<p>Hydra-MDP는 연속적인 공간에서 궤적 좌표 <span class="math math-inline">(x, y)</span>를 직접 회귀(Regression)하는 기존의 방식 대신, 사전에 정의된 **궤적 어휘(Trajectory Vocabulary)**에서 최적의 경로를 선택(Classification)하거나 이를 기반으로 미세 조정(Refinement)하는 ‘분류 기반 계획(Classification-based Planning)’ 방식을 채택한다.3</p>
<ul>
<li><strong>궤적 어휘 생성 (Trajectory Vocabulary Construction):</strong> 연구진은 nuPlan 데이터셋에 포함된 약 70만 개 이상의 실제 주행 궤적 데이터에 대해 K-means 클러스터링을 수행했다. 이를 통해 약 <strong>4,096개 또는 8,192개</strong>의 대표 궤적 앵커(Trajectory Anchors)를 추출하여 궤적 어휘 <span class="math math-inline">\mathcal{V}</span>를 구성했다.3 이 이산화된 궤적 집합은 차량이 물리적으로 수행 가능한 거의 모든 기동(직진, 좌회전, 우회전, 차선 변경, 급정지, 완만한 감속 등)을 포괄한다.</li>
<li><strong>이산화의 장점:</strong> 이러한 방식은 다중 모달성을 명시적으로 다룰 수 있게 해준다. 회귀 모델이 여러 가능성의 평균값으로 수렴하여 “어중간한” 궤적을 내놓는 문제를 원천적으로 차단하며, 확률 분포를 통해 불확실성을 모델링하기 용이하다.</li>
<li><strong>쿼리 기반 디코딩:</strong> 생성된 궤적 앵커들은 고차원 벡터로 임베딩되어 Transformer Decoder의 쿼리(Query)로 사용된다. 디코더는 인지 네트워크에서 추출된 환경 토큰(Key/Value)과 상호작용(Cross-Attention)하여, 현재의 주행 환경 <span class="math math-inline">F_{env}</span> 하에서 각 궤적 앵커가 얼마나 적합한지를 평가한다.3</li>
</ul>
<h3>3.3  핵심 혁신: 다중 목표 하이드라 증류 (Multi-Target Hydra-Distillation)</h3>
<p>이 프레임워크의 명칭이 유래된 핵심 메커니즘이다. 그리스 신화 속 괴물 히드라(Hydra)가 여러 개의 머리를 가진 것처럼, Hydra-MDP의 디코더는 여러 개의 “머리(Heads)“를 통해 서로 다른 “교사(Teachers)“의 평가 기준을 동시에 학습한다.1 이는 모델이 단일한 목적 함수에 과적합되는 것을 막고, 주행의 다면적인 속성을 내재화하도록 유도한다.</p>
<h4>3.3.1  교사 모델 구성 (The Teachers)</h4>
<p>Hydra-MDP는 단일 정답(인간 궤적)에만 의존하지 않고, 시뮬레이터(NAVSIM)에서 파생된 다양한 규칙 기반 지표를 교사로 활용한다. 각 교사는 해당 궤적의 특정 측면을 평가하고 점수를 매긴다.</p>
<p><strong>표 1. Hydra-MDP의 주요 교사(Teachers) 및 평가 지표</strong></p>
<table><thead><tr><th><strong>교사 유형 (Teacher Type)</strong></th><th><strong>평가 지표 (Metric)</strong></th><th><strong>역할 및 설명</strong></th><th><strong>원리 (Mechanism)</strong></th></tr></thead><tbody>
<tr><td><strong>인간 교사 (Human Teacher)</strong></td><td><strong>L2 Distance / Adequacy</strong></td><td>인간 운전자의 궤적과 유사한지 평가. 자연스러운 주행 스타일과 기하학적 유사성을 모방.</td><td>전문가 궤적과의 유클리드 거리 측정.</td></tr>
<tr><td><strong>규칙 기반 교사 (Rule-Based)</strong></td><td><strong>NC (No Collision)</strong></td><td>충돌 발생 여부. 가장 중요한 안전 지표.</td><td>시뮬레이션 상에서 에고 차량과 타 객체 간의 Polygon Intersection 검사.</td></tr>
<tr><td></td><td><strong>DAC (Drivable Area Compliance)</strong></td><td>도로 경계 및 차선 준수 여부.</td><td>HD맵의 도로 영역과 차량 궤적 간의 포함 관계 검사.</td></tr>
<tr><td></td><td><strong>TTC (Time-to-Collision)</strong></td><td>주변 차량과의 충돌 예상 시간. 방어 운전 능력 평가.</td><td>현재 속도 및 상대 속도를 기반으로 충돌까지 남은 시간 계산.</td></tr>
<tr><td></td><td><strong>C (Comfort)</strong></td><td>가속도, 저크(Jerk), 조향각 변화율 등 승차감 관련 물리량.</td><td>궤적의 2차, 3차 미분값을 통해 급격한 거동 감지.</td></tr>
<tr><td></td><td><strong>EP (Ego Progress)</strong></td><td>목적지 방향으로의 이동 거리. 주행 효율성 평가.</td><td>궤적의 끝점이 목표 지점(Goal)에 얼마나 가까워졌는지 측정.</td></tr>
</tbody></table>
<p>이러한 지표들은 본래 시뮬레이션 내에서 사후적으로(Post-hoc) 계산되거나 미분 불가능한 로직으로 구성되어 있어, 기존의 역전파(Backpropagation)를 통한 직접 학습이 불가능했다. Hydra-MDP는 이를 <strong>지식 증류(Knowledge Distillation)</strong> 형태로 해결한다.</p>
<h4>3.3.2  하이드라 증류 학습 과정 (Hydra-Distillation Process)</h4>
<ol>
<li><strong>시뮬레이션 롤아웃 (Simulation Rollout):</strong> 학습 데이터의 각 시나리오에 대해, 궤적 어휘 <span class="math math-inline">\mathcal{V}</span> (예: 4,096개) 내의 모든 궤적 후보를 시뮬레이터(Log-replay 또는 NAVSIM) 상에서 가상으로 실행(Rollout)해본다.3 이는 막대한 계산량을 요구하지만, 오프라인 전처리 단계에서 수행되므로 학습 속도에는 영향을 주지 않는다.</li>
<li><strong>점수 산출 (Ground Truth Scoring):</strong> 각 궤적에 대해 위에서 언급한 NC, DAC, TTC 등의 지표를 계산하여 “정답 점수(Target Scores)“를 생성한다. 예를 들어, 4,096개의 궤적 중 10번 궤적은 충돌이 발생해 <span class="math math-inline">S_{NC}=0</span>, 20번 궤적은 안전하지만 진행도가 낮아 <span class="math math-inline">S_{NC}=1, S_{EP}=0.2</span>와 같은 식으로 레이블링된다.</li>
<li><strong>다중 헤드 증류 (Multi-Head Distillation):</strong> Hydra-MDP의 각 헤드(Head)는 입력된 센서 데이터만을 보고, 특정 궤적을 선택했을 때 예상되는 NC, DAC, TTC 점수를 예측하도록 학습된다. 손실 함수는 예측된 점수 분포와 시뮬레이션 정답 점수 분포 간의 차이(예: Cross-Entropy 또는 KL Divergence)를 최소화한다.</li>
</ol>
<p><span class="math math-display">\mathcal{L}_{total} = \mathcal{L}_{imitation} + \sum_{m \in M} \lambda_m \mathcal{L}_{distill}(S_{pred}^m, S_{gt}^m)</span></p>
<p>이 과정을 통해 모델은 단순히 “인간이 이리로 갔다“는 사실만 배우는 것이 아니라, **“왜 저리로 가면 안 되는지(충돌 위험이 높아서)”, “왜 이 경로가 좋은지(안전하고 빠르며 승차감이 좋아서)”**에 대한 인과적 결과(Causal Consequence)를 예측하는 능력을 갖게 된다.1 즉, 규칙 기반 시뮬레이터의 논리적 판단 능력이 신경망 내부로 내재화(Internalization)되는 것이다.</p>
<h3>3.4 추론(Inference) 단계의 궤적 선택</h3>
<p>추론 시에는 각 헤드가 예측한 점수들을 종합하여 최적의 궤적 <span class="math math-inline">T^*</span>를 선택한다. 이때 PDM 점수(PDM Score) 공식을 활용하여 각 지표를 가중 합산한다.</p>
<p><span class="math math-display">Cost(T_i) = - \left( w_1 \log \hat{S}_{im} + w_2 \log \hat{S}_{NC} + w_3 \log \hat{S}_{DAC} + w_4 \log(5\hat{S}_{TTC} + 2\hat{S}_{C} + 5\hat{S}_{EP}) \right)</span></p>
<p><span class="math math-display">T^* = \arg\min_{T_i \in \mathcal{V}} Cost(T_i)</span></p>
<p>여기서 <span class="math math-inline">w_i</span>는 각 지표의 중요도를 조절하는 하이퍼파라미터로, 일반적으로 안전(NC, DAC) 지표에 높은 가중치를 부여하여 충돌 없는 주행을 최우선으로 한다.7</p>
<h2>4. Hydra-MDP++: 확장된 지표와 성능 고도화</h2>
<p>Hydra-MDP의 초기 성공 이후, 연구진은 NAVSIM 벤치마크의 기존 지표만으로는 포착되지 않는 미세한 주행 불안정성을 발견했다. 예를 들어, 신호를 위반하거나 차로 내에서 갈팡질팡하는 거동은 기존 지표로 완벽히 걸러내기 어려웠다. 이를 개선하기 위해 **Hydra-MDP++**가 제안되었다.1</p>
<h3>4.1 추가된 교사 및 지표 (Extended Metrics)</h3>
<p>기존 NAVSIM 지표(NC, DAC, TTC, C, EP)에 더해, 더욱 정교하고 인간다운 주행을 위한 세 가지 새로운 교사가 도입되었다.1</p>
<ol>
<li><strong>신호등 준수 (Traffic Light Compliance, TL):</strong> 기존 지표가 신호 위반을 명시적으로 충분히 처벌하지 못하는 점을 보완한다. 정지 신호 시 정지선 준수 여부를 엄격히 평가한다.</li>
<li><strong>차로 유지 능력 (Lane-Keeping Ability, LK):</strong> 단순히 도로(Drivable Area) 위에 있는 것을 넘어, 차로 중앙을 안정적으로 유지(Lane Centering)하는 능력을 평가한다. 이는 주변 차량에게 예측 가능한 주행을 제공하는 데 필수적이다.</li>
<li><strong>확장된 승차감 (Extended Comfort, EC):</strong> 횡방향 가속도(Lateral Acceleration)나 급격한 조향(Steering Rate) 등 승차감을 저해하는 요소를 더 세밀하게 평가하여, 로봇 같은 딱딱한 주행이 아닌 부드러운 주행을 유도한다.</li>
</ol>
<p>이러한 새로운 지표들은 **EPDMS (Extended PDM Score)**라는 새로운 종합 점수 체계로 통합되어 모델 최적화에 사용되었다.6</p>
<p><span class="math math-display">EPDMS = \underbrace{(\prod_{m \in \{NC, DAC, DDC, TL\}} S_m)}_{\text{penalties}} \times \underbrace{\left( \frac{\sum_{w \in \{EP, TTC, C, LK, EC\}} weight_w \times S_w}{\sum weight_w} \right)}_{\text{weighted average}}</span></p>
<p>이 식의 구조는 매우 중요한 함의를 갖는다. 충돌(NC), 도로 이탈(DAC), 신호 위반(TL), 주행 방향(DDC) 등 치명적인 안전 요소는 **곱셈 항(Product Term)**으로 적용되어, 이 중 하나라도 0점이면(즉, 사고가 나거나 법규를 어기면) 나머지 점수가 아무리 좋아도 전체 점수는 0점이 된다. 반면 승차감이나 진행도는 가중 평균으로 합산되어 점진적인 성능 향상을 유도한다.6</p>
<h3>3.4  스케일링 전략 및 모델 앙상블 (Scaling &amp; Ensembling)</h3>
<p>Hydra-MDP++는 모델 크기에 따른 성능 확장성(Scalability)을 입증했다.</p>
<ul>
<li><strong>ResNet-34:</strong> 경량 백본임에도 불구하고 효율적인 증류 기법 덕분에 상위권 성능을 유지하며, 엣지 디바이스에서의 실시간 구동 가능성을 보여준다.</li>
<li><strong>V2-99 (VoVNet):</strong> 이미지 인코더를 대형화함으로써 인지 성능을 대폭 향상시켰다. 이를 통해 NAVSIM 점수 **91.0%**라는 압도적인 기록을 달성했는데 1, 이는 규칙 기반 교사로부터 학습한 지식을 더 큰 용량의 신경망이 효과적으로 흡수했음을 의미한다.</li>
<li><strong>앙상블 (Ensembling):</strong> “Mixture of Encoders” 및 “Sub-score Ensembling” 기법을 통해 여러 모델의 예측을 결합했다.3 이는 단일 모델의 불확실성을 줄이고 강건성(Robustness)을 확보하는 데 결정적인 역할을 했다. 특히 서로 다른 아키텍처나 초기화 상태를 가진 모델들의 점수를 평균 내는 방식은 벤치마크 챌린지 우승의 핵심 전략이었다.</li>
</ul>
<h2>4.  실험 결과 및 벤치마크 성능 분석</h2>
<h3>4.1  NAVSIM 벤치마크 성과</h3>
<p>Hydra-MDP 시리즈는 CVPR 2024 Autonomous Grand Challenge의 “End-to-End Driving at Scale” 트랙에서 우승을 차지하며 그 우수성을 전 세계적으로 입증했다.3</p>
<p>표 2. NAVSIM (Navtest Split) 벤치마크 정량적 결과 비교 6</p>
<table><thead><tr><th><strong>모델 (Method)</strong></th><th><strong>입력 (Input)</strong></th><th><strong>백본 (Backbone)</strong></th><th><strong>충돌 미발생 (NC)</strong></th><th><strong>도로 준수 (DAC)</strong></th><th><strong>진행도 (EP)</strong></th><th><strong>PDM 점수 (PDMS)</strong></th></tr></thead><tbody>
<tr><td><strong>PDM-Closed</strong> (Privileged Rule-based)</td><td>GT Perception</td><td>-</td><td>94.6</td><td>99.8</td><td>89.9</td><td><strong>89.1</strong></td></tr>
<tr><td>TransFuser</td><td>Cam + LiDAR</td><td>ResNet34</td><td>97.7</td><td>92.8</td><td>79.2</td><td>84.0</td></tr>
<tr><td>UniAD</td><td>Camera</td><td>ResNet34</td><td>97.8</td><td>91.9</td><td>78.8</td><td>83.4</td></tr>
<tr><td>VADv2</td><td>Cam + LiDAR</td><td>ResNet34</td><td>97.9</td><td>91.7</td><td>77.6</td><td>83.0</td></tr>
<tr><td><strong>Hydra-MDP++ (Ours)</strong></td><td><strong>Camera</strong></td><td><strong>ResNet34</strong></td><td><strong>97.6</strong></td><td><strong>96.0</strong></td><td><strong>80.4</strong></td><td><strong>86.6</strong></td></tr>
<tr><td><strong>Hydra-MDP++ (Ours)</strong></td><td><strong>Camera</strong></td><td><strong>V2-99</strong></td><td><strong>98.6</strong></td><td><strong>98.6</strong></td><td><strong>85.7</strong></td><td><strong>91.0</strong></td></tr>
</tbody></table>
<ul>
<li><strong>분석 1 (대비 SOTA):</strong> Hydra-MDP++(ResNet34)는 동일한 백본을 사용하는 기존 최신(SOTA) 모델인 UniAD, VADv2 대비 PDMS 점수에서 약 <strong>3~4% 포인트</strong> 높은 성능을 보인다. 특히 DAC(도로 준수) 점수에서 96.0%를 기록하며 기존 모델들(91%대)을 크게 앞섰는데, 이는 규칙 기반 교사의 지도가 기하학적 제약 조건을 학습하는 데 매우 효과적임을 시사한다.</li>
<li><strong>분석 2 (대비 PDM-Closed):</strong> V2-99 백본을 사용한 모델은 **91.0%**의 점수를 기록하여, 정답 인식(GT Perception) 정보를 사용하는 특권적 에이전트인 PDM-Closed(89.1%)마저 능가했다. 이는 매우 놀라운 결과로, 신경망 기반 계획기가 노이즈가 있는 센서 데이터를 사용함에도 불구하고, 학습을 통해 규칙 기반 로직의 경직성을 극복하고 더 인간 친화적이거나 최적화된 주행 전략을 수립할 수 있음을 증명한다.</li>
</ul>
<h3>4.2  추론 속도(Inference Speed) 및 지연 시간(Latency)</h3>
<p>자율주행 시스템에서 정확도만큼 중요한 것이 실시간성이다. Hydra-MDP++는 복잡한 사후 처리 없이 전방 전파(Feed-forward)만으로 궤적을 평가하므로 높은 효율성을 보인다.6</p>
<p><strong>표 3. 추론 속도 및 지연 시간 비교</strong></p>
<table><thead><tr><th><strong>모델 (Method)</strong></th><th><strong>백본 (Backbone)</strong></th><th><strong>지연 시간 (Latency)</strong></th><th><strong>대략적 FPS</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td>UniAD</td><td>ResNet34</td><td>555.6 ms</td><td>~1.8 FPS</td><td>직렬 모듈 구조로 인한 지연</td></tr>
<tr><td>TransFuser</td><td>ResNet34</td><td>221.2 ms</td><td>~4.5 FPS</td><td></td></tr>
<tr><td><strong>Hydra-MDP++</strong></td><td><strong>ResNet34</strong></td><td><strong>206.2 ms</strong></td><td><strong>~4.8 FPS</strong></td><td><strong>가장 빠른 응답 속도</strong></td></tr>
<tr><td><strong>Hydra-MDP++</strong></td><td><strong>V2-99</strong></td><td><strong>271.0 ms</strong></td><td><strong>~3.7 FPS</strong></td><td>대형 백본 사용 시에도 준수한 속도</td></tr>
</tbody></table>
<ul>
<li><strong>효율성:</strong> Hydra-MDP++는 UniAD 대비 2배 이상 빠른 추론 속도를 보인다. UniAD가 점유(Occupancy), 모션 예측(Motion Prediction) 등을 직렬로 연결하여 계산하는 반면, Hydra-MDP는 병렬적인 궤적 스코어링 구조를 택했기 때문이다.</li>
<li><strong>실시간성:</strong> 약 200ms의 지연 시간은 약 5 FPS에 해당한다. 이는 고속 주행을 위한 10Hz(100ms) 제어 주기에는 다소 미치지 못할 수 있으나, 해당 수치는 최적화(TensorRT, FP16 등)를 거치지 않은 연구용 코드(PyTorch) 기준일 가능성이 높다. NVIDIA의 H100/H200 등 최신 하드웨어 가속 및 엔지니어링 최적화를 거친다면 상용화 가능한 수준의 10Hz 이상 구동이 충분히 가능할 것으로 판단된다.10</li>
</ul>
<h3>4.3  절제 연구 (Ablation Study) 결과: 각 구성 요소의 기여도</h3>
<p>Hydra-MDP의 성능 향상이 어디서 기인했는지 확인하기 위한 실험 결과는 다음과 같다.1</p>
<ol>
<li><strong>규칙 기반 교사의 부재:</strong> 규칙 기반 교사(NC, DAC 등) 없이 인간 모방(Imitation)만 학습했을 때, PDMS 점수는 현저히 낮았다. 특히 충돌율이 높았는데, 이는 인간 데이터만으로는 안전 제약을 학습하기 어렵다는 가설을 뒷받침한다.</li>
<li><strong>다중 모달성의 중요성:</strong> 단일 궤적(Single-mode)을 예측하는 것보다 궤적 어휘(Vocabulary)를 활용한 다중 모달(Multi-modal) 평가 방식이 복잡한 교차로 등에서 월등한 성능을 보였다. 4,096개 궤적 어휘보다 8,192개를 사용했을 때 미세한 성능 향상이 있었으나, 계산 비용 대비 효율을 고려해 4,096개가 주로 사용된다.3</li>
<li><strong>지표의 누적 효과:</strong> NC(충돌) 교사만 추가했을 때보다, DAC, TTC, EP 등을 순차적으로 추가할수록 종합 점수가 계단식으로 상승했다. 이는 각 교사가 상호 보완적인 주행 지식을 제공함을 의미한다.</li>
</ol>
<h2>5.  발전과 확장: Hydra-NeXt 및 폐쇄형 루프(Closed-Loop) 제어로의 진화</h2>
<p>Hydra-MDP의 성공은 개방형 루프 평가(NAVSIM)에서의 성과였으나, 실제 자율주행은 에이전트의 행동이 환경에 영향을 미치는 폐쇄형 루프(Closed-Loop) 환경이다. 이를 보완하기 위해 최근 NVIDIA 연구진은 <strong>Hydra-NeXt</strong>를 제안했다.11</p>
<h3>5.1  Hydra-NeXt의 주요 개선점 및 Hydra-MDP와의 관계</h3>
<p>Hydra-NeXt는 Hydra-MDP의 “평가 기반 계획” 철학을 계승하면서도, 실시간 제어(Control) 및 동적 환경 대응 능력을 강화했다.</p>
<ol>
<li><strong>제어(Control) 신호 통합:</strong> Hydra-MDP가 궤적(Trajectory, 위치 좌표의 나열)을 출력했다면, Hydra-NeXt는 제어 신호(가속도, 조향각, 조향 변화율 등)를 직접 예측하거나 궤적을 제어 신호로 변환하여 동역학적 실현 가능성(Feasibility)을 높였다.</li>
<li><strong>동적 궤적 생성 (Dynamic Generation):</strong> 고정된 궤적 어휘(Vocabulary)는 정형화된 상황에서는 효율적이나, 급작스러운 끼어들기 등 고도로 동적인 상황에는 유연성이 부족할 수 있다. Hydra-NeXt는 확산 모델(Diffusion Policy) 등을 활용해 상황에 맞는 궤적 후보를 동적으로 생성하고, 이를 Hydra-MDP 스타일의 스코어러(Scorer)로 평가하는 방식을 도입했다.12</li>
<li><strong>폐쇄형 루프 벤치마크 성과:</strong> CARLA v2 기반의 <strong>Bench2Drive</strong> 벤치마크에서 Hydra-NeXt는 기존 SOTA 모델인 DriveAdapter 등을 제치고 **DS(Driving Score) 기준 +22.9점, SR(Success Rate) 기준 +17.5%**라는 압도적인 격차로 1위를 차지했다.11 이는 Hydra-MDP에서 시작된 “규칙 증류” 접근법이 단순한 정적 데이터셋 평가를 넘어, 동적인 시뮬레이션 및 실제 주행 환경에서도 매우 강력함을 입증하는 중요한 이정표다.</li>
</ol>
<h2>6.  종합 논의 및 시사점</h2>
<h3>6.1  “그레이 박스(Grey-Box)” 접근법의 승리와 해석 가능성</h3>
<p>Hydra-MDP의 가장 큰 의의는 완전한 블랙박스(Neural)와 화이트박스(Rule-based) 사이의 이상적인 균형점, 즉 “그레이 박스” 접근법을 성공적으로 구현했다는 것이다.</p>
<ul>
<li><strong>해석 가능성(Interpretability):</strong> 기존 E2E 모델은 왜 그런 판단을 했는지 알 수 없었다. 반면 Hydra-MDP는 모델이 선택한 궤적이 “NC 점수가 높고(안전하고), EP 점수가 높아서(빨라서)” 선택되었음을 역추적할 수 있다. 각 헤드(Head)의 예측값을 통해 모델이 특정 경로를 위험하다고 판단했는지, 아니면 단순히 법규 위반으로 판단했는지 분석이 가능하다.</li>
<li><strong>안전성 주입(Safety Injection):</strong> 데이터에 내재된 편향(Bias)이나 희귀한 사고 케이스의 부재를 명시적인 규칙(Rule) 증류로 보완했다. 이는 “데이터만 많으면 해결된다“는 무조건적인 스케일링 법칙(Scaling Law)의 한계를 알고리즘적으로 보완한 훌륭한 사례다.</li>
</ul>
<h3>6.2  시뮬레이션 의존성과 Sim-to-Real 격차</h3>
<p>Hydra-MDP의 성능은 본질적으로 “교사” 역할을 하는 시뮬레이터와 규칙(Metric)의 품질에 종속된다.1 만약 시뮬레이터가 현실의 물리 현상(마찰력 변화, 센서 노이즈, 날씨 등)을 완벽히 반영하지 못한다면, 모델은 시뮬레이터의 허점(Artifact)에 과적합(Overfitting)될 위험이 있다. 저자들은 이를 인지하고 NAVSIM과 같은 고정밀 로그 리플레이(Log-replay) 시뮬레이션을 사용했으나, 여전히 존재하는 Sim-to-Real 격차를 줄이기 위해 향후에는 실제 주행 데이터에서 비지도(Unsupervised) 방식으로 안전 규칙을 학습하거나, 더욱 고도화된 뉴럴 시뮬레이터(Neural Simulator)를 활용하는 연구가 필요할 것이다.</p>
<h3>6.3  계산 효율성과 상용화 가능성</h3>
<p>ResNet-34 기반 모델이 보여준 높은 효율성은 제한된 컴퓨팅 파워를 가진 엣지 디바이스나 양산형 차량에의 탑재 가능성을 시사한다. 다만, 궤적 어휘의 크기(4,096개 ~ 16,384개)가 커질수록 평가 비용이 선형적으로 증가하므로, <strong>GTRS(Generalized Trajectory Scoring)</strong> 12와 같이 상황에 따라 궤적 후보군을 동적으로 가지치기(Pruning)하거나 중요도를 샘플링하는 기술과의 결합이 필수적일 것이다. 또한, 코드 공개(GitHub: NVlabs/Hydra-MDP)를 통해 연구 커뮤니티의 접근성을 높인 점은 해당 기술의 발전 속도를 가속화할 것으로 기대된다.9</p>
<h2>7.  결론</h2>
<p>Hydra-MDP와 그 후속 연구들은 엔드투엔드 자율주행 연구의 흐름을 “단순 모방(Imitating)“에서 “이해 기반 계획(Planning with Understanding)“으로 전환시켰다. 인간의 직관(Human Prior)과 기계의 규칙(Rule Prior)을 지식 증류(Knowledge Distillation)라는 틀 안에서 우아하게 결합함으로써, 데이터 기반 방식이 가질 수 있는 태생적인 안전성 결함을 구조적으로 해결하려 시도했다.</p>
<p>이 프레임워크는 <strong>1) 다중 목표 최적화를 위한 확장 가능한 하이드라 헤드 구조</strong>, <strong>2) 시뮬레이션 지식을 활용한 인과적 결과 학습</strong>, <strong>3) 경량 백본으로 달성한 SOTA 성능 및 효율성</strong>이라는 세 가지 핵심 기여를 통해 자율주행 상용화를 위한 실질적이고 구체적인 해법을 제시한다. 향후 연구는 이러한 평가 기반 계획(Scoring-based Planning)을 더욱 동적인 환경(실도로 주행)으로 확장하고, 시뮬레이션 의존성을 줄이거나 시뮬레이터 자체를 고도화하는 방향으로 전개될 것으로 전망된다. Hydra-MDP는 단순한 하나의 모델이 아니라, 머신러닝과 고전적 로보틱스 제어 이론을 융합하는 강력한 방법론적 프레임워크로서 자율주행 기술의 새로운 표준을 제시하고 있다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>HYDRA-MDP++: ADVANCING END-TO-END DRIV- - OpenReview, https://openreview.net/pdf?id=5xfAcRHfgP</li>
<li>End-to-End Driving at Scale with Hydra-MDP | NVIDIA Technical Blog, https://developer.nvidia.com/blog/end-to-end-driving-at-scale-with-hydra-mdp/</li>
<li>End-to-end Multimodal Planning with Multi-target Hydra-Distillation, <a href="https://opendrivelab.github.io/Challenge%202024/e2e_Team%20NVIDIA.pdf">https://opendrivelab.github.io/Challenge%202024/e2e_Team%20NVIDIA.pdf</a></li>
<li>NAVSIM: Data-Driven Non-Reactive Autonomous Vehicle …, https://papers.nips.cc/paper_files/paper/2024/file/32768f7faf1995026ef9821c696f3404-Paper-Datasets_and_Benchmarks_Track.pdf</li>
<li>Hydra-MDP++: Advancing End-to-End Driving via Expert-Guided …, https://chatpaper.com/chatpaper/paper/121520</li>
<li>Advancing End-to-End Driving via Expert-Guided Hydra-Distillation, https://arxiv.org/html/2503.12820v1</li>
<li>Hydra-MDP: End-to-end Multimodal Planning with Multi-target Hydra …, https://arxiv.org/html/2406.06978v3</li>
<li>Pseudo-Simulation for Autonomous Driving - Wei Cao, https://vveicao.github.io/projects/NavsimV2/Cao2025_supp.pdf</li>
<li>NVlabs/Hydra-MDP - GitHub, https://github.com/NVlabs/Hydra-MDP</li>
<li>Optimize AI Inference Performance with NVIDIA Full-Stack Solutions, https://developer.nvidia.com/blog/optimize-ai-inference-performance-with-nvidia-full-stack-solutions/</li>
<li>Hydra-NeXt: Robust Closed-Loop Driving with Open-Loop Training, https://arxiv.org/html/2503.12030v1</li>
<li>Generalized Trajectory Scoring For End-To-End Multimodal Planning, https://www.scribd.com/document/939034845/Generalized-Trajectory-Scoring-for-End-To-End-Multimodal-Planning</li>
<li>Generalized Trajectory Scoring for End-to-end Multimodal Planning, https://opendrivelab.github.io/challenge2025/E2E_NVIDIA.pdf</li>
<li>Hydra-NeXt: Robust Closed-Loop Driving with Open-Loop Training, https://arxiv.org/html/2503.12030v2</li>
<li>Hydra-MDP++: Advancing End-to-End Driving via Hydra-Distillation…, https://openreview.net/forum?id=5xfAcRHfgP</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>