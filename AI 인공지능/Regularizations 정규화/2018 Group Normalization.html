<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:그룹 정규화 (Group Normalization, 2018)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>그룹 정규화 (Group Normalization, 2018)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">정규화 (Regularizations)</a> / <span>그룹 정규화 (Group Normalization, 2018)</span></nav>
                </div>
            </header>
            <article>
                <h1>그룹 정규화 (Group Normalization, 2018)</h1>
<h2>1.  심층 신경망에서의 정규화의 필요성</h2>
<p>심층 신경망(Deep Neural Networks, DNNs)의 발전은 다양한 분야에서 전례 없는 성공을 이끌었으나, 네트워크의 깊이가 증가함에 따라 학습 과정의 불안정성이라는 근본적인 문제에 직면했다. 이러한 불안정성의 핵심 원인 중 하나로 지목된 것이 바로 ‘내부 공변량 변화(Internal Covariate Shift, ICS)’ 현상이다.1 ICS는 신경망의 각 층이 학습을 거치면서 이전 층의 파라미터가 계속 업데이트됨에 따라, 현재 층의 입력 데이터 분포가 훈련 과정 내내 지속적으로 변화하는 현상을 의미한다. 이 현상은 마치 끊임없이 움직이는 과녁을 맞추려는 것과 같아서, 모델이 안정적으로 수렴하는 것을 방해하고 학습 속도를 현저히 저하시킨다. 더 나아가, ICS는 경사도 소실(vanishing gradients) 또는 폭주(exploding gradients) 문제와 밀접하게 연관되어 있으며, 이는 학습률(learning rate)과 같은 중요한 하이퍼파라미터의 선택을 매우 민감하고 어렵게 만들어 최적화 과정을 복잡하게 만든다.3</p>
<p>이러한 문제를 해결하기 위한 핵심적인 접근법이 바로 ’정규화(Normalization)’이다. 정규화 계층은 각 층의 입력(활성화 값) 분포를 평균이 0, 분산이 1에 가깝도록 일정하게 재조정함으로써 ICS를 완화하는 역할을 수행한다.5 입력 분포가 안정화되면 손실 함수의 지형(optimization landscape)이 훨씬 더 평탄해지는 효과를 가져온다. 이는 경사도(gradient)의 움직임을 더 예측 가능하고 안정적으로 만들어, 결과적으로 더 높은 학습률을 사용해도 모델이 안정적으로 수렴할 수 있게 하여 학습 과정을 가속한다.7</p>
<p>2015년 Ioffe와 Szegedy에 의해 제안된 배치 정규화(Batch Normalization, BN)는 이러한 정규화의 개념을 미니배치(mini-batch) 단위로 적용하여 딥러닝 분야에 혁신을 가져왔다.9 BN은 ICS를 효과적으로 제어함으로써 이전에는 학습이 어려웠던 매우 깊은 신경망의 훈련을 가능하게 한 이정표적인 기술로 평가받는다.10 BN의 도입은 단순히 훈련 속도를 향상하고 모델의 초기값 민감도를 줄이는 것을 넘어, 일종의 정규화(regularization) 효과를 부수적으로 제공하여 모델의 일반화 성능을 높이는 데에도 기여했다.1</p>
<p>배치 정규화의 성공은 두 가지 상호 연결된 역할에서 기인한다. 첫째는 최적화 관점에서의 역할로, 앞서 언급한 ICS 완화를 통해 학습을 안정화하고 가속하는 것이다. 둘째는 정규화 관점에서의 역할이다. BN은 훈련 과정에서 무작위로 샘플링된 미니배치의 통계량(평균, 분산)을 사용하는데, 이 통계량 자체에 내재된 확률적 변동성(stochasticity)이 일종의 노이즈로 작용한다.9 즉, 동일한 입력 데이터라 할지라도 어떤 미니배치에 속하는지에 따라 정규화된 결과값이 미세하게 달라지게 되며, 이러한 미세한 변동이 모델이 훈련 데이터에 과적합(overfitting)되는 것을 방지하는 정규화 효과를 낳는 것이다. 이처럼 BN은 최적화 안정성과 정규화 효과라는 두 가지 이점을 동시에 제공하며 심층 신경망의 필수 구성 요소로 자리 잡았다. 그러나 이 강력한 기법의 근간을 이루는 ’미니배치 통계량’이 오히려 BN의 치명적인 약점이 되는 상황이 존재하며, 이는 새로운 정규화 기법의 등장을 촉발하는 계기가 되었다.</p>
<h2>2.  배치 정규화의 근본적 한계: 배치 크기 의존성</h2>
<p>배치 정규화의 막대한 성공에도 불구하고, 그 작동 방식의 핵심에 내재된 근본적인 한계가 존재한다. 바로 ’배치 크기 의존성(batch size dependency)’이다. 이 문제는 BN의 효과가 미니배치의 통계량이 전체 훈련 데이터셋의 통계량을 얼마나 잘 대표하는지에 달려 있다는 점에서 비롯된다.9</p>
<h3>2.1 배치 통계량 추정의 부정확성</h3>
<p>배치 크기가 충분히 클 경우(예: GPU 워커당 32 이상), 미니배치의 평균과 분산은 전체 데이터 분포의 신뢰할 만한 추정치로 기능한다.9 그러나 배치 크기가 작아지면, 소수의 샘플로부터 계산된 통계량은 매우 불안정해지고 노이즈가 심해져 전체 데이터 분포를 정확하게 반영하지 못하게 된다.14 이렇게 부정확한 통계량으로 정규화를 수행하면 오히려 모델 학습에 해로운 영향을 미치며, 이는 모델의 오차율을 급격히 증가시키는 결과로 이어진다. 일례로, ImageNet 데이터셋으로 ResNet-50을 훈련할 때 배치 크기를 2로 줄이면 BN의 성능이 심각하게 저하되는 것이 실험적으로 명확히 확인되었으며 9, 이는 BN의 ’더러운 작은 비밀(dirty little secret)’로 지적되기도 한다.16</p>
<h3>2.2 메모리 제약이 큰 과제에서의 적용 한계</h3>
<p>이러한 배치 크기 의존성은 특히 현대 컴퓨터 비전의 핵심 과제들에서 심각한 문제로 대두된다. 객체 탐지, 의미론적 분할, 비디오 분류와 같은 과제들은 고해상도 이미지를 입력으로 사용하고, 이를 처리하기 위한 모델 아키텍처 또한 매우 크고 복잡하다.12 모델의 복잡성과 고해상도 입력은 막대한 GPU 메모리를 요구하며, 이는 필연적으로 한 번에 처리할 수 있는 샘플의 수, 즉 배치 크기를 극단적으로 제한하게 만든다. 실제로 이러한 분야에서는 배치 크기를 1 또는 2로 설정하는 것이 일반적이다.9 이처럼 작은 배치 크기 환경에서는 BN이 제 성능을 발휘할 수 없기 때문에, 실질적으로 BN의 적용이 불가능해지는 문제가 발생한다.</p>
<p>이러한 현상은 모델 아키텍처의 발전이 역설적으로 기존의 핵심 기술을 무력화시키는 인과 관계를 형성한다. 더 높은 성능을 달성하기 위해 모델이 더 크고 정교해질수록(예: Mask R-CNN) 9, 메모리 사용량은 필연적으로 증가한다. 제한된 하드웨어 자원 하에서 이는 배치 크기의 감소를 강제하며 9, 이는 BN이 의존하는 ’배치 통계량의 신뢰성’이라는 근본적인 가정을 무너뜨린다.10 결국, 모델 성능 향상을 위한 아키텍처의 발전이 오히려 학습 안정화를 위한 핵심 구성 요소인 BN의 성능 붕괴를 초래하는 것이다. 이는 기존의 정규화 방식으로는 더 이상 진보하는 모델 아키텍처를 뒷받침할 수 없음을 시사하며, 배치 크기로부터 자유로운 새로운 정규화 패러다임의 필요성을 제기했다.</p>
<h3>2.3 추론(Inference) 시의 불일치</h3>
<p>배치 크기 의존성 외에도, BN은 훈련과 추론 단계에서의 동작 방식이 다르다는 문제를 안고 있다. 훈련 시에는 현재 미니배치의 통계량을 사용하지만, 추론 시에는 단일 샘플을 처리하는 경우가 많아 배치의 개념이 없다. 따라서 BN은 훈련 과정 동안 전체 데이터의 통계량을 근사하기 위해 이동 평균(running average) 방식으로 계산해 둔 고정된 전역 통계량(global statistics)을 추론에 사용한다.9 이러한 방식은 훈련 시의 동작과 추론 시의 동작 간에 불일치를 야기하며, 만약 훈련 데이터의 분포와 실제 추론 환경의 데이터 분포가 다를 경우(domain shift) 모델 성능 저하의 원인이 될 수 있다.</p>
<h2>3.  그룹 정규화(Group Normalization)의 제안</h2>
<p>배치 정규화가 가진 배치 크기 의존성이라는 명백한 한계를 극복하기 위해, 2018년 Yuxin Wu와 Kaiming He는 그룹 정규화(Group Normalization, GN)라는 새로운 대안을 제시했다.12 GN은 정규화를 위한 통계량 계산을 배치 차원에서 완전히 분리하여, 각 데이터 샘플 내부에서 독립적으로 수행하는 혁신적인 접근법을 취한다.</p>
<h3>3.1  개념적 프레임워크</h3>
<p>그룹 정규화의 핵심 아이디어는 채널(channel) 차원을 여러 개의 그룹(group)으로 분할하고, 각 그룹 내에서만 평균과 분산을 계산하여 정규화를 수행하는 것이다.9 예를 들어, 64개의 채널을 가진 특징 맵이 있다면, 이를 8개의 그룹으로 나누어 각 그룹이 8개의 채널을 갖도록 구성할 수 있다. 정규화는 이 8개의 채널과 공간 차원(H, W)에 걸쳐서, 각 샘플별로 독립적으로 이루어진다. 이 계산은 오직 단일 샘플 내에서만 이루어지므로 배치 크기가 1이든 100이든 결과에 아무런 영향을 미치지 않는다. 따라서 GN은 배치 크기와 무관하게 항상 일관된 방식으로 동작한다.11</p>
<p>이러한 그룹 단위의 특징 처리 및 정규화 아이디어는 새로운 것이 아니라, SIFT(Scale-Invariant Feature Transform)나 HOG(Histogram of Oriented Gradients)와 같은 고전 컴퓨터 비전 특징 기술에서 영감을 받았다.9 예를 들어, HOG 특징 기술자는 이미지를 여러 개의 작은 셀(cell)로 나누고, 각 셀 내부의 픽셀들에 대한 그래디언트 방향 히스토그램을 계산한다. 이후, 여러 셀을 묶어 하나의 블록(block)을 형성하고, 이 블록 단위로 히스토그램을 정규화하여 조명 변화에 강건한 특징을 추출한다. 이처럼, 특징들을 의미 있는 단위(그룹)로 묶어 지역적으로 정규화하는 방식은 이미 그 효과성이 입증된 바 있으며, GN은 이러한 개념을 심층 신경망의 채널 차원에 현대적으로 적용한 것이라 할 수 있다.</p>
<h3>3.2  수학적 공식화</h3>
<p>그룹 정규화의 연산 과정을 수학적으로 정의하면 다음과 같다. 먼저, 심층 신경망의 한 계층을 통과한 4차원 특징 텐서 <span class="math math-inline">x</span>를 (N, C, H, W) 형태로 가정한다. 여기서 N은 배치 축, C는 채널 축, H와 W는 각각 공간적 높이와 너비를 나타낸다.20</p>
<p><strong>1. 픽셀 집합의 정의</strong>: GN은 특정 샘플의 특정 채널 그룹에 속하는 모든 픽셀들을 하나의 집합으로 간주하고, 이 집합에 대해 통계량을 계산한다. 텐서 내 임의의 픽셀 <span class="math math-inline">i</span>의 인덱스를 <span class="math math-inline">i = (i_N, i_C, i_H, i_W)</span>라고 할 때, 이 픽셀과 함께 정규화될 픽셀들의 집합 <span class="math math-inline">S_i</span>는 다음과 같이 정의된다.24<br />
<span class="math math-display">
S_i = \{ k \mid k_N = i_N, \lfloor \frac{k_C}{C/G} \rfloor = \lfloor \frac{i_C}{C/G} \rfloor \}
</span><br />
위 식에서 <span class="math math-inline">G</span>는 사용자가 지정하는 하이퍼파라미터인 그룹의 수를 의미하며, <span class="math math-inline">C/G</span>는 각 그룹에 속하는 채널의 수가 된다. 이 정의는 두 가지 조건을 명시한다. 첫째, <span class="math math-inline">k_N = i_N</span>은 정규화가 동일한 데이터 샘플 내에서만 이루어짐을 의미한다. 둘째, <span class="math math-inline">\lfloor k_C / (C/G) \rfloor = \lfloor i_C / (C/G) \rfloor</span>$$는 동일한 채널 그룹에 속하는 픽셀들만을 고려함을 의미한다. 즉, 집합 <span class="math math-inline">S_i</span>는 <span class="math math-inline">i_N</span>번째 샘플의 특정 채널 그룹에 속하는 모든 공간적 위치(H, W)의 픽셀들을 포함한다.</p>
<p><strong>2. 평균과 분산 계산</strong>: 위에서 정의된 집합 <span class="math math-inline">S_i</span>에 속하는 픽셀 값들에 대해 평균(<span class="math math-inline">\mu_i</span>)과 분산(<span class="math math-inline">\sigma_i^2</span>)을 계산한다. 여기서 <span class="math math-inline">m</span>은 집합 <span class="math math-inline">S_i</span>의 크기, 즉 <span class="math math-inline">(C/G) * H * W</span>이다.20<br />
<span class="math math-display">
\mu_i = \frac{1}{m} \sum_{k \in S_i} x_k
</span></p>
<p><span class="math math-display">
\sigma_i^2 = \frac{1}{m} \sum_{k \in S_i} (x_k - \mu_i)^2 + \epsilon
</span></p>
<p>여기서 <span class="math math-inline">\epsilon</span>은 분산이 0이 되어 0으로 나누는 경우를 방지하기 위해 더해주는 매우 작은 양의 상수(epsilon)이다.</p>
<p><strong>3. 정규화</strong>: 계산된 평균과 분산을 사용하여 각 픽셀 값 <span class="math math-inline">x_i</span>를 정규화한다.<br />
<span class="math math-display">
\hat{x}_i = \frac{x_i - \mu_i}{\sqrt{\sigma_i^2}}
</span><br />
<strong>4. 아핀 변환(Affine Transformation)</strong>: 마지막으로, 배치 정규화와 마찬가지로 정규화 과정에서 손실될 수 있는 데이터의 표현력을 복원하기 위해, 학습 가능한 파라미터인 스케일(<span class="math math-inline">\gamma</span>)과 시프트(<span class="math math-inline">\beta</span>)를 적용한다. 이 파라미터들은 일반적으로 채널별로 학습되지만, GN에서는 그룹별로 공유될 수도 있다.11<br />
<span class="math math-display">
y_i = \gamma \hat{x}_i + \beta
</span><br />
이러한 일련의 과정을 통해 그룹 정규화는 배치 크기에 의존하지 않으면서도 효과적으로 특징 맵을 정규화한다.</p>
<h2>IV. 정규화 기법 비교 분석</h2>
<p>그룹 정규화의 독창성과 효과를 명확히 이해하기 위해서는 다른 주요 정규화 기법들과의 비교 분석이 필수적이다. 배치 정규화(BN), 레이어 정규화(LN), 인스턴스 정규화(IN)는 모두 동일한 목표를 추구하지만, 그 방식과 가정에서 근본적인 차이를 보인다.</p>
<h3>A. 차원적 관점에서의 비교</h3>
<p>정규화 기법들의 가장 근본적인 차이는 4차원 특징 텐서(N, C, H, W)의 어떤 차원들을 하나의 단위로 묶어 통계량을 계산하느냐에 있다.3</p>
<ul>
<li><strong>배치 정규화 (BN)</strong>: 각 채널(<span class="math math-inline">C</span>)을 기준으로, 배치(<span class="math math-inline">N</span>) 및 공간(<span class="math math-inline">H</span>, <span class="math math-inline">W</span>) 차원에 걸쳐 있는 모든 픽셀들을 하나의 그룹으로 묶어 정규화한다. 즉, 통계량 계산 단위는 (N, H, W)가 된다.3</li>
<li><strong>레이어 정규화 (LN)</strong>: 각 데이터 샘플(<span class="math math-inline">N</span>)을 기준으로, 모든 채널(<span class="math math-inline">C</span>)과 공간(<span class="math math-inline">H</span>, <span class="math math-inline">W</span>) 차원에 걸쳐 있는 픽셀들을 하나의 그룹으로 묶는다. 통계량 계산 단위는 (C, H, W)이다.3</li>
<li><strong>인스턴스 정규화 (IN)</strong>: 가장 작은 단위를 사용하며, 각 샘플(<span class="math math-inline">N</span>)과 각 채널(<span class="math math-inline">C</span>)에 대해 독립적으로 공간(<span class="math math-inline">H</span>, <span class="math math-inline">W</span>) 차원의 픽셀들만으로 통계량을 계산한다. 통계량 계산 단위는 (H, W)이다.3</li>
<li><strong>그룹 정규화 (GN)</strong>: LN과 IN의 중간적 형태를 띤다. 각 샘플(<span class="math math-inline">N</span>)을 기준으로 하되, 채널(<span class="math math-inline">C</span>)을 <span class="math math-inline">G</span>개의 그룹으로 나눈다. 그리고 각 그룹(<span class="math math-inline">C/G</span>)과 공간(<span class="math math-inline">H</span>, <span class="math math-inline">W</span>) 차원에 걸쳐 있는 픽셀들을 하나의 단위로 묶어 정규화한다. 통계량 계산 단위는 ((C/G), H, W)가 된다.3</li>
</ul>
<p>이러한 차이점을 종합하면 다음 표와 같다.</p>
<table><thead><tr><th>특징 (Feature)</th><th>배치 정규화 (Batch Normalization)</th><th>레이어 정규화 (Layer Normalization)</th><th>인스턴스 정규화 (Instance Normalization)</th><th>그룹 정규화 (Group Normalization)</th></tr></thead><tbody>
<tr><td><strong>정규화 차원</strong></td><td>각 채널에 대해 (N, H, W)</td><td>각 샘플에 대해 (C, H, W)</td><td>각 샘플, 각 채널에 대해 (H, W)</td><td>각 샘플, 각 그룹에 대해 ((C/G), H, W)</td></tr>
<tr><td><strong>배치 크기 의존성</strong></td><td><strong>높음 (High)</strong></td><td>없음 (None)</td><td>없음 (None)</td><td><strong>없음 (None)</strong></td></tr>
<tr><td><strong>핵심 장점</strong></td><td>큰 배치 크기에서 높은 성능, 정규화 효과</td><td>배치 크기 무관, 순차 데이터(RNN/Transformer)에 효과적</td><td>배치 크기 무관, 스타일 정보 보존에 유리</td><td><strong>배치 크기 무관</strong>, 작은 배치에서도 안정적인 성능</td></tr>
<tr><td><strong>핵심 단점</strong></td><td>작은 배치 크기에서 성능 급감, 추론 시 별도 통계량 필요</td><td>CNN에서의 성능이 BN/GN보다 떨어질 수 있음</td><td>채널 간의 상호작용 무시</td><td>큰 배치 크기에서 BN보다 성능이 다소 낮을 수 있음</td></tr>
<tr><td><strong>주요 적용 분야</strong></td><td>이미지 분류 (큰 배치)</td><td>자연어 처리 (RNN, Transformer)</td><td>스타일 전이, 이미지 생성 (GAN)</td><td><strong>객체 탐지, 분할, 비디오, 생성 모델 (작은 배치)</strong></td></tr>
</tbody></table>
<h3>B. 성능 및 특성 비교</h3>
<p>정규화 기법의 선택은 단순한 기술적 최적화를 넘어, 모델에 특정 귀납적 편향(inductive bias)을 부여하는 구조적 결정이다. 각 기법은 어떤 특징들이 통계적 속성을 공유해야 하는지에 대한 서로 다른 가정을 내포하고 있다.</p>
<ul>
<li><strong>배치 정규화의 편향</strong>: BN은 “서로 다른 이미지(배치 내)에 있더라도 동일한 채널 인덱스에 위치한 특징들은 유사한 분포를 가질 것이다“라고 가정한다. 이는 CIFAR-10과 같이 객체가 중앙에 위치하고 유사한 구도를 가진 데이터셋의 분류 문제에서는 합리적일 수 있다. 그러나 다양한 객체와 배경이 혼재된 복잡한 장면에서는 이 가정이 깨지기 쉽다.</li>
<li><strong>레이어 정규화의 편향</strong>: LN은 “하나의 이미지 내에 존재하는 모든 특징들, 즉 저수준의 엣지 정보부터 고수준의 의미 정보까지 모두 함께 정규화되어야 한다“는 매우 강한 가정을 한다. 컨볼루션 신경망에서 각 채널은 매우 다른 종류의 특징(색상, 질감, 형태 등)을 나타내므로, 이들을 모두 동일한 분포로 묶는 것은 부자연스러울 수 있다. 이것이 LN이 종종 CNN에서 BN이나 GN보다 낮은 성능을 보이는 이유를 설명한다.10</li>
<li><strong>인스턴스 정규화의 편향</strong>: IN은 “이미지의 스타일 정보는 개별 특징 맵의 통계량에 담겨 있다“고 가정한다. 각 채널을 독립적으로 정규화함으로써 이러한 인스턴스별 통계 정보(스타일)를 제거하기 때문에, 스타일 전이(style transfer)와 같은 과제에서 매우 효과적이다.3</li>
<li><strong>그룹 정규화의 편향</strong>: GN은 “채널들은 통계적 속성을 공유하는 그룹들로 묶일 수 있다“는 더 유연하고 미묘한 편향을 도입한다. 예를 들어, 어떤 채널 그룹은 질감(texture)을 감지하는 데 특화되고, 다른 그룹은 형태(shape)를 감지하는 데 특화될 수 있다. 이러한 기능적 그룹 <em>내에서</em> 통계량을 공유하는 것은 합리적이지만, 그룹 <em>간에</em> 공유하는 것은 그렇지 않을 수 있다. 이처럼 GN은 LN의 ‘전부 아니면 전무’ 식의 강한 가정과 IN의 ’채널 간 상호작용 무시’라는 한계 사이에서 균형을 맞춘다. 따라서 GN의 성공은 단순히 배치 독립성 때문만이 아니라, CNN의 특징 공간에 더 적절한 구조적 사전 지식(structural prior)을 부여하기 때문으로 해석할 수 있다.</li>
</ul>
<p>추론 시의 계산 오버헤드 측면에서, BN은 미리 계산된 통계량을 사용하므로 추가 연산이 거의 없는 반면, GN, LN, IN은 추론 시에도 입력에 대해 직접 통계량을 계산해야 하므로 약간의 추가 비용이 발생할 수 있다.23 그러나 이 비용은 일반적으로 미미하며, 배치 독립성이라는 큰 이점에 비하면 감수할 만한 수준이다.</p>
<h2>V. 하이퍼파라미터 G의 역할과 영향</h2>
<p>그룹 정규화의 핵심적인 유연성은 하이퍼파라미터인 그룹의 수, <span class="math math-inline">G</span>에 의해 결정된다. <span class="math math-inline">G</span> 값을 어떻게 설정하느냐에 따라 GN의 동작 방식이 크게 달라지며, 이는 GN을 다른 정규화 기법들을 아우르는 일반화된 프레임워크로 볼 수 있게 한다.</p>
<h3>A. 레이어 및 인스턴스 정규화와의 관계</h3>
<p>그룹 수 <span class="math math-inline">G</span>는 GN을 LN과 IN 사이의 스펙트럼에 위치시키는 조절 장치 역할을 한다.14</p>
<ul>
<li><strong>G = 1일 때</strong>: 그룹의 수를 1로 설정하면, 이는 전체 채널(C)을 단 하나의 그룹으로 묶는 것과 같다. 이 경우, 정규화는 각 데이터 샘플의 모든 채널과 공간 차원에 걸쳐 수행되므로, 그 연산 방식은 **레이어 정규화(LN)**와 완벽하게 동일해진다.14</li>
<li><strong>G = C일 때</strong>: 그룹의 수를 전체 채널의 수(C)와 동일하게 설정하면, 각 그룹은 단 하나의 채널만을 포함하게 된다. 이 때 정규화는 각 샘플의 각 채널에 대해 독립적으로 공간 차원(H, W)에 대해서만 이루어지므로, 이는 **인스턴스 정규화(IN)**의 연산 방식과 정확히 일치한다.14</li>
</ul>
<p>이러한 관계는 GN이 단순한 단일 기법이 아니라, <span class="math math-inline">G</span> 값에 따라 그 성격이 변하는 유연한 정규화 메커니즘임을 보여준다. <span class="math math-inline">G</span>를 조절함으로써, 모델 설계자는 LN의 “모든 채널이 동등하게 기여한다“는 강한 가정과 IN의 “채널 간 상호작용을 완전히 무시한다“는 한계 사이에서 최적의 절충점을 탐색할 수 있는 능력을 갖게 된다.14</p>
<h3>B. 그룹 수 선택에 따른 성능 변화</h3>
<p>하이퍼파라미터 <span class="math math-inline">G</span>의 선택은 모델의 최종 성능에 직접적인 영향을 미친다. 원본 GN 논문에서는 ImageNet 데이터셋과 ResNet-50 아키텍처를 사용하여 <span class="math math-inline">G</span> 값에 대한 체계적인 제거 연구(Ablation Study)를 수행했으며, 그 결과는 <span class="math math-inline">G</span> 선택의 중요성을 명확히 보여준다.14</p>
<p>연구는 두 가지 방식으로 진행되었다. 첫 번째는 그룹의 수(<span class="math math-inline">G</span>)를 직접 바꿔가며 성능을 측정한 것이고, 두 번째는 그룹당 채널의 수(<span class="math math-inline">C/G</span>)를 고정시킨 채 성능을 측정한 것이다. 실험 결과, <span class="math math-inline">G</span>가 너무 작거나(LN에 가까워짐) 너무 클 때(IN에 가까워짐)보다 중간 정도의 값을 가질 때 성능이 가장 좋게 나타나는 U자형 곡선 형태의 경향을 보였다. 구체적으로, 그룹 수를 32로 설정했을 때 가장 낮은 검증 오류를 기록했으며, 그룹당 채널 수를 16개로 고정했을 때 역시 최상의 성능을 보였다.</p>
<p>이러한 실험 결과는 다음과 같은 실용적인 가이드라인을 제공한다. 대부분의 컴퓨터 비전 과제에서 <span class="math math-inline">G=32</span> 또는 그룹당 채널 수를 16~32개 사이로 설정하는 것이 좋은 시작점이 될 수 있다.14 그러나 이는 일반적인 권장 사항일 뿐, 최적의</p>
<p><span class="math math-inline">G</span> 값은 특정 모델 아키텍처의 각 계층별 채널 수, 그리고 해결하고자 하는 과제의 고유한 특성에 따라 달라질 수 있다. 따라서 최고의 성능을 위해서는 주어진 문제에 맞춰 <span class="math math-inline">G</span> 값을 튜닝하는 과정이 필요하다.26 또한, <code>num_channels</code>는 <code>num_groups</code>로 나누어 떨어져야 한다는 구현상의 제약 조건도 고려해야 한다.22</p>
<p>아래 표는 원본 논문에서 보고된 <span class="math math-inline">G</span> 값에 따른 ResNet-50의 ImageNet 검증 오류율을 요약한 것이다.</p>
<table><thead><tr><th>실험 설정 (Experiment Setting)</th><th>값 (Value)</th><th>ImageNet Top-1 검증 오류 (Validation Error)</th></tr></thead><tbody>
<tr><td><strong>그룹 수 (G) 고정</strong></td><td>G = 1 (LN)</td><td>24.5%</td></tr>
<tr><td></td><td>G = 2</td><td>23.3%</td></tr>
<tr><td></td><td>G = 4</td><td>22.8%</td></tr>
<tr><td></td><td>G = 8</td><td>22.4%</td></tr>
<tr><td></td><td>G = 16</td><td>22.3%</td></tr>
<tr><td></td><td><strong>G = 32</strong></td><td><strong>22.2%</strong></td></tr>
<tr><td></td><td>G = 64</td><td>22.4%</td></tr>
<tr><td></td><td>G = C (IN)</td><td>26.0%</td></tr>
<tr><td><strong>그룹당 채널 수 (C/G) 고정</strong></td><td>C/G = 1</td><td>25.1%</td></tr>
<tr><td></td><td>C/G = 4</td><td>23.2%</td></tr>
<tr><td></td><td><strong>C/G = 16</strong></td><td><strong>22.3%</strong></td></tr>
<tr><td></td><td>C/G = 32</td><td>22.4%</td></tr>
<tr><td></td><td>C/G = 64</td><td>22.6%</td></tr>
</tbody></table>
<h2>VI. 주요 적용 분야 및 실증적 성능</h2>
<p>그룹 정규화는 배치 크기 의존성 문제를 해결함으로써, 기존에 배치 정규화의 적용이 어려웠던 여러 딥러닝 분야에서 핵심적인 역할을 수행하게 되었다. 특히 메모리 사용량이 큰 컴퓨터 비전 과제와 최신 생성 모델에서 그 가치가 두드러진다.</p>
<h3>A. 주요 적용 분야</h3>
<ul>
<li><strong>객체 탐지 및 의미론적 분할</strong>: Faster R-CNN이나 Mask R-CNN과 같은 모델들은 고해상도 이미지를 처리하기 때문에 GPU 메모리 제약으로 인해 배치 크기를 1 또는 2와 같이 매우 작게 설정하는 것이 일반적이다. 이러한 환경에서 BN은 통계량 추정이 불가능하여 제 기능을 하지 못하므로, 보통 사전 훈련된 모델의 BN 파라미터를 ’동결(frozen)’시켜 선형 변환처럼 사용하는 편법을 쓴다.9 반면, GN은 배치 크기와 무관하게 동작하므로 이러한 제약 없이 자연스럽게 적용될 수 있으며, 결과적으로 BN 기반 모델보다 월등히 우수한 성능을 보인다.18 실제로 COCO와 같은 주요 벤치마크 데이터셋에서 GN을 사용한 모델이 BN 기반 모델의 성능을 능가하는 결과가 다수 보고되었다.10</li>
<li><strong>비디오 분류</strong>: 3D 컨볼루션을 사용하는 비디오 분류 모델은 이미지의 공간적 차원(H, W)에 시간적 차원(T)이 추가되어 특징 맵의 크기가 훨씬 커진다. 이로 인해 메모리 사용량이 막대하여 작은 배치를 사용할 수밖에 없으며, 이 분야에서도 GN은 BN의 강력하고 효과적인 대안으로 자리 잡았다.12 Kinetics 비디오 데이터셋을 이용한 실험에서도 GN의 우수성이 입증되었다.9</li>
<li><strong>생성 모델</strong>: 특히 Stable Diffusion과 같은 최신 확산 모델(Diffusion Models)에서 GN은 사실상의 표준 정규화 기법으로 채택되었다.23 생성 모델은 훈련 과정에서 매우 다양한 내용과 해상도의 이미지를 다루게 되며, 이로 인해 미니배치 내 데이터의 분포가 균일하지 않은(non-i.i.d.) 경우가 많다. 배치 통계량에 의존하는 BN은 이러한 환경에서 불안정한 학습을 초래할 수 있는 반면, 각 샘플을 독립적으로 처리하는 GN은 훨씬 더 안정적이고 우수한 일반화 성능을 제공한다.23</li>
</ul>
<h3>B. 벤치마크 성능 분석</h3>
<p>ImageNet 이미지 분류 벤치마크에서의 성능 비교는 GN의 특성을 명확하게 보여준다.</p>
<ul>
<li><strong>작은 배치 크기에서의 압도적 우위</strong>: ResNet-50 모델을 배치 크기 2라는 극단적으로 작은 설정으로 ImageNet에서 훈련했을 때, 그룹 정규화를 사용한 모델은 배치 정규화를 사용한 모델보다 10.6%나 낮은 Top-1 오류율을 기록했다.9 이는 작은 배치 크기에서 BN의 성능이 붕괴되는 반면 GN은 안정성을 유지함을 극명하게 보여주는 결과이다.</li>
<li><strong>일반적인 배치 크기에서의 대등한 성능</strong>: 배치 크기를 32와 같이 일반적인 수준으로 설정했을 때, GN의 성능은 BN과 거의 대등한 수준을 보였다 (오류율 차이 약 0.5%p). 이는 GN이 작은 배치뿐만 아니라 일반적인 훈련 환경에서도 BN을 충분히 대체할 수 있는 경쟁력을 갖추고 있음을 의미한다. 또한, 이 조건에서 GN은 다른 배치 독립적 정규화 기법인 LN이나 IN보다는 확연히 우수한 성능을 나타냈다.9</li>
<li><strong>큰 배치 크기에서의 경향</strong>: 배치 크기를 64, 128 등으로 매우 크게 설정할 경우, BN이 더 많은 샘플로부터 안정적인 통계량을 계산하고 강력한 정규화 효과를 발휘하여 GN보다 약간 더 나은 성능을 보이는 경향이 있다.11</li>
</ul>
<p>이러한 결과들은 그룹 정규화가 단순히 작은 배치를 위한 ’땜질 처방’이 아니라, 모델의 규모와 과제의 복잡성을 배치 크기의 제약으로부터 해방시키는 핵심적인 ’가능 기술(enabling technology)’임을 시사한다. 과거에는 모델 크기, 입력 해상도, 배치 크기 사이에 상충 관계가 존재했다. 한정된 GPU 메모리 안에서 모델 크기나 입력 해상도를 높이려면 배치 크기를 줄여야 했고, BN은 이 배치 크기가 특정 임계값 이하로 떨어지는 것을 허용하지 않았다.9 이로 인해 연구자들은 고해상도 분할 과제 등에서 더 작은 모델을 사용하거나 입력 해상도를 낮추는 타협을 해야만 했다. GN은 이러한 의존성을 끊어냄으로써 배치 크기를 트레이드오프 방정식에서 제거했다.12 이제 연구자들은 가용 메모리가 허용하는 한, 배치 크기가 단 1이 되더라도 모델 크기와 입력 해상도를 극한까지 끌어올릴 수 있게 되었다. 즉, GN의 진정한 영향력은 기존의 작은 배치 과제에서의 성능 향상을 넘어, BN의 제약 때문에 실용적이지 못했던 새로운 규모의 모델과 복잡한 과제에 도전할 수 있는 길을 열어준 데 있다.</p>
<h2>VII. 심층적 고찰 및 향후 연구 방향</h2>
<p>그룹 정규화는 실용적인 성공을 거두었을 뿐만 아니라, 딥러닝에서의 정규화 역할에 대한 더 깊은 이론적 고찰과 새로운 연구 방향을 제시했다.</p>
<h3>A. 최적화 지형에 미치는 영향</h3>
<p>배치 정규화의 성공 요인에 대한 초기 설명은 내부 공변량 변화(ICS) 감소에 초점을 맞추었으나, 후속 연구들은 더 근본적인 이유를 제시했다. Santurkar 등의 연구(2018)에 따르면, BN의 핵심적인 역할은 최적화 지형(optimization landscape)을 훨씬 더 평탄하게(smoother) 만드는 데 있다.8 손실 함수가 평탄하다는 것은 경사도(gradient)의 변화가 급격하지 않다는 것을 의미하며, 이는 경사도의 움직임을 더 안정적이고 예측 가능하게 만든다. 결과적으로, 학습 과정이 안정화되고 더 큰 학습률을 사용하여 더 빠르게 최적점에 수렴할 수 있게 된다.8 그룹 정규화 역시 배치에 의존하지 않는 방식으로 유사한 통계적 안정화 효과를 제공하므로, 최적화 지형을 평탄하게 만드는 데 유사하게 기여할 것으로 강하게 추론할 수 있다. 이는 GN이 작은 배치 크기라는 불안정한 조건에서도 안정적인 학습을 가능하게 하는 근본적인 메커니즘 중 하나로 이해될 수 있다.</p>
<h3>B. 그룹 정규화의 변형 및 개선 연구</h3>
<p>그룹 정규화는 많은 장점을 가지고 있지만 완벽하지는 않다. 가장 큰 한계점은 큰 배치 크기 환경에서 BN이 제공하는 강력한 정규화(regularization) 효과가 부족하여, BN에 비해 성능이 다소 떨어진다는 점이다.11 또한, 일부 연구에서는 GN이 외부 노이즈나 정규화로 인한 섭동(perturbation)에 BN보다 더 민감하게 반응하며, 학습 과정 전체가 아닌 특정 기간에만 긍정적인 영향을 미친다는 분석을 내놓기도 했다.30 이러한 한계를 극복하기 위해 GN의 장점(배치 독립성)과 BN의 장점(강력한 정규화 효과)을 결합하려는 시도들이 이루어지고 있다. 예를 들어, GN을 기본 구조로 하되, BN의 메커니즘을 일부 통합하여 배치 크기에 관계없이 일관되게 높은 성능을 내고 훈련을 더욱 안정화시키는 새로운 정규화 계층을 설계하는 연구가 진행되고 있다.30</p>
<h3>C. 실용적 선택을 위한 권장 사항</h3>
<p>다양한 정규화 기법의 존재는 모델 설계자에게 상황에 맞는 최적의 도구를 선택해야 하는 과제를 안겨준다. 각 기법의 특성을 고려한 실용적인 선택 가이드라인은 다음과 같다.</p>
<ul>
<li><strong>큰 배치 크기가 가능한 경우 (예: 이미지 분류)</strong>: 메모리 제약이 비교적 적어 32 이상의 큰 배치 크기를 안정적으로 사용할 수 있는 환경이라면, 여전히 **배치 정규화(BN)**가 강력한 성능과 부수적인 정규화 효과 덕분에 우선적으로 고려될 수 있다.11</li>
<li><strong>작거나 가변적인 배치 크기가 필수적인 경우 (예: 객체 탐지, 분할, 생성 모델)</strong>: 모델의 크기, 입력 데이터의 해상도, 또는 과제의 특성상 작은 배치(예: 1~8)나 가변적인 배치를 사용해야만 하는 상황이라면, **그룹 정규화(GN)**가 월등히 안정적이고 우수한 성능을 제공하는 최적의 선택이다.20</li>
<li><strong>순차 데이터 처리 (예: 자연어 처리)</strong>: RNN, LSTM, Transformer와 같이 입력 시퀀스의 길이가 가변적인 모델에서는 미니배치 내 샘플들의 길이를 통일하기 위해 패딩(padding)이 사용된다. 이 경우, 패딩된 부분까지 포함하여 통계량을 계산하는 BN은 적합하지 않다. 각 샘플을 독립적으로 처리하는 **레이어 정규화(LN)**가 이러한 순차 모델의 표준으로 자리 잡았다.20</li>
<li><strong>스타일 정보가 중요한 경우 (예: 스타일 전이)</strong>: 스타일 전이와 같은 생성 과제에서는 개별 이미지의 고유한 스타일(색감, 질감 등)을 나타내는 통계 정보를 보존하거나 조작하는 것이 매우 중요하다. 각 채널을 독립적으로 정규화하여 이러한 인스턴스별 정보를 분리해내는 **인스턴스 정규화(IN)**가 가장 적합하다.3</li>
</ul>
<h2>VIII. 결론</h2>
<p>그룹 정규화(Group Normalization, GN)는 심층 신경망 학습의 안정성을 위해 필수적이었던 배치 정규화(BN)의 치명적인 약점, 즉 ’배치 크기 의존성’을 성공적으로 해결한 혁신적인 기법이다. 채널을 의미 있는 단위로 그룹화하여 각 데이터 샘플 내부적으로 정규화를 수행하는 단순하면서도 강력한 아이디어는, 딥러닝 모델이 극단적으로 작은 배치 크기에서도 안정적으로 학습될 수 있는 새로운 길을 열었다.</p>
<p>이러한 특성 덕분에 GN은 특히 객체 탐지, 의미론적 분할, 비디오 분석과 같이 메모리 사용량이 커서 작은 배치가 불가피했던 컴퓨터 비전 분야에서 BN을 대체하는 표준적인 기법으로 빠르게 자리매김했다. 나아가, 그 유연성과 안정성은 확산 모델과 같은 최신 생성 모델 아키텍처에서도 핵심적인 구성 요소로 채택되는 결과를 낳았다. GN은 더 이상 특정 조건 하에서의 대안이 아니라, 현대의 복잡하고 거대한 딥러닝 모델을 가능하게 하는 필수 기술 중 하나가 되었다.</p>
<p>궁극적으로 그룹 정규화는 정규화 기법이 단순히 최적화를 돕는 부가적인 도구를 넘어, 모델의 구조적 특성과 데이터의 성질을 깊이 고려한 ’설계의 일부’임을 보여준 중요한 사례이다. 레이어 정규화와 인스턴스 정규화 사이의 스펙트럼을 보간하는 유연성을 통해, GN은 앞으로의 신경망 아키텍처 연구에서 특정 과제와 데이터에 더욱 최적화된 맞춤형 정규화 기법을 탐구하는 데 중요한 이론적, 실용적 기반을 지속적으로 제공할 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>Exploring the Efficacy of Group-Normalization in Deep Learning Models for Alzheimer’s Disease Classification - arXiv, 8월 26, 2025에 액세스, https://arxiv.org/pdf/2404.00946</li>
<li>Layer Normalization in Transformer | by Sachinsoni - Medium, 8월 26, 2025에 액세스, https://medium.com/@sachinsoni600517/layer-normalization-in-transformer-1a2efbff8b85</li>
<li>Normalization Strategies: Batch vs Layer vs Instance vs Group Norm - IsaacTheBlog, 8월 26, 2025에 액세스, https://isaac-the-man.dev/posts/normalization-strategies/</li>
<li>Batch normalization - Wikipedia, 8월 26, 2025에 액세스, https://en.wikipedia.org/wiki/Batch_normalization</li>
<li>The Different Types of Normalizations in Deep Learning | by DZ …, 8월 26, 2025에 액세스, https://dzdata.medium.com/the-different-types-of-normalizations-in-deep-learning-03eece7fa789</li>
<li>Using Normalization Layers to Improve Deep Learning Models - MachineLearningMastery.com, 8월 26, 2025에 액세스, https://machinelearningmastery.com/using-normalization-layers-to-improve-deep-learning-models/</li>
<li>Batch Normalization in Machine Vision: A Beginner’s Guide - UnitX, 8월 26, 2025에 액세스, https://www.unitxlabs.com/resources/batch-normalization-machine-vision-guide/</li>
<li>How Does Batch Normalization Help Optimization? - NIPS, 8월 26, 2025에 액세스, http://papers.neurips.cc/paper/7515-how-does-batch-normalization-help-optimization.pdf</li>
<li>Group Normalization - CVF Open Access, 8월 26, 2025에 액세스, https://openaccess.thecvf.com/content_ECCV_2018/papers/Yuxin_Wu_Group_Normalization_ECCV_2018_paper.pdf</li>
<li>arXiv:1803.08494v3 [cs.CV] 11 Jun 2018, 8월 26, 2025에 액세스, https://arxiv.org/pdf/1803.08494</li>
<li>Understanding and comparing Batch Norm with all different variations | by ai4prod - Medium, 8월 26, 2025에 액세스, https://ai4prod.medium.com/understanding-and-comparing-batch-norm-with-all-different-variations-366fae237217</li>
<li>[1803.08494] Group Normalization - ar5iv - arXiv, 8월 26, 2025에 액세스, https://ar5iv.labs.arxiv.org/html/1803.08494</li>
<li>[1803.08494] Group Normalization - arXiv, 8월 26, 2025에 액세스, https://arxiv.org/abs/1803.08494</li>
<li>Group Normalization - Aman Arora’s Blog, 8월 26, 2025에 액세스, https://amaarora.github.io/posts/2020-08-09-groupnorm.html</li>
<li>Batch normalization vs batch size - Data Science Stack Exchange, 8월 26, 2025에 액세스, https://datascience.stackexchange.com/questions/41873/batch-normalization-vs-batch-size</li>
<li>[D] Paper Explained - Group Normalization : r/MachineLearning - Reddit, 8월 26, 2025에 액세스, https://www.reddit.com/r/MachineLearning/comments/gibvs8/d_paper_explained_group_normalization/</li>
<li>Group Normalization (Paper Explained) - YouTube, 8월 26, 2025에 액세스, https://www.youtube.com/watch?v=l_3zj6HeWUE</li>
<li>Group Normalization - Meta Research, 8월 26, 2025에 액세스, https://research.facebook.com/publications/group-normalization/</li>
<li>Group Normalization | Research - AI at Meta, 8월 26, 2025에 액세스, https://ai.meta.com/research/publications/group-normalization/</li>
<li>What is Group Normalization? - GeeksforGeeks, 8월 26, 2025에 액세스, https://www.geeksforgeeks.org/deep-learning/what-is-group-normalization/</li>
<li>When should I use Layer Normalization? : r/MLQuestions - Reddit, 8월 26, 2025에 액세스, https://www.reddit.com/r/MLQuestions/comments/19b79gn/when_should_i_use_layer_normalization/</li>
<li>Group Normalization in Pytorch (With Examples) | by whyamit404 - Medium, 8월 26, 2025에 액세스, https://medium.com/@whyamit404/group-normalization-in-pytorch-with-examples-3648992535f3</li>
<li>GroupNorm? Then BatchNorm, InstanceNorm, LayerNorm, … | by L.J. | Medium, 8월 26, 2025에 액세스, https://medium.com/@zljdanceholic/groupnorm-then-batchnorm-instancenorm-layernorm-e2b2a1d350a0</li>
<li>What Is Group Normalization? | Baeldung on Computer Science, 8월 26, 2025에 액세스, https://www.baeldung.com/cs/group-normalization</li>
<li>Group Normalization in Pytorch (With Examples) | GroupNorm – Weights &amp; Biases - Wandb, 8월 26, 2025에 액세스, https://wandb.ai/wandb_fc/GroupNorm/reports/Group-Normalization-in-Pytorch-With-Examples—VmlldzoxMzU0MzMy</li>
<li>Group Normalization in Depth - Number Analytics, 8월 26, 2025에 액세스, https://www.numberanalytics.com/blog/group-normalization-in-depth</li>
<li>www.unitxlabs.com, 8월 26, 2025에 액세스, <a href="https://www.unitxlabs.com/resources/batch-normalization-machine-vision-guide/#:~:text=Group%20Normalization%20(GN)%20offers%20a,improved%20performance%20on%20benchmark%20datasets.">https://www.unitxlabs.com/resources/batch-normalization-machine-vision-guide/#:~:text=Group%20Normalization%20(GN)%20offers%20a,improved%20performance%20on%20benchmark%20datasets.</a></li>
<li>GRAPHNORM: APRINCIPLED APPROACH TO ACCEL- ERATING GRAPH NEURAL NETWORK TRAINING - OpenReview, 8월 26, 2025에 액세스, https://openreview.net/pdf?id=reEp2BReEou</li>
<li>Adaptive Gradient Regularization: A Faster and Generalizable Optimization Technique for Deep Neural Networks - arXiv, 8월 26, 2025에 액세스, https://arxiv.org/html/2407.16944v4</li>
<li>[2207.01972] Understanding and Improving Group Normalization - arXiv, 8월 26, 2025에 액세스, https://arxiv.org/abs/2207.01972</li>
<li>(PDF) Understanding and Improving Group Normalization, 8월 26, 2025에 액세스, https://www.researchgate.net/publication/361788277_Understanding_and_Improving_Group_Normalization</li>
<li>Batch Normalization vs Layer Normalization - Data Science Stack Exchange, 8월 26, 2025에 액세스, https://datascience.stackexchange.com/questions/126476/batch-normalization-vs-layer-normalization</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>