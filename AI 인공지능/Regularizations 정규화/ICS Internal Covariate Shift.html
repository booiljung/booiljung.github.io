<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:내부 공변량 이동(ICS)의 심층 분석과 정규화 기법의 재조명</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>내부 공변량 이동(ICS)의 심층 분석과 정규화 기법의 재조명</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">정규화 (Regularizations)</a> / <span>내부 공변량 이동(ICS)의 심층 분석과 정규화 기법의 재조명</span></nav>
                </div>
            </header>
            <article>
                <h1>내부 공변량 이동(ICS)의 심층 분석과 정규화 기법의 재조명</h1>
<h2>1. 서론</h2>
<p>심층 신경망(Deep Neural Networks, DNNs)은 다양한 분야에서 전례 없는 성공을 거두었으나, 그 구조가 깊어질수록 훈련 과정은 본질적으로 복잡하고 불안정한 문제에 직면한다. 경사 하강법(Gradient Descent) 기반의 최적화 알고리즘은 심층 신경망의 수많은 파라미터를 조정하는 표준적인 방법론이지만, 각 계층(layer)의 파라미터가 업데이트될 때마다 발생하는 동적인 상호작용은 훈련 과정을 불안정하게 만드는 핵심적인 난제로 작용한다.1 이러한 불안정성의 근원에는 ’내부 공변량 이동(Internal Covariate Shift, ICS)’이라는 현상이 자리 잡고 있다.</p>
<p>본 안내서의 핵심 주제인 내부 공변량 이동은 훈련 과정에서 각 계층에 입력되는 데이터의 분포가 이전 계층들의 파라미터 업데이트로 인해 지속해서 변하는 현상을 지칭한다.4 이는 단순한 통계적 변화를 넘어, 신경망의 학습 속도를 저하하고, 기울기 소실(vanishing gradients)이나 폭주(exploding gradients)와 같은 고질적인 문제를 심화시키며, 파라미터 초기화에 대한 민감도를 높이는 등 훈련 동역학(training dynamics) 전반에 걸쳐 악영향을 미친다.</p>
<p>본 안내서는 먼저 공변량 이동이라는 일반적인 개념에서 출발하여, 이 현상이 심층 신경망 내부에서 어떻게 발현되는지를 탐구한다. 이후 ICS의 수학적 원인과 이것이 훈련 과정에 미치는 구체적인 영향들을 심층적으로 분석한다. 다음으로, 이 문제를 해결하기 위해 제안된 가장 대표적인 기법인 배치 정규화(Batch Normalization)의 알고리즘과 작동 원리를 상세히 설명하고, 배치 정규화의 성공을 둘러싼 최신 학술적 논쟁, 즉 ‘ICS 감소’ 가설과 ‘손실 지형 평탄화(loss landscape smoothing)’ 가설을 비판적으로 검토한다. 나아가 배치 정규화가 가지는 규제(regularization) 효과와 같은 부가적인 측면을 탐구하고, 그 한계를 극복하기 위한 대안 정규화 기법들을 비교 분석한다. 이 과정을 통해 독자가 ICS에 대한 피상적인 이해를 넘어, 심층 신경망 최적화에 대한 깊이 있는 통찰을 얻도록 하는 것이 본 안내서의 궁극적인 목표이다.</p>
<h2>2.  공변량 이동의 이해: 외부에서 내부로</h2>
<h3>2.1  공변량 이동(Covariate Shift)의 정의와 문제점</h3>
<p>전통적인 지도 학습(supervised learning) 모델은 훈련 데이터와 테스트 데이터가 동일한 확률 분포에서 독립적으로 추출되었다는 가정(independent and identically distributed, i.i.d.) 하에 설계된다. 그러나 실제 응용에서는 이 가정이 종종 깨지는데, 훈련 시점과 추론 시점의 데이터 분포가 달라지는 현상을 ’공변량 이동(Covariate Shift)’이라고 한다.2 수학적으로 공변량 이동은 입력 변수 <span class="math math-inline">X</span>의 주변 확률 분포(marginal probability distribution)는 변하지만, 주어진 입력 <span class="math math-inline">X</span>에 대한 출력 <span class="math math-inline">Y</span>의 조건부 확률 분포(conditional probability distribution) <span class="math math-inline">P(Y|X)</span>는 변하지 않는 상황을 의미한다.2 즉, 훈련 데이터의 입력 분포</p>
<p><span class="math math-inline">P_{train}(X)</span>와 테스트 데이터의 입력 분포 <span class="math math-inline">P_{test}(X)</span>가 다를 때(<span class="math math-inline">P_{train}(X) \neq P_{test}(X)</span>), 공변량 이동이 발생했다고 말한다.</p>
<p>이러한 분포의 변화는 모델의 일반화(generalization) 성능에 심각한 저하를 초래할 수 있다. 예를 들어, 특정 계절의 소비자 구매 패턴 데이터로 학습된 추천 시스템은 계절이 바뀐 후 새로운 구매 패턴을 보이는 소비자들에게는 정확한 추천을 제공하기 어렵다.6 모델은 훈련 데이터의 특정 통계적 특성에 과적합(overfitting)되었기 때문에, 분포가 달라진 새로운 데이터에 대해서는 예측 성능이 급격히 감소하는 것이다.</p>
<h3>2.2  내부 공변량 이동(Internal Covariate Shift)의 개념 확장</h3>
<p>Ioffe와 Szegedy는 2015년 논문에서 공변량 이동의 개념을 심층 신경망의 <em>내부</em>로 확장하여 ’내부 공변량 이동(Internal Covariate Shift, ICS)’이라는 용어를 처음으로 제시했다.4 ICS는 심층 신경망의 훈련 과정에서, 이전 계층들의 파라미터(<span class="math math-inline">\Theta_{1}, \dots, \Theta_{L-1}</span>)가 경사 하강법에 의해 업데이트됨에 따라, 현재 계층 <span class="math math-inline">L</span>이 입력으로 받는 데이터(즉, <span class="math math-inline">L-1</span> 계층의 활성화 값)의 분포가 매 훈련 스텝(step)마다 계속해서 변하는 현상을 의미한다.1</p>
<p>이는 모델 전체에 입력되는 데이터의 분포는 고정되어 있더라도, 각 계층이 ‘바라보는’ 국소적인 입력 데이터의 분포는 훈련 내내 역동적으로 변하는 것을 뜻한다. 각 계층은 마치 끊임없이 움직이는 목표물(moving target)을 맞추려는 것처럼, 지속해서 변하는 입력 분포에 적응해야만 한다.8 이로 인해 학습 과정이 불안정해지고 속도가 저하되는 문제가 발생한다.</p>
<p>외부 공변량 이동이 ’훈련’과 ’추론’이라는 두 개의 분리된 시점 사이에서 발생하는 정적인 분포 불일치 문제라면, 내부 공변량 이동은 ’훈련’이라는 단일 과정 내에서 매 순간 동적으로 발생하는 문제라는 점에서 근본적인 차이가 있다. 심층 신경망의 각 계층은 이전 계층의 출력을 입력으로 받는 하나의 작은 학습 시스템 또는 ’부분 망(sub-network)’으로 간주할 수 있다.4 경사 하강법은 모든 계층의 파라미터를 손실 함수에 대한 기여도에 따라 동시에 업데이트한다.11 이때, 한 하위 계층의 파라미터가 아주 조금만 변경되더라도, 여러 개의 비선형 활성화 함수를 통과하면서 그 출력 분포는 예측하기 어려운 방식으로 크게 변할 수 있다. 이 변화는 다음 계층으로 전파되고, 그 다음 계층에서 다시 증폭되는 과정을 거친다. 결과적으로 신경망이 깊어질수록 이러한 불안정성은 연쇄적으로 누적되고 증폭된다.4 따라서 ICS는 단순히 통계적 분포가 변하는 현상을 넘어, 심층 신경망의 계층적 구조와 경사 하강법 기반의 학습 방식이 결합하여 만들어내는 ‘불안정성의 연쇄 증폭’ 현상으로 이해해야 한다.</p>
<h2>3.  내부 공변량 이동(ICS)의 원인과 영향</h2>
<h3>3.1  ICS의 수학적 발생 원리</h3>
<p>ICS의 발생 원리를 이해하기 위해 심층 신경망의 한 계층에서의 연산을 수식으로 살펴보자. <span class="math math-inline">L</span>번째 계층의 선형 변환 전 입력(pre-activation) <span class="math math-inline">\mathbf{z}^{(L)}</span>은 이전 계층의 활성화(activation) 출력 <span class="math math-inline">\mathbf{a}^{(L-1)}</span>과 현재 계층의 가중치 행렬 <span class="math math-inline">\mathbf{W}^{(L)}</span>, 편향 벡터 <span class="math math-inline">\mathbf{b}^{(L)}</span>에 의해 다음과 같이 계산된다.<br />
<span class="math math-display">
\mathbf{z}^{(L)} = \mathbf{W}^{(L)}\mathbf{a}^{(L-1)} + \mathbf{b}^{(L)}
</span><br />
그리고 이 값은 활성화 함수 <span class="math math-inline">g(\cdot)</span>를 통과하여 현재 계층의 최종 출력 <span class="math math-inline">\mathbf{a}^{(L)}</span>이 된다.<br />
<span class="math math-display">
\mathbf{a}^{(L)} = g(\mathbf{z}^{(L)}) = g(\mathbf{W}^{(L)}\mathbf{a}^{(L-1)} + \mathbf{b}^{(L)})
</span><br />
여기서 <span class="math math-inline">L+1</span>번째 계층의 입장에서 보면, 그 입력은 바로 <span class="math math-inline">\mathbf{a}^{(L)}</span>이다. 훈련 과정에서 경사 하강법은 손실 함수 <span class="math math-inline">\mathcal{L}</span>을 최소화하기 위해 모든 하위 계층들(<span class="math math-inline">1, \dots, L</span>)의 파라미터(<span class="math math-inline">\mathbf{W}^{(1)}, \mathbf{b}^{(1)}, \dots, \mathbf{W}^{(L)}, \mathbf{b}^{(L)}</span>)를 업데이트한다. 예를 들어, <span class="math math-inline">L-1</span>번째 계층의 가중치 <span class="math math-inline">\mathbf{W}^{(L-1)}</span>는 다음과 같이 업데이트된다.<br />
<span class="math math-display">
\mathbf{W}^{(L-1)} \leftarrow \mathbf{W}^{(L-1)} - \eta \frac{\partial \mathcal{L}}{\partial \mathbf{W}^{(L-1)}}
</span><br />
이 업데이트로 인해 <span class="math math-inline">\mathbf{a}^{(L-1)}</span>의 값이 변하게 되고, 이는 연쇄적으로 <span class="math math-inline">\mathbf{z}^{(L)}</span>과 <span class="math math-inline">\mathbf{a}^{(L)}</span>의 분포 <span class="math math-inline">P(\mathbf{a}^{(L)})</span>를 변화시킨다. 즉, <span class="math math-inline">L+1</span>번째 계층은 이전 훈련 스텝과는 다른 분포의 입력을 받게 되는 것이다.2 이러한 변화가 모든 계층에서 동시에, 그리고 연쇄적으로 발생하면서 심층 신경망 전체에 걸쳐 ICS 현상이 나타난다.</p>
<h3>3.2  ICS가 훈련 동역학에 미치는 악영향</h3>
<p>내부 공변량 이동은 심층 신경망의 훈련 과정에 다음과 같은 심각한 악영향을 미친다.</p>
<ul>
<li><strong>학습률 제약과 훈련 속도 저하:</strong> 각 계층은 상위 계층이 유의미한 표현(representation)을 학습하는 동시에, 하위 계층으로부터 전달되는 변화무쌍한 입력 분포에 끊임없이 재적응해야 하는 이중고를 겪는다.1 이러한 불안정성은 최적화기가 파라미터 공간에서 안정적인 방향으로 나아가는 것을 방해한다. 만약 학습률(learning rate)이 너무 크면, 작은 파라미터 변화가 하위 계층에서 증폭되어 상위 계층의 입력 분포를 극심하게 변화시키고, 이는 결국 손실 함수의 발산으로 이어질 수 있다. 따라서 안정적인 학습을 보장하기 위해 매우 작은 학습률을 사용하도록 강제되며, 이는 필연적으로 모델의 수렴 속도를 현저히 저하시키는 결과를 낳는다.1</li>
<li><strong>기울기 소실 및 폭주 문제 심화:</strong> ICS는 특히 포화(saturating) 비선형 활성화 함수(예: 시그모이드, 하이퍼볼릭 탄젠트)와 결합될 때 치명적인 문제를 야기한다.4 시그모이드 함수 <span class="math math-inline">g(x) = 1/(1+e^{-x})</span>를 예로 들면, 입력값 <span class="math math-inline">x</span>의 절댓값이 커질수록 함수의 기울기 <span class="math math-inline">g&#39;(x)</span>는 0에 가깝게 수렴한다. 이 영역을 ’포화 영역(saturated regime)’이라고 한다. 훈련 과정에서 ICS로 인해 특정 계층의 입력 값들이 지속적으로 변화하다가 우연히 이 포화 영역으로 밀려나게 되면, 역전파(backpropagation) 시 해당 뉴런을 통과하는 기울기는 거의 0이 되어 소실된다.4 이로 인해 하위 계층으로는 의미 있는 학습 신호가 전달되지 않아 파라미터 업데이트가 사실상 멈추게 되며, 이는 깊은 네트워크의 학습을 극도로 어렵게 만든다.2</li>
<li><strong>파라미터 초기화에 대한 높은 민감도:</strong> 심층 신경망의 훈련 성공 여부는 가중치 파라미터의 초기값에 크게 의존한다. 만약 초기화가 부적절하게 이루어지면 훈련 초반부터 활성화 값의 분포가 한쪽으로 치우치거나 극단적인 값을 가질 수 있다. ICS는 이러한 초기의 작은 불안정성을 훈련이 진행됨에 따라 증폭시키는 역할을 한다.2 이로 인해 모델은 불안정한 상태에서 벗어나지 못하고 결국 훈련에 실패할 수 있으며, 성공적인 훈련을 위해서는 매우 신중하고 정교한 가중치 초기화 기법이 요구된다.2</li>
</ul>
<p>ICS와 포화 활성화 함수의 상호작용은 딥러닝 초창기에 깊은 네트워크를 훈련시키기 어려웠던 근본적인 원인 중 하나이다. 포화 활성화 함수는 입력 값의 특정 범위(예: 시그모이드 함수의 경우 0 근처)에서만 유의미한 기울기를 가지는데, ICS는 이 ’유의미한 범위’를 예측 불가능하게 계속해서 이동시킨다. 따라서 각 계층은 입력 데이터의 의미 있는 특징을 학습하는 본연의 임무 외에도, 입력 분포가 현재 어디에 위치하는지를 ’추적’하는 데 학습 능력의 상당 부분을 소모해야 한다. 이는 마치 사격 선수가 과녁 자체가 끊임없이 움직이는 상황에서 명중을 시도하는 것과 같다. 선수는 총을 쏘는 기술 자체보다 과녁의 움직임을 예측하는 데 더 많은 노력을 기울여야 하는 비효율적인 상황에 놓이게 된다. 이처럼 ICS는 단순히 학습을 느리게 하는 것을 넘어, 포화 활성화 함수의 핵심적인 약점을 증폭시켜 심층 신경망의 학습 자체를 불가능하게 만들 수 있다. ReLU와 같은 비포화(non-saturating) 활성화 함수의 등장이 이 문제를 일부 완화했지만, 분포 변화로 인한 근본적인 불안정성 문제는 여전히 남아있다.</p>
<h2>4.  배치 정규화(Batch Normalization): ICS에 대한 고전적 해법</h2>
<h3>4.1  배치 정규화의 핵심 아이디어</h3>
<p>2015년 Ioffe와 Szegedy는 내부 공변량 이동 문제에 대한 획기적인 해결책으로 배치 정규화(Batch Normalization, BN)를 제안했다.3 그들의 핵심 아이디어는 ICS의 근본 원인이 계층별 입력 분포의 ’불안정성’에 있다고 진단하고, 이를 각 계층에서 인위적으로 ’안정화’시키는 것이었다. 구체적으로, 배치 정규화는 신경망의 각 계층에 들어오는 입력을 미니배치(mini-batch) 단위로 정규화하여, 평균이 0이고 분산이 1인 분포로 강제 변환한다.4 이러한 과정을 통해 각 계층은 훈련이 진행되는 동안 파라미터가 어떻게 변하든 상관없이 항상 안정적인 분포의 입력을 받게 되어 학습이 용이해진다는 것이다. 이는 일종의 전처리(pre-processing) 단계인 백색화(whitening)를 신경망의 모든 계층에 적용하는 것과 유사한 개념이다.4</p>
<h3>4.2  배치 정규화 알고리즘 상세 분석</h3>
<p>배치 정규화는 모델의 훈련(training) 단계와 추론(inference) 단계에서 다르게 동작한다.</p>
<h4>4.2.1  훈련(Training) 단계</h4>
<p>훈련 단계에서 배치 정규화는 현재 처리 중인 미니배치의 통계량을 사용하여 정규화를 수행한다. 크기가 <span class="math math-inline">m</span>인 미니배치 <span class="math math-inline">\mathcal{B} = \{x_1, \dots, x_m\}</span>에 대해, 특정 활성화(피처 또는 채널)에 대한 배치 정규화 연산은 다음 4단계로 이루어진다.8</p>
<ol>
<li>
<p><strong>미니배치 평균 계산:</strong> 미니배치에 속한 샘플들의 평균을 계산한다.<br />
<span class="math math-display">
\mu_{\mathcal{B}} \leftarrow \frac{1}{m}\sum_{i=1}^{m} x_i
</span></p>
</li>
<li>
<p><strong>미니배치 분산 계산:</strong> 미니배치에 속한 샘플들의 분산을 계산한다.<br />
<span class="math math-display">
\sigma^2_{\mathcal{B}} \leftarrow \frac{1}{m}\sum_{i=1}^{m} (x_i - \mu_{\mathcal{B}})^2
</span></p>
</li>
<li>
<p><strong>정규화:</strong> 계산된 평균과 분산을 이용해 각 샘플을 정규화한다. 이때 분모가 0이 되는 것을 방지하기 위해 수치적 안정성을 위한 작은 상수 <span class="math math-inline">\epsilon</span>을 더한다.8<br />
<span class="math math-display">
\hat{x}_i \leftarrow \frac{x_i - \mu_{\mathcal{B}}}{\sqrt{\sigma^2_{\mathcal{B}} + \epsilon}}
</span></p>
</li>
<li>
<p><strong>스케일 및 시프트(Scale and Shift):</strong> 정규화된 값 <span class="math math-inline">\hat{x}_i</span>에 학습 가능한(learnable) 파라미터인 스케일 <span class="math math-inline">\gamma</span>와 시프트 <span class="math math-inline">\beta</span>를 적용하여 최종 출력 <span class="math math-inline">y_i</span>를 생성한다.<br />
<span class="math math-display">
y_i \leftarrow \gamma \hat{x}_i + \beta
</span></p>
</li>
</ol>
<h4>4.2.2  추론(Inference) 단계</h4>
<p>모델의 훈련이 완료된 후, 추론(또는 테스트) 단계에서는 일반적으로 한 번에 하나의 샘플에 대한 예측을 수행하므로 미니배치를 구성할 수 없다. 따라서 미니배치의 평균과 분산을 계산하는 것이 불가능하거나 무의미하다.1 이 문제를 해결하기 위해 배치 정규화는 훈련 과정 동안 전체 훈련 데이터의 통계량에 대한 추정치를 계산하여 저장해두고, 추론 시에 이 값을 사용한다.13</p>
<p>이 추정치는 보통 지수 이동 평균(exponentially weighted moving average) 방식을 사용하여 계산된다. 각 훈련 스텝에서 계산된 미니배치 평균 <span class="math math-inline">\mu_{\mathcal{B}}</span>와 분산 <span class="math math-inline">\sigma^2_{\mathcal{B}}</span>을 이용해 전역 통계량(population statistics)인 이동 평균 <span class="math math-inline">E[x]</span>와 이동 분산 <span class="math math-inline">Var[x]</span>을 다음과 같이 업데이트한다.12<br />
<span class="math math-display">
E[x] \leftarrow \text{momentum} \cdot E[x] + (1 - \text{momentum}) \cdot \mu_{\mathcal{B}}
</span></p>
<p><span class="math math-display">
Var[x] \leftarrow \text{momentum} \cdot Var[x] + (1 - \text{momentum}) \cdot \sigma^2_{\mathcal{B}}
</span></p>
<p>여기서 <code>momentum</code>은 하이퍼파라미터로, 보통 0.9, 0.99 등 1에 가까운 값을 사용한다. 훈련이 끝나면 이렇게 누적된 이동 평균 <span class="math math-inline">E[x]</span>와 이동 분산 <span class="math math-inline">Var[x]</span>이 고정되어 추론 시에 사용된다. 추론 시 정규화는 다음과 같이 수행된다.<br />
<span class="math math-display">
\hat{x} \leftarrow \frac{x - E[x]}{\sqrt{Var[x] + \epsilon}}
</span></p>
<p><span class="math math-display">
y \leftarrow \gamma \hat{x} + \beta
</span></p>
<h4>4.2.3  학습 가능한 파라미터 <span class="math math-inline">\gamma</span>와 <span class="math math-inline">\beta</span>의 역할</h4>
<p>단순히 모든 계층의 입력을 평균 0, 분산 1로 강제하는 것은 신경망의 표현력(representational power)을 저해할 수 있다. 예를 들어, 시그모이드 활성화 함수는 입력이 0 근처에 있을 때 거의 선형처럼 동작한다. 만약 정규화를 통해 모든 입력이 이 선형 영역에만 머무르게 된다면, 시그모이드 함수가 가진 중요한 비선형적 표현 능력을 잃게 된다.</p>
<p>학습 가능한 파라미터 <span class="math math-inline">\gamma</span>와 <span class="math math-inline">\beta</span>는 이러한 문제를 해결하기 위해 도입되었다.8 이 두 파라미터는 신경망이 역전파 과정을 통해 스스로 최적의 평균(<span class="math math-inline">\beta</span>)과 분산(<span class="math math-inline">\gamma^2</span>)을 학습할 수 있도록 한다. 즉, 네트워크가 필요하다고 판단하면 정규화의 효과를 약화시키거나 심지어는 완전히 되돌릴 수도 있다. 예를 들어, 만약 네트워크가 항등 변환(identity transform)이 최적이라고 판단하면, <span class="math math-inline">\gamma = \sqrt{\sigma^2_{\mathcal{B}} + \epsilon}</span> 와 <span class="math math-inline">\beta = \mu_{\mathcal{B}}</span>를 학습하여 원래의 활성화 값 <span class="math math-inline">x_i</span>를 복원할 수 있다. 이처럼 <span class="math math-inline">\gamma</span>와 <span class="math math-inline">\beta</span>는 정규화로 인해 손실될 수 있는 표현력을 복원하고 네트워크에 유연성을 부여하는 매우 중요한 역할을 수행한다.</p>
<h3>4.3  배치 정규화가 가져온 혁신</h3>
<p>배치 정규화의 등장은 심층 신경망 연구 및 응용에 혁신적인 변화를 가져왔다.</p>
<ul>
<li><strong>훈련 가속화:</strong> 배치 정규화는 ICS를 효과적으로 완화함으로써 이전에는 상상하기 어려웠던 높은 학습률의 사용을 가능하게 했다. 이로 인해 모델의 수렴 속도가 극적으로 향상되었다. 원 논문에서는 당시 최고 수준의 이미지 분류 모델이었던 Inception 네트워크에 배치 정규화를 적용하여, 14배 적은 훈련 단계만으로 동일한 정확도를 달성했다고 보고했다.3</li>
<li><strong>안정성 확보 및 일반화:</strong> 배치 정규화는 훈련 과정을 안정화시켜 파라미터 초기화에 대한 민감도를 크게 줄였다.21 또한, 기울기 소실 및 폭주 문제를 완화하여 이전보다 훨씬 더 깊은 네트워크의 훈련을 가능하게 했다. 이로 인해 심층 신경망 아키텍처 설계의 자유도가 높아졌으며, 모델의 전반적인 성능과 안정성이 향상되었다.</li>
</ul>
<p>배치 정규화의 강력한 성능의 이면에는 ’훈련과 추론의 불일치’라는 내재적인 딜레마가 존재한다. 훈련 시의 정규화는 현재 미니배치 내의 다른 샘플들에 통계적으로 의존한다. 즉, 한 샘플의 정규화된 출력값은 그 샘플이 어떤 다른 샘플들과 함께 배치되었는지에 따라 달라진다.24 반면, 추론 시의 정규화는 훈련 과정 전체에서 누적된 고정된 전역 통계량을 사용하므로 결정론적(deterministic)이다. 이 불일치는 특히 배치 크기가 작을 때 심각한 문제로 이어진다. 작은 배치의 통계량은 전체 데이터의 통계량과 큰 차이를 보일 수 있으며, 이러한 불안정한 통계량으로 훈련된 파라미터가 추론 시의 고정된 통계량 환경에서 최적의 성능을 보장하지 못할 수 있다. 이처럼 배치 정규화의 효과는 배치 크기에 강하게 의존하게 되었고, 이 문제를 해결하기 위해 이후에 계층 정규화(Layer Normalization), 그룹 정규화(Group Normalization)와 같은 대안적인 기법들이 제안되는 직접적인 계기가 되었다.</p>
<h2>5.  배치 정규화는 정말 ICS를 해결하는가?: 작동 원리에 대한 재조명</h2>
<h3>5.1  “ICS 감소” 가설에 대한 비판적 검토</h3>
<p>배치 정규화를 제안한 Ioffe와 Szegedy는 그 경이로운 성공의 원인을 내부 공변량 이동(ICS)의 감소로 설명했다.4 이 설명은 각 계층의 입력 분포를 안정화시켜 학습을 용이하게 한다는 점에서 매우 직관적이고 설득력이 있었기 때문에, 오랫동안 학계의 정설로 받아들여졌다. 배치 정규화가 훈련을 가속하고 안정화시키는 이유를 묻는다면 대부분의 전문가는 ’ICS를 줄여주기 때문’이라고 답했을 것이다.</p>
<p>그러나 2018년을 기점으로 이 정설에 도전하는 후속 연구들이 등장하기 시작했다. Santurkar 등이 발표한 논문 “How Does Batch Normalization Help Optimization?“에서는 배치 정규화의 유무에 따른 ICS의 변화를 정량적으로 측정하는 실험을 수행했다.25 놀랍게도 실험 결과, 배치 정규화를 적용한 네트워크가 그렇지 않은 네트워크에 비해 ICS가 줄어들지 않거나, 심지어 <strong>더 증가</strong>하는 경우도 관찰되었다.13 이는 배치 정규화의 성공 비결이 우리가 믿어왔던 ICS 감소가 아닐 수도 있으며, 그 이면에 다른 핵심적인 메커니즘이 존재할 수 있음을 강력하게 시사하는 결과였다.</p>
<h3>5.2  대안 가설: 손실 지형 평탄화(Loss Landscape Smoothing)</h3>
<p>“ICS 감소” 가설을 반박한 연구들은 배치 정규화의 진정한 역할에 대한 새로운 가설을 제시했는데, 그중 가장 유력한 것이 바로 <strong>손실 지형 평탄화(loss landscape smoothing)</strong> 가설이다.13 손실 지형이란, 신경망의 파라미터 값에 따른 손실 함수의 값을 시각화한 것으로, 이 지형이 얼마나 복잡하고 험준한지가 최적화의 난이도를 결정한다.</p>
<p>이 가설에 따르면, 배치 정규화는 최적화 과정의 손실 지형을 훨씬 더 완만하고 평탄하게(smoother) 만드는 효과를 가진다. 손실 지형이 평탄하다는 것은 파라미터를 조금 변경했을 때 손실 값과 그래디언트의 변화가 크지 않고 예측 가능하다는 의미이다. 이러한 환경에서는 최적화기가 더 큰 보폭(즉, 높은 학습률)으로 이동하더라도 급격한 절벽이나 좁고 가파른 골짜기에 빠질 위험이 적다.27 결과적으로, 더 공격적인 최적화가 가능해져 안정적으로 최솟값을 향해 빠르게 수렴할 수 있게 된다. 수학적으로 이는 손실 함수의 립시츠 상수(Lipschitz constant)를 효과적으로 줄여, 그래디언트가 더 안정적이고 신뢰할 수 있게 됨을 의미한다.13</p>
<h3>5.3  결론: 높은 학습률 허용이 핵심적인 성공 요인</h3>
<p>ICS 감소 가설과 손실 지형 평탄화 가설 사이의 논쟁에도 불구하고, 배치 정규화가 경험적으로 <strong>더 높은 학습률의 사용을 가능하게 한다</strong>는 사실에는 이론의 여지가 없다.3 배치 정규화가 없는 심층 네트워크는 높은 학습률을 사용하면 활성화 값이 폭발적으로 증가하여 훈련이 발산하기 쉽지만, 배치 정규화는 각 계층에서 활성화 값의 평균과 분산을 지속적으로 재조정함으로써 이러한 폭주를 막는 ‘안전장치’ 역할을 한다.28</p>
<p>결론적으로, 배치 정규화의 성공에 대한 현대적인 관점은 다음과 같이 정리할 수 있다. 배치 정규화의 가장 직접적이고 핵심적인 효과는 손실 지형을 평탄하게 만들어 최적화 환경 자체를 개선하는 것이다. 이로 인해 가능해진 높은 학습률의 사용이 결과적으로 훈련 가속화와 더 나은 일반화 성능이라는 실질적인 이점으로 이어진다고 보는 것이 타당하다.27 ICS 감소는 이러한 과정에서 나타나는 부수적인 현상이거나, 적어도 성공의 핵심 원인은 아닐 가능성이 높다.</p>
<p>이러한 이해의 변화는 딥러닝 연구 분야에서 흔히 발견되는 패턴을 보여준다. 어떤 기법의 놀라운 경험적 성공이 먼저 관찰되고, 그 성공의 원인에 대한 직관적이고 매력적인 설명(ICS 감소)이 제시된다. 이후, 더 깊이 있는 이론적, 실험적 분석을 통해 그 초기의 설명이 수정되거나 완전히 새로운 패러다임(손실 지형 평탄화)으로 대체되는 과정이다. 배치 정규화의 사례는 딥러닝의 작동 원리를 이해하는 과정이 여전히 진행 중이며, 직관적인 설명이 실제 메커니즘과 다를 수 있음을 보여주는 중요한 교훈을 제공한다.</p>
<h2>6.  배치 정규화의 부가적 효과: 규제(Regularization)</h2>
<h3>6.1  미니배치 통계량의 노이즈와 규제 효과</h3>
<p>배치 정규화는 본래 훈련 안정성과 속도 향상을 목표로 설계되었지만, 부가적으로 모델의 일반화 성능을 높이는 규제(regularization) 효과를 가진다는 것이 경험적으로 잘 알려져 있다. 이 규제 효과의 원천은 훈련 과정에서 사용되는 미니배치 통계량의 본질적인 ’노이즈’에 있다.</p>
<p>훈련 시 각 미니배치의 평균(<span class="math math-inline">\mu_{\mathcal{B}}</span>)과 분산(<span class="math math-inline">\sigma^2_{\mathcal{B}}</span>)은 전체 훈련 데이터셋의 실제 평균과 분산에 대한 **노이즈가 섞인 추정치(noisy estimate)**일 뿐이다.26 미니배치는 전체 데이터에서 무작위로 샘플링되기 때문에, 어떤 샘플들이 선택되느냐에 따라 그 통계량은 매번 미세하게 달라진다. 결과적으로, 동일한 훈련 샘플이라도 어떤 미니배치에 포함되느냐에 따라 매번 다른 평균과 분산에 의해 정규화되며, 이는 해당 샘플의 활성화 값에 미세한 변화를 유발한다. 이 과정은 훈련 데이터에 일종의 무작위 노이즈를 지속적으로 주입하는 것과 유사한 효과를 낳는다.1</p>
<p>이러한 노이즈는 모델이 훈련 데이터의 특정 샘플이나 미니배치의 우연한 특성에 과도하게 의존하는 것, 즉 과적합(overfitting)되는 것을 방지한다. 대신 모델은 이러한 미세한 변화에도 강건한(robust) 특징을 학습하도록 유도되며, 이는 보지 못한 데이터에 대한 일반화 성능을 향상시키는 규제 효과로 작용한다.22</p>
<h3>6.2  배치 크기와 규제 강도의 관계</h3>
<p>규제 효과의 강도는 배치 크기와 밀접한 관련이 있다. 통계학의 기본 원리에 따라, 샘플의 크기가 작을수록 추정치의 분산은 커진다. 마찬가지로, 배치 크기가 작을수록 미니배치의 평균과 분산은 전체 데이터의 통계량에서 더 많이 벗어나게 되므로, 더 큰 노이즈를 발생시킨다. 따라서 <strong>배치 크기를 작게 설정하면 더 강한 규제 효과</strong>를 얻을 수 있다.24 반대로 배치 크기를 매우 크게 설정하면 미니배치 통계량이 전체 데이터의 통계량에 가까워져 노이즈가 줄어들고 규제 효과도 감소한다.</p>
<p>이러한 특성을 의도적으로 활용하는 기법이 바로 ’고스트 배치 정규화(Ghost Batch Normalization, GBN)’이다. GBN은 큰 미니배치를 내부적으로 여러 개의 작은 ’고스트 배치’로 나누어 각각에 대해 정규화를 수행함으로써, 큰 배치 크기의 계산적 이점을 유지하면서도 작은 배치 크기의 강한 규제 효과를 얻고자 하는 방법이다.24</p>
<h3>6.3  드롭아웃(Dropout)과의 비교</h3>
<p>배치 정규화는 종종 또 다른 대표적인 규제 기법인 드롭아웃(Dropout)의 필요성을 감소시키거나 완전히 대체할 수 있는 것으로 알려져 있다.3 두 기법 모두 훈련 과정에 무작위성을 주입하여 모델의 과적합을 방지한다는 공통점을 가진다. 그러나 그 방식에는 차이가 있다. 드롭아웃은 특정 확률로 뉴런 자체를 무작위로 비활성화하여 네트워크가 특정 뉴런에 과도하게 의존하는 것을 막는다. 반면, 배치 정규화는 모든 뉴런을 활성화 상태로 두되, 미니배치 통계량의 노이즈를 통해 각 뉴런의 활성화 값 스케일에 미세한 변화를 주는 방식으로 규제를 수행한다.</p>
<p>배치 정규화의 규제 효과는 딥러닝 연구에서 의도하지 않은 설계적 특징이 예상치 못한 긍정적 효과로 이어진 ’우연한 발견(serendipity)’의 좋은 예이다. 본래 배치 정규화의 설계 핵심은 전체 데이터셋에 대한 계산을 미니배치 단위로 근사하여 계산 효율성을 높이는 것이었다. 그러나 이 ’효율성을 위한 근사’가 필연적으로 ’통계적 노이즈’를 발생시켰고, 이 노이즈가 우연히도 드롭아웃과 유사한 규제 효과를 낳는다는 것이 경험적으로 발견된 것이다. 이는 한 가지 문제를 해결하려는 시도가 다른 문제에 대한 해결책을 동시에 제공할 수 있음을 보여주는 흥미로운 사례이다.</p>
<h2>7.  배치 정규화를 넘어서: 대안 정규화 기법들</h2>
<p>배치 정규화는 심층 신경망 훈련에 혁명을 일으켰지만, 모든 상황에 적용 가능한 만능 해결책은 아니다. 특히 몇 가지 근본적인 한계점으로 인해 특정 응용 분야에서는 사용이 어렵거나 비효율적일 수 있다.</p>
<h3>7.1  배치 정규화의 한계</h3>
<ul>
<li><strong>작은 배치 크기 문제:</strong> 배치 정규화의 성능은 배치 크기에 크게 의존한다. 배치 크기가 매우 작아지면(예: 2, 4, 8) 미니배치에서 계산된 평균과 분산이 전체 데이터의 통계량을 제대로 대표하지 못하고 매우 불안정해진다. 이로 인해 모델의 성능이 급격히 저하되는 문제가 발생한다.8 이러한 상황은 GPU 메모리 제약으로 인해 큰 배치를 사용하기 어려운 고해상도 이미지 기반의 컴퓨터 비전 태스크(예: 객체 탐지, 시맨틱 분할)에서 큰 단점으로 작용한다.33</li>
<li><strong>순환 신경망(RNN) 적용의 어려움:</strong> 순환 신경망(RNN)이나 장단기 기억(LSTM) 네트워크는 가변적인 길이의 시퀀스 데이터를 처리한다. 각 시퀀스의 길이가 다르기 때문에, 모든 타임스텝(time step)에 걸쳐 일관된 미니배치 통계량을 계산하는 것이 매우 까다롭다. 이로 인해 표준적인 배치 정규화를 RNN에 직접 적용하는 것은 효과적이지 않다.8</li>
</ul>
<h3>7.2  대안 정규화 기법 소개</h3>
<p>이러한 배치 정규화의 한계를 극복하기 위해, 정규화를 수행하는 차원(dimension)을 달리하는 여러 대안 기법들이 제안되었다.</p>
<ul>
<li>
<p><strong>계층 정규화 (Layer Normalization, LN):</strong> 계층 정규화는 배치 차원에 의존하는 대신, <strong>단일 데이터 샘플 내의 모든 피처(채널) 차원</strong>에 걸쳐 평균과 분산을 계산하여 정규화를 수행한다.1 즉, 각 샘플은 다른 샘플과 독립적으로 정규화된다. 이 방식은 배치 크기에 전혀 영향을 받지 않으므로, 배치 크기가 작거나 가변적인 상황에서도 안정적으로 동작한다. 이러한 특성 덕분에 계층 정규화는 RNN, LSTM, 그리고 트랜스포머(Transformer)와 같이 시퀀스 데이터를 다루는 모델의 표준적인 정규화 기법으로 자리 잡았다.</p>
</li>
<li>
<p><strong>인스턴스 정규화 (Instance Normalization, IN):</strong> 인스턴스 정규화는 계층 정규화보다 더 국소적인 단위로 정규화를 수행한다. 컨볼루션 신경망(CNN)에서, 각 데이터 샘플의 <strong>각 채널(feature map)에 대해 독립적으로</strong> 평균과 분산을 계산한다.1 즉, 정규화가 (N, C, H, W) 텐서에서 각 (N, C) 쌍마다 이루어진다. 이 기법은 이미지의 콘텐츠 정보는 유지하면서 스타일과 관련된 통계 정보(평균, 분산)를 제거하는 데 효과적이어서, 주로 뉴럴 스타일 전송(neural style transfer)이나 생성적 적대 신경망(GAN)과 같은 이미지 생성 모델에서 널리 사용된다.</p>
</li>
<li>
<p><strong>그룹 정규화 (Group Normalization, GN):</strong> 그룹 정규화는 배치 정규화와 계층 정규화의 절충안이라고 할 수 있다.1 이 기법은 채널들을 여러 개의 그룹으로 나눈 뒤,</p>
</li>
</ul>
<p><strong>각 그룹 내에서</strong> 정규화를 수행한다.33 예를 들어 32개의 채널을 4개의 그룹으로 나눈다면, 8개의 채널마다 평균과 분산을 계산하는 식이다. 그룹 정규화는 배치 크기에 독립적이면서도, 계층 정규화처럼 모든 채널을 동일하게 취급하지 않고 채널 간의 상관관계를 어느 정도 활용할 수 있다. 이 덕분에 작은 배치 크기를 사용하는 컴퓨터 비전 태스크에서 배치 정규화를 대체하여 안정적인 성능을 보이는 것으로 알려져 있다.33</p>
<h3>7.3  정규화 기법 비교 분석</h3>
<p>다양한 정규화 기법들의 핵심적인 차이점과 특징을 이해하는 것은 특정 문제 상황에 가장 적합한 기법을 선택하는 데 매우 중요하다. 아래 표는 주요 정규화 기법들의 특성을 요약하여 비교 분석한 것이다. 이 표는 이론적 이해를 실제 문제 해결을 위한 실용적 선택으로 연결하는 중요한 다리 역할을 한다. 정규화 기법들을 구분하는 가장 중요한 기준은 ’어떤 차원에 대해 통계량을 계산하는가’이며, 이 기준이 배치 크기 의존성, 주요 적용 분야 등 다른 모든 특성을 결정한다.</p>
<table><thead><tr><th>특징 (Feature)</th><th>배치 정규화 (BN)</th><th>계층 정규화 (LN)</th><th>인스턴스 정규화 (IN)</th><th>그룹 정규화 (GN)</th></tr></thead><tbody>
<tr><td><strong>정규화 차원</strong></td><td>미니배치 (N)</td><td>피처/채널 (C, H, W)</td><td>채널별 (H, W)</td><td>채널 그룹 (G, H, W)</td></tr>
<tr><td><strong>배치 크기 의존성</strong></td><td>높음 (High)</td><td>없음 (None)</td><td>없음 (None)</td><td>없음 (None)</td></tr>
<tr><td><strong>주요 적용 분야</strong></td><td>CNN (큰 배치)</td><td>RNN, Transformer</td><td>스타일 전송, GAN</td><td>CNN (작은 배치)</td></tr>
<tr><td><strong>장점</strong></td><td>강력한 성능, 규제 효과</td><td>배치 크기 무관, RNN 적용 용이</td><td>스타일 정보 제거에 효과적</td><td>작은 배치에서 안정적</td></tr>
<tr><td><strong>단점</strong></td><td>작은 배치에서 성능 저하, 훈련/추론 불일치</td><td>배치 단위의 정보 활용 못함</td><td>콘텐츠 정보 손실 가능성</td><td>LN보다 배치 정보 일부 활용</td></tr>
</tbody></table>
<p><em>주: N은 배치 크기, C는 채널 수, H와 W는 피처 맵의 높이와 너비, G는 그룹 수를 의미한다.</em></p>
<h2>8. 결론</h2>
<p>내부 공변량 이동(ICS)은 심층 신경망이 깊어질수록 훈련을 불안정하게 만드는 근본적인 장애물로 인식되었다. 이에 대한 해결책으로 등장한 배치 정규화는 훈련을 극적으로 가속하고 안정화시킴으로써 딥러닝 분야에 하나의 패러다임 전환을 가져왔다. 본 안내서는 ICS의 개념과 원인에서 출발하여, 배치 정규화의 알고리즘과 그 효과를 다각도로 심층 분석했다.</p>
<p>분석 과정에서 우리는 배치 정규화에 대한 이해가 시간이 지남에 따라 어떻게 변천해왔는지 살펴보았다. 초기에 배치 정규화의 성공은 ’ICS 감소’라는 직관적인 가설로 설명되었으나, 후속 연구들은 이 가설에 의문을 제기하며 ’손실 지형 평탄화’라는 더 근본적인 메커니즘을 제시했다. 이 새로운 관점은 배치 정규화가 최적화 환경 자체를 개선하여 더 높은 학습률의 사용을 가능하게 하는 것이 핵심적인 성공 요인임을 시사한다. 이는 딥러닝 기술의 작동 원리에 대한 우리의 이해가 경험적 관찰에서 시작하여 점차 더 정교한 이론적 분석으로 발전해나가는 과정을 명확히 보여준다.</p>
<p>실용적인 관점에서, 배치 정규화의 작동 원리에 대한 이론적 논쟁에도 불구하고 그 유용성은 여전히 확고하다. 그러나 배치 정규화가 가진 배치 크기 의존성이라는 명확한 한계는 모든 문제에 대한 만능 해결책이 아님을 의미한다. 따라서 모델을 설계하고 훈련하는 연구자 및 엔지니어는 당면한 문제의 특성, 예를 들어 사용 가능한 배치 크기, 모델 아키텍처(CNN, RNN, Transformer 등)를 신중하게 고려하여 계층 정규화, 그룹 정규화 등 더 적합한 대안을 선택하는 지혜가 필요하다.</p>
<p>향후 연구는 정규화 기법이 최적화 동역학에 미치는 영향에 대한 더 깊은 이론적 토대를 마련하는 방향으로 나아가야 할 것이다. 또한, 특정 정규화 기법과 최적화 알고리즘(예: Adam, SGD), 학습률 스케줄링, 가중치 초기화 기법 간의 복잡한 상호작용을 체계적으로 탐구하는 것은 심층 신경망의 성능을 극한까지 끌어올리기 위한 중요한 연구 방향이 될 것이다. 이러한 노력을 통해 우리는 더욱 안정적이고 효율적인 심층 학습 모델을 구축하는 데 한 걸음 더 다가갈 수 있을 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>What is Internal Covariate Shift? - DagsHub, https://dagshub.com/glossary/internal-covariate-shift/</li>
<li>Internal Covariant Shift Problem in Deep Learning - GeeksforGeeks, https://www.geeksforgeeks.org/deep-learning/internal-covariant-shift-problem-in-deep-learning/</li>
<li>[1502.03167] Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift - arXiv, https://arxiv.org/abs/1502.03167</li>
<li>Batch Normalization: Accelerating Deep Network Training by …, https://arxiv.org/pdf/1502.03167</li>
<li>Internal covariate shift - Machine Learning Glossary, https://machinelearning.wtf/terms/internal-covariate-shift/</li>
<li>Detecting Covariate Shift: A Guide to the Multivariate Approach - NannyML, https://www.nannyml.com/blog/detecting-covariate-shift-multivariate-approach</li>
<li>Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift - Google Research, http://research.google.com/pubs/archive/43442.pdf</li>
<li>Understanding Batch Normalization and Internal Covariate Shift. | by …, https://blog.gopenai.com/understanding-batch-normalization-and-internal-covariate-shift-7f652b4d7499</li>
<li>Understanding Covariate Shift &amp; Normalization | by Michael DSouza - Medium, https://medium.com/@mikedsouza/understanding-covariate-shift-batch-normalization-0b0a4f7ba8d7</li>
<li>The Math Behind Batch Normalization | Towards Data Science, https://towardsdatascience.com/the-math-behind-batch-normalization-90ebbc0b1b0b/</li>
<li>Internal Covariate Shift | ML &amp; CV Consultant - Abhik Sarkar, https://www.abhik.xyz/concepts/deep-learning/internal-covariate-shift</li>
<li>Batch Normalization Explained - Lei Mao’s Log Book, https://leimao.github.io/blog/Batch-Normalization/</li>
<li>Batch normalization - Wikipedia, https://en.wikipedia.org/wiki/Batch_normalization</li>
<li>What is Batch Normalization In Deep Learning? - GeeksforGeeks, https://www.geeksforgeeks.org/deep-learning/what-is-batch-normalization-in-deep-learning/</li>
<li>Batch Normalization: Math and Implementation | by Anurag Ghosh | Medium, https://medium.com/@ghoshanurag66/batch-normalization-math-and-implementation-fe06293f7443</li>
<li>kaixih.github.io, <a href="https://kaixih.github.io/batch-norm/#:~:text=Typical%20Batch%20Norm&amp;text=After%20statistics%20computation%2C%20they%20are,the%20momentum%20is%20a%20hyperparameter.">https://kaixih.github.io/batch-norm/#:~:text=Typical%20Batch%20Norm&amp;text=After%20statistics%20computation%2C%20they%20are,the%20momentum%20is%20a%20hyperparameter.</a></li>
<li>Moving Mean and Moving Variance In Batch Normalization - Kaixi Hou’s Log, https://kaixih.github.io/batch-norm/</li>
<li>Review of Ioffe &amp; Szegedy 2015 <em>Batch normalization</em> - neural.vision, https://neural.vision/blog/article-reviews/deep-learning/ioffe-batch-2015/</li>
<li>Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift - Proceedings of Machine Learning Research, https://proceedings.mlr.press/v37/ioffe15.html</li>
<li>The Role of Batch Normalization in CNNs - Viso Suite, https://viso.ai/deep-learning/batch-normalization/</li>
<li>What is Batch Normalization - Deepchecks, https://www.deepchecks.com/glossary/batch-normalization/</li>
<li>Understanding Batch Normalization in Deep Learning: A Beginner’s Guide - Medium, https://medium.com/@piyushkashyap045/understanding-batch-normalization-in-deep-learning-a-beginners-guide-40917c5bebc8</li>
<li>Why Batch Normalization Matters for Deep Learning | Towards Data Science, https://towardsdatascience.com/why-batch-normalization-matters-for-deep-learning-3e5f4d71f567/</li>
<li>Ghost Noise for Regularizing Deep Neural Networks, https://ojs.aaai.org/index.php/AAAI/article/view/29228/30317</li>
<li>[R] Debunking one of the most misunderstood concepts in Deep Learning - Reddit, https://www.reddit.com/r/MachineLearning/comments/8yny9g/r_debunking_one_of_the_most_misunderstood/</li>
<li>Batch normalization for regularization - Improving Deep Neural Networks - DeepLearning.AI, https://community.deeplearning.ai/t/batch-normalization-for-regularization/230911</li>
<li>[1806.02375] Understanding Batch Normalization - arXiv, https://arxiv.org/abs/1806.02375</li>
<li>Understanding Batch Normalization, http://papers.neurips.cc/paper/7996-understanding-batch-normalization.pdf</li>
<li>Does Batch Normalization act as a regularizer when we don’t shuffle the dataset at each epoch? - Cross Validated, https://stats.stackexchange.com/questions/665288/does-batch-normalization-act-as-a-regularizer-when-we-dont-shuffle-the-dataset</li>
<li>Regularization: Batch-normalization and Drop out | by aditi kothiya | Analytics Vidhya, https://medium.com/analytics-vidhya/everything-you-need-to-know-about-regularizer-eb477b0c82ba</li>
<li>Visualizing What Batch Normalization Is and Its Advantages : r/datascience - Reddit, https://www.reddit.com/r/datascience/comments/1aihddg/visualizing_what_batch_normalization_is_and_its/</li>
<li>[2305.17205] Ghost Noise for Regularizing Deep Neural Networks - arXiv, https://arxiv.org/abs/2305.17205</li>
<li>[1803.08494] Group Normalization - arXiv, https://arxiv.org/abs/1803.08494</li>
<li>[1607.06450] Layer Normalization - arXiv, https://arxiv.org/abs/1607.06450</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>