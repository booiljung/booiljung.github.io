<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:회귀 모델 성능 평가 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>회귀 모델 성능 평가 안내서</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">인공지능 평가지표 (AI evaluation metrics)</a> / <span>회귀 모델 성능 평가 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>회귀 모델 성능 평가 안내서</h1>
<h2>1. 서론: 올바른 회귀 모델 평가의 중요성</h2>
<p>본 보고서는 인공지능 회귀 모델의 성능을 평가하는 다각적이고 심층적인 방법론을 제시하는 것을 목표로 한다. 회귀 모델 평가는 단순히 예측 결과에 점수를 부여하는 행위를 넘어, 모델의 신뢰성, 일반화 가능성, 그리고 궁극적으로 비즈니스 가치와 직결되는 핵심적인 진단 과정이다.</p>
<p>현장에서 흔히 발생하는 오류 중 하나는 단일 평가 지표에 의존하여 모델의 우수성을 판단하는 것이다. 그러나 특정 지표는 모델 성능의 한 단면만을 보여줄 뿐이며, 이러한 단편적인 정보에 기반한 의사결정은 모델의 잠재적 결함을 간과하거나 편향된 결론으로 이어질 수 있다. 따라서 예측 모델의 목적과 데이터의 특성을 종합적으로 고려하여 적절한 평가 지표를 선택하고, 여러 지표를 함께 해석하는 통합적 시각이 필수적이다.1</p>
<p>본 보고서는 이러한 문제의식을 바탕으로, 회귀 모델 평가를 위한 통합적 프레임워크를 제안한다. 보고서는 총 4부로 구성된다. 제1부와 제2부에서는 각각 예측 오차의 크기와 모델의 설명력을 측정하는 핵심적인 정량적 평가 지표들을 심도 있게 분석한다. 제3부에서는 수치만으로는 파악할 수 없는 모델의 구조적 타당성을 진단하는 질적 평가 방법론인 잔차 분석을 다룬다. 마지막으로 제4부에서는 모델이 학습 데이터에만 과적합되지 않고 새로운 데이터에 대해서도 안정적인 성능을 보일지를 검증하는 교차 검증의 원리와 기법을 상세히 설명한다. 이를 통해 독자는 회귀 모델을 평가하는 기술적 깊이를 더하고, 신뢰도 높은 모델을 구축하기 위한 견고한 이론적 토대를 마련할 수 있을 것이다.</p>
<h2>2.  예측 오차의 정량적 측정</h2>
<p>이 장에서는 모델의 예측 값이 실제 값으로부터 얼마나 벗어났는지를 수치적으로 측정하는 핵심 지표들을 다룬다. 각 지표는 오차를 바라보는 서로 다른 관점을 반영하며, 이는 모델의 학습 과정(손실 함수 선택)과 최종 평가 결과에 지대한 영향을 미친다.</p>
<h3>2.1  MAE (Mean Absolute Error): 직관적 오차의 평균</h3>
<h4>2.1.1 개념 정의</h4>
<p>MAE(평균 절대 오차)는 실제 값과 예측 값의 차이, 즉 오차(error)의 절댓값에 대한 산술 평균이다. 이는 예측 오차가 평균적으로 어느 정도의 크기를 갖는지 가장 직관적으로 보여주는 지표다.2</p>
<h4>2.1.2 수학적 공식</h4>
<p><code>n</code>개의 데이터 포인트에 대해, 실제 값 <span class="math math-inline">y_i</span>와 예측 값 <span class="math math-inline">\hat{y}_i</span>가 주어졌을 때 MAE는 다음과 같이 정의된다.<br />
<span class="math math-display">
\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} \vert y_i - \hat{y}_i \vert
</span></p>
<h4>2.1.3 해석</h4>
<p>MAE 값은 원래 데이터의 스케일과 동일한 단위를 갖는다. 예를 들어, 주택 가격(단위: 억 원)을 예측하는 모델의 MAE가 0.5라면, 이는 해당 모델이 평균적으로 0.5억 원(5,000만 원)의 예측 오차를 보인다고 해석할 수 있다. 이러한 직관성 덕분에 성능 지표에 익숙하지 않은 비전문가나 현업 담당자에게 모델의 성능을 설명하기 매우 용이하다.2</p>
<h4>2.1.4 장점</h4>
<ul>
<li>
<p><strong>이상치에 대한 견고함 (Robustness):</strong> 오차를 제곱하지 않고 절댓값만 취하기 때문에, MSE나 RMSE에 비해 극단적인 값, 즉 이상치(outlier)의 영향을 덜 받는다. 따라서 데이터에 이상치가 존재하더라도 전체적인 오차 수준을 안정적으로 평가할 수 있다.3</p>
</li>
<li>
<p><strong>해석의 용이성:</strong> 지표 자체가 실제 오차의 평균 크기를 의미하므로 매우 직관적이다.2</p>
</li>
</ul>
<h4>2.1.5 단점</h4>
<ul>
<li>
<p><strong>스케일 의존성 (Scale Dependency):</strong> 측정 대상의 단위에 따라 값의 크기가 달라진다. 예를 들어, 100만 원 단위의 주가 예측 모델과 10만 원 단위의 주가 예측 모델에서 동일하게 MAE가 5,000이 나왔다고 해도, 두 모델의 오차율은 전혀 다르다. 이처럼 서로 다른 스케일을 가진 모델들의 성능을 MAE 값만으로 직접 비교하기는 어렵다.2</p>
</li>
<li>
<p><strong>최적화의 어려움:</strong> 오차가 0이 되는 지점(<span class="math math-inline">y_i = \hat{y}_i</span>)에서 절댓값 함수는 뾰족한 형태를 가져 미분이 불가능하다. 이로 인해 경사 하강법(Gradient Descent)과 같은 최적화 알고리즘을 손실 함수로 사용할 경우, 최적점에 가까워져도 기울기(gradient)가 일정하게 유지되어 최적점을 지나치며 진동하는 등 수렴에 어려움을 겪을 수 있다.3</p>
</li>
</ul>
<p>MAE의 선택은 ’해석의 용이성’과 ’이상치에 대한 견고함’을 우선시하겠다는 전략적 결정이다. 이는 모델 학습 시 손실 함수 선택에 있어 ’최적화의 안정성’을 일부 포기할 수 있다는 점을 내포한다. 이처럼 평가 지표와 손실 함수는 별개의 개념이 아니라, 모델의 특성을 결정하는 데 있어 깊이 연관되어 있음을 이해하는 것이 중요하다.</p>
<h3>2.2  MSE (Mean Squared Error): 오차 제곱을 통한 페널티 강화</h3>
<h4>2.2.1 개념 정의</h4>
<p>MSE(평균 제곱 오차)는 오차를 제곱한 값의 산술 평균으로, 회귀 모델 평가에서 가장 널리 사용되는 지표 중 하나다.2</p>
<h4>2.2.2 수학적 공식</h4>
<p><span class="math math-display">
\text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2
</span></p>
<h4>2.2.3 해석</h4>
<p>MSE는 오차를 제곱하기 때문에, 오차의 크기가 클수록 페널티를 기하급수적으로 부여한다. 예를 들어 오차가 2인 경우와 10인 경우, MAE에서는 5배 차이지만 MSE에서는 25배(<span class="math math-inline">10^2 / 2^2</span>)의 차이로 평가된다. 따라서 MSE를 최소화하도록 학습된 모델은 큰 실수를 피하는 방향으로 최적화된다.3</p>
<h4>2.2.4 장점</h4>
<ul>
<li>
<p><strong>수학적 용이성:</strong> 오차에 대한 손실 함수가 모든 지점에서 미분 가능한 볼록 함수(convex function) 형태를 띠므로, 경사 하강법을 사용하여 최적 해를 안정적으로 찾기 용이하다.3</p>
</li>
<li>
<p><strong>큰 오차에 대한 민감성:</strong> 예측 값이 실제 값과 매우 큰 차이를 보이는 경우에 민감하게 반응한다. 따라서 큰 오차가 치명적인 손실을 유발하는 문제(예: 금융 리스크 예측, 의료 장비의 안전성 예측)에 적합하다.6</p>
</li>
</ul>
<h4>2.2.5 단점</h4>
<ul>
<li>
<p><strong>이상치에 대한 과도한 민감성:</strong> 큰 오차에 민감하다는 특성은 단점이 되기도 한다. 데이터에 이상치가 존재할 경우, 해당 오차의 제곱 값이 전체 MSE를 크게 왜곡시켜 모델의 전반적인 성능을 실제보다 비관적으로 평가하게 만들 수 있다.3</p>
</li>
<li>
<p><strong>단위 왜곡:</strong> 오차를 제곱하므로 원래 데이터의 단위와 달라져 직관적인 해석이 어렵다. 예를 들어, 주택 가격(단위: 억 원) 예측 모델의 MSE 단위는 ’억 원의 제곱’이 되어, 이 수치만으로 실제 오차의 크기를 가늠하기 힘들다.2</p>
</li>
<li>
<p><strong>값의 왜곡:</strong> 오차가 1보다 작으면 제곱으로 인해 원래 오차보다 더 작아지고, 1보다 크면 더 커지는 왜곡이 발생한다. 이로 인해 작은 오차들이 모델 평가에 미치는 영향이 과소평가될 수 있다.5</p>
</li>
</ul>
<h3>2.3  RMSE (Root Mean Squared Error): MSE의 실용적 변환</h3>
<h4>2.3.1 개념 정의</h4>
<p>RMSE(평균 제곱근 오차)는 MSE에 제곱근을 취한 값이다. 이는 MSE의 단점인 단위 왜곡 문제를 해결하면서도, MSE의 핵심적인 특성을 유지하기 위해 고안되었다.2</p>
<h4>2.3.2 수학적 공식</h4>
<p><span class="math math-display">
\text{RMSE} = \sqrt{\text{MSE}} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2}
</span></p>
<h4>2.3.3 해석</h4>
<p>RMSE는 MSE와 마찬가지로 큰 오차에 민감하게 반응하지만, 결과 값의 단위가 실제 값의 단위와 동일해진다. 따라서 오차의 크기를 MAE처럼 직관적으로 해석할 수 있는 장점을 가진다.2</p>
<h4>2.3.4 장점</h4>
<ul>
<li>
<p><strong>단위 해석의 직관성:</strong> 결과 값을 실제 데이터의 단위로 해석할 수 있어 실용적이다. 예를 들어, RMSE가 0.5억 원이라면 이는 모델의 예측이 평균적으로 실제 값과 약 0.5억 원 정도의 차이를 보인다고 이해할 수 있다.2</p>
</li>
<li>
<p><strong>MSE 특성 유지:</strong> MSE의 장점인 수학적 용이성과 큰 오차에 대한 민감성을 그대로 유지한다.</p>
</li>
</ul>
<h4>2.3.5 단점</h4>
<ul>
<li><strong>이상치 민감성:</strong> MSE에 기반하므로 여전히 이상치에 민감하다. MAE에 비해서는 이상치의 영향을 더 크게 받는다.3</li>
</ul>
<h2>3.  모델의 설명력 평가</h2>
<p>이 장에서는 모델이 데이터의 변동성을 얼마나 잘 설명하는지를 평가하는 지표를 다룬다. 이는 오차의 절대적인 크기를 넘어, 모델이 데이터에 내재된 패턴을 얼마나 효과적으로 포착했는지를 상대적으로 평가하는 데 중점을 둔다.</p>
<h3>3.1  R² (결정계수, R-squared): 분산 기반 설명력의 측정</h3>
<h4>3.1.1 개념 정의</h4>
<p>결정계수(R-squared 또는 R²)는 종속 변수(y)의 총 변동성 중에서 회귀 모델에 의해 설명되는 변동성의 비율을 나타낸다. 다시 말해, 모델이 데이터의 분산을 얼마나 잘 설명하는지를 나타내는 상대적인 지표다.7</p>
<h4>3.1.2 수학적 공식</h4>
<p>R²는 총 제곱합(SST)에 대한 회귀 제곱합(SSR)의 비율로 계산되거나, 1에서 총 제곱합에 대한 잔차 제곱합(SSE)의 비율을 빼서 계산할 수 있다.</p>
<p><span class="math math-display">
R^2 = \frac{\text{SSR}}{\text{SST}} = 1 - \frac{\text{SSE}}{\text{SST}}
</span><br />
여기서 각 항은 다음과 같이 정의된다 7:</p>
<ul>
<li>
<p><strong>총 제곱합 (Total Sum of Squares, SST):</strong> <span class="math math-inline">\sum_{i=1}^{n} (y_i - \bar{y})^2</span>. 각 실제 값이 종속 변수의 전체 평균에서 얼마나 떨어져 있는지를 나타내며, 데이터의 총 변동량을 의미한다.</p>
</li>
<li>
<p><strong>회귀 제곱합 (Sum of Squares due to Regression, SSR):</strong> <span class="math math-inline">\sum_{i=1}^{n} (\hat{y}_i - \bar{y})^2</span>. 모델의 예측 값이 전체 평균에서 얼마나 떨어져 있는지를 나타내며, 모델에 의해 설명된 변동량을 의미한다.</p>
</li>
<li>
<p><strong>잔차 제곱합 (Sum of Squares of Errors, SSE):</strong> <span class="math math-inline">\sum_{i=1}^{n} (y_i - \hat{y}_i)^2</span>. 실제 값과 예측 값의 차이(잔차)의 제곱합으로, 모델이 설명하지 못하는 변동량을 의미한다.</p>
</li>
</ul>
<h4>3.1.3 해석</h4>
<ul>
<li>
<p>R²는 일반적으로 0과 1 사이의 값을 가진다. 1에 가까울수록 모델이 데이터의 변동성을 완벽하게 설명함을 의미하고, 0에 가까울수록 설명력이 없음을 의미한다.10</p>
</li>
<li>
<p>만약 R²가 0.7이라면, 이는 종속 변수 분산의 70%를 해당 모델이 설명하고 있으며, 나머지 30%는 모델이 설명하지 못하는 오차에 해당한다고 해석할 수 있다.9</p>
</li>
<li>
<p><strong>음수 값의 가능성:</strong> 드물게 R²가 음수가 나올 수도 있다. 이는 모델의 예측 성능이 단순히 데이터의 평균값으로 예측하는 것보다도 못하다는 것을 의미한다. 즉, 모델이 데이터의 패턴을 전혀 학습하지 못하고 오히려 예측을 악화시키고 있음을 시사한다.7</p>
</li>
</ul>
<h4>3.1.4 장점</h4>
<ul>
<li><strong>상대적 성능 비교:</strong> MAE, MSE 등과 달리 결과 값이 데이터의 스케일에 의존하지 않는 0과 1 사이의 표준화된 값을 갖는다. 따라서 서로 다른 데이터셋이나 다른 스케일의 변수를 사용하는 모델들의 설명력을 직관적으로 비교하는 데 매우 용이하다.5</li>
</ul>
<h4>3.1.5 단점</h4>
<ul>
<li><strong>독립변수 개수에 대한 맹점:</strong> R²의 치명적인 단점은 모델에 유의미하지 않은 독립변수가 추가되어도 그 값이 항상 증가하거나 최소한 유지된다는 점이다. SSE는 변수가 추가될수록 감소하거나 유지될 수밖에 없기 때문이다. 이는 모델의 복잡도가 불필요하게 증가하고 과적합(overfitting)될 위험이 있음에도 불구하고, R² 값만 보면 성능이 개선된 것처럼 보이는 착시를 유발할 수 있다.9</li>
</ul>
<h3>3.2  Adjusted R² (조정된 결정계수): 변수의 개수를 고려한 보정</h3>
<h4>3.2.1 개념 정의</h4>
<p>조정된 결정계수(Adjusted R²)는 R²가 독립변수의 개수가 늘어날수록 증가하는 경향을 보이는 단점을 보완하기 위해 고안된 지표다. 불필요한 변수가 모델에 추가될 경우 페널티를 부여하여 R² 값을 보정한다.10</p>
<h4>3.2.2 수학적 공식</h4>
<p>조정된 R²는 표본의 수(<span class="math math-inline">n</span>)와 독립변수의 개수(<span class="math math-inline">k</span>)를 함께 고려하여 계산된다.</p>
<p><span class="math math-display">
\text{Adjusted } R^2 = 1 - \frac{(1-R^2)(n-1)}{n-k-1}
</span><br />
여기서 분모의 <span class="math math-inline">n-k-1</span> 항은 자유도(degrees of freedom)를 반영하며, 독립변수 <span class="math math-inline">k</span>가 증가할수록 분모가 작아져 전체 값이 감소하는 방식으로 페널티를 부과한다.7</p>
<h4>3.2.3 해석</h4>
<ul>
<li>
<p>유의미한 설명력을 가진 변수가 추가될 때는 조정된 R² 값이 증가하지만, 모델 성능에 기여하지 못하는 무의미한 변수가 추가되면 오히려 감소할 수 있다. 따라서 조정된 R²는 모델의 설명력과 함께 간결성(parsimony)까지 고려한 지표라고 할 수 있다.14</p>
</li>
<li>
<p>이러한 특성 때문에, 독립변수의 개수가 서로 다른 여러 다중 회귀 모델의 설명력을 객관적으로 비교하고자 할 때는 반드시 조정된 R²를 사용해야 한다.17</p>
</li>
</ul>
<h4>3.2.4 장점</h4>
<ul>
<li>
<p><strong>객관적인 모델 비교:</strong> 독립변수의 개수가 다른 모델들을 비교할 때 R²보다 훨씬 신뢰할 수 있는 기준을 제공한다.</p>
</li>
<li>
<p><strong>과적합 방지 지표:</strong> R²와 조정된 R²의 값 차이가 크다면, 이는 모델에 불필요한 변수가 다수 포함되어 과적합되었을 가능성을 시사하는 중요한 단서가 된다.</p>
</li>
</ul>
<h4>3.2.5 단점</h4>
<ul>
<li>R²와 마찬가지로 설명력의 상대적인 크기를 나타낼 뿐, 모델 예측의 절대적인 정확도를 직접적으로 보장하지는 않는다.</li>
</ul>
<p>R²와 조정된 R²의 관계는 모델의 ’설명력’과 ‘간결성’ 사이의 균형을 보여주는 중요한 바로미터 역할을 한다. 새로운 변수를 모델에 추가했을 때 R²는 증가했지만 조정된 R²가 감소했다면, 이는 해당 변수가 추가됨으로써 얻는 설명력의 이득보다 모델 복잡도 증가로 인한 손실이 더 크다는 명확한 신호다. 따라서 두 지표를 함께 분석하는 것은 단순히 더 높은 점수를 찾는 과정이 아니라, 모델의 설명력과 효율성 및 일반화 가능성 사이의 최적 균형점을 찾는 정교한 분석 과정임을 의미한다.</p>
<h2>4.  종합적 평가를 위한 심화 분석</h2>
<p>정량적 수치만으로는 모델의 모든 측면을 파악할 수 없다. 이 장에서는 주어진 문제 상황에 맞는 지표를 선택하는 전략을 제시하고, 모델의 근본적인 통계적 가정을 진단하는 질적 평가 방법을 통해 평가의 깊이를 더한다.</p>
<h3>4.1  평가 지표 선택을 위한 전략적 가이드</h3>
<p>최적의 평가 지표는 문제의 종류와 데이터의 특성, 그리고 비즈니스 목표에 따라 달라진다.</p>
<ul>
<li>
<p><strong>이상치의 존재 여부:</strong> 데이터에 제거하기 어려운 이상치가 많고, 이 이상치에 모델이 과민 반응하는 것을 원치 않는다면 MAE가 더 적합하다. 반면, 큰 오차를 반드시 탐지하고 이를 최소화하는 것이 중요한 미션 크리티컬한 시스템(예: 발전소 고장 예측)에서는 RMSE가 더 나은 선택이 될 수 있다.3</p>
</li>
<li>
<p><strong>비즈니스 목표:</strong> 과대 예측과 과소 예측의 비용이 비대칭적인 경우, 단순 오차 지표만으로는 부족하다. 예를 들어, 상품 수요 예측에서 과소 예측은 판매 기회 손실을, 과대 예측은 재고 및 폐기 비용 증가를 의미한다. 이러한 경우, 비즈니스 손실을 반영하는 맞춤형 비용 함수를 직접 정의하여 평가하거나, 특정 분위수를 예측하는 분위수 회귀(Quantile Regression)와 같은 다른 접근법을 고려해야 한다.</p>
</li>
<li>
<p><strong>모델 비교 vs. 절대 성능 평가:</strong> 여러 모델의 상대적 우위를 비교하고 싶을 때는 스케일에 독립적인 R²나 조정된 R²가 유용하다. 반면, 모델의 절대적인 예측 오차 크기를 비즈니스 관점에서 이해하고 전달하고 싶을 때는 실제 단위로 해석 가능한 RMSE나 MAE가 더 적합하다.5</p>
</li>
</ul>
<p>다음 표는 본 보고서에서 다룬 핵심적인 정량적 평가지표들의 특성을 요약하고, 실무자가 특정 상황에 가장 적합한 지표를 신속하게 선택할 수 있도록 돕는 의사결정 도구다.</p>
<table><thead><tr><th>평가지표</th><th>수식</th><th>핵심 개념</th><th>이상치 민감도</th><th>스케일 의존성</th><th>주요 활용 사례</th></tr></thead><tbody>
<tr><td><strong>MAE</strong></td><td><span class="math math-inline">\frac{1}{n} \sum \vert y_i - \hat{y}_i \vert</span></td><td>오차 절댓값의 평균</td><td>낮음 (Robust)</td><td>높음</td><td>오차의 직관적 해석이 중요하고, 이상치의 영향이 적어야 할 때</td></tr>
<tr><td><strong>MSE</strong></td><td><span class="math math-inline">\frac{1}{n} \sum (y_i - \hat{y}_i)^2</span></td><td>오차 제곱의 평균</td><td>매우 높음</td><td>높음</td><td>큰 오차에 강한 페널티를 부여해야 하는 경우, 최적화 손실 함수</td></tr>
<tr><td><strong>RMSE</strong></td><td><span class="math math-inline">\sqrt{\frac{1}{n} \sum (y_i - \hat{y}_i)^2}</span></td><td>오차 제곱 평균의 제곱근</td><td>높음</td><td>높음</td><td>오차를 실제 단위로 해석하면서 큰 오차에 페널티를 주고 싶을 때</td></tr>
<tr><td><strong>R²</strong></td><td><span class="math math-inline">1 - \frac{\text{SSE}}{\text{SST}}</span></td><td>총 분산 중 모델이 설명하는 분산의 비율</td><td>중간</td><td>없음</td><td>모델의 상대적인 설명력을 비교하고 싶을 때 (단순 회귀)</td></tr>
<tr><td><strong>Adj. R²</strong></td><td><span class="math math-inline">1 - \frac{(1-R^2)(n-1)}{n-k-1}</span></td><td>변수 개수를 고려하여 보정된 설명력</td><td>중간</td><td>없음</td><td>변수 개수가 다른 모델들의 설명력을 객관적으로 비교할 때 (다중 회귀)</td></tr>
</tbody></table>
<h3>4.2  잔차 분석: 모델의 가정을 진단하는 질적 평가</h3>
<h4>4.2.1 잔차(Residual)의 정의와 중요성</h4>
<p>잔차 <span class="math math-inline">e_i = y_i - \hat{y}_i</span>는 실제 값과 모델의 예측 값 사이의 차이로, 모델이 데이터의 패턴을 얼마나 잘 포착했는지에 대한 풍부한 정보를 담고 있다.18 잔차 분석은 선형 회귀 모델이 통계적으로 유의미하기 위해 만족해야 하는 기본 가정(선형성, 등분산성, 정규성, 독립성)이 충족되었는지 시각적으로 진단하는 필수 과정이다. 만약 이 가정들이 심각하게 위배된다면, 회귀 계수의 신뢰도가 떨어지고 모델의 예측 성능을 신뢰할 수 없게 된다.21 정량적 지표가 모델 성능의 ’결과’를 보여준다면, 잔차 분석은 그 ’원인’을 파헤치는 진단 도구와 같다.</p>
<h4>4.2.2 선형성(Linearity) 검증</h4>
<ul>
<li>
<p><strong>방법:</strong> 잔차-예측값 도표(Residuals vs. Fitted Plot)를 그려 확인한다.24</p>
</li>
<li>
<p><strong>해석:</strong> 이상적인 경우, 잔차들은 예측값의 크기와 무관하게 0을 중심으로 특별한 패턴 없이 무작위로 흩어져 있어야 한다. 만약 잔차들이 뚜렷한 패턴(예: U자 형태의 곡선)을 보인다면, 이는 모델이 데이터의 비선형 관계를 제대로 포착하지 못했음을 의미한다. 잔차의 추세를 나타내는 선(붉은 실선)이 수평선(y=0)에서 크게 벗어나지 않아야 선형성 가정이 만족된다고 볼 수 있다.21</p>
</li>
</ul>
<h4>4.2.3 등분산성(Homoscedasticity) 검증</h4>
<ul>
<li>
<p><strong>방법:</strong> 척도-위치 도표(Scale-Location Plot) 또는 잔차-예측값 도표를 사용한다.</p>
</li>
<li>
<p><strong>해석:</strong> 예측값의 크기와 상관없이 잔차의 분산이 일정해야 한다는 가정이다. 만약 예측값이 커짐에 따라 잔차의 흩어짐 정도가 체계적으로 커지거나 작아지는 깔때기 형태를 보인다면, 등분산성 가정이 위배된 것이다. 이 경우에도 추세선이 수평에 가까워야 가정이 충족된다고 판단한다.24</p>
</li>
</ul>
<h4>4.2.4 정규성(Normality) 검증</h4>
<ul>
<li>
<p><strong>방법:</strong> Q-Q 도표(Normal Q-Q Plot)를 통해 시각적으로 확인한다.</p>
</li>
<li>
<p><strong>해석:</strong> 잔차가 정규분포를 따른다면, Q-Q 도표의 점들이 대각선 형태의 기준선 위에 거의 일직선으로 분포해야 한다. 점들이 기준선에서 체계적으로 벗어난다면(예: S자 형태), 잔차의 분포가 정규분포를 따르지 않음을 의심할 수 있다.24</p>
</li>
</ul>
<h4>4.2.5 독립성(Independence) 검증</h4>
<ul>
<li>
<p><strong>방법:</strong> 더빈-왓슨(Durbin-Watson) 통계량을 확인한다. 이 가정은 특히 시계열 데이터에서 잔차 간의 자기상관을 확인하는 데 중요하다.</p>
</li>
<li>
<p><strong>해석:</strong> 더빈-왓슨 통계량은 0에서 4 사이의 값을 가진다. 값이 2에 가까우면 잔차 간에 자기상관이 없어 독립성 가정을 만족한다. 0에 가까우면 양의 자기상관, 4에 가까우면 음의 자기상관을 의심할 수 있다.24 잔차에 자기상관이 존재하면 모델의 통계적 유의성이 왜곡될 수 있다.18</p>
</li>
</ul>
<p>잔차 분석에서 위와 같은 가정 위배가 발견되면, 아무리 R² 값이 높더라도 그 모델의 신뢰성은 떨어진다.9 패턴이 보이는 잔차는 모델이 아직 설명하지 못한 체계적인 정보가 데이터에 남아있다는 명백한 신호이며, 이는 모델 개선의 방향(예: 변수 변환, 다항식 항 추가, 상호작용 항 고려)을 제시해주는 중요한 단서가 된다.</p>
<h2>5.  모델의 일반화 능력 검증</h2>
<p>모델 평가의 궁극적인 목적은 학습에 사용된 데이터가 아닌, 앞으로 마주할 새로운 데이터에 대해 얼마나 잘 예측하는지를 가늠하는 것이다. 이 장에서는 모델의 일반화 능력을 신뢰성 있게 평가하는 핵심 방법론인 교차 검증을 다룬다.</p>
<h3>5.1  과적합 문제와 교차 검증의 필요성</h3>
<h4>5.1.1 과적합(Overfitting)의 정의</h4>
<p>과적합이란 모델이 훈련 데이터에만 과도하게 최적화되어, 훈련 데이터에 대한 성능은 매우 높지만 새로운 데이터(검증 또는 테스트 데이터)에 대한 성능은 현저히 떨어지는 현상을 의미한다.25 이는 모델이 데이터의 근본적인 패턴을 학습한 것이 아니라, 훈련 데이터에만 존재하는 노이즈까지 암기했기 때문에 발생한다.</p>
<h4>5.1.2 교차 검증의 필요성</h4>
<p>모델의 진정한 가치는 일반화 성능, 즉 ’표본 외 성능(out-of-sample performance)’에 있다. 교차 검증은 이 일반화 성능을 측정하기 위한 필수적인 절차다. 주어진 데이터를 훈련용과 검증용으로 반복적으로 나누어, 훈련에 사용되지 않은 데이터로 모델을 평가함으로써 과적합을 탐지하고 방지하는 역할을 한다.26</p>
<h4>5.1.3 데이터 분할의 원리</h4>
<p>가장 기본적인 접근법은 전체 데이터를 훈련(Training), 검증(Validation), 테스트(Test) 세트로 분할하는 것이다. 훈련 세트는 모델의 파라미터를 학습하는 데 사용되고, 검증 세트는 학습된 여러 모델 중 최적의 하이퍼파라미터를 찾거나 모델을 선택하는 데 사용된다. 테스트 세트는 최종적으로 선택된 모델의 일반화 성능을 단 한 번 평가하기 위해 사용되며, 모델 개발 과정에서는 절대 참조해서는 안 된다.27</p>
<h3>5.2  K-Fold 교차 검증 (K-Fold Cross-Validation)</h3>
<p>데이터의 양이 충분하지 않을 경우, 훈련/검증/테스트로 한 번만 분할하는 방식은 분할 방식에 따라 성능 평가 결과가 크게 달라질 수 있는 불안정성을 내포한다. K-Fold 교차 검증은 이러한 문제를 해결하고 데이터를 보다 효율적으로 사용하기 위한 표준적인 기법이다.</p>
<h4>5.2.1 수행 절차</h4>
<ol>
<li>
<p>전체 훈련 데이터를 무작위로 K개의 동일한 크기의 부분집합(fold)으로 나눈다.</p>
</li>
<li>
<p>첫 번째 fold를 검증 세트로 사용하고, 나머지 K-1개의 fold를 훈련 세트로 사용하여 모델을 학습시키고 성능을 평가한다.</p>
</li>
<li>
<p>두 번째 fold를 검증 세트로, 나머지 K-1개를 훈련 세트로 사용하여 두 번째 모델을 학습하고 평가한다.</p>
</li>
<li>
<p>이 과정을 K번 반복하여, 모든 fold가 정확히 한 번씩 검증 세트로 사용되도록 한다.</p>
</li>
<li>
<p>K번의 평가를 통해 얻은 K개의 성능 점수를 산술 평균하여 모델의 최종 성능 지표로 삼는다.26</p>
</li>
</ol>
<h4>5.2.2 장점</h4>
<ul>
<li>
<p><strong>데이터의 효율적 활용:</strong> 모든 데이터가 훈련과 검증에 한 번씩 사용되므로, 데이터를 한 번만 분할하는 방식보다 모델의 성능을 더 안정적이고 신뢰성 있게 추정할 수 있다. 특히 데이터의 양이 적을 때 매우 유용하다.29</p>
</li>
<li>
<p><strong>안정적인 성능 추정:</strong> 데이터 분할 방식에 따른 성능의 우연성 및 변동성을 줄여준다.26</p>
</li>
</ul>
<h4>5.2.3 단점</h4>
<ul>
<li>모델을 K번 학습하고 평가해야 하므로, 한 번만 학습하는 것에 비해 계산 비용이 K배로 증가한다.29</li>
</ul>
<h4>5.2.4 다양한 교차 검증 기법</h4>
<ul>
<li>
<p><strong>Stratified K-Fold:</strong> 불균형한 데이터에서 각 fold의 클래스 비율을 원본 데이터와 동일하게 유지하는 방식이다. 주로 분류 문제에 사용되지만, 회귀 문제에서도 타겟 변수의 분포가 특정 구간에 쏠려 있을 경우 응용할 수 있다.29</p>
</li>
<li>
<p><strong>Leave-One-Out CV (LOOCV):</strong> K가 데이터 포인트의 수(<span class="math math-inline">n</span>)와 같은 극단적인 K-Fold 교차 검증이다. 데이터가 아주 적을 때 편향이 적은 성능 추정치를 얻을 수 있지만, 계산 비용이 매우 높다.26</p>
</li>
<li>
<p><strong>Time Series Split:</strong> 시계열 데이터에서 미래의 데이터로 과거를 예측하는 데이터 누수(data leakage)를 방지하기 위해, 훈련 세트는 항상 검증 세트보다 시간적으로 앞서도록 데이터를 분할하는 방식이다.29</p>
</li>
</ul>
<p>교차 검증은 모델의 성능을 단일 점수로 제시하는 것을 넘어선다. K-Fold 교차 검증을 수행하면 K개의 성능 점수 분포를 얻게 되는데, 이 분포의 평균은 모델 성능에 대한 더 강건한 추정치(robust estimate)가 된다. 더 나아가, 이 점수들의 표준편차를 계산하면 모델 성능의 변동성, 즉 안정성을 파악할 수 있다. 따라서 교차 검증은 “이 모델의 점수는 85점이다“라고 단정적으로 말하는 대신, “이 모델의 기대 성능은 평균 85점이며, 데이터 분할에 따라 약 ±3점 정도 변동할 수 있다“는 훨씬 더 정교하고 신뢰도 높은 정보를 제공한다. 이는 모델이 실제 운영 환경에서 보일 성능을 예측하는 데 매우 중요한 분석이다.</p>
<h2>6. 결론: 신뢰도 높은 회귀 모델을 위한 종합 제언</h2>
<p>성공적인 회귀 모델링은 단일 지표의 최적화를 넘어, 다각적인 관점에서 모델을 평가하고 진단하는 통합적 접근법을 요구한다. 본 보고서에서 제시한 내용을 바탕으로, 신뢰도 높은 회귀 모델 구축을 위한 종합적인 평가 프레임워크를 다음과 같이 제안한다.</p>
<ol>
<li>
<p><strong>정량적 정확성 (Quantitative Accuracy):</strong> MAE, RMSE, 조정된 R² 등 비즈니스 목표와 데이터 특성에 맞는 정량적 지표를 통해 모델의 예측 오차와 설명력을 객관적으로 측정해야 한다.</p>
</li>
<li>
<p><strong>질적 타당성 (Qualitative Validity):</strong> 잔차 분석을 통해 모델의 선형성, 등분산성, 정규성, 독립성 등 통계적 기본 가정이 충족되었는지 반드시 진단해야 한다. 이는 모델의 구조적 문제를 파악하고 개선 방향을 설정하는 데 결정적인 역할을 한다.</p>
</li>
<li>
<p><strong>일반화 능력 (Generalization Capability):</strong> K-Fold 교차 검증과 같은 엄격한 검증 절차를 통해 모델이 학습 데이터에 과적합되지 않고, 새로운 데이터에 대해서도 안정적인 성능을 보일 것인지 신뢰성 있게 검증해야 한다.</p>
</li>
</ol>
<p>최고의 모델은 단일 지표에서 가장 높은 점수를 받은 모델이 아니다. 비즈니스 목표에 부합하고, 통계적 가정을 만족하며, 일반화 성능이 안정적인 모델이 진정으로 우수한 모델이다. 모델 평가는 일회성으로 끝나는 과정이 아니라, 평가 과정에서 발견된 통찰을 바탕으로 모델을 반복적으로 개선해 나가는 순환적 과정임을 인지하는 것이 무엇보다 중요하다. 이러한 통합적이고 비판적인 평가 자세를 견지할 때, 비로소 신뢰할 수 있고 실질적인 가치를 창출하는 인공지능 회귀 모델을 구축할 수 있을 것이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>[머신러닝] 회귀 : 모델 성능 평가(R2-Score, MAE, MSE, RMSE, MSLE, RMSLE…), <a href="https://allensdatablog.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%ED%9A%8C%EA%B7%80-%EB%AA%A8%EB%8D%B8-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80R2-Score-MAE-MSE-RMSE-MSLE-RMSLE">https://allensdatablog.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%ED%9A%8C%EA%B7%80-%EB%AA%A8%EB%8D%B8-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80R2-Score-MAE-MSE-RMSE-MSLE-RMSLE</a></li>
<li>회귀 모델에 대한 성능 평가 지표들 - 하나씩 점을 찍어 나가며 - 티스토리, https://dailyheumsi.tistory.com/167</li>
<li>[ML] 머신러닝 평가지표 - 회귀 모델 MSE, RMSE, MAE - DataPilots, https://datapilots.tistory.com/42</li>
<li>회귀(regression) 모델 성능 지표 (MAE, MSE, RMSE, R2 score) - 공기반코딩반 - 티스토리, https://min23th.tistory.com/25</li>
<li>회귀 모델 성능 평가 지표(MAE, MSE, RMSE, MAPE 등) - Note, https://white-joy.tistory.com/10</li>
<li>[ML] 회귀 모델 성능 평가 지표 개념과 파이썬 코드 (MAE,MSE,RMSE,R2,MAPE,MPE), https://sseozytank.tistory.com/25</li>
<li>[Python] 결정계수 R2 score(R-squared)와 조정된 결정계수(Adjusted R-squared)의 이해, https://aliencoder.tistory.com/34</li>
<li>[회귀분석] 결정계수(R²; Coefficient of Determination) - 간토끼 DataMining Lab - 티스토리, https://datalabbit.tistory.com/54</li>
<li>[회귀분석] 단순선형회귀분석(Linear Regression)(7) - R-squared (R^2)(결정계수) (SST/SSR/SSE/Adjusted R-squared) - YSY의 데이터분석 블로그, https://ysyblog.tistory.com/168</li>
<li>모델의 적합성과 결정 계수 (Accuracy Measure) - 영구노트 - 티스토리, https://satlab.tistory.com/11</li>
<li>회귀분석 결과의 해석과 R²(설명력,결정계수)의 의미, 그리고 R²은 상관계수의 제곱. 응?, <a href="https://recipesds.tistory.com/entry/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D-%EA%B2%B0%EA%B3%BC%EC%9D%98-%ED%95%B4%EC%84%9D%EA%B3%BC-R%C2%B2%EC%84%A4%EB%AA%85%EB%A0%A5%EC%9D%98-%EC%9D%98%EB%AF%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-R%EC%9D%80-%EC%83%81%EA%B4%80%EA%B3%84%EC%88%98%EC%9D%98-%EC%A0%9C%EA%B3%B1-%EC%9D%91">https://recipesds.tistory.com/entry/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D-%EA%B2%B0%EA%B3%BC%EC%9D%98-%ED%95%B4%EC%84%9D%EA%B3%BC-R%C2%B2%EC%84%A4%EB%AA%85%EB%A0%A5%EC%9D%98-%EC%9D%98%EB%AF%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-R%EC%9D%80-%EC%83%81%EA%B4%80%EA%B3%84%EC%88%98%EC%9D%98-%EC%A0%9C%EA%B3%B1-%EC%9D%91</a></li>
<li>회귀분석 평가지표 종류(특징, 장단점, 파이썬 코드) - 컴퓨터하는 상어, https://csshark.tistory.com/66</li>
<li>Coefficient of Determination(결정계수), R^2(R square) - New Sight - 티스토리, https://newsight.tistory.com/259</li>
<li>(번역) 29가지 통계 개념 - 수정된 R제곱 무엇에 사용하는 것인가?, https://chukycheese.github.io/statistics/adjusted-r2/</li>
<li>Linear Regression (선형 회귀) - 7 | Adjusted R-Squared (수정된 결정 계수) - Channi Studies, https://code-studies.tistory.com/97</li>
<li>[결정계수] R square와 adjusted R square - one of a kind scene - 티스토리, https://specialscene.tistory.com/63</li>
<li>회귀, <a href="https://rnarnie.tistory.com/entry/%ED%9A%8C%EA%B7%80">https://rnarnie.tistory.com/entry/%ED%9A%8C%EA%B7%80</a></li>
<li>3.3 잔차 진단 | Forecasting: Principles and Practice - OTexts, https://otexts.com/fppkr/residuals.html</li>
<li>13일차 (회귀와 예측,적합값과 잔차,최소제곱,다중회귀분석,OLS,RMSE,MSE,MAE,RMSLE), https://datacook.tistory.com/45</li>
<li>단순 선형회귀분석 - 제이드의 낙서장 - 티스토리, https://rstatistics.tistory.com/13</li>
<li>잔차분석, https://velog.io/@jaekim3220/Day49</li>
<li>회귀진단 - 의미를 이해하는 통계학과 데이터 분석, <a href="https://diseny.tistory.com/entry/%ED%9A%8C%EA%B7%80%EC%A7%84%EB%8B%A8">https://diseny.tistory.com/entry/%ED%9A%8C%EA%B7%80%EC%A7%84%EB%8B%A8</a></li>
<li>회귀분석이란/ 회귀분석의 구분/ 회귀결과 해석에 필요한 주의 - J-KEYBOARD, https://j-keyboard.tistory.com/2</li>
<li>[회귀분석] 회귀분석 실습(2) - 잔차분석 (Python), https://ysyblog.tistory.com/120</li>
<li>[machine learning class] 2. 교차검증 - 하마가 분석하마 - 티스토리, https://rrohchan.tistory.com/5</li>
<li>[R] 교차 유효성 검사를 통한 예측 모델 성능 평가, https://dncjf0223.tistory.com/30</li>
<li>6.3 교차검증 — 데이터 사이언스 스쿨, <a href="https://datascienceschool.net/03%20machine%20learning/06.03%20%EA%B5%90%EC%B0%A8%EA%B2%80%EC%A6%9D.html">https://datascienceschool.net/03%20machine%20learning/06.03%20%EA%B5%90%EC%B0%A8%EA%B2%80%EC%A6%9D.html</a></li>
<li>교차 검증 - Amazon Machine Learning, https://docs.aws.amazon.com/ko_kr/machine-learning/latest/dg/cross-validation.html</li>
<li>교차검증(Cross-Validation) - 이게또오류 - 티스토리, https://aigaeddo.tistory.com/44</li>
<li>K-Fold Cross Validation(교차검증) 정의 및 설명 - nonameyet - 티스토리, <a href="https://nonmeyet.tistory.com/entry/KFold-Cross-Validation%EA%B5%90%EC%B0%A8%EA%B2%80%EC%A6%9D-%EC%A0%95%EC%9D%98-%EB%B0%8F-%EC%84%A4%EB%AA%85">https://nonmeyet.tistory.com/entry/KFold-Cross-Validation%EA%B5%90%EC%B0%A8%EA%B2%80%EC%A6%9D-%EC%A0%95%EC%9D%98-%EB%B0%8F-%EC%84%A4%EB%AA%85</a></li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>