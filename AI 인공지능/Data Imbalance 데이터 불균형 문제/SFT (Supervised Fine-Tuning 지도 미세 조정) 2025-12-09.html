<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:SFT (Supervised Fine-Tuning, 지도 미세 조정)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>SFT (Supervised Fine-Tuning, 지도 미세 조정)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">데이터 불균형 문제 (Data Imbalance Problem)</a> / <span>SFT (Supervised Fine-Tuning, 지도 미세 조정)</span></nav>
                </div>
            </header>
            <article>
                <h1>SFT (Supervised Fine-Tuning, 지도 미세 조정)</h1>
<p>2025-12-09, G30DR</p>
<h2>1.  서론: 생성형 AI 시대의 새로운 패러다임과 SFT의 위상</h2>
<p>인공지능 연구의 흐름은 대규모 언어 모델(Large Language Models, LLM)의 등장과 함께 급격한 전환점을 맞이했다. 수조 개의 토큰을 학습하여 언어의 통계적 구조를 파악하는 사전 학습(Pre-training)은 모델에게 방대한 지식과 추론 능력을 부여했으나, 이것만으로는 인간의 의도에 부합하는 유용한 도구가 되기에 불충분했다. 사전 학습된 원시 모델(Base Model)은 단순히 주어진 텍스트의 다음 단어를 확률적으로 예측하는 ’문서 완성기(Document Completer)’에 불과했기 때문이다.1 이러한 맥락에서 지도 미세 조정(Supervised Fine-Tuning, SFT)은 원시 모델을 사용자의 명령을 이해하고 수행할 수 있는 ’어시스턴트(Assistant)’로 변모시키는 핵심적인 전이 학습(Transfer Learning) 단계로 자리 잡았다.</p>
<p>SFT는 본질적으로 사전 학습된 모델의 파라미터를 특정 작업이나 도메인에 맞게 미세하게 조정하는 과정이다. 그러나 최근의 연구 결과들은 SFT가 단순히 새로운 지식을 주입하는 과정이라기보다, 모델이 이미 보유하고 있는 지식을 사용자가 원하는 형식(Format)과 스타일(Style)로 인출(Elicitation)하도록 유도하는 ‘행동 정렬(Behavioral Alignment)’ 과정임을 시사한다.3 이는 “Less Is More for Alignment (LIMA)” 가설과 같이, 소량의 고품질 데이터만으로도 모델의 성능을 극대화할 수 있다는 데이터 중심 AI(Data-Centric AI)의 흐름과 궤를 같이한다.</p>
<p>본 보고서는 SFT의 기술적 메커니즘부터 데이터셋 구축 전략, 주요 연구 사례(InstructGPT, Alpaca, LIMA), 그리고 인간 피드백 기반 강화 학습(RLHF)과의 비교 분석에 이르기까지, SFT를 둘러싼 기술적 지형을 포괄적으로 조망한다. 특히, 단순히 기존 문헌을 나열하는 것을 넘어, 데이터의 다양성과 품질 간의 상충 관계, 환각(Hallucination) 현상의 원인, 그리고 토큰 그룹 최적화(SFT-GO)와 같은 최신 최적화 기법의 수학적 원리를 심층적으로 분석한다. 이를 통해 SFT가 현대 LLM 파이프라인에서 갖는 전략적 중요성과 향후 기술 발전의 방향성을 제시하고자 한다.</p>
<h2>2.  SFT의 이론적 배경 및 수학적 메커니즘</h2>
<p>SFT의 작동 원리를 이해하기 위해서는 먼저 언어 모델링의 확률적 기반과 이를 최적화하기 위한 손실 함수(Loss Function)의 수학적 구조를 명확히 해야 한다. SFT는 기본적으로 사전 학습과 동일한 ‘다음 토큰 예측(Next Token Prediction)’ 메커니즘을 사용하지만, 학습 데이터의 구조와 손실 계산 방식에서 결정적인 차이를 보인다.</p>
<h3>2.1  조건부 언어 모델링과 확률 분포의 재조정</h3>
<p>언어 모델은 토큰 시퀀스 <span class="math math-inline">X = (x_1, x_2,..., x_n)</span>의 결합 확률(Joint Probability) <span class="math math-inline">P(X)</span>를 모델링하는 것을 목표로 한다. 이는 연쇄 법칙(Chain Rule)에 의해 조건부 확률의 곱으로 분해된다.</p>
<p><span class="math math-display">P(X) = \prod_{i=1}^{n} P(x_i | x_{&lt;i})</span></p>
<p>사전 학습 단계에서는 비지도 데이터(Unlabeled Data)를 사용하여 범용적인 언어 분포를 학습한다. 반면, SFT 단계에서는 입력 프롬프트(Prompt) 또는 지시문(Instruction) <span class="math math-inline">x</span>와 이에 대한 이상적인 응답(Response) <span class="math math-inline">y</span>로 구성된 데이터셋 <span class="math math-inline">\mathcal{D} = {(x^{(i)}, y^{(i)})}</span>를 사용한다. 여기서 목표는 입력 <span class="math math-inline">x</span>가 주어졌을 때 응답 <span class="math math-inline">y</span>가 생성될 조건부 확률 <span class="math math-inline">P(y|x)</span>를 최대화하도록 모델 파라미터 <span class="math math-inline">\theta</span>를 업데이트하는 것이다.5</p>
<p>응답 <span class="math math-inline">y</span>가 길이 <span class="math math-inline">T</span>의 토큰 시퀀스 <span class="math math-inline">(y_1, y_2,..., y_T)</span>라고 할 때, SFT의 목적 함수는 다음과 같이 정의된다.</p>
<p><span class="math math-display">\mathcal{L}_{SFT}(\theta) = - \mathbb{E}_{(x, y) \sim \mathcal{D}} \left</span></p>
<p>이 수식은 모델이 주어진 지시문 <span class="math math-inline">x</span>와 현재까지 생성된 응답 <span class="math math-inline">y_{&lt;t}</span>를 문맥으로 하여, 정답 토큰 <span class="math math-inline">y_t</span>에 높은 확률을 할당하도록 강제함을 의미한다.6 이 과정은 모델의 확률 분포를 ’자연어의 일반적인 분포’에서 ’지시를 따르는 유용한 응답의 분포’로 이동(Shift)시키는 역할을 한다.</p>
<h3>2.2  손실 함수와 프롬프트 마스킹(Prompt Masking) 전략</h3>
<p>SFT 구현에 있어 가장 중요한 기술적 디테일 중 하나는 손실(Loss) 계산 시 입력 프롬프트 <span class="math math-inline">x</span>를 어떻게 처리하느냐에 있다. 이를 ‘프롬프트 마스킹(Prompt Masking)’ 또는 ’사용자 토큰 마스킹(User Token Masking)’이라 한다.7</p>
<h4>2.2.1  전체 시퀀스 학습 (Full Sequence Training)</h4>
<p>가장 단순한 형태는 프롬프트 <span class="math math-inline">x</span>와 응답 <span class="math math-inline">y</span>를 연결한 전체 시퀀스에 대해 손실을 계산하는 것이다. 그러나 이 방식은 모델이 사용자의 질문을 예측하는 것까지 학습하게 만든다. LLM의 목적은 질문을 ’반복’하거나 ’예측’하는 것이 아니라, 질문에 대한 ’답변’을 생성하는 것이다. 질문 자체를 학습하는 것은 모델의 제한된 용량(Capacity)을 낭비하는 것이며, 특히 질문이 길고 답변이 짧은 경우 학습 효율을 저해할 수 있다.7</p>
<h4>2.2.2  응답 전용 학습 (Completion-Only Training)</h4>
<p>현대의 표준적인 SFT 방식은 프롬프트 영역의 토큰에 대한 손실을 0으로 처리(Masking out)하는 것이다.10 PyTorch 등의 프레임워크에서는 일반적으로 레이블(Label) 시퀀스에서 프롬프트에 해당하는 위치의 값을 <code>-100</code> (Ignore Index)으로 설정하여 구현한다.7</p>
<p><span class="math math-display">\mathcal{L}_{token}^{(t)} = \begin{cases} -\log P(y_t | x, y_{&lt;t}) &amp; \text{if } t \in \text{Response} \\ 0 &amp; \text{if } t \in \text{Instruction} \end{cases}</span></p>
<p>연구 결과에 따르면, 프롬프트 마스킹을 적용한 모델(Prompt Loss Weight, PLW=0)이 그렇지 않은 모델에 비해 수렴 속도가 빠르고, 최종적인 지시 수행 성능 또한 우수한 것으로 나타났다.9 이는 모델이 그라디언트(Gradient)를 통해 업데이트될 때, 오직 ’정답을 생성하는 능력’을 개선하는 데에만 집중하기 때문이다. 특히 Universal-NER와 같이 사용자 입력과 어시스턴트 출력 간의 길이 불균형이 심한 데이터셋에서 이 기법의 중요성은 더욱 부각된다.7</p>
<h3>2.3 데이터 포맷팅과 특수 토큰의 역할</h3>
<p>SFT 데이터셋은 추상적인 (명령어, 응답) 쌍으로 존재하지만, 실제 모델 학습 시에는 이를 하나의 긴 텍스트 시퀀스로 변환해야 한다. 이 과정에서 모델이 화자(User vs. Assistant)를 구분하고 턴(Turn)의 경계를 인식할 수 있도록 돕는 것이 ’채팅 템플릿(Chat Template)’과 특수 토큰(Special Tokens)이다.7</p>
<p>Stanford Alpaca 프로젝트에서 사용된 데이터 처리 방식을 예로 들면, JSON 형식의 데이터는 다음과 같은 템플릿을 통해 변환된다.12</p>
<h3>Instruction:</h3>
<p>{instruction}</p>
<h3>Input:</h3>
<p>{input}</p>
<h3>Output:</h3>
<p>{output}</p>
<p>더 현대적인 모델들(예: ChatML 형식을 사용하는 모델)은 <code>&lt;|im_start|&gt;</code>, <code>&lt;|im_end|&gt;</code>와 같은 명시적인 제어 토큰을 사용하여 구조를 더욱 명확히 한다.7</p>
<p>&lt;|im_start|&gt;user</p>
<p>{instruction}&lt;|im_end|&gt;</p>
<p>&lt;|im_start|&gt;assistant</p>
<p>{response}&lt;|im_end|&gt;</p>
<p>이러한 포맷팅은 단순한 텍스트 처리가 아니라, 모델이 ’지시 모드’와 ’생성 모드’를 스위칭하는 문맥적 단서(Contextual Cue)를 학습하게 하는 중요한 엔지니어링 요소이다. 이 형식이 통일되지 않거나 훈련 시와 추론 시의 형식이 다를 경우, 모델 성능은 급격히 하락할 수 있다.</p>
<h2>3. 데이터 중심 AI와 SFT 데이터셋의 진화</h2>
<p>SFT의 성능을 결정짓는 가장 중요한 변수는 모델 아키텍처가 아니라 데이터의 품질과 다양성이다. “Garbage In, Garbage Out“의 원칙은 SFT에서 더욱 극명하게 드러난다. 최근 연구 흐름은 데이터의 양(Quantity)을 늘리는 것에서 질(Quality)과 다양성(Diversity)을 확보하는 방향으로 이동하고 있다.</p>
<h3>3.1 InstructGPT: 인간 레이블러 중심의 고품질 데이터</h3>
<p>OpenAI의 InstructGPT 연구는 SFT 데이터셋 구축의 초기 표준을 정립했다.13 이들은 API 프롬프트와 인간 레이블러가 직접 작성한 지시문을 혼합하여 약 13,000개의 SFT 학습 데이터를 구축했다.14</p>
<table><thead><tr><th><strong>데이터셋 종류</strong></th><th><strong>크기 (프롬프트 수)</strong></th><th><strong>출처</strong></th><th><strong>용도</strong></th></tr></thead><tbody>
<tr><td><strong>SFT 데이터셋</strong></td><td>~13,000</td><td>API + 레이블러 작성</td><td>지도 미세 조정 (1단계)</td></tr>
<tr><td><strong>RM 데이터셋</strong></td><td>~33,000</td><td>API + 레이블러 작성</td><td>보상 모델 학습 (2단계)</td></tr>
<tr><td><strong>PPO 데이터셋</strong></td><td>~31,000</td><td>API 전용</td><td>강화 학습 (3단계)</td></tr>
</tbody></table>
<p>InstructGPT의 SFT 데이터는 생성(Generation), 질의응답(QA), 브레인스토밍, 채팅, 요약 등 다양한 범주를 포괄하도록 설계되었다.15 이 연구의 핵심 발견은 175B의 거대 모델(GPT-3)보다 100배 작은 1.3B InstructGPT 모델이 인간 선호도 평가에서 더 우수한 성능을 보였다는 점이다.13 이는 모델의 크기보다 데이터의 ’정렬(Alignment)’이 사용자 만족도에 더 큰 영향을 미침을 증명한다.</p>
<h3>3.2 Stanford Alpaca와 Self-Instruct: 합성 데이터의 혁명</h3>
<p>InstructGPT 방식의 가장 큰 문제점은 고비용의 인간 노동력이 필요하다는 것이다. 이를 해결하기 위해 등장한 것이 Stanford Alpaca 프로젝트이며, 여기서 도입된 ‘Self-Instruct’ 방법론은 SFT 데이터 확보의 패러다임을 바꾸었다.17</p>
<h4>Self-Instruct 파이프라인의 메커니즘</h4>
<ol>
<li><strong>시드 데이터(Seed Data):</strong> 인간이 작성한 175개의 다양한 작업 예시(Instruction-Output 쌍)로 시작한다.18</li>
<li><strong>지시문 생성(Instruction Generation):</strong> 강력한 교사 모델(Teacher Model, 예: text-davinci-003)에게 시드 데이터를 보여주고, 유사하지만 새로운 지시문을 생성하도록 요청한다.</li>
<li><strong>입력 및 출력 생성(Input &amp; Output Generation):</strong> 생성된 지시문에 어울리는 입력값(Input)과 정답(Output)을 교사 모델이 생성한다.</li>
<li><strong>필터링(Filtering):</strong> ROUGE 점수 등을 활용하여 기존 데이터와 지나치게 유사한 중복 데이터를 제거하고 다양성을 확보한다.12</li>
</ol>
<p>Alpaca 팀은 이 방식을 통해 52,000개의 데이터를 단돈 500달러 미만의 API 비용으로 구축했다.18 이는 학계와 오픈소스 커뮤니티가 적은 예산으로도 고성능 지시 따르기 모델을 만들 수 있는 길을 열어주었다. 그러나 합성 데이터는 교사 모델의 편향이나 오류를 그대로 답습할 수 있다는 한계점 또한 내포하고 있다.19</p>
<h3>3.3 LIMA (Less Is More for Alignment): 표면 형태 가설</h3>
<p>LIMA(Less Is More for Alignment) 연구는 데이터의 양에 대한 집착을 버리고 극단적인 품질 중심주의를 제안했다.3 연구진은 단 1,000개의 엄선된 프롬프트만으로 65B 파라미터의 LLaMA 모델을 튜닝했고, 그 결과가 수만 개의 데이터로 학습한 Alpaca나 RLHF가 적용된 상용 모델(DaVinci003, Bard)과 대등하거나 더 우수함을 보였다.3</p>
<h4>표면 형태 가설 (Surface Form Hypothesis)</h4>
<p>LIMA 논문이 제시한 핵심 통찰은 **“모델의 지식과 능력은 거의 전적으로 사전 학습(Pre-training) 단계에서 습득된다”**는 것이다.3 SFT의 역할은 새로운 능력을 가르치는 것이 아니라, 모델이 이미 알고 있는 지식을 사용자가 선호하는 형식(스타일, 톤, 포맷)으로 표현하도록 ’형태’를 잡아주는 것에 불과하다. 따라서 스타일을 학습시키기 위해서는 수백만 개의 데이터가 필요하지 않으며, 다양하고 품질 높은 소수의 예시만으로도 충분하다는 것이다.21</p>
<p>LIMA 데이터셋의 구성 비율 (일부 재구성) 22:</p>
<ul>
<li>글쓰기 (Writing): 13.7%</li>
<li>지식 (Knowledge): 18.7%</li>
<li>조언 (Advice): 18.7%</li>
<li>코딩 및 STEM: 9%</li>
<li>기타 (브레인스토밍, 역할극 등): ~40%</li>
</ul>
<p>이 결과는 SFT 데이터셋 구축 시 양적 팽창보다는 데이터의 **다양성(Diversity)**과 <strong>품질(Quality)</strong>, 그리고 **복잡성(Complexity)**을 확보하는 데 자원을 집중해야 함을 시사한다.23</p>
<h2>4. 고급 최적화 기법: SFT-GO와 토큰 그룹화</h2>
<p>전통적인 SFT는 모든 토큰을 평등하게 취급한다. 그러나 문장 내에서 문법적인 기능을 하는 조사나 관사와, 문장의 의미를 결정짓는 핵심 키워드는 그 정보량과 중요도가 다르다. 이러한 불균형을 해결하기 위해 제안된 것이 **SFT-GO (Supervised Fine-Tuning with Group Optimization)**이다.25</p>
<h3>4.1 문제 의식: 균일한 손실 함수의 한계</h3>
<p>표준 교차 엔트로피 손실 함수는 쉬운 토큰(Easy Tokens)과 어려운 토큰(Hard Tokens)을 구분하지 않고 평균적인 손실을 최소화한다. 이는 모델이 이미 잘 예측하고 있는 문법적 요소들에 최적화 노력을 낭비하게 하고, 정작 학습이 필요한 복잡한 추론이나 핵심 정보 처리에 소홀하게 만들 수 있다.25</p>
<h3>4.2 그룹 분포 최적화 (Group Distributional Robust Optimization)</h3>
<p>SFT-GO는 토큰들을 중요도에 따라 그룹화하고, 모델이 가장 예측하기 어려워하는 그룹(Worst-group)에 더 큰 가중치를 부여하는 방식을 채택한다.25</p>
<ul>
<li><strong>토큰 그룹화:</strong> 중요도 지표(Importance Value)에 기반하여 토큰을 그룹핑한다. 이는 의미론적 중요도일 수도 있고, 모델의 손실값 자체일 수도 있다.</li>
<li><strong>가중치 조정:</strong> 최악의 그룹(Loss가 가장 높은 그룹)의 손실과 표준 교차 엔트로피 손실의 가중 합을 최소화하도록 최적화한다.</li>
</ul>
<p>수학적으로 이는 분포적으로 강건한 최적화(Distributionally Robust Optimization, DRO)의 일종으로 해석될 수 있다. SFT-GO는 특정 도메인(예: 수학, 추론)에서 표준 SFT보다 일관되게 우수한 성능을 보였으며, 이는 모델이 ’어려운 부분’을 회피하지 않고 정면으로 학습하도록 유도하기 때문이다.6</p>
<h2>5. SFT와 RLHF: 비교 분석 및 정렬(Alignment)의 역학</h2>
<p>SFT가 강력한 도구임은 분명하지만, 현대의 최고 성능 모델들(GPT-4, Claude 3 등)은 SFT 이후에 반드시 RLHF(Reinforcement Learning from Human Feedback) 단계를 거친다. 왜 SFT만으로는 충분하지 않은지, 두 방법론의 본질적인 차이와 상호보완적 관계를 분석한다.</p>
<h3>5.1 기술적/철학적 차이점 비교</h3>
<table><thead><tr><th><strong>비교 차원</strong></th><th><strong>Supervised Fine-Tuning (SFT)</strong></th><th><strong>RLHF (PPO, DPO 등)</strong></th></tr></thead><tbody>
<tr><td><strong>학습 목표</strong></td><td><strong>모방 학습 (Imitation):</strong> 주어진 정답 데이터를 흉내 내어 다음 토큰의 확률 분포를 조정함.1</td><td><strong>보상 최대화 (Maximization):</strong> 정답을 흉내 내는 것이 아니라, 인간이 선호하는 결과물에 대해 높은 점수를 받도록 정책을 최적화함.28</td></tr>
<tr><td><strong>데이터 형태</strong></td><td>(프롬프트, 정답) 쌍. 정확한 ’정답’이 존재해야 함.29</td><td>(프롬프트, 승리 응답, 패배 응답) 쌍. 정답이 없어도 선호도 비교만 가능하면 됨.30</td></tr>
<tr><td><strong>최적화 난이도</strong></td><td>비교적 낮음. 수렴이 안정적이고 빠름.29</td><td>매우 높음. 보상 모델 학습과 정책 최적화 과정이 불안정하고 하이퍼파라미터에 민감함.1</td></tr>
<tr><td><strong>주요 강점</strong></td><td>명확한 도메인 지식, 포맷 준수, 코드 생성 등 정답이 확실한 태스크.</td><td>윤리적 판단, 톤 앤 매너 조절, 창의적 글쓰기, 모호한 지시 수행.32</td></tr>
</tbody></table>
<h3>5.2 SFT의 한계: 부정적 제약과 환각</h3>
<p>SFT의 가장 큰 약점은 **“부정적 제약(Negative Constraints)”**을 학습시키기 어렵다는 점이다. SFT 데이터는 “A를 해라“라는 긍정적 예시로 구성되어 있어, 모델에게 “B는 하지 마라(예: 편향된 발언, 위험한 정보 제공)“를 가르치는 데 한계가 있다.19 또한, SFT 모델은 학습 데이터에 없는 내용을 질문받았을 때도, 학습된 패턴을 억지로 적용하여 그럴듯한 거짓말을 만들어내는 <strong>환각(Hallucination)</strong> 경향이 강하다.33</p>
<p>반면 RLHF는 모델이 편향되거나 유해한 답변을 생성했을 때 낮은 보상(Penalty)을 부여함으로써, 모델이 스스로 그런 행동을 억제하도록 학습시킬 수 있다. 또한, “모른다“고 솔직하게 답변하는 것에 높은 보상을 줌으로써 환각을 완화할 수 있다.28</p>
<h3>5.3 정렬 세금 (Alignment Tax)</h3>
<p>RLHF를 통해 모델을 인간의 선호도에 맞추다 보면, 모델의 객관적인 성능(예: 수학 문제 해결 능력, 사실적 지식 인출)이 오히려 떨어지는 현상이 발생하는데, 이를 **‘정렬 세금(Alignment Tax)’**이라 한다.35 SFT는 이러한 정렬 세금이 상대적으로 적은 편이다. 따라서 최신 연구들은 SFT 모델과 RLHF 모델의 가중치를 보간(Interpolation)하거나 혼합하여, 지시 따르기 능력과 원천적인 지능(Reasoning) 사이의 균형을 맞추려 시도한다.36</p>
<h2>6. SFT의 병리적 현상과 해결 과제</h2>
<p>SFT는 만능이 아니며, 잘못 수행될 경우 모델의 성능을 치명적으로 훼손할 수 있다.</p>
<h3>6.1 환각의 증폭과 지식 경계 (Knowledge Boundary)</h3>
<p>연구에 따르면, 새로운 사실적 지식을 SFT를 통해 주입하려 할 때 모델의 환각이 증가한다.34 모델은 사전 학습 단계에서 배우지 못한 지식을 SFT 데이터셋에서 접하게 되면, 그 내용을 이해하기보다는 표면적인 문장 구조만을 암기하여 잘못된 인과 관계(Erroneous causal links)를 형성하게 된다.33 이는 모델이 자신의 <strong>지식 경계</strong>를 인식하지 못하게 만들며, 모르는 것도 아는 것처럼 꾸며내는 부작용을 낳는다.39 따라서 사실적 지식은 SFT가 아닌 RAG(Retrieval-Augmented Generation)와 같은 외부 지식 연동을 통해 해결하는 것이 바람직하다.</p>
<h3>6.2 데이터 편향과 다양성 부족</h3>
<p>SFT 데이터셋이 특정 스타일이나 관점에 치우칠 경우, 모델은 그 편향을 과도하게 증폭시켜 학습한다. 예를 들어, 모든 답변이 “물론입니다(Sure, here is…)“로 시작하는 데이터로 학습하면, 모델은 거절해야 할 유해한 질문에도 긍정적으로 답하는 경향을 보이게 된다. 이를 방지하기 위해서는 데이터셋의 다양성을 정량적으로 측정하고(예: 클러스터링 기반 분석), 의도적으로 희소한 유형의 데이터를 보강하는 **QDIT(Quality-Diversity Instruction Tuning)**와 같은 접근이 필요하다.23</p>
<h2>7. 결론 및 향후 전망</h2>
<p>SFT는 대규모 언어 모델을 연구실의 실험체에서 실용적인 제품으로 전환시키는 가장 결정적인 공정이다. InstructGPT에서 시작된 SFT의 역사는 Stanford Alpaca의 합성 데이터 혁명과 LIMA의 소량 고품질 데이터론을 거치며, “데이터의 양“에서 “데이터의 질과 다양성“으로 그 초점이 완전히 이동하였다.</p>
<p>본 분석을 통해 도출된 핵심 시사점은 다음과 같다.</p>
<ol>
<li><strong>SFT의 본질 재정의:</strong> SFT는 지식 주입(Knowledge Injection) 과정이 아니라, 지식 인출(Knowledge Elicitation) 및 행동 양식(Behavior) 정렬 과정이다. 따라서 사전 학습 모델의 기본 역량이 SFT의 상한선을 결정한다.</li>
<li><strong>데이터 엔지니어링의 중요성:</strong> 수만 개의 저품질 데이터보다 수천 개의 전문가 수준 데이터가 훨씬 더 강력하다. 향후 경쟁력은 모델 아키텍처보다 도메인 특화된 고품질 SFT 데이터셋을 얼마나 효율적으로 구축하느냐에 달려 있다.</li>
<li><strong>RLHF와의 공존:</strong> 안전하고 윤리적인 AI를 위해서는 SFT만으로는 부족하다. SFT로 기초적인 역량을 다지고, RLHF(또는 DPO)로 미세한 가치관을 정렬하는 하이브리드 파이프라인이 표준으로 굳어질 것이다.</li>
<li><strong>최적화 기법의 고도화:</strong> 모든 토큰을 평등하게 학습하는 방식을 넘어, SFT-GO와 같이 토큰별, 그룹별 중요도를 반영하는 정교한 손실 함수 설계가 모델의 학습 효율과 추론 능력을 한 단계 더 끌어올릴 것이다.</li>
</ol>
<p>결론적으로 SFT는 단순한 미세 조정을 넘어, 인간의 의도와 기계의 연산 능력을 일치시키는 인터페이스 설계의 영역으로 진화하고 있다. 앞으로의 연구는 환각을 최소화하면서 모델의 지식 경계를 명확히 하고, 적은 데이터로도 인간의 복잡한 선호도를 반영할 수 있는 효율적인 정렬 알고리즘 개발에 집중될 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>What Is Reinforcement Learning From Human Feedback (RLHF)? - IBM, 12월 9, 2025에 액세스, https://www.ibm.com/think/topics/rlhf</li>
<li>What Is Instruction Tuning? | IBM, 12월 9, 2025에 액세스, https://www.ibm.com/think/topics/instruction-tuning</li>
<li>LIMA: Less Is More for Alignment - OpenReview, 12월 9, 2025에 액세스, https://openreview.net/pdf?id=KBMOKmX2he</li>
<li>Comprehensive Analysis of LIMA: (Less is More for Alignment) | by Vaishnavi R - Medium, 12월 9, 2025에 액세스, https://medium.com/version-1/comprehensive-analysis-of-lima-less-is-more-for-alignment-8967687ea432</li>
<li>Forgetting: A New Mechanism Towards Better Large Language Model Fine-tuning - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2508.04329v3</li>
<li>On the Generalization of SFT: A Reinforcement Learning Perspective with Reward Rectification - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2508.05629v1</li>
<li>Mask Your User Tokens | Yoni Gottesman, 12월 9, 2025에 액세스, https://yonigottesman.github.io/2024/05/13/mask-user-tokens.html</li>
<li>To Mask or Not to Mask: The Effect of Prompt Tokens on Instruction Tuning, 12월 9, 2025에 액세스, https://towardsdatascience.com/to-mask-or-not-to-mask-the-effect-of-prompt-tokens-on-instruction-tuning-016f85fd67f4/</li>
<li>Instruction Fine-Tuning: Does Prompt Loss Matter? - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2401.13586v2</li>
<li>Comments - LLM Research Insights: Instruction Masking and New LoRA Finetuning Experiments - Ahead of AI, 12월 9, 2025에 액세스, https://magazine.sebastianraschka.com/p/llm-research-insights-instruction/comments</li>
<li>Instruction Fine-Tuning: Does Prompt Loss Matter? - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2401.13586v4</li>
<li>Self-Instruct Style Data Generation: The Secret Behind Stanford Alpaca | by Okan Yenigün, 12월 9, 2025에 액세스, https://medium.com/@okanyenigun/self-instruct-style-data-generation-the-secret-behind-stanford-alpaca-e1575ea9ad71</li>
<li>[2203.02155] Training language models to follow instructions with human feedback - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/abs/2203.02155</li>
<li>Training language models to follow instructions with human feedback, 12월 9, 2025에 액세스, https://proceedings.neurips.cc/paper_files/paper/2022/file/b1efde53be364a73914f58805a001731-Paper-Conference.pdf</li>
<li>arXiv:2203.02155v1 [cs.CL] 4 Mar 2022, 12월 9, 2025에 액세스, https://arxiv.org/pdf/2203.02155</li>
<li>Aligning language models to follow instructions - OpenAI, 12월 9, 2025에 액세스, https://openai.com/index/instruction-following/</li>
<li>tatsu-lab/stanford_alpaca: Code and documentation to train Stanford’s Alpaca models, and generate the data. - GitHub, 12월 9, 2025에 액세스, https://github.com/tatsu-lab/stanford_alpaca</li>
<li>Alpaca: A Strong, Replicable Instruction-Following Model - Stanford CRFM, 12월 9, 2025에 액세스, https://crfm.stanford.edu/2023/03/13/alpaca.html</li>
<li>Fine-tune large language models with reinforcement learning from human or AI feedback, 12월 9, 2025에 액세스, https://aws.amazon.com/blogs/machine-learning/fine-tune-large-language-models-with-reinforcement-learning-from-human-or-ai-feedback/</li>
<li>LIMA: Less Is More for Alignment - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/pdf/2305.11206</li>
<li>LIMIT: Less Is More for Instruction Tuning | Databricks Blog, 12월 9, 2025에 액세스, https://www.databricks.com/blog/limit-less-more-instruction-tuning</li>
<li>LIMA: Less Is More for Alignment - OpenReview, 12월 9, 2025에 액세스, https://openreview.net/forum?id=KBMOKmX2he</li>
<li>Data Diversity Matters for Robust Instruction Tuning, 12월 9, 2025에 액세스, https://par.nsf.gov/servlets/purl/10624024</li>
<li>Surveying the Effects of Quality, Diversity, and Complexity in Synthetic Data From Large Language Models - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2412.02980v2</li>
<li>SFT-GO: Supervised Fine-Tuning with Group Optimization for Large Language Models, 12월 9, 2025에 액세스, https://openreview.net/forum?id=dPJJLv4q3r</li>
<li>SFT-GO: Supervised Fine-Tuning with Group Optimization for Large Language Models, 12월 9, 2025에 액세스, https://chatpaper.com/paper/150852</li>
<li>SFT-GO: Supervised Fine-Tuning with Group Optimization for Large Language Models - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2506.15021v1</li>
<li>SFT vs RLHF: How to Choose the Best AI Training Method | 2025, 12월 9, 2025에 액세스, https://www.gdsonline.tech/sft-vs-rlhf/</li>
<li>RLHF vs. Supervised Fine-Tuning: When, Why, &amp; How to Choose - V2Solutions, 12월 9, 2025에 액세스, https://www.v2solutions.com/blogs/rlhf-vs-supervised-fine-tuning/</li>
<li>Why is RLHF necessary when we can do SFT in tuning LLMs? | by Baicen Xiao - Medium, 12월 9, 2025에 액세스, https://medium.com/@baicenxiao/why-is-rlhf-necessary-when-we-can-do-sft-in-tuning-llms-36089cba8ef2</li>
<li>Alignment and Safety in Large Language Models: Safety Mechanisms, Training Paradigms, and Emerging Challenges - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2507.19672v1</li>
<li>Supervised Fine-Tuning vs. RLHF: How to Choose the Right Approach to Train Your LLM, 12월 9, 2025에 액세스, https://invisibletech.ai/blog/supervised-fine-tuning-vs-rlhf-how-to-choose-the-right-approach-to-train-your-llm</li>
<li>A Closer Look at the Limitations of Instruction Tuning - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2402.05119v3</li>
<li>A Survey on Hallucination in Large Language Models: Principles, Taxonomy, Challenges, and Open Questions - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2311.05232v2</li>
<li>[R] What’s the current research status of “SFT with high-quality data” vs RLHF? - Reddit, 12월 9, 2025에 액세스, https://www.reddit.com/r/MachineLearning/comments/15ldjdz/r_whats_the_current_research_status_of_sft_with/</li>
<li>Mitigating the Alignment Tax of RLHF - ACL Anthology, 12월 9, 2025에 액세스, https://aclanthology.org/2024.emnlp-main.35.pdf</li>
<li>Mitigating the Alignment Tax of RLHF - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2309.06256v3</li>
<li>Analyzing the Effects of Supervised Fine-Tuning on Model Knowledge from Token and Parameter Levels - arXiv, 12월 9, 2025에 액세스, https://arxiv.org/html/2509.16596v1</li>
<li>Alleviating Hallucinations of Large Language Models through Induced Hallucinations - ACL Anthology, 12월 9, 2025에 액세스, https://aclanthology.org/2025.findings-naacl.459.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>