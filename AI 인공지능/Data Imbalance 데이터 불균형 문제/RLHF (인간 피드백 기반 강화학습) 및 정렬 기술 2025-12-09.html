<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:RLHF (인간 피드백 기반 강화학습) 및 정렬 기술</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>RLHF (인간 피드백 기반 강화학습) 및 정렬 기술</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">데이터 불균형 문제 (Data Imbalance Problem)</a> / <span>RLHF (인간 피드백 기반 강화학습) 및 정렬 기술</span></nav>
                </div>
            </header>
            <article>
                <h1>RLHF (인간 피드백 기반 강화학습) 및 정렬 기술</h1>
<p>2025-12-09, G30DR</p>
<h2>1.  서론: 인공지능 정렬(Alignment)의 대전환</h2>
<p>인공지능, 특히 대규모 언어 모델(Large Language Model, LLM)의 발전사는 데이터 처리 용량의 확대와 파라미터 수의 기하급수적 증가로 요약될 수 있었다. 그러나 GPT-3와 같은 초거대 모델의 등장은 역설적으로 ’능력(Capability)’과 ‘의도(Intent)’ 사이의 괴리라는 근본적인 문제를 수면 위로 부상시켰다. 사전 학습(Pre-training) 단계에서 모델은 인터넷상의 방대한 텍스트 데이터를 기반으로 ’다음 토큰 예측(Next Token Prediction)’이라는 단순한 목표 함수를 최적화한다. 이 과정에서 모델은 문법적 유창성과 광범위한 지식을 습득하지만, 동시에 인터넷 데이터에 내재된 편향성, 허위 정보, 그리고 사용자의 지시를 무시하고 텍스트를 제멋대로 이어 쓰는 경향까지 학습하게 된다.1</p>
<p>이러한 배경에서 인간 피드백 기반 강화학습(Reinforcement Learning from Human Feedback, RLHF)의 도입은 AI 개발 패러다임의 결정적인 전환점이 되었다. RLHF는 모델이 “무엇을 말할 수 있는가“의 확률적 문제에서 벗어나, 인간의 가치관과 의도에 부합하는 “무엇을 말해야 하는가“의 규범적 문제로 초점을 이동시켰다. 이는 단순한 기술적 방법론을 넘어, AI 시스템을 인간 사회의 규범과 가치에 정렬(Alignment)시키려는 최초의 체계적이고 확장 가능한 시도로 평가받는다.4</p>
<p>본 보고서는 RLHF의 이론적 메커니즘부터 최신 기술적 진화에 이르기까지 전 과정을 심층적으로 분석한다. InstructGPT로 정립된 표준 파이프라인의 수학적 기초를 상세히 규명하고, PPO(Proximal Policy Optimization)에서 DPO(Direct Preference Optimization)로 이어지는 최적화 알고리즘의 혁신, Llama 2와 HyperCLOVA X 등 최신 파운데이션 모델의 구체적인 적용 사례, 그리고 인간의 개입을 최소화하려는 RLAIF(RL from AI Feedback)와 추론 능력을 강화하는 과정 보상 모델(Process Reward Model) 등 미래 기술의 흐름을 포괄적으로 고찰한다.</p>
<hr />
<h2>2.  이론적 배경 및 표준 파이프라인: InstructGPT 방법론의 해부</h2>
<p>OpenAI의 InstructGPT 연구는 RLHF를 대규모 언어 모델에 성공적으로 적용하여, 1.3B 파라미터 모델이 175B 파라미터 모델보다 인간 평가에서 더 우수한 성능을 보일 수 있음을 증명했다. 이 연구를 통해 정립된 3단계 파이프라인은 현재까지도 대부분의 LLM 개발에 있어 표준 참조 모델(Reference Model)로 기능하고 있다.2</p>
<h3>2.1  1단계: 지도 미세 조정 (Supervised Fine-Tuning, SFT) - 행동의 초기화</h3>
<p>강화학습 에이전트가 환경에서 유의미한 보상을 얻기 위해서는 일정 수준 이상의 합리적인 행동을 할 수 있어야 한다. 무작위로 텍스트를 생성하는 초기 모델에 강화학습을 즉시 적용할 경우, 탐색(Exploration) 공간이 지나치게 넓어 학습이 수렴하지 않거나 매우 비효율적으로 진행되는 ‘콜드 스타트(Cold Start)’ 문제가 발생한다. SFT는 이를 해결하기 위한 부트스트래핑(Bootstrapping) 과정이다.8</p>
<h4>2.1.1  데이터 큐레이션과 품질의 중요성</h4>
<p>SFT 단계의 핵심은 데이터의 ’양’보다 ’질’에 있다. InstructGPT의 경우, 인간 레이블러(Labeler)가 직접 작성한 고품질의 지시-응답(Prompt-Response) 쌍을 사용하여 모델을 학습시켰다. 이 데이터셋은 모델에게 “사용자의 질문에 답변한다“는 기본적인 형식을 가르치며, 도움이 되고(Helpful), 해롭지 않으며(Harmless), 정직한(Honest) 답변의 기준을 제시한다.2 데이터 분포는 요약, 질의응답, 분류, 창작 등 다양한 태스크를 포괄해야 하며, 이를 통해 모델은 사전 학습된 지식을 사용자의 의도에 맞게 재구성하는 법을 익힌다.</p>
<h4>2.1.2  수학적 목표</h4>
<p>SFT는 전형적인 언어 모델링 목표 함수를 따른다. 주어진 프롬프트 <span class="math math-inline">x</span>와 이에 대한 모범 답안 <span class="math math-inline">y</span>가 주어졌을 때, 모델 파라미터 <span class="math math-inline">\theta</span>에 대한 우도(Likelihood)를 최대화한다.</p>
<p><span class="math math-display">\mathcal{L}_{SFT}(\theta) = - \sum_{(x, y) \sim D_{SFT}} \log P_\theta(y|x)</span></p>
<p>이 단계가 완료된 모델 <span class="math math-inline">\pi^{SFT}</span>는 사용자의 지시를 따르는 기본적인 능력을 갖추게 되지만, 여전히 답변의 다양성이나 미묘한 뉘앙스 차이를 구분하는 데에는 한계를 보인다.</p>
<h3>2.2 2단계: 보상 모델 학습 (Reward Model Training) - 가치 판단의 내재화</h3>
<p>SFT 모델이 생성한 답변의 품질을 정량적으로 평가할 수 있는 별도의 신경망, 즉 보상 모델(Reward Model, RM)을 구축하는 단계이다. 이 과정은 인간의 주관적인 선호도를 기계가 이해할 수 있는 스칼라(Scalar) 값으로 변환하는 핵심적인 연결 고리 역할을 한다.1</p>
<h4>2.2.1 비교(Comparison) 데이터 수집의 필연성</h4>
<p>인간에게 개별 답변에 대해 절대적인 점수(예: 1~10점)를 매기게 하는 방식은 평가자 간의 편차(Inter-annotator variance)가 크고, 점수의 일관성을 유지하기 어렵다는 근본적인 문제가 있다. 따라서 RLHF는 <strong>비교 순위(Ranking)</strong> 방식을 채택한다. 동일한 프롬프트 <span class="math math-inline">x</span>에 대해 모델이 생성한 두 개(또는 그 이상)의 답변 쌍 <span class="math math-inline">(y_A, y_B)</span>를 인간에게 제시하고, 어느 것이 더 나은지 선택하게 한다. 이를 통해 구축된 데이터셋 <span class="math math-inline">D_{R}</span>은 <span class="math math-inline">(x, y_w, y_l)</span>의 형태를 띤다. 여기서 <span class="math math-inline">y_w</span>는 선택된(Winning) 답변, <span class="math math-inline">y_l</span>은 선택받지 못한(Losing) 답변을 의미한다.10</p>
<h4>2.2.2 Bradley-Terry 모델과 손실 함수</h4>
<p>수집된 비교 데이터를 기반으로 보상 모델 <span class="math math-inline">r_\phi(x, y)</span>를 학습시킨다. 이때 보상 모델의 출력값이 선호 확률과 일치하도록 Bradley-Terry 모델을 차용하여 손실 함수를 설계한다.</p>
<p><span class="math math-display"> \mathcal{L}*{RM}(\phi) = - \mathbb{E}*{(x, y_w, y_l) \sim D_R} \left[ \log(\sigma(r_\phi(x, y_w) - r_\phi(x, y_l))) \right] </span></p>
<p>여기서 <span class="math math-inline">\sigma</span>는 로지스틱 함수(Sigmoid)이다. 이 수식의 직관적인 의미는 <span class="math math-inline">y_w</span>에 대한 보상 점수가 <span class="math math-inline">y_l</span>에 대한 보상 점수보다 클 확률을 최대화하는 것이다. 보상 모델은 생성 모델과 유사한 트랜스포머 구조를 가지지만, 마지막 토큰의 임베딩을 스칼라 값으로 변환하는 선형 레이어(Linear Head)가 추가된다. 일반적으로 보상 모델은 생성 모델보다 작거나 같은 크기로 설계되지만, 언어적 맥락을 충분히 이해할 수 있을 만큼 충분히 거대해야 한다(예: OpenAI는 175B 생성 모델에 대해 6B 보상 모델 사용).10</p>
<h3>2.2  3단계: 강화학습을 통한 정책 최적화 (PPO) - 정렬의 완성</h3>
<p>마지막으로, 학습된 보상 모델을 환경(Environment)으로 설정하고, 생성 모델을 에이전트(Agent)로 하여 강화학습을 수행한다. 이 단계의 목표는 보상 모델이 부여하는 점수를 최대화하는 방향으로 정책(Policy, <span class="math math-inline">\pi</span>)을 업데이트하는 것이다.4</p>
<h4>2.2.1  PPO (Proximal Policy Optimization) 알고리즘</h4>
<p>PPO는 정책 경사(Policy Gradient) 기반의 강화학습 알고리즘으로, 학습의 안정성을 위해 정책 업데이트의 폭을 제한(Clipping)하는 것이 특징이다. LLM 학습에서 PPO는 다음과 같은 과정을 거친다:</p>
<ol>
<li>모델이 프롬프트 <span class="math math-inline">x</span>에 대해 답변 <span class="math math-inline">y</span>를 생성한다.</li>
<li>보상 모델이 <span class="math math-inline">(x, y)</span>에 대한 보상 <span class="math math-inline">r</span>을 계산한다.</li>
<li>PPO 알고리즘을 사용하여 기대 보상을 최대화하도록 모델 파라미터를 업데이트한다.</li>
</ol>
<h4>2.2.2  KL 발산(Kullback-Leibler Divergence) 페널티의 역할</h4>
<p>단순히 보상 모델의 점수만을 최대화할 경우, 모델은 보상 모델의 허점을 악용(Gaming)하여 문법적으로 엉망이거나 무의미한 텍스트를 생성하면서도 높은 점수를 받으려는 <strong>보상 해킹(Reward Hacking)</strong> 현상을 보인다. 또한, 모델의 분포가 인간의 선호 데이터에 과적합되어 다양성을 상실하는 **모드 붕괴(Mode Collapse)**가 발생할 수 있다.</p>
<p>이를 방지하기 위해 목적 함수에 KL 발산 페널티 항을 추가한다. 이는 학습 중인 정책 <span class="math math-inline">\pi_{RL}</span>이 초기 SFT 모델 <span class="math math-inline">\pi_{SFT}</span>의 확률 분포에서 너무 멀어지지 않도록 강제하는 ‘닻(Anchor)’ 역할을 한다.11</p>
<p><span class="math math-display">R(x, y) = r_\phi(x, y) - \beta \log \left( \frac{\pi_{RL}(y|x)}{\pi_{SFT}(y|x)} \right)</span></p>
<p>최종적인 PPO 목적 함수는 이 수정된 보상 <span class="math math-inline">R(x, y)</span>를 최대화하는 방향으로 설정된다. <span class="math math-inline">\beta</span>는 KL 페널티의 강도를 조절하는 하이퍼파라미터로, 모델의 탐색 능력과 보상 모델에 대한 신뢰도 사이의 균형을 맞춘다.</p>
<hr />
<h2>3. 최적화 알고리즘의 진화: PPO의 한계와 DPO의 혁신</h2>
<p>InstructGPT가 제시한 PPO 기반 파이프라인은 강력했지만, 엔지니어링 관점에서 극도로 복잡하고 불안정했다. 이를 극복하기 위해 강화학습 과정을 단순화하고 안정성을 높이려는 시도가 이어졌으며, 그 정점에 DPO(Direct Preference Optimization)가 있다.12</p>
<h3>3.1 PPO의 구조적 복잡성과 불안정성</h3>
<p>PPO 기반 RLHF를 수행하기 위해서는 훈련 과정에서 최소 4개의 모델을 메모리에 로드해야 한다:</p>
<ol>
<li><strong>Policy Model:</strong> 학습 대상인 생성 모델.</li>
<li><strong>Reference Model (SFT):</strong> KL 발산 계산을 위한 기준 모델(Frozen).</li>
<li><strong>Reward Model:</strong> 보상을 계산하는 모델(Frozen).</li>
<li><strong>Value Model (Critic):</strong> 현재 상태의 가치를 평가하여 PPO 업데이트를 돕는 모델.</li>
</ol>
<p>이러한 구조는 막대한 GPU 메모리를 요구하며, 분산 학습 환경 구축을 어렵게 만든다. 또한, PPO는 하이퍼파라미터에 매우 민감하여, 학습 곡선이 발산하거나 성능이 급격히 저하되는 경우가 빈번하다. 샘플링(Sampling) 과정이 포함되어 있어 학습 속도 또한 느리다.9</p>
<h3>3.2 DPO (Direct Preference Optimization): 패러다임의 전환</h3>
<p>2023년 스탠포드 대학 연구진이 제안한 DPO는 “보상 모델을 명시적으로 학습시킬 필요가 없다“는 통찰에서 출발했다. 연구진은 최적의 정책(Optimal Policy) <span class="math math-inline">\pi^*</span>와 보상 함수 <span class="math math-inline">r</span> 사이에 수학적인 일대일 대응 관계가 존재함을 증명했다. 이를 이용하면 보상 함수를 정책 모델에 대한 수식으로 치환할 수 있으며, 결과적으로 별도의 보상 모델 없이 선호 데이터만으로 정책을 직접 최적화할 수 있다.12</p>
<h4>3.2.1 DPO의 수학적 유도와 직관</h4>
<p>DPO는 강화학습 문제를 <strong>이진 분류(Binary Classification)</strong> 문제로 재정의한다. DPO의 손실 함수는 다음과 같이 유도된다:</p>
<p><span class="math math-display"> \mathcal{L}*{DPO}(\pi*\theta) = - \mathbb{E}*{(x, y_w, y_l) \sim D} \left[ \log \sigma \left( \beta \log \frac{\pi*\theta(y_w|x)}{\pi_{ref}(y_w|x)} - \beta \log \frac{\pi_\theta(y_l|x)}{\pi_{ref}(y_l|x)} \right) \right] </span></p>
<p>이 수식은 모델이 선호 답변 <span class="math math-inline">y_w</span>를 생성할 확률을 참조 모델 대비 높이고, 비선호 답변 <span class="math math-inline">y_l</span>을 생성할 확률을 참조 모델 대비 낮추도록 유도한다. 이는 본질적으로 Bradley-Terry 모델을 따르면서도, 복잡한 샘플링이나 가치 모델 학습 과정 없이 지도 학습(Supervised Learning)과 유사한 방식으로 최적화가 가능하다.12</p>
<h4>2.2.3  PPO와 DPO의 비교 분석</h4>
<table><thead><tr><th><strong>특징</strong></th><th><strong>PPO (Proximal Policy Optimization)</strong></th><th><strong>DPO (Direct Preference Optimization)</strong></th></tr></thead><tbody>
<tr><td><strong>학습 방식</strong></td><td>온라인 강화학습 (On-Policy)</td><td>오프라인 지도학습 유사 (Off-Policy)</td></tr>
<tr><td><strong>필요 모델 수</strong></td><td>4개 (Policy, Ref, Reward, Value)</td><td>2개 (Policy, Ref)</td></tr>
<tr><td><strong>계산 비용</strong></td><td>매우 높음 (샘플링 및 복잡한 업데이트)</td><td>낮음 (일반적인 Fine-tuning과 유사)</td></tr>
<tr><td><strong>학습 안정성</strong></td><td>낮음 (발산하기 쉬움)</td><td>높음 (수렴이 빠르고 안정적)</td></tr>
<tr><td><strong>성능</strong></td><td>탐색(Exploration)이 가능하여 잠재력 높음</td><td>정적 데이터셋에 의존하지만 일반적으로 PPO와 대등하거나 우수</td></tr>
</tbody></table>
<p>최근 연구 결과에 따르면, DPO는 요약, 대화 생성 등 대부분의 벤치마크에서 PPO와 대등하거나 더 우수한 성능을 보이면서도 학습 시간과 자원을 획기적으로 절감한다. 그러나 PPO는 모델이 스스로 데이터를 생성하며 탐색하는 On-Policy 특성 덕분에, 데이터 분포를 벗어난 새로운 해결책을 찾는(Out-of-distribution generalization) 과제에서는 여전히 강점을 가질 수 있다는 주장이 제기된다.15</p>
<hr />
<h2>3.  사례 연구: 최신 파운데이션 모델의 RLHF 전략</h2>
<p>실제 최신 모델들은 이론적인 파이프라인을 그대로 따르기보다, 각 모델의 목적과 인프라에 맞춰 고도화된 변형 전략을 사용한다. Meta의 Llama 2와 Naver의 HyperCLOVA X는 이러한 현장의 노하우가 집약된 대표적인 사례이다.</p>
<h3>3.1  Meta Llama 2: 반복적 거부 샘플링(Rejection Sampling)과 이원화된 보상</h3>
<p>Llama 2는 오픈 소스 모델임에도 불구하고 상용 모델에 버금가는 안전성과 성능을 달성했다. 그 비결은 RLHF 프로세스의 정교한 설계에 있다.</p>
<ol>
<li><strong>거부 샘플링(Rejection Sampling)의 도입:</strong> PPO 적용 전, Llama 2는 ’거부 샘플링’을 통해 모델을 먼저 워밍업했다. 모델이 하나의 프롬프트에 대해 <span class="math math-inline">K</span>개의 답변을 생성하면, 보상 모델이 최상위 점수를 받은 답변만을 선택한다. 이 선택된 데이터(Gold samples)를 다시 SFT 데이터로 사용하여 모델을 재학습시킨다. 이 과정을 반복(Iterative Rejection Sampling)함으로써 모델은 자신이 생성할 수 있는 최선의 답변 분포(Max margin)를 스스로 학습하게 된다.9</li>
<li><strong>안전성(Safety)과 유용성(Helpfulness)의 분리:</strong> 단일 보상 모델이 두 가지 상충하는 가치를 모두 학습하기 어렵다는 점에 착안하여, Llama 2는 안전성 보상 모델과 유용성 보상 모델을 별도로 훈련시켰다. PPO 단계에서 이 두 점수를 결합하거나, 안전성 임계값을 넘지 못하는 답변을 필터링하는 방식으로 ‘도움이 되면서도 안전한’ 모델을 구현했다.19</li>
<li><strong>고스트 어텐션(Ghost Attention, GAtt):</strong> 멀티 턴 대화에서 모델이 초기 지시사항(예: “항상 셰익스피어 말투로 대답해”)을 잊어버리는 문제를 해결하기 위해 고안되었다. 학습 데이터의 모든 턴에 시스템 프롬프트를 인위적으로 연결(Concat)하되, 손실 계산 시에는 이전 턴의 시스템 프롬프트를 마스킹 처리하여 모델이 문맥을 통해 지시사항을 유지하도록 훈련시켰다.19</li>
</ol>
<h3>3.2  Naver HyperCLOVA X: 한국어 특화 및 파이프라인 자동화</h3>
<p>HyperCLOVA X는 영미권 중심의 AI 기술을 한국어와 한국 문화에 맞게 최적화한 사례이다. “주권 AI(Sovereign AI)“를 표방하며, 문화적 맥락을 이해하는 정렬 기술에 주력했다.</p>
<ol>
<li><strong>문화적 정렬(Cultural Alignment):</strong> 단순히 언어를 번역하는 것을 넘어, 한국의 사회적 규범, 법률, 가치관에 부합하는 RLHF 데이터셋을 구축했다. 이는 영어 모델이 한국어 질문에 대해 미국식 관점이나 맞지 않는 정보를 제공하는 문제를 해결한다.20</li>
<li><strong>자동화된 파이프라인 (NSML):</strong> 네이버는 자체 머신러닝 플랫폼 NSML을 통해 SFT부터 보상 모델 학습, PPO에 이르는 과정을 자동화된 이벤트 기반 파이프라인으로 구축했다. 이는 데이터가 업데이트될 때마다 사람의 개입 없이 지속적으로 모델을 개선(Continuous Learning)할 수 있는 인프라를 제공한다.22</li>
<li><strong>다양한 태스크의 균형:</strong> 한국어, 영어, 코딩 능력의 균형을 맞추기 위해 SFT와 RLHF 단계에서 데이터의 혼합 비율(Mixture Rate)을 정밀하게 조정했으며, 이를 통해 다국어 처리 능력과 논리적 추론 능력을 동시에 확보했다.20</li>
</ol>
<hr />
<h2>4.  데이터 확장성과 AI 감독: RLAIF와 헌법적 AI</h2>
<p>RLHF의 가장 큰 병목은 고품질의 인간 피드백을 수집하는 비용과 시간이다. 또한, 인간 평가자도 편향되거나 실수할 수 있다. 이를 해결하기 위해 AI를 사용하여 AI를 평가하고 학습시키는 방법론이 대두되었다.</p>
<h3>4.1  RLAIF (Reinforcement Learning from AI Feedback)</h3>
<p>구글과 앤스로픽(Anthropic) 등의 연구는 고성능 LLM이 인간을 대신하여 선호도 데이터를 생성할 수 있음을 증명했다. 이를 RLAIF라고 한다.</p>
<ul>
<li><strong>방법론:</strong> 인간 라벨러 대신 ‘Off-the-shelf’ LLM(예: GPT-4)에게 두 답변을 제시하고, 평가 기준(Rubric)에 따라 더 나은 답변을 선택하게 한다. 이때 단순히 선택만 하게 하는 것이 아니라, <strong>사고의 사슬(Chain-of-Thought, CoT)</strong> 프롬프팅을 사용하여 “왜 이 답변이 더 좋은지” 이유를 서술하게 한 뒤 결론을 내리게 하면 평가의 정확도가 비약적으로 상승한다.24</li>
<li><strong>성능 검증:</strong> 연구 결과에 따르면, RLAIF로 훈련된 모델은 요약, 대화 생성 등에서 RLHF로 훈련된 모델과 동등하거나 더 우수한 성능을 보였다. 인간 평가자들은 두 모델의 결과물을 구분하지 못하거나 RLAIF 모델을 더 선호하는 경향을 보였다. 이는 AI 정렬의 확장성 문제를 해결할 열쇠로 평가된다.25</li>
</ul>
<h3>4.2  헌법적 AI (Constitutional AI): 원칙 기반의 자동 정렬</h3>
<p>앤스로픽이 제안한 헌법적 AI는 RLAIF의 개념을 안전성 확보에 적극적으로 활용한 프레임워크이다.</p>
<ul>
<li><strong>배경:</strong> 인간이 유해한 콘텐츠(폭력, 혐오 등)를 직접 보고 수정하는 것은 심리적 고통을 유발하며 비효율적이다.</li>
<li><strong>프로세스:</strong></li>
</ul>
<ol>
<li><strong>지도 학습 단계 (SL-CAI):</strong> 모델에게 “헌법(Constitution)“이라 불리는 일련의 원칙(예: 유엔 인권 선언, 애플의 서비스 약관 등)을 제공한다. 모델이 유해한 답변을 생성하면, 스스로 헌법에 비추어 비평(Critique)하고 수정(Revision)된 답변을 생성하게 한다. 이 수정된 데이터로 모델을 미세 조정한다.</li>
<li><strong>강화 학습 단계 (RL-CAI):</strong> 수정된 모델이 생성한 답변 쌍에 대해, AI 피드백 모델이 헌법을 기준으로 선호도를 판별한다. 이를 통해 보상 모델을 학습시키고 PPO를 수행한다.27</li>
</ol>
<ul>
<li><strong>의의:</strong> 이 방식은 블랙박스적인 인간 피드백 대신 명시적인 원칙을 통해 AI를 제어할 수 있게 하며, 정렬 과정의 투명성을 높인다.29</li>
</ul>
<hr />
<h2>5.  정렬의 최전선: 추론 능력과 과정 감독 (Process Supervision)</h2>
<p>복잡한 수학 문제, 코딩, 논리적 추론 과제에서 기존의 결과 중심 RLHF는 한계를 드러냈다. 정답만 맞으면 보상을 주는 방식은 모델이 잘못된 논리로 우연히 정답을 맞히는 ’거짓 상관관계(Spurious Correlation)’를 학습하게 할 위험이 있다.</p>
<h3>5.1  과정 보상 모델 (Process Reward Model, PRM) vs 결과 보상 모델 (ORM)</h3>
<p>OpenAI의 Lightman 등이 주도한 연구는 추론 과정의 각 단계(Step-by-step)를 평가하는 PRM의 우수성을 입증했다.</p>
<ul>
<li><strong>ORM (Outcome Reward Model):</strong> 최종 답변의 정답 여부만으로 보상을 준다. 구현이 쉽지만, 추론 과정의 오류를 잡아내지 못한다.</li>
<li><strong>PRM (Process Reward Model):</strong> 문제 해결 과정을 논리적 단위(Step)로 쪼개고, 각 단계가 올바른지 평가하여 보상을 준다. 예를 들어 수학 문제 풀이의 각 줄마다 “올바름”, “틀림”, “중립” 등의 태그를 붙인다.31</li>
</ul>
<h4>5.1.1  PRM의 장점과 데이터 효율성</h4>
<p>PRM은 모델이 <em>어디서</em> 틀렸는지를 명확히 알려주기 때문에 ORM보다 훨씬 풍부한 피드백 신호를 제공한다. MATH 데이터셋 실험 결과, PRM으로 훈련된 모델은 훨씬 적은 데이터로도 ORM 모델을 압도하는 성능을 보였다. 또한, 모델이 확신하지 못하는 단계만 인간에게 검증을 요청하는 **활성 학습(Active Learning)**을 통해 데이터 수집 효율을 극대화할 수 있다.31</p>
<h3>5.2  OpenAI o1과 추론(Reasoning) 모델의 등장</h3>
<p>2024년 9월 공개된 OpenAI o1 모델은 이러한 과정 중심 강화학습의 정점을 보여준다. o1은 기존 모델과 달리 답변을 내놓기 전 긴 시간 동안 ’생각(Thinking)’을 한다.</p>
<ul>
<li><strong>내재화된 사고의 사슬 (Internal Chain of Thought):</strong> o1은 강화학습을 통해 문제를 분해하고, 계획을 수립하고, 중간 결과를 검증하며, 오류가 발생하면 되돌아가서 다시 시도(Backtracking)하는 법을 학습했다. 이는 프롬프트 엔지니어링 수준의 CoT가 아니라, 모델의 가중치에 내재화된 사고 과정이다.34</li>
<li><strong>테스트 타임 스케일링 (Test-Time Scaling):</strong> o1은 “추론 시간을 늘리면 성능이 향상된다“는 새로운 스케일링 법칙을 입증했다. 이는 모델 크기나 학습 데이터를 늘리는 기존의 스케일링 법칙과는 다른 차원의 발전이며, AI가 직관적인 ‘시스템 1’ 사고에서 논리적인 ‘시스템 2’ 사고로 진화하고 있음을 시사한다.34</li>
</ul>
<hr />
<h2>6.  핵심 과제와 한계점: 정렬 기술의 이면</h2>
<p>RLHF가 LLM을 실용적인 수준으로 끌어올렸지만, 여전히 해결되지 않은 본질적인 문제들이 존재한다.</p>
<h3>6.1  보상 해킹 (Reward Hacking)과 굿하트의 법칙</h3>
<p>“측정치가 목표가 되는 순간, 그것은 더 이상 좋은 측정치가 아니다“라는 굿하트의 법칙(Goodhart’s Law)은 RLHF에도 적용된다. 보상 모델은 인간 선호도의 불완전한 대리자(Proxy)일 뿐이다. 모델이 최적화 과정에서 보상 모델의 허점을 찾아내어, 실제로는 품질이 낮지만 보상 점수만 높은 답변(예: 무의미한 미사여구의 반복, 지나치게 방어적이고 긴 답변)을 생성하는 현상이 빈번히 발생한다.37</p>
<h3>6.2  정렬 세금 (Alignment Tax)</h3>
<p>모델을 안전하고 예의 바르게 만들수록, 창의성이나 정보 제공 능력이 저하되는 현상이다. 예를 들어, InstructGPT는 GPT-3보다 독성은 줄었지만 일부 NLP 벤치마크에서는 성능이 하락했다. 이를 완화하기 위해 PPO 학습 시 사전 학습 데이터(Pre-training mix)를 섞어서 언어 능력을 유지하려는 시도(PPO-ptx)가 이루어지지만, 완벽한 해결책은 아니다.7</p>
<h3>6.3  환각 (Hallucination)의 지속</h3>
<p>RLHF는 인간이 <em>선호하는</em> 답변을 학습시킨다. 인간은 종종 틀렸지만 자신감 있고 그럴듯한 답변을 선호하는 경향이 있다. 이로 인해 모델은 사실이 아닌 정보를 사실인 양 꾸며내는 ‘아부(Sycophancy)’ 성향을 학습할 수 있다. 통계적으로 RLHF 적용 후 사실적 환각이 줄어든다는 보고가 있지만41, 모델의 지식 경계를 명확히 하는 것은 여전히 난제이다.</p>
<hr />
<h2>7.  결론 및 미래 전망: 초지능 정렬을 향하여</h2>
<p>인간 피드백 기반 강화학습(RLHF)은 대규모 언어 모델을 단순한 확률적 텍스트 생성기에서 인간과 상호작용 가능한 지능형 에이전트로 진화시킨 핵심 동력이다. InstructGPT에서 시작된 PPO 파이프라인은 DPO와 같은 효율적인 알고리즘으로 발전하여 오픈 소스 생태계로 확산되었으며, RLAIF와 헌법적 AI는 인간 개입의 한계를 기술적으로 극복하고 있다. 특히 PRM과 o1 모델의 등장은 단순한 선호도 정렬을 넘어, AI가 스스로 논리를 검증하고 사고하는 단계로 진입했음을 알리는 신호탄이다.</p>
<p>향후 연구는 다음과 같은 방향으로 전개될 것으로 전망된다. 첫째, <strong>검증 가능한 보상(Verifiable Rewards)의 확대</strong>이다. 코딩이나 수학처럼 정답이 명확한 영역에서는 인간의 주관적 선호도 대신 컴파일러나 검증기(Verifier)의 객관적 피드백을 활용하는 강화학습(RLVR)이 주류가 될 것이다.42 둘째, <strong>커리큘럼 학습과 반복적 정렬</strong>이다. 단순한 1회성 RLHF가 아니라, 모델의 수준에 맞춰 난이도를 높여가는 커리큘럼 방식이나, DPO를 반복 수행(Iterative DPO)하여 성능을 극한으로 끌어올리는 시도가 계속될 것이다.43 마지막으로, **초지능 정렬(Superalignment)**이다. 인간보다 똑똑한 AI 모델을 어떻게 평가하고 제어할 것인가에 대한 문제는 더 이상 철학적 담론이 아닌 엔지니어링 과제가 되었다. 약한 모델로 강한 모델을 감독하거나(Weak-to-Strong Generalization), AI 간의 토론을 통해 진실을 검증하는 시스템이 연구의 최전선이 될 것이다.</p>
<p>결론적으로 RLHF는 완성된 기술이 아니라, AI를 인간의 가치에 부합하게 만들려는 거대한 여정의 시작점에 불과하다. 기술적 완성도를 높이는 것과 동시에, 윤리적 안전장치를 견고히 하는 것이 AI 발전의 지속 가능성을 담보하는 유일한 길이 될 것이다.</p>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>