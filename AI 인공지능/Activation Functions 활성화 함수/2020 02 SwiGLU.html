<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:SwiGLU 활성화 함수</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>SwiGLU 활성화 함수</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">인공지능 (Artificial Intelligence, AI)</a> / <a href="index.html">활성화 함수 (Activation Functions)</a> / <span>SwiGLU 활성화 함수</span></nav>
                </div>
            </header>
            <article>
                <h1>SwiGLU 활성화 함수</h1>
<h2>1. 서론</h2>
<p>심층 신경망(Deep Neural Network)의 근간을 이루는 핵심 원리 중 하나는 비선형성(non-linearity)의 도입이다. 만약 신경망이 선형 변환의 연속으로만 구성된다면, 전체 네트워크는 결국 하나의 거대한 선형 변환으로 축약되어 복잡한 데이터 패턴을 학습하는 능력을 상실하게 된다.1 활성화 함수는 이러한 선형 변환 사이에 비선형성을 주입하여, 신경망이 복잡하고 다양한 함수를 근사할 수 있도록 만드는 근본적인 역할을 수행한다. 각 뉴런의 출력을 조절하고 정보의 흐름을 제어하는 ’게이트키퍼(gatekeeper)’로서, 활성화 함수의 선택은 모델의 성능과 학습 동역학에 지대한 영향을 미친다.3</p>
<p>오랜 기간 동안, ReLU(Rectified Linear Unit)는 심층 신경망의 표준 활성화 함수로 군림했다. ReLU는 시그모이드(Sigmoid)나 하이퍼볼릭 탄젠트(Tanh) 함수가 겪던 경사 소실(vanishing gradient) 문제를 효과적으로 완화하고, 계산이 매우 효율적이라는 장점을 바탕으로 딥러닝의 발전을 견인했다.4 그러나 음수 입력에 대해 항상 0을 출력하여 뉴런이 학습 과정에서 비활성화되는 ‘죽은 ReLU(Dying ReLU)’ 문제와 원점에서의 미분 불가능성과 같은 내재적 한계는 더 정교하고 성능이 뛰어난 활성화 함수에 대한 연구를 촉발하는 계기가 되었다.4</p>
<p>이러한 배경 속에서 GELU(Gaussian Error Linear Unit)와 Swish와 같은 부드러운(smooth) 활성화 함수들이 ReLU의 대안으로 등장하며 주목받기 시작했다.7 본 안내서의 핵심 주제인 SwiGLU(Swish-Gated Linear Unit)는 이러한 흐름의 정점에 있는 혁신이다. SwiGLU는 단순히 더 나은 비선형 함수를 제안하는 것을 넘어, ’게이트 메커니즘(gating mechanism)’이라는 구조적 혁신을 통합하여 트랜스포머(Transformer) 아키텍처의 순방향 신경망(Feed-Forward Network, FFN) 계층 성능을 극적으로 향상시켰다.7 그 결과, Google의 PaLM, Meta의 LLaMA, Mistral AI의 Mixtral 등 현대 대규모 언어 모델(Large Language Models, LLM)의 사실상 표준 구성 요소로 자리매김하며 그 중요성을 입증했다.10 본 안내서는 SwiGLU의 이론적 기반과 작동 원리를 심층적으로 분석하고, 다른 활성화 함수와의 비교를 통해 그 장점을 명확히 하며, 최신 LLM에서의 적용 사례를 통해 그 실질적인 가치를 조명하고자 한다.</p>
<h2>2.  활성화 함수의 기초와 발전</h2>
<h3>2.1  초기 활성화 함수와 그 한계: Sigmoid와 Tanh</h3>
<p>신경망 연구 초기에는 생물학적 뉴런의 활성화 과정을 모방한 시그모이드 함수가 널리 사용되었다. 시그모이드 함수는 모든 입력 값을 <span class="math math-inline">(0, 1)</span> 사이의 범위로 압축하여 출력값을 확률적으로 해석할 수 있는 길을 열었다.1 하지만 이 함수는 입력값의 절댓값이 커질수록 함수의 기울기가 0에 수렴하는 치명적인 단점을 가지고 있었다. 역전파(backpropagation) 과정에서 이 작은 기울기들이 여러 계층을 거치며 곱해지면, 하위 계층으로 갈수록 경사가 거의 사라지는 ‘경사 소실’ 문제가 발생하여 깊은 신경망의 학습을 사실상 불가능하게 만들었다.4</p>
<p>하이퍼볼릭 탄젠트(Tanh) 함수는 출력 범위를 <span class="math math-inline">(-1, 1)</span>로 확장하고 함수 중심을 0으로 이동시켜 시그모이드 함수의 일부 문제를 완화했다. 출력값이 0을 중심으로 분포하면 학습 과정이 더 안정적이고 효율적으로 진행될 수 있기 때문이다. 그럼에도 불구하고, Tanh 함수 역시 S자 형태의 곡선을 가지므로 입력값이 극단으로 갈수록 기울기가 0에 가까워지는 본질적인 경사 소실 문제를 그대로 공유했다.13</p>
<h3>2.2  ReLU(Rectified Linear Unit)의 혁신과 과제</h3>
<p>경사 소실 문제에 대한 획기적인 해결책으로 등장한 것이 바로 ReLU이다. ReLU는 수학적으로 <span class="math math-inline">max(0, x)</span>로 매우 간단하게 정의된다.14 이 단순함은 두 가지 큰 혁신을 가져왔다. 첫째, 양수 입력에 대해서는 기울기가 항상 1로 일정하기 때문에, 네트워크가 깊어져도 경사가 소실되지 않고 효과적으로 전파될 수 있었다.4 둘째, 지수 함수 계산이 필요한 시그모이드나 Tanh와 달리 단순 비교 연산만으로 계산이 가능하여 계산 효율성이 비약적으로 향상되었다.4</p>
<p>그러나 ReLU 역시 완벽하지 않았다. 가장 큰 단점은 음수 입력에 대해 출력이 항상 0이 되고 기울기 또한 0이 되는 ‘죽은 ReLU’ 현상이다. 만약 특정 뉴런이 한 번 음수 값을 입력받아 출력이 0이 되면, 그 뉴런은 더 이상 어떤 입력에 대해서도 경사를 전파하지 못하게 되어 학습 과정에서 영구적으로 비활성화될 수 있다.4 또한, 원점(<span class="math math-inline">x=0</span>)에서 미분이 불가능하다는 점도 이론적인 한계로 지적되었다.6</p>
<h3>2.3  ReLU를 넘어서: 부드러운 비선형성의 탐구</h3>
<p>ReLU의 한계를 극복하기 위해, ReLU의 장점을 유지하면서도 단점을 보완하는 부드럽고 미분 가능한 함수들에 대한 연구가 활발히 진행되었다.</p>
<h4>2.3.1 GELU (Gaussian Error Linear Unit)</h4>
<p>GELU는 ReLU를 확률론적 관점에서 일반화한 함수다. 이 함수는 입력값 <span class="math math-inline">x</span>에 표준 정규 분포의 누적 분포 함수(Cumulative Distribution Function, CDF) <span class="math math-inline">Φ(x)</span>를 곱하는 방식으로 정의된다.7 수학적 공식은 다음과 같다.<br />
<span class="math math-display">
GELU(x) = x \cdot \Phi(x)
</span><br />
이는 입력의 크기에 따라 확률적으로 뉴런의 활성화를 조절하는 개념으로 해석할 수 있다. GELU는 모든 지점에서 미분 가능하며 ReLU보다 부드러운 곡선 형태를 띠어, 학습의 안정성을 높이는 데 기여할 수 있다.10</p>
<h4>2.3.2 Swish와 SiLU (Sigmoid Linear Unit)</h4>
<p>Swish 함수는 입력값 <span class="math math-inline">x</span>에 시그모이드 함수를 곱한 형태로, 자기 게이팅(self-gating)의 특성을 보인다.1 일반적인 공식은 다음과 같으며, 여기서 <span class="math math-inline">β</span>는 학습 가능한 파라미터다.<br />
<span class="math math-display">
Swish_{\beta}(x) = x \cdot \sigma(\beta x)
</span><br />
실제 구현에서는 <span class="math math-inline">β</span>를 1로 고정한 형태가 널리 사용되는데, 이를 특별히 SiLU(Sigmoid Linear Unit)라고 부르며 PyTorch와 같은 딥러닝 프레임워크에서 표준으로 제공된다.2 Swish/SiLU는 ReLU와 유사한 형태를 가지면서도 음수 영역에서 작은 음수 값을 가질 수 있는 비단조적(non-monotonic) 특성을 보인다. 이 특성과 전 구간에서 부드러운 곡선 덕분에 ‘죽은 ReLU’ 문제를 피하고 경사 흐름을 개선하여, 많은 실험에서 ReLU와 GELU를 능가하는 성능을 입증했다.2</p>
<p>활성화 함수의 발전 과정은 ’정보 손실 최소화’와 ‘표현력 극대화’ 사이의 균형을 찾아가는 여정으로 해석할 수 있다. 시그모이드와 Tanh는 입력 범위 전체를 압축하면서 극단값의 정보를 소실시키고 경사를 죽인다. ReLU는 음수 영역의 모든 정보를 0으로 만들어 버리는 극단적인 정보 손실을 감수하는 대신 계산 효율과 경사 문제를 해결했다. GELU와 Swish/SiLU는 이러한 정보 손실을 최소화하려는 시도다. 이들은 음수 영역에서도 정보를 완전히 차단하지 않고, 부드러운 곡선을 통해 입력값의 미세한 변화를 출력에 반영한다. 특히 Swish의 비단조성은 단순한 단조 증가 함수보다 더 복잡한 함수를 근사할 수 있는 잠재력, 즉 표현력의 극대화를 시사한다.2 이러한 진화의 흐름 속에서, SwiGLU는 구조적인 혁신을 통해 이 두 가지 목표를 한 단계 더 높은 수준에서 달성하게 된다.</p>
<h2>3.  게이트 메커니즘과 Gated Linear Unit (GLU)</h2>
<h3>3.1  게이팅(Gating)의 개념: 정보 흐름의 동적 제어</h3>
<p>게이트 메커니즘은 신경망 내에서 정보의 흐름을 동적으로 제어하는 장치다. 이 개념은 순환 신경망(Recurrent Neural Network, RNN)의 장기 의존성 문제를 해결하기 위해 등장한 LSTM(Long Short-Term Memory)과 GRU(Gated Recurrent Unit)에서 처음으로 핵심적인 역할을 수행했다.21 LSTM의 입력 게이트, 망각 게이트, 출력 게이트는 시퀀스 데이터의 각 시점에서 어떤 정보를 새로 받아들이고, 어떤 정보를 잊어버리며, 어떤 정보를 다음 단계로 전달할지를 학습을 통해 동적으로 결정한다. 이처럼 게이트는 입력 데이터에 따라 정보의 흐름을 유연하게 조절하는 역할을 한다. 이러한 아이디어는 순방향 신경망(FFN)에도 적용되어, 입력 데이터 자체의 특성에 따라 정보의 통과 여부나 강도를 조절하는 메커니즘의 필요성을 제기했다.22</p>
<h3>3.2  Gated Linear Unit (GLU)의 구조와 수학적 정의</h3>
<p>2016년 Yann Dauphin 등이 제안한 Gated Linear Unit (GLU)은 게이트 메커니즘을 FFN에 성공적으로 적용한 사례다.7 GLU의 핵심 아이디어는 입력 <span class="math math-inline">x</span>를 두 개의 독립적인 경로로 나누어 처리하는 것이다. 하나의 경로는 데이터를 변환하고, 다른 하나는 이 데이터의 어느 부분을 통과시킬지를 결정하는 ‘게이트’ 역할을 한다. 두 경로의 결과는 요소별 곱셈(element-wise multiplication)을 통해 결합된다.7</p>
<p>GLU의 완전한 수학적 공식은 다음과 같다.<br />
<span class="math math-display">
GLU(x, W, V, b, c) = (xW + b) \otimes \sigma(xV + c)
</span><br />
여기서 <span class="math math-inline">W</span>, <span class="math math-inline">V</span>는 가중치 행렬이고 <span class="math math-inline">b</span>, <span class="math math-inline">c</span>는 편향 벡터다. <span class="math math-inline">(xW + b)</span>는 ’데이터 경로(data path)’로, 입력 데이터를 선형 변환하는 역할을 한다. <span class="math math-inline">σ(xV + c)</span>는 ’게이트 경로(gate path)’로, 또 다른 선형 변환 결과에 시그모이드 함수(<span class="math math-inline">σ</span>)를 적용하여 <span class="math math-inline">(0, 1)</span> 사이의 값을 갖는 게이트 벡터를 생성한다. <span class="math math-inline">⊗</span> 기호는 두 벡터 간의 요소별 곱셈을 의미한다.7</p>
<h3>3.3  GLU의 작동 원리: 동적 정보 필터링</h3>
<p>GLU의 작동 원리는 동적 정보 필터링으로 요약할 수 있다. 게이트 경로 <span class="math math-inline">σ(xV + c)</span>의 출력 벡터는 각 차원(뉴런)에 대해 0과 1 사이의 값을 가진다. 이 값은 데이터 경로 <span class="math math-inline">(xW + b)</span>의 해당 차원 값이 얼마나 통과될지를 결정하는 스위치 또는 필터 역할을 한다.11 게이트 값이 1에 가까우면 정보가 거의 그대로 통과하고, 0에 가까우면 정보가 차단된다.</p>
<p>중요한 점은 이 게이트 값이 입력 <span class="math math-inline">x</span>에 따라 동적으로 계산된다는 것이다. 이는 ReLU나 GELU와 같은 정적인 활성화 함수가 모든 입력에 동일한 변환을 적용하는 것과 근본적인 차이를 만든다. GLU는 데이터에 의존적인(data-dependent) 비선형 변환을 수행함으로써, 네트워크가 각 토큰의 문맥적 특성에 맞춰 정보의 흐름을 지능적으로 라우팅할 수 있는 능력을 부여한다.11</p>
<h3>3.4  GLU의 이론적 장점</h3>
<p>GLU는 두 가지 주요 이론적 장점을 가진다. 첫째, 경사 흐름을 개선한다. GLU의 경사를 계산할 때, 게이트가 열려있는(시그모이드 출력이 1에 가까운) 뉴런에 대해서는 경사가 축소되지 않고 데이터 경로를 통해 거의 그대로 전달되는 경로가 존재한다. 이는 일종의 ’곱셈 기반 스킵 연결(multiplicative skip connection)’로 작용하여, 깊은 네트워크에서 발생할 수 있는 경사 소실 문제를 완화하는 데 기여한다.21</p>
<p>둘째, 모델의 표현력을 증대시킨다. GLU는 선형 경로를 통해 정보를 보존하면서도, 게이팅 메커니즘을 통해 복잡하고 문맥에 의존적인 비선형 패턴을 학습할 수 있는 능력을 확보한다.23</p>
<p>GLU의 도입은 트랜스포머 아키텍처에 중요한 의미를 가진다. 기존 트랜스포머에서 동적인 정보 선택은 주로 어텐션(attention) 계층의 역할이었다. 어텐션은 토큰 간의 관계를 바탕으로 어떤 토큰에 ’주의’를 기울일지 동적으로 결정한다. 반면, FFN 계층은 각 토큰을 독립적으로 처리하며 고정된 비선형 변환을 적용할 뿐이었다. GLU는 FFN 계층에 ‘어텐션과 유사한(attention-like)’ 동적 선택성을 부여한다. 즉, 어텐션이 토큰 간의 관계를 가중치로 조절한다면, GLU는 FFN 내부에서 토큰 자체의 내용에 기반하여 <em>특성(feature) 채널</em>의 중요도를 동적으로 조절하는 역할을 한다고 볼 수 있다.11 이는 어텐션 계층에만 국한되었던 동적 정보 라우팅 개념을 FFN 계층으로 확장한 것으로, 트랜스포머 블록 전체의 표현력을 비약적으로 향상시키는 근본적인 아키텍처 개선으로 평가할 수 있다.</p>
<h2>4.  SwiGLU의 구조와 작동 원리</h2>
<h3>4.1  Swish와 GLU의 결합: SwiGLU의 탄생</h3>
<p>SwiGLU는 2020년 Noam Shazeer의 논문 “GLU Variants Improve Transformer“에서 제안된 여러 GLU 변형 중 하나다.7 이 논문은 기존 GLU의 게이트 활성화 함수인 시그모이드를 다른 함수로 교체했을 때의 성능을 체계적으로 비교 분석했다. SwiGLU는 이름에서 유추할 수 있듯이, GLU의 시그모이드 게이트를 Swish 함수로 대체한 구조다.1 이 간단한 변경은 트랜스포머 모델의 성능을 크게 향상시키는 결과를 낳았고, 이후 SwiGLU가 널리 채택되는 계기가 되었다.</p>
<h3>4.2  SwiGLU의 수학적 공식 상세 분석</h3>
<p>SwiGLU의 수학적 공식은 GLU의 공식에서 시그모이드 함수 <span class="math math-inline">σ</span>를 Swish 함수로 대체한 형태다. 편향(bias) 항을 포함한 일반적인 공식은 다음과 같다.<br />
<span class="math math-display">
SwiGLU(x, W, V, b, c, \beta) = Swish_{\beta}(xW + b) \otimes (xV + c)
</span><br />
그러나 대규모 언어 모델 구현에서는 학습 안정성을 위해 편향 항을 생략하는 경우가 많다.7 트랜스포머의 FFN 계층에 적용될 때, SwiGLU는 일반적으로 다음과 같은 형태로 구성된다.<br />
<span class="math math-display">
FFN_{SwiGLU}(x, W, V, W_2) = (Swish_1(xW) \otimes (xV)) W_2
</span><br />
여기서 입력 <span class="math math-inline">x</span>는 <span class="math math-inline">W</span>와 <span class="math math-inline">V</span>라는 두 개의 다른 가중치 행렬과 곱해져 두 개의 중간 표현을 생성한다. 하나(<span class="math math-inline">xW</span>)는 Swish 함수를 통과하고, 다른 하나(<span class="math math-inline">xV</span>)는 그대로 사용된다. 이 두 결과가 요소별로 곱해진 후, 다시 <span class="math math-inline">W_2</span> 행렬과 곱해져 최종 출력 차원으로 변환된다. 여기서 Swish 함수의 <span class="math math-inline">β</span> 파라미터는 일반적으로 1로 고정되며, 이는 SiLU 함수를 사용하는 것과 동일하다.7</p>
<h3>4.3  GLU 변형들과의 비교 분석</h3>
<p>“GLU Variants Improve Transformer” 논문은 SwiGLU 외에도 다양한 GLU 변형들을 실험하고 그 성능을 비교했다.7 주요 변형들과의 비교는 SwiGLU의 우수성을 이해하는 데 중요한 단서를 제공한다.</p>
<ul>
<li><strong>ReGLU (Rectified Gated Linear Unit):</strong> 게이트 활성화 함수로 ReLU(<span class="math math-inline">max(0, x)</span>)를 사용한다. 이 경우 게이트의 출력은 0 또는 양수 값을 가지게 되어, 정보를 완전히 차단하거나 선형적으로 통과시키는 ’하드 게이팅(hard gating)’에 가깝다.</li>
<li><strong>GEGLU (Gaussian Error Gated Linear Unit):</strong> 게이트로 GELU를 사용한다. GELU는 부드러운 곡선을 가지므로, 정보의 흐름을 점진적으로 조절하는 ’소프트 게이팅(soft gating)’을 수행한다.28</li>
<li><strong>SwiGLU (Swish-Gated Linear Unit):</strong> 게이트로 Swish를 사용한다. GEGLU와 마찬가지로 부드러운 소프트 게이팅을 제공하며, Swish 고유의 비단조적 특성이 추가적인 이점을 제공할 수 있다.</li>
</ul>
<p>실험 결과, GEGLU와 SwiGLU가 다른 변형들(ReGLU 포함)에 비해 일관되게 가장 우수한 성능, 즉 가장 낮은 Perplexity(혼잡도)를 기록했다.27 이는 게이팅 메커니즘에서 정보의 흐름을 급격하게 차단하거나 통과시키는 것보다, 부드럽고 점진적으로 조절하는 방식이 더 효과적임을 시사한다. 특히, 음수 영역에서 정보를 완전히 차단하지 않고 미세한 경사를 유지하는 GELU와 Swish 함수가 게이트로서 더 나은 성능을 보인 것은, 정보의 손실을 최소화하면서 유연하게 흐름을 제어하는 능력의 중요성을 보여준다.</p>
<h2>5.  SwiGLU의 성능 및 이론적 장점 분석</h2>
<h3>5.1  표현력 증대: 동적 특징 선택과 고차 상호작용 모델링</h3>
<p>SwiGLU의 가장 큰 장점은 모델의 표현력을 근본적으로 향상시킨다는 점에 있다. 게이트 메커니즘은 FFN 블록이 각 토큰에 대해 동적인 ‘라우터(router)’ 또는 ’특징 선택기(feature selector)’처럼 작동하게 한다.11 어텐션 계층이 토큰 간의 관계를 동적으로 조절한다면, SwiGLU가 적용된 FFN 계층은 토큰 내부의 다양한 특징(feature)들 중 어떤 것을 증폭하고 어떤 것을 억제할지를 동적으로 결정하는 역할을 분담한다.</p>
<p>더 나아가, SwiGLU는 고차 함수를 근사할 수 있는 능력을 부여한다. SwiGLU의 구조는 <span class="math math-inline">(xW)</span>와 <span class="math math-inline">Swish(xV)</span>라는 <span class="math math-inline">x</span>에 대한 두 함수의 곱으로 이루어져 있다. 이는 결과적으로 <span class="math math-inline">x</span>의 다항식, 예를 들어 2차 함수(<span class="math math-inline">x^2</span>)와 같은 고차 상호작용을 모델링할 수 있게 한다.29 선형 계층과 ReLU의 단순한 조합만으로는 이러한 복잡한 패턴을 효율적으로 학습하기 어렵다. 이처럼 고차 상호작용을 직접 모델링할 수 있는 능력은 네트워크가 더 풍부하고 복잡한 데이터의 관계를 포착할 수 있게 하여 모델의 전반적인 표현력을 크게 향상시킨다.11</p>
<h3>5.2  경사 흐름 최적화 및 학습 안정성</h3>
<p>SwiGLU는 대규모 모델의 학습을 안정시키는 데 중요한 역할을 한다. 게이트로 사용되는 Swish 함수는 모든 지점에서 미분 가능하며, ReLU처럼 특정 지점에서 기울기가 급격하게 변하지 않는 부드러운 경사 곡선을 가진다.2 이러한 평활성(smoothness)은 경사 하강법 기반 최적화 과정에서 안정적인 경사 흐름을 제공하여 학습을 원활하게 한다.</p>
<p>또한, Swish 함수는 음수 입력에 대해서도 경사가 0이 아니기 때문에 ‘죽은 뉴런’ 문제를 효과적으로 방지한다.1 네트워크가 깊어질수록 죽은 뉴런 문제는 학습을 저해하는 심각한 요인이 될 수 있는데, SwiGLU는 이러한 위험을 줄여 깊은 네트워크의 학습 안정성을 크게 향상시킨다.</p>
<h3>5.3  기존 활성화 함수(ReLU, GELU)와의 심층 비교</h3>
<p>SwiGLU는 성능, 계산 복잡성, 파라미터 효율성 측면에서 기존 활성화 함수들과 뚜렷한 차이를 보인다.</p>
<ul>
<li><strong>성능:</strong> 다수의 연구와 실제 LLM 적용 사례에서, 동일한 파라미터 및 계산량 조건으로 조정했을 때 SwiGLU 기반 FFN은 ReLU나 GELU 기반 FFN보다 일관되게 우수한 성능(낮은 손실, 높은 정확도)을 보인다.2</li>
<li><strong>계산 복잡성:</strong> SwiGLU는 세 개의 가중치 행렬(<span class="math math-inline">W, V, W_2</span>)과 지수 함수 계산이 포함된 Swish 함수를 사용하므로, 두 개의 행렬과 단순한 <span class="math math-inline">max</span> 연산만 사용하는 ReLU 기반 FFN보다 계산 비용이 더 높다.7</li>
<li><strong>파라미터 효율성:</strong> SwiGLU는 더 많은 가중치 행렬을 사용하지만, 제5장에서 자세히 다룰 ’2/3 규칙’을 통해 전체 파라미터 수를 기존 FFN과 유사하게 유지하면서도 더 높은 성능을 달성한다. 이는 SwiGLU가 파라미터를 더 효율적으로 사용하여 더 풍부한 표현을 학습함을 시사한다.11</li>
</ul>
<p>SwiGLU의 성공은 단지 Swish 함수가 ReLU나 GELU보다 우수하기 때문만은 아니다. 이는 ’구조적 복잡성’과 ’경사 품질’의 시너지 효과로 해석해야 한다. GLU라는 구조는 동적 게이팅이라는 강력한 표현력을 제공하고, Swish라는 활성화 함수는 그 높은 표현력을 실제로 학습할 수 있도록 안정적이고 품질 좋은 경사를 제공한다. 즉, 강력한 구조(GLU)에 최적의 연료(Swish)를 주입한 형태다. ReGLU가 SwiGLU보다 성능이 낮은 이유는, 좋은 구조에 상대적으로 경사 품질이 낮은 ReLU를 사용했기 때문으로 설명할 수 있다. 이처럼 SwiGLU는 구조와 함수의 이상적인 결합을 통해 새로운 차원의 성능을 이끌어냈다.</p>
<p>다음 표는 주요 활성화 함수의 특징을 요약하여 비교한 것이다.</p>
<table><thead><tr><th>함수 (Function)</th><th>수학적 공식 (Mathematical Formula)</th><th>주요 특징 (Key Characteristics)</th><th>장점 (Advantages)</th><th>단점/한계 (Disadvantages/Limitations)</th></tr></thead><tbody>
<tr><td><strong>ReLU</strong></td><td><span class="math math-inline">max(0, x)</span></td><td>단조적, 비평활(x=0), 희소 활성화</td><td>계산 효율성 높음, 경사 소실 완화</td><td>죽은 뉴런 문제, x=0에서 미분 불가</td></tr>
<tr><td><strong>GELU</strong></td><td><span class="math math-inline">x \cdot \Phi(x)</span></td><td>비단조적, 평활, 확률적 가중</td><td>평활한 경사, ReLU보다 높은 표현력</td><td>ReLU보다 계산 비용 높음</td></tr>
<tr><td><strong>Swish/SiLU</strong></td><td><span class="math math-inline">x \cdot \sigma(\beta x)</span> (SiLU: <span class="math math-display">\beta=1</span>)</td><td>비단조적, 평활, 자기 게이팅</td><td>평활한 경사, 죽은 뉴런 방지, 경험적 성능 우수</td><td>ReLU보다 계산 비용 높음</td></tr>
<tr><td><strong>GLU</strong></td><td><span class="math math-inline">(xW+b) \otimes \sigma(xV+c)</span></td><td>동적 게이팅, 입력 의존적 비선형성</td><td>동적 정보 필터링, 경사 흐름 개선</td><td>파라미터 수 증가, 계산 비용 증가</td></tr>
<tr><td><strong>SwiGLU</strong></td><td><span class="math math-inline">(xW+b) \otimes Swish(xV+c)</span></td><td>동적 게이팅, 평활한 비단조 게이트</td><td>최고의 경험적 성능, 동적 특징 선택, 풍부한 표현력</td><td>GLU 변형 중 계산 비용 가장 높음, 파라미터 수 많음</td></tr>
</tbody></table>
<h2>제5장: 최신 대규모 언어 모델(LLM)에서의 SwiGLU 적용</h2>
<h3>5.1. SwiGLU를 채택한 주요 LLM 아키텍처 분석</h3>
<p>SwiGLU의 이론적 우수성은 실제 세계의 최첨단 대규모 언어 모델(LLM)에 의해 입증되었다. 다수의 주요 LLM이 FFN 계층의 활성화 함수로 SwiGLU를 채택하면서, 이는 사실상 업계 표준으로 자리 잡았다.</p>
<ul>
<li><strong>Google PaLM &amp; Gemini:</strong> Google의 Pathways Language Model (PaLM)은 SwiGLU를 채택한 대표적인 초기 대규모 모델이다. PaLM 논문에서는 기존의 ReLU나 GELU 대신 SwiGLU를 사용함으로써 모델의 품질이 크게 향상되었다고 명시적으로 밝혔다.11 이는 SwiGLU가 수천억 개 파라미터 규모의 거대 모델에서도 효과적이라는 강력한 증거가 되었으며, 이후 LLM 아키텍처 설계에 큰 영향을 미쳤다.</li>
<li><strong>Meta LLaMA (1, 2, 3):</strong> Meta에서 개발한 LLaMA 시리즈는 오픈소스 LLM 생태계에 큰 파장을 일으켰다. LLaMA 모델들은 아키텍처의 핵심 결정 사항 중 하나로 FFN의 비선형 함수로 SwiGLU를 채택했다.10 LLaMA의 뛰어난 성능과 효율성이 널리 알려지면서, SwiGLU의 위상은 연구 단계를 넘어 산업계의 표준으로 격상되었다.</li>
<li><strong>Mistral &amp; Mixtral:</strong> 프랑스의 스타트업 Mistral AI가 개발한 Mistral 7B와, 이를 기반으로 한 희소 전문가 혼합(Sparse Mixture of Experts, MoE) 모델인 Mixtral 역시 FFN 계층에 SwiGLU를 사용한다.11 특히 Mixtral의 경우, 여러 전문가 네트워크 각각의 내부 FFN에 SwiGLU를 적용했는데, 이는 SwiGLU가 MoE와 같은 복잡한 아키텍처에서도 효과적으로 작동함을 보여주는 중요한 사례다.</li>
</ul>
<h3>5.2. 실질적 구현 시 고려사항: 파라미터와 계산량 균형</h3>
<p>SwiGLU를 실제 모델에 적용할 때는 파라미터 수와 계산량을 신중하게 고려해야 한다.</p>
<h4>The 2/3 Rule</h4>
<p>표준적인 트랜스포머 FFN은 확장(<span class="math math-inline">W_1</span>)과 축소(<span class="math math-inline">W_2</span>)를 위한 두 개의 가중치 행렬을 사용한다. 반면, SwiGLU 기반 FFN은 <span class="math math-inline">W</span>, <span class="math math-inline">V</span>, <span class="math math-inline">W_2</span>라는 세 개의 가중치 행렬을 필요로 한다.7 만약 FFN의 중간 은닉 차원(<span class="math math-inline">d_ff</span>)을 동일하게 유지한다면, SwiGLU FFN의 파라미터 수는 표준 FFN보다 약 50% 증가하게 된다.11</p>
<p>이 문제를 해결하고 공정한 비교를 위해 PaLM 논문에서는 독창적인 접근법을 제안했다. 표준 FFN의 은닉 차원을 <span class="math math-inline">d_ff</span>라고 할 때, SwiGLU FFN의 은닉 차원을 약 <span class="math math-inline">(2/3) \cdot d_{ff}</span>로 설정하는 것이다.11 이렇게 하면 세 개의 행렬을 사용하더라도 전체 파라미터 수가 표준 FFN과 거의 동일하게 유지된다. 그럼에도 불구하고 SwiGLU가 더 나은 성능을 보인다는 사실은, SwiGLU가 더 적은 뉴런으로도 더 효율적이고 풍부한 표현을 학습할 수 있음을 시사하는 중요한 엔지니어링 발견이다.</p>
<h4>하드웨어 가속</h4>
<p>실제 구현에서는 하드웨어의 계산 효율을 극대화하기 위한 추가적인 최적화가 이루어진다. GPU나 TPU와 같은 가속기는 특정 크기의 행렬 곱셈 연산에서 최고의 성능을 발휘한다. 따라서 FFN의 은닉 차원을 8 또는 16의 배수로 설정하여 하드웨어 활용도를 높이고 학습 속도를 개선하는 기법이 널리 사용된다.11</p>
<p>SwiGLU의 광범위한 채택은 LLM 아키텍처 설계 철학의 변화를 반영한다. 초기 트랜스포머 모델들은 ReLU와 같은 비교적 단순한 구성요소를 깊게 쌓는 ‘단순성의 확장’ 전략을 따랐다. 그러나 PaLM, LLaMA와 같은 후기 모델들은 RMSNorm, RoPE, 그리고 SwiGLU와 같이 더 정교하고 복잡한 구성요소를 도입했다. SwiGLU는 단순한 비선형 함수가 아니라, 내부에 여러 선형 변환과 요소별 곱셈을 포함하는 ’작은 서브네트워크’에 가깝다. 이는 모델 설계자들이 단순히 네트워크를 더 크고 깊게 만드는 것을 넘어, 각 구성요소 자체의 표현력과 제어 능력을 높이는 ’제어된 복잡성’을 추구하는 방향으로 전환했음을 의미한다. SwiGLU의 성공은 FFN 계층에 이러한 제어된 복잡성을 추가하는 것이 전체 모델의 성능과 효율에 큰 이득을 가져다준다는 것을 증명한 사례다.</p>
<h2>결론: SwiGLU의 현재와 미래</h2>
<p>SwiGLU 활성화 함수는 현대 심층 신경망, 특히 대규모 언어 모델의 발전에 있어 중요한 이정표를 세웠다. 동적 게이트 메커니즘을 통해 순방향 신경망(FFN) 계층에 전례 없는 표현력을 부여하고, Swish 함수의 부드러운 경사 특성을 활용하여 대규모 모델의 학습을 안정화시킴으로써, SwiGLU는 오늘날 최첨단 LLM 아키텍처의 핵심 부품으로 확고히 자리 잡았다. 이는 단순한 활성화 함수의 교체를 넘어, 네트워크의 정보 처리 방식에 대한 근본적인 개선을 이룬 구조적 혁신으로 평가받아야 한다.</p>
<p>흥미롭게도, SwiGLU의 성공 신화는 현대 딥러닝 연구의 한 단면을 보여준다. SwiGLU를 제안한 “GLU Variants Improve Transformer” 논문의 저자들은 그 성공의 원인에 대해 “왜 이러한 아키텍처가 잘 작동하는지에 대한 설명을 제공하지 않는다. 우리는 그 성공을, 다른 모든 것과 마찬가지로, 신성한 자비(divine benevolence) 덕분으로 돌린다“고 유머러스하게 언급했다.1 이 언급은 엄격한 이론적 증명보다 경험적 성공이 연구를 주도하는 현대 딥러닝 분야의 경향을 상징적으로 보여준다. SwiGLU의 사례는 때로는 직관과 실험적 발견이 이론적 이해를 앞서나가며 새로운 기술적 지평을 열 수 있음을 시사한다.</p>
<p>그러나 학계와 산업계는 SwiGLU의 성공에 안주하지 않고 활성화 함수에 대한 연구를 계속하고 있다. <span class="math math-inline">ReLU^2</span>와 같이 더 단순하면서도 SwiGLU와 유사한 고차 상호작용 모델링 능력을 갖춘 함수에 대한 연구가 진행되고 있으며 8, 게이트 메커니즘 자체를 개선하려는 노력도 이어지고 있다. 예를 들어, 게이트의 출력 범위를 <span class="math math-inline">(0, 1)</span> 이상으로 확장하거나(Expanded Gating Ranges), 아크탄젠트(arctan)와 같은 새로운 함수를 게이트로 탐색하는 연구는 활성화 함수가 여전히 활발하고 역동적인 연구 분야임을 보여준다.36</p>
<p>결론적으로, SwiGLU는 ’동적 비선형성’이라는 새로운 패러다임을 제시하며 활성화 함수의 역할을 재정의했다. 앞으로 등장할 새로운 신경망 아키텍처들은 SwiGLU가 열어젖힌 이 길 위에서 더욱 정교하고 효율적인 정보 처리 메커니즘을 탐구하게 될 것이다. SwiGLU는 그 자체로 뛰어난 성능을 제공할 뿐만 아니라, 미래의 혁신을 위한 중요한 영감의 원천으로 계속해서 기능할 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>What is SwiGLU? - J. Carlos Roldán, 8월 29, 2025에 액세스, https://jcarlosroldan.com/post/348</li>
<li>Exploring SwiGLU : The Activation Function Powering Modern LLMs …, 8월 29, 2025에 액세스, https://medium.com/@s_boudefel/exploring-swiglu-the-activation-function-powering-modern-llms-9697f88221e7</li>
<li>Activation Functions - Deepgram, 8월 29, 2025에 액세스, https://deepgram.com/ai-glossary/activation-functions</li>
<li>What are the advantages of ReLU over sigmoid function in deep neural networks?, 8월 29, 2025에 액세스, https://stats.stackexchange.com/questions/126238/what-are-the-advantages-of-relu-over-sigmoid-function-in-deep-neural-networks</li>
<li>ReLU vs. Sigmoid Function in Deep Neural Networks | dl-question-bank – Weights &amp; Biases, 8월 29, 2025에 액세스, https://wandb.ai/ayush-thakur/dl-question-bank/reports/ReLU-vs-Sigmoid-Function-in-Deep-Neural-Networks–VmlldzoyMDk0MzI</li>
<li>What are the benefits of using SoftPlus over ReLU activation functions? - Cross Validated, 8월 29, 2025에 액세스, https://stats.stackexchange.com/questions/534908/what-are-the-benefits-of-using-softplus-over-relu-activation-functions</li>
<li>[2002.05202] GLU Variants Improve Transformer - ar5iv - arXiv, 8월 29, 2025에 액세스, https://ar5iv.labs.arxiv.org/html/2002.05202</li>
<li>Deriving Activation Functions via Integration - arXiv, 8월 29, 2025에 액세스, https://arxiv.org/html/2411.13010v1</li>
<li>GLU Variants Improve Transformer - ResearchGate, 8월 29, 2025에 액세스, https://www.researchgate.net/publication/339252250_GLU_Variants_Improve_Transformer</li>
<li>Beyond ReLU: Discovering the Power of SwiGLU | by heping_LU - Medium, 8월 29, 2025에 액세스, <a href="https://medium.com/@jiangmen28/beyond-relu-discovering-the-power-of-swiglu-%E8%B6%85%E8%B6%8A-relu-%E5%8F%91%E7%8E%B0-swiglu-%E7%9A%84%E5%8A%9B%E9%87%8F-9dbc7d8258bf">https://medium.com/@jiangmen28/beyond-relu-discovering-the-power-of-swiglu-%E8%B6%85%E8%B6%8A-relu-%E5%8F%91%E7%8E%B0-swiglu-%E7%9A%84%E5%8A%9B%E9%87%8F-9dbc7d8258bf</a></li>
<li>SwiGLU: The FFN Upgrade I Use to Get Free Performance - DEV Community, 8월 29, 2025에 액세스, https://dev.to/mshojaei77/swiglu-the-ffn-upgrade-i-use-to-get-free-performance-33jc</li>
<li>Mixtral - Cerebras AI, 8월 29, 2025에 액세스, https://training-docs.cerebras.ai/rel-2.6.0/model-zoo/models/nlp/mixtral</li>
<li>Activation functions in neural networks [Updated 2024] - SuperAnnotate, 8월 29, 2025에 액세스, https://www.superannotate.com/blog/activation-functions-in-neural-networks</li>
<li>Linear Layers and Activation Functions in Transformer Models - Machine Learning Mastery, 8월 29, 2025에 액세스, https://machinelearningmastery.com/linear-layers-and-activation-functions-in-transformer-models/</li>
<li>
<ol start="21">
<li>Activation Functions - Aussie AI, 8월 29, 2025에 액세스, https://www.aussieai.com/book/ch21-activation-functions</li>
</ol>
</li>
<li>Gaussian error linear unit (GELU) activation function. — activation_gelu - keras3 - Posit, 8월 29, 2025에 액세스, https://keras3.posit.co/reference/activation_gelu.html</li>
<li>Unlocking the Power of GeGLU: Advanced Activation Functions in Deep Learning - Medium, 8월 29, 2025에 액세스, https://medium.com/@juanc.olamendy/unlocking-the-power-of-geglu-advanced-activation-functions-in-deep-learning-444868d6d89c</li>
<li>Swish function - Wikipedia, 8월 29, 2025에 액세스, https://en.wikipedia.org/wiki/Swish_function</li>
<li>SiLU — PyTorch 2.8 documentation, 8월 29, 2025에 액세스, https://docs.pytorch.org/docs/stable/generated/torch.nn.SiLU.html</li>
<li>SiLU Activation Function Explained - Ultralytics, 8월 29, 2025에 액세스, https://www.ultralytics.com/glossary/silu-sigmoid-linear-unit</li>
<li>GLU: Gated Linear Unit implementation | by Alvaro Durán Tovar | Deep Learning made easy, 8월 29, 2025에 액세스, https://medium.com/deeplearningmadeeasy/glu-gated-linear-unit-21e71cd52081</li>
<li>Gating mechanism - Wikipedia, 8월 29, 2025에 액세스, https://en.wikipedia.org/wiki/Gating_mechanism</li>
<li>Gated Linear Unit — Enabling stacked convolutions to out-perform RNNs - Medium, 8월 29, 2025에 액세스, https://medium.com/@pragyansubedi/gated-linear-unit-enabling-stacked-convolutions-to-out-perform-rnns-ea08daa653b8</li>
<li>Gated Linear Unit: Transforming NLPs - Telnyx, 8월 29, 2025에 액세스, https://telnyx.com/learn-ai/gated-linear-unit</li>
<li>[D] Why do GLUs (Gated Linear Units) work? : r/MachineLearning - Reddit, 8월 29, 2025에 액세스, https://www.reddit.com/r/MachineLearning/comments/1b6ggpz/d_why_do_glus_gated_linear_units_work/</li>
<li>Paper page - GLU Variants Improve Transformer - Hugging Face, 8월 29, 2025에 액세스, https://huggingface.co/papers/2002.05202</li>
<li>GLU Variants Improve Transformer - arXiv, 8월 29, 2025에 액세스, https://arxiv.org/pdf/2002.05202</li>
<li>Some recent activation functions mimicking ReLU - The VITALab website, 8월 29, 2025에 액세스, https://vitalab.github.io/blog/2024/08/20/new_activation_functions.html</li>
<li>What is SwiGLU? A full bottom-up explanation of what’s it and why every new LLM uses it, 8월 29, 2025에 액세스, https://www.reddit.com/r/LocalLLaMA/comments/1eh6b1h/what_is_swiglu_a_full_bottomup_explanation_of/</li>
<li>Vinija’s Notes • Models • LLaMA, 8월 29, 2025에 액세스, https://vinija.ai/models/LLaMA/</li>
<li>Brief Review — PaLM: Scaling Language Modeling with Pathways - Sik-Ho Tsang - Medium, 8월 29, 2025에 액세스, https://sh-tsang.medium.com/brief-review-palm-scaling-language-modeling-with-pathways-cac58244820f</li>
<li>PaLM: Scaling Language Modeling with Pathways, 8월 29, 2025에 액세스, https://www.cis.uni-muenchen.de/~stef/seminare/klassifikation_2022/PaLMandGPT.pdf</li>
<li>LLaMA Explained!. Llama is one of the leading state of… | by Pranjal Khadka - Towards AI, 8월 29, 2025에 액세스, https://pub.towardsai.net/llama-explained-a70e71e706e9</li>
<li>Mixtral 8x7B | Open Laboratory, 8월 29, 2025에 액세스, https://openlaboratory.ai/models/mixtral-8x7b</li>
<li>Reading Notes: Mixtral of Experts | by lzhangstat - Medium, 8월 29, 2025에 액세스, https://lzhangstat.medium.com/reading-notes-mixtral-of-experts-296dfce5060b</li>
<li>Expanded Gating Ranges Improve Activation Functions - arXiv, 8월 29, 2025에 액세스, https://arxiv.org/html/2405.20768v1</li>
<li>[2405.20768] Expanded Gating Ranges Improve Activation Functions - arXiv, 8월 29, 2025에 액세스, https://arxiv.org/abs/2405.20768</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>