<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:이산 코사인 변환(DCT)을 활용한 영상 압축 기술</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>이산 코사인 변환(DCT)을 활용한 영상 압축 기술</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">센서 (Sensors)</a> / <a href="index.html">영상 처리</a> / <span>이산 코사인 변환(DCT)을 활용한 영상 압축 기술</span></nav>
                </div>
            </header>
            <article>
                <h1>이산 코사인 변환(DCT)을 활용한 영상 압축 기술</h1>
<p>2025-12-10, G30DR</p>
<h2>1.  서론: 디지털 영상 신호 처리와 압축의 본질적 필요성</h2>
<p>현대 디지털 정보화 사회에서 영상 데이터의 생산과 소비는 기하급수적으로 증가하고 있다. 4K, 8K를 넘어선 초고해상도(UHD) 디스플레이의 보급, 가상현실(VR) 및 증강현실(AR) 콘텐츠의 등장, 그리고 실시간 스트리밍 서비스의 폭발적인 성장은 막대한 양의 데이터 처리를 요구한다. 원본(Raw) 상태의 디지털 이미지는 픽셀 당 색상 심도(Bit Depth)와 해상도의 곱으로 표현되는 방대한 비트 수를 가지며, 이를 압축 없이 저장하거나 전송하는 것은 저장 장치의 물리적 한계와 네트워크 대역폭의 제약으로 인해 사실상 불가능하다. 예를 들어, 일반적인 24비트 트루 컬러(True Color) 포맷의 1920x1080 Full HD 이미지는 한 프레임당 약 6.2MB의 용량을 차지하며, 이를 초당 60프레임의 영상으로 환산하면 초당 370MB 이상의 대역폭이 요구된다. 이러한 배경에서 데이터의 효율적인 압축 기술은 디지털 미디어 생태계를 유지하는 가장 핵심적인 기반 기술로 자리 잡았다.</p>
<p>영상 압축 기술은 크게 정보의 손실이 전혀 없는 무손실(Lossless) 압축과, 인간의 시각적 인지 한계를 이용하여 불필요한 정보를 제거하는 손실(Lossy) 압축으로 구분된다. 의료 영상이나 위성 사진과 같이 데이터의 정밀성이 생명인 분야를 제외하고, 대부분의 멀티미디어 서비스는 높은 압축률을 달성하기 위해 손실 압축 방식을 채택한다. 이 손실 압축 기술의 중심에는 1972년 Nasir Ahmed에 의해 제안된 **이산 코사인 변환(Discrete Cosine Transform, 이하 DCT)**이 존재한다.1 DCT는 JPEG(Joint Photographic Experts Group) 정지 영상 표준뿐만 아니라, MPEG(Moving Picture Experts Group), H.264/AVC, H.265/HEVC 등 현대의 거의 모든 비디오 코딩 표준의 근간을 이루는 변환 부호화(Transform Coding) 기술의 핵심이다.1</p>
<p>본 보고서는 DCT 기반 영상 압축의 원리를 수학적 배경, 신호 처리적 특성, 인간 시각 시스템(Human Visual System, HVS)과의 상호작용, 그리고 실제 압축 파이프라인인 JPEG 알고리즘의 세부 구현을 통해 심층적으로 분석한다. 또한, 단순한 알고리즘의 나열을 넘어, 왜 DCT가 영상 압축의 표준이 되었는지에 대한 정보 이론적 고찰과 에너지 압축(Energy Compaction)의 물리적 의미, 그리고 최근의 인공지능(AI) 기반 압축 기술과의 융합 트렌드까지 포괄적으로 다룬다.</p>
<h2>2.  신호 처리의 이론적 기초와 변환 부호화</h2>
<h3>2.1  공간 도메인의 한계와 상관관계(Correlation)</h3>
<p>디지털 이미지는 2차원 그리드 위에 배열된 픽셀(Pixel)들의 집합인 공간 도메인(Spatial Domain)으로 표현된다. 공간 도메인 상의 데이터는 인접한 픽셀끼리 매우 강한 상관관계(Correlation)를 갖는다는 통계적 특징이 있다. 자연 영상(Natural Image)을 예로 들면, 파란 하늘이나 평평한 벽면을 촬영했을 때, 특정 좌표 <span class="math math-inline">(x, y)</span>의 픽셀 값은 바로 옆 좌표 <span class="math math-inline">(x+1, y)</span>의 픽셀 값과 거의 유사하거나 동일할 확률이 매우 높다.3 통계적으로 이를 자기상관(Autocorrelation)이 높다고 표현하며, 이는 정보 이론 관점에서 데이터의 중복성(Redundancy)이 매우 큼을 의미한다.</p>
<p>DCT와 같은 변환 부호화의 주된 목적은 이러한 공간상의 상관관계를 제거(Decorrelation)하는 것이다. 상관관계를 제거한다는 것은 데이터를 서로 독립적인 성분들로 분리해낸다는 것을 의미하며, 이를 통해 데이터의 에너지를 소수의 계수에 집중시키는 에너지 압축(Energy Compaction)이 가능해진다.4 만약 신호가 백색 잡음(White Noise)과 같이 모든 주파수 대역에서 무작위적인 값을 가진다면 인접 픽셀 간의 상관관계가 없으므로 변환을 통한 압축 효과를 기대할 수 없다. 그러나 대부분의 자연 영상은 저주파 성분이 지배적(Pinkish)인 특성을 가지므로 DCT를 통해 높은 압축 효율을 얻을 수 있다.5</p>
<h3>2.2  기저 함수(Basis Function)와 직교 변환</h3>
<p>모든 신호 변환은 입력 신호를 일련의 기저 함수(Basis Functions)들의 선형 결합(Linear Combination)으로 표현하는 과정이다. DCT는 서로 다른 주파수를 가지는 코사인 함수들을 기저 함수로 사용한다. 이 기저 함수들은 서로 직교(Orthogonal)하는 성질을 가진다. 즉, 서로 다른 두 기저 함수의 내적(Dot Product)은 0이 된다. 이러한 직교성은 변환된 계수들이 서로 독립적임을 보장하며, 역변환(Inverse Transform) 시에 각 계수가 원본 신호 복원에 기여하는 바를 명확하게 분리할 수 있게 해 준다.</p>
<h3>2.3  DFT(이산 푸리에 변환)와 DCT의 비교 및 DCT의 우위성</h3>
<p>신호 처리에서 가장 널리 알려진 변환은 이산 푸리에 변환(DFT)이다. DFT는 복소수 지수 함수(<span class="math math-inline">e^{-j\omega n}</span>)를 기저로 사용하며, 신호의 주기성(Periodicity)을 가정한다. 그러나 영상 압축에 있어 DFT 대신 DCT가 선택된 이유는 크게 두 가지다.</p>
<ol>
<li><strong>실수 연산(Real Arithmetic):</strong> DFT는 복소수 연산을 수반하여 결과값으로 위상(Phase)과 크기(Magnitude)를 갖는 복소수가 생성된다. 이는 데이터 저장 및 연산 복잡도 측면에서 비효율적이다. 반면 DCT는 코사인 함수만을 사용하므로 실수(Real Number) 영역에서만 연산이 이루어져 계산 효율이 높다.1</li>
<li><strong>경계 불연속성(Boundary Discontinuity) 문제 해결:</strong> 이미지를 블록 단위로 나누어 처리할 때, DFT는 블록의 양 끝단이 주기적으로 반복된다고 가정한다. 이 경우 블록의 왼쪽 끝과 오른쪽 끝의 픽셀 값이 다를 경우 급격한 불연속이 발생하고, 이는 고주파 성분의 증가(Gibbs Phenomenon)를 유발하여 압축 효율을 떨어뜨린다. 반면, DCT는 신호를 짝대칭(Even Symmetry)으로 확장하여 주기화한다고 가정한다. 이는 블록의 경계에서의 연속성을 보장하여 고주파 성분의 발생을 억제하고 에너지 집중도를 높인다.1</li>
</ol>
<pre><code class="language-mermaid">mindmap
  root((변환 부호화 기술))
    DFT 이산 푸리에 변환
      ::icon(fa fa-calculator)
      ["기저 함수: 복소수 지수 함수"]
      ["연산: 복소수 연산 (비효율적)"]
      ["단점: 경계 불연속성 (Gibbs 현상)"]
      ["가정: 주기적 반복"]
    DCT 이산 코사인 변환
      ::icon(fa fa-image)
      ["기저 함수: 코사인 함수 (실수)"]
      ["연산: 실수 연산 (고효율)"]
      ["특징: 짝대칭 (Even Symmetry) 확장"]
      ["장점: 경계 연속성 보장"]
      ["에너지 압축: 저주파 집중 우수"]
    선정 이유
      ::icon(fa fa-check-circle)
      [실수 연산으로 인한 계산 효율성]
      [블록 경계 아티팩트 감소]
      [KLT에 근접한 준최적 성능]
</code></pre>
<h2>3.  DCT의 수학적 원리와 알고리즘 심층 분석</h2>
<h3>3.1  1차원 DCT (1D-DCT)</h3>
<p>영상 처리에 가장 표준적으로 사용되는 Type-II DCT의 수식은 다음과 같이 정의된다. 길이가 <span class="math math-inline">N</span>인 1차원 입력 신호 <span class="math math-inline">f(x)</span> (<span class="math math-inline">x = 0, \dots, N-1</span>)에 대하여, 변환된 계수 <span class="math math-inline">F(u)</span>는 다음과 같다1:<br />
<span class="math math-display">
F(u) = C(u) \sum_{x=0}^{N-1} f(x) \cos \left[ \frac{(2x+1)u\pi}{2N} \right]
</span><br />
여기서 <span class="math math-inline">u = 0, \dots, N-1</span>은 주파수 인덱스를 나타내며, <span class="math math-inline">C(u)</span>는 정규화 계수(Normalization Coefficient)로 다음과 같이 정의된다:<br />
<span class="math math-display">
C(u) = \begin{cases} \sqrt{\frac{1}{N}} &amp; \text{if } u = 0 \\ \sqrt{\frac{2}{N}} &amp; \text{if } u &gt; 0 \end{cases}
</span><br />
이 수식의 의미를 분석하면 다음과 같다.</p>
<ul>
<li><strong><span class="math math-inline">u=0</span> (DC 계수):</strong> 코사인 항 <span class="math math-inline">\cos(0) = 1</span>이 되므로, <span class="math math-inline">F(0)</span>는 입력 신호 <span class="math math-inline">f(x)</span>의 총합에 비례하는 값을 가진다. 이는 신호의 평균적 크기, 즉 ‘직류(Direct Current)’ 성분을 나타낸다.9</li>
<li><strong><span class="math math-inline">u&gt;0</span> (AC 계수):</strong> 입력 신호 <span class="math math-inline">f(x)</span>와 주파수가 <span class="math math-inline">u</span>인 코사인 파형 간의 유사도(내적)를 나타낸다. 이를 ‘교류(Alternating Current)’ 성분이라 하며, <span class="math math-inline">u</span>가 커질수록 더 빠르게 진동하는 고주파 성분을 의미한다.</li>
</ul>
<h3>3.2  2차원 DCT (2D-DCT)와 분리 가능성(Separability)</h3>
<p>이미지는 2차원 평면 데이터이므로 2차원 DCT가 필요하다. <span class="math math-inline">N \times N</span> 크기의 이미지 블록 <span class="math math-inline">f(x, y)</span>에 대한 2차원 DCT는 다음과 같다:<br />
<span class="math math-display">
F(u, v) = C(u)C(v) \sum_{y=0}^{N-1} \sum_{x=0}^{N-1} f(x, y) \cos \left[ \frac{(2x+1)u\pi}{2N} \right] \cos \left[ \frac{(2y+1)v\pi}{2N} \right]
</span><br />
2차원 DCT의 가장 강력한 수학적 특성은 **분리 가능성(Separability)**이다. 위 식의 코사인 항은 <span class="math math-inline">x</span>에 대한 함수와 <span class="math math-inline">y</span>에 대한 함수의 곱으로 분리될 수 있다.</p>
<p>즉, <span class="math math-inline">\cos(\dots x \dots) \times \cos(\dots y \dots)</span> 형태로 표현되므로, 2차원 변환을 두 번의 1차원 변환으로 쪼개서 수행할 수 있다.</p>
<ol>
<li>이미지의 각 행(Row)에 대해 1차원 DCT를 수행한다.</li>
<li>그 결과의 각 열(Column)에 대해 다시 1차원 DCT를 수행한다.</li>
</ol>
<p>이를 행렬 연산으로 표현하면 더욱 명확해진다. 입력 블록을 행렬 <span class="math math-inline">X</span>, 변환 행렬을 <span class="math math-inline">T</span>라고 할 때, 변환된 계수 행렬 <span class="math math-inline">Y</span>는 다음과 같다:<br />
<span class="math math-display">
Y = T \cdot X \cdot T^T
</span><br />
여기서 <span class="math math-inline">T</span>는 직교 행렬(Orthogonal Matrix)이므로 <span class="math math-inline">T^{-1} = T^T</span>가 성립하여 역변환(IDCT) 또한 <span class="math math-inline">X = T^T \cdot Y \cdot T</span>로 쉽게 계산된다.</p>
<p>이러한 분리 가능성은 연산 복잡도를 <span class="math math-inline">O(N^4)</span>에서 <span class="math math-inline">O(2N^3)</span>으로 획기적으로 감소시킨다. <span class="math math-inline">8 \times 8</span> 블록의 경우, 직접 2D 변환을 수행하는 것보다 행/열 분리 변환이 하드웨어 구현 및 소프트웨어 최적화 측면에서 월등히 유리하다.10</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant Input as "입력: 8x8 이미지 블록 (X)"
    participant RowDCT as "1차: 행(Row) 단위 1D-DCT"
    participant Inter as "중간 결과 (X * T^T)"
    participant ColDCT as "2차: 열(Column) 단위 1D-DCT"
    participant Output as "최종 결과: DCT 계수 행렬 (Y)"

    Note over Input, Output: "분리 가능성: 2D 변환을 두 번의 1D 변환으로 수행"
    
    Input-&gt;&gt;RowDCT: "각 행에 대해 변환 수행"
    RowDCT-&gt;&gt;Inter: "수평 방향 주파수 성분 분리"
    Inter-&gt;&gt;ColDCT: "중간 결과의 각 열에 대해 변환 수행"
    ColDCT-&gt;&gt;Output: "수직 방향 주파수 성분 분리"
    
    Note right of Output: "Y = T * X * T^T"
    Note right of Output: "연산량 감소: O(N^4) -&gt; O(2N^3)"
</code></pre>
<h3>3.3  에너지 압축(Energy Compaction)과 KLT 근사</h3>
<p>DCT가 영상 압축의 표준으로 채택된 이론적 배경의 핵심은 에너지 압축 효율에 있다. 이론적으로 임의의 확률 과정을 따르는 신호에 대해 최적의 상관관계 제거와 에너지 압축을 수행하는 변환은 **카루넨-레베 변환(Karhunen-Loève Transform, KLT)**이다. KLT는 데이터의 공분산 행렬(Covariance Matrix)로부터 고유 벡터(Eigenvector)를 추출하여 기저 함수를 생성한다.12</p>
<p>그러나 KLT는 다음과 같은 치명적인 단점이 있다.</p>
<ol>
<li><strong>데이터 종속성:</strong> 입력 이미지의 통계적 특성에 따라 기저 함수가 매번 달라지므로, 이를 계산하는 비용이 크다.</li>
<li><strong>오버헤드:</strong> 디코더가 역변환을 수행하기 위해서는 인코더가 사용한 기저 함수(변환 행렬) 정보를 함께 전송받아야 하므로 추가적인 데이터 전송이 필요하다.</li>
</ol>
<p>반면, 이미지를 1차 마르코프 과정(First-order Markov Process)으로 모델링할 때, 픽셀 간 상관계수(<span class="math math-inline">\rho</span>)가 1에 가까워질수록 DCT의 성능은 KLT에 점근적으로 수렴한다는 것이 증명되었다.5 자연 영상의 픽셀 간 상관계수는 보통 0.90 ~ 0.95 이상으로 매우 높기 때문에, DCT는 고정된 기저 함수(코사인)를 사용하면서도 KLT에 버금가는 ’준최적(Sub-optimal)’의 성능을 제공한다. 이것이 DCT가 ’고정 변환(Fixed Transform)’으로서 범용 압축 표준에 채택된 결정적인 이유이다.</p>
<pre><code class="language-mermaid">quadrantChart
    title "DCT 변환 후 계수의 에너지 분포 및 양자화 민감도"
    x-axis "저주파 (Low Freq)" --&gt; "고주파 (High Freq)"
    y-axis "에너지(정보량) 낮음" --&gt; "에너지(정보량) 높음"
    quadrant-1 "존재하지 않는 영역 (이론적)"
    quadrant-2 "DC 및 저주파 AC: 보존 필수 (눈에 민감)"
    quadrant-3 "고주파 AC: 에너지 희소, 과감한 삭제 가능"
    quadrant-4 "중간 주파수: 적당한 양자화 필요"
    "DC 계수": [0.05, 0.95]
    "저주파 AC": [0.2, 0.7]
    "고주파 AC": [0.9, 0.05]
</code></pre>
<h2>4.  JPEG 압축 파이프라인의 상세 분석</h2>
<p>DCT 이론이 실제 압축 시스템에 어떻게 적용되는지, 가장 대표적인 표준인 JPEG 인코딩 과정을 통해 상세히 분석한다. JPEG 알고리즘은 크게 전처리, 변환, 양자화, 엔트로피 부호화의 4단계로 구성된다.</p>
<pre><code class="language-mermaid">graph TD
    subgraph "1단계: 전처리 (Preprocessing)"
        A["RGB 입력 이미지"] --&gt;|"색상 공간 변환"| B["YCbCr 데이터"]
        B --&gt;|"크로마 서브샘플링 (4:2:0)"| C["다운샘플링된 Y, Cb, Cr"]
    end

    subgraph "2단계: 블록화 (Block Splitting)"
        C --&gt;|"8x8 픽셀 분할"| D["8x8 블록들"]
        D --&gt;|"레벨 시프트 (-128)"| E["값 범위 조정된 블록"]
    end

    subgraph "3단계: 변환 (Transformation)"
        E --&gt;|"Forward DCT (2D)"| F["DCT 계수 (주파수 도메인)"]
        F --"좌측 상단"--&gt; G["DC 계수 (평균 밝기)"]
        F --"우측 하단"--&gt; H["AC 계수 (고주파)"]
    end

    subgraph "4단계: 양자화 (Quantization)"
        G &amp; H --&gt;|"양자화 테이블로 나누기"| I["양자화된 계수 (정보 손실 발생)"]
        I --"HVS 특성 반영"--&gt; J["고주파 성분 0으로 제거"]
    end

    subgraph "5단계: 엔트로피 부호화 (Entropy Coding)"
        J --&gt;|"지그재그 스캔 (Zigzag Scan)"| K["1차원 배열"]
        K --&gt;|"DC: DPCM / AC: RLE"| L["중간 심볼"]
        L --&gt;|"허프만 코딩 (Huffman Coding)"| M["최종 압축 비트스트림"]
    end
</code></pre>
<h3>4.1  1단계: 색상 공간 변환 및 서브샘플링 (Preprocessing)</h3>
<p>입력된 RGB 이미지는 먼저 <strong>YCbCr</strong> 색상 공간으로 변환된다. RGB 모델은 빛의 삼원색에 기반하지만, 각 채널 간의 상관관계가 높고 인간의 시각 특성을 반영하지 못한다. YCbCr 모델은 밝기 성분인 **Y (Luma)**와 색차 성분인 **Cb (Blue-difference), Cr (Red-difference)**로 정보를 분리한다.13</p>
<ul>
<li><strong>Y 채널:</strong> 이미지의 구조, 디테일, 밝기 정보를 담고 있으며 시각적으로 가장 중요하다.</li>
<li><strong>Cb/Cr 채널:</strong> 색상 정보를 담고 있으며, 인간의 눈은 밝기 변화에 비해 색상 변화에 상대적으로 둔감하다.</li>
</ul>
<p>이러한 인간 시각 시스템(HVS)의 특성을 이용하여 **크로마 서브샘플링(Chroma Subsampling)**을 수행한다. 일반적으로 <strong>4:2:0</strong> 포맷이 사용되는데, 이는 Y 채널은 그대로 두고 Cb와 Cr 채널의 해상도를 가로, 세로 각각 1/2로 줄이는 방식이다. 이 과정에서 이미 원본 데이터 양의 50%가 감축된다(RGB 대비). 이는 DCT 적용 전 단계에서 수행되는 공간 도메인에서의 압축이다.13</p>
<pre><code class="language-mermaid">pie
    title "4:2:0 포맷의 데이터 샘플 구성 비율 (2x2 픽셀 영역 기준)"
    "Y (Luma) - 밝기 정보 (4개)": 67
    "Cb (Blue diff) - 색차 정보 (1개)": 16.5
    "Cr (Red diff) - 색차 정보 (1개)": 16.5
</code></pre>
<h3>4.2  2단계: 블록 분할 및 레벨 시프트 (Block Splitting &amp; Level Shift)</h3>
<p>이미지를 <span class="math math-inline">8 \times 8</span> 크기의 블록으로 분할한다.</p>
<p>왜 <span class="math math-inline">8 \times 8</span>인가? 이는 압축 효율과 화질, 그리고 하드웨어 복잡도 사이의 타협점(Trade-off)이다.7</p>
<ul>
<li><strong>블록이 클 경우 (<span class="math math-inline">16 \times 16</span> 이상):</strong> 더 많은 픽셀 간의 상관관계를 이용할 수 있어 압축률은 높아질 수 있으나, 국부적인 이미지 특성(Local Stationarity)이 약해져 고주파 성분이 증가하고, ’링잉 현상(Ringing Artifact)’이 심해진다. 연산량 또한 급증한다.</li>
<li><strong>블록이 작을 경우 (<span class="math math-inline">4 \times 4</span> 이하):</strong> 픽셀 간의 상관관계를 충분히 활용하지 못해 압축 효율이 떨어지고, 블록 경계가 많아져 ’블록킹 현상(Blocking Artifact)’이 두드러진다.</li>
</ul>
<p>분할된 각 픽셀 값(일반적으로 0~255의 8비트 정수)에서 128을 뺀다(Level Shift). 이는 값의 범위를 -128~127로 이동시켜 DCT 변환 시 DC 계수의 동적 범위(Dynamic Range)를 줄이고 연산 정밀도를 확보하기 위함이다.18</p>
<pre><code class="language-mermaid">quadrantChart
    title "블록 크기에 따른 압축 효율과 화질의 관계"
    x-axis "블록 크기 작음 (4x4 이하)" --&gt; "블록 크기 큼 (16x16 이상)"
    y-axis "압축 효율 낮음" --&gt; "압축 효율 높음"
    quadrant-1 "압축률 높으나 링잉 현상(Ringing) 심화"
    quadrant-2 "이상적인 절충점 (8x8 DCT)"
    quadrant-3 "상관관계 활용 부족, 낮은 효율"
    quadrant-4 "블록킹 현상(Blocking) 극심"
    "8x8 블록": [0.5, 0.5]
    "16x16 블록": [0.85, 0.8]
    "4x4 블록": [0.15, 0.2]
    "전체 프레임 변환": [0.95, 0.9]
</code></pre>
<h3>4.3  3단계: 순방향 DCT (Forward DCT)</h3>
<p>각 <span class="math math-inline">8 \times 8</span> 블록에 대해 2차원 DCT를 수행한다. 그 결과로 64개의 DCT 계수 행렬이 생성된다.</p>
<p>이 행렬의 좌측 상단 <span class="math math-inline">(0,0)</span> 위치의 계수는 DC 계수로, 해당 <span class="math math-inline">8 \times 8</span> 블록 전체의 평균 밝기를 나타낸다. 나머지 63개의 계수는 AC 계수로, 우측 하단으로 갈수록 고주파 성분(가로, 세로 방향의 빠른 변화)을 나타낸다.</p>
<p>자연 영상의 경우, 에너지는 대부분 저주파 영역(좌측 상단)에 집중되며, 고주파 영역(우측 하단)의 계수들은 대부분 0에 가까운 매우 작은 값을 갖게 된다. 이것이 DCT의 에너지 압축(Compaction) 효과이다.19 이 단계까지는 연산 오차를 제외하면 정보 손실이 없는 가역적 과정이다.</p>
<h3>4.4  4단계: 양자화 (Quantization) - 압축의 핵심 메커니즘</h3>
<p>DCT 계수들을 양자화 행렬(Quantization Table)의 값으로 나누고 반올림하여 정수화하는 과정이다. 이 과정은 **비가역적(Irreversible)**이며, JPEG 압축에서 실질적인 데이터 감축과 화질 저하가 발생하는 유일한 단계이다.21<br />
<span class="math math-display">
F_{Quantized}(u, v) = \text{Round} \left( \frac{F(u, v)}{Q(u, v)} \right)
</span><br />
여기서 <span class="math math-inline">Q(u, v)</span>는 <span class="math math-inline">8 \times 8</span> 양자화 테이블의 값이다.</p>
<p>이 양자화 테이블의 설계에는 **인간 시각 시스템(HVS)의 대비 감도 함수(Contrast Sensitivity Function, CSF)**가 반영된다.22</p>
<ul>
<li><strong>저주파 영역:</strong> 인간의 눈은 낮은 주파수의 밝기 변화에 민감하므로, <span class="math math-inline">Q</span> 값을 작게 설정하여 정밀하게 양자화한다(정보 보존).</li>
<li><strong>고주파 영역:</strong> 인간의 눈은 복잡한 패턴이나 미세한 고주파 변화를 잘 감지하지 못하므로, <span class="math math-inline">Q</span> 값을 매우 크게 설정하여 계수들을 0으로 만든다(정보 삭제).</li>
</ul>
<p>Luma(밝기) 채널용 양자화 테이블과 Chroma(색차) 채널용 테이블은 서로 다르며, Chroma 채널이 더 거칠게(더 큰 값으로) 양자화된다.24 사용자가 설정하는 ’화질 계수(Quality Factor)’는 이 양자화 테이블의 값 전체에 스칼라 배를 하여 조절된다. 화질을 낮추면 양자화 스텝(<span class="math math-inline">Q</span>)이 커져 더 많은 고주파 계수가 0이 되고 압축률은 높아지지만, 블록킹 아티팩트가 발생할 확률이 높아진다.9</p>
<p>표 1. 전형적인 JPEG Luminance(밝기) 양자화 테이블 예시 24</p>
<p>(좌측 상단 저주파 영역은 값이 작고, 우측 하단 고주파 영역은 값이 큼)</p>
<table><thead><tr><th></th><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>2</strong></th><th><strong>3</strong></th><th><strong>4</strong></th><th><strong>5</strong></th><th><strong>6</strong></th><th><strong>7</strong></th></tr></thead><tbody>
<tr><td><strong>0</strong></td><td>16</td><td>11</td><td>10</td><td>16</td><td>24</td><td>40</td><td>51</td><td>61</td></tr>
<tr><td><strong>1</strong></td><td>12</td><td>12</td><td>14</td><td>19</td><td>26</td><td>58</td><td>60</td><td>55</td></tr>
<tr><td><strong>2</strong></td><td>14</td><td>13</td><td>16</td><td>24</td><td>40</td><td>57</td><td>69</td><td>56</td></tr>
<tr><td><strong>3</strong></td><td>14</td><td>17</td><td>22</td><td>29</td><td>51</td><td>87</td><td>80</td><td>62</td></tr>
<tr><td><strong>4</strong></td><td>18</td><td>22</td><td>37</td><td>56</td><td>68</td><td>109</td><td>103</td><td>77</td></tr>
<tr><td><strong>5</strong></td><td>24</td><td>35</td><td>55</td><td>64</td><td>81</td><td>104</td><td>113</td><td>92</td></tr>
<tr><td><strong>6</strong></td><td>49</td><td>64</td><td>78</td><td>87</td><td>103</td><td>121</td><td>120</td><td>101</td></tr>
<tr><td><strong>7</strong></td><td>72</td><td>92</td><td>95</td><td>98</td><td>112</td><td>100</td><td>103</td><td>99</td></tr>
</tbody></table>
<pre><code class="language-mermaid">graph TD
    subgraph "인간 시각 시스템 (HVS) 특성"
        A["시각적 입력"] --&gt; B{"주파수 대역&lt;br&gt;확인"}
        B --"저주파 (Low Freq)"--&gt; C["민감도 높음&lt;br&gt;(Sensitive)"]
        B --"고주파 (High Freq)"--&gt; D["민감도 낮음&lt;br&gt;(Insensitive)"]
        D --&gt; E["복잡한 텍스처&lt;br&gt;마스킹 효과"]
    end

    subgraph "DCT 양자화 적용"
        F["DCT 계수 행렬"] --&gt; G{"양자화 테이블&lt;br&gt;적용"}
        C -.-&gt;|"작은 양자화 값 적용"| H["정밀 보존&lt;br&gt;(적은 손실)"]
        D -.-&gt;|"큰 양자화 값 적용"| I["거친 양자화&lt;br&gt;(정보 제거)"]
        E -.-&gt;|"적응형 양자화"| I
        
        G --&gt; H
        G --&gt; I
        H &amp; I --&gt; J["0이 많은&lt;br&gt;희소 행렬(Sparse Matrix)&lt;br&gt;생성"]
    end
</code></pre>
<h3>4.5  5단계: 엔트로피 부호화 (Entropy Coding)</h3>
<p>양자화된 계수들을 효율적인 비트스트림으로 변환하는 무손실 압축 단계이다.</p>
<ol>
<li><strong>지그재그 스캔 (Zigzag Scan):</strong> 2차원 배열을 1차원 배열로 변환한다. 단순히 행 우선으로 읽는 것이 아니라, 좌측 상단(DC)에서 시작하여 대각선 방향으로 지그재그로 훑으며 우측 하단으로 이동한다. 이는 중요한 저주파 계수들을 앞쪽에 배치하고, 0이 된 고주파 계수들을 뒤쪽에 몰아넣어 긴 ’0의 연속(Run of Zeros)’을 만들기 위함이다.9</li>
<li><strong>DC 계수의 DPCM (Differential Pulse Code Modulation):</strong> 인접한 블록들의 DC 계수는 (이미지의 밝기가 서서히 변하므로) 매우 유사하다. 따라서 현재 블록의 DC 값과 이전 블록의 DC 값의 차이(Diff)만을 부호화한다. 이를 통해 필요한 비트 수를 크게 줄일 수 있다.9</li>
<li><strong>AC 계수의 RLE (Run Length Encoding):</strong> AC 계수들은 지그재그 스캔 결과 뒤쪽에 0이 연속되는 경우가 많다. 이를 (앞선 0의 개수, 0이 아닌 값)의 쌍으로 표현한다. 블록의 끝까지 모두 0인 경우에는 EOB(End of Block)라는 특수 심볼 하나로 처리하여 데이터를 획기적으로 줄인다.12</li>
<li><strong>허프만 코딩 (Huffman Coding):</strong> 최종적으로 생성된 심볼들에 대해, 빈도수가 높은 심볼에는 짧은 코드를, 빈도수가 낮은 심볼에는 긴 코드를 할당하는 가변 길이 부호화(Variable Length Coding)를 수행한다. JPEG 표준은 일반적인 이미지 통계에 기반한 표준 허프만 테이블을 제공하거나, 해당 이미지에 최적화된 테이블을 생성하여 사용할 수 있다.13</li>
</ol>
<pre><code class="language-mermaid">sequenceDiagram
    participant AC_List as "1D AC&lt;br&gt;계수 배열"
    participant RLE as "Run-Length&lt;br&gt;Encoding"
    participant Symbol as "중간 심볼&lt;br&gt;(Run, Value)"
    participant Huffman as "Huffman&lt;br&gt;Table"
    participant Bitstream as "최종&lt;br&gt;비트스트림"

    Note over AC_List, Bitstream: "AC 계수 압축 과정 예시"

    AC_List-&gt;&gt;RLE: "입력:&lt;br&gt;[5, 0, 0, -2, 0, 0, 0, 0, 1, EOB]"
    RLE-&gt;&gt;RLE: "0의 연속 개수 카운트"
    
    RLE-&gt;&gt;Symbol: "변환: (0, 5)"
    Symbol-&gt;&gt;Huffman: "매핑 요청"
    Huffman--&gt;&gt;Bitstream: "이진 코드 출력 (예: 110)"
    
    RLE-&gt;&gt;Symbol: "변환: (2, -2)"
    Note right of RLE: "0이 두 번 반복됨"
    Symbol-&gt;&gt;Huffman: "매핑 요청"
    Huffman--&gt;&gt;Bitstream: "이진 코드 출력 (예: 11101)"

    RLE-&gt;&gt;Symbol: "변환: (4, 1)"
    Note right of RLE: "0이 네 번 반복됨"
    Symbol-&gt;&gt;Huffman: "매핑 요청"
    Huffman--&gt;&gt;Bitstream: "이진 코드 출력"

    RLE-&gt;&gt;Symbol: "변환: (0, 0) -&gt; EOB"
    Symbol-&gt;&gt;Huffman: "EOB 코드 매핑"
    Huffman--&gt;&gt;Bitstream: "블록 종료 코드"
</code></pre>
<h2>5.  인간 시각 시스템(HVS)과 DCT 양자화의 심리물리학적 연계</h2>
<p>DCT 기반 압축이 성공할 수 있었던 가장 큰 요인은 단순한 수학적 변환을 넘어 생물학적 인지 특성을 공학적으로 모델링했다는 점이다.</p>
<h3>5.1  대비 감도 함수 (Contrast Sensitivity Function, CSF)</h3>
<p>CSF는 인간의 시각 시스템이 다양한 공간 주파수(Spatial Frequency)에서 대비(Contrast)를 얼마나 잘 감지하는지를 나타내는 함수이다. 실험 결과, 인간의 눈은 중간 대역의 주파수(약 2~5 cycles/degree)에서 가장 민감하며, 주파수가 매우 낮거나 매우 높으면 감도가 떨어진다.22 특히 고주파 영역(복잡한 무늬)에서의 감도 저하는 급격하다. JPEG의 양자화 행렬은 이 CSF 곡선의 역수(Inverse) 형태를 띤다. 즉, 감도가 낮은 고주파 영역에는 큰 양자화 계수를 할당하여 오차를 허용하고, 감도가 높은 저주파 영역에는 작은 계수를 할당하여 오차를 최소화한다.24</p>
<h3>5.2  마스킹 효과 (Masking Effect)</h3>
<p>밝기의 변화가 심한 영역(텍스처가 복잡한 영역)에서는 잡음이나 왜곡이 잘 보이지 않는 현상을 ’텍스처 마스킹(Texture Masking)’이라 한다. DCT는 이미지를 주파수 성분으로 분해하므로, 고주파 성분이 많은 블록(복잡한 텍스처)에서는 양자화를 더 강하게 하더라도(정보를 더 많이 버리더라도) 인간이 이를 인지하기 어렵다. 최신의 적응형 양자화(Adaptive Quantization) 기법들은 각 블록의 AC 에너지 양을 분석하여 블록마다 다른 양자화 스케일을 적용함으로써 이러한 마스킹 효과를 극대화한다.32</p>
<h2>6.  비디오 코딩(MPEG, H.26x)에서의 DCT 확장</h2>
<p>비디오 압축은 정지 영상 압축(Intra-frame coding)에 더해 시간적 중복성(Inter-frame coding)을 제거해야 한다. 여기서도 DCT는 핵심 역할을 수행한다.</p>
<pre><code class="language-mermaid">graph TD
    Input["현재 프레임"] --&gt; Diff{"차분기 (Subtraction)"}
    Ref["참조 프레임 (이전 복원 영상)"] --&gt; ME["움직임 추정 (ME)"]
    ME --&gt;|"움직임 벡터"| MC["움직임 보상 (MC)"]
    MC --&gt;|"예측 블록"| Diff
    
    Diff --&gt;|"잔차 신호 (Residual)"| T["변환 (DCT/Integer Transform)"]
    T --&gt; Q["양자화 (Quantization)"]
    Q --&gt;|"압축 데이터"| EC["엔트로피 코딩"]
    
    Q -.-&gt;|"역양자화"| IQ["역양자화"]
    IQ -.-&gt;|"역변환"| IT["역변환 (IDCT)"]
    IT --&gt;|"복원된 잔차"| Add{"가산기"}
    MC --&gt; Add
    Add --&gt;|"현재 프레임 복원 (다음 참조용)"| Buf["프레임 버퍼"]
    Buf --&gt; Ref
</code></pre>
<h3>6.1  움직임 보상과 잔차 신호 (Motion Compensation &amp; Residuals)</h3>
<p>비디오 인코더는 이전 프레임에서 현재 프레임의 블록과 가장 유사한 영역을 찾아 움직임 벡터(Motion Vector)를 생성한다(Motion Estimation). 그리고 찾아낸 참조 블록을 현재 블록에서 뺀 차이값, 즉 **잔차 신호(Residual Signal)**를 생성한다.2</p>
<p>DCT는 원본 이미지뿐만 아니라 이 잔차 신호에 대해서도 적용된다. 잔차 신호는 픽셀 간 상관관계가 원본 이미지보다는 낮지만, 여전히 저주파 성분이 우세한 경향이 있어 DCT를 통한 에너지 압축이 유효하다. 다만, 잔차 신호의 방향성이나 통계적 특성에 따라 DCT 대신 DST(Discrete Sine Transform)나 KLT 기반의 변환이 더 효율적일 수 있으며, 최신 코덱인 HEVC나 VVC에서는 이러한 다중 변환 선택(Multiple Transform Selection) 기술이 도입되었다.34</p>
<h3>6.2  정수 변환 (Integer Transform)</h3>
<p>MPEG-2까지는 실수 연산 기반의 DCT를 사용했으나, H.264/AVC부터는 **정수 변환(Integer Transform)**을 도입했다. 실수 기반 DCT는 인코더와 디코더의 부동 소수점 연산 정밀도 차이로 인해 ‘역변환 불일치(Inverse Transform Mismatch)’ 문제를 야기하여, 시간이 지날수록 화질 열화가 누적되는 ‘드리프트(Drift)’ 현상을 발생시켰다. 정수 변환은 코사인 기저 함수를 정수로 근사화하여(예: 0.5 <span class="math math-inline">\to</span> 1/2 비트 시프트) 모든 연산을 정수로 수행함으로써, 하드웨어 구현을 단순화하고 인코더-디코더 간의 완벽한 일치를 보장한다. 이는 DCT의 수학적 성질을 유지하면서 공학적 안정성을 확보한 진보된 형태이다.</p>
<pre><code class="language-mermaid">journey
    title "영상 데이터 픽셀의 압축 여정 (Pixel Journey)"
    section 공간 도메인 (Spatial)
      RGB 원본 상태: 5: "나는 24비트 트루컬러, 매우 무겁다."
      YCbCr 변환: 5: "밝기와 색상으로 분리되었다."
      서브샘플링: 4: "색상 정보 가족들이 절반으로 줄었다."
      블록 분할: 5: "8x8 방에 갇혔다. 옆 친구들과 비슷하게 생겼다."
    section 주파수 도메인 (Frequency)
      DCT 변환: 3: "갑자기 주파수 계수로 변했다. 에너지가 한쪽으로 쏠린다."
      양자화 (Quantization): 1: "충격! 덜 중요한 친구들이 0이 되어 사라졌다 (고통/손실)."
    section 비트스트림 (Bitstream)
      지그재그 스캔: 3: "줄을 서서 1열로 나열된다."
      엔트로피 코딩: 5: "짧은 부호로 포장되어 가벼워졌다. 전송 준비 완료!"
</code></pre>
<h2>7.  DCT 기반 압축의 한계와 시각적 아티팩트</h2>
<p>DCT는 블록 기반 처리 방식을 사용하기 때문에 높은 압축률에서 특유의 화질 열화(Artifact)를 보인다.</p>
<ol>
<li><strong>블록킹 현상 (Blocking Artifacts):</strong> 각 <span class="math math-inline">8 \times 8</span> 블록이 독립적으로 양자화되므로, 블록 경계에서 픽셀 값의 불연속이 발생하여 바둑판 모양의 격자가 보이는 현상이다. 이는 DC 계수와 저주파 AC 계수 간의 오차가 블록마다 다르게 발생하기 때문이다.4 이를 완화하기 위해 H.264 등에서는 루프 필터(Deblocking Filter)를 사용하여 블록 경계를 부드럽게 처리한다.</li>
<li><strong>링잉 현상 (Ringing Artifacts):</strong> 영상 내의 급격한 에지(Edge) 주변에서 물결치듯 번지는 잡음이다. 이는 무한한 주파수 성분을 포함하는 에지 신호를 유한한 개수의 DCT 기저 함수로 근사하려고 할 때 발생하는 **깁스 현상(Gibbs Phenomenon)**에 기인한다. 고주파 계수가 양자화로 제거되면서 에지를 완벽하게 표현하지 못하고 오버슈트/언더슈트가 발생하는 것이다.30</li>
<li><strong>모기 잡음 (Mosquito Noise):</strong> 비디오 압축에서 주로 발생하며, 움직이는 물체의 경계면 주변에 모기 떼가 날아다니는 것과 같은 자글자글한 시간적 잡음이 발생하는 현상이다. 이는 링잉 현상이 시간에 따라 변하면서 나타나는 시각적 효과이다.</li>
</ol>
<pre><code class="language-mermaid">mindmap
  root((DCT 압축 아티팩트))
    블록킹 현상 Blocking
      원인: 블록 간 독립적 양자화
      증상: 바둑판/격자 무늬 발생
      해결: 디블로킹 필터 (H.264+)
    링잉 현상 Ringing
      원인: 깁스 현상 (Gibbs Phenomenon)
      설명: 급격한 에지 근사 실패
      증상: 에지 주변의 물결/번짐
    모기 잡음 Mosquito
      원인: 시간적 링잉 현상
      발생: 비디오/움직이는 물체
      증상: 경계면 주변의 자글자글한 잡음
</code></pre>
<h2>8.  결론 및 미래 전망: AI와 DCT의 융합</h2>
<p>DCT는 지난 50년 동안 영상 압축의 절대적인 표준으로 자리 잡아왔다. 공간 도메인의 정보를 주파수 도메인으로 변환하여(Decorrelation), 인간의 시각적 중요도에 따라 정보를 선별적으로 제거(Quantization)하는 DCT의 원리는 정보 이론과 생물학적 인지 특성의 완벽한 조화를 보여준다.</p>
<p>최근 딥러닝(Deep Learning) 기술의 발전으로 End-to-End 신경망 기반 압축 기술이 연구되고 있다. 그러나 DCT는 여전히 중요한 위치를 차지한다.</p>
<ol>
<li><strong>하이브리드 접근:</strong> CNN(Convolutional Neural Network)이나 MLP를 사용하여 중요한 DCT 계수를 예측하거나, 양자화 테이블을 이미지 특성에 맞게 동적으로 최적화하는 연구가 활발하다.19</li>
<li><strong>전처리 도구:</strong> 신경망의 입력으로 픽셀값 대신 DCT 계수를 사용하여 학습 효율과 수렴 속도를 높이는 기법이 사용된다.19</li>
<li><strong>표준의 지속성:</strong> 기존 하드웨어 인프라와의 호환성과 연산 효율성 측면에서, 순수 신경망 압축이 DCT 기반 코덱을 단기간에 완전히 대체하기는 어려울 것으로 전망된다.</li>
</ol>
<p>결론적으로 DCT는 단순한 수학 공식을 넘어, 데이터의 통계적 특성과 인간의 인지적 특성을 연결하는 가교로서 현대 디지털 문명을 지탱하는 핵심 기술이라 정의할 수 있다.</p>
<p><strong>표 2: 영상 압축 단계별 데이터 변환 및 특성 요약</strong></p>
<table><thead><tr><th><strong>처리 단계</strong></th><th><strong>처리 도메인</strong></th><th><strong>데이터 형태</strong></th><th><strong>주요 목적 및 원리</strong></th><th><strong>손실 여부</strong></th></tr></thead><tbody>
<tr><td><strong>Color Space Conversion</strong></td><td>공간 (Spatial)</td><td>RGB <span class="math math-inline">\to</span> YCbCr</td><td>색상 간 상관관계 제거 (Decorrelation), 명도/색차 분리</td><td>무손실 (연산오차 제외)</td></tr>
<tr><td><strong>Subsampling</strong></td><td>공간 (Spatial)</td><td>4:4:4 <span class="math math-inline">\to</span> 4:2:0</td><td>색차 정보의 해상도를 낮춤 (HVS 특성 활용)</td><td><strong>손실 (Lossy)</strong></td></tr>
<tr><td><strong>Block Splitting</strong></td><td>공간 (Spatial)</td><td>Frame <span class="math math-inline">\to</span> <span class="math math-inline">8 \times 8</span> Blocks</td><td>국소적 통계 특성(Local Stationarity) 활용</td><td>무손실</td></tr>
<tr><td><strong>Forward DCT</strong></td><td>주파수 (Frequency)</td><td>Pixel Value <span class="math math-inline">\to</span> Frequency Coeff.</td><td>에너지 압축 (Energy Compaction), 저주파 집중</td><td>무손실</td></tr>
<tr><td><strong>Quantization</strong></td><td>주파수 (Frequency)</td><td>실수 계수 <span class="math math-inline">\to</span> 정수 인덱스</td><td>고주파 정보 제거 (HVS CSF 적용), 데이터 감축의 핵심</td><td><strong>손실 (Lossy - 핵심)</strong></td></tr>
<tr><td><strong>Zigzag Scan</strong></td><td>-</td><td>2D 배열 <span class="math math-inline">\to</span> 1D 배열</td><td>0의 연속 구간(Run-length) 최대화</td><td>무손실</td></tr>
<tr><td><strong>Entropy Coding</strong></td><td>비트스트림</td><td>심볼 <span class="math math-inline">\to</span> 이진 코드 (Binary)</td><td>통계적 중복성 제거 (Huffman, Arithmetic)</td><td>무손실</td></tr>
</tbody></table>
<h2>9. 참고 자료</h2>
<ol>
<li>Discrete cosine transform - Wikipedia, https://en.wikipedia.org/wiki/Discrete_cosine_transform</li>
<li>Motion compensation - Wikipedia, https://en.wikipedia.org/wiki/Motion_compensation</li>
<li>JPEG DCT Coefficients Overview - Emergent Mind, https://www.emergentmind.com/topics/jpeg-discrete-cosine-transform-dct-coefficients</li>
<li>12월 10, 2025에 액세스, [https://www.ioriver.io/terms/dct-compression#:<sub>:text=to%20hardware%2Daccelerate.-,How%20does%20DCT%20compression%20impact%20image%20quality%3F,create%20blocking%20artifacts%20and%20banding.](https://www.ioriver.io/terms/dct-compression#:</sub>:text=to hardware-accelerate.-,How does DCT compression impact image quality%3F, <a href="https://www.ioriver.io/terms/dct-compression#:~:text=to%20hardware-accelerate.-,How%20does%20DCT%20compression%20impact%20image%20quality%3F,create%20blocking%20artifacts%20and%20banding.">https://www.ioriver.io/terms/dct-compression#:~:text=to%20hardware%2Daccelerate.-,How%20does%20DCT%20compression%20impact%20image%20quality%3F,create%20blocking%20artifacts%20and%20banding.</a></li>
<li>What is ‘energy compaction’ in simple terms? - Signal Processing Stack Exchange, https://dsp.stackexchange.com/questions/17326/what-is-energy-compaction-in-simple-terms</li>
<li>Discrete Cosine Transform, <a href="https://www.commsp.ee.ic.ac.uk/~tania/teaching/DIP%202014/DCT%20other.pdf">https://www.commsp.ee.ic.ac.uk/~tania/teaching/DIP%202014/DCT%20other.pdf</a></li>
<li>Why is <span class="math math-inline">8 \times 8</span> matrix chosen for Discrete Cosine Transform? - Math Stack Exchange, https://math.stackexchange.com/questions/32491/why-is-8-times-8-matrix-chosen-for-discrete-cosine-transform</li>
<li>DCT - Lossy Data Compression: JPEG, https://cs.stanford.edu/people/eroberts/courses/soco/projects/data-compression/lossy/jpeg/dct.htm</li>
<li>Digital Image Processing Laboratory: Achromatic Baseline JPEG encoding Lab - Purdue College of Engineering, https://engineering.purdue.edu/~bouman/grad-labs/JPEG-Image-Coding/pdf/lab.pdf</li>
<li>Why JPEG compression processes image by 8x8 blocks? - Stack Overflow, https://stackoverflow.com/questions/10780425/why-jpeg-compression-processes-image-by-8x8-blocks</li>
<li>Transforms: Part 6 - The Discrete Cosine Transform (DCT) - The Broadcast Bridge, https://www.thebroadcastbridge.com/content/entry/18568/transforms-part-6-dct</li>
<li>Lecture 14: Predictive and Transform Coding, https://web.engr.oregonstate.edu/~thinhq/teaching/ece499/spring06/transform.pdf</li>
<li>12월 10, 2025에 액세스, https://davidblog.si/2025/06/17/the-inner-working-of-jpeg/</li>
<li>JPEG Compression step by step. Introduction | by Pasan Kalansooriya | Medium, https://medium.com/@pasanSK/jpeg-compression-step-by-step-8d84598190c</li>
<li>JPEG Compression Explained | Baeldung on Computer Science, https://www.baeldung.com/cs/jpeg-compression</li>
<li>Dev Network Series: Everything you need to know about image compression - Bitmovin, https://bitmovin.com/blog/image-compression-jpeg/</li>
<li>jpeg compression: necessity of dividing input image into 8x8 blocks, https://dsp.stackexchange.com/questions/82655/jpeg-compression-necessity-of-dividing-input-image-into-8x8-blocks</li>
<li>JPEG Image Format or Compression for Dummies | by Abhinav Tripathi | Medium, https://medium.com/@abhinavtripathi95/jpeg-image-format-or-compression-for-dummies-758664a6aff9</li>
<li>Extracting the most important Discrete Cosine Transform (DCT) Coefficients for Image Compression using Deep Learning | VFAST Transactions on Software Engineering, https://vfast.org/journals/index.php/VTSE/article/view/1145</li>
<li>What Is DCT Compression? Benefits &amp; Types - IO River, https://www.ioriver.io/terms/dct-compression</li>
<li>Quantization (image processing) - Wikipedia, https://en.wikipedia.org/wiki/Quantization_(image_processing)</li>
<li>Perceptual Compressive Sensing based on Contrast Sensitivity Function: Can we avoid non-visible redundancies acquisition? - arXiv, https://arxiv.org/pdf/1702.05718</li>
<li>Relevance of human vision to JPEG-DCT compression - SPIE Digital Library, https://www.spiedigitallibrary.org/conference-proceedings-of-spie/1666/1/Relevance-of-human-vision-to-JPEG-DCT-compression/10.1117/12.135968.full</li>
<li>THE OPTIMAL QUANTIZATION MATRICES FOR JPEG IMAGE COMPRESSION FROM PSYCHOVISUAL THRESHOLD - jatit, http://www.jatit.org/volumes/Vol70No3/24Vol70No3.pdf</li>
<li>Contrast sensitivity functions in autoencoders - PMC - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC9145138/</li>
<li>8x8 Quantization matrix on 4x4 subsampled matrix. JPEG - Stack Overflow, https://stackoverflow.com/questions/77297179/8x8-quantization-matrix-on-4x4-subsampled-matrix-jpeg</li>
<li>A Reliable JPEG Quantization Table Estimator - IPOL Journal, https://www.ipol.im/pub/art/2022/399/article_lr.pdf</li>
<li>Lecture 12: JPEG, http://users.dimi.uniud.it/~antonio.dangelo/MMS/2013/lessons/L12lecture.pdf</li>
<li>JPEG - Wikipedia, https://en.wikipedia.org/wiki/JPEG</li>
<li>JPEG Optimization Algorithms Review | by Fyodor Serzhenko - Medium, https://fastcompression.medium.com/jpeg-optimization-algorithms-review-eb2dc1a2e154</li>
<li>A contrast sensitivity model of the human visual system in modern conditions for presenting video content - PubMed Central, https://pmc.ncbi.nlm.nih.gov/articles/PMC11139320/</li>
<li>Design of image-adaptive quantization tables for JPEG - Hajim School of Engineering &amp; Applied Sciences, <a href="https://www.hajim.rochester.edu/ece/sites/parker/assets/pdf/56%20-%20Design%20of%20image-adaptive%20quantization%20tables%20for%20JPEG.pdf">https://www.hajim.rochester.edu/ece/sites/parker/assets/pdf/56%20-%20Design%20of%20image-adaptive%20quantization%20tables%20for%20JPEG.pdf</a></li>
<li>A Brief Overview of H.264 Frame Encoding Principles - Intra Prediction and Inter Prediction, https://gwliang.com/en/posts/intra-prediction-and-inter-prediction/</li>
<li>Transforms for Prediction Residuals in Video Coding Fatih Kamigh - DSpace@MIT, https://dspace.mit.edu/bitstream/handle/1721.1/62424/710987360-MIT.pdf?sequence=2&amp;isAllowed=y</li>
<li>An Optimized Template Matching Approach to Intra Coding in Video/Image Compression - Google Research, https://research.google.com/pubs/archive/43249.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>