<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS2 Humble 기반 Multi-LiCa를 활용한 다중 LiDAR 캘리브레이션 실용 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS2 Humble 기반 Multi-LiCa를 활용한 다중 LiDAR 캘리브레이션 실용 안내서</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">센서 (Sensors)</a> / <a href="index.html">HKU-MaRS</a> / <span>ROS2 Humble 기반 Multi-LiCa를 활용한 다중 LiDAR 캘리브레이션 실용 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS2 Humble 기반 Multi-LiCa를 활용한 다중 LiDAR 캘리브레이션 실용 안내서</h1>
<p>2025-10-21, G25DR</p>
<p>이 문서는 ROS2 Humble 환경에서 <code>Multi-LiCa</code> 패키지를 사용하여 다중 LiDAR 센서의 외부 파라미터(extrinsic parameters)를 캘리브레이션하는 실용적이고 단계적인 절차를 제공한다. 이 가이드는 알고리즘의 이론적 배경 설명은 생략하고, 실제 시스템에 적용하는 방법에만 집중하여 사용자가 성공적으로 캘리브레이션을 수행할 수 있도록 지원하는 것을 목표로 한다.</p>
<h2>1.  환경 설정 및 설치</h2>
<p>이 섹션에서는 <code>Multi-LiCa</code> 패키지 설치를 위한 시스템 준비 과정과 두 가지 권장 설치 방법을 안내한다. 각 방법은 사용자의 목적에 따라 장단점이 있으므로, 자신의 환경에 가장 적합한 경로를 선택하는 것이 중요하다.</p>
<h3>1.1  시스템 전제 조건</h3>
<p>캘리브레이션 작업을 시작하기 전에, 시스템이 다음의 필수 소프트웨어 요구사항을 충족하는지 확인해야 한다.</p>
<ul>
<li><strong>운영체제:</strong> Ubuntu 22.04 LTS 1</li>
<li><strong>ROS2 배포판:</strong> ROS2 Humble Hawksbill (Desktop-Full 버전 설치 권장) 1</li>
<li><strong>Python 버전:</strong> Python 3.10 (Ubuntu 22.04에 기본 포함) 4</li>
<li><strong>Docker:</strong> 컨테이너 기반 설치 방법을 위한 Docker Engine 4</li>
</ul>
<p><code>Multi-LiCa</code>는 공식적으로 ROS2 Humble 환경에서 테스트 및 지원되므로, 안정적인 실행을 위해 명시된 환경을 사용하는 것이 강력히 권장된다.4</p>
<h3>1.2  방법 A: Docker 기반 배포 (단순성과 신뢰성을 위한 권장 방법)</h3>
<p>Docker를 사용하는 것은 모든 의존성을 격리된 컨테이너 내에 캡슐화하여 호스트 시스템과의 충돌을 방지하는 가장 간단하고 신뢰성 높은 방법이다. <code>Multi-LiCa</code> 프로젝트는 이 방식을 최소 요구사항으로 명시하고 있으며, 처음 사용하는 사용자에게 가장 권장되는 경로이다.4</p>
<h4>1.2.1 단계: Docker 이미지 빌드</h4>
<p>먼저, <code>Multi-LiCa</code> 저장소를 복제한 후, 제공된 셸 스크립트를 사용하여 Docker 이미지를 빌드한다.</p>
<pre><code class="language-Bash">git clone --recurse-submodules git@github.com:TUMFTM/Multi_LiCa.git
cd Multi_LiCa
./docker/build_docker.sh
</code></pre>
<h4>1.2.2 단계: Docker 컨테이너 실행</h4>
<p>이미지 빌드가 완료되면, 다음 스크립트를 실행하여 필요한 볼륨 마운트 및 환경 설정이 완료된 컨테이너를 시작한다.</p>
<pre><code class="language-Bash">./docker/run_docker.sh
</code></pre>
<h4>1.2.3 단계: 환경 확인</h4>
<p>컨테이너가 실행된 후, 새 터미널에서 다음 명령어를 입력하여 컨테이너 내부로 진입하고 ROS2 환경이 정상적으로 활성화되었는지 확인할 수 있다.</p>
<pre><code class="language-Bash">docker exec -it multi_lica /bin/bash
source /opt/ros/humble/setup.bash
ros2 topic list
</code></pre>
<h3>1.3  방법 B: 로컬 소스 빌드 (개발 및 사용자 정의를 위한 방법)</h3>
<p>소스 코드를 직접 수정하거나 개발 환경에 통합해야 하는 경우, 로컬 소스 빌드 방법을 사용할 수 있다. 이 방법은 의존성을 수동으로 관리해야 하므로 주의가 필요한다.</p>
<h4>1.3.1 단계: <code>colcon</code> 작업 공간 생성</h4>
<p>표준 ROS2 절차에 따라 <code>colcon</code> 빌드를 위한 작업 공간(workspace)을 생성한다.</p>
<pre><code class="language-Bash">mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
</code></pre>
<h4>1.3.2 단계: 저장소 복제</h4>
<p>저장소를 복제할 때, 외부 라이브러리 의존성(예: TEASER++)을 함께 받기 위해 <code>--recurse-submodules</code> 플래그를 반드시 포함해야 한다. 이 단계를 누락하면 빌드 과정에서 오류가 발생한다.4</p>
<pre><code class="language-Bash">cd ~/ros2_ws/src
git clone --recurse-submodules git@github.com:TUMFTM/Multi_LiCa.git
</code></pre>
<h4>1.3.3 단계: Python 의존성 설치</h4>
<p>프로젝트 루트에 있는 <code>requirements.txt</code> 파일을 사용하여 필요한 Python 패키지를 설치한다. 이는 런타임 오류를 방지하는 데 필수적인 과정이다.</p>
<pre><code class="language-Bash">cd Multi_LiCa
pip install --no-cache-dir -r requirements.txt
</code></pre>
<h4>1.3.4 단계: ROS2 환경 소싱 및 빌드</h4>
<p>마지막으로, ROS2 환경을 활성화하고 <code>colcon</code>을 사용하여 프로젝트를 빌드한다. <code>--packages-up-to</code> 인자를 사용하면 불필요한 패키지 빌드를 건너뛰어 효율성을 높일 수 있다.4</p>
<pre><code class="language-Bash">cd ~/ros2_ws
source /opt/ros/humble/setup.bash
colcon build --symlink-install --packages-up-to multi_lidar_calibrator --cmake-args -DCMAKE_BUILD_TYPE=Release
</code></pre>
<h2>2.  캘리브레이션을 위한 LiDAR 데이터 준비</h2>
<p>성공적인 캘리브레이션을 위해서는 양질의 입력 데이터가 필수적이다. <code>Multi-LiCa</code>는 특정 환경 가정 하에 작동하므로, 데이터 수집 단계부터 이러한 제약 조건을 염두에 두어야 한다.</p>
<h3>2.1  데이터 요구사항 및 제한 사항 이해</h3>
<p>데이터 수집 전에 <code>Multi-LiCa</code>의 다음과 같은 핵심 운영 제약 조건을 숙지해야 한다.4</p>
<ul>
<li><strong>정적 환경:</strong> 데이터 수집 중 로봇과 주변 환경은 반드시 움직이지 않는 상태여야 한다.</li>
<li><strong>충분한 중첩 영역:</strong> 캘리브레이션 대상 LiDAR 센서들은 직접적 또는 연쇄적으로 시야(Field-of-View, FOV)가 중첩되는 영역을 가져야 한다.</li>
<li><strong>평평한 지면 가정:</strong> LiDAR-to-Ground 캘리브레이션 기능을 사용하는 경우, 지면이 평평하다고 가정한다.</li>
<li><strong>입력 데이터 형식:</strong> 데이터는 ROS2 토픽의 <code>sensor_msgs/PointCloud2</code> 메시지 또는 <code>.pcd</code> 파일 형식이어야 한다.4</li>
</ul>
<h3>2.2  방법 A: 기존 포인트 클라우드 데이터(<code>.pcd</code> 파일) 사용</h3>
<p>이 방법은 오프라인 데이터 처리나 데모에서 제공되는 OpenCalib 데이터셋과 같은 기존 데이터를 사용할 때 이상적이다.4 <code>.pcd</code> 파일을 특정 디렉토리에 구성하고, 이후 <code>params.yaml</code> 파일에서 해당 경로를 정확히 지정해야 한다.</p>
<h3>2.3  방법 B: <code>ros2 bag</code>을 이용한 실시간 센서 데이터 기록</h3>
<p>이 방법은 사용자가 소유한 실제 하드웨어를 캘리브레이션하기 위한 표준 워크플로우이다.</p>
<h4>2.3.1 단계: LiDAR 토픽 식별</h4>
<p>먼저, LiDAR 드라이버가 발행하는 <code>PointCloud2</code> 메시지의 토픽 이름을 확인한다.</p>
<pre><code class="language-Bash">ros2 topic list -t
</code></pre>
<p>출력된 리스트에서 <code>sensor_msgs/msg/PointCloud2</code> 타입의 토픽들을 식별한다.</p>
<h4>2.3.2 단계: Rosbag 기록</h4>
<p>식별된 토픽들을 <code>ros2 bag record</code> 명령어를 사용하여 동시에 기록한다. 여러 토픽을 기록하려면 토픽 이름을 공백으로 구분하여 나열하면 된다.7</p>
<pre><code class="language-Bash"># bag 파일을 저장할 디렉토리 생성
mkdir -p ~/lidar_bags
cd ~/lidar_bags

# 3개의 LiDAR 토픽을 30초 동안 'my_calibration_data'라는 이름으로 기록
ros2 bag record /lidar_front/points /lidar_left/points /lidar_right/points -d 30 -o my_calibration_data
</code></pre>
<h4>2.3.3 단계: 데이터 수집을 위한 모범 사례</h4>
<p>캘리브레이션의 성공은 데이터의 질에 크게 좌우된다. <code>Multi-LiCa</code>는 별도의 캘리브레이션 타겟 없이 환경의 기하학적 특징을 사용하므로, 데이터 수집 환경이 매우 중요하다.9 다음은 성공 확률을 높이기 위한 핵심 지침이다.</p>
<ul>
<li><strong>특징이 풍부한 환경 선택:</strong> 선반이 있는 차고, 가구가 배치된 방 등 기하학적 특징이 풍부하고 복잡한 정적 환경에 로봇을 배치하라. 개방된 평지나 텅 빈 복도와 같은 단순한 환경은 피해야 한다. 이러한 환경은 정합 알고리즘이 대응점을 찾는 데 필요한 충분한 정보를 제공하지 못하여 캘리브레이션 실패의 주된 원인이 된다.</li>
<li><strong>완벽한 정지 상태 유지:</strong> 로봇이 평평한 지면 위에서 완전히 정지한 상태인지 확인하라.</li>
<li><strong>적절한 기록 시간:</strong> 각 센서로부터 밀도 높고 대표적인 포인트 클라우드를 획득하기 위해 10초에서 30초 사이의 짧은 시간 동안 데이터를 기록하는 것으로 충분하다.</li>
</ul>
<h2>3.  <code>params.yaml</code>을 통한 상세 설정</h2>
<p><code>params.yaml</code> 파일은 캘리브레이션 프로세스를 제어하는 핵심 인터페이스다. 이 섹션에서는 각 파라미터의 역할과 설정 방법을 상세히 설명하여 사용자가 자신의 요구에 맞게 설정을 최적화할 수 있도록 돕는다.</p>
<h3>3.1  파일 개요</h3>
<ul>
<li><strong>위치:</strong> 소스 저장소 내 <code>config/params.yaml</code>.4</li>
<li><strong>목적:</strong> 캘리브레이션 노드의 모든 입력, 출력, 그리고 알고리즘 튜닝 파라미터를 정의한다.</li>
</ul>
<h3>3.2  파라미터 상세 설명</h3>
<p><code>params.yaml</code> 파일의 모든 파라미터는 <code>multi_lidar_calibrator.ros__parameters</code> 네임스페이스 아래에 정의되어야 한다. 주요 파라미터 그룹은 다음과 같다.</p>
<ul>
<li><strong>전역 설정:</strong> 출력 경로, 시각화 여부 등 전반적인 동작을 제어한다.</li>
<li><strong>LiDAR 정의 (<code>lidars</code>):</strong> 각 센서의 이름, 데이터 소스(<code>.pcd</code> 경로 또는 ROS 토픽), 기준 센서 여부를 정의한다.</li>
<li><strong>전처리 (<code>preprocessing</code>):</strong> Voxel downsampling, 이상치 제거 등 포인트 클라우드 전처리 관련 파라미터를 설정한다.</li>
<li><strong>초기 정합 (<code>feature_matching</code>):</strong> FPFH/TEASER++ 기반의 대략적인 초기 정합 단계를 위한 파라미터를 설정한다.</li>
<li><strong>정밀 정합 (<code>gicp</code>):</strong> GICP 알고리즘의 최대 대응 거리, 최대 반복 횟수 등 핵심 파라미터를 조정한다.</li>
<li><strong>지면 캘리브레이션 (<code>ransac_ground_filter</code>):</strong> RANSAC 기반 지면 평면 검출 관련 파라미터를 설정한다.</li>
<li><strong>출력 제어:</strong> 기준 LiDAR와 로봇 베이스 프레임 간의 추가 캘리브레이션 여부, URDF 파일 출력 경로 등을 제어한다.</li>
</ul>
<h3>3.3  <code>params.yaml</code> 전체 파라미터 참조 테이블</h3>
<p>다음 표는 <code>params.yaml</code> 파일의 모든 파라미터에 대한 상세 설명과 권장 설정 가이드를 제공한다.</p>
<table><thead><tr><th><strong>파라미터 경로</strong></th><th><strong>데이터 타입</strong></th><th><strong>설명</strong></th><th><strong>기본값</strong></th><th><strong>설정 가이드 / 예시</strong></th></tr></thead><tbody>
<tr><td><code>target_lidar</code></td><td>string</td><td>기준 좌표계로 사용될 LiDAR의 이름. 다른 모든 LiDAR는 이 LiDAR를 기준으로 캘리브레이션된다.</td><td><code>"lidar_front_right"</code></td><td><code>lidars</code> 리스트에 정의된 <code>name</code> 중 하나와 반드시 일치해야 한다.</td></tr>
<tr><td><code>output_path</code></td><td>string</td><td>캘리브레이션 결과(변환 행렬, 병합된 포인트 클라우드 등)가 저장될 디렉토리 경로다.</td><td><code>"src/multi_lidar_calibrator/output/"</code></td><td>절대 경로 또는 작업 공간 루트 기준 상대 경로를 사용하라.</td></tr>
<tr><td><code>visualize</code></td><td>boolean</td><td>캘리브레이션 전후의 포인트 클라우드를 Open3D 창으로 시각화할지 여부를 결정한다.</td><td><code>true</code></td><td>디버깅 및 결과의 즉각적인 확인을 위해 <code>true</code>로 설정하는 것을 권장한다.</td></tr>
<tr><td><code>use_ros_time</code></td><td>boolean</td><td>ROS 시간을 사용할지 여부를 결정한다. 시뮬레이션 환경이나 bag 파일 재생 시 <code>true</code>로 설정해야 한다.</td><td><code>false</code></td><td></td></tr>
<tr><td><code>lidars</code></td><td>list</td><td>캘리브레이션할 LiDAR 센서 목록이다. 각 항목은 아래의 <code>name</code>, <code>pcd_path</code>, <code>topic</code> 등을 포함한다.</td><td>-</td><td>최소 2개 이상의 LiDAR를 정의해야 한다.</td></tr>
<tr><td><code>lidars.name</code></td><td>string</td><td>LiDAR 센서의 고유 이름이다.</td><td>-</td><td>예: <code>"lidar_left"</code>, <code>"lidar_rear"</code></td></tr>
<tr><td><code>lidars.pcd_path</code></td><td>string</td><td>ROS 토픽 대신 <code>.pcd</code> 파일을 입력으로 사용할 경우, 파일의 경로를 지정한다.</td><td><code>""</code></td><td>예: <code>"data/pcd/lidar_left.pcd"</code></td></tr>
<tr><td><code>lidars.topic</code></td><td>string</td><td><code>.pcd</code> 파일 대신 ROS 토픽을 입력으로 사용할 경우, <code>sensor_msgs/PointCloud2</code> 토픽 이름을 지정한다.</td><td><code>""</code></td><td>예: <code>"/ouster_left/points"</code></td></tr>
<tr><td><code>preprocessing.voxel_leaf_size</code></td><td>double</td><td>Voxel Grid 필터를 사용하여 포인트 클라우드를 다운샘플링할 때의 복셀 크기(미터 단위)이다.</td><td><code>0.1</code></td><td>값을 줄이면 더 정밀하지만 계산량이 증가한다. 센서 밀도에 따라 조정한다.</td></tr>
<tr><td><code>preprocessing.outlier_removal.active</code></td><td>boolean</td><td>통계적 이상치 제거(Statistical Outlier Removal) 필터 활성화 여부다.</td><td><code>true</code></td><td>노이즈가 많은 센서의 경우 활성화하는 것이 좋습니다.</td></tr>
<tr><td><code>feature_matching.active</code></td><td>boolean</td><td>FPFH와 TEASER++를 이용한 초기 정합(coarse alignment)을 수행할지 여부다.</td><td><code>true</code></td><td>초기 추정치가 없는 경우 반드시 <code>true</code>로 설정해야 한다.</td></tr>
<tr><td><code>gicp.max_correspondence_distance</code></td><td>double</td><td>GICP 정합 시 대응점을 찾기 위한 최대 검색 거리(미터 단위)다.</td><td><code>1.0</code></td><td>캘리브레이션 품질에 가장 큰 영향을 미치는 파라미터 중 하나이다. 초기 정렬 상태가 좋으면 값을 줄이고, 상태가 나쁘면 값을 늘려야 한다.</td></tr>
<tr><td><code>gicp.max_iterations</code></td><td>integer</td><td>GICP 알고리즘의 최대 반복 횟수다.</td><td><code>100</code></td><td>일반적으로 기본값을 사용해도 충분하다.</td></tr>
<tr><td><code>ransac_ground_filter.active</code></td><td>boolean</td><td>RANSAC을 이용해 지면을 제거하는 필터의 활성화 여부다.</td><td><code>true</code></td><td>평평하지 않은 지면이나 지면 정보가 중요한 환경에서는 <code>false</code>로 설정할 수 있다.</td></tr>
<tr><td><code>calibrate_target_to_base</code></td><td>boolean</td><td><code>true</code>로 설정하면, 기준 LiDAR(<code>target_lidar</code>)와 로봇의 베이스 프레임(<code>base_frame_id</code>) 간의 추가 캘리브레이션을 수행한다.</td><td><code>false</code></td><td>이 기능을 사용하려면 <code>x</code>, <code>y</code> 변환과 <code>roll</code>, <code>yaw</code> 회전값이 정확히 알려져 있어야 한다.</td></tr>
<tr><td><code>base_frame_id</code></td><td>string</td><td><code>calibrate_target_to_base</code>가 활성화되었을 때 사용할 로봇의 베이스 프레임 ID다.</td><td><code>"base_link"</code></td><td>로봇의 URDF에 정의된 베이스 프레임 이름과 일치시켜야 한다.</td></tr>
<tr><td><code>urdf_path</code></td><td>string</td><td><code>calibrate_target_to_base</code>가 활성화되었을 때, 캘리브레이션 결과를 저장할 URDF 파일의 경로다.</td><td><code>""</code></td><td>지정하면, <code>static_transform_publisher</code>를 포함하는 URDF 파일이 생성된다.</td></tr>
</tbody></table>
<h2>4.  캘리브레이션 실행 및 검증</h2>
<p>설정이 완료되면 캘리브레이션을 실행하고 그 결과를 정량적, 정성적으로 검증해야 한다. 이 단계는 캘리브레이션의 신뢰성을 확보하는 데 매우 중요하다.</p>
<h3>4.1  캘리브레이션 노드 실행</h3>
<p>작업 공간의 루트 디렉토리에서 다음 명령어를 실행하여 캘리브레이션 노드를 시작한다. <code>parameter_file</code> 인자를 통해 방금 수정한 <code>params.yaml</code> 파일의 경로를 정확히 지정해야 한다.4</p>
<pre><code class="language-Bash"># 작업 공간 루트에서 실행 (예: ~/ros2_ws)
source install/setup.bash
ros2 launch multi_lidar_calibrator calibration.launch.py parameter_file:=/path/to/your/params.yaml
</code></pre>
<h3>4.2  대화형 시각화 과정</h3>
<p><code>visualize</code> 파라미터가 <code>true</code>로 설정된 경우, 두 개의 Open3D 창이 순차적으로 나타난다.4</p>
<ol>
<li><strong>초기 정렬 상태 창:</strong> 캘리브레이션 전, 각 LiDAR의 포인트 클라우드가 초기 상태로 표시된다. 이 창에서 데이터가 정상적으로 로드되었는지 확인한 후, 키보드에서 ‘Q’ 키를 눌러 창을 닫으면 실제 캘리브레이션 계산이 시작된다.</li>
<li><strong>최종 정렬 상태 창:</strong> 계산이 완료된 후, 변환 행렬이 적용된 포인트 클라우드가 표시된다. 이 창에서 시각적으로 포인트 클라우드가 잘 정합되었는지 즉시 확인할 수 있다.</li>
</ol>
<h3>4.3  터미널 출력 해석</h3>
<p>캘리브레이션이 완료되면 터미널에 결과가 출력된다. 여기서 주목해야 할 가장 중요한 정보는 다음과 같다.</p>
<ul>
<li><strong>변환 행렬 (Transformation Matrix):</strong> 각 LiDAR 쌍에 대한 <span class="math math-inline">4 \times 4</span> 동차 변환 행렬이 출력된다. 이 행렬이 최종 캘리브레이션 결과다.</li>
<li><strong>GICP <code>fitness_score</code>:</strong> 정합의 품질을 나타내는 정량적 지표이다. 이 점수는 정합된 포인트 쌍의 비율을 나타내며, 일반적으로 0.2 이상의 값이면 양호한 정합으로 간주할 수 있다.11 점수가 지나치게 낮다면, 데이터 수집 환경이나 GICP 파라미터 조정을 검토해야 한다.</li>
</ul>
<h3>4.4  RViz2를 이용한 고급 시각적 검증</h3>
<p><code>Multi-LiCa</code>가 제공하는 시각화 도구 외에, ROS 생태계의 표준 시각화 도구인 RViz2를 사용하면 보다 신뢰성 높은 검증이 가능한다. 이는 캘리브레이션 결과가 실제 로봇 시스템 내에서 어떻게 적용되는지 확인하는 데 필수적인 과정이다.</p>
<h4>4.4.1 단계: RViz2 실행</h4>
<p>새 터미널을 열고 RViz2를 실행한다.</p>
<pre><code class="language-Bash">ros2 run rviz2 rviz2
</code></pre>
<h4>4.4.2 단계: 다중 PointCloud2 디스플레이 추가</h4>
<p>RViz2 좌측 하단의 ‘Add’ 버튼을 클릭한 후, ‘By topic’ 탭에서 각 LiDAR의 원본 <code>PointCloud2</code> 토픽을 선택하여 여러 개의 PointCloud2 디스플레이를 추가한다.12</p>
<h4>4.4.3 단계: 고정 프레임 설정</h4>
<p>‘Global Options’ 패널에서 ’Fixed Frame’을 <code>target_lidar</code>의 프레임 ID(예: <code>lidar_front_right_link</code>)로 설정한다.</p>
<h4>4.4.4 단계: 정렬 불일치 확인</h4>
<p>이 상태에서는 TF(Transform) 정보가 없으므로, RViz2의 3D 뷰에서 포인트 클라우드들이 서로 어긋나 보일 것이다.</p>
<h4>4.4.5 단계: 계산된 변환 정보 발행</h4>
<p>새 터미널에서 <code>tf2_ros</code>의 <code>static_transform_publisher</code>를 사용하여 터미널에 출력된 캘리브레이션 결과를 <code>/tf_static</code> 토픽으로 직접 발행한다.</p>
<pre><code class="language-Bash"># 터미널 출력에서 얻은 x, y, z, yaw, pitch, roll 값을 사용
# 예시: target_lidar_frame을 기준으로 source_lidar_frame의 위치를 발행
ros2 run tf2_ros static_transform_publisher --x 0.0 --y -1.5 --z 0.0 --roll 0.0 --pitch 0.0 --yaw 3.14159 target_lidar_frame source_lidar_frame
</code></pre>
<h4>4.4.6 단계: RViz2에서 정렬 확인</h4>
<p>위 명령을 실행하는 즉시, RViz2의 3D 뷰에서 어긋나 있던 포인트 클라우드들이 정확하게 정렬되는 것을 시각적으로 확인할 수 있다. 이는 캘리브레이션 결과가 올바르다는 강력한 증거가 된다.</p>
<h2>5.  캘리브레이션 결과 적용</h2>
<p>캘리브레이션이 성공적으로 완료되었다면, 그 결과를 로봇 시스템에 영구적으로 적용하여 다른 모든 ROS2 노드가 활용할 수 있도록 해야 한다.</p>
<h3>5.1  출력 파일 이해</h3>
<p><code>params.yaml</code>의 <code>output_path</code>에 지정된 디렉토리에는 다음과 같은 결과 파일들이 생성된다.</p>
<ul>
<li><code>transforms.yaml</code>: 각 센서에 대한 최종 <span class="math math-inline">4 \times 4</span> 변환 행렬이 저장된 YAML 파일이다.4</li>
<li><code>merged.pcd</code>: 모든 포인트 클라우드가 최종적으로 병합된 씬(scene)의 <code>.pcd</code> 파일이다.</li>
<li><code>(선택) calibration.urdf</code>: <code>urdf_path</code>가 지정된 경우, 정적 변환 정보를 포함하는 URDF 파일이 생성된다.4</li>
</ul>
<h3>5.2  영구적인 TF 발행을 위한 Launch 파일 작성</h3>
<p>ROS2에서 정적 변환(static transform)을 관리하는 가장 표준적인 방법은 런치 파일(<code>.launch.py</code>) 내에서 <code>static_transform_publisher</code> 노드를 실행하는 것이다. 다음은 <code>transforms.yaml</code> 파일에서 얻은 결과를 사용하여 영구적인 TF를 발행하는 완전한 Python 런치 파일 예제다.</p>
<p>이 런치 파일은 로봇이 시작될 때마다 자동으로 캘리브레이션된 TF 관계를 발행하여, 시스템의 모든 노드가 정렬된 센서 데이터를 사용할 수 있도록 보장한다.</p>
<pre><code class="language-Python">import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import Node
import yaml

def generate_launch_description():

    # 캘리브레이션 결과 파일 경로
    # 실제 환경에서는 이 경로를 정확하게 수정해야 한다.
    calibration_config_path = os.path.join(
        get_package_share_directory('your_robot_description_package'),
        'config',
        'transforms.yaml'
    )

    # YAML 파일 로드
    with open(calibration_config_path, 'r') as file:
        config = yaml.safe_load(file)

    static_transform_publisher_nodes =

    target_frame = config['target_lidar']

    for lidar_name, transform_data in config['transforms'].items():
        # 변환 데이터 추출
        translation = transform_data['translation']
        rotation_quat = transform_data['rotation_quat'] # 쿼터니언 사용

        # static_transform_publisher 노드 생성
        # quaternions (x, y, z, w) 순서로 인자 전달
        node = Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name=f'static_tf_pub_{lidar_name}_to_{target_frame}',
            arguments=[
                str(translation['x']),
                str(translation['y']),
                str(translation['z']),
                str(rotation_quat['x']),
                str(rotation_quat['y']),
                str(rotation_quat['z']),
                str(rotation_quat['w']),
                target_frame,      # 부모 프레임 (parent frame)
                lidar_name         # 자식 프레임 (child frame)
            ]
        )
        static_transform_publisher_nodes.append(node)

    return LaunchDescription(static_transform_publisher_nodes)
</code></pre>
<p>이 예제는 <code>transforms.yaml</code> 파일에서 변환 값을 동적으로 읽어와 각 LiDAR에 대한 <code>static_transform_publisher</code> 노드를 생성한다. 이를 통해 캘리브레이션 결과를 로봇의 기본 실행 절차에 견고하게 통합할 수 있다.15</p>
<h2>6.  종합 문제 해결 가이드</h2>
<p>이 섹션은 사용자가 캘리브레이션 과정에서 마주할 수 있는 일반적인 문제들을 진단하고 해결하는 데 도움을 주기 위해 구성되었다.</p>
<h3>6.1  카테고리 1: 빌드 실패 (<code>colcon build</code>)</h3>
<ul>
<li><strong>증상:</strong> <code>colcon build</code> 명령 실행 시 오류와 함께 종료된다.</li>
<li><strong>일반적인 원인 및 해결책:</strong></li>
<li><strong>서브모듈 누락:</strong> TEASER++ 관련 헤더 파일을 찾을 수 없다는 오류가 발생한다. <strong>해결책:</strong> 저장소를 <code>git clone --recurse-submodules</code> 명령으로 다시 복제한다.</li>
<li><strong>Python 의존성 문제:</strong> <code>setuptools</code> 등 특정 패키지와 관련된 오류가 발생한다. <strong>해결책:</strong> <code>pip install -r requirements.txt</code> 명령이 성공적으로 실행되었는지 확인한다. 특히 ROS2 Humble과 Ubuntu 22.04 환경에서는 <code>setuptools</code> 버전 충돌이 발생할 수 있으며, <code>pip install setuptools==58.2.0</code>과 같이 버전을 낮추는 것이 해결책이 될 수 있다.17</li>
<li><strong>오래된 빌드/설치 디렉토리:</strong> 코드 변경 후 <code>colcon</code>이 오래된 캐시 정보를 사용하여 문제가 발생할 수 있다. <strong>해결책:</strong> 작업 공간의 <code>build/</code>, <code>install/</code>, <code>log/</code> 디렉토리를 모두 삭제한 후 다시 빌드한다.18</li>
</ul>
<h3>6.2  카테고리 2: 런타임 오류</h3>
<ul>
<li><strong>증상:</strong> <code>ros2 launch</code> 명령이 실패하거나 노드가 실행 중 예기치 않게 종료된다.</li>
<li><strong>일반적인 원인 및 해결책:</strong></li>
<li><strong>ROS2 토픽을 찾을 수 없음:</strong> 노드가 <code>params.yaml</code>에 명시된 토픽을 기다리지만, 해당 토픽이 발행되지 않는 경우다. <strong>해결책:</strong> <code>ros2 topic echo &lt;topic_name&gt;</code> 명령을 사용하여 LiDAR 드라이버가 정상적으로 데이터를 발행하고 있는지 확인한다.</li>
<li><strong>Docker 네트워킹 문제:</strong> 컨테이너 내부의 노드와 호스트의 노드가 통신하지 못하는 경우다. <strong>해결책:</strong> 호스트와 컨테이너의 <code>ROS_DOMAIN_ID</code> 환경 변수가 동일하게 설정되었는지 확인한다.4</li>
<li><strong>부정확한 파일 경로:</strong> 노드가 <code>.pcd</code> 파일을 찾지 못하는 경우다. <strong>해결책:</strong> <code>params.yaml</code>에 지정된 경로가 올바른지 다시 확인하고, 모호성을 피하기 위해 절대 경로를 사용하는 것을 권장한다.</li>
</ul>
<h3>6.3  카테고리 3: 낮은 캘리브레이션 품질</h3>
<ul>
<li><strong>증상:</strong> 프로세스는 성공적으로 완료되지만, <code>fitness_score</code>가 0.2 미만으로 낮거나 시각적 정렬 상태가 불량한다.</li>
<li><strong>일반적인 원인 및 해결책:</strong></li>
<li><strong>부족한 환경 특징:</strong> 데이터 수집 환경이 너무 단순하여(예: 특징 없는 긴 복도) 알고리즘이 대응점을 찾지 못하는 경우다. <strong>해결책:</strong> 기하학적으로 더 복잡한 환경에서 데이터를 다시 수집한다.</li>
<li><strong>FOV 중첩 부족:</strong> LiDAR 센서들이 충분한 공통 영역을 보지 못하는 경우다. <strong>해결책:</strong> 센서나 로봇의 위치를 조정하여 중첩 영역을 확보한다.</li>
<li><strong>부적절한 GICP 파라미터:</strong> 기본 파라미터가 현재 센서나 환경에 최적화되지 않았을 수 있다. <strong>해결책:</strong> <code>params.yaml</code>의 <code>gicp.max_correspondence_distance</code> 값을 체계적으로 조정한다. 기본값에서 시작하여, 포인트 클라우드가 매우 밀집된 경우 값을 줄이거나 초기 정렬 상태가 매우 나쁜 경우 값을 늘려본다.</li>
</ul>
<h2>7. 결론</h2>
<p>이 가이드는 ROS2 Humble 환경에서 <code>Multi-LiCa</code> 패키지를 사용하여 다중 LiDAR 시스템을 성공적으로 캘리브레이션하는 데 필요한 모든 실용적인 절차를 상세히 다루었다. 올바른 환경 설정, 양질의 데이터 준비, 세심한 파라미터 구성, 그리고 체계적인 결과 검증 과정을 통해 사용자는 복잡한 센서 시스템의 정밀한 외부 파라미터를 효과적으로 획득할 수 있다. 최종적으로, 캘리브레이션 결과를 ROS2 런치 파일에 통합함으로써, 로봇의 모든 후속 작업(예: SLAM, 장애물 인식, 내비게이션)에서 일관되고 정합된 센서 데이터를 활용할 수 있는 견고한 기반을 마련하게 된다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>How to install ROS 2 Humble Hawksbill - Forecr.io, https://www.forecr.io/blogs/installation/how-to-install-ros-2-humble-hawksbill</li>
<li>ROS 2 Humble Installation - JARVIS DOCS - Goat Robotics, <a href="https://jarvis.goat-robotics.com/docs/Installation/ROS2%20installation/">https://jarvis.goat-robotics.com/docs/Installation/ROS2%20installation/</a></li>
<li>Install the ROS2 Humble | Seeed Studio Wiki, https://wiki.seeedstudio.com/install_ros2_humble/</li>
<li>TUMFTM/Multi_LiCa: Multi - LiDAR-to-LiDAR calibration framework for ROS2 and non-ROS applications - GitHub, https://github.com/TUMFTM/Multi_LiCa</li>
<li>A universal build tool - ROS2 Design, https://design.ros2.org/articles/build_tool.html</li>
<li>ram-lab/lidar_appearance_calibration: This a ros package for multi-LiDAR calibration using three planar surfaces. - GitHub, https://github.com/ram-lab/lidar_appearance_calibration</li>
<li>ros2 bag - Save and Replay Topic Data - The Robotics Back-End, https://roboticsbackend.com/ros2-bag-save-and-replay-topic-data/</li>
<li>Recording and playing back data — ROS 2 Documentation: Jazzy documentation, https://docs.ros.org/en/jazzy/Tutorials/Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data.html</li>
<li>Multi-LiCa: A Motion and Targetless Multi LiDAR-to-LiDAR Calibration Framework - arXiv, https://arxiv.org/abs/2501.11088</li>
<li>Multi-LiCa: A Motion- and Targetless Multi - LiDAR-to-LiDAR Calibration Framework - arXiv, https://arxiv.org/html/2501.11088v1</li>
<li>(PDF) Multi-LiCa: A Motion and Targetless Multi LiDAR-to-LiDAR Calibration Framework, https://www.researchgate.net/publication/388231076_Multi-LiCa_A_Motion_and_Targetless_Multi_LiDAR-to-LiDAR_Calibration_Framework</li>
<li>rviz/DisplayTypes/PointCloud - ROS Wiki, https://wiki.ros.org/rviz/DisplayTypes/PointCloud</li>
<li>RViz User Guide — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Intermediate/RViz/RViz-User-Guide/RViz-User-Guide.html</li>
<li>tudelft-iv/multi_sensor_calibration - GitHub, https://github.com/tudelft-iv/multi_sensor_calibration</li>
<li>[ROS2 Q&amp;A] 216 - How to Use Static Transform Publisher in ROS2 - The Construct, https://www.theconstruct.ai/ros2-qa-216-how-to-use-static-transform-publisher-in-ros2/</li>
<li>roslaunch - static_transform_publisher in ROS2 launch file …, https://robotics.stackexchange.com/questions/98420/static-transform-publisher-in-ros2-launch-file</li>
<li>“colcon build” fails on ROS2 tutorials - ROS Answers archive, https://answers.ros.org/question/404536/</li>
<li>colcon build fails humble - ros2 - Robotics Stack Exchange, https://robotics.stackexchange.com/questions/101935/colcon-build-fails-humble</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>