<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:VDB (Volumetric Dynamic B+tree)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>VDB (Volumetric Dynamic B+tree)</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">센서 (Sensors)</a> / <a href="../index.html">포인트 클라우드</a> / <a href="index.html">VDB</a> / <span>VDB (Volumetric Dynamic B+tree)</span></nav>
                </div>
            </header>
            <article>
                <h1>VDB (Volumetric Dynamic B+tree)</h1>
<h2>1. 서론</h2>
<p>VDB(Volumetric Dynamic B+tree)는 3차원 그리드에 이산화된 희소(sparse), 동적(dynamic), 시변(time-varying) 볼류메트릭 데이터를 효율적으로 저장하고 조작하기 위해 설계된 컴팩트한 계층적 자료 구조이다.1 이 구조는 DreamWorks Animation의 Ken Museth에 의해 처음 개발되었으며, 시각 효과(VFX) 산업에서 연기, 구름, 물과 같은 복잡한 현상을 표현하기 위한 목적으로 시작되었다.1 이후 그 성능과 유연성을 인정받아 로보틱스, 과학 시뮬레이션, 의료 영상, 3D 재구성 등 다양한 분야로 그 적용 범위를 성공적으로 확장해왔다.4</p>
<p>본 안내서를 시작하기에 앞서, 용어의 혼동을 방지하기 위해 중요한 개념적 구분을 명확히 할 필요가 있다. 최근 인공지능(AI) 및 데이터 과학 분야에서 부상하고 있는 ’VDB’는 주로 ’벡터 데이터베이스(Vector Database)’를 지칭한다. 이는 텍스트, 이미지, 오디오 등에서 추출된 고차원 벡터 임베딩을 저장하고, 유사도 기반의 빠른 검색을 수행하는 시스템이다.6 본 안내서에서 다루는 <strong>Volumetric Dynamic B+tree</strong>는 이름의 약어(VDB)가 동일할 뿐, 컴퓨터 그래픽스와 시뮬레이션을 위한 3차원 공간 데이터 구조로서 벡터 데이터베이스와는 근본적으로 다른 목적과 구조, 기술적 배경을 가진다. 따라서 본 안내서의 ’VDB’는 전적으로 Volumetric Dynamic B+tree를 의미한다.</p>
<p>VDB의 개발 배경에는 기존 볼류메트릭 데이터 표현 방식의 근본적인 한계가 존재했다. 가장 직관적인 방식인 밀집 그리드(dense grid), 즉 3차원 배열은 데이터의 해상도가 증가함에 따라 메모리 요구량이 해상도의 세제곱에 비례하여(<span class="math math-inline">O(N3)</span>) 폭발적으로 증가한다.7 이는 연기나 구름처럼 대부분의 공간이 비어있는 희소(sparse) 데이터의 경우, 막대한 양의 메모리를 낭비하는 결과를 초래한다. VDB는 이러한 문제를 해결하기 위해 탄생했다. VDB의 핵심 목표는 사실상 무한한(unbounded) 3차원 인덱스 공간을 제공하면서도, 데이터가 존재하는 영역만을 효율적으로 저장하여 메모리 사용량을 최소화하고, 데이터의 삽입, 삭제, 조회가 빈번한 동적 환경에서도 빠른 랜덤 및 순차 접근 성능을 보장하는 것이다.1</p>
<h2>2.  VDB의 기본 원리</h2>
<h3>2.1  볼류메트릭 데이터 표현의 도전 과제</h3>
<p>3차원 공간상의 데이터를 표현하는 가장 간단한 방법은 공간을 균일한 격자, 즉 복셀(voxel)로 나누고 각 복셀의 값을 3차원 배열에 저장하는 밀집 그리드 방식이다. 이 방식은 특정 위치의 데이터에 <span class="math math-inline">O(1)</span>시간 복잡도로 즉시 접근할 수 있다는 장점이 있지만, 치명적인 단점을 내포하고 있다. 그리드의 해상도가 각 축으로 <span class="math math-inline">N</span>배 증가하면, 필요한 총 메모리 양은<span class="math math-display">N^3</span>에 비례하여 기하급수적으로 늘어난다.7 고해상도 시뮬레이션이나 렌더링에서 이는 곧 수십, 수백 기가바이트의 메모리를 요구하게 되어 현실적으로 사용이 불가능한 경우가 많다.</p>
<p>문제는 실제 세계의 많은 볼륨 데이터가 본질적으로 희소하다는 점에 있다. 예를 들어, 피어오르는 연기, 하늘에 떠 있는 구름, 혹은 레벨셋(level set) 기법에서 물체의 표면을 표현하는 좁은 밴드(narrow-band)는 전체 3차원 공간 중 극히 일부만을 차지한다.8 이러한 데이터에 밀집 그리드를 사용하는 것은 대부분의 메모리를 ‘빈 공간’ 또는 의미 없는 배경 값으로 채우는 것과 같다. 따라서 데이터가 실제로 존재하는 ‘활성(active)’ 영역만을 효율적으로 저장하는 희소 자료 구조의 필요성이 대두되었다. 하지만 VDB 이전의 많은 희소 볼륨 자료 구조들은 데이터의 토폴로지(topology)가 변하지 않는 정적(static) 상황을 가정하거나, 특정 접근 패턴(예: 순차 접근)에만 최적화되어 있어 데이터의 구조가 실시간으로 변하는 동적 시뮬레이션 환경에서는 무작위 접근(random access) 속도가 느려지는 등의 한계를 보였다.4</p>
<h3>1.2. VDB의 핵심 철학: 공간적 일관성(Spatial Coherency)과 토폴로지-데이터 분리</h3>
<p>VDB는 이러한 도전 과제를 해결하기 위해 두 가지 핵심 철학에 기반하여 설계되었다. 첫째는 <strong>공간적 일관성(spatial coherency)의 적극적인 활용</strong>이다.4 이는 자연계의 현상이나 시뮬레이션 데이터가 무작위로 흩어져 있기보다는 공간적으로 서로 뭉쳐서 나타나는 경향이 있다는 관찰에 기반한다. 즉, 특정 복셀 주변의 다른 복셀들은 유사하거나 동일한 값을 가질 확률이 높다. VDB는 이러한 특성을 이용하여 데이터를 계층적인 트리 구조로 묶고, 값이 동일한 넓은 영역을 상위 노드에서 하나의 ‘타일(tile)’ 값으로 압축하여 표현함으로써 메모리 효율성을 극대화한다.</p>
<p>둘째는 VDB의 가장 중요한 설계 원칙 중 하나인 **토폴로지-데이터 분리(separation of topology and data)**이다.4 이는 데이터의 공간적 위치와 구조를 정의하는 ’토폴로지’와, 해당 위치에 저장된 실제 ’데이터 값(value)’을 물리적으로 분리하여 관리하는 것을 의미한다. 토폴로지는 VDB 트리의 노드와 포인터 구조로 표현되며, 실제 float, vector, boolean 등의 데이터 값들은 리프 노드에 밀집된 데이터 블록(data block) 형태로 별도로 저장된다. 이러한 분리 구조는 데이터베이스 시스템에서 B+tree가 인덱스(키)와 실제 데이터 레코드를 가리키는 포인터를 분리하여 관리하는 철학과 매우 유사하다.9 이 덕분에 토폴로지 구조의 변경 없이 데이터 값만 효율적으로 업데이트하거나, 반대로 동일한 토폴로지 구조를 여러 다른 데이터셋(예: 밀도, 온도, 속도 필드)이 공유하는 인스턴싱(instancing)이 가능해져 높은 수준의 유연성과 메모리 효율성을 동시에 달성할 수 있다.8</p>
<h3>1.3. 이름의 해부: ‘Volumetric’, ’Dynamic’의 의미</h3>
<p>VDB라는 이름 자체는 이 자료 구조의 핵심적인 특성을 함축하고 있다.</p>
<ul>
<li><strong>‘Volumetric’</strong>: 이 자료 구조가 2차원 이미지나 1차원 데이터가 아닌, 3차원 공간상의 부피를 가진 데이터를 다루기 위해 특별히 설계되었음을 명확히 한다. 데이터 접근은 3차원 정수 인덱스 좌표 체계인 <span class="math math-inline">(i, j, k)</span>를 사용하여 이루어지며, 이를 통해 공간상의 특정 복셀 위치를 지정한다.8</li>
<li><strong>‘Dynamic’</strong>: VDB가 정적인 데이터뿐만 아니라, 시뮬레이션 과정에서 토폴로지가 끊임없이 변화하는 시변(time-varying) 데이터를 매우 효율적으로 처리할 수 있음을 의미한다.1 데이터의 삽입, 검색, 삭제가 빈번하게 일어나더라도 전체 구조를 재구성할 필요 없이 국소적인 노드의 할당과 해제를 통해 대응할 수 있다. 이러한 동적 특성은 평균적으로 상수 시간에 가까운(<span class="math math-inline">O(1)</span>) 빠른 업데이트 성능으로 이어진다.2</li>
</ul>
<p>여기서 VDB의 ’Dynamic’이라는 특성은 이중적인 의미를 지닌다. 런타임(runtime) 관점에서는 복셀 데이터의 추가 및 삭제에 따라 트리의 토폴로지가 동적으로 변화할 수 있다는 것을 의미한다.4 하지만 OpenVDB 구현체의 관점에서 보면, 트리의 레벨 수나 각 노드의 분기 계수(branching factor)와 같은 핵심적인 구조적 ’구성(configuration)’은 C++ 템플릿을 통해 컴파일 타임(compile-time)에 고정된다.1 이 두 가지 특성은 언뜻 모순처럼 보일 수 있지만, 실제로는 성능과 유연성을 모두 잡기 위한 정교한 설계의 결과이다. ’컴파일 타임 정적성’은 특정 데이터 타입과 트리 구조에 대해 컴파일러가 코드를 완벽하게 인라이닝하고 최적화하여 최고의 실행 성능을 이끌어내기 위한 전략적 선택이다. 반면, ’런타임 동적성’은 이렇게 최적화된 고정된 ‘틀’ 안에서 데이터의 존재 유무(활성/비활성 상태)가 자유롭게 변할 수 있음을 의미한다. 이 이중적 특성이야말로 VDB가 고성능과 높은 유연성을 동시에 제공하는 비결이다.</p>
<p>궁극적으로 VDB의 혁신은 완전히 새로운 개념의 ’발명’이라기보다는, B+tree, 옥트리(Octree), 희소 그리드 등 기존에 존재하던 여러 아이디어들을 통합하고, 3D 볼류메트릭 데이터라는 특정 도메인의 문제 해결을 위해 극도로 최적화한 ’공학적 성취’에 가깝다. VDB는 B+tree로부터 넓고 얕은 구조와 키-데이터 분리 철학을 9, 옥트리로부터는 공간 분할 아이디어를 차용했다. 그러나 VDB의 진정한 독창성은 3D 공간 좌표를 직접 해싱하여 자식 노드를 찾는 고유한 인덱싱 방식, 토폴로지와 데이터를 명확히 분리한 아키텍처, 그리고 현대 CPU의 캐시 구조에 극도로 최적화된 메모리 레이아웃 설계에 있다.4 이는 이론적 순수성보다는 VFX 프로덕션 현장에서 마주하는 ’고해상도의 동적 희소 데이터를 실시간에 가깝게 처리해야 한다’는 실용적인 요구사항을 해결하기 위한 고도의 엔지니어링적 절충과 통합의 산물이라 할 수 있다.</p>
<h2>제 2부: VDB 자료 구조 심층 탐구</h2>
<h3>2.1. 3차원 공간을 위한 B+tree: 구조적 비교 분석</h3>
<p>VDB는 그 이름에서 알 수 있듯이 데이터베이스 인덱싱에 널리 사용되는 B+tree와 여러 중요한 특성을 공유하지만, 3차원 공간 데이터를 다루기 위해 근본적인 차이점을 가진다.</p>
<h4>유사점 (B+tree-like Characteristics)</h4>
<ul>
<li><strong>높이 균형(Height-Balanced):</strong> B+tree와 마찬가지로 VDB 트리의 모든 리프 노드(Leaf Node)는 루트로부터 동일한 깊이에 존재한다.7 이는 어떤 데이터에 접근하더라도 트리 탐색에 소요되는 시간이 일정하게 유지되도록 보장하며, 예측 가능한 성능의 기반이 된다.</li>
<li><strong>넓고 얕은 구조(Shallow and Wide):</strong> VDB는 매우 높은 분기 계수(branching factor, 한 노드가 가질 수 있는 자식 노드의 수)를 가지도록 설계되어 트리의 전체 깊이가 매우 얕다.5 예를 들어, OpenVDB의 표준 4레벨 구조는 수조(1012) 개 이상의 복셀 위치를 표현하면서도 트리의 깊이는 단 4에 불과하다. 이는 디스크 기반의 B+tree가 느린 디스크 I/O 횟수를 최소화하기 위해 넓고 얕은 구조를 채택하는 원리와 유사하다. VDB에서는 이 구조가 메모리 내 포인터 역참조(pointer indirection) 횟수를 줄여 캐시 효율성을 높이고 접근 속도를 향상시키는 역할을 한다.</li>
<li><strong>데이터는 리프에만 (Data in Leaves, Conceptually):</strong> B+tree에서 실제 데이터 포인터가 리프 노드에만 존재하는 것처럼, VDB에서도 실제 개별 복셀 값들은 주로 최하위 레벨인 리프 노드에 저장된다.8 상위의 내부 노드(Internal Node)들은 자식 노드들을 가리키는 인덱스, 즉 공간을 분할하는 가이드 역할을 수행한다. 다만 VDB는 ’타일(tile)’이라는 개념을 통해 내부 노드에도 균일한 값을 저장할 수 있는 유연성을 추가로 제공한다.8</li>
</ul>
<h4>결정적 차이점</h4>
<ul>
<li><strong>인덱싱 방식(Indexing Method):</strong> 이것이 가장 근본적인 차이점이다. 전통적인 B+tree는 1차원의 정렬된 키(key)를 사용하며, 노드 내에서 키 비교(예: 이진 탐색)를 통해 다음 자식 노드로의 경로를 찾는다.7 반면, VDB는 3차원 공간 좌표 ‘(i,j,k)‘ 자체를 인덱스로 사용한다. 특정 좌표가 주어지면, 해당 좌표 값에 비트 마스킹(bit masking)과 시프트(shift) 연산을 적용하여 자식 노드의 배열 인덱스를 <strong>직접 계산</strong>해낸다.7 이는 정렬된 키 순서에 따른 순회가 아닌, 공간적 지역성(spatial locality)에 기반한 초고속 접근을 가능하게 하는 핵심 메커니즘이다.</li>
<li><strong>노드 분할/병합 부재(Absence of Split/Merge):</strong> B+tree는 데이터 삽입 및 삭제 시 노드가 가득 차거나 일정 수준 이하로 비게 되면 노드 분할(split) 또는 병합(merge) 연산을 수행하여 트리의 높이 균형을 동적으로 유지한다. VDB는 이와 같은 복잡한 분할/병합 로직을 사용하지 않는다.5 대신, 각 노드는 고정된 크기의 자식 포인터 배열을 가지며, 새로운 데이터가 추가될 때 필요한 경로상의 노드들이 동적으로 할당(allocate)되는 방식으로 희소성을 관리한다.</li>
</ul>
<h3>2.2. 계층적 아키텍처: 루트, 내부, 리프 노드</h3>
<p>VDB 트리는 일반적으로 3개에서 5개의 레벨로 구성된 계층 구조를 가진다.1 OpenVDB에서 가장 널리 사용되는 표준 4레벨 구성(<code>FloatGrid</code> 등)은 다음과 같은 노드들로 이루어진다.8</p>
<ul>
<li>
<p><strong>레벨 3 (RootNode):</strong> 트리의 최상위 노드로, 모든 탐색의 시작점이다. 다른 노드들과 달리 동적인 분기 계수(dynamic branching factor)를 가진다. 즉, 자식 노드의 수에 제한이 없다. 이 특징 덕분에 VDB는 사실상 무한한 3D 인덱스 공간을 표현할 수 있다. 루트 노드는 해시 테이블과 유사한 구조를 사용하여 3D 좌표에 해당하는 최상위 내부 노드(레벨 2)를 관리한다.1</p>
</li>
<li>
<p><strong>레벨 2 (InternalNode):</strong> OpenVDB에서는 종종 ’5-node’라고 불리며, 고정된 분기 계수를 가진다. 예를 들어, 각 차원당 2^5=32$개씩, 총 32×32×32=32,768개의 자식(레벨 1 노드)을 가리키는 포인터 배열을 가진다.12</p>
</li>
<li>
<p><strong>레벨 1 (InternalNode):</strong> ’4-node’라고 불리며, 마찬가지로 고정된 분기 계수를 가진다. 각 차원당 <span class="math math-inline">2^4=16</span></p>
<p>개씩, 총 16×16×16=4,096개의 자식(레벨 0 노드) 포인터를 가진다.12</p>
</li>
<li>
<p><strong>레벨 0 (LeafNode):</strong> ’3-node’라고도 불리며, 트리의 가장 마지막 레벨이다. 이 노드는 더 이상 자식 노드를 가리키지 않고, 실제 복셀 데이터 값들을 담고 있는 밀집된 3D 블록을 저장한다. 일반적으로 각 차원당 <span class="math math-inline">2^3=8</span> 개씩, 총 8×8×8=512개의 복셀 값을 저장하는 배열을 가진다.8</p>
</li>
</ul>
<p>이러한 계층 구조는 3D 공간을 효율적으로 분할하고 인덱싱한다. 특정 복셀의 전역 좌표 <span class="math math-inline">(i, j, k)</span>가 주어지면, 각 레벨에서 해당 좌표의 특정 비트들을 추출하여 자식 노드 배열 내의 지역 인덱스(local index)를 계산한다. 예를 들어, 8×8×8 리프 노드 내의 지역 좌표는 전역 좌표의 하위 3비트(<span class="math math-inline">2^3=8</span>)로 결정되고, 그 상위 레벨인 4-node 내의 자식 인덱스는 그 다음 4비트(<span class="math math-inline">2^4=16</span>)로 결정되는 식이다. 이 계산은 단순한 비트 연산으로 이루어지므로 매우 빠르다. 구체적인 인덱스 계산 공식의 예는 다음과 같다 12:</p>
<ul>
<li>
<p>리프 노드 (3-node, 83) 내 복셀 인덱스:</p>
<pre><code>index=(i &amp; 7)≪6+(j &amp; 7)≪3+(k &amp; 7)
</code></pre>
<p>(자료 12의 <code>z + y*8 + x*64</code>는 x, y, z 순서가 다를 뿐 원리는 동일)</p>
</li>
<li>
<p>상위 노드 (5-node, 323) 내 자식 인덱스:</p>
<pre><code>index=((i≫3) &amp; 31)≪10+((j≫3) &amp; 31)≪5+((k≫3) &amp; 31)
</code></pre>
<p>(자료 12의 <code>z + y*32 + x*1024</code>와 원리 동일)</p>
</li>
</ul>
<h3>2.3. 데이터 표현과 희소성 압축</h3>
<p>VDB는 메모리 사용량을 최적화하고 데이터 접근을 가속화하기 위해, 데이터를 단일 형태가 아닌 세 가지의 논리적 형태로 구분하여 저장한다.8</p>
<ul>
<li><strong>배경 값 (Background Value):</strong> 트리에 명시적으로 저장되지 않은 모든 무한한 공간이 갖는 기본값이다. 예를 들어, 연기 시뮬레이션에서 연기가 없는 대부분의 공간은 밀도 0이라는 배경 값을 갖는다. 단 하나의 값으로 무한한 빈 공간을 표현하므로 VDB 메모리 효율성의 핵심이라 할 수 있다.1 배경 값을 가진 복셀은 항상 ‘비활성(inactive)’ 상태로 간주된다.1</li>
<li><strong>타일 값 (Tile Value):</strong> 내부 노드 수준에서 이루어지는 압축 기법이다. 만약 어떤 내부 노드가 포괄하는 전체 3D 공간의 모든 복셀 값이 하나의 동일한 값(배경 값과는 다른)을 갖는다면, VDB는 그 밑으로 수많은 하위 노드와 리프 노드를 생성하는 대신, 해당 내부 노드에 단일 ’타일 값’을 저장하고 하위 트리 생성을 중단한다. 이는 균일한 값으로 채워진 넓은 영역(예: 물 속 전체)을 매우 효율적으로 압축하는 역할을 한다.8</li>
<li><strong>복셀 값 (Voxel Value):</strong> 리프 노드의 데이터 블록에 저장되는 개별 복셀의 고유한 값이다. 데이터가 실제로 변화하고 세밀한 디테일이 존재하는 활성 영역을 표현하는 데 사용된다.8</li>
</ul>
<p>이러한 데이터 표현과 더불어, VDB는 **활성/비활성 상태와 비트마스크(bitmask)**를 통해 희소성을 적극적으로 관리한다. 모든 내부 노드와 리프 노드는 자신의 자식들(자식 노드 또는 복셀)이 ‘활성’ 상태인지, 즉 배경 값과 다른 유의미한 데이터를 담고 있는지 여부를 나타내는 비트마스크를 가진다.1 예를 들어, 8×8×8 리프 노드는 512개의 복셀 각각의 활성 상태를 나타내는 512비트(64바이트) 크기의 비트마스크를 갖는다. 데이터에 접근하거나 그리드를 순회할 때, 이 비트마스크를 먼저 검사하여 비활성 상태인 자식 노드나 복셀 영역 전체를 신속하게 건너뛸 수 있다. 이는 특히 활성 복셀만 순회하는 이터레이터의 성능을 극적으로 향상시키는 핵심 요소이다.1</p>
<p>VDB의 계층적 구조와 인덱싱 방식은 현대 컴퓨터의 가상 메모리 시스템이 작동하는 방식과 놀라울 정도로 유사하다. 가상 메모리 시스템은 페이지 테이블(Page Table)이라는 다단계 트리 구조를 사용하여 프로그램의 거대한 논리 주소 공간을 실제 물리 메모리 주소로 변환(address translation)한다. 이 과정의 속도를 높이기 위해 TLB(Translation Lookaside Buffer)라는 고속 캐시를 사용한다. VDB의 구조는 이러한 하드웨어적 접근법을 소프트웨어적으로 정교하게 모방한 것으로 볼 수 있다.10 VDB의 거대한 3D 인덱스 공간은 논리 주소 공간에, 루트-내부-리프 노드로 이어지는 트리는 페이지 테이블에, 그리고 실제 데이터가 저장된 리프 노드의 메모리 위치는 물리 주소에 해당한다. 특히, VDB의 <code>Value Accessor</code>가 사용하는 소프트웨어 캐시는 최근 접근한 노드의 주소 변환 결과를 저장하여 후속 접근을 가속화하는데 1, 이는 CPU의 TLB와 정확히 동일한 역할을 수행한다. 경쟁 자료 구조인 SPGrid가 VDB의 소프트웨어 캐시 대신 하드웨어 TLB를 직접 활용하도록 설계되었다는 점은 10, VDB의 설계 철학이 하드웨어 메모리 관리 방식과 얼마나 깊은 연관성을 갖는지 명확히 보여준다.</p>
<p>또한, 토폴로지와 데이터의 분리는 단순한 메모리 절약을 넘어 ’알고리즘적 유연성’이라는 더 큰 가치를 제공한다. 표면적으로 이 분리는 동일한 공간 구조를 여러 데이터 그리드(밀도, 온도 등)가 공유하여 메모리를 절약하는 데 사용된다.8 하지만 더 깊은 차원에서 이는 알고리즘의 분리를 가능하게 한다. 예를 들어, 충돌 감지, 최근접 이웃 탐색, 거리 필드 계산과 같은 기하학적 연산은 대부분 복셀의 실제 값보다는 토폴로지, 즉 활성 복셀의 위치에만 의존한다. VDB는 토폴로리만 순회하는 이터레이터와 값을 포함하여 순회하는 이터레이터를 별도로 제공함으로써 8, 기하 연산은 가벼운 토폴로리 트리만 순회하고, 렌더링이나 물리 계산처럼 실제 값이 필요한 경우에만 데이터 블록에 접근하도록 할 수 있다. 이러한 아키텍처 덕분에</p>
<p><code>VDB-GPDF</code> 14나 로보틱스의 3D 재구성 9 같은 복잡한 응용 프로그램에서, 맵의 구조(토폴로지)를 구축하는 작업과 표면의 색상이나 거리 값(데이터)을 갱신하는 작업을 독립적으로, 심지어 병렬적으로 처리할 수 있는 강력한 알고리즘적 기반이 마련된다.</p>
<h2>제 3부: 성능 특성 및 알고리즘 효율성</h2>
<p>VDB의 설계는 단순히 메모리를 효율적으로 사용하는 것을 넘어, 데이터 접근 및 조작의 성능을 극대화하는 데 초점이 맞춰져 있다. 특히 평균 <span class="math math-inline">O(1)</span> 랜덤 접근과 캐시 친화적인 순차 접근은 VDB를 다른 희소 자료 구조와 차별화하는 핵심 성능 특성이다.</p>
<h3>3.1. 평균 <span class="math math-inline">O(1)</span> 랜덤 접근의 달성 원리</h3>
<p>전통적인 트리 기반 자료 구조의 탐색 시간 복잡도는 일반적으로 트리의 높이에 비례하는 <span class="math math-display">O(\log N)</span>으로 알려져 있다. 하지만 VDB는 평균(average) <span class="math math-inline">O(1)</span> 랜덤 접근 성능을 제공한다고 주장하는데 2, 이는 이론과 실제 사이의 간극처럼 보일 수 있다. 이 놀라운 성능은 다음 세 가지 핵심 원리의 조합을 통해 달성된다.</p>
<ol>
<li><strong>고정된 얕은 깊이 (Fixed Shallow Depth):</strong> 앞서 설명했듯이, VDB 트리의 최대 높이는 데이터의 총량(<span class="math math-inline">N</span>)과 무관하게 컴파일 타임에 3~5 정도의 작은 상수로 고정된다.1 트리의 높이가 상수(<span class="math math-inline">k</span>)이므로, 최악의 경우(worst-case)에도 트리 탐색에 필요한 단계는 상수 번으로 제한된다. 따라서 시간 복잡도는 엄밀히 말해 <span class="math math-inline">O(k)</span>, 즉 <span class="math math-display">O(1)</span>이다.</li>
<li><strong>직접 좌표 해싱 (Direct Coordinate Hashing):</strong> 각 노드 레벨에서 다음 자식 노드를 찾기 위해 정렬된 키들을 비교하며 탐색하는 것이 아니라, 3D 좌표 값에 대한 간단한 비트 연산(마스킹 및 시프트)을 통해 자식 노드 배열의 인덱스를 한 번에 계산해낸다. 이 연산 자체는 CPU에서 매우 빠르게 수행되는 상수 시간 연산이다.</li>
<li><strong>경로 캐싱 메커니즘 (Path Caching Mechanism):</strong> 이것이 ‘평균적’ 성능을 <span class="math math-display">O(1)</span>에 가깝게 만드는 가장 결정적인 요소이다. OpenVDB에서 권장하는 데이터 접근 방식인 <code>Value Accessor</code> 객체는 내부적으로 캐시를 유지한다.1 사용자가 특정 복셀에 접근하면, <code>Value Accessor</code>는 루트 노드부터 해당 복셀이 포함된 리프 노드까지의 경로(path)에 있는 각 레벨의 노드 포인터들을 캐시에 저장한다. 이후 사용자가 이전에 접근했던 복셀과 공간적으로 인접한 다른 복셀에 접근할 경우(이는 시뮬레이션 및 렌더링에서 매우 흔한 패턴이다), <code>Value Accessor</code>는 루트부터 다시 탐색을 시작하는 대신 캐시된 상위 또는 중간 레벨 노드 포인터를 재사용하여 목표 리프 노드까지의 경로를 훨씬 짧게 단축한다. 이 캐싱 덕분에 연속적인 접근에 대한 상각(amortized) 시간 복잡도가 실질적으로 <span class="math math-display">O(1)</span>에 수렴하게 된다.</li>
</ol>
<p>결론적으로, VDB의 <span class="math math-inline">O(1)</span> 성능 주장은 모든 접근이 단일 연산으로 끝난다는 이론적 시간 복잡도에 대한 선언이 아니라, 일반적인 작업 부하(spatially coherent access) 하에서 상각 실행 시간이 상수처럼 동작한다는 ’실질적 처리량(Amortized Throughput)’에 대한 공학적 선언으로 해석해야 한다. 이는 VDB가 순수 컴퓨터 과학의 이론적 보장보다는, 고성능 컴퓨팅(HPC) 분야에서 실제 애플리케이션의 성능을 극대화하기 위한 실용적인 문제 해결 방식에 더 가깝다는 것을 보여준다.</p>
<h3>2.2  캐시 일관성(Cache Coherency)과 메모리 접근 패턴</h3>
<p>VDB는 현대 CPU 아키텍처의 핵심인 캐시 메모리를 최대한 활용하도록 설계되었다. 이는 <strong>데이터 지역성(data locality)</strong> 원리를 극대화함으로써 달성된다.</p>
<p>VDB의 리프 노드는 <span class="math math-inline">8×8×8</span>과 같은 작은 3D 블록 단위로 복셀 데이터를 저장하며, 이 데이터 블록은 메모리 상에 연속적으로 배치된다.8 따라서 애플리케이션이 특정 복셀 하나에 접근하면, 해당 복셀을 포함하는 전체 데이터 블록이 CPU의 L1, L2 캐시 라인(cache line)에 함께 로드될 확률이 매우 높다. 이로 인해 스텐실(stencil) 연산(예: 유체 시뮬레이션에서 이웃 복셀 6개의 값을 참조하는 연산)이나 특정 영역을 순차적으로 순회하는 작업 시, 대부분의 메모리 접근이 주 메모리가 아닌 매우 빠른 캐시 메모리 내에서 처리된다. 이는 캐시 미스(cache miss) 발생을 최소화하여, 희소 자료 구조임에도 불구하고 마치 밀집 배열(dense array)에 접근하는 것과 유사한 높은 메모리 대역폭과 처리량을 달성하게 해준다.10 VDB가 캐시 일관성을 고려한(cache-coherent) 빠른 데이터 접근을 제공하도록 설계되었다는 언급은 바로 이 점을 의미한다.2</p>
<h3>2.3  효율적 순회(Traversal) 메커니즘: 이터레이터와 값 접근자</h3>
<p>OpenVDB는 사용 사례에 따라 최적의 성능을 낼 수 있도록 두 가지 주요 데이터 접근 메커니즘을 제공한다.</p>
<ul>
<li><strong>값 접근자 (Value Accessor):</strong> 좌표 기반의 랜덤 접근에 최적화된 ‘가속기’ 객체이다.1 앞서 설명한 경로 캐싱 기능을 내장하여 반복적인 랜덤 접근 성능을 극대화한다.</li>
</ul>
<p><code>getValue(ijk)</code> 및 <code>setValue(ijk, value)</code>와 같은 메서드를 제공하여 직관적인 사용이 가능하다.13 하지만 중요한 점은, 이 내부 캐싱 메커니즘 때문에 <code>Value Accessor</code> 객체 자체가 본질적으로 스레드에 안전하지 않다(not thread-safe)는 것이다. 따라서 멀티스레드 환경에서는 각 스레드가 자신만의 독립적인 <code>Value Accessor</code> 인스턴스를 생성하여 사용해야 한다.1</p>
<ul>
<li>
<p><strong>이터레이터 (Iterators):</strong> 데이터 그리드의 순차적인 접근을 위해 설계된 강력한 도구이다. OpenVDB는 다양한 목적에 맞는 특화된 이터레이터를 제공하여 불필요한 연산을 최소화한다.8</p>
</li>
<li>
<p><code>ValueOnCIter</code> / <code>ValueOnIter</code>: ‘활성(active)’ 상태인 복셀들만 건너뛰며 순회한다. 희소 데이터를 처리하는 대부분의 작업에서 핵심적으로 사용된다.</p>
</li>
<li>
<p><code>ValueOffIter</code>: ‘비활성(inactive)’ 상태인 복셀들, 즉 배경 값을 가진 영역을 순회한다.</p>
</li>
<li>
<p><code>LeafNodeIter</code>: 복셀 단위가 아닌 리프 노드 단위로 순회한다. 이는 각 스레드가 서로 다른 리프 노드를 독립적으로 처리하는 방식의 병렬 처리에 매우 유용하다.13</p>
</li>
</ul>
<p>이러한 이터레이터들은 내부적으로 각 노드의 비트마스크를 효율적으로 검사하여 데이터가 없는 빈 공간을 통째로 건너뛰기 때문에, 전체 그리드를 무작정 순회하는 것보다 월등히 높은 성능을 보인다.1</p>
<h2>3.  실제 적용: OpenVDB 에코시스템</h2>
<p>VDB의 이론적 개념은 오픈소스 라이브러리인 OpenVDB를 통해 실제 애플리케이션에서 널리 사용되고 있다. OpenVDB는 VDB 자료 구조의 C++ 구현체이자, 이를 활용한 다양한 도구와 유틸리티의 집합이다. OpenVDB의 에코시스템을 이해하기 위해서는 핵심 구성 요소인 <code>Grid</code>, <code>Tree</code>, <code>Transform</code>의 관계를 파악하는 것이 중요하다.</p>
<h3>3.1  핵심 구성 요소: <code>Grid</code>, <code>Tree</code>, <code>Transform</code></h3>
<p>OpenVDB에서 데이터를 다룰 때 사용자는 주로 세 가지 핵심 객체와 상호작용하게 된다.8</p>
<ul>
<li>
<p><strong><code>Tree</code>:</strong> 지금까지 설명한 VDB의 핵심 계층적 자료 구조 그 자체이다. <code>Tree</code>는 저장될 데이터의 타입(예: <code>float</code>, <code>bool</code>, <code>openvdb::Vec3s</code>)과 트리의 구성(레벨 수, 각 레벨의 분기 계수 등)이 C++ 템플릿 파라미터로 결합되어 구체적인 타입으로 정의된다.1 예를 들어, 부동소수점 데이터를 저장하는 표준 4레벨 트리는 <code>openvdb::v11_0::tree::Tree&lt;openvdb::v11_0::tree::RootNode&lt;openvdb::v11_0::tree::InternalNode&lt;openvdb::v11_0::tree::InternalNode&lt;openvdb::v11_0::tree::LeafNode&lt;float, 3u&gt; , 4u&gt;, 5u&gt; &gt; &gt;</code> 와 같이 복잡한 템플릿으로 정의되며, 보통 <code>openvdb::FloatTree</code>와 같은 타입 별칭(type alias)으로 사용된다.</p>
</li>
<li>
<p><strong><code>Grid</code>:</strong> <code>Tree</code>를 감싸는 고수준의 컨테이너 객체이다. <code>Grid</code>는 핵심 데이터인 <code>Tree</code>에 더하여, 그리드의 이름이나 단위와 같은 메타데이터, 그리고 가장 중요하게는 <code>Transform</code> 객체를 포함한다.8 대부분의 경우, 애플리케이션 개발자는 저수준의 <code>Tree</code> 객체를 직접 조작하기보다는 <code>Grid</code> 객체가 제공하는 편리한 인터페이스(예: <code>getAccessor()</code>)를 통해 데이터에 접근한다. 하나의 <code>Tree</code>는 여러 <code>Grid</code> 객체에 의해 스마트 포인터로 참조될 수 있으며, 각 <code>Grid</code>는 서로 다른 <code>Transform</code>을 가질 수 있다. 이를 통해 동일한 볼륨 데이터를 여러 다른 위치에 복사본 없이 배치(instancing)하는 것이 가능하다.8</p>
</li>
<li>
<p><strong><code>Transform</code>:</strong> 복셀의 이산적인 정수 인덱스 좌표 <span class="math math-inline">(i, j, k)</span>를 실제 물리적 공간의 연속적인 월드 좌표 <span class="math math-inline">(x, y, z)</span>로 변환하는 역할을 담당한다.8</p>
</li>
</ul>
<p><code>Transform</code>을 통해 그리드 전체를 이동(translation), 회전(rotation), 크기 조절(scaling)할 수 있다. 이 변환 로직은 내부적으로 <code>Map</code>이라는 객체에 의해 관리되며, <code>applyMap</code> (인덱스 -&gt; 월드) 및 <code>applyInverseMap</code> (월드 -&gt; 인덱스) 메서드를 제공해야 한다.8</p>
<h3>3.2  컴파일 타임 구성을 통한 커스터마이징</h3>
<p>OpenVDB의 높은 성능과 유연성은 C++ 템플릿 메타프로그래밍(template metaprogramming)의 광범위한 활용에 크게 의존한다.1 사용자는 저장하고자 하는 데이터의 타입(<code>float</code>, <code>int</code>, <code>bool</code> 등)뿐만 아니라, 트리의 계층 구조(예: 레벨 2, 3, 4의 로그 차원)를 컴파일 시점에 자유롭게 지정하여 자신만의 커스텀 그리드를 정의할 수 있다.</p>
<p>이러한 정적 구성 방식은 런타임에 설정을 변경하는 방식에 비해 명백한 성능상의 이점을 가진다. 컴파일러는 특정 그리드 타입(예: <code>FloatGrid</code>와 <code>BoolGrid</code>)에 대해 모든 함수 호출과 데이터 접근을 인라이닝(inlining)하고, 타입에 특화된 최적화된 기계어 코드를 생성할 수 있다. 이는 가상 함수 호출이나 런타임 타입 체크와 같은 오버헤드를 원천적으로 제거하여 최고 수준의 성능을 이끌어낸다.1 OpenVDB의 API 설계는 이처럼 성능을 최우선으로 고려하는 철학을 명확히 보여준다.</p>
<p><code>Value Accessor</code>와 같은 가속기 객체의 사용이나 컴파일 타임 구성은, 사용 편의성이나 완전한 추상화보다는 ’전문가 사용자가 올바르게 사용할 때 최고의 성능을 얻을 수 있다’는 설계 사상을 반영한다. 이는 OpenVDB가 범용 라이브러리가 아니라, 성능이 가장 중요한 VFX 및 시뮬레이션 분야의 요구에 철저히 맞춰진 전문가용 도구임을 시사한다.</p>
<h3>3.3  동시성(Concurrency) 및 스레드 안전성(Thread Safety)</h3>
<p>OpenVDB가 멀티코어 CPU 환경에서 효율적으로 작동하는지, 즉 스레드에 안전한지에 대한 질문의 답은 “예, 그리고 아니오(Yes and no)“이다.1</p>
<ul>
<li><strong>안전한 경우 (Yes):</strong> OpenVDB는 멀티스레드 애플리케이션에서 안전하게 사용될 수 있도록 설계되었다. 특히, 여러 스레드가 동시에 그리드에서 데이터를 ‘읽기만’ 하는 작업은 완전히 안전하다. 실제로 OpenVDB에 포함된 많은 도구들(예: 필터링, CSG 연산)은 내부적으로 Intel의 TBB(Threading Building Blocks) 라이브러리를 사용하여 병렬화되어 있어 멀티코어 성능을 최대한 활용한다.1</li>
<li><strong>안전하지 않은 경우 (No):</strong> 문제는 쓰기 작업이 포함될 때 발생한다. 한 스레드가 그리드에 데이터를 쓰고 있을 때(즉, 복셀 값을 변경하거나 새로운 복셀을 삽입하여 트리의 토폴로지를 변경할 때), 다른 스레드가 동일한 그리드에서 데이터를 읽거나 쓰는 것은 일반적으로 안전하지 않다.1 이는 앞서 설명한 <code>Value Accessor</code>의 내부 캐시 상태나, 새로운 노드를 할당하는 메모리 관리 로직이 여러 스레드의 동시 접근을 고려하여 설계되지 않았기 때문이다.</li>
<li><strong>올바른 사용법:</strong> 이러한 문제를 해결하기 위해 개발자는 올바른 동시성 패턴을 사용해야 한다. 여러 스레드가 동시에 그리드에 써야 하는 경우, 각 스레드가 자신만의 로컬 그리드에 작업한 후 나중에 결과를 하나의 전역 그리드로 병합하는 방식을 사용하거나, 공유 그리드의 특정 부분에 대한 접근을 제어하기 위해 적절한 락(lock) 메커니즘을 구현해야 한다. 여러 스레드가 동시에 읽기 작업을 수행할 때는, 각 스레드가 자신만의 독립적인 <code>Value Accessor</code> 인스턴스를 생성하여 사용함으로써 캐시 상태의 충돌을 피해야 한다.1</li>
</ul>
<h2>4.  비교 분석</h2>
<p>VDB의 특성과 장점을 더 명확히 이해하기 위해, 이를 다른 주요 볼류메트릭 데이터 표현 방식들과 비교 분석하는 것은 매우 유용하다.</p>
<h3>4.1  VDB vs. 옥트리(Octree)</h3>
<p>옥트리는 공간을 재귀적으로 8개의 동일한 크기의 자식 노드로 분할하는, 가장 잘 알려진 3D 공간 분할 자료 구조 중 하나이다. VDB와 옥트리는 모두 계층적 구조를 갖지만 몇 가지 중요한 차이점이 있다.</p>
<ul>
<li><strong>구조적 차이:</strong> 가장 큰 차이는 분기 계수이다. 옥트리는 이름 그대로 항상 8개의 자식을 갖는 반면, VDB는 훨씬 높은 분기 계수(예: 리프 노드 바로 위는 <span class="math math-inline">16^3=4096</span>, 그 위는 <span class="math math-inline">32^3=32768</span>)를 사용한다.12 이로 인해 동일한 공간 해상도를 표현하더라도 VDB는 옥트리보다 훨씬 얕은 트리를 가지게 된다. 얕은 트리는 루트에서 리프까지의 포인터 추적 횟수를 줄여주므로 접근 속도에 유리하다.9</li>
<li><strong>메모리 지역성 및 성능:</strong> 옥트리는 깊이가 깊어질 수 있어, 트리 노드를 따라 포인터를 여러 번 추적하는 과정에서 캐시 미스가 발생할 확률이 VDB보다 높을 수 있다.15 반면 VDB의 리프 노드는 연속된 메모리 공간에 복셀 데이터 블록을 저장하므로 공간적, 메모리적 지역성이 더 우수하여 스텐실 연산 등에서 더 나은 성능을 보인다.</li>
<li><strong>적응성(Adaptivity):</strong> 옥트리는 데이터가 밀집된 영역은 깊게 분할하고 희소한 영역은 얕게 분할하는 진정한 의미의 ’공간 적응성(spatial adaptivity)’을 가진다. 즉, 공간에 따라 해상도 자체가 달라질 수 있다. 반면, OpenVDB의 표준 구현에서 트리는 모든 리프 노드가 동일한 깊이에 위치하는 고정된 높이를 가진다. 따라서 VDB는 데이터 값의 존재 유무(활성/비활성)에 따른 희소성은 완벽하게 표현하지만(OpenVDB 문서에서는 이를 ’adaptive in the first sense’라고 표현), 밉맵(mipmap)처럼 공간에 따라 해상도 자체를 다르게 하지는 않는다(‘not adaptive in the second sense’).1</li>
</ul>
<h3>4.2  VDB vs. 기타 희소 볼륨 표현 방식</h3>
<ul>
<li><strong>해싱 기반 그리드 (Hashing-based Grids):</strong> Voxel Hashing과 같은 기법들은 3D 공간 좌표를 해시 함수에 통과시켜 얻은 해시 값을 메모리 블록의 주소로 사용하는 방식이다. 이는 이론적으로 <span class="math math-display">O(1)</span>의 빠른 접근 속도를 제공하며 동적 업데이트에도 효율적이다. 하지만 두 가지 주요 단점이 있다. 첫째, 서로 다른 좌표가 동일한 해시 값으로 매핑되는 해시 충돌(hash collision)이 발생할 수 있으며, 이를 처리하기 위한 추가적인 비용이 발생한다. 둘째, 해시 함수는 입력 좌표를 의사 난수처럼 흩어버리기 때문에 공간적 지역성을 보존하지 못한다. 따라서 특정 복셀의 이웃을 찾는 작업이나 영역을 순차적으로 접근하는 작업의 성능이 저하될 수 있다. 반면, VDB는 계층적 트리 구조를 통해 공간적 지역성을 자연스럽게 보존하므로 이러한 작업에 강점을 가진다.</li>
<li><strong>정적/매니폴드 토폴로지 구조:</strong> 많은 전통적인 희소 자료 구조들은 데이터의 토폴로지가 시뮬레이션 중에 변하지 않는 정적(static) 상황을 가정하거나, 데이터가 얇은 2D 표면(manifold) 형태라고 가정하고 이에 최적화되어 있다. VDB의 가장 큰 장점 중 하나는 이러한 토폴로지 제약이 전혀 없다는 것이다.2 부피를 가진 구름, 복잡하게 얽히고 위상이 변하는 유체 시뮬레이션, 여러 개의 독립된 객체 등 임의의 복잡한 토폴로지를 가진 데이터도 아무런 제약 없이 효율적으로 표현하고 동적으로 수정할 수 있다.</li>
</ul>
<h3>Table 1: 주요 볼류메트릭 자료 구조 비교 분석</h3>
<p>다음 표는 VDB와 다른 주요 볼류메트릭 자료 구조들의 핵심 특성을 요약하여 비교한 것이다.</p>
<table><thead><tr><th>특성 (Attribute)</th><th>밀집 그리드 (Dense Grid)</th><th>옥트리 (Octree)</th><th>VDB (Volumetric Dynamic B+tree)</th><th>해싱 그리드 (Hashing Grid)</th></tr></thead><tbody>
<tr><td><strong>핵심 아이디어</strong></td><td>3차원 배열</td><td>공간의 재귀적 8분할</td><td>넓고 얕은 B+tree 유사 구조</td><td>공간 좌표의 해시 매핑</td></tr>
<tr><td><strong>메모리 사용량</strong></td><td>매우 높음 (O(N3)) 7</td><td>희소성에 비례 (중간)</td><td>희소성에 비례 (낮음, 압축 효율 높음) 8</td><td>희소성에 비례 (매우 낮음)</td></tr>
<tr><td><strong>랜덤 접근 속도</strong></td><td>O(1)</td><td>O(logN)15</td><td>평균 O(1) 2</td><td>평균 O(1), 최악의 경우 충돌 처리 비용</td></tr>
<tr><td><strong>순차/이웃 접근</strong></td><td>매우 빠름 (최적)</td><td>보통 (포인터 추적 필요)</td><td>매우 빠름 (캐시 효율적) 10</td><td>느림 (지역성 보장 안됨)</td></tr>
<tr><td><strong>동적 업데이트</strong></td><td>비효율적</td><td>보통 (트리 재구성 필요 가능)</td><td>매우 효율적 (평균 O(1)) 4</td><td>매우 효율적</td></tr>
<tr><td><strong>주요 응용 분야</strong></td><td>저해상도, 밀집 데이터</td><td>공간 분할, 충돌 감지</td><td>VFX, 시뮬레이션, 렌더링, 로보틱스 4</td><td>실시간 3D 스캐닝, 동적 재구성</td></tr>
</tbody></table>
<h2>제 6부: 응용 분야 및 미래 방향성</h2>
<p>VDB는 그 뛰어난 성능과 유연성을 바탕으로 초기 개발 목적인 시각 효과 분야를 넘어 다양한 첨단 기술 분야에서 핵심적인 역할을 수행하고 있다. 또한, 컴퓨팅 환경의 변화에 발맞춰 끊임없이 진화하고 있다.</p>
<h3>6.1. 시각 효과(VFX)에서 과학 컴퓨팅까지</h3>
<ul>
<li><strong>VFX 및 애니메이션:</strong> VDB는 영화 및 애니메이션 산업에서 연기, 불, 폭발, 구름, 물과 같은 유체 시뮬레이션 결과를 저장하고 렌더링하는 데 있어 사실상의 산업 표준(de facto standard)으로 자리 잡았다.3 또한 레벨셋(level set) 기법과 결합하여 복잡한 유기체나 액체 표면을 모델링하고 조작하는 데에도 널리 사용된다.</li>
<li><strong>로보틱스 및 3D 재구성:</strong> 로봇이 센서(LiDAR, Depth Camera 등) 데이터를 통합하여 주변 환경에 대한 3D 지도를 실시간으로 구축하는 SLAM(Simultaneous Localization and Mapping) 및 3D 재구성 분야에서 VDB의 활용이 급증하고 있다. VDBFusion, VDB-EDT, VDB-GPDF와 같은 프레임워크들은 VDB를 기반으로 대규모 환경에서도 확장성을 유지하면서 효율적인 맵 업데이트와 쿼리를 수행한다.4 VDB의 사실상 무한한 공간 표현 능력과 빠른 동적 업데이트 성능은 터널이나 동굴과 같은 넓고 복잡한 환경을 매핑하는 데 특히 유용하다.4</li>
<li><strong>과학 및 의료 컴퓨팅:</strong> 대규모 물리 시뮬레이션(예: 천체물리학, 기상학)에서 생성되는 방대한 양의 희소 데이터를 효율적으로 저장하고 시각화하는 데 사용된다. 의료 영상 분야에서는 CT나 MRI 스캔 데이터와 같은 3D 볼륨 데이터를 다루고 분석하는 데 적용될 수 있다. 또한, 공학 설계 분야에서는 위상 최적화(Topology Optimization) 과정에서 복잡한 3차원 구조를 표현하고 점진적으로 수정해 나가는 데 VDB가 활용되어 계산 비용과 메모리 사용량을 크게 줄이는 데 기여하고 있다.4</li>
</ul>
<h3>6.2. 한계점과 현대적 확장</h3>
<p>VDB는 매우 성공적인 자료 구조이지만, 근본적인 한계 또한 존재한다. 이러한 한계를 극복하기 위해 VDB 생태계는 새로운 기술과 결합하며 진화하고 있다.</p>
<ul>
<li><strong>근본적 한계:</strong>
<ul>
<li><strong>무손실 압축의 한계:</strong> VDB는 기본적으로 무손실(lossless) 자료 구조이다. 이는 데이터의 정보 손실이 없다는 장점이 있지만, 데이터의 복잡도가 매우 높거나 조밀해지면 메모리 사용량이 선형적으로 증가하는 한계를 가진다. 예를 들어, 렌더링 업계에서 벤치마크로 사용되는 디즈니의 ‘Cloud’ 데이터셋은 16비트 양자화와 전통적인 압축을 적용했음에도 VDB 파일 크기가 1.5GB에 달한다.5</li>
<li><strong>GPU 지원의 부재 (기본 OpenVDB):</strong> 원래 OpenVDB는 멀티코어 CPU 환경에 최적화되어 설계되었다. GPU의 대규모 병렬 처리 능력을 직접적으로, 그리고 최대한 효율적으로 활용하는 데에는 구조적인 한계가 있다. GPU에서 VDB 데이터에 접근하기 위해서는 데이터를 GPU 메모리로 복사하고 CPU와 유사한 방식으로 트리를 순회해야 하므로, GPU 아키텍처의 잠재력을 완전히 이끌어내기 어렵다.17</li>
</ul>
</li>
<li><strong>현대적 확장:</strong>
<ul>
<li><strong>GPU 네이티브 구현 (NanoVDB):</strong> 이러한 GPU 지원의 한계를 극복하기 위해 NVIDIA에서 개발한 것이 NanoVDB이다. NanoVDB는 OpenVDB의 모든 기능을 포함하는 대신, GPU에서의 읽기 전용(read-only) 접근, 특히 레이 트레이싱과 같은 대규모 병렬 광선-볼륨 교차 판정에 필요한 핵심 기능만을 추출하여 GPU 아키텍처에 맞게 재설계한 경량 버전이다.17 선형 메모리 레이아웃과 포인터가 없는 구조를 통해 GPU의 수천 개 코어가 VDB 데이터에 매우 효율적으로 동시 접근할 수 있도록 하여, 렌더링과 같은 작업에서 엄청난 성능 향상을 제공한다.</li>
<li><strong>신경망 결합 압축 (NeuralVDB):</strong> VDB의 무손실 압축 한계를 극복하기 위한 혁신적인 시도로, VDB와 신경망(Neural Network)을 결합한 하이브리드 자료 구조이다.5 NeuralVDB의 핵심 아이디어는, VDB 트리의 하위 노드(주로 리프 노드 또는 그 바로 위 내부 노드)를 작고 효율적인 신경망으로 대체하는 것이다. 이 신경망은 해당 노드가 담당하는 공간 영역의 토폴로지(어떤 복셀이 활성 상태인지)와 데이터 값(활성 복셀의 실제 값)을 ’학습’하여 암시적(implicit)으로 표현한다. 이를 통해 기존 VDB 대비 수십 배에서 수백 배에 달하는 극적인 데이터 압축률을 달성할 수 있다. 중요한 점은, VDB의 상위 계층 구조는 그대로 유지하여 기존 VDB 파이프라인과의 호환성을 높이고, 빠른 공간 탐색 능력이라는 VDB의 장점을 보존한다는 것이다.5</li>
</ul>
</li>
</ul>
<p>이러한 VDB의 진화 방향은 현대 컴퓨팅의 두 가지 거대한 기술적 흐름을 명확히 따르고 있다. 첫째는 <strong>하드웨어 아키텍처의 변화</strong>이다. 컴퓨팅의 중심이 멀티코어 CPU에서 대규모 병렬 처리가 가능한 GPU로 이동함에 따라, VDB의 핵심 철학은 유지하되 구현을 GPU에 맞게 재설계한 NanoVDB가 등장했다. 둘째는 <strong>데이터 표현 패러다임의 변화</strong>이다. 데이터 표현 방식이 모든 값을 명시적으로 저장하는 방식(explicit storage)에서, 함수나 신경망을 통해 연속적인 공간을 표현하는 암시적 표현(implicit representation)으로 변화하고 있다. NeuralVDB는 이 두 세계를 영리하게 결합한 시도이다. VDB의 효율적인 희소 공간 분할 능력과 신경망의 강력한 데이터 압축 및 표현 능력을 결합함으로써, 두 방식의 장점을 모두 취하는 하이브리드 접근법을 제시한다. 따라서 VDB의 미래는 단일 구조의 점진적 개선을 넘어, 새로운 하드웨어와 데이터 표현 패러다임을 적극적으로 수용하는 ’하이브리드 자료 구조’로 진화하고 있으며, 이는 VDB가 여전히 살아있는 생태계임을 보여준다.</p>
<h2>결론</h2>
<p>VDB(Volumetric Dynamic B+tree)는 넓고 얕은 B+tree 유사 구조, 토폴로지와 데이터의 근본적인 분리, 그리고 현대 CPU 캐시 아키텍처에 최적화된 설계를 통해, 희소 볼류메트릭 데이터를 다루는 데 있어 세 가지 핵심적인 난제를 동시에 해결한 혁신적인 자료 구조이다. 첫째, <strong>뛰어난 메모리 효율성</strong>을 통해 고해상도 데이터도 실용적인 메모리 공간 내에서 처리할 수 있게 했으며, 둘째, 경로 캐싱과 직접 좌표 해싱을 통해 <strong>평균 <span class="math math-display">O(1)</span>의 빠른 랜덤 및 순차 접근 속도</strong>를 달성했다. 셋째, 복잡한 분할/병합 로직 없이 <strong>유연하고 효율적인 동적 토폴로지 지원</strong>을 가능하게 했다.</p>
<p>시각 효과(VFX) 산업의 특정 문제를 해결하기 위해 탄생했지만, VDB의 설계 철학이 가진 근본적인 우수성은 그 적용 범위를 로보틱스, 과학 컴퓨팅, 의료 영상 등 희소 고차원 데이터를 다루는 거의 모든 분야로 확장시켰고, 오늘날 이들 분야에서 표준적인 핵심 도구 중 하나로 자리매김했다.</p>
<p>더 나아가, NanoVDB와 NeuralVDB의 등장은 VDB가 과거의 유산에 머물러 있는 정적인 기술이 아니라, 컴퓨팅 환경의 급격한 변화에 발맞춰 끊임없이 진화하는 살아있는 생태계임을 명확히 보여준다. GPU 컴퓨팅의 부상과 인공지능 기반의 새로운 데이터 표현 패러다임이라는 거대한 흐름과 적극적으로 융합함으로써, VDB는 미래에도 더욱 방대하고 복잡해질 가상 세계를 시뮬레이션하고, 분석하며, 시각화하는 데 있어 핵심적인 역할을 계속해서 수행할 것으로 전망된다. VDB는 앞으로도 데이터 구조 설계가 어떻게 특정 도메인의 문제를 해결하고, 나아가 기술의 발전을 선도할 수 있는지를 보여주는 탁월한 사례로 남을 것이다.</p>
<h2>5. 참고자료</h2>
<ol>
<li>Frequently Asked Questions - OpenVDB, accessed August 5, 2025, https://www.openvdb.org/documentation/doxygen/faq.html</li>
<li>VDB: High-resolution sparse volumes with dynamic topology - Ken Museth, accessed August 5, 2025, https://www.museth.org/Ken/Publications_files/Museth_TOG13.pdf</li>
<li>OpenVDB 11.0 Updates | LightWave, accessed August 5, 2025, https://docs.lightwave3d.com/2025/openvdb-11-0-updates.html</li>
<li>VDB: High-Resolution Sparse Volumes with Dynamic Topology - ResearchGate, accessed August 5, 2025, https://www.researchgate.net/publication/259288658_VDB_High-Resolution_Sparse_Volumes_with_Dynamic_Topology</li>
<li>NeuralVDB: High-resolution Sparse Volume Representation using Hierarchical Neural Networks - Research at NVIDIA, accessed August 5, 2025, https://research.nvidia.com/labs/prl/neuralvdb/neuralvdb2024.pdf</li>
<li>A Comprehensive Survey on Vector Database: Storage and Retrieval Technique, Challenge, accessed August 5, 2025, https://arxiv.org/html/2310.11703v2</li>
<li>Feature-Based 3D Level Set Morphing - Department of Computer Science, accessed August 5, 2025, https://www.cs.drexel.edu/~david/Papers/rcampos_thesis.pdf</li>
<li>OpenVDB Overview, accessed August 5, 2025, https://www.openvdb.org/documentation/doxygen/overview.html</li>
<li>Hierarchical, Dense and Dynamic 3D Reconstruction … - Frontiers, accessed August 5, 2025, https://www.frontiersin.org/journals/robotics-and-ai/articles/10.3389/frobt.2020.600387/full</li>
<li>SPGrid: A Sparse Paged Grid structure applied to adaptive smoke simulation - cs.wisc.edu, accessed August 5, 2025, https://pages.cs.wisc.edu/~sifakis/papers/SPGrid.pdf</li>
<li>Real-time voxel visualization and editing for 3D printing, accessed August 5, 2025, https://dspace.cuni.cz/bitstream/handle/20.500.11956/148776/120397271.pdf?sequence=1&amp;isAllowed=y</li>
<li>Insight: VDB, a deep dive - JangaFX, accessed August 5, 2025, https://jangafx.com/insights/vdb-a-deep-dive</li>
<li>OpenVDB Cookbook, accessed August 5, 2025, https://www.openvdb.org/documentation/doxygen/codeExamples.html</li>
<li>VDB-GPDF: Online Gaussian Process Distance Field with VDB Structure - arXiv, accessed August 5, 2025, https://arxiv.org/html/2407.09649v1</li>
<li>Represent an octree as a binary tree of thrice the depth?, accessed August 5, 2025, https://cs.stackexchange.com/questions/41898/represent-an-octree-as-a-binary-tree-of-thrice-the-depth</li>
<li>(a) Optimized topology of the obtained using VDB-LSTO using 34 million… - ResearchGate, accessed August 5, 2025, https://www.researchgate.net/figure/a-Optimized-topology-of-the-obtained-using-VDB-LSTO-using-34-million-elements-b_fig13_337908686</li>
<li>ACM SIGGRAPH 2021 Talks, accessed August 5, 2025, https://www.siggraph.org/wp-content/uploads/2021/08/ACM-SIGGRAPH-2021-Talks.html</li>
<li>VDBFusion: Flexible and Efficient TSDF Integration of Range Sensor Data - MDPI, accessed August 5, 2025, https://www.mdpi.com/1424-8220/22/3/1296</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>