<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:RC-Vox 구조에 대한 심층 고찰</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>RC-Vox 구조에 대한 심층 고찰</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">센서 (Sensors)</a> / <a href="../index.html">포인트 클라우드</a> / <a href="index.html">RC-Vox</a> / <span>RC-Vox 구조에 대한 심층 고찰</span></nav>
                </div>
            </header>
            <article>
                <h1>RC-Vox 구조에 대한 심층 고찰</h1>
<h2>1. 서문: LIO 시스템의 효율성 문제와 RC-Vox의 등장</h2>
<h3>1.1 LIO 시스템의 핵심 과제: 실시간성과 정확성</h3>
<p>라이다-관성 측정 장치 오도메트리(LIDAR-Inertial Odometry, LIO) 시스템은 자율주행 차량, 로보틱스, 증강 현실 등 다양한 분야에서 주변 환경을 3차원으로 인식하고 자신의 위치를 추정하는 데 필수적인 기술로 자리 잡았다.1 이 시스템의 핵심 성능 지표는 정확성(accuracy), 강건성(robustness), 그리고 효율성(efficiency)의 세 가지로 요약될 수 있다.2 특히, 로봇이 실시간으로 주변 환경과 상호작용하고 경로를 계획하기 위해서는, 센서 데이터를 지연 없이 처리하는 효율성이 무엇보다 중요하다. 그러나 LIO 시스템의 파이프라인, 특히 지속적으로 업데이트되는 3D 맵을 관리하는 모듈은 상당한 계산 부하를 유발하며, 이는 전체 시스템의 실시간 성능을 저해하는 주요 병목 지점(bottleneck)으로 작용한다.2</p>
<h3>1.2 맵 관리의 병목 현상: 기존 공간 자료 구조의 한계</h3>
<p>전통적인 LIO 시스템은 맵 관리를 위해 주로 kd-tree나 해시(hash) 기반 복셀(voxel)과 같은 공간 자료 구조에 의존해왔다. 이러한 구조들은 대규모 포인트 클라우드 데이터를 효율적으로 저장하고 검색하기 위해 고안되었지만, LIO의 특수한 요구사항, 즉 빈번한 동적 업데이트와 빠른 이웃 탐색이라는 과제 앞에서 명확한 한계를 드러낸다.</p>
<p>첫째, <strong>kd-tree</strong> 구조는 특정 지점의 k-최근접 이웃(k-Nearest Neighbor, k-NN)을 빠르게 찾는 데 강점을 보인다.3 FAST-LIO2 시스템에서 사용된 <strong>ikd-Tree</strong>는 이러한 kd-tree를 동적으로 업데이트할 수 있도록 개선한 버전으로, 새로운 포인트가 추가되거나 오래된 포인트가 삭제될 때 전체 트리를 재구성하는 대신 부분적인 수정만을 수행하여 맵 업데이트 시간을 크게 단축시켰다.2 그럼에도 불구하고, 트리의 특정 부분에서 삽입 및 삭제가 빈번하게 발생하여 트리가 불균형해지면, 균형을 맞추기 위한 부분적인 재구성 작업이 여전히 필요하며 이는 계산 비용을 유발한다.3</p>
<p>둘째, <strong>해시 기반 복셀</strong> 구조는 kd-tree에 비해 맵의 삽입, 삭제, 쿼리 연산에서 더 낮은 시간 복잡도를 가진다.2 Faster-LIO 시스템에서 제안된 <strong>iVox</strong>는 해시 테이블과 LRU(Least Recently Used) 캐시 정책을 결합하여 복셀 맵을 관리한다.2 이 구조는 병렬 처리를 통해 ikd-Tree의 성능을 능가하는 효율성을 보여주었으나, 근본적인 한계를 내포하고 있다. 해시 구조는 해시 함수 자체의 계산에 따르는 오버헤드와 서로 다른 키가 동일한 해시 값으로 매핑되는 해시 충돌(hash collision) 문제를 피할 수 없다. 이러한 문제들로 인해 해시 테이블은 이론적으로 가장 빠른 접근 속도인 O(1)을 보장하는 <strong>배열(array)</strong> 구조만큼의 순수한 속도를 달성하기 어렵다.2</p>
<h3>1.3 RC-Vox의 제안: 패러다임의 전환</h3>
<p>이러한 기존 자료 구조들의 한계를 극복하기 위해, FR-LIO 시스템의 일부로 **RC-Vox (Robocentric Voxel Map)**라는 새로운 맵 관리 구조가 제안되었다.1 RC-Vox의 핵심은 기존 접근법들이 확장 가능한 전역 맵(global map)을 효율적으로 관리하는 방법에 초점을 맞춘 것과 달리, 문제 자체를 ’LIO 프론트엔드 오도메트리에 필요한 지역 맵(local map)을 어떻게 가장 빠르게 처리할 것인가’로 재정의한 데 있다. LIO 시스템의 실시간 성능은 상태 추정 단계의 속도에 크게 좌우되며, 이 과정은 본질적으로 현재 라이다 스캔과 주변 맵 사이의 대응점을 찾는 k-NN 탐색에 의존한다.2 RC-Vox 개발자들은 오도메트리가 ‘로컬’ 작업이라는 본질에 착안하여, 전역 맵의 무한한 확장성을 과감히 포기하는 대신 로컬 맵의 접근 속도를 극한으로 끌어올리는 방향을 선택했다.</p>
<p>이를 위해 RC-Vox는 그동안 대규모 포인트 클라우드 표현에 있어 막대한 메모리 소비 문제(<span class="math math-inline">O(N^3)</span>) 때문에 기피되어 온 <strong>배열 구조</strong>를 과감하게 채택했다.2 이는 로봇을 중심으로 한 고정된 크기의 지역 맵만을 유지하는 ‘로보센트릭(robocentric)’ 접근 방식을 통해 가능해졌다. 즉, RC-Vox는 가장 적합한 도구를 선택한 것을 넘어, 문제 자체를 도구(배열)에 맞게 재구성한 혁신적인 발상이라 할 수 있다. 본 안내서는 이 RC-Vox의 개념적 기반, 아키텍처, 작동 메커니즘, 그리고 성능을 심층적으로 고찰하고자 한다.</p>
<h2>2.  RC-Vox의 개념적 기반과 설계 철학</h2>
<h3>2.1 RC-Vox의 정의: 로봇 중심 복셀 맵</h3>
<p>RC-Vox는 이름에서 알 수 있듯이 <strong>로봇을 중심으로(robocentric)</strong> 하는 복셀 맵 구조이다. 보다 구체적으로, RC-Vox는 로봇의 현재 위치를 기준으로 하는 고정된 크기의 정육면체(cube) 형태의 가상 공간 내에서 지역 맵 포인트(local map points)를 유지하고 관리하는 역할을 한다.1 이 큐브의 한 변의 길이는 일반적으로 라이다 센서의 유효 측정 범위(예: 150m)의 두 배로 설정된다. 이는 로봇이 어떤 방향으로든 이동하더라도, 포인트 클라우드 정합(registration)을 수행하는 데 필요한 주변 맵 정보를 충분히 확보하기 위함이다.2</p>
<p>중요한 점은 RC-Vox 내에 저장되는 모든 포인트의 좌표 자체는 전역 좌표계(global coordinate system)를 기준으로 표현된다는 것이다.2 그러나 이 포인트들의 관리, 즉 저장, 검색, 삭제는 오직 로봇 중심의 지역 맵 내에서만 이루어진다. 이는 전역 맵 전체를 메모리에 상주시키거나 디스크에서 불러오는 대신, 현재 위치 추정에 직접적으로 필요한 데이터만을 효율적으로 다루겠다는 설계 철학을 반영한다.</p>
<h3>2.2 설계 철학: 속도를 위한 트레이드오프</h3>
<p>RC-Vox의 가장 근본적인 설계 철학은 <strong>속도를 위해 확장성을 희생하는 트레이드오프</strong>에 있다. 이를 구현하기 위한 핵심 선택은 포인터 기반의 트리 구조(kd-tree)나 해시 테이블 대신, 직접 주소 지정(direct addressing)이 가능한 <strong>고정 크기 3D 배열</strong>을 기본 자료 구조로 채택한 것이다.2</p>
<p>이 선택은 시간 복잡도와 공간 복잡도 사이의 고전적인 트레이드오프를 명확히 보여준다.</p>
<ul>
<li><strong>시간 복잡도:</strong> 배열은 인덱스를 통한 원소 접근(access)이 <span class="math math-inline">O(1)</span>의 시간 복잡도를 가지므로 이론적으로 가장 빠른 데이터 접근 속도를 제공한다.10 이는 포인터를 따라 여러 노드를 순회해야 하는 트리 구조(<span class="math math-inline">O(\log N)</span>)나 해시 충돌 해결 과정이 필요한 해시 테이블과 근본적인 차이를 만든다.</li>
<li><strong>공간 복잡도:</strong> 반면, <span class="math math-inline">D \times D \times D</span> 크기의 공간을 표현하기 위해 배열은 <span class="math math-inline">O(D^3)</span>의 메모리를 필요로 한다.2 탐사 영역이 수백 미터에 달하는 실외 환경에서 전역 맵을 단일 배열로 표현하는 것은 메모리 관점에서 비현실적이다.</li>
</ul>
<p>RC-Vox는 이 문제를 로봇 주변의 ’지역 맵’으로 범위를 한정함으로써 해결한다. 관리해야 할 공간의 크기가 고정되므로, 배열의 메모리 요구량이 예측 가능하고 감당할 수 있는 수준으로 유지된다. 대신, LIO 시스템의 프론트엔드 성능에 가장 치명적인 영향을 미치는 데이터 접근 속도의 이점을 극대화하는 전략을 취한 것이다.</p>
<p>이러한 설계는 ’로보센트릭’이라는 개념에 이중적인 의미를 부여한다. 첫째, 공간적으로 로봇 주변의 데이터만을 다룬다는 의미이다. 둘째, 계산 복잡도 측면에서 오도메트리 연산을 전체 맵의 크기와 무관하게 <strong>상수 시간(constant time)에 가까운 성능</strong>으로 묶어두는 역할을 한다. ikd-Tree나 iVox와 같은 전역 맵 구조는 탐사 영역이 넓어질수록 데이터의 총량이 증가하고, 비록 점근적 시간 복잡도가 효율적일지라도 실제 연산 시간은 미세하게나마 증가할 수 있다. 반면, RC-Vox는 로봇이 얼마나 멀리 이동하든 오도메트리 모듈이 처리해야 할 데이터의 양과 구조의 크기가 변하지 않는다.2 결과적으로, RC-Vox 기반 시스템의 프론트엔드 성능은 전체 맵의 크기와 사실상 **분리(decoupled)**된다. 이는 장시간, 대규모 환경 탐사 시에도 일관된 실시간 성능을 보장하는 결정적인 요인이며, 단순한 최적화를 넘어 시스템 아키텍처 수준의 강건성을 확보하는 설계라 평가할 수 있다.</p>
<p>마지막으로, RC-Vox는 물리적으로는 ’정적’인 고정 크기 배열을 사용하지만, ’모듈로 연산(modulo operation)’이라는 수학적 기법을 통해 로봇의 움직임에 따라 맵 데이터를 배열 내에서 ’동적’으로 순환시켜 관리한다.2 이는 정적 구조의 속도 이점과 동적 데이터 관리의 유연성을 결합한 하이브리드 접근 방식으로, RC-Vox의 핵심 작동 원리 중 하나이다.</p>
<h2>3.  RC-Vox의 아키텍처: 2계층 3D 배열 구조 심층 분석</h2>
<h3>3.1 개요: 메모리 효율과 접근 속도의 조화</h3>
<p>RC-Vox는 배열 구조의 빠른 접근 속도를 활용하면서도, 단일 거대 배열이 가질 수 있는 메모리 비효율성과 희소 데이터(sparse data) 관리의 어려움을 완화하기 위해 독창적인 **고정 크기의 2계층 3D 배열 구조(fixed-size, two-layer 3D array structure)**를 채택했다.1 이 계층적 구조는 공간을 서로 다른 해상도로 분할하여 관리함으로써 메모리 사용과 접근 속도 사이의 균형을 맞춘다. 상위 계층은 <strong>TLA(Top-Level Array)</strong>, 하위 계층은 **BLA(Bottom-Level Array)**로 명명된다.2</p>
<p>이러한 접근 방식은 컴퓨터 그래픽스나 데이터베이스 분야에서 오랫동안 연구되어 온 ’계층적 그리드(Grid Hierarchy)’나 ’그리드 파일(Grid File)’과 개념적으로 유사하다.9 단일 플랫 그리드(Flat Grid)는 접근은 빠르지만 메모리 낭비가 심한 반면 9, RC-Vox의 TLA는 데이터 대신 포인터를 저장하여 1차적으로 공간을 분할하고, BLA는 필요한 부분에만 세부 그리드를 동적으로 할당하는 ‘적응형(adaptive)’ 그리드 전략을 사용한다. 이는 완전히 동적인 트리(Octree)나 해시 테이블과, 완전히 정적인 플랫 그리드 사이의 영리한 절충안이다. 포인터 추적이 거의 없고(TLA에서 BLA로 단 한 번), 메모리 접근 패턴이 규칙적이고 예측 가능하여 CPU 캐시 효율성(cache friendliness)이 매우 높다는 장점이 있다.9 따라서 RC-Vox는 새로운 발명이라기보다는, LIO라는 특정 도메인의 제약 조건(로컬 맵, 실시간성)에 맞춰 고전적인 자료구조를 극한으로 튜닝하고 최적화한 엔지니어링의 성과로 볼 수 있다.</p>
<h3>3.2 상위 계층: TLA (Top-Level Array)</h3>
<p>TLA는 RC-Vox 구조의 최상위 계층으로, 전체 지역 맵 공간을 거시적으로 분할하는 <strong>거친 해상도(coarse resolution)의 그리드(grid)</strong> 역할을 수행한다.2</p>
<ul>
<li><strong>역할 및 구조:</strong> TLA의 각 요소(element)는 ’그리드’라고 불린다. 이 그리드들은 실제 포인트 클라우드 데이터를 직접 저장하지 않는다. 대신, 각 그리드는 자신에게 속한 하위 계층 BLA에 대한 포인터나 인덱스를 저장하거나, 아직 포인트가 할당되지 않았음을 나타내는 널(null) 상태를 가진다. TLA의 차원은 시스템 파라미터에 의해 고정된다. 예를 들어, 라이다 유효 범위를 <span class="math math-inline">l</span>, 그리드 크기를 <span class="math math-inline">g</span>, 그리고 여유 계수를 <span class="math math-inline">\lambda</span>(<span class="math math-inline">\lambda &gt; 1</span>)라고 할 때, TLA는 <span class="math math-inline">2\lambda l \times 2\lambda l \times 2\lambda l</span> 크기의 공간을 표현하며, 각 차원은 <span class="math math-inline">2\lambda l/g</span> 개의 그리드로 구성된다.2</li>
<li><strong>특징:</strong> TLA의 해상도는 메모리 소비를 고려하여 비교적 낮게 설정된다. 예를 들어, 그리드 크기 <span class="math math-inline">g</span>는 수 미터(meter) 수준으로 설정될 수 있다.2 이는 TLA 자체가 차지하는 메모리 공간을 합리적인 수준으로 유지하기 위함이다. TLA는 공간을 균일하게 분할하는 역할을 하며, 빠른 인덱스 계산을 통해 특정 포인트가 어떤 그리드에 속하는지를 <span class="math math-inline">O(1)</span> 시간 복잡도로 즉시 알아낼 수 있게 한다.</li>
</ul>
<h3>3.3 하위 계층: BLA (Bottom-Level Array)</h3>
<p>BLA는 TLA 그리드 하나하나의 내부 공간을 미시적으로 분할하는 <strong>고해상도(fine resolution)의 복셀(voxel)</strong> 배열이다.2</p>
<ul>
<li><strong>역할 및 구조:</strong> BLA의 각 요소는 ’복셀’이라고 불리며, 실제 라이다 포인트 데이터가 저장되는 최종 컨테이너 역할을 한다. 각 BLA의 차원은 상위 그리드 크기 <span class="math math-inline">g</span>와 복셀 크기 <span class="math math-inline">v</span>에 의해 결정된다. 예를 들어, 각 차원은 <span class="math math-inline">g/v</span> 개의 복셀로 구성된다.2 복셀 크기 <span class="math math-inline">v</span>는 수십 센티미터 수준으로 설정되어, 포인트 클라우드의 세밀한 형상을 표현할 수 있다.</li>
<li><strong>동적 할당 (On-demand Allocation):</strong> RC-Vox의 메모리 효율성을 극대화하는 핵심적인 특징은 BLA의 <strong>동적 할당</strong> 방식이다. 시스템 초기에는 모든 TLA 그리드에 BLA가 할당되어 있지 않다. 특정 TLA 그리드에 속하는 라이다 포인트가 처음으로 맵에 추가될 때, 바로 그 시점에 해당 그리드에 대한 BLA가 메모리에 동적으로 생성된다.2 이 방식은 포인트 클라우드가 존재하지 않는 빈 공간(empty space)에 대해서는 메모리를 전혀 사용하지 않으므로, 맵이 전체적으로 희소(sparse)한 LIO 환경에서 메모리 사용량을 크게 절약할 수 있다.</li>
<li><strong>데이터 저장:</strong> 일단 BLA가 생성되면, 해당 그리드에 속하는 포인트들은 자신의 좌표에 따라 계산된 BLA 인덱스의 복셀 내에 저장된다. 각 복셀은 여러 개의 포인트를 담을 수 있도록 <code>std::vector</code>와 같은 동적 배열 형태로 구현된다.</li>
</ul>
<p>결론적으로, TLA는 빠른 거시적 위치 탐색을, BLA는 필요한 곳에만 할당되는 효율적인 미시적 데이터 저장을 담당함으로써, RC-Vox는 속도와 메모리 효율이라는 두 마리 토끼를 모두 잡는 정교한 아키텍처를 완성한다.</p>
<h2>4.  RC-Vox의 작동 메커니즘: 증분 매핑과 k-NN 탐색</h2>
<p>RC-Vox의 아키텍처가 ’어떻게 구성되어 있는가’를 설명한다면, 작동 메커니즘은 ’어떻게 동작하는가’에 대한 답을 제공한다. 핵심 메커니즘은 로봇의 움직임에 따라 맵을 효율적으로 업데이트하는 <strong>증분 매핑</strong>과, 포인트 클라우드 정합의 핵심인 <strong>k-NN 탐색</strong>을 가속화하는 전략으로 나뉜다.</p>
<h3>4.1 증분 매핑과 모듈로 연산</h3>
<p>RC-Vox의 증분 매핑은 고정된 크기의 배열(TLA) 위에서 무한히 넓은 공간을 탐사하는 것처럼 보이게 만드는 독창적인 기법이다. 그 핵심에는 **모듈로 연산(modulo operation)**이 있다. 이 과정은 3차원 공간에서 동작하는 환형 버퍼(Circular Buffer) 또는 링 버퍼(Ring Buffer)와 개념적으로 동일하다.</p>
<ol>
<li><strong>초기화:</strong> 시스템이 시작되면, 로봇은 가상의 TLA 공간 중앙에 위치한다고 가정한다. 이때 TLA의 원점(<span class="math math-inline">t_{init}</span>)과 지역 맵의 원점(<span class="math math-inline">m_{init}</span>)이 전역 좌표계 기준으로 정의된다.2</li>
<li><strong>좌표 계산 및 매핑:</strong> 로봇이 이동하여 현재 전역 좌표가 <span class="math math-inline">r_{curr}</span>가 되면, RC-Vox는 다음의 연산을 순차적으로 수행한다.</li>
</ol>
<ul>
<li>먼저, 로봇의 현재 위치를 기준으로 그리드에 정렬된 새로운 지역 맵의 원점 <span class="math math-inline">m_{curr}</span>을 계산한다.2</li>
<li>다음으로, 이 지역 맵 원점의 TLA 인덱스 <span class="math math-inline">IT_{m_{curr}}</span>를 <strong>모듈로(%)</strong> 연산을 사용하여 계산한다. 이 단계가 바로 무한한 전역 공간 좌표를 유한한 TLA 인덱스 공간 안으로 “감싸는(wrap-around)” 핵심적인 과정이다.2</li>
<li>새로운 라이다 포인트 <span class="math math-inline">p</span>가 입력되면, 이 포인트가 속할 TLA 인덱스 <span class="math math-inline">IT_p</span>와 BLA 인덱스 <span class="math math-inline">IB_p</span>를 순차적으로 계산하여 해당 복셀에 포인트를 저장한다. 만약 해당 TLA 그리드에 BLA가 아직 생성되지 않았다면, 이 시점에서 동적으로 할당된다.2</li>
</ul>
<ol start="3">
<li><strong>맵 업데이트 및 삭제:</strong> 로봇이 계속 이동하여 지역 맵의 경계가 TLA의 물리적 경계를 넘어서는 상황을 상상해보자. 모듈로 연산 덕분에, TLA의 한쪽 끝을 벗어난 그리드는 반대쪽 끝으로 자연스럽게 다시 나타나게 된다. 이때, 재사용되는 그리드에 저장되어 있던 기존의 오래된 포인트 정보는 초기화(reset)된다. 이 메커니즘을 통해, 로봇의 시야에서 멀어진 오래된 맵 포인트의 <strong>삭제</strong>와, 로봇이 새로 진입한 영역에 대한 맵의 <strong>증분적 건설</strong>이 별도의 복잡한 관리 로직 없이 매우 효율적으로, 사실상 자동으로 이루어진다.2</li>
</ol>
<h3>4.2 개선된 k-NN 탐색 전략</h3>
<p>k-NN 탐색은 LIO의 상태 추정 단계에서 가장 많은 계산량을 차지하는 작업 중 하나이다. 전통적으로는 쿼리 포인트가 속한 복셀과 그 주변의 26개 이웃 복셀(3x3x3 큐브)을 모두 검색하여 가장 가까운 포인트들을 찾아야 했다. RC-Vox는 이 과정의 비효율성을 개선하기 위해 **계산 부하를 전가(shifting the computational load)**하는 영리한 전략을 사용한다.</p>
<p>이 전략의 배경에는 LIO 시스템의 두 주요 단계, 즉 ’상태 추정’과 ’매핑’의 실행 빈도와 시간 민감도가 비대칭적이라는 통찰이 있다. 상태 추정(k-NN 탐색 포함)은 IMU 데이터가 들어올 때마다 수백~수천 Hz의 매우 높은 빈도로 실행되며, 지연 시간에 극도로 민감하다.5 반면, 맵 업데이트(포인트 삽입)는 라이다 스캔 주기에 맞춰 상대적으로 낮은 빈도(예: 10~20 Hz)로 실행되며 시간적 여유가 있다.</p>
<p>RC-Vox는 이 비대칭성을 이용하여 다음과 같이 동작한다:</p>
<ol>
<li><strong>매핑 단계에서의 사전 계산:</strong> 계산 부하가 덜 민감한 <strong>매핑 단계</strong>에서 라이다 포인트를 맵에 등록할 때, 단순히 해당 포인트가 속한 복셀에만 저장하는 것이 아니다. 추가적으로, 그 주변의 <strong>6, 18, 또는 26개의 이웃 복셀에도 해당 포인트의 참조(또는 복사본)를 중복으로 기록</strong>해 둔다.2 이는 약간의 추가적인 쓰기(write) 비용을 발생시키지만, 매핑 단계는 시간적 여유가 있으므로 전체 시스템 성능에 미치는 영향이 미미하다.</li>
<li><strong>탐색 단계에서의 연산 단순화:</strong> 이후, 계산 부하가 매우 민감한 <strong>상태 추정 단계</strong>에서 k-NN 탐색을 수행할 때는 더 이상 주변 복셀을 뒤질 필요가 없다. 쿼리 포인트가 속한 <strong>단 하나의 복셀만</strong> 조회하면, 그 안에는 이미 주변 영역의 포인트 정보가 모두 사전 계산되어 저장되어 있기 때문이다.2 탐색 알고리즘은 이 복셀에서 가져온 포인트 후보군 내에서 실제 거리를 계산하여 가장 가까운 k개를 선택하기만 하면 된다.</li>
</ol>
<p>결과적으로, 계산 비용이 높은 ‘주변 복셀 탐색’ 작업이 빈번하고 민감한 상태 추정 단계에서 제거되고, 대신 ’이웃 복셀에 포인트 복사’라는 추가 작업이 덜 민감하고 빈도가 낮은 매핑 단계로 옮겨진다. 이는 시스템 전체의 평균 응답 시간과 최악 응답 시간을 모두 향상시키는 효과를 가져온다. 이 기법은 전형적인 <strong>사전 계산(pre-computation) 또는 캐싱(caching)</strong> 전략을 시공간적 자료구조에 창의적으로 적용한 사례로 평가할 수 있다.</p>
<h2>5.  수학적 공식화</h2>
<p>RC-Vox의 작동 메커니즘을 명확히 이해하기 위해, 핵심 연산을 정의하는 수학적 공식을 상세히 기술한다. 모든 좌표는 전역 좌표계 기준이며, 연산은 3차원의 각 축에 대해 독립적으로 적용된다.</p>
<h3>5.1 지역 맵 원점 계산</h3>
<p>로봇의 현재 전역 좌표를 <span class="math math-inline">r_{curr} \in \mathbb{R}^3</span>, 시스템 초기화 시 정의된 TLA 원점의 전역 좌표를 <span class="math math-inline">t_{init} \in \mathbb{R}^3</span>라 하자. TLA 그리드의 크기가 <span class="math math-inline">g</span>일 때, 로봇의 현재 위치에 정렬된 지역 맵의 원점 <span class="math math-inline">m_{curr} \in \mathbb{R}^3</span>는 다음과 같이 계산된다.2<br />
<span class="math math-display">
m_{curr} = \lfloor (r_{curr} - t_{init}) / g \rfloor \cdot g + t_{init}
</span><br />
여기서 <span class="math math-inline">\lfloor \cdot \rfloor</span>는 각 요소에 대한 floor 연산(버림)을 의미한다. 이 식은 로봇의 위치를 가장 가까운 그리드 경계로 “스냅(snap)“하여 지역 맵의 기준점을 설정하는 역할을 한다.</p>
<h3>5.2 TLA 인덱스 계산</h3>
<p>전역 좌표 <span class="math math-inline">p \in \mathbb{R}^3</span>를 가진 포인트가 매핑될 TLA의 3차원 인덱스 <span class="math math-inline">IT_p \in \mathbb{Z}^3</span>를 계산하는 과정은 두 단계로 이루어진다. 먼저, 현재 지역 맵 원점의 TLA 인덱스 <span class="math math-inline">IT_{m_{curr}}</span>를 계산한다.<br />
<span class="math math-display">
IT_{m_{curr}} = \lfloor (r_{curr} - t_{init}) / g \rfloor \% N_{TLA}
</span><br />
여기서 <span class="math math-inline">N_{TLA}</span>는 TLA의 한 축에 대한 그리드의 개수(예: <span class="math math-inline">2\lambda l / g</span>)이고, <code>%</code>는 정수 나눗셈의 나머지, 즉 모듈로 연산을 의미한다. 그 다음, 포인트 <span class="math math-inline">p</span>의 최종 TLA 인덱스 <span class="math math-inline">IT_p</span>는 다음과 같이 계산된다.2<br />
<span class="math math-display">
IT_p = (\lfloor (p - m_{curr}) / g \rfloor + IT_{m_{curr}}) \% N_{TLA}
</span><br />
이 두 공식은 전역 좌표계 상의 무한한 공간을 TLA라는 유한하고 순환적인 인덱스 공간으로 변환하는 RC-Vox의 핵심적인 변환 과정이다.</p>
<h3>5.3 BLA 인덱스 계산</h3>
<p>포인트 <span class="math math-inline">p</span>가 속한 TLA 그리드에 대해 BLA가 생성될 때, 해당 BLA의 원점 좌표 <span class="math math-inline">bor_i \in \mathbb{R}^3</span>는 다음과 같이 먼저 결정된다.2<br />
<span class="math math-display">
bor_i = \lfloor (p - t_{init}) / g \rfloor \cdot g + t_{init}
</span><br />
이 BLA 원점 <span class="math math-inline">bor_i</span>를 기준으로, BLA 복셀의 크기가 <span class="math math-inline">v</span>일 때, 포인트 <span class="math math-inline">p</span>가 매핑될 BLA의 3차원 인덱스 <span class="math math-inline">IB_p \in \mathbb{Z}^3</span>는 다음과 같이 계산된다.2<br />
<span class="math math-display">
IB_p = \lfloor (p - bor_i) / v \rfloor
</span><br />
이 식은 TLA 그리드라는 거시적 공간 내에서 포인트의 미시적 위치를 복셀 단위로 정확하게 특정하는 역할을 수행한다.</p>
<h2>6.  성능 분석 및 비교 벤치마킹</h2>
<p>RC-Vox의 설계가 이론적으로 우수하다는 점을 넘어, 실제 LIO 시스템에서 얼마나 효과적인지를 정량적으로 평가하는 것은 매우 중요하다. FR-LIO 논문에서 제시된 실험 결과는 RC-Vox가 기존의 대표적인 맵 관리 자료구조인 ikd-Tree와 iVox에 비해 상당한 성능 우위를 가짐을 명확히 보여준다.2</p>
<p>아래 표는 M2DGR 데이터셋을 사용하여 LIO 시스템의 주요 모듈별 평균 연산 시간을 비교한 것이다. 이 표는 RC-Vox의 성능 우위를 직관적으로 보여주는 핵심적인 증거이다. 단순히 ’빠르다’는 주장을 넘어, 어떤 연산에서, 얼마나 빠른지를 구체적인 수치로 증명한다. 특히 RC-Vox가 단일 스레드(Single)로 동작함에도 불구하고 병렬 처리(Paral)된 경쟁자보다 빠르다는 점은 그 설계의 근본적인 효율성을 입증한다.</p>
<p><strong>Table 1: 주요 맵 관리 자료구조의 연산 시간 비교 (M2DGR 데이터셋 기준)</strong></p>
<table><thead><tr><th>모듈 (Module)</th><th>ikd-Tree (Single) [ms]</th><th>iVox (Paral) [ms]</th><th><strong>RC-Vox (Single) [ms]</strong></th></tr></thead><tbody>
<tr><td>증분 매핑 (Incremental Mapping)</td><td>~6.0</td><td>~1.5</td><td><strong>~1.6</strong></td></tr>
<tr><td>맵 삭제 (Map Delete)</td><td>~1.0</td><td>~0.1</td><td><strong>~0.1</strong></td></tr>
<tr><td>상태 추정 (State Estimation)</td><td>~10.0</td><td>~4.0</td><td><strong>~2.5</strong></td></tr>
<tr><td><strong>총합 (Total)</strong></td><td><strong>~17.0</strong></td><td><strong>~5.6</strong></td><td><strong>~4.2</strong></td></tr>
</tbody></table>
<p>주: 위 표의 수치는 FR-LIO 논문8에 제시된 그래프를 기반으로 한 근사치이며, 시스템의 주요 연산 시간을 나타낸다.</p>
<h3>6.1 결과 분석</h3>
<p>표의 데이터를 통해 각 모듈별 성능을 심층적으로 분석할 수 있다.</p>
<ul>
<li>
<p><strong>상태 추정 단계의 압도적 우위:</strong> 가장 주목할 만한 부분은 <strong>상태 추정</strong> 단계에서의 성능이다. RC-Vox(Single)는 약 2.5ms를 소요하여, 병렬 처리된 iVox(Paral)의 약 4.0ms보다 약 37.5% 더 빠르며, 단일 스레드 ikd-Tree(Single)의 약 10.0ms에 비해서는 4배나 빠르다. 이는 앞서 설명한 <strong>개선된 k-NN 탐색 전략</strong>이 결정적인 역할을 했음을 증명한다. 계산 부하가 가장 큰 주변 복셀 탐색 과정을 매핑 단계로 이전함으로써, 실시간성이 가장 중요한 상태 추정 단계의 연산량을 극적으로 줄인 것이다.2 또한, 포인터 추적이나 해시 충돌 처리 없이 인덱스로 직접 접근하는 배열 구조의 본질적인 속도 이점이 이 단계에서 가장 크게 발휘된다.</p>
</li>
<li>
<p><strong>매핑 및 삭제 단계의 경쟁력:</strong> <strong>증분 매핑</strong> 단계에서 RC-Vox는 이웃 복셀에 데이터를 중복으로 기록하는 추가적인 오버헤드가 있음에도 불구하고, 병렬 처리된 iVox와 거의 동등한 성능(약 1.5ms vs 1.6ms)을 보인다. 이는 배열 구조의 빠른 쓰기(write) 접근 속도가 추가적인 작업을 상쇄할 만큼 효율적이라는 것을 의미한다.8</p>
</li>
</ul>
<p><strong>맵 삭제</strong> 단계에서는 RC-Vox와 iVox 모두 매우 빠른 성능을 보여주는데, 이는 RC-Vox의 경우 단순히 배열의 특정 영역을 초기화하는 작업에 해당하기 때문이다. 반면, ikd-Tree는 노드 삭제와 트리 재조정에 상대적으로 많은 시간을 소요한다.</p>
<ul>
<li><strong>종합 성능:</strong> 결과적으로 RC-Vox는 <strong>단일 스레드 환경</strong>에서도 현재 가장 빠른 LIO 시스템 중 하나인 Faster-LIO의 병렬 처리 버전보다도 빠른 총 연산 시간(약 4.2ms vs 5.6ms)을 달성했다.1 이는 RC-Vox가 LIO 시스템의 프론트엔드 효율성을 한 단계 끌어올린 혁신적인 자료구조임을 정량적으로 입증하는 결과이다.</li>
</ul>
<h2>7.  고찰 및 향후 연구 방향</h2>
<h3>7.1 RC-Vox의 기여 요약</h3>
<p>RC-Vox는 LIO 시스템, 특히 프론트엔드 오도메트리의 효율성 문제를 해결하기 위한 새로운 패러다임을 제시했다는 점에서 큰 의의를 가진다. 그 핵심 기여는 다음과 같이 요약할 수 있다.</p>
<ol>
<li><strong>고효율 맵 관리 패러다임 제시:</strong> 로봇 중심의 지역 맵 개념을 도입하여, LIO 오도메트리의 본질적인 요구사항에 집중함으로써 전역 맵 관리의 복잡성에서 벗어났다.</li>
<li><strong>배열 구조의 성공적 도입:</strong> 고정 크기 2계층 배열과 모듈로 연산을 결합하는 독창적인 방식으로, 배열 구조의 고질적인 메모리 문제를 해결하고 그 속도 이점을 LIO 시스템에 성공적으로 이식했다.2</li>
<li><strong>k-NN 탐색의 혁신적 최적화:</strong> LIO 파이프라인의 비대칭적 계산 부하를 이용하여 k-NN 탐색의 핵심 연산을 매핑 단계로 전가함으로써, 실시간성이 가장 중요한 상태 추정 단계의 속도를 극적으로 향상시켰다.2</li>
</ol>
<h3>7.2 잠재적 한계점</h3>
<p>모든 공학적 설계와 마찬가지로, RC-Vox 또한 특정 목적을 위해 다른 부분을 희생한 트레이드오프의 산물이며, 다음과 같은 잠재적 한계점을 가진다.</p>
<ul>
<li><strong>메모리 사용량:</strong> 로봇 중심의 지역 맵으로 범위를 한정했지만, TLA와 BLA의 해상도(<span class="math math-inline">g</span>, <span class="math math-inline">v</span>)를 높여 맵의 정밀도를 올리려고 하면 메모리 요구량이 3차 함수($O(D^3)`) 형태로 급격히 증가하는 근본적인 트레이드오프는 여전히 존재한다.2</li>
<li><strong>고정 해상도의 한계:</strong> RC-Vox는 모든 공간을 동일한 크기의 복셀로 분할한다. 이는 환경의 기하학적 복잡도에 따라 해상도를 동적으로 조절하는 Octree와 같은 적응형 구조에 비해 표현의 유연성이 떨어질 수 있다. 예를 들어, 거대한 평면과 복잡한 형상의 물체가 혼재된 환경에서 비효율적인 메모리 사용을 유발할 수 있다.</li>
<li><strong>하이퍼파라미터 민감성:</strong> 시스템 성능은 라이다 유효 범위(<span class="math math-inline">l</span>), 그리드 크기(<span class="math math-inline">g</span>), 복셀 크기(<span class="math math-inline">v</span>) 등 여러 하이퍼파라미터의 설정에 민감하게 반응할 수 있다. 예를 들어, Faster-LIO의 iVox가 복셀 크기에 민감하다는 점은 RC-Vox에도 유사하게 적용될 수 있다.6 따라서 다양한 환경에 대해 최적의 파라미터를 찾는 튜닝 과정이 중요할 수 있다.</li>
</ul>
<h3>7.3 향후 연구 방향</h3>
<p>RC-Vox의 견고한 기본 구조를 바탕으로 다음과 같은 방향으로의 확장을 기대할 수 있다.</p>
<ul>
<li><strong>적응형 해상도(Adaptive Resolution) 도입:</strong> RC-Vox의 2계층 구조를 유지하면서, BLA 내부의 복셀 크기를 환경의 복잡도(예: 평탄도)에 따라 동적으로 조절하는 메커니즘을 연구할 수 있다. 평면과 같이 단순한 영역은 큰 복셀로, 객체의 경계와 같이 복잡한 영역은 작은 복셀로 표현함으로써 표현의 정밀도와 메모리 효율을 동시에 개선할 수 있다.</li>
<li><strong>GPU 가속화:</strong> RC-Vox의 규칙적이고 예측 가능한 배열 구조는 GPU의 SIMD(Single Instruction, Multiple Data) 병렬 처리에 매우 이상적인 형태이다. CUDA와 같은 기술을 활용하여 포인트의 매핑, 이웃 복셀로의 복사, k-NN 탐색을 위한 거리 계산 등의 과정을 대규모로 병렬 처리함으로써 시스템의 처리 속도를 더욱 향상시킬 수 있다.9</li>
<li><strong>다중 센서 융합으로의 확장:</strong> 현재 RC-Vox는 라이다 포인트의 3차원 좌표 정보만을 저장한다. 여기에 카메라로부터 얻은 색상(RGB)이나 딥러닝 기반의 시맨틱(semantic) 정보를 복셀에 추가적인 데이터 레이어로 저장하는 방식으로 구조를 확장할 수 있다.12 이는 단순한 위치 추정을 넘어, 환경을 더 깊이 이해하는 LiDAR-Camera 융합 SLAM 시스템의 강력한 백본(backbone)으로 RC-Vox가 활용될 수 있는 가능성을 연다.15</li>
<li><strong>동적 환경 대응:</strong> 동적 객체가 많은 환경은 LIO 시스템의 강건성을 저해하는 주요 요인이다. RC-Vox 구조 내에서 특정 복셀에 저장된 포인트들의 움직임을 추적하여 동적 객체를 탐지하고, 해당 복셀을 상태 추정 과정에서 일시적으로 비활성화하거나 별도의 동적 객체 레이어로 관리하는 메커니즘을 추가할 수 있다.18 이를 통해 동적 환경에서의 위치 추정 정확성과 맵의 일관성을 높일 수 있을 것이다.</li>
</ul>
<h2>8. 참고 자료</h2>
<ol>
<li>FR-LIO: Fast and Robust Lidar-Inertial Odometry by Tightly-Coupled Iterated Kalman Smoother and Robocentric Voxels - ResearchGate, https://www.researchgate.net/publication/368361497_FR-LIO_Fast_and_Robust_Lidar-Inertial_Odometry_by_Tightly-Coupled_Iterated_Kalman_Smoother_and_Robocentric_Voxels</li>
<li>FR-LIO: Fast and Robust Lidar-Inertial Odometry by Tightly-Coupled …, https://arxiv.org/pdf/2302.04031</li>
<li>[2302.04031] Fast and Robust Lidar-Inertial Odometry by Tightly-Coupled Iterated Kalman Smoother and Robocentric Voxels - ar5iv, https://ar5iv.labs.arxiv.org/html/2302.04031</li>
<li>LIO-GVM: an Accurate, Tightly-Coupled Lidar-Inertial Odometry with Gaussian Voxel Map, https://arxiv.org/html/2306.17436v1</li>
<li>hku-mars/FAST_LIO: A computationally efficient and robust LiDAR-inertial odometry (LIO) package - GitHub, https://github.com/hku-mars/FAST_LIO</li>
<li>Faster-LIO: Lightweight Tightly Coupled Lidar-inertial Odometry using Parallel Sparse Incremental Voxels - GitHub, https://github.com/gaoxiang12/faster-lio</li>
<li>[2302.04031] FR-LIO: Fast and Robust Lidar-Inertial Odometry by Tightly-Coupled Iterated Kalman Smoother and Robocentric Voxels - arXiv, https://arxiv.org/abs/2302.04031</li>
<li>Speed test of ikd-Tree, iVox and RC-Vox | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/Speed-test-of-ikd-Tree-iVox-and-RC-Vox_fig4_368361497</li>
<li>Fast Voxel Data Structures, https://bink.eu.org/fast-voxel-datastructures/</li>
<li>Which data structure should be used to represent voxel terrain?, https://gamedev.stackexchange.com/questions/17050/which-data-structure-should-be-used-to-represent-voxel-terrain</li>
<li>(PDF) A comparison of six voxel-based data structures for part geometry and cutter-workpiece engagement computations in multi-axis virtual milling - ResearchGate, https://www.researchgate.net/publication/384025865_A_comparison_of_six_voxel-based_data_structures_for_part_geometry_and_cutter-workpiece_engagement_computations_in_multi-axis_virtual_milling</li>
<li>Full article: LiDAR-camera fusion: dual-scale correction for vehicle multi-object detection and trajectory extraction - Taylor &amp; Francis Online, https://www.tandfonline.com/doi/full/10.1080/15472450.2024.2416164?af=R</li>
<li>SNI-SLAM: Semantic Neural Implicit SLAM | CVF Open Access, https://openaccess.thecvf.com/content/CVPR2024/papers/Zhu_SNI-SLAM_Semantic_Neural_Implicit_SLAM_CVPR_2024_paper.pdf</li>
<li>SLAM and 3D Semantic Reconstruction Based on the Fusion of Lidar and Monocular Vision, https://www.mdpi.com/1424-8220/23/3/1502</li>
<li>Gaussian-LIC2: LiDAR-Inertial-Camera Gaussian Splatting SLAM - arXiv, https://arxiv.org/html/2507.04004v1</li>
<li>SLAM and 3D Semantic Reconstruction Based on the Fusion of Lidar and Monocular Vision, https://pmc.ncbi.nlm.nih.gov/articles/PMC9920633/</li>
<li>Mergeable Probabilistic Voxel Mapping for LiDAR–Inertial–Visual Odometry - MDPI, https://www.mdpi.com/2079-9292/14/11/2142</li>
<li>ZikangYuan/dynamic_lio: [IROS 2025] A LiDAR-inertial odometry for dynamic environments, https://github.com/ZikangYuan/dynamic_lio</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>