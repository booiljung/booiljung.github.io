<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:i-Octree</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>i-Octree</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">센서 (Sensors)</a> / <a href="../index.html">포인트 클라우드</a> / <a href="index.html">Octree</a> / <span>i-Octree</span></nav>
                </div>
            </header>
            <article>
                <h1>i-Octree</h1>
<h2>1. 서론</h2>
<p>3차원 공간에 분포하는 데이터를 효율적으로 관리하고 질의하는 기술은 현대 컴퓨터 과학의 여러 분야에서 핵심적인 과제로 자리 잡았다. 컴퓨터 그래픽스, 물리 기반 시뮬레이션, 로봇 공학, 지리 정보 시스템(GIS), 가상현실 등 방대한 양의 3차원 데이터를 다루는 응용 분야에서는 데이터의 공간적 관계를 신속하게 파악하는 능력이 시스템 전체의 성능을 좌우한다.1 이러한 문제에 대한 가장 근본적이고 강력한 해결책 중 하나가 바로 공간 분할(Spatial Partitioning) 기법이며, 그중에서도 옥트리(Octree)는 3차원 공간을 위한 가장 대표적인 계층적 자료구조로 널리 활용되어 왔다.3 옥트리는 주어진 3차원 공간을 재귀적으로 8개의 균등한 부분 공간(옥턴트)으로 분할하여, 데이터의 밀도에 따라 공간을 적응적으로 세분화한다. 이 계층적 구조는 특정 영역 내의 데이터를 빠르게 찾거나, 객체 간의 충돌을 효율적으로 감지하는 등 다양한 공간 질의(Spatial Query)를 가속하는 데 탁월한 성능을 보인다.</p>
<p>전통적인 옥트리 구현은 주로 정적인(static) 환경을 가정하고 설계되었다. 3D 모델링, CAD, 또는 한 번 구축된 게임 월드와 같이 데이터의 변화가 없거나 드문 경우, 초기에 옥트리를 구축하는 비용은 전체 수명 주기 동안 얻는 검색 효율성에 의해 충분히 상쇄될 수 있었다. 그러나 기술이 발전함에 따라 데이터의 성격은 점차 동적으로 변모하였다. 특히 실시간 물리 시뮬레이션이나 인터랙티브 가상 환경에서는 객체들이 끊임없이 이동하고, 생성되며, 소멸한다. 이러한 동적 환경에서 전통적인 옥트리 구조는 심각한 한계에 부딪힌다. 객체의 위치가 변경될 때마다 영향을 받는 노드를 찾아 업데이트해야 하며, 많은 수의 객체가 동시에 움직일 경우 트리 구조의 유효성을 유지하기 위해 전체 트리를 폐기하고 새로 구축하는 ‘Trash and Rebuild’ 방식이 불가피해진다.5 이 재구축 과정은 막대한 계산 비용을 수반하며, 실시간 응용 프로그램에서 심각한 성능 저하, 즉 병목 현상을 유발하는 주된 원인이 된다.</p>
<p>이러한 동적 환경의 요구는 특히 로봇 공학 및 자율 주행 분야에서 폭발적으로 증가했다. LiDAR(Light Detection and Ranging) 센서는 초당 수십만에서 수백만 개에 이르는 3차원 포인트 클라우드 데이터를 실시간으로 생성하며, 로봇은 이 데이터를 바탕으로 주변 환경을 인식하고 자신의 위치를 추정하며 경로를 계획해야 한다(SLAM, Simultaneous Localization and Mapping).7 이러한 시나리오에서는 매 순간 쏟아지는 방대한 양의 데이터를 기존에 구축된 맵에 ‘증분적으로(incrementally)’ 통합하고, 동시에 새로운 데이터와 기존 맵 데이터 간의 연관성을 찾기 위한 ’최근접 이웃 탐색(Nearest Neighbor Search, NNS)’을 초고속으로 수행해야 하는 이중의 과제가 발생한다.8 전통적인 옥트리의 재구축 방식은 이러한 실시간 요구사항을 도저히 만족시킬 수 없었다. 이와 같은 기술적 공백과 시대적 요구에 부응하여 등장한 것이 바로 동적 환경에 최적화된 옥트리 변종인 i-Octree이다. i-Octree는 데이터의 실시간 증분 업데이트와 빠른 공간 질의라는 두 마리 토끼를 모두 잡기 위해 설계된 진보된 자료구조다. 본 안내서는 바로 이 i-Octree의 설계 철학부터 수학적 기반, 핵심 구현 알고리즘, 그리고 객관적인 성능 분석에 이르기까지, 그 기술적 본질을 심층적으로 탐구하고 고찰하는 것을 목표로 한다. 이를 통해 정적 데이터 구조의 패러다임을 넘어, 동적인 실제 세계의 데이터를 실시간으로 다루기 위한 공간 분할 기술의 진화를 조망하고자 한다.</p>
<h2>2.  옥트리의 수학적 원리 및 기본 구조</h2>
<p>옥트리는 3차원 공간을 효율적으로 표현하고 관리하기 위한 근간이 되는 자료구조로서, 그 구조와 동작 원리를 이해하는 것은 i-Octree와 같은 고급 변종을 파악하기 위한 필수적인 선행 과정이다. 본 장에서는 옥트리의 수학적 정의, 핵심 구성 요소, 그리고 기본적인 분할 메커니즘에 대해 상세히 기술한다.</p>
<h3>2.1  3차원 공간의 계층적 재귀 분할</h3>
<p>옥트리의 가장 핵심적인 개념은 ’계층적 재귀 분할’이다. 수학적으로 옥트리는 각 내부 노드(internal node)가 정확히 8개의 자식 노드(child node)를 갖는 트리 자료구조로 정의된다.3 이는 2차원 평면을 4개의 사분면(quadrant)으로 나누는 쿼드트리(Quadtree)를 3차원 공간으로 자연스럽게 확장한 개념이다.3</p>
<p>분할 과정은 루트 노드(root node)에서 시작된다. 루트 노드는 분석하고자 하는 전체 3차원 공간, 예를 들어 정육면체 형태의 경계 상자(Bounding Box)를 나타낸다. 이 공간은 공간의 중심을 지나는 세 개의 축(x, y, z)에 평행한 평면에 의해 8개의 동일한 크기의 부분 공간으로 분할된다. 이 8개의 부분 공간을 **옥턴트(Octant)**라 칭하며, 각각은 루트 노드의 8개 자식 노드에 해당한다.2 이어서 각 자식 노드는 자신이 나타내는 부분 공간에 대해 동일한 분할 규칙을 재귀적으로 적용한다. 즉, 자신의 공간을 다시 8개의 옥턴트로 나누고, 이를 위한 새로운 8개의 자식 노드를 생성한다. 이 과정은 특정 종료 조건이 충족될 때까지 반복되며, 결과적으로 데이터가 밀집된 영역은 깊은 레벨까지 세밀하게 분할되고, 데이터가 희소하거나 없는 영역은 더 이상 분할되지 않은 채 큰 노드로 남게 되는 적응적(adaptive) 공간 분할 구조를 형성한다. 이러한 계층적 표현 방식은 방대한 3차원 공간을 관리 가능한 단위로 나누어 효율적인 탐색과 연산을 가능하게 하는 옥트리의 근본적인 힘이 된다.</p>
<h3>2.2  핵심 용어 정의</h3>
<p>옥트리를 정확히 이해하기 위해 사용되는 몇 가지 핵심 용어의 정의는 다음과 같다.</p>
<ul>
<li><strong>노드 (Node)</strong>: 옥트리를 구성하는 기본 단위이다. 각 노드는 특정 3차원 공간 영역을 표현하며, 이 영역은 일반적으로 축에 정렬된 경계 상자(Axis-Aligned Bounding Box, AABB)로 정의된다.4 노드는 분할이 일어나는 내부 노드와 분할이 멈춘 단말 노드(leaf node)로 구분된다.</li>
<li><strong>옥턴트 (Octant)</strong>: 하나의 노드가 표현하는 공간을 3개의 기준 평면(x, y, z 평면에 평행)으로 분할했을 때 생성되는 8개의 하위 공간을 의미한다.5 각 옥턴트는 부모 노드의 자식 노드 하나와 일대일로 대응된다. 8개의 옥턴트는 일반적으로 ‘상단-좌측-전면(Top-Left-Front)’, ‘하단-우측-후면(Bottom-Right-Back)’ 등과 같이 위치에 따라 명명되고 인덱싱된다.</li>
<li><strong>복셀 (Voxel)</strong>: ’Volume’과 ’Pixel’의 합성어로, 옥트리 노드가 나타내는 3차원 공간의 단위 격자 또는 셀을 지칭하는 용어로 자주 사용된다.2 옥트리 문맥에서는 노드가 표현하는 정육면체 공간 자체를 의미하는 경우가 많다.</li>
</ul>
<h3>2.3  분할 프로세스와 종료 조건</h3>
<p>옥트리의 구축은 일반적으로 루트 노드에서 시작하여 아래로 내려가는 Top-down 방식으로 진행된다.4 이 재귀적인 분할 과정은 무한히 계속될 수 없으므로, 반드시 분할을 멈추는 종료 조건(Termination Condition)이 필요하다. 이 조건은 옥트리의 세밀도와 메모리 사용량 사이의 균형을 결정하는 중요한 요소이며, 응용 분야의 요구사항에 따라 다양하게 설정될 수 있다. 대표적인 종료 조건은 다음과 같다.3</p>
<ul>
<li><strong>최소 객체 수 (Minimum Object Count)</strong>: 노드가 포함하는 데이터 포인트나 객체의 수가 사전에 정의된 임계값(예: 1개 또는 10개)보다 작아지면 더 이상 분할하지 않는다. 이는 데이터가 희소한 영역의 불필요한 분할을 막아 메모리를 절약하는 가장 일반적인 조건이다.</li>
<li><strong>최소 노드 크기 (Minimum Node Size)</strong>: 노드의 경계 상자 한 변의 길이가 특정 최소값에 도달하면 분할을 중단한다. 이는 과도한 분할로 인해 발생하는 정밀도 문제를 방지하고, 매우 작은 객체 하나 때문에 트리가 무한히 깊어지는 것을 막는다.</li>
<li><strong>최대 트리 깊이 (Maximum Tree Depth)</strong>: 트리의 깊이가 미리 설정된 최대 깊이에 도달하면, 해당 노드가 여전히 많은 객체를 포함하더라도 강제로 분할을 멈춘다. 이는 트리의 전체 크기를 제어하고, 최악의 경우(모든 객체가 한 점에 모여 있는 경우 등)에 대한 성능을 보장하는 역할을 한다.</li>
</ul>
<p>이러한 조건들을 어떻게 조합하고 설정하는가는 옥트리 성능 최적화의 핵심이다. 예를 들어, 정밀한 충돌 감지가 필요한 게임 환경에서는 최소 노드 크기를 작게 설정할 수 있고, 대규모 포인트 클라우드 시각화에서는 최대 깊이를 제한하여 메모리 사용량을 조절할 수 있다. 이처럼 종료 조건의 선택은 옥트리가 특정 문제 영역에 얼마나 잘 적응하는지를 결정하는 근본적인 설계 결정 사항이다.</p>
<h3>2.4  옥트리의 종류: PR 옥트리와 MX 옥트리</h3>
<p>옥트리는 분할 기준점에 따라 크게 두 가지 유형으로 나눌 수 있다. 이는 노드가 데이터를 저장하고 공간을 분할하는 방식에 근본적인 차이를 만든다.3</p>
<ul>
<li><strong>PR (Point Region) 옥트리</strong>: 이 유형의 옥트리에서 각 내부 노드는 분할의 기준이 되는 하나의 명시적인 3차원 포인트 데이터를 저장한다. 이 포인트는 8개 자식 노드가 생성될 때 각 옥턴트의 기준 모서리 중 하나가 된다. PR 옥트리의 루트 노드는 무한한 공간을 표현할 수 있다는 장점이 있지만, 데이터 포인트의 위치에 따라 분할이 이루어지므로 불균형한 트리가 생성될 수 있다.</li>
<li><strong>MX (Matrix-based) 옥트리</strong>: MX 옥트리는 분할 지점이 노드 내에 명시적으로 저장되지 않고, 노드가 표현하는 공간의 기하학적 중심점으로 암시적으로(implicitly) 결정된다. 이는 항상 균등한 분할을 보장하며 구조가 매우 규칙적이다. 그러나 이 암시적 중심점을 정의하기 위해 루트 노드는 반드시 유한하고 경계가 명확한 공간을 표현해야 한다. 대부분의 컴퓨터 그래픽스 및 시뮬레이션 응용에서는 경계가 명확한 공간을 다루므로 MX 옥트리가 더 널리 사용된다.</li>
</ul>
<p>이러한 옥트리는 다른 공간 분할 자료구조와도 비교될 수 있다. 특히 **k-d 트리(k-d tree)**와의 차이점은 명확히 이해할 필요가 있다. k-d 트리는 각 레벨에서 하나의 차원(x, y, 또는 z)을 선택하여 해당 축에 수직인 평면으로 공간을 이진 분할한다. 반면, 옥트리는 특정 ‘점’(주로 공간의 중심)을 기준으로 세 개의 평면을 동시에 사용하여 공간을 8분할한다. 또한, k-d 트리는 항상 이진 트리(binary tree)이지만 옥트리는 8진 트리(8-ary tree)라는 구조적 차이가 있다.3 이러한 분할 방식의 차이는 각 자료구조의 성능 특성과 적합한 응용 분야를 결정하는 중요한 요인이 된다.</p>
<h2>3.  포인터리스 옥트리: 선형 옥트리와 모튼 코드</h2>
<p>전통적인 옥트리 구현은 트리 구조를 명시적으로 표현하기 위해 포인터(pointer)를 사용한다. 그러나 이러한 방식은 대규모 데이터를 처리하거나 고성능 컴퓨팅 환경으로 확장될 때 여러 가지 한계점을 드러낸다. 본 장에서는 포인터 기반 표현법의 문제점을 분석하고, 이를 극복하기 위해 등장한 포인터리스(pointerless) 표현법, 특히 선형 옥트리와 그 핵심 기술인 모튼 코드에 대해 심층적으로 다룬다.</p>
<h3>3.1  포인터 기반 표현법의 한계</h3>
<p>전통적인 옥트리 노드 구조는 일반적으로 자신이 표현하는 공간의 경계 상자 정보와 8개의 자식 노드를 가리키는 포인터 배열을 포함한다.12 이 직관적인 구조는 구현이 비교적 간단하지만 다음과 같은 근본적인 문제점을 내포한다.</p>
<ul>
<li><strong>메모리 오버헤드 (Memory Overhead)</strong>: 각 노드가 8개의 포인터를 저장해야 하므로 상당한 메모리 공간이 필요하다. 특히 64비트 시스템에서는 포인터 하나가 8바이트를 차지하므로, 자식 포인터에만 노드당 64바이트가 소요된다. 데이터가 희소하게 분포하여 대부분의 자식 포인터가 <code>NULL</code> 값을 갖는 경우에도 이 공간은 낭비된다.12 트리의 깊이가 깊어지고 노드의 수가 수백만 개에 이르면 이러한 오버헤드는 시스템 전체의 메모리 가용성을 심각하게 저해할 수 있다.</li>
<li><strong>캐시 비효율성 (Cache Inefficiency)</strong>: 현대 컴퓨터 아키텍처에서 메모리 접근 속도는 CPU 연산 속도에 비해 매우 느리다. 이를 보완하기 위해 CPU는 캐시 메모리(cache memory)를 사용하여 자주 접근하는 데이터를 임시 저장한다. 데이터가 메모리에 연속적으로 배치되어 있을 때(공간적 지역성), 캐시의 효율은 극대화된다. 그러나 포인터 기반 트리는 동적 메모리 할당으로 인해 부모 노드와 자식 노드가 메모리 상의 임의의, 서로 멀리 떨어진 위치에 할당될 가능성이 높다. 따라서 트리를 순회하는 과정에서 포인터를 따라 메모리의 여러 곳을 건너뛰며 접근해야 하므로 캐시 미스(cache miss)가 빈번하게 발생한다. 이는 CPU가 메인 메모리에서 데이터를 기다리는 시간을 증가시켜 실제 연산 성능을 크게 저하시키는 주된 원인이 된다.14</li>
</ul>
<p>이러한 한계는 옥트리를 대규모 병렬 처리 환경, 특히 GPU와 같은 아키텍처에 적용하는 것을 어렵게 만든다. GPU는 포인터를 이용한 복잡한 자료구조의 순회에 비효율적이며, 방대한 양의 데이터를 병렬로 처리하기 위해서는 데이터가 연속적인 메모리 블록에 배치되는 것이 절대적으로 유리하다.</p>
<h3>3.2  포인터리스(Pointerless) 표현법과 선형 옥트리</h3>
<p>포인터 기반 표현법의 한계를 극복하기 위해 제안된 것이 포인터리스 표현법이다. 이 접근법의 핵심 아이디어는 노드 간의 부모-자식 관계와 같은 구조적 정보를 명시적인 포인터로 저장하는 대신, 각 노드에 부여된 고유한 <strong>위치 코드(Locational Code)</strong> 또는 키(key)를 통해 암시적으로 계산하고 유도하는 것이다.12</p>
<p>이러한 포인터리스 개념을 극대화한 대표적인 구조가 바로 **선형 옥트리(Linear Octree)**이다.13 선형 옥트리는 트리의 전체 구조, 특히 중간 단계에 해당하는 내부 노드들을 명시적으로 저장하지 않는다. 대신, 데이터가 실제로 존재하는 단말 노드(leaf node)들만을 그들의 위치 코드를 기준으로 정렬하여 하나의 거대한 배열과 같은 연속적인 메모리 공간에 저장한다.10</p>
<p>이 방식은 다음과 같은 혁신적인 장점을 제공한다.</p>
<ul>
<li><strong>메모리 효율성 극대화</strong>: 내부 노드와 포인터를 전혀 저장하지 않으므로 메모리 사용량이 획기적으로 감소한다. 이는 특히 리프 노드의 수가 전체 노드 수에 비해 적은, 매우 깊고 희소한 트리의 경우에 더욱 두드러진다.14</li>
<li><strong>캐시 성능 향상 및 병렬 처리 용이성</strong>: 모든 데이터가 정렬된 상태로 배열에 연속적으로 저장되므로, 순차적 접근이나 범위 탐색 시 뛰어난 캐시 성능을 보인다. 또한, 데이터가 단일 배열 형태로 존재하므로 GPU와 같은 병렬 처리 장치로 데이터를 전송하고 처리하기에 매우 적합한 구조이다.14</li>
</ul>
<p>선형 옥트리의 효율성은 전적으로 위치 코드를 얼마나 효율적으로 생성하고, 이 코드를 통해 트리 관계를 얼마나 빠르게 계산할 수 있느냐에 달려있다. 이를 위해 가장 널리 사용되는 기술이 바로 모튼 코드이다.</p>
<h3>3.3  모튼 코드와 Z-순서 곡선</h3>
<p><strong>모튼 코드(Morton Code)</strong>, 또는 Z-순서 곡선(Z-order Curve)은 다차원 데이터를 1차원으로 매핑하면서 원본 데이터의 공간적 지역성(spatial locality)을 최대한 보존하는 강력한 기법이다.17 즉, 3차원 공간에서 서로 가까이 위치한 점들은 모튼 코드로 변환된 1차원 값에서도 높은 확률로 서로 가까운 값을 갖게 된다.19 이 특성이 선형 옥트리를 가능하게 하는 핵심 원리이다.</p>
<p>모튼 코드의 생성 원리는 **비트 인터리빙(bit interleaving)**이다. 3차원 좌표 <span class="math math-inline">(x, y, z)</span>가 주어졌을 때, 각 좌표값을 이진수로 표현한 뒤, 각 자리의 비트들을 순서대로 번갈아 가며 엮어 하나의 긴 이진수를 만든다.20 예를 들어, 3비트로 표현된 좌표 <span class="math math-inline">(x, y, z) = (x_2x_1x_0, y_2y_1y_0, z_2z_1z_0)</span>가 있다면, 모튼 코드는 z2y2x2z1y1x1z0y0x0 와 같이 생성된다.</p>
<p>수학적으로, 3차원 단위 정육면체 내의 한 점 <span class="math math-inline">P = (x, y, z)</span>의 좌표가 다음과 같이 이진 소수로 표현된다고 가정하자.<br />
<span class="math math-display">
x = \sum_{i=1}^{\infty} x_i 2^{-i}, \quad y = \sum_{i=1}^{\infty} y_i 2^{-i}, \quad z = \sum_{i=1}^{\infty} z_i 2^{-i} \quad (x_i, y_i, z_i \in \{0, 1\})
</span><br />
이때, 점 P에 해당하는 모튼 코드 M은 다음과 같이 정의된다.<br />
<span class="math math-display">
M = \sum_{i=1}^{\infty} (z_i 4^{-i} + y_i 2 \cdot 4^{-i} + x_i 4 \cdot 4^{-i}) = \sum_{i=1}^{\infty} (4x_i + 2y_i + z_i) 8^{-i}
</span><br />
이러한 모튼 코드를 값의 크기 순서대로 정렬하면, 이는 해당 옥트리 구조를 깊이 우선 탐색(Depth-First Search, DFS) 순서로 방문하는 것과 정확히 일치한다.12 즉, 모튼 코드 자체가 옥트리 내 노드의 경로 정보를 압축하여 담고 있는 것이다.</p>
<h3>3.4  선형 옥트리에서의 연산</h3>
<p>모튼 코드를 사용하면 포인터 없이도 순전히 산술 및 비트 연산만으로 트리 구조를 탐색하고 조작할 수 있다.</p>
<ul>
<li>
<p><strong>부모-자식 관계</strong>: 모튼 코드의 구조적 특성상, 특정 노드의 위치 코드는 그 부모 노드의 위치 코드 뒤에 해당 옥턴트를 식별하는 3비트 코드를 이어 붙인 형태가 된다. 예를 들어, 부모 노드의 코드가 <span class="math math-inline">M_{parent}</span>이고, 자식이 5번 옥턴트(이진수 101)에 위치한다면 자식의 코드는 <span class="math math-inline">M_{child} = (M_{parent} \ll 3) \lor 5</span> 가 된다. 역으로, 자식 노드의 코드 <span class="math math-inline">M_{child}</span>에서 부모 노드의 코드를 찾는 것은 단순히 3비트 오른쪽 시프트(right shift) 연산, 즉 <span class="math math-inline">M_{parent} = M_{child} \gg 3</span> 으로 매우 빠르게 계산할 수 있다.14</p>
</li>
<li>
<p><strong>이웃 노드 탐색 (Neighbor Finding)</strong>: 포인터가 없기 때문에 이웃 노드를 찾는 과정은 더 복잡하지만, 역시 위치 코드를 이용한 계산으로 해결 가능하다. 가장 직관적인 방법은 다음과 같다: (1) 현재 노드의 모튼 코드를 3차원 좌표로 디코딩한다. (2) 찾고자 하는 방향(예: +x 방향)으로 좌표를 1만큼 이동시킨다. (3) 새로 얻은 좌표를 다시 모튼 코드로 인코딩하여 이웃 노드의 위치 코드를 얻는다.25 이 방법은 코딩/디코딩 연산 비용이 발생한다.</p>
</li>
</ul>
<p>더 발전된 기법은 모튼 코드 공간에서 직접 이웃을 찾는다. 예를 들어, 현재 노드의 모튼 코드와 이웃할 것으로 예상되는 좌표의 모튼 코드 간에 비트별 XOR 연산을 수행한다. 이 결과에서 가장 중요한 비트(most significant bit)의 위치를 찾으면, 두 노드의 가장 가까운 공통 조상(Lowest Common Ancestor)이 트리의 어느 깊이에 있는지를 알 수 있다. 이 정보를 이용하면 루트에서부터 다시 탐색을 시작할 필요 없이 공통 조상으로부터 탐색을 시작하여 이웃 노드까지의 경로를 효율적으로 계산할 수 있다.26 이러한 비트 조작 기법들은 포인터 추적에 비해 훨씬 빠르고 예측 가능한 성능을 제공하며, 포인터리스 옥트리의 효율성을 뒷받침하는 핵심 기술이다.</p>
<p>이처럼 모튼 코드를 기반으로 한 선형 옥트리는 전통적인 포인터 기반 구조의 패러다임을 완전히 전환시켰다. 이는 구조적 관계를 산술적 관계로 변환함으로써 메모리 사용량을 획기적으로 줄이고, 현대 병렬 컴퓨팅 아키텍처의 성능을 최대한 활용할 수 있는 길을 열었다. i-Octree와 같은 최신 동적 옥트리 구조 역시 이러한 포인터리스 접근법의 철학을 계승하고 발전시킨 결과물이다.</p>
<h2>4.  i-Octree의 설계 및 구현</h2>
<p>i-Octree는 전통적인 옥트리의 견고한 공간 분할 원리를 기반으로 하되, 현대적인 실시간 동적 환경의 요구사항을 충족시키기 위해 설계된 진보된 자료구조이다. 특히 LiDAR SLAM과 같이 지속적으로 대규모 데이터가 유입되는 응용 분야를 목표로, 빠른 증분 업데이트와 효율적인 최근접 이웃 탐색(NNS)에 초점을 맞추고 있다. 본 장에서는 i-Octree를 탄생시킨 설계 동기부터 핵심적인 기술적 특징, 그리고 실제 구현에 사용되는 자료구조와 알고리즘에 대해 상세히 분석한다.</p>
<h3>4.1  설계 동기: 동적 포인트 클라우드의 실시간 처리</h3>
<p>i-Octree의 등장은 기술적 필요성에 의해 촉발되었다. 자율 주행 자동차나 모바일 로봇에 탑재된 LiDAR 센서는 주변 환경을 스캔하여 초당 수백만 개에 달하는 3차원 포인트 클라우드를 생성한다.7 SLAM(Simultaneous Localization and Mapping) 시스템은 이 데이터를 실시간으로 처리하여 두 가지 핵심 작업을 수행해야 한다.</p>
<ol>
<li><strong>맵 업데이트</strong>: 새로 들어온 포인트 클라우드를 기존에 구축된 전역 맵(global map)에 지속적으로 통합해야 한다. 이 과정은 ’증분적(incremental)’으로, 즉 전체 맵을 재구성하지 않고 새로운 데이터만 효율적으로 추가하거나 변경할 수 있어야 한다.</li>
<li><strong>위치 추정</strong>: 새로 들어온 포인트 클라우드와 기존 맵 사이의 기하학적 정합(registration)을 통해 로봇의 현재 위치와 자세를 추정해야 한다. 이를 위해서는 두 데이터셋 간의 대응점(correspondence)을 찾아야 하며, 이 과정에서 NNS(최근접 이웃 탐색)가 핵심적인 역할을 한다.</li>
</ol>
<p>기존의 공간 분할 자료구조들은 이러한 동시적이고 연속적인 요구사항을 만족시키기에 부족했다. 정적 옥트리는 업데이트 비용이 너무 컸고, k-d 트리의 변종인 ikd-Tree와 같은 구조는 증분 업데이트를 지원하지만 특정 연산(예: 반경 탐색)이나 메모리 효율성 측면에서 한계를 보였다.7 i-Octree는 바로 이 지점에서 출발한다. 즉,</p>
<p><strong>실시간 포인트 삽입, 삭제, 그리고 빠른 NNS를 동시에 지원하는 고효율, 저메모리 동적 옥트리</strong>를 구현하는 것이 그 핵심 설계 목표이다.</p>
<h3>4.2  i-Octree의 핵심 특징</h3>
<p>i-Octree는 위와 같은 설계 목표를 달성하기 위해 몇 가지 독창적인 특징을 갖추고 있다.</p>
<h4>4.2.1  증분적 및 동적 업데이트 (Incremental and Dynamic Updates)</h4>
<p>i-Octree의 가장 큰 장점은 동적 데이터 처리에 있다. 이는 단순히 데이터를 추가하는 것을 넘어, 트리 구조 자체를 유연하게 변경하는 능력을 포함한다.</p>
<ul>
<li><strong>효율적인 포인트 삽입/삭제</strong>: 새로운 포인트가 추가될 때, i-Octree는 전체 트리를 재구성하는 대신 해당 포인트가 속할 리프 노드만을 찾아 데이터를 추가한다. 만약 리프 노드가 분할 조건을 만족하게 되면, 해당 노드만 지역적으로 분할(local subdivision)하여 8개의 새로운 자식 리프 노드를 생성한다. 삭제 역시 마찬가지로, 해당 포인트를 포함하는 리프 노드에서 포인트를 제거하고, 필요하다면 형제 노드들과의 병합(merge)을 통해 트리를 최적화한다. 이러한 지역적 연산(local operation)은 계산 비용을 최소화하여 실시간 삽입 및 삭제를 가능하게 한다.7</li>
<li><strong>동적 트리 확장</strong>: 로봇이 이동함에 따라 센서 데이터는 기존 맵의 경계를 벗어날 수 있다. i-Octree는 이러한 상황에 대응하기 위해 동적 확장 기능을 제공한다. 새로운 포인트가 현재 옥트리의 전체 경계 상자(root bounding box)를 벗어나면, 기존 루트 노드를 자식으로 포함하는 더 큰 새로운 루트 노드를 생성하여 전체 공간의 범위를 동적으로 확장한다.8 이 과정은 여러 번 반복될 수 있어, 무한히 넓은 공간을 점진적으로 탐사하는 시나리오에 효과적으로 대응할 수 있다.</li>
</ul>
<h4>4.2.2  지역적 공간 연속 저장 전략 (Local Spatially Continuous Storing Strategy)</h4>
<p>i-Octree의 성능을 뒷받침하는 핵심적인 구현 기술은 바로 메모리 관리 방식에 있다.</p>
<ul>
<li><strong>전략의 핵심</strong>: 전통적인 선형 옥트리가 모든 포인트를 하나의 거대한 정렬된 배열에 저장하는 것과 달리, i-Octree는 <strong>리프 노드 단위</strong>로 포인트를 관리한다. 각 리프 노드는 자신에게 속한 포인트들의 정보(좌표, 속성 등)를 저장하기 위한 별도의 연속적인 메모리 세그먼트(a segment of continuous memory)를 할당받아 관리한다.8</li>
<li><strong>성능상의 이점</strong>: 이 전략은 여러 가지 중요한 이점을 가져온다. 첫째, 특정 리프 노드 내의 모든 포인트는 메모리 상에 밀집해 있으므로, 해당 노드를 방문하는 NNS와 같은 질의 수행 시 캐시 효율성이 극대화되어 데이터 접근 속도가 매우 빠르다. 둘째, 포인트 삽입 및 삭제가 해당 리프 노드의 지역적인 메모리 블록 내에서만 이루어지므로, 다른 노드의 데이터에 영향을 주지 않고 전역적인 데이터 이동이나 재정렬이 필요 없다. 이는 업데이트 성능을 획기적으로 향상시킨다. 셋째, 각 리프 노드가 자신의 포인트만 관리하므로, 전체 구조에 대한 복잡한 포인터 추적을 최소화하고 메모리 사용량을 절감할 수 있다.7</li>
</ul>
<h4>4.2.3  고급 기능 (Advanced Features)</h4>
<p>i-Octree는 기본적인 기능을 넘어 실제 응용에서 유용한 고급 기능들을 통합하고 있다.</p>
<ul>
<li><strong>트리 상 다운샘플링 (On-tree Down-sampling)</strong>: 대규모 포인트 클라우드를 처리할 때, 계산 효율성을 위해 데이터의 밀도를 낮추는 다운샘플링이 필수적이다. i-Octree는 별도의 전처리 과정 없이, 구축된 트리 구조를 직접 순회하며 각 리프 노드(복셀)의 중심점이나 평균점을 취하는 방식으로 효율적인 다운샘플링을 수행할 수 있다.</li>
<li><strong>박스 단위 삭제 (Box-wise Deletion)</strong>: SLAM 응용에서는 로봇의 현재 위치 주변의 맵만 활성 상태로 유지하고, 멀리 떨어진 과거의 맵 데이터는 제거하여 맵의 크기가 무한정 커지는 것을 방지해야 한다. i-Octree는 특정 축에 정렬된 상자(axis-aligned box) 영역을 지정하여, 해당 영역과 겹치는 모든 노드 및 포인트를 매우 효율적으로 제거하는 ‘박스 단위 삭제’ 기능을 지원한다. 이는 동적 맵 관리에 있어 매우 강력한 도구이다.7</li>
</ul>
<h3>4.3  자료구조 및 알고리즘</h3>
<p>i-Octree의 구체적인 구현은 다음과 같은 자료구조와 알고리즘에 기반한다.</p>
<ul>
<li><strong>기본 자료구조</strong>: i-Octree는 근본적으로 **리프 기반 옥트리(leaf-based octree)**이다. 즉, 데이터는 오직 리프 노드에만 저장된다. 각 노드는 공간 내에서의 위치를 식별하기 위해 **모튼 코드(Morton code)**를 기반으로 인덱싱된다.8 노드 구조체는 일반적으로 자신의 경계 상자, 깊이(depth), 자식 노드에 대한 참조(포인터 또는 인덱스), 그리고 리프 노드의 경우 포인트 데이터를 저장하는 연속 메모리 블록에 대한 포인터 등을 포함한다.</li>
<li><strong>구축 알고리즘</strong>: 초기 구축 과정은 전통적인 Top-down 방식을 따른다. (1) 입력된 포인트 클라우드에서 유효한 포인트들만 필터링하여 전체를 감싸는 최소 경계 상자를 계산한다. (2) 루트 노드에서 시작하여, 현재 노드의 공간 중심을 기준으로 8개의 하위 큐브(옥턴트)로 분할한다. (3) 현재 노드에 속한 모든 포인트를 각각 어느 하위 큐브에 속하는지 판별하여 분배한다. (4) 각 하위 큐브에 대해 포인트가 하나 이상 존재하면 새로운 자식 노드를 생성하고, 이 과정을 재귀적으로 반복한다. 이 과정은 리프 노드가 종료 조건을 만족할 때까지 계속된다.8</li>
<li><strong>NNS (Nearest Neighbor Search) 알고리즘</strong>: NNS 질의(KNN 또는 반경 탐색)가 주어지면, 탐색은 루트 노드에서 시작된다. (1) 현재 노드의 경계 상자가 질의 영역(예: 탐색 반경을 갖는 구)과 겹치는지 확인한다. 겹치지 않으면 해당 노드와 그 하위 트리는 모두 탐색에서 제외한다(가지치기, pruning). (2) 만약 현재 노드가 리프 노드이면, 해당 노드가 관리하는 연속 메모리 블록 내의 모든 포인트들을 순회하며 질의 조건에 맞는 이웃을 찾는다. (3) 현재 노드가 내부 노드이면, 8개의 자식 노드에 대해 이 과정을 재귀적으로 반복한다. 이 과정에서 질의 지점과 더 가까운 자식 노드를 먼저 방문하는 등의 최적화를 통해 탐색 효율을 높일 수 있다. 옥트리의 규칙적인 공간 분할 특성은 특히 반경 탐색에서 불필요한 영역을 효과적으로 제거하여 뛰어난 성능을 발휘하게 한다.7</li>
</ul>
<p>결론적으로, i-Octree는 검증된 옥트리 원리에 혁신적인 메모리 관리 기법과 동적 업데이트 알고리즘을 결합하여, 현대 실시간 3D 데이터 처리의 난제를 해결하는 강력하고 실용적인 솔루션이라 할 수 있다.</p>
<h2>5.  i-Octree 성능 분석 및 벤치마크</h2>
<p>자료구조의 우수성은 이론적 설계뿐만 아니라 실제 환경에서의 성능으로 입증된다. i-Octree는 동적 포인트 클라우드 처리를 위해 제안된 만큼, 기존의 최신 기술들과의 엄격한 성능 비교를 통해 그 효율성을 검증받았다. 본 장에서는 공개된 벤치마크 결과를 바탕으로 i-Octree의 핵심 성능 지표들을 심층적으로 분석하고, 그 성능의 배경이 되는 기술적 요인들을 고찰한다.</p>
<h3>5.1  실험 환경 및 비교 대상</h3>
<p>i-Octree의 성능 평가는 두 가지 종류의 데이터셋을 사용하여 종합적으로 이루어졌다. 첫째는 통제된 환경에서 알고리즘의 순수한 성능을 측정하기 위한 **무작위 생성 데이터(randomized data)**이고, 둘째는 실제 응용 시나리오에서의 효율성을 검증하기 위한 <strong>실세계 데이터(real-world data)</strong>, 특히 자율 주행 연구에서 널리 사용되는 KITTI 데이터셋이다.7</p>
<p>성능 비교를 위해 선정된 대상들은 현재 동적 포인트 클라우드 처리 분야에서 가장 경쟁력 있는 기술들이다.</p>
<ul>
<li><strong>ikd-Tree</strong>: k-d 트리를 기반으로 증분적 업데이트(삽입, 삭제, 재균형) 기능을 효율적으로 구현한 최신 자료구조이다. 동적 환경에서의 포인트 탐색에 강점을 보여 i-Octree의 직접적인 성능 비교 대상으로 선정되었다.7</li>
<li><strong>PCL (Point Cloud Library) Octree</strong>: PCL은 3D 포인트 클라우드 처리를 위한 산업 표준에 가까운 오픈소스 라이브러리로, 여기에 포함된 옥트리 구현은 널리 사용되는 기준 성능(baseline)을 대표한다.7</li>
</ul>
<p>이러한 비교 대상과의 대결을 통해 i-Octree가 단순히 새로운 구조가 아니라, 기존 기술 대비 실질적인 성능 향상을 이루었는지를 객관적으로 평가할 수 있다.</p>
<h3>5.2  핵심 성능 지표 분석</h3>
<p>벤치마크는 자료구조의 수명 주기 전반에 걸친 다양한 연산에 대해 수행되었다. 각 지표에 대한 분석은 다음과 같다.</p>
<h4>5.2.1  구축 시간 (Construction Time)</h4>
<p>초기 맵을 생성하는 데 걸리는 시간으로, 대규모 포인트 클라우드를 처음 처리할 때의 효율성을 나타낸다. 실험 결과, i-Octree는 16.63 ms의 구축 시간을 기록하여, ikd-Tree(46.26 ms) 대비 약 64% 더 빠른 성능을 보였으며, PCL 옥트리(52.66 ms)보다는 3배 이상 빨랐다.7 이러한 우위는 i-Octree의 효율적인 재귀 분할 알고리즘과 모튼 코드를 사용한 인덱싱, 그리고 지역화된 메모리 할당 전략이 초기 데이터 분배 과정에서부터 효과적으로 작동함을 시사한다. 전체 데이터를 한 번에 정렬하고 복잡한 균형 조정 과정을 거치는 일부 트리 구조에 비해, 규칙적인 공간 분할에 기반한 i-Octree의 구축 과정이 더 단순하고 빠르다는 것을 의미한다.</p>
<h4>5.2.2  포인트 삽입 (Point Insertion)</h4>
<p>동적 자료구조의 핵심 성능 지표로, 새로운 데이터 포인트를 기존 트리에 추가하는 데 걸리는 시간을 측정한다. i-Octree는 평균 0.83 ms의 삽입 시간을 기록하여, 2.45 ms가 소요된 ikd-Tree보다 약 66% 더 빠른 압도적인 성능을 보였다.7 PCL 옥트리(0.85 ms)와는 유사한 수준이지만, 다른 모든 성능 지표에서 i-Octree가 우월하다는 점을 고려해야 한다. 이 결과는 3장에서 설명한 ’지역적 공간 연속 저장 전략’의 효율성을 명확히 입증한다. 포인트 삽입이 대부분 해당 리프 노드의 지역적인 메모리 블록 내에서 처리되고, 전역적인 트리 구조 변경이나 데이터 재배열을 최소화하기 때문에 이처럼 빠른 증분 업데이트가 가능한 것이다.</p>
<h4>5.2.3  최근접 이웃 탐색 (Nearest Neighbor Search, NNS)</h4>
<p>NNS는 SLAM의 데이터 연관(data association) 단계에서 가장 빈번하게 호출되는 연산으로, 그 성능이 전체 시스템의 실시간성에 직접적인 영향을 미친다.</p>
<ul>
<li><strong>KNN (k-Nearest Neighbors) Search</strong>: k개의 가장 가까운 이웃을 찾는 연산에서 i-Octree는 0.41 ms를 기록하여, ikd-Tree(0.59 ms)보다 약 30% 빠른 성능을 보였다. PCL 옥트리(2.53 ms)와 비교하면 약 6배 빠른 속도이다.7</li>
<li><strong>Radius Neighbors Search</strong>: 특정 반경 내의 모든 이웃을 찾는 연산에서 i-Octree의 장점은 더욱 두드러진다. 0.81 ms를 기록하여 ikd-Tree(1.85 ms) 대비 56% 더 빠른 성능을 달성했다.7 이는 옥트리의 구조적 특성 때문이다. 옥트리는 공간을 정육면체 형태로 규칙적으로 분할하므로, 구(sphere) 형태의 반경 탐색 영역과 경계 상자 간의 교차 판정이 매우 간단하고 효율적이다. 반면, k-d 트리와 같이 데이터 분포에 따라 불규칙하게 공간을 분할하는 구조는 반경 탐색 시 더 많은 노드를 방문해야 할 수 있다.</li>
</ul>
<h4>5.2.4  메모리 사용량 (Peak Memory Usage)</h4>
<p>제한된 컴퓨팅 자원을 가진 로봇 시스템에서 메모리 효율성은 매우 중요하다. i-Octree는 최대 21.53 Mb의 메모리를 사용하여, 62.91 Mb를 사용한 ikd-Tree와 136.82 Mb를 사용한 PCL 옥트리에 비해 각각 약 1/3, 1/6 수준의 메모리만을 필요로 했다.7 이처럼 뛰어난 메모리 효율성은 포인터 사용을 최소화하고, 각 리프 노드에서 포인트 데이터를 연속적인 메모리 블록에 컴팩트하게 저장하는 i-Octree의 핵심 설계 철학이 성공적으로 구현되었음을 보여준다.</p>
<h4>5.2.5  박스 단위 삭제 (Box-wise Deletion)</h4>
<p>SLAM에서 맵의 크기를 관리하기 위한 이 기능에서 i-Octree는 다른 구조들을 압도하는 성능을 보였다. 특정 상자 영역 내의 포인트를 삭제하는 데 평균 0.016 ms가 소요된 반면, ikd-Tree는 약 0.250 ms가 걸려 10배 이상의 성능 차이를 보였다.7 이는 i-Octree가 상자와 겹치는 노드를 빠르게 식별하고, 해당 노드와 관련된 지역적 메모리 블록만을 해제하는 방식으로 동작하기 때문이다. 반면, 다른 트리 구조에서는 삭제 후 트리의 균형을 맞추기 위한 추가적인 복잡한 연산이 필요할 수 있다.</p>
<h3>5.3  성능 비교표</h3>
<p>상기 분석 내용을 요약하면 다음과 같다. 이 표는 7에서 제공된 벤치마크 데이터를 기반으로 재구성되었다.</p>
<table><thead><tr><th><strong>성능 지표 (Performance Metric)</strong></th><th><strong>i-Octree</strong></th><th><strong>ikd-Tree</strong></th><th><strong>PCL octree</strong></th></tr></thead><tbody>
<tr><td>구축 시간 (Construction) [ms]</td><td><strong>16.63</strong></td><td>46.26</td><td>52.66</td></tr>
<tr><td>포인트 삽입 (Point Insertion) [ms]</td><td><strong>0.83</strong></td><td>2.45</td><td>0.85</td></tr>
<tr><td>KNN 탐색 (KNN Search) [ms]</td><td><strong>0.41</strong></td><td>0.59</td><td>2.53</td></tr>
<tr><td>반경 탐색 (Radius Neighbors Search) [ms]</td><td><strong>0.81</strong></td><td>1.85</td><td>3.96</td></tr>
<tr><td>최대 메모리 사용량 (Peak Memory) [Mb]</td><td><strong>21.53</strong></td><td>62.91</td><td>136.82</td></tr>
<tr><td>박스 단위 삭제 (Box-wise Delete) [ms]</td><td><strong>~0.016</strong></td><td>~0.250</td><td>해당 없음</td></tr>
</tbody></table>
<p>이러한 정량적 데이터는 i-Octree가 단지 하나의 특정 연산에서만 뛰어난 것이 아님을 명확히 보여준다. 구축, 업데이트, 다양한 종류의 탐색, 메모리 관리, 그리고 동적 맵 관리 기능에 이르기까지, 자료구조가 갖추어야 할 거의 모든 덕목에서 경쟁 기술들을 능가하는 균형 잡힌 고성능을 제공한다. 이는 i-Octree의 설계가 실제 동적 포인트 클라우드 응용 프로그램의 다차원적인 요구사항을 깊이 이해하고, 이를 해결하기 위해 종합적으로 최적화된 결과임을 시사한다. 따라서 i-Octree는 현존하는 동적 포인트 클라우드 처리 기술 중 가장 강력하고 실용적인 대안 중 하나로 평가될 수 있다.</p>
<h2>6.  활용 분야 및 비교 고찰</h2>
<p>i-Octree는 특정 문제 해결을 위해 탄생했지만, 그 기반이 되는 옥트리 기술은 지난 수십 년간 컴퓨터 과학의 다양한 분야에서 폭넓게 활용되어 온 범용적인 기술이다. 본 장에서는 i-Octree의 핵심 응용 분야를 명확히 하고, 더 나아가 일반적인 옥트리가 어떤 분야에서 어떻게 활용되는지를 조망한다. 또한, 다른 주요 공간 분할 자료구조와의 비교를 통해 옥트리 계열 기술의 상대적인 장단점과 기술적 위치를 명확히 한다.</p>
<h3>6.1  i-Octree의 주요 활용 분야</h3>
<p>i-Octree의 설계 목적과 성능 특성은 그 주요 활용 분야를 명확하게 지시한다.</p>
<ul>
<li><strong>LiDAR SLAM 및 로봇 공학</strong>: i-Octree의 가장 직접적이고 강력한 응용 분야는 실시간 LiDAR SLAM이다. 로봇이나 자율 주행 차량이 이동하면서 지속적으로 수집하는 방대한 3D 포인트 클라우드를 동적으로 관리하는 데 최적화되어 있다. 빠른 증분 업데이트 기능은 새로운 센서 데이터를 지연 없이 맵에 통합하게 해주며, 초고속 NNS 기능은 현재 스캔과 기존 맵 간의 정합을 위한 대응점 탐색(data association)을 가속화한다. 이는 로봇의 위치 추정 정확도와 실시간성을 보장하는 핵심 요소이다. 또한, 박스 단위 삭제 기능은 로봇의 이동에 따라 맵을 유연하게 관리하고 메모리 사용량을 제어하는 데 결정적인 역할을 한다.7</li>
</ul>
<h3>6.2  일반 옥트리의 확장된 활용 분야</h3>
<p>i-Octree의 기반 기술인 옥트리는 다음과 같이 훨씬 더 넓은 영역에서 그 유용성을 입증해왔다.</p>
<h4>6.2.1  컴퓨터 그래픽스</h4>
<p>컴퓨터 그래픽스는 옥트리가 가장 먼저, 그리고 가장 활발하게 사용된 분야 중 하나이다.</p>
<ul>
<li><strong>충돌 감지 (Collision Detection)</strong>: 복잡한 3D 장면에서 객체 간의 충돌을 검사하는 것은 계산 비용이 매우 높은 작업이다. 옥트리는 전체 공간을 계층적으로 분할하여, 서로 다른 노드에 위치하여 충돌 가능성이 없는 객체 쌍에 대한 검사를 생략하게 해준다. 이를 통해 검사해야 할 객체 쌍의 수를 <span class="math math-inline">O(N^2)</span>에서 <span class="math math-inline">O(N \log N)</span>에 가깝게 줄일 수 있다.2</li>
<li><strong>레이 트레이싱 (Ray Tracing)</strong>: 사실적인 이미지를 생성하는 레이 트레이싱은 화면의 각 픽셀에서 가상의 광선을 쏘아 장면에 있는 객체와의 교차점을 찾는 과정이다. 옥트리는 광선이 통과하는 경로에 있는 복셀(노드)들만을 순차적으로 탐색하도록 하여, 광선과 무관한 수많은 객체와의 불필요한 교차 연산을 제거한다. 이는 렌더링 속도를 획기적으로 향상시키는 핵심 가속 기법이다.28</li>
<li><strong>가시거리 컬링 (View Frustum Culling)</strong>: 3D 장면을 렌더링할 때, 카메라의 시야각(frustum) 밖에 있어 어차피 보이지 않는 객체들을 렌더링 파이프라인에서 미리 제거하는 과정이다. 옥트리를 사용하면, 노드 단위로 프러스텀과의 교차 여부를 빠르게 판단하여 시야 밖의 공간 전체를 한 번에 컬링할 수 있다.3</li>
<li><strong>LOD (Level of Detail) 렌더링</strong>: 옥트리의 계층 구조는 LOD 기법에 자연스럽게 적용된다. 카메라에서 멀리 있는 객체는 옥트리의 상위 레벨에 있는 거친 노드(coarse node)를 사용하여 간략하게 렌더링하고, 가까이 있는 객체는 하위 레벨의 세밀한 노드(fine node)를 사용하여 정교하게 렌더링함으로써, 시각적 품질을 유지하면서 렌더링 부하를 동적으로 조절할 수 있다.2</li>
</ul>
<h4>6.2.2  과학 시뮬레이션 및 시각화</h4>
<p>복잡한 물리 현상을 모델링하는 과학 및 공학 분야에서도 옥트리는 핵심적인 역할을 한다.</p>
<ul>
<li><strong>적응적 격자 생성 (Adaptive Mesh Refinement, AMR)</strong>: 유한 요소 해석(FEA), 전산 유체 역학(CFD), N-body 시뮬레이션 등에서 계산의 정확도는 격자(mesh)의 해상도에 크게 의존한다. 옥트리는 압력이나 응력 변화가 심한 중요 영역은 격자를 조밀하게(refine), 변화가 적은 영역은 성기게(coarsen) 만드는 적응적 격자를 효율적으로 생성하고 관리하는 데 사용된다. 이를 통해 전체 계산량을 줄이면서도 국소적인 정확도를 높일 수 있다.3</li>
<li><strong>대규모 볼륨 데이터 시각화</strong>: 의료 영상(CT, MRI)이나 과학 시뮬레이션 결과로 생성되는 거대한 볼륨 데이터를 시각화할 때, 옥트리는 데이터를 압축하고 계층적으로 저장하는 데 사용된다. 이를 통해 사용자는 전체 데이터를 메모리에 올리지 않고도 상호작용적으로 데이터를 탐색하고, 관심 영역을 확대하며 세부 구조를 확인할 수 있다.13</li>
</ul>
<h4>6.2.3  3D 모델링 및 GIS</h4>
<ul>
<li><strong>3D 모델링 및 CAD</strong>: Autodesk Inventor와 같은 CAD 소프트웨어에서는 복잡한 3D 모델의 렌더링 성능을 최적화하고, 부품 간의 간섭을 확인하는 충돌 감지, 특정 지점의 객체를 찾는 공간 탐색 등을 가속하기 위해 옥트리를 내부적으로 사용한다.2</li>
<li><strong>지리 정보 시스템 (GIS)</strong>: OpenStreetMap과 같은 프로젝트에서는 방대한 3D 도시 모델이나 넓은 지역의 지형 데이터를 효율적으로 저장하고, 특정 영역 내의 건물이나 지형 정보를 빠르게 질의하기 위한 공간 인덱싱 구조로 옥트리를 활용한다.2</li>
</ul>
<h3>6.3  타 공간 분할 자료구조와의 비교</h3>
<p>옥트리의 특성을 더 명확히 이해하기 위해서는 다른 주요 공간 분할 자료구조와의 비교가 필수적이다. 어떤 자료구조가 ‘절대적으로’ 우월하다기보다는, 데이터의 특성과 주된 연산의 종류에 따라 각자의 장단점이 드러난다.</p>
<h4>6.3.1  옥트리 vs. k-d 트리 (Octree vs. k-d Tree)</h4>
<ul>
<li><strong>분할 방식의 차이</strong>: 옥트리는 항상 공간의 중심을 기준으로 세 축을 동시에 사용하여 규칙적인 8분할을 수행한다. 반면, k-d 트리는 각 분할 단계에서 데이터의 분포를 고려하여 가장 분산이 큰 축 하나를 선택하고, 해당 축에 수직인 평면으로 공간을 이진 분할한다.5 이로 인해 k-d 트리는 데이터 분포에 매우 잘 적응하는 비대칭적인 구조를 형성할 수 있는 반면, 옥트리는 데이터 분포와 무관하게 항상 규칙적인 구조를 유지한다.35</li>
<li><strong>성능 특성</strong>: 옥트리의 규칙성은 구조가 단순하고 예측 가능하게 만들어, 특히 반경 탐색이나 이웃 노드 탐색과 같은 연산에서 강점을 보인다.7 k-d 트리는 특정 점을 찾는 질의(point query)나 최근접 이웃 탐색에서 매우 효율적일 수 있으나, 데이터의 삽입 및 삭제가 발생하면 트리의 균형이 쉽게 깨져 성능이 급격히 저하될 수 있으며, 이를 재조정하는 과정이 복잡하다.5 따라서 동적인 환경에서는 옥트리 기반의 구조가 더 선호되는 경향이 있다.36</li>
</ul>
<h4>6.3.2  옥트리 vs. BVH (Bounding Volume Hierarchy)</h4>
<ul>
<li><strong>분할 대상의 차이</strong>: 두 구조의 가장 근본적인 차이는 분할의 대상이다. 옥트리는 **공간(space)**을 분할하는 기법(Space Partitioning)이다. 즉, 공간을 먼저 나누고 각 공간에 어떤 객체가 포함되는지를 결정한다. 반면, BVH는 **객체(object)**를 분할하는 기법(Object Partitioning)이다. 즉, 객체들의 집합을 두 그룹으로 나누고, 각 그룹을 감싸는 최소한의 경계 볼륨(bounding volume)을 계산하는 과정을 재귀적으로 반복한다.15</li>
<li><strong>메모리 및 성능</strong>: BVH는 객체의 실제 분포에 맞춰 매우 타이트한(tight-fitting) 경계 볼륨을 생성할 수 있어, 객체가 희소하게 분포된 장면의 레이 트레이싱에서 매우 높은 성능을 보인다.38 그러나 각 노드가 경계 볼륨의 좌표를 명시적으로 저장해야 하므로 메모리 사용량이 더 클 수 있다. 옥트리는 노드의 경계가 깊이와 위치 코드로부터 암시적으로 계산되므로 노드 자체의 메모리 오버헤드가 적을 수 있다.40 동적 환경에서는 객체가 약간 움직였을 때 BVH는 해당 객체가 포함된 노드들의 경계 볼륨만 다시 계산하여 ’재조정(refitting)’하는 것이 가능하여, 전체 구조를 재구성하는 것보다 훨씬 효율적일 수 있다.38</li>
</ul>
<p>결론적으로, 어떤 공간 분할 구조를 선택할 것인지는 해결하려는 문제의 본질에 달려있다. 균일한 밀도의 복셀 데이터나 포인트 클라우드를 다루며 반경 탐색이 중요하다면 옥트리가 유리하다. 비균일하게 분포된 개별 폴리곤 객체들로 구성된 장면에서 광선 추적을 한다면 BVH가 더 나은 선택일 수 있다. i-Octree의 성공은, 대규모 동적 포인트 클라우드라는 특정 문제 영역의 요구사항(빠른 증분 업데이트, 효율적인 반경 탐색, 낮은 메모리)을 정확히 파악하고, 이에 가장 적합한 옥트리라는 기반 구조를 선택하여 극한으로 최적화했기 때문에 가능했던 것이다.</p>
<h2>7. 결론</h2>
<p>본 안내서는 3차원 공간 분할을 위한 핵심 자료구조인 옥트리의 기본 원리에서 출발하여, 현대 실시간 동적 환경의 요구에 부응하기 위해 탄생한 i-Octree의 설계, 구현, 성능에 이르기까지 심층적인 분석을 제공했다. 분석을 통해 i-Octree는 단순한 옥트리의 변종이 아니라, 특정 문제 영역, 즉 대규모 동적 포인트 클라우드의 실시간 처리를 위해 고도로 전문화되고 최적화된 기술적 성취임을 확인할 수 있었다.</p>
<p>i-Octree의 핵심적인 기여는 두 가지로 요약될 수 있다. 첫째, **‘지역적 공간 연속 저장 전략(Local Spatially Continuous Storing Strategy)’**의 도입이다. 이는 전통적인 포인터 기반 구조의 캐시 비효율성과 선형 옥트리의 전역적 데이터 관리 부담을 동시에 해결하는 혁신적인 메모리 관리 기법이다. 각 리프 노드가 자신에게 속한 포인트들을 독립적인 연속 메모리 블록에서 관리하게 함으로써, 데이터 접근의 지역성을 극대화하고 NNS와 같은 핵심 질의의 성능을 비약적으로 향상시켰다. 둘째, 이 메모리 전략을 바탕으로 구현된 **‘효율적인 증분 업데이트 알고리즘’**이다. 포인트의 삽입, 삭제, 그리고 맵 경계의 확장이 모두 지역적인 연산으로 처리되어, 전체 트리를 재구성하는 막대한 비용을 제거했다. 이는 LiDAR SLAM과 같이 끊임없이 데이터가 유입되는 환경에서 실시간 성능을 보장하는 결정적인 요소로 작용한다. 벤치마크 결과는 이러한 설계의 우수성을 객관적으로 입증했다. i-Octree는 구축 시간, 삽입 속도, 탐색 성능, 메모리 효율성 등 거의 모든 평가 지표에서 ikd-Tree나 PCL 옥트리와 같은 기존의 최신 기술들을 능가하는 균형 잡힌 고성능을 보여주었다.</p>
<p>i-Octree의 기술적 의의는 단순히 로봇 공학 분야에 국한되지 않는다. 이는 고주파수 데이터 스트림을 처리해야 하는 모든 현대적 응용 분야에 중요한 시사점을 던진다. 데이터가 동적으로 변화하는 환경에서는 자료구조의 정적인 검색 효율성뿐만 아니라, 업데이트와 메모리 관리를 얼마나 효율적으로 수행하는지가 전체 시스템의 성능을 좌우한다는 패러다임을 명확히 보여주었다.</p>
<p>향후 i-Octree 및 관련 기술은 여러 방향으로 발전할 잠재력을 가지고 있다. 첫째, <strong>GPU 및 이종 컴퓨팅 환경으로의 확장</strong>이다. 현재 CPU 기반으로도 뛰어난 성능을 보이지만, i-Octree의 지역적 연산 특성과 데이터 병렬성은 GPU 가속화에 매우 적합하다. 수천 개의 코어를 활용하여 다수의 노드 업데이트 및 탐색을 동시에 처리함으로써 성능을 한 차원 더 끌어올릴 수 있을 것이다.27 둘째,</p>
<p><strong>머신러닝과의 융합</strong>이다. 최근에는 옥트리 구조를 신경망 아키텍처에 통합하여 3D 형상을 표현하거나(Implicit Neural Representations), 포인트 클라우드로부터 고품질의 표면을 재구성(surface reconstruction)하는 연구가 활발히 진행되고 있다.43 i-Octree의 동적 관리 능력은 실시간으로 변화하는 장면에 대한 학습 및 추론 모델의 기반 데이터 구조로서 활용될 수 있다. 마지막으로, 자율 주행, 증강 현실, 디지털 트윈 등 3차원 공간 인식이 핵심이 되는 미래 기술들이 더욱 정교해짐에 따라, i-Octree와 같이 빠르고 강건하며 효율적인 동적 공간 자료구조에 대한 수요는 계속해서 증가할 것이다. i-Octree는 이러한 미래 기술의 발전을 뒷받침하는 핵심 기반 기술로서 그 역할을 더욱 공고히 할 것으로 전망된다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Free Download Octree Spatial Partitioning Setup Template - Meegle, https://www.meegle.com/en_us/advanced-templates/graphics_rendering/octree_spatial_partitioning_setup_template</li>
<li>Octrees: The Ultimate Spatial Data Structure - Number Analytics, https://www.numberanalytics.com/blog/octrees-ultimate-spatial-data-structure</li>
<li>Octree - Wikipedia, https://en.wikipedia.org/wiki/Octree</li>
<li>Mastering Octrees in Algorithm Design - Number Analytics, https://www.numberanalytics.com/blog/ultimate-guide-to-octree-in-algorithm-design</li>
<li>US7002571B2 - Grid-based loose octree for spatial partitioning - Google Patents, https://patents.google.com/patent/US7002571B2/en</li>
<li>Introduction to Octrees - Wobbly Duck Studios, https://www.wobblyduckstudios.com/Octrees.php</li>
<li>A Fast, Lightweight, and Dynamic Octree for Proximity Search - arXiv, https://arxiv.org/html/2309.08315v2</li>
<li>A Fast, Lightweight, and Dynamic Octree for Proximity Search - arXiv, https://arxiv.org/pdf/2309.08315</li>
<li>Octree | Insertion and Searching - GeeksforGeeks, https://www.geeksforgeeks.org/dsa/octree-insertion-and-searching/</li>
<li>An Octree-Based Spatial Index for Space-Based Space Surveillance Coverage Volume Computation, https://arc.aiaa.org/doi/pdfplus/10.2514/6.2024-1675</li>
<li>4.2. How octree works - Castle Game Engine, https://castle-engine.io/vrml_engine_doc/output/xsl/html/section.how_octree_works.html</li>
<li>Advanced Octrees 2: node representations | The Infinite Loop - WordPress.com, https://geidav.wordpress.com/2014/08/18/advanced-octrees-2-node-representations/</li>
<li>A Survey of Octree Volume Rendering Methods - Scientific Computing and Imaging Institute, https://www.sci.utah.edu/~knolla/octsurvey.pdf</li>
<li>Fast generation of pointerless octree duals 1 Introduction, https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Lewiner10.pdf</li>
<li>Are sparse voxel octrees really (always) the best voxel data structure? - Reddit, https://www.reddit.com/r/VoxelGameDev/comments/1jb8uol/are_sparse_voxel_octrees_really_always_the_best/</li>
<li>Fast Generation of Pointerless Octree Duals | Request PDF - ResearchGate, https://www.researchgate.net/publication/220507495_Fast_Generation_of_Pointerless_Octree_Duals</li>
<li>Z-order curve - Wikipedia, https://en.wikipedia.org/wiki/Z-order_curve</li>
<li>Thinking Parallel, Part III: Tree Construction on the GPU | NVIDIA Technical Blog, https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu/</li>
<li>Z-Order Indexing for Efficient Queries in Data Lake | by Nishant Chandra | Medium, https://medium.com/@nishant.chandra/z-order-indexing-for-efficient-queries-in-data-lake-48eceaeb2320</li>
<li>Out-Of-Core construction of Sparse Voxel Octrees - Jeroen Baert’s Blog, https://www.forceflow.be/2012/07/24/out-of-core-construction-of-sparse-voxel-octrees/</li>
<li>Morton encoding/decoding through bit interleaving: Implementations - Jeroen Baert’s Blog, https://www.forceflow.be/2013/10/07/morton-encodingdecoding-through-bit-interleaving-implementations/</li>
<li>Using morton codes to compress data - how? - Stack Overflow, https://stackoverflow.com/questions/22638874/using-morton-codes-to-compress-data-how</li>
<li>Statistical optimization of octree searches - Thomas Lewiner, http://thomas.lewiner.org/pdfs/octree_cgf.pdf</li>
<li>How to Extract Parent Nodes from SVO Built Using Morton Keys? : r/VoxelGameDev - Reddit, https://www.reddit.com/r/VoxelGameDev/comments/1hgpz4w/how_to_extract_parent_nodes_from_svo_built_using/</li>
<li>How to find a octree node’s neighbors when the tree is ordered by Morton code, https://stackoverflow.com/questions/40389011/how-to-find-a-octree-nodes-neighbors-when-the-tree-is-ordered-by-morton-code</li>
<li>What’s the algorithm for 2:1 balancing a linear octree? - Stack Overflow, https://stackoverflow.com/questions/25309784/whats-the-algorithm-for-21-balancing-a-linear-octree</li>
<li>ParallelNN: A Parallel Octree-based Nearest Neighbor Search Accelerator for 3D Point Clouds - WashU Computer Science &amp; Engineering, https://www.cse.wustl.edu/~roger/566S.s24/ParallelNN_2023.pdf</li>
<li>Octree - Sceneri, https://www.sceneri.com/sceneri-docs-glossar/octree/</li>
<li>Fast Collision Detection Method with Octree-Based Parallel Processing in Unity3D - MDPI, https://www.mdpi.com/2673-4591/89/1/37</li>
<li>Octree - Sinspired Studio, https://sinspiredstudio.com/glossary/octree/</li>
<li>Ray / Octree traversal - Jeroen Baert’s Blog, https://www.forceflow.be/2012/04/20/ray-octree-traversal/</li>
<li>Bottom-Up Construction and 2:1 Balance Refinement of Linear Octrees in Parallel | SIAM Journal on Scientific Computing, https://epubs.siam.org/doi/10.1137/070681727</li>
<li>Bottom-Up Construction and 2:1 Balance Refinement of Linear Octrees in Parallel - PADAS, https://padas.oden.utexas.edu/static/papers/OctreeBalance21.pdf</li>
<li>Fast Octree Neighborhood Search for SPH Simulations - Andreas Longva, https://andreaslongva.com/pdf/2022-SA-NeighborhoodSearch-compressed.pdf</li>
<li>Why specifically are k-d trees preferred in ray tracing and octrees in collision? - Reddit, https://www.reddit.com/r/gameenginedevs/comments/1789f54/why_specifically_are_kd_trees_preferred_in_ray/</li>
<li>kd-tree vs octree for 3d radius search - Stack Overflow, https://stackoverflow.com/questions/17998103/kd-tree-vs-octree-for-3d-radius-search</li>
<li>Accelerated Ray Tracing using R-Trees - Fraunhofer-Publica, https://publica.fraunhofer.de/bitstreams/d4e282eb-b669-419b-87d4-4f847fb3aef5/download</li>
<li>A Survey on Bounding Volume Hierarchies for Ray Tracing - Daniel Meister, https://meistdan.github.io/publications/bvh_star/paper.pdf</li>
<li>An evaluation of Kd-Trees vs Bounding Volume Hierarchy (BVH) acceleration structures in modern CPU architectures - SciELO, https://www.scielo.sa.cr/scielo.php?script=sci_arttext&amp;pid=S0379-39822023000200086</li>
<li>What are common benefits and uses of Octrees? : r/GraphicsProgramming - Reddit, https://www.reddit.com/r/GraphicsProgramming/comments/10mf504/what_are_common_benefits_and_uses_of_octrees/</li>
<li>OLBVH: octree linear bounding volume hierarchy for volumetric meshes - ResearchGate, https://www.researchgate.net/publication/342718520_OLBVH_octree_linear_bounding_volume_hierarchy_for_volumetric_meshes</li>
<li>Highly Parallel Surface Reconstruction - Kun Zhou, http://www.kunzhou.net/2008/MSR-TR-2008-53.pdf</li>
<li>Octree Guided Unoriented Surface Reconstruction - CVF Open Access, https://openaccess.thecvf.com/content/CVPR2023/papers/Koneputugodage_Octree_Guided_Unoriented_Surface_Reconstruction_CVPR_2023_paper.pdf</li>
<li>OctField: Hierarchical Implicit Functions for 3D Modeling - Geometry Learning, http://geometrylearning.com/OctField/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>