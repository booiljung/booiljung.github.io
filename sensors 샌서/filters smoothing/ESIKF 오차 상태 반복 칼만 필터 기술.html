<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:오차 상태 반복 칼만 필터(ESIKF) 기술</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>오차 상태 반복 칼만 필터(ESIKF) 기술</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">센서 (Sensors)</a> / <a href="index.html">필터 & 스무딩</a> / <span>오차 상태 반복 칼만 필터(ESIKF) 기술</span></nav>
                </div>
            </header>
            <article>
                <h1>오차 상태 반복 칼만 필터(ESIKF) 기술</h1>
<h2>1. 비선형 상태 추정의 난제</h2>
<h3>1.1 동적 시스템에서의 상태 추정 개요</h3>
<p>동적 시스템에서의 상태 추정은 공학 및 과학의 여러 분야에서 핵심적인 과제이다. 이는 시간에 따라 변화하는 시스템의 내부 상태(예: 위치, 속도, 자세)를 일련의 잡음이 섞인 측정값으로부터 추정하는 과정을 의미한다.1 근본적으로 상태 추정은 시스템의 상태가 어떻게 변화하는지를 기술하는 ’프로세스 모델’과, 현재 상태가 센서 측정값과 어떻게 관련되는지를 설명하는 ’측정 모델’로 구성된 상태 공간 모델에 기반한다.4 칼만 필터와 같은 추정 기법의 목표는 단일 측정값만 사용하는 것보다 더 정확하고 신뢰할 수 있는 추정치를 생성하는 것이다.2</p>
<p>이러한 필터링 기법의 핵심적인 특징 중 하나는 재귀적(recursive) 특성이다. 필터는 새로운 상태를 계산하기 위해 과거의 모든 데이터 이력을 필요로 하는 것이 아니라, 오직 직전 시간 단계의 ’최선의 추정치’만을 요구한다.2 이 특성 덕분에 실시간 시스템에서 매우 높은 계산 효율성을 달성할 수 있으며, 이는 자율 로봇, 항공우주 시스템, 내비게이션 등 다양한 응용 분야에서 필수적이다. 필터는 센서 데이터에 포함된 잡음을 효과적으로 제거하고, 시스템의 불확실성을 줄여줌으로써, 궁극적으로 더 정밀하고 안정적인 상태 추정을 가능하게 한다.1</p>
<h3>1.2 선형 칼만 필터: 최적의 기준선</h3>
<p>상태 추정 논의의 출발점은 선형 칼만 필터(KF)이다. 시스템의 동역학과 측정 모델이 모두 선형이고, 프로세스 및 측정 잡음이 가우시안 분포를 따른다고 가정할 때, 칼만 필터는 평균 제곱 오차(Minimum Mean-Square-Error, MMSE)를 최소화하는 최적의 선형 추정기이다.2 이는 선형-가우시안 시스템에 한해서는 이론적으로 칼만 필터보다 더 나은 성능을 내는 추정기가 존재할 수 없음을 의미하며, 이로 인해 칼만 필터는 비선형 필터를 평가하고 개발하는 데 있어 중요한 이론적 ’황금 표준(gold standard)’으로 자리매김한다.</p>
<h3>1.3 확장 칼만 필터(EKF): 선형화와 그 한계</h3>
<p>그러나 현실 세계의 대부분 시스템은 비선형적이다. 이러한 비선형 시스템에 칼만 필터를 적용하기 위해 가장 널리 사용되는 기법이 바로 확장 칼만 필터(Extended Kalman Filter, EKF)이다.12 EKF의 핵심 아이디어는 비선형적인 프로세스 및 측정 함수를 현재 상태 추정치 주변에서 1차 테일러 급수 전개를 통해 선형화하는 것이다. 즉, 자코비안 행렬을 계산하여 비선형 함수를 국소적으로 선형 함수로 근사하는 방식을 취한다.5</p>
<p>이러한 선형화 근사는 EKF의 가장 큰 강점이자 동시에 치명적인 약점이다. 시스템의 비선형성이 강할 경우, 1차 근사는 실제 비선형 함수를 제대로 표현하지 못하여 큰 오차를 유발한다.12 이 ’선형화 오차’는 EKF의 성능을 저하하는 주된 원인이며, 다음과 같은 심각한 문제들을 야기한다.</p>
<ul>
<li><strong>필터 발산(Divergence) 및 불안정성:</strong> 선형화 오차가 누적되면 필터는 잘못된 추정치에 대해 과도하게 확신하게 될 수 있다. 이로 인해 추정된 상태가 실제 상태로부터 점점 멀어지는 발산 현상이 발생할 수 있으며, 이는 필터의 불안정성으로 이어진다.12 이러한 문제는 특히 초기화 단계나 시스템의 불확실성이 높은 구간에서 두드러진다.12</li>
<li><strong>불일치성(Inconsistency):</strong> 필터의 공분산 행렬이 추정치의 실제 불확실성을 더 이상 정확하게 나타내지 못하는 상태, 즉 불일치성 문제가 발생할 수 있다.</li>
</ul>
<p>EKF의 근본적인 문제는 단순히 근사를 사용한다는 점을 넘어선다. EKF는 가우시안 분포를 ’선형화된 모델’을 통해 전파시키지만, 실제 상태는 ’참 비선형 모델’을 통해 전파된다. 비선형 변환을 거친 가우시안 분포의 평균은 원래 평균을 비선형 변환한 값과 일반적으로 일치하지 않는다 (<span class="math math-inline">E[f(x)] \neq f(E[x])</span>). 따라서 EKF가 예측하는 평균과 공분산은 실제 사후 분포(posterior distribution)에 대한 1차 근사일 뿐이며, 이 사후 분포는 더 이상 가우시안이 아닐 가능성이 높다.16 EKF의 예측과 실제 시스템의 거동 사이의 이러한 근본적인 불일치가 발산과 불일치성의 근본 원인이며, 본 안내서에서 다룰 모든 진보된 필터들의 개발 동기가 된다.</p>
<h2>2. 오차 상태 칼만 필터(ESKF)의 개념 정립</h2>
<h3>2.1 상태의 분리: 공칭 상태와 오차 상태 패러다임</h3>
<p>EKF의 근본적인 한계를 극복하기 위해 제안된 강력한 대안 중 하나가 오차 상태 칼만 필터(Error-State Kalman Filter, ESKF)이다. ESKF의 핵심 철학은 ‘참 상태(true state)’ <span class="math math-inline">x_{true}</span>를 두 부분으로 분리하는 것이다: 하나는 시스템의 동역학을 따라 움직이는 크고 비선형적인 ‘공칭 상태(nominal state)’ <span class="math math-inline">x_{nom}</span>이고, 다른 하나는 이 공칭 상태로부터의 작은 편차를 나타내는 ‘오차 상태(error state)’ <span class="math math-inline">\delta x</span>이다. 이 관계는 <span class="math math-inline">x_{true} = x_{nom} \oplus \delta x</span> 와 같이 표현된다.19 여기서</p>
<p><span class="math math-inline">\oplus</span> 연산자는 일반화된 합성을 의미하며, 벡터 공간에서는 단순 덧셈이지만 회전과 같은 매니폴드(manifold) 상에서는 더 복잡한 연산(예: 쿼터니언 곱셈)이 된다.</p>
<p>ESKF의 핵심 아이디어는 공칭 상태는 완전한 비선형 동역학 모델을 사용하여 전파하고, 칼만 필터는 오직 오차 상태 <span class="math math-inline">\delta x</span>에만 적용하는 것이다. 이 오차 상태는 항상 0에 가깝다고 가정되므로, 그 동역학은 선형 모델로 매우 정확하게 근사할 수 있다.19</p>
<h3>2.2 오차 상태 접근법의 장점</h3>
<p>이러한 접근 방식은 EKF에 비해 몇 가지 중요한 장점을 제공한다.</p>
<ul>
<li><strong>오차 동역학의 선형화:</strong> 오차 상태 <span class="math math-inline">\delta x</span>는 정의상 항상 0 주변의 작은 값을 가지므로, 그 동역학은 선형 모델로 매우 정확하게 근사될 수 있다. 이는 칼만 필터의 선형성 가정을 훨씬 더 잘 만족시키며, 결과적으로 EKF가 전체 상태를 선형화할 때 발생하는 큰 오차를 근본적으로 줄여준다.19 이는 필터의 정확성과 안정성을 크게 향상시킨다.</li>
<li><strong>기하학적 제약 및 특이점 처리:</strong> 이 장점은 특히 로보틱스와 내비게이션 분야에서 두드러진다. 3차원 회전(<span class="math math-inline">SO(3)</span>)과 같은 매니폴드 상의 상태를 다룰 때, 오차 상태는 해당 매니폴드의 접선 공간(tangent space)에 존재하는 최소 차원의 벡터(예: 3차원 축-각 표현)로 나타낼 수 있다.19 이는 오일러 각도의 김벌 락(gimbal lock)과 같은 특이점 문제나, 쿼터니언의 단위 길이 제약 조건과 같은 복잡성을 회피하게 해준다. 칼만 필터는 이러한 수학적으로 다루기 쉬운 유클리드 접선 공간에서 작동하며, 그 결과는 다시 매니폴드 상의 상태에 “더해져” 상태를 보정한다.19 이로 인해 ESKF는 자세 추정 및 내비게이션 문제에 매우 우아하고 강력한 해법을 제공한다.21</li>
</ul>
<p>이처럼 ESKF는 비선형성 문제를 해결하기 위해 ‘분할 정복(divide and conquer)’ 전략을 사용한다고 볼 수 있다. 즉, 전체 비선형 문제를 필터 내에서 한 번에 해결하려 하지 않고, 문제를 두 부분으로 전략적으로 분할한다: 하나는 큰 신호의 비선형 궤적 적분(공칭 상태)이고, 다른 하나는 작은 신호의 선형 확률적 추정(오차 상태 필터)이다. 표준 EKF는 복잡한 궤적 전파와 그로부터의 편차 추정이라는 두 가지 어려운 작업을 하나의 선형화된 프레임워크 안에 혼합한다. 반면, ESKF는 이들이 서로 다른 문제임을 인식한다. 공칭 상태 전파 <span class="math math-inline">x_{nom}(t) = \int f(x_{nom}(\tau), u(\tau)) d\tau</span>는 결정론적 적분 문제로, 필터링 가정 없이 시스템의 거시적인 움직임을 포착한다.23 그 후 칼만 필터는 이 공칭 궤적으로부터의 ‘작은 편차’(</p>
<p><span class="math math-inline">\delta x</span>)를 추정하는 훨씬 간단한 작업을 맡는다. <span class="math math-inline">\delta x</span>가 작기 때문에 그 동역학 <span class="math math-inline">\delta\dot{x} = F \delta x + G w</span>는 거의 선형에 가깝다.22 이러한 분리는 특히 회전에서 강력하다. 공칭 상태(쿼터니언 또는 회전 행렬)는 <span class="math math-inline">SO(3)</span> 매니폴드 위에서 기하학적 속성을 완벽하게 보존하며 적분될 수 있다. 필터는 단지 접선 공간의 간단한 3차원 벡터만 다루면 된다.19 이는 <span class="math math-inline">SO(3)</span> 자체를 선형화하려는 시도에서 발생하는 어색함과 오차를 피하게 해주며, 이것이 바로 내비게이션에서 표준 EKF의 주요 실패 지점 중 하나이다. 따라서 ESKF의 진정한 혁신은 오차 상태 자체라기보다는, 결정론적 비선형 적분과 선형 확률적 추정을 철학적으로 분리한 데 있다.</p>
<h3>2.3 ESKF의 예측 및 업데이트 주기</h3>
<p>ESKF 알고리즘은 다음과 같은 재귀적 주기로 동작한다.</p>
<ol>
<li><strong>예측(Prediction):</strong> 공칭 상태는 완전한 비선형 시스템 모델을 사용하여 시간상으로 전파된다. 동시에, 오차 상태의 공분산은 선형화된 오차 상태 동역학 모델을 사용하여 전파된다.23</li>
<li><strong>업데이트(Update):</strong> 예측된 공칭 상태를 사용하여 측정 잔차(measurement residual)가 계산된다. 이 잔차는 선형 칼만 필터 업데이트 단계에서 사용되어 오차 상태 <span class="math math-inline">\delta x</span>의 추정치를 계산한다.</li>
<li><strong>주입(Injection):</strong> 추정된 오차 <span class="math math-inline">\delta x</span>는 공칭 상태를 보정하기 위해 “주입“되거나 “더해진다” (<span class="math math-inline">x_{nom\_corrected} = x_{nom\_predicted} \oplus \delta x</span>).</li>
<li><strong>리셋(Reset):</strong> 오차 주입 후, 오차 상태의 평균은 0으로 리셋되고, 공분산은 불확실성이 감소했음을 반영하여 업데이트된다.19 이 ‘리셋’ 과정은 다음 주기에서도 ‘작은 오차’ 가정이 유효하도록 보장하는 핵심적인 단계이다.</li>
</ol>
<h2>3. 측정 업데이트를 위한 반복적 개선</h2>
<h3>3.1 반복 확장 칼만 필터(IEKF)의 원리</h3>
<p>ESKF가 프로세스 모델의 비선형성을 효과적으로 다루는 반면, 측정 모델의 비선형성으로 인한 오차는 여전히 남을 수 있다. 이 문제를 해결하기 위해 반복 확장 칼만 필터(Iterated Extended Kalman Filter, IEKF)의 개념이 도입되었다.25 IEKF가 해결하고자 하는 핵심 문제는 측정 선형화 오차이다. 표준 EKF(및 비반복 ESKF)는 측정 함수 <span class="math math-inline">h(x)</span>를 사전(a priori) 상태 추정치 <span class="math math-inline">x̂⁻</span>에서 단 한 번만 선형화한다. 만약 이 사전 추정치가 실제 상태와 멀리 떨어져 있다면, 이 선형화는 매우 부정확할 수 있다.</p>
<p>IEKF의 해법은 업데이트 단계를 ‘반복적으로’ 수행하는 것이다. 단일 시간 단계 내에서, IEKF는 가장 최근에 개선된 상태 추정치를 중심으로 측정 함수를 반복적으로 재선형화한다.21</p>
<h3>3.2 반복을 통한 측정 선형화 오차 감소</h3>
<p>IEKF의 업데이트 과정은 다음과 같이 설명될 수 있다.</p>
<ol>
<li>사전 추정치 <span class="math math-inline">x̂⁻</span>에서 시작한다.</li>
<li>이 지점에서 <span class="math math-inline">h(x)</span>를 선형화하고, 이를 이용해 첫 번째 업데이트된 상태 <span class="math math-inline">x̂⁺_1</span>을 계산한다.</li>
<li>이제 <span class="math math-inline">x̂⁺_1</span>을 새로운 선형화 지점으로 삼아 <span class="math math-inline">h(x)</span>를 다시 선형화하고, 이를 이용해 두 번째 업데이트된 상태 <span class="math math-inline">x̂⁺_2</span>를 계산한다.</li>
<li>이 과정을 정해진 횟수만큼 반복하거나, 상태 추정치의 변화가 무시할 수 있을 만큼 작아질 때까지 계속한다.26</li>
</ol>
<p>이 반복적인 과정은 실제 사후 상태에 더 가까운, 더 나은 선형화 지점을 효과적으로 찾아내며, 이를 통해 선형화 오차를 줄이고 훨씬 더 정확한 상태 추정치를 산출한다.27</p>
<h3>3.3 가우스-뉴턴 최적화와의 유사성</h3>
<p>IEKF의 반복적 업데이트 과정은 상태의 최대 사후 확률(Maximum A Posteriori, MAP) 추정치를 찾기 위해 가우스-뉴턴(Gauss-Newton) 최적화 방법을 사용하는 것으로 해석될 수 있다.21 각 시간 단계에서 IEKF는 사전 정보(예측된 상태)와 새로운 측정값 사이의 균형을 맞추는 가중 최소 제곱(weighted least squares) 문제를 반복적으로 푼다.26 이는 IEKF의 효과에 대한 강력한 이론적 근거를 제공한다.</p>
<p>ESKF와 IEKF는 서로 다른 오차의 원인을 해결한다는 점에서 상호 보완적인 관계에 있다. ESKF는 주로 프로세스 모델의 비선형성, 특히 기하학적 제약 조건에 초점을 맞추는 반면, IEKF는 배타적으로 측정 모델의 비선형성을 목표로 한다. 예를 들어, 거의 선형적인 운동 동역학(예: 등속도 운동)을 가지지만 매우 비선형적인 측정 센서(예: 랜드마크를 관측하는 카메라)를 가진 로봇을 생각해보자. 이 경우, 프로세스 모델 <span class="math math-inline">f(x)</span>가 이미 선형에 가깝기 때문에 ESKF는 EKF에 비해 큰 이점을 제공하지 못할 수 있다. 주요 오차의 원인은 <span class="math math-inline">h(x)</span>의 선형화일 것이다. 그러나 IEKF는 이 상황에서 매우 효과적일 것이다. IEKF는 비선형적인 카메라 투영 모델에 더 잘 부합하도록 상태 추정치를 반복적으로 개선하여 훨씬 더 정확한 업데이트를 이끌어낼 것이다. 반대로, 매우 비선형적인 동역학(예: 빠르게 회전하는 우주선)을 가지지만 선형적인 측정(예: 각속도의 직접 측정)을 하는 시스템의 경우, ESKF는 <span class="math math-inline">SO(3)</span> 기하학을 다루는 데 필수적이지만 IEKF는 아무런 이점을 제공하지 못할 것이다. 이는 ESKF와 IEKF가 경쟁적인 아이디어가 아니라, 전체 문제의 서로 다른 측면을 해결하는 직교적인 개선책임을 보여준다. 이러한 통찰은 두 기법을 결합하여 두 종류의 비선형성 문제를 동시에 해결하고자 하는 ESIKF의 등장을 직접적으로 동기 부여한다.</p>
<h2>4. 오차 상태 반복 칼만 필터(ESIKF): 두 기법의 통합</h2>
<h3>4.1 핵심 원리: 오차 상태에 대한 반복적 개선 적용</h3>
<p>오차 상태 반복 칼만 필터(Error-State Iterated Kalman Filter, ESIKF)는 앞서 논의된 두 개념의 논리적 통합체이다. ESIKF는 프로세스 모델의 비선형성과 기하학적 제약 조건을 처리하기 위해 오차 상태 공식(ESKF)을 사용하고, 측정 모델의 비선형성을 처리하기 위해 반복적 업데이트 루프(IEKF)를 통합한다.19</p>
<p>여기서 핵심적인 차이점은 반복이 ‘오차 상태’ <span class="math math-inline">\delta x</span>에 대해 이루어진다는 것이다. 즉, 최적화 과정이 제약 조건이 없고 수학적으로 잘 정의된 유클리드 접선 공간에서 수행된다. 이는 전체 상태 매니폴드 위에서 직접 반복을 수행하는 것보다 훨씬 안정적이고 수학적으로 견고한 접근 방식이다.</p>
<h3>4.2 상세 수학적 유도 과정</h3>
<p>이 절은 ESIKF 알고리즘 전체를 상세한 수식과 함께 제시하는 본 안내서의 기술적 핵심이다.19</p>
<h4>4.2.1 상태 표현</h4>
<ul>
<li><strong>공칭 상태 (Nominal State) <span class="math math-inline">x</span></strong>: 시스템의 전체 상태를 나타내며, 일반적으로 위치, 속도, 자세, 센서 바이어스 등을 포함한다. 예를 들어, <span class="math math-inline">x =^T</span> 로 표현될 수 있으며, 여기서 <span class="math math-inline">p</span>는 위치, <span class="math math-inline">v</span>는 속도, <span class="math math-inline">q</span>는 자세를 나타내는 쿼터니언, <span class="math math-inline">b_a</span>와 <span class="math math-inline">b_g</span>는 각각 가속도계와 자이로스코프 바이어스이다. 이 상태는 <span class="math math-inline">R^n \times SO(3)</span>와 같은 매니폴드 상에 존재한다.</li>
<li><strong>오차 상태 (Error State) <span class="math math-inline">\delta x</span></strong>: 공칭 상태에 대한 작은 오차를 나타내며, 벡터 공간에 존재한다. 예를 들어, <span class="math math-inline">\delta x =^T</span> 로 표현될 수 있으며, 여기서 <span class="math math-inline">\delta \theta</span>는 자세 오차를 나타내는 3차원 회전 벡터이다.</li>
</ul>
<h4>4.2.2 예측 단계 (Prediction Step)</h4>
<ol>
<li><strong>공칭 상태 전파</strong>: 이전 시간 단계 <span class="math math-inline">k-1</span>의 사후(posteriori) 공칭 상태 <span class="math math-inline">x_{k-1}^+</span>와 제어 입력 <span class="math math-inline">u_{k-1}</span>을 사용하여 현재 시간 단계 <span class="math math-inline">k</span>의 사전(a priori) 공칭 상태 <span class="math math-inline">x_k^-</span>를 계산한다. 이는 완전한 비선형 동역학 모델 <span class="math math-inline">f(\cdot)</span>을 직접 적분하여 수행된다.23<br />
<span class="math math-display">
x_k^- = f(x_{k-1}^+, u_{k-1})
</span><br />
<strong>오차 공분산 전파</strong>: 오차 상태의 공분산 행렬 <span class="math math-inline">P</span>를 전파한다. 이는 선형화된 오차 동역학의 자코비안 <span class="math math-inline">F_x</span>와 잡음의 자코비안 <span class="math math-inline">F_w</span>를 사용하여 계산된다. <span class="math math-inline">Q</span>는 프로세스 잡음의 공분산이다.<br />
<span class="math math-display">
P_k^- = F_x P_{k-1}^+ F_x^T + F_w Q F_w^T
</span><br />
반복적 업데이트 단계 (Iterative Update Step)</li>
</ol>
<p>측정값 <span class="math math-inline">z_k</span>가 주어지면, 최적의 오차 보정치 <span class="math math-inline">\delta x</span>를 찾기 위해 다음 과정을 <span class="math math-inline">j=1, \dots, N</span>회 반복한다. 이 과정은 본질적으로 가우스-뉴턴 최적화를 통해 사후 확률을 최대화하는 <span class="math math-inline">\delta x</span>를 찾는 것이다.26</p>
<ol>
<li>
<p><strong>초기화</strong>: 반복을 위한 초기 오차 상태를 0으로 설정한다: <span class="math math-inline">\delta x_0 = \mathbf{0}</span>.</p>
</li>
<li>
<p><strong>반복 루프 (<span class="math math-inline">j=1, \dots, N</span>)</strong>:</p>
</li>
</ol>
<ul>
<li><strong>선형화 지점 계산</strong>: 현재 반복 단계의 선형화 지점이 될 공칭 상태를 계산한다. 이는 사전 공칭 상태 <span class="math math-inline">x_k^-</span>에 이전 반복 단계의 오차 추정치 <span class="math math-inline">\delta x_{j-1}</span>를 더하여 얻는다.<br />
<span class="math math-display">
   x_j = x_k^- \oplus \delta x_{j-1}
</span><br />
<strong>측정 자코비안 계산</strong>: 측정 모델 <span class="math math-inline">h(\cdot)</span>을 현재 오차 상태에 대해 선형화하여 자코비안 <span class="math math-inline">H_j</span>를 계산한다.<br />
<span class="math math-display">
   H_j = \left. \frac{\partial h(x_k^- \oplus \delta x)}{\partial \delta x} \right|_{\delta x = \delta x_{j-1}}
</span><br />
<strong>칼만 이득 계산</strong>: 현재 반복 단계의 칼만 이득 <span class="math math-inline">K_j</span>를 계산한다. <span class="math math-inline">R</span>은 측정 잡음의 공분산이다.<br />
<span class="math math-display">
   K_j = P_k^- H_j^T (H_j P_k^- H_j^T + R)^{-1}
</span><br />
<strong>오차 상태 개선</strong>: 가우스-뉴턴 업데이트 공식을 사용하여 오차 상태 추정치를 개선한다. 이 공식은 예측된 측정값과 실제 측정값 사이의 차이(innovation)를 최소화하도록 <span class="math math-inline">\delta x</span>를 조정한다.<br />
<span class="math math-display">
   \delta x_j = K_j (z_k - h(x_j)) + (K_j H_j - I) \delta x_{j-1}
</span><br />
일부 문헌에서는 더 단순화된 형태를 사용하기도 하지만, 위 공식은 가우스-뉴턴 최적화 문제의 해에 더 가깝다.26</li>
</ul>
<h4>4.2.3 오차 주입 및 리셋</h4>
<ol>
<li><strong>오차 주입</strong>: 반복이 종료된 후, 최종적으로 계산된 최적의 오차 상태 <span class="math math-inline">\delta x_N</span>을 사전 공칭 상태에 주입하여 사후 공칭 상태 <span class="math math-inline">x_k^+</span>를 얻는다.19<br />
<span class="math math-display">
x_k^+ = x_k^- \oplus \delta x_N
</span><br />
<strong>공분산 업데이트</strong>: 최종 칼만 이득 <span class="math math-inline">K_N</span>과 자코비안 <span class="math math-inline">H_N</span>을 사용하여 사후 공분산 <span class="math math-inline">P_k^+</span>를 계산한다.<br />
<span class="math math-display">
P_k^+ = (I - K_N H_N) P_k^-
</span><br />
<strong>오차 상태 리셋</strong>: 다음 시간 단계를 위해 오차 상태의 평균은 다시 <span class="math math-inline">\mathbf{0}</span>으로 리셋된다.</li>
</ol>
<p>ESIKF 업데이트 과정은 단순한 보정이 아니라, 지역적 최적화 문제의 해를 구하는 과정이다. 각 측정 업데이트는 사전 확률과 측정 가능도(likelihood)의 곱으로 정의되는 사후 확률을 최대화하는, 즉 지역적인 비용 함수 <span class="math math-inline">J(\delta x) = ||\delta x_{prior} - \delta x||^2_{P^{-1}} + ||z - h(x \oplus \delta x)||^2_{R^{-1}}</span>를 최소화하는 오차 상태 <span class="math math-inline">\delta x</span>를 찾는 과정으로 볼 수 있다. 가우스-뉴턴 방법은 이 비선형 최소 제곱 문제의 해를 구하기 위해 사용되며, 각 반복은 이 문제의 선형화된 버전을 푸는 것과 같다. 따라서 ESIKF는 종종 별개의 접근법으로 여겨지는 필터링(칼만)과 최적화(번들 조정)의 세계를 잇는 다리 역할을 한다.29 ESIKF는 본질적으로 각 단계에서 ‘지연 없는(zero-lag)’ 최적화를 수행하는 것으로 볼 수 있으며, 이는 최첨단 VIO 시스템에서 사용되는 최적화 기반의 ‘슬라이딩 윈도우’ 기법과 개념적으로 연결된다.29</p>
<h3>4.3 매니폴드 상의 상태 처리 (리 이론)</h3>
<p>ESIKF가 자세와 같은 매니폴드 상의 상태를 우아하게 처리할 수 있는 비결은 리 이론(Lie Theory)에 기반한 연산자를 사용하는 데 있다.19</p>
<ul>
<li>
<p><strong>박스플러스 연산자 (Boxplus, <span class="math math-inline">\oplus</span>)</strong>: 이 연산은 매니폴드 상의 상태(리 그룹 원소)를 접선 공간의 작은 벡터(리 대수 원소)로 업데이트하는 과정을 나타낸다. 예를 들어, 회전 행렬 <span class="math math-inline">R_{old} \in SO(3)</span>를 오차 회전 벡터 <span class="math math-inline">\delta \theta \in \mathfrak{so}(3)</span>로 업데이트하는 것은 다음과 같이 표현된다.<br />
<span class="math math-display">
R_{new} = R_{old} \otimes \text{Exp}(\delta \theta)
</span><br />
여기서 <span class="math math-inline">\text{Exp}(\cdot)</span>는 리 대수에서 리 그룹으로의 지수 사상(exponential map)이며, 회전 벡터를 회전 행렬로 변환한다.21</p>
</li>
<li>
<p><strong>박스마이너스 연산자 (Boxminus, <span class="math math-inline">\ominus</span>)</strong>: 이 연산은 두 매니폴드 상태 간의 차이를 접선 공간의 최소 표현 벡터로 계산한다. 예를 들어, 두 회전 행렬 <span class="math math-inline">R_1, R_2</span> 사이의 차이는 다음과 같다.<br />
<span class="math math-display">
\delta \theta = \text{Log}(R_1^T R_2)
</span><br />
여기서 <span class="math math-inline">\text{Log}(\cdot)</span>는 리 그룹에서 리 대수로의 로그 사상(logarithm map)이다.</p>
</li>
</ul>
<p>이러한 연산자를 사용함으로써, 상태 추정치는 항상 올바른 매니폴드 상에 머무르게 된다 (예: 회전 행렬은 항상 직교성을 유지하고 행렬식이 +1이 됨). 이는 표준 EKF가 보장할 수 없는 중요한 속성이다.19</p>
<h2>5. 성능 분석 및 구현</h2>
<h3>5.1 계산 복잡도</h3>
<p>필터의 계산 복잡도는 실시간 적용 가능성을 결정하는 중요한 요소이다.</p>
<ul>
<li>표준 EKF 또는 ESKF의 계산 비용은 주로 상태 차원이 <span class="math math-inline">n</span>일 때 <span class="math math-inline">n \times n</span> 크기의 행렬 곱셈이 포함된 공분산 전파 및 업데이트 단계에 의해 결정된다. 따라서 단계별 복잡도는 <span class="math math-inline">O(n^2)</span>이다.32</li>
<li>ESIKF는 업데이트 단계를 <span class="math math-inline">k</span>번 반복하므로, 그 복잡도는 <span class="math math-inline">O(k \cdot n^2)</span>가 된다. 여기서 <span class="math math-inline">k</span>는 반복 횟수로, 보통 3~5 정도의 작은 상수이므로 전체 복잡도는 여전히 EKF와 같은 차수로 간주되지만, 상수 인수가 더 크다.34</li>
<li>이는 UKF와 비교할 때 중요한 지점이다. UKF의 복잡도는 구현에 따라 <span class="math math-inline">O(n^3)</span> 또는 <span class="math math-inline">O(n^2)</span> 스케일을 가지므로, <span class="math math-inline">k</span>가 작다면 매우 고차원 상태(예: SLAM)에 대해 ESIKF가 더 효율적일 수 있다.34</li>
</ul>
<p>시스템 설계자는 “계산 예산” 내에서 필터의 복잡도와 반복 횟수 사이의 트레이드오프를 고려해야 한다. 예를 들어, 200Hz IMU에 대해 업데이트 단계당 5ms의 고정된 시간 예산이 있다고 가정해보자. 한 가지 선택지는 <span class="math math-inline">O(n^3)</span>의 비용이 드는 UKF를 사용하는 것이다.34 이는 예산을 모두 소진할 수 있지만, 자코비안 계산을 피하고 더 나은 통계적 근사를 통해 한 번에 좋은 추정치를 제공한다. 다른 선택지는 <span class="math math-inline">k \cdot O(n^2)</span> 비용의 ESIKF를 사용하는 것이다. 상태 차원 <span class="math math-inline">n</span>이 매우 크다면 <span class="math math-inline">n^2</span>은 <span class="math math-inline">n^3</span>보다 훨씬 작으므로, 동일한 5ms 예산 내에서 여러 번의 반복(<span class="math math-inline">k &gt; 1</span>)이 가능할 수 있다. 이 선택은 비선형성의 ’근원’에 따라 달라진다. 비선형성이 부드럽고 2차 다항식으로 잘 근사된다면 UKF의 통계적 접근 방식이 더 효율적일 수 있다.15 만약 비선형성이 급격하지만 상태 차원 <span class="math math-inline">n</span>이 매우 크다면(예: 많은 랜드마크를 포함하는 SLAM), ESIKF의 <span class="math math-inline">O(n^2)</span> 스케일링이 더 매력적이며, 몇 번 반복하는 것이 UKF의 <span class="math math-inline">O(n^3)</span> 비용보다 저렴할 수 있다.33 이는 필터 선택이 단지 정확도 문제가 아니라, 문제의 ’구조’와 알고리즘의 계산 스케일링 법칙에 관한 문제임을 보여준다. ESIKF는 UKF와 달리 정확도와 계산량 사이의 균형을 조절할 수 있는 튜닝 노브(<span class="math math-inline">k</span>)를 제공한다.</p>
<h3>5.2 수렴 및 안정성</h3>
<ul>
<li>
<p><strong>수렴성</strong>: ESIKF의 반복 과정은 항상 수렴이 보장되지는 않는다. 특히 초기 추정치가 매우 나쁘거나 시스템이 극도로 비선형적인 경우 발산할 수 있다.12 하지만 ESIKF는 일반적으로 EKF보다 더 정확한 ESKF의 예측 상태에서 시작하기 때문에, 수렴 영역(basin of attraction) 내에 있을 가능성이 더 높다.</p>
</li>
<li>
<p><strong>안정성</strong>: ESIKF는 반복적인 개선 과정을 통해 선형화 오차를 줄여주기 때문에 EKF나 ESKF보다 발산에 대해 일반적으로 더 강건하다.12 선형화 오차는 필터 불안정성의 주요 원인 중 하나이기 때문이다. 그러나 모든 필터와 마찬가지로, 부정확한 모델 파라미터와 잡음 공분산 행렬(</p>
</li>
</ul>
<p><span class="math math-inline">Q</span>와 <span class="math math-inline">R</span>)에 민감하다.12 이러한 행렬을 정밀하게 튜닝하는 것은 필터 성능에 매우 중요하다. 또한, 필터에 좋은 시작점을 제공하기 위한 강건한 초기화 절차는 수렴에 필수적이다.37</p>
<h3>5.3 비선형성에 대한 강건성</h3>
<p>이는 ESIKF의 핵심 강점이다. 측정 함수를 반복적으로 재선형화함으로써, ESIKF는 EKF나 ESKF와 같은 단일 선형화 필터보다 훨씬 강한 비선형성을 처리할 수 있다.21 구체적인 예로, 로봇이 특정 특징점(feature)에 매우 가깝게 이동하는 VIO 시스템을 들 수 있다. 이 경우, 원근 투영(perspective projection) 모델은 매우 비선형적이 된다. EKF/ESKF는 부정확한 초기 선형화로 인해 발산할 수 있지만, ESIKF는 측정을 올바르게 설명하는 상태를 찾기 위해 반복적으로 추정치를 개선함으로써 우수한 강건성을 보인다.28</p>
<h2>6. 대안 필터와의 비교 분석</h2>
<h3>6.1 ESIKF 대 EKF/ESKF</h3>
<ul>
<li><strong>장점</strong>: ESIKF는 측정 모델이 매우 비선형적일 때 EKF/ESKF의 업데이트 단계에서 발생하는 주요 오차 원인을 완화하므로 훨씬 높은 정확도를 제공한다.21</li>
<li><strong>비용</strong>: 반복 루프로 인해 계산 비용이 더 높다는 단점이 있다.</li>
<li><strong>사용 시점</strong>: 측정 정확도가 매우 중요하고 측정 모델이 비선형성의 주된 원인인 경우(예: 비전 기반 추정)에 권장된다.</li>
</ul>
<h3>6.2 ESIKF 대 무향 칼만 필터(UKF)</h3>
<p>이는 비선형성을 다루는 두 가지 다른 철학 간의 미묘한 비교이다.</p>
<ul>
<li><strong>선형화 방식</strong>: ESIKF는 반복적인 해석적 선형화(자코비안)를 사용한다. 반면 UKF는 무향 변환(unscented transform)을 통한 통계적 선형화를 사용한다. UKF는 상태 분포를 대표하는 시그마 포인트(sigma points)를 결정론적으로 샘플링하고, 이 포인트들을 실제 비선형 함수에 직접 통과시켜 사후 분포를 근사한다.15</li>
<li><strong>정확도</strong>: UKF는 일반적으로 가우시안 입력에 대해 3차 정확도를 가지는 반면, EKF는 1차 정확도에 그친다. ESIKF는 EKF를 개선하며, 비선형성의 종류와 반복 횟수에 따라 UKF에 근접하거나 능가하는 정확도를 보일 수 있다.</li>
<li><strong>구현</strong>: UKF는 해석적인 자코비안 유도를 필요로 하지 않기 때문에 구현이 더 쉬운 경우가 많다.38 ESIKF는 자코비안 계산과 반복 루프를 모두 필요로 하므로 올바르게 구현하기가 가장 복잡할 수 있다.19</li>
<li><strong>계산 비용</strong>: 앞서 논의했듯이 ESIKF는 <span class="math math-inline">O(k \cdot n^2)</span>이고 UKF는 종종 <span class="math math-inline">O(n^3)</span>이다.34 따라서 고차원 상태에서는 ESIKF가 더 빠를 수 있다.</li>
<li><strong>리 그룹 적용</strong>: 두 필터 모두 리 그룹에서 작동하도록 수정되었다. UKF-LG는 리 대수에서 시그마 포인트를 생성하고 이를 다시 매니폴드로 사상(retract)하는 특별한 처리가 필요하다.40 반면, ESIKF의 오차 상태 공식은 자연스럽게 리 대수에서 작동하므로 더 직접적이고 우아한 접근 방식으로 볼 수 있다.19</li>
</ul>
<p>다음 표는 주요 비선형 칼만 필터 변종들의 핵심적인 특징을 요약하여 비교한다. 상태 추정 실무자나 연구자는 어떤 필터를 구현할지 결정해야 하는 상황에 끊임없이 직면한다. 이 표는 가장 일반적인 비선형 필터링 옵션 간의 중요한 트레이드오프를 한눈에 파악할 수 있는 밀도 높은 요약을 제공하며, 안내서 전체의 복잡한 논의를 실용적인 의사결정 도구로 압축한다.</p>
<table><thead><tr><th>특징</th><th>확장 칼만 필터 (EKF)</th><th>오차 상태 칼만 필터 (ESKF)</th><th>무향 칼만 필터 (UKF)</th><th>오차 상태 반복 칼만 필터 (ESIKF)</th></tr></thead><tbody>
<tr><td><strong>선형화 방식</strong></td><td>1차 테일러 (전체 상태)</td><td>1차 테일러 (오차 상태)</td><td>무향 변환 (통계적)</td><td>반복적 1차 테일러 (오차 상태)</td></tr>
<tr><td><strong>상태 표현</strong></td><td>전체 상태 (벡터 공간)</td><td>공칭 (매니폴드) + 오차 (벡터)</td><td>전체 상태 (벡터/매니폴드)</td><td>공칭 (매니폴드) + 오차 (벡터)</td></tr>
<tr><td><strong>정확도 (고 비선형성)</strong></td><td>낮음</td><td>중간</td><td>높음</td><td>매우 높음</td></tr>
<tr><td><strong>계산 비용</strong></td><td><span class="math math-inline">O(n^2)</span></td><td><span class="math math-inline">O(n^2)</span></td><td><span class="math math-inline">O(n^3)</span> 또는 <span class="math math-inline">O(n^2L^2)</span></td><td><span class="math math-inline">O(k \cdot n^2)</span> (k=반복 횟수)</td></tr>
<tr><td><strong>구현 난이도</strong></td><td>중간 (자코비안 필요)</td><td>복잡 (매니폴드 연산)</td><td>중간 (자코비안 불필요)</td><td>매우 복잡 (반복 + 매니폴드)</td></tr>
<tr><td><strong>강건성</strong></td><td>발산 경향 있음</td><td>EKF보다 강건함</td><td>일반적으로 강건함</td><td>측정 비선형성에 매우 강건함</td></tr>
</tbody></table>
<h2>7. 최신 로보틱스 및 내비게이션 응용</h2>
<h3>7.1 시각-관성 주행 거리 측정(VIO)</h3>
<p>VIO는 ESIKF의 주요 응용 분야 중 하나이다. 관성 측정 장치(IMU)는 고주파의 프로세스 모델을 제공하고, 카메라는 비선형적인 측정값을 제공한다. 이 두 센서의 융합은 일반적으로 ‘강결합(tightly-coupled)’ 방식으로 이루어지는데, 이는 원시 특징점 측정값이 필터 업데이트 단계에 직접 사용됨을 의미한다.19 카메라 투영 모델은 매우 비선형적이므로, ESIKF의 반복적 업데이트는 높은 정확도를 달성하는 데 매우 유용하다.28</p>
<p>주요 오픈소스 VIO 프레임워크에서의 필터 선택은 ESIKF의 위치를 이해하는 데 중요한 통찰을 제공한다.</p>
<ul>
<li><strong>VINS-Mono</strong>: 슬라이딩 윈도우 최적화(sliding-window optimization) 방식을 사용하는데, 이는 개념적으로 배치(batch) ESIKF와 유사하다. 상태와 측정값 집합을 함께 최적화함으로써 여러 번 재선형화를 효과적으로 수행한다.29 이는 ESIKF가 재귀적 프레임워크 내에서 모방하려는 최적화 기반 접근법의 추세를 보여준다.</li>
<li><strong>OKVIS</strong>: 이 또한 키프레임 기반 비선형 최적화 접근법을 사용하며, 오래된 상태를 주변화(marginalize)하여 계산 복잡도를 유한하게 유지한다.30 필터링보다 최적화를 선택한 이유는 선형화 오차에 대한 높은 정확도와 강건성 때문이다.30</li>
<li><strong>MSCKF (Multi-State Constraint Kalman Filter)</strong>: 특징점을 상태 벡터에 추가하지 않음으로써 복잡도를 낮게 유지하는 영향력 있는 EKF 기반 VIO이다. ESIKF는 처리하는 특징점에 대해 더 높은 정확도를 목표로 하는 대안으로 볼 수 있다.</li>
</ul>
<p>필터링(ESIKF 등)과 최적화(VINS-Mono 등) 사이의 선택은 이분법적인 것이 아니라 스펙트럼 상의 문제이다. ESIKF는 이 스펙트럼 위에서 두 세계의 장점, 즉 필터의 재귀적 효율성과 최적화기의 재선형화 정확도를 모두 얻으려는 지점을 대표한다. 순수 필터(EKF)는 측정값을 한 번 처리하고 버리므로 빠르지만, 선형화와 정보 손실로 인해 차선책이 된다. 반면, 전체 배치 최적화기(오프라인 SLAM)는 모든 측정값을 유지하고 거대한 비선형 최소 제곱 문제를 풀므로 가장 정확하지만 실시간이 아니다. 슬라이딩 윈도우 최적화기(VINS-Mono, OKVIS)는 이 둘의 타협점으로, 최근의 키프레임과 측정값 윈도우에 대해 최적화를 수행하고 오래된 정보를 주변화하여 유한한 복잡도를 유지한다.29 ESIKF는 ’크기 1의 슬라이딩 윈도우’로 볼 수 있다. 각 시간 단계에서 사전 정보와 현재 측정값을 포함하는 작은 지역적 최적화(반복 루프)를 수행한다. 이러한 관점은 ESIKF가 현대적인 최적화 방법에 비해 ‘오래된’ 기술이 아님을 보여준다. 오히려, 재귀적이고 지연 없는 비선형 최소 제곱 추정기의 매우 효율적인 구현이다. 이는 더 큰 최적화 윈도우를 관리하는 계산 오버헤드가 감당하기 어려운 시스템에서 ESIKF가 계속해서 중요하게 사용되는 이유를 설명한다.28</p>
<h3>7.2 라이다-관성 주행 거리 측정 및 SLAM</h3>
<p>ESKF/ESIKF는 자율주행차에서 라이다 기반 위치 측정 결과와 IMU 및 차량 상태 측정을 융합하여 강건하고 정밀한 위치를 추정하는 데 사용된다.48 IMU 전파는 고품질의 모션 사전 정보를 제공하여 라이다 스캔 매칭 알고리즘을 돕고, 라이다는 절대적인 드리프트 보정을 제공한다. ESKF 프레임워크는 이러한 상호 보완적인 센서 양식을 융합하는 데 이상적이다.48</p>
<h3>7.3 일반적인 센서 융합 및 보정</h3>
<p>이러한 원리는 GPS, 휠 인코더, 지자기 센서 등 다양한 센서의 융합으로 확장될 수 있다.1 필터는 각 정보 소스를 불확실성(<span class="math math-inline">R</span> 행렬)에 따라 가중치를 부여하여 결합하는 원칙적인 방법을 제공한다.51</p>
<p>또한, ESIKF는 센서 외부 파라미터(예: 카메라와 IMU 간의 변환)의 온라인 추정에도 사용될 수 있다. 이러한 파라미터는 상태 벡터에 추가되어 내비게이션 상태와 함께 추정된다. 이를 위해서는 관측 가능성(observability)을 보장하기 위한 충분한 센서 움직임이 필요하다.19 유명한 오프라인 보정 도구인 Kalibr는 종종 배치 최적화를 사용하는데, 이 또한 ESIKF와 원리를 공유한다.54</p>
<h2>8. 결론 및 향후 연구 방향</h2>
<h3>8.1 ESIKF의 강점과 약점 요약</h3>
<ul>
<li><strong>강점</strong>: 비선형 측정 모델을 가진 시스템에 대한 높은 정확도, 매니폴드 상태(회전)의 강건한 처리, 필터링과 최적화 사이의 개념적으로 우아한 연결고리.</li>
<li><strong>약점</strong>: 높은 구현 복잡도, 비반복 필터보다 높은 계산 비용, 엄밀한 의미에서 수렴이 보장되지 않음.</li>
</ul>
<h3>8.2 실무자를 위한 권장 사항</h3>
<ul>
<li><strong>ESIKF 선택 시점</strong>: (1) 측정 모델이 상당한 비선형성의 주요 원인일 때, (2) 상태가 3차원 자세를 포함할 때, (3) 추가적인 계산 및 구현 비용을 정당화할 만큼 높은 정확도가 중요할 때, (4) 재귀적 프레임워크에서 작업해야 하며 완전한 슬라이딩 윈도우 최적화기를 사용할 여유가 없을 때.</li>
<li><strong>대안 고려 시점</strong>: (1) 시스템이 약한 비선형성만 가질 때 (EKF/ESKF로 충분), (2) 자코비안을 사용할 수 없거나 유도하기 어려울 때 (UKF가 더 나음), (3) 상태 차원이 작고 프로세스 모델이 매우 비선형적일 때 (UKF가 더 간단하고 효과적인 선택일 수 있음), (4) 완전한 최적화 기반 접근이 가능하고 선호될 때 (VINS-Mono/OKVIS 등).</li>
</ul>
<h3>8.3 향후 연구 방향</h3>
<ul>
<li><strong>적응형 ESIKF (Adaptive ESIKF)</strong>: 변화하는 환경에 대응하기 위해 잡음 공분산 행렬(<span class="math math-inline">Q</span>와 <span class="math math-inline">R</span>)을 온라인으로 적응적으로 조정하는 기술을 통합하는 연구. 예를 들어, 퍼지 추론 시스템(FIS)을 사용하여 동적으로 변하는 잡음 특성을 처리할 수 있다.58</li>
<li><strong>하이브리드 AI/ESIKF 시스템</strong>: 신경망과 같은 머신러닝 모델을 사용하여 복잡한 시스템 동역학이나 센서 잡음 특성을 학습하고, 이 정보를 ESIKF 프레임워크에 공급하는 연구. 예를 들어, RBF 신경망이 모델링되지 않은 동역학을 보상하여 필터의 혁신 항(innovation term)을 개선할 수 있다.13</li>
<li><strong>수치적으로 안정적인 구현</strong>: 제곱근 필터링(Square-Root Filtering, SRF) 기법을 사용하여 공분산 행렬의 수치적 안정성을 향상시키는 연구. 이는 특히 단정밀도 부동소수점 연산을 사용하는 자원 제약적인 하드웨어에서 중요하다.29 이는 정확도, 강건성, 수치적 안정성 측면에서 모든 장점을 결합한 ’제곱근 ESIKF(Square-Root ESIKF)’의 개발로 이어질 수 있다.</li>
</ul>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>