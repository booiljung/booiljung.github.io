<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:확장 칼만 필터(EKF)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>확장 칼만 필터(EKF)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">센서 (Sensors)</a> / <a href="index.html">필터 & 스무딩</a> / <span>확장 칼만 필터(EKF)</span></nav>
                </div>
            </header>
            <article>
                <h1>확장 칼만 필터(EKF)</h1>
<h2>1. 칼만 필터의 한계와 확장 칼만 필터의 탄생</h2>
<h3>1.1 되짚어보기: 선형 칼만 필터(KF)의 완벽한 세계</h3>
<p>선형 칼만 필터(Linear Kalman Filter, KF)는 ‘추정(Estimation)’ 문제에 있어 거의 표준과 같은 알고리즘이다. 하지만 이 강력한 도구는 ’선형(Linear)’이라는 엄격한 조건이 붙은 세계에서만 최적의 성능을 발휘한다.1 선형 칼만 필터의 핵심은 두 가지 단계, 예측(Prediction)과 업데이트(Update)의 끝없는 재귀적 반복에 있다.</p>
<ul>
<li><strong>예측 단계:</strong> 시스템의 동역학 모델(dynamic model)을 사용하여 이전 상태로부터 현재 상태를 추정한다. 예를 들어, “이전 위치와 속도를 보니, 1초 뒤에는 저기쯤 가 있겠군” 하고 예측하는 것이다. 이 단계에서는 시스템의 불확실성(프로세스 노이즈) 때문에 추정치의 불확실성(오차 공분산)이 증가한다.</li>
<li><strong>업데이트 단계:</strong> 센서로부터 실제 측정값을 받아서, 예측이 얼마나 빗나갔는지 확인하고 이를 보정한다. “예측은 저기였는데, 센서를 보니 실제로는 여기네. 예측과 측정값 사이의 적절한 지점으로 최종 추정치를 수정해야겠다“고 결정하는 것이다. 이 과정에서 외부 정보를 얻었기 때문에 추정치의 불확실성은 다시 감소한다.2</li>
</ul>
<p>이 과정이 재귀적(recursive)이라는 점은 칼만 필터의 가장 큰 효율성 중 하나다. 과거의 모든 데이터를 저장하고 매번 다시 계산할 필요 없이, 바로 직전 스텝의 추정값(상태와 공분산)만 있으면 현재 상태를 추정할 수 있다.3 이는 메모리 사용량이 적고 계산 속도가 빨라 실시간 시스템에 매우 적합하다는 의미다.</p>
<p>하지만 이 모든 아름다운 과정은 두 가지 핵심적인 가정 위에 세워져 있다. 첫째, 시스템의 움직임(상태 전이)과 측정 과정이 모두 행렬 곱으로 표현되는 선형 관계여야 한다(<span class="math math-inline">\mathbf{x}_k = \mathbf{A}\mathbf{x}_{k-1} + \mathbf{B}\mathbf{u}_{k-1}</span>, <span class="math math-inline">\mathbf{z}_k = \mathbf{H}\mathbf{x}_k</span>). 둘째, 시스템 모델의 불확실성(프로세스 노이즈)과 측정값의 불확실성(측정 노이즈)이 모두 평균이 0인 가우시안 분포(정규 분포)를 따라야 한다.1</p>
<h3>1.2 현실의 벽: 비선형성이 가우시안 분포를 파괴할 때</h3>
<p>문제는 현실 세계가 선형적이지 않다는 점이다.1 자율주행 자동차가 코너를 도는 움직임, 로봇팔이 관절을 꺾어 물체를 집는 동작, 심지어 레이더 센서가 물체의 위치를 측정하는 방식까지, 그 어떤 것도 완벽한 선형 관계로 설명되지 않는다. 예를 들어, 레이더는 물체까지의 거리(<span class="math math-inline">\rho</span>)와 방위각(<span class="math math-inline">\phi</span>)을 측정하는데, 이를 직교 좌표계의 위치 (<span class="math math-inline">p_x, p_y</span>)로 변환하려면 <span class="math math-inline">\rho = \sqrt{p_x^2 + p_y^2}</span>나 <span class="math math-inline">\phi = \operatorname{atan2}(p_y, p_x)</span>와 같은 삼각함수와 제곱근이 포함된 비선형 함수가 필요하다.5</p>
<p>선형 칼만 필터의 수학적 아름다움과 최적성은 ’가우시안 분포의 보존’이라는 특성에서 기인한다. 가우시안 분포를 따르는 확률 변수를 선형 변환(행렬 곱)하면, 그 결과 역시 가우시안 분포를 유지한다. 덕분에 우리는 상태를 평균과 공분산만으로 완벽하게 표현하고 추적할 수 있다.4 하지만 이 가우시안 분포가 비선형 함수를 통과하는 순간, 그 결과는 더 이상 아름다운 종 모양의 가우시안 분포가 아니라, 찌그러지고 비대칭적인 복잡한 형태의 분포로 변해버린다.4 이렇게 되면 평균과 공분산만으로는 상태의 불확실성을 제대로 표현할 수 없게 되고, 선형 칼만 필터의 수학적 기반이 송두리째 흔들리게 된다.6 이것이 바로 확장 칼만 필터가 해결해야만 하는 근본적인 문제다.</p>
<h3>1.3 EKF의 접근법: ‘순간의’ 선형성으로 비선형을 길들이다</h3>
<p>확장 칼만 필터(Extended Kalman Filter, EKF)의 핵심 아이디어는 매우 직관적이다. “전체 곡선을 한 번에 다룰 수 없다면, 우리가 관심 있는 한 지점 근처에서 아주 짧은 직선으로 잘라내어 근사하자“는 것이다.1 EKF는 다루기 힘든 비선형 함수를 현재 상태 추정치라는 특정 지점에서 ’테일러 급수 전개(Taylor Series Expansion)’를 이용해 1차 선형 함수, 즉 접선으로 근사한다.7 그리고 이 근사된 선형 모델을 가지고 기존 선형 칼만 필터의 예측 및 업데이트 메커니즘을 거의 그대로 적용한다.</p>
<p>이 ‘순간적인’ 선형화는 EKF의 가장 큰 장점이자 동시에 가장 치명적인 약점이 된다.</p>
<ul>
<li><strong>장점:</strong> 선형 칼만 필터의 강력하고 잘 정립된 프레임워크를 비선형 시스템에까지 확장하여 적용할 수 있게 해준다. 덕분에 EKF는 수십 년간 GPS, 내비게이션, 로봇 공학 등 수많은 분야에서 가장 대중적인 비선형 필터로 자리 잡았다.1</li>
<li><strong>약점:</strong> 근사는 결국 근사일 뿐이다. 실제 비선형 모델과 선형화된 모델 사이의 오차(linearization error)는 필연적으로 발생한다. 이 오차 때문에 EKF는 선형 KF와 달리 더 이상 통계적으로 ’최적(optimal)’인 필터가 아니다.1 시스템의 비선형성이 강할수록, 즉 곡선이 많이 휘어있을수록 이 오차는 걷잡을 수 없이 커지고, 필터가 완전히 잘못된 추정치를 내놓으며 발산(diverge)할 위험이 커진다.8 이러한 이유로 EKF의 성능은 초기 추정값을 얼마나 정확하게 설정하느냐에 매우 민감하다. 초기 오차가 크면, 엉뚱한 지점에서 선형화를 수행하게 되고 첫 단추부터 잘못 끼워져 결국 발산으로 이어질 수 있다.</li>
</ul>
<h2>2. EKF의 수학적 심장: 자코비안 행렬</h2>
<h3>2.1 비선형 함수를 선형으로 근사하는 마법, 테일러 급수</h3>
<p>EKF의 선형화 아이디어는 테일러 급수(Taylor Series)에서 출발한다. 어떤 미분 가능한 함수 <span class="math math-inline">f(x)</span>를 특정 지점 <span class="math math-inline">a</span> 근처에서 다항식의 합으로 근사하는 방법이다.</p>
<p><span class="math math-display">
f(x) = f(a) + \frac{f&#39;(a)}{1!}(x-a) + \frac{f&#39;&#39;(a)}{2!}(x-a)^2 + \dots
</span><br />
EKF는 이 복잡한 식에서 과감하게 2차 이상의 고차항을 모두 무시하고 1차 항까지만 사용한다.7</p>
<p><span class="math math-display">
f(x) \approx f(a) + f&#39;(a)(x-a)
</span><br />
이것은 다름 아닌 점 <span class="math math-inline">a</span>에서 함수 <span class="math math-inline">f(x)</span>에 접하는 접선의 방정식이다. 즉, EKF는 복잡한 곡선을 아주 작은 구간에서는 직선으로 취급하겠다는 전략을 사용한다.7</p>
<h3>2.2 자코비안 행렬: 다변수 함수의 ‘기울기 집합’</h3>
<p>하지만 우리가 다루는 시스템의 상태는 위치, 속도 등 여러 변수로 구성된 벡터(<span class="math math-inline">\mathbf{x}</span>)이고, 이를 통해 예측하거나 측정하는 값 역시 여러 변수로 구성된 벡터(<span class="math math-inline">\mathbf{y}</span>)다. 이처럼 입력과 출력이 모두 여러 개인 다변수 함수에서는 단순한 미분계수 <span class="math math-inline">f&#39;(a)</span> 대신, 모든 입력 변수에 대한 모든 출력 함수의 편미분(partial derivative) 값을 모아놓은 행렬, 즉 자코비안 행렬(Jacobian Matrix)을 사용한다.1</p>
<p>예를 들어, 입력 벡터가 <span class="math math-inline">\mathbf{x} = [x_1, x_2]^T</span>이고 출력 벡터가 <span class="math math-inline">\mathbf{y} = f(\mathbf{x}) = [y_1(x_1, x_2), y_2(x_1, x_2)]^T</span>인 함수가 있다고 하자. 이 함수의 자코비안 행렬 <span class="math math-inline">\mathbf{J}</span>는 다음과 같이 정의된다.</p>
<p><span class="math math-display">
\mathbf{J} = \frac{\partial \mathbf{y}}{\partial \mathbf{x}} = 
\begin{bmatrix}
\frac{\partial y_1}{\partial x_1} &amp; \frac{\partial y_1}{\partial x_2} \\
\frac{\partial y_2}{\partial x_1} &amp; \frac{\partial y_2}{\partial x_2}
\end{bmatrix}
</span></p>
<h3>2.3 선형 KF의 A, H를 대체하는 동적 행렬 F, H</h3>
<p>EKF에서 자코비안 행렬은 선형 칼만 필터의 상태 전이 행렬 <span class="math math-inline">\mathbf{A}</span>와 측정 행렬 <span class="math math-inline">\mathbf{H}</span>의 역할을 비선형 시스템에서 대신 수행한다. 혼동을 피하기 위해 EKF에서는 이들을 각각 <span class="math math-inline">\mathbf{F}</span>와 <span class="math math-inline">\mathbf{H}</span>로 표기하는 경우가 많다.1 중요한 차이점은 이들이 더 이상 고정된 상수 행렬이 아니라는 점이다. 자코비안은 선형화의 기준점, 즉 현재 상태 추정치 <span class="math math-inline">\hat{\mathbf{x}}</span>에 따라 그 값이 매번 달라지는 동적인 행렬이다.3 이 때문에 EKF는 매 스텝마다 자코비안을 새로 계산해야 하는 추가적인 계산 부담을 안게 된다.11</p>
<h2>3. 확장 칼만 필터 알고리즘 완전 해부</h2>
<h3>3.1 일반적인 비선형 시스템 모델</h3>
<p>EKF가 다루는 비선형 시스템 모델은 일반적으로 다음과 같이 표현된다.2</p>
<p><span class="math math-display">
\mathbf{x}_k = f(\mathbf{x}_{k-1}, \mathbf{u}_{k-1}) + \mathbf{w}_{k-1}</span><br />
<span class="math math-display">\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k
</span><br />
여기서 <span class="math math-inline">f</span>는 현재 상태가 이전 상태로부터 어떻게 변하는지를 나타내는 비선형 상태 전이 함수이고, <span class="math math-inline">h</span>는 현재 상태가 센서에서 어떻게 측정되는지를 나타내는 비선형 측정 함수다. <span class="math math-inline">\mathbf{w}_{k-1}</span>와 <span class="math math-inline">\mathbf{v}_k</span>는 각각 평균이 0이고 공분산이 <span class="math math-inline">\mathbf{Q}_{k-1}</span>과 <span class="math math-inline">\mathbf{R}_k</span>인 가우시안 분포를 따르는 프로세스 노이즈와 측정 노이즈를 의미한다.</p>
<h3>3.2 예측 단계 (Prediction Step): “어디로 갈 것인가?”</h3>
<p>예측 단계의 목표는 이전 시간(<span class="math math-inline">k-1</span>)의 최종 추정치(<span class="math math-inline">\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{P}_{k-1|k-1}</span>)를 바탕으로 현재 시간(<span class="math math-inline">k</span>)의 상태(<span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>)와 그 불확실성(<span class="math math-inline">\mathbf{P}_{k|k-1}</span>)을 예측하는 것이다.</p>
<ul>
<li>
<p><strong>상태 예측 (State Prediction)</strong><br />
<span class="math math-display">
\hat{\mathbf{x}}_{k|k-1} = f(\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_{k-1})
</span><br />
상태 자체를 예측할 때는 선형화된 모델이 아닌, 실제 비선형 상태 전이 함수 <span class="math math-inline">f</span>를 직접 사용한다.3 이는 선형화로 인한 오차를 상태 예측 자체에는 개입시키지 않으려는 의도이며, 가능한 한 실제 시스템의 움직임을 그대로 반영하여 더 정확한 예측을 하기 위함이다.3</p>
</li>
<li>
<p><strong>오차 공분산 예측 (Error Covariance Prediction)</strong></p>
<p><span class="math math-display">
\mathbf{P}_{k|k-1} = \mathbf{F}_{k-1} \mathbf{P}_{k-1|k-1} \mathbf{F}_{k-1}^T + \mathbf{Q}_{k-1}
</span><br />
상태의 불확실성이 시간이 지남에 따라 어떻게 커지는지를 예측한다. 여기서는 상태 자체가 아닌, 오차의 전파를 다루기 때문에 선형화된 모델, 즉 자코비안 <span class="math math-inline">\mathbf{F}_{k-1}</span>을 사용한다.3 수식의 구조는 선형 KF와 동일하며, 단지 상태 전이 행렬 <span class="math math-inline">\mathbf{A}</span>가 자코비안 <span class="math math-inline">\mathbf{F}_{k-1}</span>으로 대체되었을 뿐이다. 이 자코비안은 상태 전이 함수 <span class="math math-inline">f</span>를 이전 스텝의 최종 추정치 <span class="math math-inline">\hat{\mathbf{x}}_{k-1|k-1}</span>에 대해 편미분하여 구한다.</p>
<p><span class="math math-display">
\mathbf{F}_{k-1} = \left. \frac{\partial f}{\partial \mathbf{x}} \right|_{\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_{k-1}}
</span></p>
</li>
<li></li>
</ul>
<h3>3.3 업데이트 단계 (Update Step): “실제는 어떠한가?”</h3>
<p>업데이트 단계에서는 센서로부터 들어온 실제 측정값(<span class="math math-inline">\mathbf{z}_k</span>)을 사용하여 예측 단계에서 계산한 예측치(<span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}, \mathbf{P}_{k|k-1}</span>)를 보정하고, 현재 시간(<span class="math math-inline">k</span>)의 최종 추정치(<span class="math math-inline">\hat{\mathbf{x}}_{k|k}, \mathbf{P}_{k|k}</span>)를 계산한다.</p>
<ul>
<li>
<p><strong>혁신 또는 잔차 계산 (Innovation / Residual)</strong></p>
<p><span class="math math-display">
\tilde{\mathbf{y}}_k = \mathbf{z}_k - h(\hat{\mathbf{x}}_{k|k-1})
</span><br />
예측된 측정값과 실제 측정값 사이의 차이를 계산한다.3 이 차이를 ‘혁신(Innovation)’ 또는 ’잔차(Residual)’라고 부르는데, 이는 예측이 얼마나 ‘놀라운’ 결과를 낳았는지를 나타내기 때문이다. 상태 예측과 마찬가지로, 예측된 측정값을 계산할 때는 비선형 측정 함수</p>
</li>
</ul>
<p><span class="math math-inline">h</span>를 직접 사용한다. <span class="math math-inline">h(\hat{\mathbf{x}}_{k|k-1})</span>는 “만약 우리의 상태 예측이 맞다면, 센서는 이런 값을 보여줬을 것이다“라는 의미를 가진다.</p>
<ul>
<li>
<p><strong>혁신 공분산 계산 (Innovation Covariance)</strong></p>
<p><span class="math math-display">
\mathbf{S}_k = \mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T + \mathbf{R}_k
</span><br />
이 ’놀라움’이 얼마나 큰 불확실성을 가지는지를 계산한다.3 이는 두 가지 불확실성의 합으로 구성된다. 첫째는 예측된 상태의 불확실성(<span class="math math-inline">\mathbf{P}_{k|k-1}</span>)이 측정 공간으로 투영된 것(<span class="math math-inline">\mathbf{H}_k \mathbf{P}_{k|k-1} \mathbf{H}_k^T</span>)이고, 둘째는 측정 자체의 불확실성(<span class="math math-inline">\mathbf{R}_k</span>)이다. 여기서 자코비안 <span class="math math-inline">\mathbf{H}_k</span>는 측정 함수 <span class="math math-inline">h</span>를 현재 스텝의 예측치 <span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>에 대해 편미분하여 구한다.</p>
<p><span class="math math-display">
\mathbf{H}_k = \left. \frac{\partial h}{\partial \mathbf{x}} \right|_{\hat{\mathbf{x}}_{k|k-1}}
</span><br />
<strong>칼만 이득 계산 (Kalman Gain)</strong><br />
<span class="math math-display">
\mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}_k^T \mathbf{S}_k^{-1}
</span><br />
칼만 이득 <span class="math math-inline">\mathbf{K}_k</span>는 예측의 불확실성(<span class="math math-inline">\mathbf{P}_{k|k-1}</span>)과 측정의 불확실성(<span class="math math-inline">\mathbf{S}_k</span>)을 종합적으로 고려하여, 우리가 계산한 ‘잔차’ <span class="math math-inline">\tilde{\mathbf{y}}_k</span>를 얼마나 신뢰하고 반영할지를 결정하는 최적의 가중치다.3</p>
</li>
<li>
<p><strong>상태 업데이트 (State Update)</strong></p>
<p><span class="math math-display">
\hat{\mathbf{x}}_{k|k} = \hat{\mathbf{x}}_{k|k-1} + \mathbf{K}_k \tilde{\mathbf{y}}_k
</span><br />
최종적으로 현재 상태를 추정한다. 예측된 상태 <span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>에 ‘칼만 이득 × 잔차’ 만큼을 더하여 보정한다.3</p>
</li>
<li>
<p><strong>오차 공분산 업데이트 (Error Covariance Update)</strong><br />
<span class="math math-display">
\mathbf{P}_{k|k} = (I - \mathbf{K}_k \mathbf{H}_k) \mathbf{P}_{k|k-1}
</span><br />
측정값을 통해 새로운 정보를 얻었으므로, 상태의 불확실성은 예측 단계보다 줄어들어야 한다. <span class="math math-inline">(I - \mathbf{K}_k \mathbf{H}_k)</span> 항은 이 불확실성 감소 효과를 수학적으로 나타낸다.3</p>
</li>
</ul>
<h3>3.4 핵심 질문에 대한 심층 답변: 왜 F와 H의 선형화 기준점이 다른가?</h3>
<p>여기서 한 가지 중요한 질문이 생긴다. 왜 상태 전이 자코비안 <span class="math math-inline">\mathbf{F}_{k-1}</span>은 이전 스텝의 최종 추정치 <span class="math math-inline">\hat{\mathbf{x}}_{k-1|k-1}</span>을 기준으로 계산하고, 측정 자코비안 <span class="math math-inline">\mathbf{H}_k</span>는 현재 스텝의 예측치 <span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>을 기준으로 계산하는 것일까? 이는 각 자코비안이 사용되는 목적과 시점을 생각해보면 명확해진다. 핵심 원리는 “각 계산이 수행되는 시점에서 가장 최신의, 그리고 가장 적절한 정보를 사용한다“는 것이다.</p>
<ol>
<li><strong><span class="math math-inline">\mathbf{F}_{k-1}</span>의 역할:</strong> 자코비안 <span class="math math-inline">\mathbf{F}_{k-1}</span>은 <span class="math math-inline">k-1</span> 시점에서 <span class="math math-inline">k</span> 시점으로의 <strong>오차 공분산을 예측</strong>하는 데 사용된다 (<span class="math math-inline">\mathbf{P}_{k|k-1} = \mathbf{F}_{k-1} \mathbf{P}_{k-1|k-1} \mathbf{F}_{k-1}^T + \mathbf{Q}_{k-1}</span>). 이 계산은 <span class="math math-inline">k</span> 시점의 측정값이 들어오기 <em>전</em>에 수행된다. 이 시점에서 우리가 가진 가장 정확하고 보정된 상태 정보는 바로 <span class="math math-inline">k-1</span> 시점의 모든 정보를 종합하여 얻은 최종 추정치, 즉 <span class="math math-inline">\hat{\mathbf{x}}_{k-1|k-1}</span>이다. 따라서 이 지점에서 운동 모델 <span class="math math-inline">f</span>를 선형화하여 불확실성을 전파시키는 것이 가장 합리적인 선택이다.3</li>
<li><strong><span class="math math-inline">\mathbf{H}_k</span>의 역할:</strong> 자코비안 <span class="math math-inline">\mathbf{H}_k</span>는 <span class="math math-inline">k</span> 시점의 <strong>측정값을 이용해 예측을 보정</strong>하는 업데이트 단계에서 사용된다. 이 단계의 핵심은 실제 측정값 <span class="math math-inline">\mathbf{z}_k</span>와 예측된 측정값 <span class="math math-inline">h(\hat{\mathbf{x}}_{k|k-1})</span>을 비교하는 것이다. 자코비안 <span class="math math-inline">\mathbf{H}_k</span>는 상태 예측치 <span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>의 작은 변화가 예측된 측정값 <span class="math math-inline">h(\hat{\mathbf{x}}_{k|k-1})</span>에 어떤 영향을 미치는지를 나타내는 선형 관계를 모델링한다. 따라서 이 둘 사이의 관계를 가장 잘 나타내는 지역적 선형 모델을 얻기 위해서는, 당연히 예측치 <span class="math math-inline">\hat{\mathbf{x}}_{k|k-1}</span>를 기준으로 측정 함수 <span class="math math-inline">h</span>를 선형화해야 한다.3</li>
</ol>
<p>결론적으로, 각 자코비안은 해당 계산이 수행되는 시점에서 가장 최신의, 그리고 가장 적절한 상태 추정치를 기준으로 선형화된다. 이는 EKF가 매 스텝마다 변화하는 상황에 맞춰 ‘최선의’ 선형 모델을 동적으로 찾아가려는 노력의 일환이라고 볼 수 있다.</p>
<table><thead><tr><th>단계 (Step)</th><th>목표 (Goal)</th><th>상태 계산 (State Calculation)</th><th>공분산 계산 (Covariance Calculation)</th><th>핵심 변수 (Key Variables)</th><th>사용 함수 (Functions Used)</th></tr></thead><tbody>
<tr><td><strong>예측 (Prediction)</strong></td><td>이전 상태로부터 현재 상태와 불확실성을 예측</td><td>$\hat{\mathbf{x}}_{k</td><td>k-1} = f(\hat{\mathbf{x}}_{k-1</td><td>k-1}, \mathbf{u}_{k-1})$</td><td>$\mathbf{P}_{k</td></tr>
<tr><td><strong>업데이트 (Update)</strong></td><td>측정값을 이용해 예측을 보정하고 최종 추정치 생성</td><td>$\hat{\mathbf{x}}_{k</td><td>k} = \hat{\mathbf{x}}_{k</td><td>k-1} + \mathbf{K}_k \tilde{\mathbf{y}}_k$</td><td>$\mathbf{P}_{k</td></tr>
</tbody></table>
<h2>4. 실전 예제 1: CTRV 모델을 이용한 차량 추적</h2>
<p>이제 이론을 실제 문제에 적용해 보자. 자율주행이나 로봇 공학에서 가장 흔하게 접하는 문제 중 하나는 움직이는 차량을 추적하는 것이다. 이를 위해 널리 사용되는 CTRV(Constant Turn Rate and Velocity) 모델을 EKF에 적용하는 과정을 단계별로 살펴보자.</p>
<h3>4.1 CTRV (Constant Turn Rate and Velocity) 모델 소개</h3>
<p>CTRV 모델은 이름에서 알 수 있듯이, 아주 짧은 시간 간격(<span class="math math-inline">\Delta t</span>) 동안에는 차량의 선회율(turn rate, <span class="math math-inline">\dot{\psi}</span>)과 속력(velocity, <span class="math math-inline">v</span>)이 일정하다고 가정하는 운동 모델이다.12 이는 단순히 등속 직선 운동(Constant Velocity, CV)을 가정하는 것보다 회전하는 차량의 움직임을 훨씬 더 현실적으로 묘사할 수 있어 널리 사용된다.</p>
<ul>
<li><strong>상태 벡터 정의:</strong> CTRV 모델에서 우리가 추적하고자 하는 객체의 상태는 보통 5개의 변수로 구성된 상태 벡터 <span class="math math-inline">\mathbf{x}</span>로 정의한다.12</li>
<li><span class="math math-inline">p_x, p_y</span>: 차량의 전역 좌표계(Global Frame) 상에서의 x, y 위치</li>
<li><span class="math math-inline">v</span>: 차량의 속력 (방향이 아닌 스칼라 값)</li>
<li><span class="math math-inline">\psi</span>: 차량의 주행 방향 각도 (Yaw 또는 Heading)</li>
<li><span class="math math-inline">\dot{\psi}</span>: 차량의 각속도, 즉 선회율 (Yaw Rate)</li>
<li><span class="math math-inline">\mathbf{x} = [p_x, p_y, v, \psi, \dot{\psi}]^T</span></li>
</ul>
<h3>4.2 상태 전이 함수 f(x) 단계별 유도</h3>
<p>상태 전이 함수 <span class="math math-inline">f(\mathbf{x})</span>는 <span class="math math-inline">k-1</span> 시점의 상태 <span class="math math-inline">\mathbf{x}_{k-1}</span>이 주어졌을 때, <span class="math math-inline">\Delta t</span> 시간이 흐른 뒤의 <span class="math math-inline">k</span> 시점의 상태 <span class="math math-inline">\mathbf{x}_k</span>를 예측하는 비선형 함수다. 각 상태 변수가 어떻게 변하는지 살펴보자.</p>
<p>속력 <span class="math math-inline">v</span>, 주행 방향 <span class="math math-inline">\psi</span>, 선회율 <span class="math math-inline">\dot{\psi}</span>의 업데이트는 CTRV 가정에 따라 매우 간단하다.</p>
<ul>
<li><span class="math math-inline">v_k = v_{k-1}</span> (속력은 일정)</li>
<li><span class="math math-inline">\dot{\psi}_k = \dot{\psi}_{k-1}</span> (선회율은 일정)</li>
<li><span class="math math-inline">\psi_k = \psi_{k-1} + \dot{\psi}_{k-1} \Delta t</span> (주행 방향은 선회율에 따라 변함)</li>
</ul>
<p>위치 <span class="math math-inline">p_x, p_y</span>의 업데이트는 적분을 통해 계산해야 한다. 시간 <span class="math math-inline">t</span>에서의 위치 변화율은 <span class="math math-inline">\dot{p}_x(t) = v(t) \cos(\psi(t))</span>, <span class="math math-inline">\dot{p}_y(t) = v(t) \sin(\psi(t))</span>이다. CTRV 가정에 따라 <span class="math math-inline">v(t) = v_{k-1}</span>이고 <span class="math math-inline">\psi(t) = \psi_{k-1} + \dot{\psi}_{k-1}(t-t_{k-1})</span>이므로, 이를 <span class="math math-inline">t_{k-1}</span>부터 <span class="math math-inline">t_k</span>까지 <span class="math math-inline">\Delta t</span> 동안 적분하면 된다.12</p>
<h4>4.2.1 Case 1: <span class="math math-inline">\dot{\psi}_{k-1} \neq 0</span> (회전 중일 때)</h4>
<p>선회율이 0이 아닐 때는 삼각함수의 적분을 통해 다음과 같은 식을 얻는다.12</p>
<p><span class="math math-display">
\begin{align*}
p_{x,k} &amp;= p_{x,k-1} + \int_{t_{k-1}}^{t_k} v_{k-1} \cos(\psi_{k-1} + \dot{\psi}_{k-1}(t-t_{k-1})) dt \\
&amp;= p_{x,k-1} + \left[ \frac{v_{k-1}}{\dot{\psi}_{k-1}} \sin(\psi_{k-1} + \dot{\psi}_{k-1}(t-t_{k-1})) \right]_{t_{k-1}}^{t_k} \\
&amp;= p_{x,k-1} + \frac{v_{k-1}}{\dot{\psi}_{k-1}} (\sin(\psi_{k-1} + \dot{\psi}_{k-1}\Delta t) - \sin(\psi_{k-1}))
\end{align*}
</span></p>
<p>$$<br />
$$<br />
\begin{align*}<br />
p_{y,k} &amp;= p_{y,k-1} + \int_{t_{k-1}}<sup>{t_k} v_{k-1} \sin(\psi_{k-1} + \dot{\psi}<em>{k-1}(t-t</em>{k-1})) dt \<br />
&amp;= p_{y,k-1} + \left[ -\frac{v_{k-1}}{\dot{\psi}<em>{k-1}} \cos(\psi</em>{k-1} + \dot{\psi}<em>{k-1}(t-t</em>{k-1})) \right]<em>{t</em>{k-1}}</sup>{t_k} \<br />
&amp;= p_{y,k-1} + \frac{v_{k-1}}{\dot{\psi}<em>{k-1}} (-\cos(\psi</em>{k-1} + \dot{\psi}<em>{k-1}\Delta t) + \cos(\psi</em>{k-1}))<br />
\end{align*}<br />
$$</p>
<h4>Case 2: <span class="math math-inline">\dot{\psi}_{k-1} = 0</span> (직진 중일 때)</h4>
<p>위 식에서 <span class="math math-inline">\dot{\psi}_{k-1}</span>이 0에 가까워지면 분모가 0이 되어 수치적으로 불안정해지는 문제가 발생한다. 이는 단순히 수학적 특이점(singularity)일 뿐만 아니라 물리적 현실을 반영한다. 선회율이 0이라는 것은 차량이 회전하지 않고 직선 운동을 한다는 의미다. 이 경우, <span class="math math-inline">\psi(t)</span>는 <span class="math math-inline">\psi_{k-1}</span>로 상수이므로 적분이 훨씬 간단해진다.12</p>
<p><span class="math math-display">
\begin{align*}
p_{x,k} &amp;= p_{x,k-1} + \int_{t_{k-1}}^{t_k} v_{k-1} \cos(\psi_{k-1}) dt = p_{x,k-1} + v_{k-1} \cos(\psi_{k-1}) \Delta t \\
p_{y,k} &amp;= p_{y,k-1} + \int_{t_{k-1}}^{t_k} v_{k-1} \sin(\psi_{k-1}) dt = p_{y,k-1} + v_{k-1} \sin(\psi_{k-1}) \Delta t
\end{align*}
</span><br />
실제 코드를 구현할 때는 <code>if abs(yaw_rate) &lt; 0.0001:</code> 과 같이 아주 작은 임계값을 설정하여 이 두 경우를 분기 처리하는 것이 필수적이다. 이 분기 처리는 수학적 오류를 피하는 것뿐만 아니라, 물리적으로 다른 두 운동 모델(원운동과 직선운동)을 올바르게 전환하는 과정이다.12</p>
<h3>상태 전이 자코비안 F 단계별 유도</h3>
<p>이제 EKF 구현의 가장 까다로운 부분인 자코비안 <span class="math math-inline">\mathbf{F}_k</span>를 유도할 차례다. <span class="math math-inline">\mathbf{F}_k</span>는 상태 전이 함수 <span class="math math-inline">f(\mathbf{x})</span>의 5개 출력 함수(<span class="math math-inline">p_{x,k}, p_{y,k}, v_k, \psi_k, \dot{\psi}_k</span>)를 5개의 입력 상태 변수(<span class="math math-inline">p_{x,k-1}, p_{y,k-1}, v_{k-1}, \psi_{k-1}, \dot{\psi}_{k-1}</span>) 각각에 대해 편미분한 5x5 행렬이다.15</p>
<p><span class="math math-display">
\mathbf{F}_k = \left. \frac{\partial f}{\partial \mathbf{x}} \right|_{\hat{\mathbf{x}}_{k-1|k-1}}
</span><br />
대부분의 항은 미분하면 0, 1, 또는 <span class="math math-inline">\Delta t</span>가 되어 간단하다. 예를 들어, <span class="math math-inline">\frac{\partial p_{x,k}}{\partial p_{x,k-1}} = 1</span>, <span class="math math-inline">\frac{\partial \psi_k}{\partial \psi_{k-1}} = 1</span>, <span class="math math-inline">\frac{\partial \psi_k}{\partial \dot{\psi}_{k-1}} = \Delta t</span> 이다. 복잡한 부분은 위치 <span class="math math-inline">p_x, p_y</span>를 속도, 주행 방향, 선회율(<span class="math math-inline">v, \psi, \dot{\psi}</span>)로 편미분하는 항들이다.</p>
<h4>Case 1: <span class="math math-inline">\dot{\psi}_{k-1} \neq 0</span> 일 때의 <span class="math math-inline">\mathbf{F}_k</span></h4>
<p>편의상 <span class="math math-inline">v = v_{k-1}, \psi = \psi_{k-1}, \dot{\psi} = \dot{\psi}_{k-1}</span> 라고 간단히 표기하자.</p>
<ul>
<li><span class="math math-inline">\frac{\partial p_{x,k}}{\partial v} = \frac{1}{\dot{\psi}} (\sin(\psi + \dot{\psi}\Delta t) - \sin(\psi))</span></li>
<li><span class="math math-inline">\frac{\partial p_{x,k}}{\partial \psi} = \frac{v}{\dot{\psi}} (\cos(\psi + \dot{\psi}\Delta t) - \cos(\psi))</span></li>
<li><span class="math math-inline">\frac{\partial p_{x,k}}{\partial \dot{\psi}} = \frac{v\Delta t}{\dot{\psi}} \cos(\psi + \dot{\psi}\Delta t) - \frac{v}{\dot{\psi}^2} (\sin(\psi + \dot{\psi}\Delta t) - \sin(\psi))</span></li>
<li><span class="math math-inline">\frac{\partial p_{y,k}}{\partial v} = \frac{1}{\dot{\psi}} (-\cos(\psi + \dot{\psi}\Delta t) + \cos(\psi))</span></li>
<li><span class="math math-inline">\frac{\partial p_{y,k}}{\partial \psi} = \frac{v}{\dot{\psi}} (\sin(\psi + \dot{\psi}\Delta t) - \sin(\psi))</span></li>
<li><span class="math math-inline">\frac{\partial p_{y,k}}{\partial \dot{\psi}} = \frac{v\Delta t}{\dot{\psi}} \sin(\psi + \dot{\psi}\Delta t) - \frac{v}{\dot{\psi}^2} (-\cos(\psi + \dot{\psi}\Delta t) + \cos(\psi))</span></li>
</ul>
<p>이를 모두 모으면 자코비안 <span class="math math-inline">\mathbf{F}_k</span>는 다음과 같다.</p>
<p><span class="math math-display">
\mathbf{F}_k =
\begin{bmatrix}
1 &amp; 0 &amp; \frac{1}{\dot{\psi}}(\sin(\psi+\dot{\psi}\Delta t) - \sin(\psi)) &amp; \frac{v}{\dot{\psi}}(\cos(\psi+\dot{\psi}\Delta t) - \cos(\psi)) &amp; \frac{\partial p_{x,k}}{\partial \dot{\psi}} \\
0 &amp; 1 &amp; \frac{1}{\dot{\psi}}(-\cos(\psi+\dot{\psi}\Delta t) + \cos(\psi)) &amp; \frac{v}{\dot{\psi}}(\sin(\psi+\dot{\psi}\Delta t) - \sin(\psi)) &amp; \frac{\partial p_{y,k}}{\partial \dot{\psi}} \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; \Delta t \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
</span></p>
<h4>Case 2: <span class="math math-inline">\dot{\psi}_{k-1} = 0</span> 일 때의 <span class="math math-inline">\mathbf{F}_k</span></h4>
<p>직진 운동 시에는 상태 전이 함수가 더 단순하므로 자코비안도 간단해진다.</p>
<ul>
<li><span class="math math-inline">\frac{\partial p_{x,k}}{\partial v} = \cos(\psi)\Delta t</span></li>
<li><span class="math math-inline">\frac{\partial p_{x,k}}{\partial \psi} = -v\sin(\psi)\Delta t</span></li>
<li><span class="math math-inline">\frac{\partial p_{y,k}}{\partial v} = \sin(\psi)\Delta t</span></li>
<li><span class="math math-inline">\frac{\partial p_{y,k}}{\partial \psi} = v\cos(\psi)\Delta t</span></li>
<li><span class="math math-inline">\dot{\psi}</span>에 대한 편미분 항들은 0이 된다. 하지만 0으로 나누는 특이점을 피하기 위해 <span class="math math-inline">\dot{\psi} \to 0</span> 극한을 취하면, <span class="math math-inline">\frac{\partial p_{x,k}}{\partial \dot{\psi}}</span>와 <span class="math math-inline">\frac{\partial p_{y,k}}{\partial \dot{\psi}}</span> 항은 0이 아닌 값을 가진다. 로피탈의 정리를 적용하면 <span class="math math-inline">\lim_{\dot{\psi} \to 0} \frac{\partial p_{x,k}}{\partial \dot{\psi}} = -\frac{1}{2}v\Delta t^2 \sin(\psi)</span> 와 <span class="math math-inline">\lim_{\dot{\psi} \to 0} \frac{\partial p_{y,k}}{\partial \dot{\psi}} = \frac{1}{2}v\Delta t^2 \cos(\psi)</span>를 얻을 수 있다. 하지만 많은 간소화된 구현에서는 이 항들을 0으로 처리하기도 한다. 여기서는 더 정확한 모델을 위해 0으로 두지 않는다.</li>
</ul>
<p>이때의 자코비안은 다음과 같다.</p>
<p><span class="math math-display">
\mathbf{F}_k =
\begin{bmatrix}
1 &amp; 0 &amp; \cos(\psi)\Delta t &amp; -v\sin(\psi)\Delta t &amp; -\frac{1}{2}v\Delta t^2 \sin(\psi) \\
0 &amp; 1 &amp; \sin(\psi)\Delta t &amp; v\cos(\psi)\Delta t &amp; \frac{1}{2}v\Delta t^2 \cos(\psi) \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; \Delta t \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
</span><br />
이처럼 자코비안을 손으로 직접 유도하는 과정은 EKF 구현에서 가장 까다롭고 버그가 발생하기 쉬운 부분이다. 사소한 부호 실수나 미분 계산 착오가 필터 전체의 성능을 망가뜨릴 수 있다. 바로 이 점이 많은 개발자들이 자코비안 계산이 필요 없는 무향 칼만 필터(UKF)를 선호하게 되는 주된 이유 중 하나다.18 하지만 이 과정을 상세히 따라가 보는 것은 EKF의 실제적인 어려움과 그 작동 원리를 깊이 이해하는 데 필수적인 학습 과정이다.</p>
<h2>실전 예제 2: 라이다(Lidar)와 레이더(Radar) 센서 퓨전</h2>
<p>이제 EKF의 또 다른 핵심 응용 분야인 센서 퓨전(Sensor Fusion)을 살펴보자. 자율주행차는 보통 라이다, 레이더, 카메라 등 여러 종류의 센서를 함께 사용하는데, 각 센서의 장단점을 보완하여 더 강건하고 정확한 인지를 하기 위함이다. EKF는 이처럼 서로 다른 종류의 측정값을 하나의 일관된 상태 추정치로 통합하는 데 매우 효과적인 도구다.</p>
<h3>측정 모델 h(x)의 역할</h3>
<p>측정 모델 <span class="math math-inline">h(\mathbf{x})</span>는 추상적인 상태 공간(State Space)의 변수들을 센서가 실제로 측정하는 물리적인 측정 공간(Measurement Space)으로 변환하는 다리 역할을 한다.19 예를 들어, CTRV 모델의 상태 벡터 <span class="math math-inline">\mathbf{x} = [p_x, p_y, v, \psi, \dot{\psi}]^T</span>를 레이더가 측정하는 (<span class="math math-inline">\rho, \phi, \dot{\rho}</span>) 값으로 변환하는 함수가 바로 레이더의 측정 모델 <span class="math math-inline">h_{Radar}(\mathbf{x})</span>이다.</p>
<h3>라이다 측정 모델과 자코비안 <span class="math math-inline">\mathbf{H}_{Lidar}</span></h3>
<p>라이다(Lidar)는 레이저 펄스를 이용해 주변 환경을 스캔하고, 매우 정밀한 3D 포인트 클라우드를 생성한다. 차량 추적의 맥락에서, 라이다는 보통 객체의 직교 좌표계 위치 (<span class="math math-inline">p_x, p_y</span>)를 직접적으로 측정한다고 모델링할 수 있다.</p>
<ul>
<li>
<p>측정 벡터: <span class="math math-inline">\mathbf{z}_{Lidar} = [p_x, p_y]^T</span></p>
</li>
<li>
<p>측정 함수: 상태 벡터 <span class="math math-inline">\mathbf{x}</span>에서 위치 정보인 <span class="math math-inline">p_x</span>와 <span class="math math-inline">p_y</span>를 그대로 가져오면 된다. 이는 선형 변환으로 표현할 수 있다.</p>
</li>
</ul>
<p><span class="math math-display">
h_{Lidar}(\mathbf{x}) = \begin{bmatrix} p_x \\ p_y \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} \mathbf{x}
  </span></p>
<ul>
<li>자코비안 <span class="math math-inline">\mathbf{H}_{Lidar}</span>: 측정 함수가 이미 선형이므로, 이를 상태 벡터 <span class="math math-inline">\mathbf{x}</span>에 대해 편미분한 자코비안은 상수 행렬이 된다.</li>
</ul>
<p><span class="math math-display">
\mathbf{H}_{Lidar} = \frac{\partial h_{Lidar}}{\partial \mathbf{x}} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}
  </span></p>
<p>라이다의 측정 모델은 선형이기 때문에, 라이다 측정값으로 업데이트를 수행할 때는 EKF가 사실상 선형 칼만 필터처럼 동작한다. 비선형성은 시스템의 움직임을 예측하는 단계와, 아래에서 다룰 비선형적인 레이더 측정값을 처리하는 단계에서만 나타난다.</p>
<h3>레이더 측정 모델(<span class="math math-inline">\rho, \phi, \dot{\rho}</span>)과 자코비안 <span class="math math-inline">\mathbf{H}_{Radar}</span> 단계별 유도</h3>
<p>레이더(Radar)는 전파를 이용하여 객체를 탐지하며, 보통 극좌표계(polar coordinates)로 측정값을 제공한다: 센서로부터 객체까지의 거리(range, <span class="math math-inline">\rho</span>), 방위각(bearing, <span class="math math-inline">\phi</span>), 그리고 거리가 변하는 속도(range rate, <span class="math math-inline">\dot{\rho}</span>).5 이 측정값들과 상태 변수 (<span class="math math-inline">p_x, p_y, v, \psi</span>) 사이의 관계는 비선형적이다.</p>
<ul>
<li>
<p>측정 벡터: <span class="math math-inline">\mathbf{z}_{Radar} = [\rho, \phi, \dot{\rho}]^T</span></p>
</li>
<li>
<p>측정 함수 <span class="math math-inline">h_{Radar}(\mathbf{x})</span>: 상태 벡터 <span class="math math-inline">\mathbf{x}</span>를 레이더 측정 벡터 <span class="math math-inline">\mathbf{z}_{Radar}</span>로 변환하는 함수는 다음과 같다.</p>
</li>
</ul>
<p><span class="math math-display">
h_{Radar}(\mathbf{x}) = \begin{bmatrix} \rho \\ \phi \\ \dot{\rho} \end{bmatrix} =
\begin{bmatrix}
\sqrt{p_x^2 + p_y^2} \\
\operatorname{atan2}(p_y, p_x) \\
\frac{p_x v \cos(\psi) + p_y v \sin(\psi)}{\sqrt{p_x^2 + p_y^2}}
\end{bmatrix}
  </span><br />
여기서 <span class="math math-inline">\dot{\rho}</span> 유도 과정은 다음과 같다. 위치 벡터 <span class="math math-inline">\mathbf{p} = [p_x, p_y]^T</span>와 속도 벡터 <span class="math math-inline">\mathbf{v}_{xy} = [v\cos(\psi), v\sin(\psi)]^T</span>의 내적을 거리 <span class="math math-inline">\rho</span>로 나눈 값, 즉 속도 벡터를 위치 벡터 방향으로 투영(projection)한 크기다. 이는 <span class="math math-inline">\rho^2 = p_x^2 + p_y^2</span>를 시간에 대해 미분하여 유도할 수 있다: <span class="math math-inline">2\rho\dot{\rho} = 2p_x\dot{p}_x + 2p_y\dot{p}_y</span>. 따라서 <span class="math math-inline">\dot{\rho} = (p_x\dot{p}_x + p_y\dot{p}_y)/\rho</span> 이고, <span class="math math-inline">\dot{p}_x</span>와 <span class="math math-inline">\dot{p}_y</span>에 CTRV 모델의 속도 성분을 대입하면 위 식을 얻는다.5</p>
<ul>
<li>자코비안 <span class="math math-inline">\mathbf{H}_{Radar}</span>: 이제 측정 함수 <span class="math math-inline">h_{Radar}</span>를 5개의 상태 변수(<span class="math math-inline">p_x, p_y, v, \psi, \dot{\psi}</span>) 각각에 대해 편미분하여 3x5 크기의 자코비안 행렬 <span class="math math-inline">\mathbf{H}_{Radar}</span>를 구해야 한다. 이 과정은 연쇄 법칙(chain rule)과 분수, 제곱근, 아크탄젠트 함수의 미분 등 다소 복잡한 계산을 요구한다.5</li>
</ul>
<p><span class="math math-display">
\mathbf{H}_{Radar} = \frac{\partial h_{Radar}}{\partial \mathbf{x}} = \begin{bmatrix} \frac{\partial \rho}{\partial p_x} &amp; \frac{\partial \rho}{\partial p_y} &amp; \frac{\partial \rho}{\partial v} &amp; \frac{\partial \rho}{\partial \psi} &amp; \frac{\partial \rho}{\partial \dot{\psi}} \\ \frac{\partial \phi}{\partial p_x} &amp; \frac{\partial \phi}{\partial p_y} &amp; \frac{\partial \phi}{\partial v} &amp; \frac{\partial \phi}{\partial \psi} &amp; \frac{\partial \phi}{\partial \dot{\psi}} \\ \frac{\partial \dot{\rho}}{\partial p_x} &amp; \frac{\partial \dot{\rho}}{\partial p_y} &amp; \frac{\partial \dot{\rho}}{\partial v} &amp; \frac{\partial \dot{\rho}}{\partial \psi} &amp; \frac{\partial \dot{\rho}}{\partial \dot{\psi}} \end{bmatrix}
  </span><br />
각 항을 계산해 보면 다음과 같다. (편의상 <span class="math math-inline">\rho = \sqrt{p_x^2+p_y^2}</span>로 표기)</p>
<ul>
<li><span class="math math-inline">\frac{\partial \rho}{\partial p_x} = \frac{p_x}{\rho}, \frac{\partial \rho}{\partial p_y} = \frac{p_y}{\rho}, \frac{\partial \rho}{\partial v} = 0, \frac{\partial \rho}{\partial \psi} = 0, \frac{\partial \rho}{\partial \dot{\psi}} = 0</span></li>
<li><span class="math math-inline">\frac{\partial \phi}{\partial p_x} = -\frac{p_y}{\rho^2}, \frac{\partial \phi}{\partial p_y} = \frac{p_x}{\rho^2}, \frac{\partial \phi}{\partial v} = 0, \frac{\partial \phi}{\partial \psi} = 0, \frac{\partial \phi}{\partial \dot{\psi}} = 0</span></li>
<li><span class="math math-inline">\frac{\partial \dot{\rho}}{\partial p_x} = \frac{v\cos(\psi)}{\rho} - \frac{p_x(p_x v\cos(\psi) + p_y v\sin(\psi))}{\rho^3} = \frac{v}{\rho^3}(p_y^2 \cos\psi - p_x p_y \sin\psi)</span></li>
<li><span class="math math-inline">\frac{\partial \dot{\rho}}{\partial p_y} = \frac{v\sin(\psi)}{\rho} - \frac{p_y(p_x v\cos(\psi) + p_y v\sin(\psi))}{\rho^3} = \frac{v}{\rho^3}(p_x^2 \sin\psi - p_x p_y \cos\psi)</span></li>
<li><span class="math math-inline">\frac{\partial \dot{\rho}}{\partial v} = \frac{p_x\cos(\psi) + p_y\sin(\psi)}{\rho}</span></li>
<li><span class="math math-inline">\frac{\partial \dot{\rho}}{\partial \psi} = \frac{-p_x v\sin(\psi) + p_y v\cos(\psi)}{\rho}</span></li>
<li><span class="math math-inline">\frac{\partial \dot{\rho}}{\partial \dot{\psi}} = 0</span></li>
</ul>
<p>이 자코비안 행렬의 각 원소는 중요한 물리적 의미를 담고 있다. 이는 단순히 계산을 위한 도구가 아니라, 특정 측정값이 각 상태 변수에 대해 얼마나 민감한 정보(sensitivity)를 담고 있는지를 나타내는 지표이기도 하다. 예를 들어, <span class="math math-inline">\frac{\partial \phi}{\partial v} = 0</span> 이라는 사실은 레이더의 방위각 측정값 <span class="math math-inline">\phi</span>가 차량의 속력 <span class="math math-inline">v</span>를 추정하는 데 아무런 직접적인 정보를 주지 못한다는 것을 의미한다. 반면, <span class="math math-inline">\frac{\partial \dot{\rho}}{\partial v}</span> 항은 0이 아니므로, 거리 변화율 <span class="math math-inline">\dot{\rho}</span> 측정값은 속력 <span class="math math-inline">v</span>를 추정하는 데 직접적인 단서가 된다. 이처럼 자코비안을 분석하면 어떤 센서가 어떤 상태 변수를 추정하는 데 더 기여하는지 통찰을 얻을 수 있다.</p>
<table><thead><tr><th>특성 (Characteristic)</th><th>라이다 (Lidar)</th><th>레이더 (Radar)</th></tr></thead><tbody>
<tr><td><strong>측정 벡터 <span class="math math-inline">\mathbf{z}</span></strong></td><td><span class="math math-inline">[p_x, p_y]^T</span> (직교 좌표)</td><td><span class="math math-inline">[\rho, \phi, \dot{\rho}]^T</span> (극 좌표)</td></tr>
<tr><td><strong>측정 함수 <span class="math math-inline">h(\mathbf{x})</span></strong></td><td><span class="math math-inline">\begin{bmatrix} p_x \\ p_y \end{bmatrix}</span></td><td><span class="math math-inline">\begin{bmatrix} \sqrt{p_x^2+p_y^2} \\ \operatorname{atan2}(p_y, p_x) \\ \frac{p_x (v \cos\psi) + p_y (v \sin\psi)}{\sqrt{p_x^2+p_y^2}} \end{bmatrix}</span></td></tr>
<tr><td><strong>선형성 (Linearity)</strong></td><td>선형 (Linear)</td><td>비선형 (Non-linear)</td></tr>
<tr><td><strong>자코비안 <span class="math math-inline">\mathbf{H}</span></strong></td><td>상수 행렬, 계산 용이</td><td>상태 의존적, 계산 복잡</td></tr>
<tr><td><strong>주요 제공 정보</strong></td><td>정확한 위치</td><td>위치, 방향, 그리고 직접적인 속도 정보</td></tr>
<tr><td><strong>장점</strong></td><td>높은 위치 정밀도, 조밀한 데이터</td><td>전천후 성능, 속도 직접 측정 가능, 원거리 탐지</td></tr>
<tr><td><strong>단점</strong></td><td>악천후(비, 눈, 안개)에 취약, 속도 직접 측정 불가</td><td>낮은 위치 정밀도, 희소한 데이터</td></tr>
</tbody></table>
<h2>EKF를 넘어서: 더 나은 필터를 향한 여정</h2>
<p>EKF는 수많은 비선형 문제에 성공적으로 적용되어 왔지만, 근본적인 한계를 가지고 있다. 이 한계를 이해하는 것은 더 발전된 필터인 무향 칼만 필터(UKF)와 파티클 필터(PF)의 필요성을 이해하는 데 중요하다.</p>
<h3>EKF의 근본적 한계: 언제 EKF는 실패하는가?</h3>
<p>EKF는 다음과 같은 상황에서 심각한 성능 저하를 겪거나 발산할 수 있다.</p>
<ul>
<li><strong>강한 비선형성 (Strong Non-linearity):</strong> 시스템의 상태 전이나 측정 모델이 매우 비선형적일 때, 즉 함수 그래프가 급격하게 휘어질 때, 1차 테일러 급수 전개를 통한 선형 근사는 실제 함수와 너무 큰 차이를 보이게 된다. 이 선형화 오차는 매 스텝마다 누적되어 결국 필터가 엉뚱한 방향으로 가게 만든다.8</li>
<li><strong>비가우시안 분포 (Non-Gaussian Distribution):</strong> EKF의 모든 과정은 상태의 불확실성이 단일 가우시안 분포로 표현될 수 있다는 가정에 기반한다. 하지만 초기 불확실성이 가우시안이 아니거나, 강한 비선형 변환을 거치면서 확률 분포가 여러 개의 봉우리를 갖는 다봉성(multi-modal) 분포나 한쪽으로 심하게 치우친(skewed) 분포로 변형될 경우, 단 하나의 평균과 공분산으로 이 분포를 표현하려는 EKF의 시도는 현실을 제대로 반영하지 못하게 된다.4</li>
<li><strong>미분 불가능한 모델:</strong> 모델 함수에 <code>if</code> 문이나 <code>abs()</code> 함수처럼 미분 불가능한 지점이 포함되어 있다면, 자코비안 자체를 계산할 수 없으므로 EKF를 원천적으로 적용할 수 없다.</li>
</ul>
<p>EKF에서 UKF, 그리고 PF로의 발전은 단순히 정확도의 점진적 향상이 아니다. 이는 비선형성을 다루는 핵심 전략의 근본적인 철학적 변화를 나타낸다.</p>
<ul>
<li><strong>EKF의 철학:</strong> “모델이 너무 어려우니, <strong>모델 자체를 근사하자</strong>.” EKF는 비선형 함수 <span class="math math-inline">f</span>와 <span class="math math-inline">h</span>를 직접 선형화한다. 모든 계산은 이 단순화된 선형 모델 위에서 이루어진다.1</li>
<li><strong>UKF의 철학:</strong> “모델을 근사하는 것은 부정확하다. 대신 <strong>확률 분포를 근사하자</strong>.” UKF는 비선형 함수를 건드리지 않는다. 대신, 가우시안 분포의 평균과 공분산을 완벽하게 대표하는 소수의 샘플 포인트(시그마 포인트)를 지능적으로 선택한다. 그리고 이 포인트들을 <em>있는 그대로의 비선형 함수</em>에 통과시킨 후, 변환된 포인트들로부터 새로운 평균과 공분산을 계산한다. 복잡한 함수를 하나의 접선으로 근사하는 것보다, 분포를 몇 개의 대표점으로 근사하는 것이 더 낫다는 발상이다.1</li>
<li><strong>PF의 철학:</strong> “왜 굳이 가우시안 분포를 가정해야 하는가? 분포를 그냥 <strong>무작위 샘플들의 집합</strong>으로 근사하자.” 파티클 필터는 확률 분포의 모양에 대한 어떠한 가정도 하지 않는다. 분포를 수많은 가중치를 가진 샘플(파티클)들의 집합으로 표현한다. 이는 가장 유연한 접근법으로, 임의의 복잡한 분포도 표현할 수 있지만 가장 큰 계산 비용을 요구한다.24</li>
</ul>
<h3>무향 칼만 필터(UKF): 자코비안 대신 시그마 포인트로</h3>
<p>무향 칼만 필터(Unscented Kalman Filter, UKF)는 EKF의 선형화 오차 문제를 해결하기 위해 등장했다. UKF의 핵심 철학은 “비선형 함수를 근사하는 것보다, 확률 분포를 근사하는 것이 더 쉽고 정확하다“는 것이다.22</p>
<p>UKF의 동작 방식은 다음과 같다.</p>
<ol>
<li><strong>시그마 포인트 생성:</strong> 현재 상태의 평균과 공분산 정보를 완벽하게 대표하는 소수의 샘플 포인트, 즉 시그마 포인트(Sigma Points)를 결정론적인 규칙에 따라 선택한다. 상태 벡터의 차원이 <span class="math math-inline">n</span>일 때 보통 <span class="math math-inline">2n+1</span>개의 시그마 포인트를 사용한다.26</li>
<li><strong>포인트 전파:</strong> 이 시그마 포인트들을 자코비안 계산 없이 그대로 실제 비선형 함수(<span class="math math-inline">f</span> 또는 <span class="math math-inline">h</span>)에 입력하여 변환시킨다.</li>
<li><strong>분포 재구성:</strong> 변환된 시그마 포인트들의 가중 평균(weighted average)과 가중 공분산(weighted covariance)을 계산하여, 변환 후의 새로운 가우시안 분포를 재구성한다.26</li>
</ol>
<p>EKF가 분포의 평균 지점 단 하나만을 사용하여 선형화를 수행하는 반면, UKF는 분포의 ‘형태’(분산)까지 고려한 여러 개의 지점(시그마 포인트)을 사용한다. 이 덕분에 UKF는 비선형 변환 후의 실제 평균과 공분산을 EKF보다 훨씬 더 정확하게(테일러 급수 기준으로 최소 2차 항까지, 종종 3차 항까지) 근사할 수 있다.27 자코비안을 계산할 필요가 없어 복잡한 편미분 유도 과정에서 해방된다는 점은 매우 큰 실용적 장점이다.18</p>
<h3>파티클 필터(PF): 가우시안의 굴레를 벗어난 궁극의 유연성</h3>
<p>파티클 필터(Particle Filter, PF)는 EKF와 UKF가 여전히 고수하고 있는 ’가우시안’이라는 가정마저 완전히 버린, 가장 유연한 비선형 필터다. PF의 핵심 아이디어는 어떤 복잡한 형태의 확률 분포라도, 수많은 무작위 샘플, 즉 파티클(Particles)들의 집합으로 근사할 수 있다는 것이다.25</p>
<p>PF의 동작 방식은 직관적인 몬테카를로 시뮬레이션에 가깝다.</p>
<ol>
<li><strong>초기화:</strong> 수천, 수만 개의 파티클을 상태 공간에 뿌린다. 각 파티클은 “객체가 여기에 있을 수도 있다“는 하나의 가설을 의미한다.</li>
<li><strong>예측 (Propagation):</strong> 모든 파티클을 상태 전이 모델 <span class="math math-inline">f</span>에 따라 이동시킨다. 이때 약간의 무작위 노이즈를 추가하여 시스템의 불확실성을 반영한다.</li>
<li><strong>업데이트 (Weighting):</strong> 실제 측정값 <span class="math math-inline">\mathbf{z}_k</span>가 들어오면, 각 파티클이 이 측정값을 얼마나 잘 설명하는지를 나타내는 가능도(likelihood)를 계산한다. 이 가능도를 기반으로 각 파티클에 가중치(weight)를 부여한다. 실제 측정값과 가까운 위치의 파티클은 높은 가중치를, 먼 곳의 파티클은 낮은 가중치를 받게 된다.</li>
<li><strong>리샘플링 (Resampling):</strong> 가중치가 낮은 파티클은 버리고, 가중치가 높은 파티클을 그 가중치에 비례하여 복제한다. 이는 마치 ’적자생존’처럼, 가능성이 낮은 가설은 도태시키고 유망한 가설에 더 많은 자원을 집중하는 과정이다. 이 단계를 통해 파티클 고갈(degeneracy) 문제를 해결하고 파티클들이 실제 상태 주변에 모이게 된다.24</li>
</ol>
<p>PF는 가우시안 가정을 완전히 버렸기 때문에, 확률 분포가 두 개 이상의 봉우리를 갖는 다봉성(multi-modal) 문제나 매우 비대칭적인 분포를 갖는 문제를 유일하게 제대로 해결할 수 있다. 예를 들어, 로봇이 복도를 가다가 누군가에게 납치되어 다른 위치로 순간 이동했다고 가정해보자. 이 경우 로봇의 위치에 대한 확률 분포는 원래 있던 위치와 새로 옮겨진 위치, 두 곳에 봉우리를 갖게 된다. EKF나 UKF는 이 두 봉우리의 어중간한 중간 지점을 평균으로 계산하여 완전히 틀린 추정을 할 수 있지만, PF는 두 위치에 모두 파티클을 유지함으로써 이러한 상황을 올바르게 표현할 수 있다.6</p>
<table><thead><tr><th>기준 (Criteria)</th><th>확장 칼만 필터 (EKF)</th><th>무향 칼만 필터 (UKF)</th><th>파티클 필터 (PF)</th></tr></thead><tbody>
<tr><td><strong>핵심 아이디어</strong></td><td>비선형 함수를 선형으로 근사 (테일러 1차)</td><td>확률 분포를 시그마 포인트로 근사</td><td>확률 분포를 파티클(샘플)로 근사</td></tr>
<tr><td><strong>비선형성 처리</strong></td><td>자코비안 행렬을 통한 선형화</td><td>무향 변환 (Unscented Transform)</td><td>순차적 몬테카를로 (SMC)</td></tr>
<tr><td><strong>확률 분포 가정</strong></td><td>가우시안 (Gaussian)</td><td>가우시안 (Gaussian)</td><td>임의의 분포 (Non-Gaussian)</td></tr>
<tr><td><strong>장점</strong></td><td>계산적으로 가장 효율적, 구현이 (비교적) 간단</td><td>EKF보다 정확, 자코비안 불필요</td><td>매우 유연, 비가우시안/다봉성 문제 해결 가능</td></tr>
<tr><td><strong>단점</strong></td><td>강한 비선형성에 취약, 발산 위험, 자코비안 유도 필요</td><td>EKF보다 계산량 많음, 여전히 가우시안 가정</td><td>계산량 가장 많음, 파티클 수에 성능 의존, 파티클 고갈(degeneracy) 문제</td></tr>
<tr><td><strong>계산 복잡도</strong></td><td>낮음 (상태 차원 <span class="math math-inline">n</span>에 대해 <span class="math math-inline">O(n^3)</span>)</td><td>중간 (<span class="math math-inline">O(n^3)</span>, EKF보다 상수배 높음)</td><td>높음 (파티클 수 <span class="math math-inline">N</span>에 대해 <span class="math math-inline">O(N)</span>)</td></tr>
<tr><td><strong>언제 사용하는가?</strong></td><td>시스템이 약한 비선형성을 띠고, 계산 자원이 제한적일 때 18</td><td>시스템이 강한 비선형성을 띠지만, 분포는 가우시안으로 가정할 수 있을 때 9</td><td>시스템이 매우 비선형적이거나, 분포가 명백히 비가우시안일 때 25</td></tr>
</tbody></table>
<h2>결론: 현명한 EKF 활용을 위한 최종 조언</h2>
<p>확장 칼만 필터는 비선형 상태 추정의 세계로 들어가는 첫 관문이자, 여전히 많은 분야에서 현역으로 활약하는 강력한 도구다. EKF의 성공적인 적용은 알고리즘 자체의 이해를 넘어, 모델링과 튜닝의 디테일에 달려 있다.</p>
<h3>EKF 구현을 위한 핵심 체크리스트</h3>
<p>EKF를 구현하고 디버깅할 때 다음 체크리스트를 따라가면 많은 실수를 예방할 수 있다.</p>
<ol>
<li><strong>모델링의 정확성:</strong> 상태 전이 함수 <span class="math math-inline">f</span>와 측정 함수 <span class="math math-inline">h</span>가 물리적 현실을 올바르게 반영하는가? CTRV 모델의 단위(라디안 vs. 도)나 좌표계(전역 vs. 지역) 같은 기본적인 사항을 명확히 정의했는가?</li>
<li><strong>자코비안의 검증:</strong> 자코비안 행렬 <span class="math math-inline">\mathbf{F}</span>와 <span class="math math-inline">\mathbf{H}</span>를 손으로 유도한 후, 반드시 수치 미분(finite differences)을 이용해 그 결과를 검증해야 한다. 이는 EKF 구현에서 가장 흔한 버그의 원천이다.</li>
<li><strong>초기값의 합리성:</strong> 초기 상태 <span class="math math-inline">\hat{\mathbf{x}}_{0|0}</span>와 초기 공분산 <span class="math math-inline">\mathbf{P}_{0|0}</span>을 합리적으로 설정했는가? 초기 상태를 전혀 모른다면 공분산을 큰 값으로 설정하여 필터가 초기에는 측정값을 더 신뢰하도록 만들 수 있다. 하지만 너무 큰 값은 수치적 불안정성을 야기할 수 있다.</li>
<li><strong>노이즈 튜닝의 기술:</strong> 프로세스 노이즈 공분산 <span class="math math-inline">\mathbf{Q}</span>와 측정 노이즈 공분산 <span class="math math-inline">\mathbf{R}</span>은 필터의 성능을 좌우하는 가장 중요한 튜닝 파라미터다. <span class="math math-inline">\mathbf{R}</span>은 보통 센서 제조사의 사양을 참고하여 설정할 수 있지만, <span class="math math-inline">\mathbf{Q}</span>는 시스템 모델이 얼마나 불완전한지를 나타내므로 실험적으로 결정해야 한다. <span class="math math-inline">\mathbf{Q}</span>를 크게 하면 필터가 모델 예측보다 측정값을 더 믿게 되어 반응이 빨라지지만 노이즈에 민감해지고, 작게 하면 예측을 더 믿어 결과가 부드러워지지만 실제 변화를 늦게 따라갈 수 있다. 필터의 혁신 시퀀스(<span class="math math-inline">\tilde{\mathbf{y}}_k</span>)를 모니터링하며 그 통계적 특성을 분석하여 <span class="math math-inline">\mathbf{Q}</span>와 <span class="math math-inline">\mathbf{R}</span>을 튜닝하는 기법도 있다.</li>
<li><strong>특이점 처리 로직:</strong> CTRV 모델에서 선회율 <span class="math math-inline">\dot{\psi}</span>이 0에 가까워지는 경우처럼, 모델에 수학적 특이점이 존재한다면 이를 회피하기 위한 분기 처리 로직이 반드시 포함되어야 한다.</li>
</ol>
<h3>구현을 위한 조언 및 라이브러리</h3>
<p>이론을 이해했다면 직접 코드를 작성해보는 것이 최고의 학습 방법이다. <code>numpy</code> 라이브러리를 사용하면 EKF의 행렬 연산을 효율적으로 구현할 수 있다. 다음은 EKF 업데이트 단계의 핵심 로직을 보여주는 Python 코드 스니펫의 예시다.</p>
<pre><code class="language-Python"># H는 상태에 따라 계산된 자코비안 행렬
# P_pred는 예측된 공분산, R은 측정 노이즈 공분산
# np는 numpy 라이브러리
S = H @ P_pred @ H.T + R

# 칼만 이득 계산
K = P_pred @ H.T @ np.linalg.inv(S)

# z는 실제 측정값, hx는 예측된 측정값 (h(x_pred))
y = z - hx

# 상태 및 공분산 업데이트
x_est = x_pred + K @ y
P_est = (np.eye(n_states) - K @ H) @ P_pred
</code></pre>
<p>CTRV 모델과 라이다/레이더 센서 퓨전을 구현한 완전한 형태의 Python 예제는 GitHub 등에서 쉽게 찾아볼 수 있다.28 또한, 모든 것을 밑바닥부터 구현할 필요는 없다.</p>
<p><code>FilterPy</code>와 같은 잘 알려진 오픈소스 라이브러리는 EKF, UKF 등 다양한 필터를 구현해 놓아 사용자가 자신의 문제에 집중할 수 있도록 돕는다.30</p>
<h3>심화 학습을 위한 참고 자료</h3>
<p>이 문서를 통해 EKF의 기초를 다졌다면, 더 깊이 있는 학습을 위해 다음 자료들을 참고하는 것이 좋다.</p>
<ul>
<li><strong>서적:</strong>
<ul>
<li>Sebastian Thrun, Wolfram Burgard, Dieter Fox, <strong>“Probabilistic Robotics”</strong>: 로봇 공학 관점에서 칼만 필터, EKF, UKF, 파티클 필터를 매우 직관적이고 실용적으로 설명하는 필독서다.25</li>
<li>Yaakov Bar-Shalom, X. Rong Li, Thiagalingam Kirubarajan, <strong>“Estimation with Applications to Tracking and Navigation”</strong>: 추적 및 항법 분야의 바이블로, 더 깊이 있는 수학적 이론과 다양한 응용 사례를 다룬다.</li>
</ul>
</li>
<li><strong>주요 논문:</strong>
<ul>
<li>R. E. Kalman, “A New Approach to Linear Filtering and Prediction Problems” (1960): 모든 것의 시작이 된 역사적인 논문.</li>
<li>S. Julier &amp; J. Uhlmann, “A New Extension of the Kalman Filter to Nonlinear Systems” (1997): UKF를 처음 제안한 논문.</li>
<li>A. Doucet et al., “On sequential Monte Carlo sampling methods for Bayesian filtering” (2000): 파티클 필터의 이론적 기반을 다진 중요한 논문.</li>
</ul>
</li>
</ul>
<p>EKF는 완벽하지 않다. 하지만 그 한계를 명확히 이해하고, 문제의 특성에 맞게 UKF나 파티클 필터와 같은 대안을 고려할 수 있을 때, 비로소 진정한 상태 추정 전문가로 거듭날 수 있을 것이다.</p>
<h4><strong>참고 자료</strong></h4>
<ol>
<li>Extended Kalman filter - Wikipedia, accessed July 29, 2025, https://en.wikipedia.org/wiki/Extended_Kalman_filter</li>
<li>Kalman and Extended Kalman Filters: Concept, Derivation and Properties - ResearchGate, accessed July 29, 2025, https://www.researchgate.net/publication/2888846_Kalman_and_Extended_Kalman_Filters_Concept_Derivation_and_Properties</li>
<li>Derivation of Extended Kalman Filtering and Smoothing Equations, accessed July 29, 2025, https://users.ece.cmu.edu/~byronyu/papers/derive_eks.pdf</li>
<li>Probabilistic Robotics, accessed July 29, 2025, http://ais.informatik.uni-freiburg.de/teaching/ws15/mapping/pdf/slam04-ekf.pdf</li>
<li>The Extended Kalman Filter (EKF) - Wireless Pi, accessed July 29, 2025, https://wirelesspi.com/the-extended-kalman-filter-ekf/</li>
<li>Probabilistic Algorithms in Robotics - Washington, accessed July 29, 2025, https://courses.cs.washington.edu/courses/cse599j/12sp/papers/ThrunProbRobotics-AIMagazine.pdf</li>
<li>The math behind Extended Kalman Filtering | by Sasha Przybylski - Medium, accessed July 29, 2025, https://medium.com/@sasha_przybylski/the-math-behind-extended-kalman-filtering-0df981a87453</li>
<li>An Improved Extended Kalman Filter for Radar Tracking of Satellite Trajectories - MDPI, accessed July 29, 2025, https://www.mdpi.com/2411-9660/5/3/54</li>
<li>What is the difference between EKF and UKF? - ResearchGate, accessed July 29, 2025, https://www.researchgate.net/post/What_is_the_difference_between_EKF_and_UKF</li>
<li>The Jacobian Matrix, Real Analysis II - YouTube, accessed July 29, 2025, https://www.youtube.com/watch?v=Hpbo4qYgFKA</li>
<li>trackingEKF - Extended Kalman filter for object tracking - MATLAB - MathWorks, accessed July 29, 2025, https://www.mathworks.com/help/radar/ref/trackingekf.html</li>
<li>Mathematic Formula Note of Unscented Kalman Filter with CTRV model - fevemania’s blog, accessed July 29, 2025, https://fevemania.github.io/blog/mathematic-formula-note-of-unscented-kalman-filter/</li>
<li>Comparative evaluation of Kalman filters and motion models in vehicular state estimation and path prediction | The Journal of Navigation - Cambridge University Press, accessed July 29, 2025, https://www.cambridge.org/core/journals/journal-of-navigation/article/comparative-evaluation-of-kalman-filters-and-motion-models-in-vehicular-state-estimation-and-path-prediction/8E194806C5BBE5249A351067801E9CE9</li>
<li>Extended-Kalman-Filter-CTRV.py - GitHub, accessed July 29, 2025, https://github.com/balzer82/Kalman/blob/master/Extended-Kalman-Filter-CTRV.py</li>
<li>www.mathworks.com, accessed July 29, 2025, <a href="https://www.mathworks.com/help/fusion/ref/ctrvjac.html#:~:text=Description,to%20the%20input%20state%2C%20state%20.">https://www.mathworks.com/help/fusion/ref/ctrvjac.html#:~:text=Description,to%20the%20input%20state%2C%20state%20.</a></li>
<li>ctrvjac - Jacobian of state transition function based on constant turn-rate and velocity-magnitude motion model - MATLAB - MathWorks, accessed July 29, 2025, https://www.mathworks.com/help/fusion/ref/ctrvjac.html</li>
<li>Kalman/.ipynb_checkpoints/Extended-Kalman-Filter-CTRA-checkpoint.ipynb at master / balzer82/Kalman / GitHub, accessed July 29, 2025, https://github.com/balzer82/Kalman/blob/master/.ipynb_checkpoints/Extended-Kalman-Filter-CTRA-checkpoint.ipynb</li>
<li>Why should I still use EKF instead of UKF? - Robotics Stack Exchange, accessed July 29, 2025, https://robotics.stackexchange.com/questions/3063/why-should-i-still-use-ekf-instead-of-ukf</li>
<li>Extended Kalman Filters - MATLAB &amp; Simulink - MathWorks, accessed July 29, 2025, https://www.mathworks.com/help/fusion/ug/extended-kalman-filters.html</li>
<li>Extended Kalman Filter (EKF) for Non Linear (Coordinate Conversion - Polar to Cartesian) Measurements and Linear Predictions, accessed July 29, 2025, https://dsp.stackexchange.com/questions/51386/extended-kalman-filter-ekf-for-non-linear-coordinate-conversion-polar-to-ca</li>
<li>16.4 Extended Kalman Filter - Carnegie Mellon University, accessed July 29, 2025, https://www.cs.cmu.edu/~16385/s17/Slides/16.4_Extended_Kalman_Filter.pdf</li>
<li>A Comparison of Unscented and Extended Kalman Filtering for Estimating Quaternion Motion - Department of Electrical Engineering and Computer Science, accessed July 29, 2025, http://www.eecs.ucf.edu/isuelab/publications/pubs/laviola_acc2003.pdf</li>
<li>The Unscented Kalman Filter for Nonlinear Estimation - Harvard University, accessed July 29, 2025, https://groups.seas.harvard.edu/courses/cs281/papers/unscented.pdf</li>
<li>Probabilistic-Robotics-Algorithms/README.md at master - GitHub, accessed July 29, 2025, https://github.com/ChengeYang/Probabilistic-Robotics-Algorithms/blob/master/README.md</li>
<li>Probabilistic Algorithms in Robotics - Sebastian Thrun, accessed July 29, 2025, http://robots.stanford.edu/papers/thrun.probrob.pdf</li>
<li>Extended and Unscented Kalman Filter Algorithms for Online State Estimation - MathWorks, accessed July 29, 2025, https://www.mathworks.com/help/ident/ug/extended-and-unscented-kalman-filter-algorithms-for-online-state-estimation.html</li>
<li>LiDAR and Radar Sensor Fusion using Unscented Kalman Filter | by Nikhil Nair | Medium, accessed July 29, 2025, https://medium.com/@nikhilnair8490/lidar-and-radar-sensor-fusion-using-unscented-kalman-filter-5b20de0ab1d1</li>
<li>sharathsrini/Extended-Kalman-Filter-for-Sensor-Fusion - GitHub, accessed July 29, 2025, https://github.com/sharathsrini/Extended-Kalman-Filter-for-Sensor-Fusion</li>
<li>A2Amir/Extended-Kalman-Filter-for-Sensor-Fusion-Radar-and-Lidar - GitHub, accessed July 29, 2025, https://github.com/A2Amir/Extended-Kalman-Filter-for-Sensor-Fusion-Radar-and-Lidar</li>
<li>extended-kalman-filter / GitHub Topics, accessed July 29, 2025, https://github.com/topics/extended-kalman-filter</li>
<li>Probabilistic Robotics, accessed July 29, 2025, https://gaoyichao.com/Xiaotu/resource/refs/PR.MIT.en.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>