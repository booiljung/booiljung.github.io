<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Ubuntu Server 24.04 네트워크 구성 (Netplan)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Ubuntu Server 24.04 네트워크 구성 (Netplan)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">시스템 (Systems)</a> / <a href="index.html">우분투 리눅스 (Ubuntu Linux)</a> / <span>Ubuntu Server 24.04 네트워크 구성 (Netplan)</span></nav>
                </div>
            </header>
            <article>
                <h1>Ubuntu Server 24.04 네트워크 구성 (Netplan)</h1>
<h2>1.  서론: Ubuntu 24.04 네트워크의 새로운 패러다임, Netplan</h2>
<p>Ubuntu 24.04 LTS 환경에서 네트워크 구성은 <code>Netplan</code>을 통해 수행하는 것이 표준이다. <code>Netplan</code>은 데스크톱, 서버, 클라우드, IoT 등 다양한 Ubuntu 배포판에 걸쳐 일관된 네트워크 구성 방식을 제공하려는 Canonical의 전략적 도구이다.1</p>
<p>Netplan의 핵심 철학은 ‘선언적(declarative)’ 구성에 있다. 관리자는 복잡한 스크립트나 명령형 절차를 기술하는 대신, YAML (Yet Another Markup Language)이라는 가독성 높은 형식을 사용하여 시스템이 도달해야 할 ’원하는 상태(desired state)’를 선언한다.2 이 상태를 실제로 구현하는 복잡한 과정은 Netplan이 내부적으로 처리한다.</p>
<p>이 방식은 과거 <code>/etc/network/interfaces</code> 파일에 인터페이스별로 스크립트와 유사한 명령형 구성을 작성하던 방식 3에서 근본적으로 벗어난 것이다. 선언적 접근법은 구성의 복잡성을 낮추고, 오류 가능성을 줄이며, 시스템 간 설정 이식성을 높인다. 모든 Netplan 설정 파일은 <code>/etc/netplan/</code> 디렉터리 내에 <code>.yaml</code> 확장자로 위치해야 한다.1</p>
<h3>1.1  Netplan 아키텍처: 렌더러(Renderer)의 심층 이해</h3>
<p>Netplan의 아키텍처를 이해하는 것은 문제 해결의 첫걸음이다. 가장 흔한 오해와 달리, Netplan 자체는 네트워크를 직접 관리하는 데몬이나 서비스가 아니다. Netplan은 관리자가 작성한 추상적인 YAML 설정 파일을 읽어, 시스템에서 실제로 네트워킹을 담당할 백엔드 데몬(Backend Daemon)을 위한 네이티브 설정 파일을 생성(render)하는 ‘설정 번역기’ 또는 ’추상화 렌더러(abstraction renderer)’이다.1</p>
<p><code>netplan generate</code> 명령이 실행되면 6, Netplan은 <code>/etc/netplan/</code>의 YAML을 파싱하여 백엔드 데몬이 이해할 수 있는 설정 파일(예: <code>/run/systemd/network/</code> 내의 <code>.network</code> 파일)을 생성한다. 그 후 <code>netplan apply</code>는 이 백엔드 데몬을 재시작하여 새 설정을 적용한다.7</p>
<p>이 아키텍처는 네트워크 문제 진단 시 매우 중요한 함의를 갖는다. 네트워크가 동작하지 않을 때, 관리자는 다음 세 가지 지점을 순차적으로 점검해야 한다.</p>
<ol>
<li><code>/etc/netplan/</code>의 YAML 파일 구문이 유효한가?</li>
<li><code>netplan generate</code> 명령이 <code>/run/</code> 디렉터리에 의도한 백엔드 설정을 올바르게 생성했는가?</li>
<li>실제 백엔드 데몬(예: <code>systemd-networkd</code>)이 오류 없이 실행 중이며, 생성된 설정을 올바르게 해석했는가? 8</li>
</ol>
<h3>1.2  핵심 렌더러(Renderer) 비교: <code>systemd-networkd</code> 대 <code>NetworkManager</code></h3>
<p>Netplan YAML 파일 내의 <code>renderer:</code> 9 지시어는 단순한 옵션이 아니다. 이는 시스템의 전반적인 ’네트워크 운영 모드’를 결정하는 근본적인 선택이다.2 Netplan은 현재 <code>systemd-networkd</code>와 <code>NetworkManager</code>라는 두 가지 주요 렌더러를 지원한다.1</p>
<ol>
<li><strong><code>systemd-networkd</code></strong>:</li>
</ol>
<ul>
<li>Ubuntu Server 설치 시 기본값으로 사용된다.9</li>
<li>네트워크 환경이 거의 변하지 않는 정적(static) 서버, 가상 머신, 컨테이너 호스트 환경에 최적화되어 있다.3</li>
<li>브리징(Bridging), 본딩(Bonding), VLAN 등 고급 서버 네트워킹 기능을 강력하게 지원한다.3</li>
<li>관련 CLI 도구로 <code>networkctl</code>이 있다.10</li>
</ul>
<ol start="2">
<li><strong><code>NetworkManager</code></strong>:</li>
</ol>
<ul>
<li>Ubuntu Desktop 설치 시 기본값이며, 과거 모든 Ubuntu 버전에서 사용되었다.9</li>
<li>Wi-Fi, VPN, 모바일 브로드밴드 등 네트워크 요구사항이 자주 변경되는 동적(dynamic) 환경에 적합하다.3</li>
<li>데스크톱 GUI 환경과 완벽하게 통합되며, <code>nmcli</code>, <code>nmtui</code> 같은 강력한 CLI/TUI 도구를 제공한다.9</li>
</ul>
<p>Ubuntu Server 24.04 환경에서는 특별히 Wi-Fi나 복잡한 VPN 연결이 필요하지 않은 한, 기본 렌더러인 <code>systemd-networkd</code>를 사용하는 것이 표준이다. 본 안내서는 <code>systemd-networkd</code>를 중심으로 서술한다.</p>
<p><strong>표 1. 렌더러 핵심 비교 (<code>systemd-networkd</code> vs. <code>NetworkManager</code>)</strong></p>
<table><thead><tr><th><strong>기능</strong></th><th><strong>systemd-networkd</strong></th><th><strong>NetworkManager</strong></th></tr></thead><tbody>
<tr><td><strong>주 사용처</strong></td><td>서버, 클라우드 VM 3</td><td>데스크톱, 랩톱 2</td></tr>
<tr><td><strong>환경 적합성</strong></td><td>정적(Static), 예측 가능한 환경 9</td><td>동적(Dynamic), 변동성 높은 환경 9</td></tr>
<tr><td><strong>Wi-Fi/VPN 지원</strong></td><td>제한적/복잡함 3</td><td>네이티브 지원 (권장됨) 3</td></tr>
<tr><td><strong>주요 관리 도구</strong></td><td><code>networkctl</code> 10</td><td><code>nmcli</code>, <code>nmtui</code> 11</td></tr>
<tr><td><strong>서버 기능 (본딩/브리지)</strong></td><td>강력하며 서버 환경에 권장됨 3</td><td>가능하나 12, <code>networkd</code>가 선호됨 3</td></tr>
<tr><td><strong>Netplan YAML 예제</strong></td><td><code>renderer: networkd</code> 4</td><td><code>renderer: NetworkManager</code> 9</td></tr>
</tbody></table>
<h2>2.  1단계: 시스템 네트워크 환경 분석</h2>
<p>Netplan YAML 파일 작성을 시작하기 전, 가장 먼저 수행해야 할 작업은 시스템의 물리적, 논리적 네트워크 인터페이스 이름을 정확히 식별하는 것이다.</p>
<h3>2.1  ’예측 가능한 인터페이스 이름’의 이해</h3>
<p>과거 리눅스 시스템은 네트워크 인터페이스를 <code>eth0</code>, <code>eth1</code> 5 등으로 명명했다. 이 방식은 커널이 부팅 시 드라이버를 로드하고 장치를 인식하는 순서에 따라 결정되었다. 이로 인해 서버에 디스크 컨트롤러나 USB 장치 등 다른 하드웨어를 추가/제거하면, 부팅 시 인터페이스 이름(<code>eth0</code>이 <code>eth1</code>로 변경)이 예기치 않게 뒤바뀌는 심각한 문제가 발생했다.</p>
<p>이러한 불안정성을 해결하기 위해, 최신 Ubuntu 서버는 ‘예측 가능한 네트워크 인터페이스 이름(Predictable Network Interface Names)’ 체계를 사용한다.5 이 이름은 더 이상 부팅 순서에 의존하지 않으며, 인터페이스의 물리적 위치(예: 온보드 펌웨어, PCI 버스 주소)에 기반하여 영구적으로 할당된다.</p>
<p>이름의 예시는 다음과 같다 4:</p>
<ul>
<li><code>eno1</code>: 온보드(Onboard) NIC</li>
<li><code>enp0s25</code>: PCI 버스 0, 슬롯 25에 연결된 NIC</li>
<li><code>wlp1s0</code>: 무선(WLAN) PCI 장치</li>
</ul>
<p>이 이름들은 <code>eth0</code>보다 복잡해 보일 수 있으나, 하드웨어 구성이 변경되어도 항상 동일한 물리적 포트를 지칭하므로 서버 환경의 안정성을 비약적으로 향상시킨다. Netplan YAML 파일의 <code>ethernets:</code>, <code>wifis:</code> 섹션에는 반드시 이 정확한 이름을 사용해야 한다.</p>
<h3>2.2  인터페이스 식별 핵심 명령어</h3>
<p>Netplan 설정에 필요한 인터페이스 이름과 하드웨어 정보를 확인하는 명령어는 다음과 같다.</p>
<ol>
<li><strong><code>ip</code> 명령어 (필수)</strong>:</li>
</ol>
<ul>
<li><code>ip link show</code>: 시스템의 모든 네트워크 인터페이스 목록과 L2(링크 계층) 정보(MAC 주소, 링크 상태(UP/DOWN))를 표시한다.11 인터페이스의 존재와 논리적 이름을 확인하는 가장 기본적이고 정확한 방법이다.</li>
<li><code>ip a</code> (또는 <code>ip addr show</code>): <code>ip link</code>의 모든 정보에 더해, 각 인터페이스에 할당된 L3(네트워크 계층) 정보, 즉 IPv4 및 IPv6 주소를 함께 보여준다.5</li>
<li>가독성을 높이기 위해 <code>ip -c a</code> (컬러 출력) 19 또는 <code>ip -br a</code> (간략한 테이블 형식) 20 옵션을 사용할 수 있다.</li>
</ul>
<ol start="2">
<li><strong><code>lshw</code> 명령어 (하드웨어 상세)</strong>:</li>
</ol>
<ul>
<li><code>sudo lshw -C network</code>: <code>ip</code> 명령어가 보여주는 논리적 이름(logical name) 외에 5, 해당 인터페이스의 물리적 하드웨어 세부 정보(제조사, 제품명, 버스 정보, 사용 중인 커널 드라이버)를 매우 상세하게 보여준다.5 특정 하드웨어의 드라이버 호환성 문제를 진단하거나 여러 포트 중 특정 포트를 물리적으로 식별해야 할 때 필수적이다.</li>
</ul>
<ol start="3">
<li><strong>레거시 도구 (참고)</strong>:</li>
</ol>
<ul>
<li><code>ifconfig -a</code> 13: <code>net-tools</code> 패키지에 포함된 고전적인 명령어이다. Ubuntu 24.04 서버 최소 설치 버전에는 기본적으로 포함되어 있지 않을 수 있으며 22, <code>ip</code> 명령어가 이 기능을 완전히 대체한다.</li>
<li><code>netstat -i</code> 23: 인터페이스 목록과 간단한 통계를 보여준다.</li>
</ul>
<p><strong>표 2. 인터페이스 식별 명령어 비교</strong></p>
<table><thead><tr><th><strong>명령어</strong></th><th><strong>주요 용도</strong></th><th><strong>제공 정보</strong></th></tr></thead><tbody>
<tr><td><code>ip a</code> (또는 <code>ip addr show</code>)</td><td>인터페이스 이름, IP 주소, MAC 주소, 상태(UP/DOWN) 확인 5</td><td>논리적/소프트웨어적 상태 (L2/L3)</td></tr>
<tr><td><code>ip link show</code></td><td>인터페이스 이름, MAC 주소, 상태(UP/DOWN) 확인 11</td><td>링크 계층 정보 (L2)</td></tr>
<tr><td><code>lshw -C network</code></td><td>하드웨어 세부 정보 5</td><td>물리적 정보 (제품명, 제조사, 드라이버) (L1)</td></tr>
<tr><td><code>networkctl status</code></td><td><code>systemd-networkd</code>가 관리하는 인터페이스 상태 10</td><td>렌더러 관점의 상태</td></tr>
<tr><td><code>nmcli dev status</code></td><td><code>NetworkManager</code>가 관리하는 인터페이스 상태 11</td><td>렌더러 관점의 상태</td></tr>
</tbody></table>
<h2>3.  2단계: 기본 네트워크 구성 (Netplan YAML 작성)</h2>
<p>인터페이스 이름을 확인했다면, 이제 <code>/etc/netplan/</code> 디렉터리에 <code>.yaml</code> 설정 파일을 작성할 차례이다.</p>
<h3>3.1  Netplan YAML 파일 관리: 오버라이드(Override) 전략</h3>
<p>Netplan은 시스템 부팅 시 또는 <code>netplan</code> 명령어 실행 시, 여러 위치의 설정 파일을 순차적으로 읽어들여 하나의 논리적 설정으로 병합한다. Netplan은 <code>/lib/netplan/*.yaml</code>, <code>/etc/netplan/*.yaml</code>, <code>/run/netplan/*.yaml</code> 순서로 파일을 고려한다.6</p>
<p>특히 관리자가 직접 수정하는 <code>/etc/netplan/</code> 디렉터리 내에서는, 파일들이 알파벳 순서(lexicographical order)로 병합된다. 예를 들어 <code>00-installer-config.yaml</code>이 먼저 적용되고, 그다음 <code>50-cloud-init.yaml</code>, 마지막으로 <code>99-admin-override.yaml</code>이 적용된다.</p>
<p>Ubuntu 설치 프로그램은 종종 <code>00-installer-config.yaml</code> 24 또는 <code>50-cloud-init.yaml</code> 같은 기본 설정 파일을 생성한다.</p>
<p><strong>Best Practice:</strong> 설치 프로그램이 생성한 이 기본 파일을 직접 수정하는 것은 권장되지 않는다. 시스템 업그레이드 시 충돌이 발생하거나, 클라우드 환경에서는 cloud-init에 의해 덮어쓰여질 수 있기 때문이다. 대신, 관리자는 <code>99-custom.yaml</code>과 같이 알파벳 순서에서 가장 뒤에 오는 새 파일을 생성하여, 기존 설정을 ’오버라이드(override)’하는 방식을 사용해야 한다. 이 방식이 가장 안전하고, 확장 가능하며, 변경 사항을 추적하기 용이하다.</p>
<h3>3.2  사례 1: DHCP를 이용한 동적 IP 할당</h3>
<p>가장 단순한 구성이다. <code>ethernets</code> 섹션 아래에 식별된 인터페이스 이름을 명시하고, <code>dhcp4: true</code> (IPv4) 및/또는 <code>dhcp6: true</code> (IPv6)를 선언한다.4</p>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-dhcp.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp3s0:      # 'ip a'로 확인한 인터페이스 이름
      dhcp4: true
      dhcp6: true
</code></pre>
<p><strong>심화:</strong> 만약 서버에 여러 네트워크 인터페이스가 있고, 모든 인터페이스가 DHCP를 통해 기본 게이트웨이(Default Gateway)를 받는다고 가정하자. 이때 특정 인터페이스(예: 관리용 네트워크)의 라우팅 우선순위를 낮추고 싶다면 <code>dhcp4-overrides</code>를 사용할 수 있다. <code>route-metric</code> 값을 높게 설정하면(숫자가 낮을수록 우선순위가 높음), 해당 경로가 덜 선호된다.4</p>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-dual-dhcp.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enred:  # 메인 인터페이스 (낮은 메트릭, 높은 우선순위)
      dhcp4: true
      dhcp4-overrides:
        route-metric: 100
    engreen: # 백업/관리 인터페이스 (높은 메트릭, 낮은 우선순위)
      dhcp4: true
      dhcp4-overrides:
        route-metric: 200
</code></pre>
<h3>3.3  사례 2: 고정 IP(Static IP) 할당</h3>
<p>대부분의 서버 환경에서 요구되는 표준 구성이다.18 고정 IP를 할당하려면 <code>dhcp4: no</code>로 DHCP를 명시적으로 비활성화하고, <code>addresses</code>, <code>routes</code>, <code>nameservers</code> 블록을 정확히 정의해야 한다.4</p>
<ul>
<li><strong><code>addresses</code></strong>: IP 주소와 서브넷 마스크를 CIDR(Classless Inter-Domain Routing) 표기법으로 리스트(list, <code>-</code> 기호 사용) 형식으로 정의한다.</li>
<li><strong><code>routes</code></strong>: 라우팅 테이블을 정의한다. 기본 게이트웨이(Default Gateway)는 <code>to: default</code>와 <code>via: [게이트웨이 IP]</code>의 조합으로 설정한다.</li>
<li><strong><code>nameservers</code></strong>: DNS 설정을 정의한다. <code>search</code> (검색 도메인, 옵션)와 <code>addresses</code> (DNS 서버 IP 주소 리스트)로 구성된다.</li>
</ul>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-static.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp3s0:                 # 'ip a'로 확인한 인터페이스 이름
      dhcp4: no             # DHCP 비활성화
      addresses:
        - 10.10.10.2/24     # 고정 IP와 서브넷 마스크 (CIDR)
      routes:
        - to: default
          via: 10.10.10.1   # 기본 게이트웨이 주소
      nameservers:
        search: [ mydomain.local, otherdomain.local ] # 검색 도메인 (선택 사항)
        addresses: [ 10.10.10.1, 1.1.1.1 ]          # 주 DNS, 보조 DNS
</code></pre>
<h3>3.4  사례 3: 무선 네트워크(Wi-Fi) 연결</h3>
<p>서버 환경에서 Wi-Fi를 사용하는 것은 일반적이지 않으나, 초기 설정이나 임시 백업망으로 필요할 수 있다. 앞서 ’렌더러 비교’에서 설명했듯이, Wi-Fi는 본질적으로 동적이며 WPA/WPA2 인증이 필요하므로 <code>renderer: NetworkManager</code>를 사용하는 것이 압도적으로 간편하고 강력히 권장된다.9</p>
<p><code>NetworkManager</code>를 렌더러로 지정한 후, <code>wifis:</code> 블록을 사용하고, <code>access-points</code> 섹션에 연결할 네트워크의 SSID와 비밀번호(PSK)를 정의한다.4</p>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-wifi.yaml
network:
  version: 2
  renderer: NetworkManager  # &lt;-- Wi-Fi를 위해 NetworkManager로 변경 
  wifis:
    wlp1s0:                 # 'ip a'로 확인한 무선 인터페이스 이름
      dhcp4: true           # Wi-Fi 네트워크에서 DHCP 사용
      access-points:
        "My-Home-SSID":     # 연결할 Wi-Fi SSID
          password: "My-Secret-Password" # Wi-Fi 비밀번호
</code></pre>
<h2>4.  3단계: 고급 서버 네트워크 구성 (브리지 및 본딩)</h2>
<p><code>systemd-networkd</code> 렌더러는 서버 환경에 필수적인 브리징 및 본딩 기능을 완벽하게 지원한다.</p>
<h3>4.1  가상화를 위한 네트워크 브리지(Bridge) 설정</h3>
<p><strong>목적</strong>: 네트워크 브리지는 호스트 시스템의 물리적 네트워크 인터페이스를 KVM/QEMU 4, Libvirt, Docker, LXD 컨테이너 등과 공유하기 위한 가상 스위치 역할을 한다. 이를 통해 가상 머신(VM)이나 컨테이너가 호스트와 동일한 물리적 네트워크 서브넷에 직접 연결되고, 동일한 대역의 IP 주소를 할당받을 수 있다.</p>
<p><strong>개념</strong>: 브리지를 설정하면, 기존의 물리적 인터페이스(예: <code>enp3s0</code>)는 IP 주소를 갖지 않고, 대신 새로 생성된 브리지 인터페이스(예: <code>br0</code>)의 ’슬레이브’가 된다. DHCP 또는 고정 IP 주소 설정은 물리적 인터페이스가 아닌 <code>br0</code> 인터페이스에 적용되어야 한다.4</p>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-bridge.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp3s0:                 # 물리적 인터페이스
      dhcp4: no             # 물리적 인터페이스의 IP 비활성화
      dhcp6: no
  bridges:
    br0:                    # 생성할 브리지 인터페이스 이름
      interfaces: [ enp3s0 ] # enp3s0을 브리지 멤버로 포함
      dhcp4: yes            # 브리지 인터페이스가 DHCP로 IP를 할당받음
      # --- 또는 고정 IP 설정 ---
      # dhcp4: no
      # addresses: [ 10.10.10.5/24 ]
      # routes:
      #   - to: default
      #     via: 10.10.10.1
      # nameservers:
      #   addresses: [ 10.10.10.1 ]
</code></pre>
<p>KVM/Libvirt와 연동하기 위해, Netplan 설정 적용 후 <code>libvirtd</code>가 이 <code>br0</code> 브리지를 인식하도록 추가 XML 설정이 필요할 수 있다.4</p>
<h3>4.2  고가용성/대역폭을 위한 네트워크 본딩(Bonding)</h3>
<p><strong>목적</strong>: 네트워크 본딩(Bonding) 또는 링크 집합(Link Aggregation)은 두 개 이상의 물리적 인터페이스를 하나의 논리적 인터페이스(예: <code>bond0</code>)로 묶는 기술이다. 주된 목적은 1) 장애 조치(Failover)를 통해 고가용성을 확보하거나 2) 대역폭을 확장(Load Balancing)하는 것이다.4</p>
<p><strong><code>bonds:</code> 블록</strong>: <code>bonds:</code> 섹션 아래에 논리적 본딩 인터페이스를 정의하고, <code>interfaces:</code>에 본딩 멤버가 될 물리적 인터페이스들을 나열한다. 모든 IP 설정은 개별 물리 인터페이스가 아닌 <code>bond0</code> 인터페이스에 적용된다.4</p>
<p><strong><code>parameters:</code></strong>: 본딩의 동작 방식을 결정하는 핵심 설정이다.</p>
<ul>
<li><code>mode: active-backup</code> (Mode 1): 가장 널리 사용되는 장애 조치 모드이다. 하나의 인터페이스(<code>primary</code>로 지정 가능)만 활성 상태로 트래픽을 처리하며, 해당 링크에 장애가 발생하면 즉시 다른 슬레이브 인터페이스가 트래픽을 인계받는다. 스위치 쪽의 별도 설정이 필요 없다.4</li>
<li><code>mode: 802.3ad</code> (Mode 4): LACP (Link Aggregation Control Protocol)를 사용한다. 대역폭 확장과 장애 조치를 동시에 제공한다. 이 모드를 사용하려면, 연결된 <strong>물리적 스위치에서 반드시 LACP (802.3ad) 설정을 지원하고 활성화</strong>해야 한다.4</li>
<li><code>mii-monitor-interval</code>: 링크 상태를 모니터링하는 주기(밀리초)를 지정한다.</li>
</ul>
<p>YAML</p>
<pre><code># /etc/netplan/99-custom-bonding.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp3s0:                 # 본딩 멤버 1
      dhcp4: no
    enp4s0:                 # 본딩 멤버 2
      dhcp4: no
  bonds:
    bond0:                  # 생성할 본드 인터페이스 이름
      interfaces: [ enp3s0, enp4s0 ] # 두 물리적 인터페이스를 멤버로
      dhcp4: yes            # 본드 인터페이스가 DHCP로 IP를 할당받음
      parameters:
        mode: active-backup # 장애 조치 모드
        primary: enp3s0     # 평상시 enp3s0을 우선 사용
        mii-monitor-interval: 100 # 100ms 주기로 링크 상태 모니터링
</code></pre>
<p><strong>표 3. 주요 네트워크 본딩(Bonding) 모드</strong></p>
<table><thead><tr><th><strong>모드</strong></th><th><strong>이름 (번호)</strong></th><th><strong>목적</strong></th><th><strong>스위치 설정</strong></th></tr></thead><tbody>
<tr><td><code>active-backup</code></td><td>Mode 1</td><td>장애 조치 (Failover) 4</td><td>불필요</td></tr>
<tr><td><code>802.3ad</code></td><td>Mode 4</td><td>대역폭 확장 및 장애 조치 (LACP) 4</td><td><strong>필수 (LACP/802.3ad)</strong></td></tr>
<tr><td><code>balance-rr</code></td><td>Mode 0</td><td>대역폭 확장 (Round-Robin) 4</td><td>불필요 (패킷 순서 보장 안 됨)</td></tr>
<tr><td><code>balance-tlb</code></td><td>Mode 5</td><td>송신 부하 분산 (Transmit Load Balancing)</td><td>불필요</td></tr>
<tr><td><code>balance-alb</code></td><td>Mode 6</td><td>송/수신 부하 분산 (Adaptive Load Balancing)</td><td>불필요</td></tr>
</tbody></table>
<h2>5.  4단계: Netplan 설정 적용, 검증 및 문제 해결</h2>
<p>YAML 파일 작성을 완료한 후, 설정을 시스템에 적용하고 검증하는 단계이다.</p>
<h3>5.1  Netplan 3대 핵심 명령어</h3>
<p>Netplan은 설정을 적용하고 관리하기 위해 세 가지 주요 명령어를 제공한다.</p>
<ol>
<li><strong><code>sudo netplan generate</code></strong>:</li>
</ol>
<ul>
<li><code>/etc/netplan/</code>의 YAML 파일을 읽어 구문(syntax)을 검사한다.7</li>
<li>구문이 유효하면, 렌더러(백엔드 데몬)가 이해할 수 있는 설정 파일(예: <code>/run/systemd/network/</code>)을 생성(generate)한다.6</li>
<li><strong>중요</strong>: 이 명령어는 설정 파일을 생성만 할 뿐, 네트워크 데몬을 재시작하지 않으므로 실제 네트워크 설정이 변경되지는 않는다.6 YAML 파일의 구문 오류를 미리 검증하는 용도로 유용하다. <code>--debug</code> 옵션과 함께 사용하면 더 상세한 정보를 얻을 수 있다.6</li>
</ul>
<ol start="2">
<li><strong><code>sudo netplan apply</code></strong>:</li>
</ol>
<ul>
<li>내부적으로 <code>netplan generate</code>를 먼저 실행한다.6</li>
<li>그 후, 백엔드 네트워크 데몬(systemd-networkd 또는 NetworkManager)을 재시작(restart)하여 새 설정을 시스템에 즉시 적용(apply)한다.4</li>
<li>이 명령어는 로컬 콘솔에서 작업하거나 이미 검증된 설정을 적용할 때 사용한다.</li>
</ul>
<ol start="3">
<li><strong><code>sudo netplan try</code></strong>:</li>
</ol>
<ul>
<li><strong>원격 관리자의 생명줄(Lifeline)</strong>: 이 명령어는 원격 서버 관리자에게 필수적이다.26</li>
<li>만약 관리자가 SSH 원격 세션을 통해 IP 주소, 서브넷, 게이트웨이 설정을 변경하다가 <code>netplan apply</code>를 실행했는데 설정에 오류가 있다면, SSH 연결은 즉시 끊어지고 서버에 대한 접근 권한을 완전히 잃게(lock-out) 된다.</li>
<li><code>netplan try</code>는 이러한 재앙을 방지한다.25</li>
<li><strong>동작 방식</strong>: 1) 새 설정을 임시로 적용한다. 2) “이 설정을 유지하시겠습니까?(Do you want to keep these settings?)“라는 확인 프롬프트를 띄우고 카운트다운(기본 120초)을 시작한다.27 3) 관리자가 새 설정 하에서도 SSH 접속이 유지되는 것을 확인하고 [Enter] 키를 누르면 설정이 영구 적용된다. 4) 만약 관리자가 응답하지 않거나(접속이 끊어졌거나) [Ctrl]+[C]로 취소하면, 카운트다운 종료 시 이전의 정상 설정으로 자동 롤백(roll back)한다.25</li>
<li><strong>Best Practice</strong>: 로컬 콘솔이 아닌 SSH를 통해 네트워크 설정을 변경할 때는, <code>apply</code> 대신 <strong>반드시</strong> <code>try</code>를 사용해야 한다.26</li>
</ul>
<h3>5.2  네트워크 상태 검증 및 진단</h3>
<p><code>netplan try</code> 또는 <code>apply</code> 실행 후, 다음 단계에 따라 네트워크 상태를 체계적으로 검증해야 한다.</p>
<ol>
<li><strong>1단계 (IP/링크 확인)</strong>:</li>
</ol>
<ul>
<li><code>ip a</code> 18 또는 <code>ip link show</code> 11 명령어를 실행한다.</li>
<li>설정한 인터페이스(또는 브리지/본드)가 <code>UP</code> 상태인지 확인한다.</li>
<li>의도한 고정 IP가 할당되었는지, 또는 DHCP를 통해 유효한 IP를 받았는지 확인한다.</li>
</ul>
<ol start="2">
<li><strong>2단계 (렌더러 상태 확인)</strong>:</li>
</ol>
<ul>
<li>(Netplan 아키텍처 이해) YAML 설정이 백엔드 데몬에 올바르게 적용되었는지 확인한다.</li>
<li><strong><code>systemd-networkd</code> (서버 기본) 사용 시</strong>:</li>
<li><code>networkctl status [인터페이스명]</code> 10 또는 <code>networkctl status</code> (전체 목록)를 실행한다.</li>
<li>인터페이스의 ’State’가 ‘routable’ 또는 ’configured’인지 확인한다. ‘degraded’ 8 상태라면 문제가 발생한 것이다.</li>
<li><code>systemctl status systemd-networkd</code>로 데몬 자체의 활성화 상태를 확인한다.8</li>
<li><code>journalctl -b -u systemd-networkd</code>로 DHCP 요청 실패 등 데몬의 상세 로그를 확인한다.8</li>
<li><strong><code>NetworkManager</code> 사용 시</strong>:</li>
<li><code>nmcli dev status</code> 11 또는 <code>nmcli g</code> (전반적 상태)를 확인한다.</li>
</ul>
<ol start="3">
<li><strong>3단계 (연결성 확인)</strong>:</li>
</ol>
<ul>
<li><code>ip route show</code>로 확인된 기본 게이트웨이 IP로 <code>ping [게이트웨이IP]</code> 18를 실행하여 내부 네트워크 연결을 확인한다.</li>
<li><code>ping 8.8.8.8</code> 18 (Google DNS) 등으로 외부 인터넷 연결을 확인한다.</li>
</ul>
<ol start="4">
<li><strong>4단계 (DNS 확인)</strong>:</li>
</ol>
<ul>
<li><code>nslookup www.google.com</code> 18 또는 <code>resolvectl query www.google.com</code>을 실행하여 <code>nameservers:</code> 설정이 올바르게 동작하는지, DNS 이름 해석이 가능한지 확인한다.</li>
</ul>
<h3>5.3  주요 문제 해결 시나리오</h3>
<ol>
<li><strong>시나리오 1: <code>netplan apply</code> 실행 시 YAML 구문 오류 발생</strong></li>
</ol>
<ul>
<li><em>원인</em>: YAML은 들여쓰기(indentation)에 극도로 민감하다. 스페이스 2칸 또는 4칸을 일관되게 사용해야 하며, <strong>탭(Tab) 문자는 절대로 허용되지 않는다.</strong></li>
<li><em>해결</em>: <code>sudo netplan generate --debug</code> 6를 실행하여 오류가 발생한 정확한 줄과 원인을 확인하고 YAML 파일을 수정한다.</li>
</ul>
<ol start="2">
<li><strong>시나리오 2: 설정은 적용됐으나 IP가 할당되지 않음 (고정 IP)</strong></li>
</ol>
<ul>
<li><em>원인</em>: <code>/etc/netplan/</code> YAML 파일에 기술한 인터페이스 이름(예: <code>enp3s0</code>)이 <code>ip a</code> 5로 확인된 실제 시스템의 인터페이스 이름과 일치하지 않음.</li>
<li><em>해결</em>: <code>ip a</code> 5 명령어로 정확한 인터페이스 이름을 다시 확인하고 YAML 파일을 수정한다.</li>
</ul>
<ol start="3">
<li>시나리오 3: <code>networkctl status</code>에 ‘degraded’ 8 표시</li>
</ol>
<ul>
<li><em>원인</em>: (DHCP의 경우) DHCP 서버에서 응답을 받지 못함. (브리지/본딩의 경우) 슬레이브 인터페이스 중 하나가 물리적으로 연결되지 않았거나 ‘UP’ 상태가 아님.</li>
<li><em>해결</em>: <code>journalctl -b -u systemd-networkd</code> 8 로그를 확인하여 DHCP 실패 원인을 찾거나, <code>ip link set enp3s0 up</code> 16 등으로 물리적 인터페이스를 수동 활성화해 본다.</li>
</ul>
<ol start="4">
<li><strong>시나리오 4: <code>netplan apply</code> 이후 SSH 원격 연결이 즉시 끊김</strong></li>
</ol>
<ul>
<li><em>원인</em>: <code>netplan try</code> 27를 사용하지 않고 원격지에서 IP 주소, 서브넷, 게이트웨이 4 중 하나를 잘못 변경하여 네트워크 경로가 유실됨.</li>
<li><em>해결</em>: 물리적 콘솔 접근 또는 클라우드 제공업체(AWS, GCP, Azure 등)의 웹 콘솔을 통해 설정을 복구해야 한다. <strong>이는 <code>netplan try</code> 사용을 습관화해야 하는 가장 강력한 이유이다</strong>.26</li>
</ul>
<h2>6.  결론: Netplan 기반 네트워크 관리의 확립</h2>
<p>Ubuntu 24.04 서버 환경에서 Netplan은 더 이상 선택 사항이 아닌, 네트워크 구성을 위한 필수 표준이다. Netplan은 선언적 YAML 2의 간결함과 가독성을 통해 복잡한 네트워크 설정을 단순화하며, 동시에 강력한 백엔드 렌더러(<code>systemd-networkd</code> 9)를 통해 고급 서버 기능(브리징, 본딩) 4을 완벽하게 지원한다.</p>
<p>성공적인 시스템 관리자는 Netplan의 아키텍처, 즉 Netplan이 ‘설정 번역기’ 역할을 한다는 점을 명확히 이해해야 한다. 이를 통해 문제 발생 시 YAML 파일, 렌더링 결과, 그리고 <code>networkctl</code> 10과 같은 백엔드 진단 도구를 체계적으로 점검할 수 있다.</p>
<p>또한, 원격 관리 시에는 <code>netplan apply</code>의 위험성을 인지하고, 설정 롤백 기능이 내장된 <code>netplan try</code> 26를 습관적으로 사용하여 시스템 접근 유실이라는 치명적인 실수를 방지해야 한다. 이러한 원칙을 준수할 때, 관리자는 Ubuntu 24.04 서버에서 가장 예측 가능하고 안정적이며 확장 가능한 네트워크 환경을 구축하고 유지할 수 있다.</p>
<h2>7. Works cited</h2>
<ol>
<li>Netplan brings consistent network configuration across Desktop …, accessed November 12, 2025, https://ubuntu.com/blog/netplan-configuration-across-desktop-server-cloud-and-iot</li>
<li>Netplan systemd-networkd and NetworkManager trio - Ubuntu - Reddit, accessed November 12, 2025, https://www.reddit.com/r/Ubuntu/comments/16oizuj/netplan_systemdnetworkd_and_networkmanager_trio/</li>
<li>NetworkManager.service VS. systemd-networkd.service VS networking.service - Unix &amp; Linux Stack Exchange, accessed November 12, 2025, https://unix.stackexchange.com/questions/710751/networkmanager-service-vs-systemd-networkd-service-vs-networking-service</li>
<li>Examples - Netplan documentation, accessed November 12, 2025, https://people.ubuntu.com/~slyon/netplan-docs/examples/</li>
<li>Configuring networks - Ubuntu Server documentation, accessed November 12, 2025, https://documentation.ubuntu.com/server/explanation/networking/configuring-networks/</li>
<li>NETPLAN-GENERATE, accessed November 12, 2025, https://netplan.readthedocs.io/en/stable/netplan-generate/</li>
<li>accessed November 12, 2025, <a href="https://netplan.io/#:~:text=Commands,renderers%2C%20restarting%20them%20as%20necessary.">https://netplan.io/#:~:text=Commands,renderers%2C%20restarting%20them%20as%20necessary.</a></li>
<li>Networkctl “Degraded” : r/linux4noobs - Reddit, accessed November 12, 2025, https://www.reddit.com/r/linux4noobs/comments/4ddoiv/networkctl_degraded/?tl=ko</li>
<li>networking - netplan vs NetworkManager on Ubuntu 18.04 and …, accessed November 12, 2025, https://askubuntu.com/questions/1122757/netplan-vs-networkmanager-on-ubuntu-18-04-and-above</li>
<li>networkctl - Check Network Status on Linux - Tecmint, accessed November 12, 2025, https://www.tecmint.com/networkctl-check-linux-network-interface-status/</li>
<li>How to List Network Interfaces in Ubuntu, accessed November 12, 2025, https://learnubuntu.com/list-network-interfaces/</li>
<li>Few Questions about NetworkManager vs systemd-networkd on both RedHat and ubuntu : r/linuxadmin - Reddit, accessed November 12, 2025, https://www.reddit.com/r/linuxadmin/comments/klhcpt/few_questions_about_networkmanager_vs/</li>
<li>[Linux] NetPlan을 이용해 IP 주소 변경하기 - Ga0Lee, accessed November 12, 2025, <a href="https://ga0lee.tistory.com/entry/Linux-NetPlan%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-IP-%EC%A3%BC%EC%86%8C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0">https://ga0lee.tistory.com/entry/Linux-NetPlan%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-IP-%EC%A3%BC%EC%86%8C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0</a></li>
<li>How can I find available network interfaces? - Unix &amp; Linux Stack Exchange, accessed November 12, 2025, https://unix.stackexchange.com/questions/125400/how-can-i-find-available-network-interfaces</li>
<li>Finding Your Linux IP Address - University of Rochester, accessed November 12, 2025, https://tech.rochester.edu/tutorials/finding-your-linux-ip-address/</li>
<li>ip-link - network device configuration - Ubuntu Manpage, accessed November 12, 2025, https://manpages.ubuntu.com/manpages/jammy/man8/ip-link.8.html</li>
<li>[Ubuntu] 우분투 IP 확인방법 - Dongle’s 개발노트, accessed November 12, 2025, https://dongle94.github.io/ubuntu/ubuntu-check-ip/</li>
<li>Ubuntu 24.04 LTS IP 고정 설정하기, accessed November 12, 2025, https://blog.injunweb.com/post/52/</li>
<li>Identify PHYSICAL Network Interfaces? - Ask Ubuntu, accessed November 12, 2025, https://askubuntu.com/questions/1477667/identify-physical-network-interfaces</li>
<li>ip - show / manipulate routing, network devices, interfaces and tunnels - Ubuntu Manpage, accessed November 12, 2025, https://manpages.ubuntu.com/manpages/jammy/man8/ip.8.html</li>
<li>리눅스(Linux) 네트워크 인터페이스 설정 [ ifconfig 명령어] - Mind Doodle - 티스토리, accessed November 12, 2025, <a href="https://minddoodle.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4Linux-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95-ifconfig-%EB%AA%85%EB%A0%B9%EC%96%B4">https://minddoodle.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4Linux-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%84%A4%EC%A0%95-ifconfig-%EB%AA%85%EB%A0%B9%EC%96%B4</a></li>
<li>How to get the ip address without ifconfig or ip command in Ubuntu?, accessed November 12, 2025, https://askubuntu.com/questions/1443572/how-to-get-the-ip-address-without-ifconfig-or-ip-command-in-ubuntu</li>
<li>How can I list installed network cards using Terminal? - Ask Ubuntu, accessed November 12, 2025, https://askubuntu.com/questions/425859/how-can-i-list-installed-network-cards-using-terminal</li>
<li>Ubuntu 24.04에서 Netplan 설정이 적용되지 않음, accessed November 12, 2025, https://www.reddit.com/r/Ubuntu/comments/1ebnu7a/netplan_not_applying_config_on_ubuntu_2404/?tl=ko</li>
<li>Canonical Netplan, accessed November 12, 2025, https://netplan.io/</li>
<li>Do I need to issue netplan apply after netplan try? - Ask Ubuntu, accessed November 12, 2025, https://askubuntu.com/questions/1354576/do-i-need-to-issue-netplan-apply-after-netplan-try</li>
<li>netplan이 어떻게 작동하려고 하는 거야? : r/linuxadmin - Reddit, accessed November 12, 2025, https://www.reddit.com/r/linuxadmin/comments/xa0764/how_does_netplan_try_work/?tl=ko</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>