<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:OverlayFS 파일 시스템</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>OverlayFS 파일 시스템</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">시스템 (Systems)</a> / <a href="index.html">파일 시스템 (File Systems)</a> / <span>OverlayFS 파일 시스템</span></nav>
                </div>
            </header>
            <article>
                <h1>OverlayFS 파일 시스템</h1>
<h2>1. 서론</h2>
<p>OverlayFS는 리눅스를 위한 현대적 유니온 마운트(union mount) 파일 시스템으로, 여러 파일 시스템이나 디렉터리 트리를 계층적으로 중첩하여 사용자에게 단일 통합 뷰(unified view)를 제공하는 강력한 기술이다.1 이 파일 시스템의 핵심 철학은 하나 이상의 읽기 전용(read-only) 하위 레이어(lower layer) 위에 읽기-쓰기(read-write)가 가능한 상위 레이어(upper layer)를 겹쳐 놓는 것이다.3 이 구조를 통해 발생하는 모든 변경 사항은 상위 레이어에만 기록되며, 하위 레이어는 원본 상태를 그대로 유지하게 된다.1 이러한 특성 덕분에 OverlayFS는 시스템의 불변성(immutability)을 보장하면서도 유연한 변경을 허용하는 독특한 능력을 갖추게 된다.</p>
<p>본 안내서는 OverlayFS의 내부 아키텍처, 핵심 동작 원리인 Copy-on-Write(CoW), 실제 시스템에서의 활용 방안, 그리고 성능에 영향을 미치는 주요 요인들을 심층적으로 분석한다. 더 나아가, POSIX 표준과의 비호환성 문제, 주요 보안 취약점 사례, 그리고 Aufs와 같은 다른 유니온 파일 시스템과의 비교를 통해 OverlayFS의 기술적 한계와 장점을 명확히 규명한다. 최종적으로, 시스템 아키텍트, 데브옵스 엔지니어, 그리고 보안 전문가가 이 기술을 시스템 설계, 성능 최적화, 보안 감사 등의 실무에 효과적으로 적용할 수 있도록 종합적이고 심도 있는 통찰을 제공하는 것을 목표로 한다.</p>
<p>OverlayFS는 단순한 파일 시스템 기술의 범주를 넘어선다. 이는 컨테이너화(containerization) 기술의 대명사인 도커(Docker)의 핵심 스토리지 드라이버로 채택되면서 현대 클라우드 네이티브 컴퓨팅 환경의 근간을 이루게 되었다.5 또한, Live CD나 IoT 기기와 같이 쓰기 횟수가 제한된 플래시 메모리를 사용하는 시스템에서도 원본 미디어를 보호하는 효율적인 솔루션을 제공한다.2 나아가, 서버 구성을 코드처럼 관리하고 배포 시마다 새로운 인스턴스로 교체하는 불변 인프라(Immutable Infrastructure) 패러다임을 파일 시스템 수준에서 완벽하게 지원하는 핵심 구현체로서 그 중요성이 날로 증대되고 있다.7 따라서 OverlayFS에 대한 깊이 있는 이해는 현대 IT 인프라를 구축하고 운영하는 모든 기술 전문가에게 필수적인 역량이라 할 수 있다.</p>
<h2>2.  OverlayFS의 구조와 핵심 원리</h2>
<h3>2.1  유니온 파일 시스템의 개념과 역사</h3>
<p>유니온 파일 시스템은 여러 개의 독립된 디렉터리, 즉 브랜치(branch)의 내용을 물리적으로는 분리된 상태를 유지하면서, 논리적으로는 하나의 통합된 디렉터리처럼 보이도록 병합하는 파일 시스템 기술이다.2 사용자는 이 통합된 뷰를 통해 여러 소스에 흩어져 있는 파일과 디렉터리를 단일 경로에서 접근하고 조작할 수 있다.10 이러한 개념은 시스템의 유연성과 효율성을 극대화하는 데 중요한 역할을 한다.</p>
<p>OverlayFS의 등장은 리눅스 유니온 파일 시스템의 역사에서 중요한 전환점을 마련했다. 2010년, Miklos Szeredi에 의해 초기 RFC(Request for Comments) 패치셋이 리눅스 커널 커뮤니티에 제출되었으며, 수년간의 논의와 개선을 거쳐 2014년 리눅스 커널 버전 3.18에 공식적으로 병합되었다.2 이는 Aufs(Another Union File System)와 같이 커널 외부에서 별도의 패치를 통해 유지되던 기존 유니온 파일 시스템들과 근본적인 차이를 보이는 지점이다. 커널 메인라인에 포함됨으로써 OverlayFS는 광범위한 리눅스 배포판에서 표준으로 지원받게 되었고, 이는 안정성, 보안, 그리고 유지보수성 측면에서 큰 이점을 가져왔다. 이후 커널 4.0에서는 도커의 <code>overlay2</code> 스토리지 드라이버가 요구하는 기능 개선이 이루어지는 등 지속적인 발전을 거듭하며 사실상의 표준 유니온 파일 시스템으로 자리매김하게 되었다.2</p>
<h3>2.2  OverlayFS의 4대 구성 요소</h3>
<p>OverlayFS의 동작을 이해하기 위해서는 네 가지 핵심 구성 요소의 역할과 상호작용을 명확히 파악해야 한다. 이 구성 요소들은 계층적 파일 시스템이라는 OverlayFS의 본질을 구현하는 기본 단위이다.</p>
<ul>
<li>
<p><code>lowerdir</code> (하위 디렉터리): <code>lowerdir</code>는 변경되지 않는 원본 데이터를 담고 있는 하나 이상의 읽기 전용(Read-Only) 베이스 레이어(base layer)를 의미한다.5 컨테이너 이미지의 기반이 되는 OS 파일이나 애플리케이션 라이브러리 등이 여기에 해당한다. 마운트 시 여러 개의 <code>lowerdir</code>를 지정할 수 있으며, 이를 통해 다층적인 파일 시스템 구조를 형성할 수 있다.3 <code>lowerdir</code>는 마운트된 후에는 어떠한 쓰기 작업도 허용하지 않음으로써 원본 데이터의 무결성을 보장하는 역할을 한다.5</p>
</li>
<li>
<p><code>upperdir</code> (상위 디렉터리): <code>upperdir</code>는 파일 시스템 계층의 가장 위에 위치하는 읽기-쓰기(Read-Write)가 가능한 레이어다.3 사용자가 <code>merged</code> 디렉터리를 통해 수행하는 모든 변경 작업, 즉 파일 생성, 기존 파일 수정, 파일 삭제 등의 결과가 이 <code>upperdir</code>에 기록된다.5 <code>lowerdir</code>의 불변성을 유지하면서 동적인 변경을 수용하는 창구 역할을 수행한다.</p>
</li>
<li>
<p><code>merged</code> (병합 디렉터리): <code>merged</code> 디렉터리는 <code>lowerdir</code>와 <code>upperdir</code>의 내용이 논리적으로 통합되어 사용자에게 최종적으로 보여지는 가상의 마운트 지점이다.5 사용자는 이 디렉터리를 일반적인 파일 시스템처럼 사용하며, 내부적으로는 OverlayFS가 각 파일 연산을 적절한 레이어로 전달한다. 만약  <code>upperdir</code>와 <code>lowerdir</code>에 동일한 이름의 파일이 존재할 경우, 우선순위가 높은 <code>upperdir</code>의 파일이 <code>merged</code> 뷰에 나타나게 된다.5</p>
</li>
<li>
<p><code>workdir</code> (작업 디렉터리): <code>workdir</code>는 파일 시스템 연산의 원자성(atomicity)을 보장하기 위해 내부적으로 사용되는 임시 작업 공간이다.5 이 디렉터리는 반드시  <code>upperdir</code>와 동일한 파일 시스템 상에 위치해야 하는 제약 조건을 가진다.3</p>
</li>
</ul>
<p><code>workdir</code>의 존재는 OverlayFS의 안정성과 데이터 무결성을 위한 핵심적인 설계 결정이다. <code>copy_up</code>과 같이 여러 단계로 이루어진 복잡한 파일 연산(예: 파일 생성, 메타데이터 복사, 데이터 복사)이 중간에 시스템 장애로 중단될 경우, <code>upperdir</code>에는 불완전하거나 손상된 파일이 남을 수 있다. <code>workdir</code>는 이러한 연산이 완전히 성공하기 전까지의 중간 상태를 처리하는 ‘준비 영역(staging area)’ 역할을 수행한다. 모든 단계가 성공적으로 완료되면, <code>workdir</code>의 결과물은 <code>rename</code> 시스템 콜을 통해 원자적으로 <code>upperdir</code>로 이동된다. 만약 연산이 실패하면 <code>workdir</code>의 내용은 단순히 폐기되므로, <code>upperdir</code>의 일관성은 깨지지 않는다. 따라서 <code>workdir</code>는 단순한 임시 폴더가 아니라, 파일 시스템의 트랜잭션적 특성을 보장하여 신뢰성을 높이는 필수적인 안전장치로 기능한다.5</p>
<h3>2.3  핵심 동작 메이커니즘: Copy-on-Write (CoW)</h3>
<p>OverlayFS의 효율성과 불변성의 핵심에는 Copy-on-Write(CoW)라는 메커니즘이 자리 잡고 있다. 이는 데이터에 대한 수정 요청이 발생했을 때, 원본을 직접 수정하는 대신 복사본을 만들어 그 복사본을 수정하는 방식을 의미한다.</p>
<h4>2.3.1  파일 I/O 연산 분석</h4>
<ul>
<li>
<p><strong>읽기(Read):</strong> 파일 읽기 작업 시에는 CoW가 발생하지 않는다.11 시스템은 먼저 변경 사항이 저장되는 <code>upperdir</code>에서 요청된 파일을 찾는다. 만약 파일이 <code>upperdir</code>에 존재하지 않으면, <code>lowerdir</code> 계층을 우선순위에 따라 순차적으로 탐색하여 파일을 찾아 읽는다. 이 과정은 하위 파일 시스템으로 I/O 요청을 직접 전달하는 방식에 가깝기 때문에, 네이티브 파일 시스템과 거의 유사한 성능을 보인다.3</p>
</li>
<li>
<p><strong>쓰기/수정(Write/Modify):</strong> 진정한 CoW 메커니즘은 쓰기 또는 수정 작업 시에 발현된다. 만약 <code>lowerdir</code>에만 존재하는 파일을 처음으로 수정하려고 시도하면, ’copy-up’이라는 연산이 트리거된다.12 이 과정에서 해당 파일 전체가</p>
</li>
</ul>
<p><code>lowerdir</code>에서 <code>upperdir</code>로 복사된다. 복사가 완료된 후, 사용자의 수정 작업은 <code>upperdir</code>에 생성된 이 복사본에 적용된다.11 이후 해당 파일에 대한 모든 추가적인 수정 작업은 더 이상</p>
<p><code>copy-up</code>을 유발하지 않고 <code>upperdir</code>의 파일에 직접 이루어진다. 이 메커니즘 덕분에 원본 <code>lowerdir</code>는 어떠한 변경도 겪지 않고 불변성을 유지할 수 있다.11</p>
<h4>2.3.2  파일 삭제 메커니즘</h4>
<p>OverlayFS는 <code>lowerdir</code>의 불변성을 유지해야 하므로, 파일을 물리적으로 삭제하는 대신 논리적으로 보이지 않게 만드는 특별한 방법을 사용한다.</p>
<ul>
<li><code>Whiteout</code> 파일: 사용자가 <code>merged</code> 뷰에서 <code>lowerdir</code>에 존재하는 파일을 삭제하면, OverlayFS는 <code>upperdir</code>에 해당 파일과 동일한 이름의 특수한 파일을 생성한다. 이 파일은 캐릭터 디바이스(character device) 형태이며, 주/부 번호(major/minor number)가 각각 0/0으로 설정되어 있다.14 이 특수 파일을 ‘whiteout’ 파일이라고 부른다.5</li>
</ul>
<p><code>merged</code> 뷰를 생성할 때, OverlayFS는 <code>upperdir</code>에서 whiteout 파일을 발견하면 <code>lowerdir</code>에 있는 동일한 이름의 원본 파일을 무시하고 사용자에게 보여주지 않는다. 즉, whiteout 파일은 하위 레이어의 파일을 가리는(masking) 역할을 하여 논리적인 삭제를 구현한다.11 실제 원본 파일은</p>
<p><code>lowerdir</code>에 그대로 남아있다.</p>
<ul>
<li><code>Opaque Directory</code> (불투명 디렉터리): 파일 단위의 마스킹 외에도, 디렉터리 단위로 병합을 차단하는 기능이 존재한다. <code>upperdir</code>의 특정 디렉터리에 <code>trusted.overlay.opaque</code>라는 확장 속성(extended attribute, xattr)을 ‘y’ 값으로 설정하면, 해당 디렉터리는 ‘불투명(opaque)’ 상태가 된다.14 이 경우, <code>merged</code> 뷰에서 해당 디렉터리를 조회할 때, <code>lowerdir</code>에 동일한 이름의 디렉터리가 존재하더라도 그 내용은 완전히 무시되고 <code>upperdir</code>의 내용만 보이게 된다.2 이는 특정 디렉터리의 내용을 하위 레이어와 무관하게 완전히 새로운 것으로 대체하고자 할 때 유용하게 사용된다.</li>
</ul>
<h2>3.  실제 활용 및 구현</h2>
<h3>3.1  마운트 명령어 및 옵션 상세 분석</h3>
<p>OverlayFS를 시스템에 적용하기 위해서는 <code>mount</code> 명령어를 통해 파일 시스템을 마운트해야 한다. 이때 다양한 옵션을 조합하여 특정 요구사항에 맞게 동작을 정밀하게 제어할 수 있다. 기본적인 마운트 명령어의 형식은 다음과 같다 3:</p>
<pre><code class="language-sh">$ mount -t overlay overlay -o [options] /merged
</code></pre>
<p>여기서 <code>-t overlay</code>는 파일 시스템 유형을 지정하고, <code>overlay</code>는 소스 디바이스가 없음을 의미하는 더미 이름이다. 핵심적인 설정은 <code>-o</code> 플래그 뒤에 오는 옵션들을 통해 이루어진다. 각 옵션의 기능과 그로 인한 시스템 동작의 변화를 명확히 이해하는 것은 성능 최적화와 안정성 확보에 필수적이다. 주요 마운트 옵션과 그 역할은 다음 표와 같다.</p>
<p><strong>Table 2.1: 주요 OverlayFS 마운트 옵션</strong></p>
<table><thead><tr><th>옵션 (Option)</th><th>설명</th><th>주요 사용 사례 및 영향</th></tr></thead><tbody>
<tr><td><code>lowerdir=[dir1]:[dir2]...</code></td><td>하나 이상의 읽기 전용 하위 레이어를 지정한다. 복수 지정 시 <code>:</code>로 구분하며, 오른쪽 디렉터리가 가장 낮은 계층이 된다.3</td><td>도커 이미지 레이어 구성, Live CD 베이스 시스템 등 계층적 구조가 필요한 경우에 사용된다. 레이어 순서가 병합 결과에 직접적인 영향을 미친다.</td></tr>
<tr><td><code>upperdir=[dir]</code></td><td>읽기-쓰기가 가능한 상위 레이어를 지정한다. <code>merged</code> 디렉터리에서 발생하는 모든 변경 사항이 이 디렉터리에 기록된다.3</td><td>컨테이너의 쓰기 가능 공간, 사용자 세션 동안의 변경사항 저장 등 동적인 데이터 처리에 필수적이다.</td></tr>
<tr><td><code>workdir=[dir]</code></td><td>원자적 파일 연산을 보장하기 위한 내부 작업 디렉터리. 반드시 <code>upperdir</code>와 동일한 파일 시스템에 위치한 빈 디렉터리여야 한다.3</td><td>파일 시스템의 무결성을 보장하는 핵심 요소로, 쓰기 가능한 OverlayFS 마운트 시 필수적으로 지정해야 한다.</td></tr>
<tr><td>`xino=[on</td><td>auto</td><td>off]`</td></tr>
<tr><td><code>volatile</code></td><td><code>upperdir</code>에 대한 모든 <code>sync</code> 시스템 콜을 생략하여 쓰기 성능을 가속화한다. 데이터 손실의 위험이 있다.17</td><td>데이터 영속성이 중요하지 않은 임시 빌드 컨테이너나 테스트 환경에서 I/O 성능을 극대화하기 위해 사용된다.</td></tr>
<tr><td>`redirect_dir=[on</td><td>off</td><td>follow]`</td></tr>
<tr><td>`index=[on</td><td>off]`</td><td>하드 링크가 있는 파일을 <code>copy_up</code>할 때, 링크 관계를 <code>upperdir</code>에서도 유지하도록 한다. 비활성화 시 링크가 깨진다.16</td></tr>
<tr><td>`metacopy=[on</td><td>off]`</td><td><code>chmod</code>, <code>chown</code> 등 메타데이터만 변경되는 경우, 파일 데이터 전체를 복사하지 않고 메타데이터만 <code>copy_up</code>하도록 한다.18</td></tr>
</tbody></table>
<h3>3.2  다중 <code>lowerdir</code>의 계층적 구조와 활용 사례</h3>
<p>OverlayFS의 가장 강력한 기능 중 하나는 <code>lowerdir</code> 옵션에 복수의 디렉터리를 지정하여 계층적인 읽기 전용 레이어 스택(stack)을 구성할 수 있다는 점이다.3 디렉터리들은 콜론(<code>:</code>)으로 구분되며, 마운트 옵션 문자열에서 왼쪽에 위치한 디렉터리가 더 높은 우선순위를 갖는다. 예를 들어, <code>lowerdir=/app:/os</code>로 지정하면 <code>/app</code> 레이어가 <code>/os</code> 레이어 위에 겹쳐지게 된다.14 만약 두 레이어에 동일한 경로의 파일이 존재한다면, 더 높은 우선순위를 가진 <code>/app</code> 레이어의 파일이 <code>merged</code> 뷰에 나타난다.5</p>
<p>이러한 계층적 구조는 현대적인 소프트웨어 배포 모델에서 매우 유용하게 활용된다. 대표적인 시나리오는 다음과 같다 21:</p>
<ol>
<li><strong>가장 낮은 레이어 (<code>lower2</code>):</strong> 최소한의 운영 체제 파일들을 포함하는 베이스 OS 이미지를 배치한다. (예: <code>ubuntu:22.04</code> 이미지)</li>
<li><strong>중간 레이어 (<code>lower1</code>):</strong> 베이스 OS 위에 특정 애플리케이션을 실행하는 데 필요한 런타임과 라이브러리를 포함하는 이미지를 배치한다. (예: <code>python:3.10</code> 이미지)</li>
<li><strong>최상위 레이어 (<code>upperdir</code>):</strong> 사용자의 애플리케이션 코드나 설정 파일 변경사항, 실행 중 생성되는 로그 파일 등을 저장한다.</li>
</ol>
<p>이 구조를 통해 OS, 런타임, 애플리케이션 코드를 논리적으로 분리하고 독립적으로 관리할 수 있다. 여러 애플리케이션이 동일한 OS와 런타임 레이어를 공유함으로써 스토리지 공간을 획기적으로 절약할 수 있으며, 업데이트 시에는 해당 레이어만 교체하면 되므로 배포 및 관리가 매우 효율적이다.23 이는 도커 이미지 레이어링이 동작하는 핵심 원리이기도 하다.</p>
<h3>3.3  컨테이너 기술의 심장: 도커(Docker) 스토리지 드라이버로서의 OverlayFS</h3>
<p>OverlayFS는 오늘날 컨테이너 생태계의 ’속도’와 ’밀도’를 결정하는 핵심 기반 기술이라고 해도 과언이 아니다. 만약 OverlayFS와 같은 유니온 파일 시스템이 없었다면, 컨테이너를 시작할 때마다 수 기가바이트에 달하는 전체 OS와 애플리케이션 파일을 매번 복사해야 했을 것이다. 이는 막대한 시간과 디스크 공간을 소모하여 컨테이너의 핵심 가치인 민첩성과 효율성을 심각하게 저해했을 것이다. OverlayFS의 CoW 및 레이어 공유 메커니즘은 이러한 비효율적인 복사 과정을 제거함으로써 현대적인 컨테이너 기술을 가능하게 했다. 컨테이너 시작은 단순히 새로운 <code>upperdir</code>를 생성하고 기존 <code>lowerdir</code> 스택 위에 마운트하는 과정으로 축소되어 거의 즉각적으로 이루어진다. 또한, 1GB의 베이스 이미지를 사용하는 100개의 컨테이너는 1GB(베이스 이미지)에 각 컨테이너의 미미한 변경분(<code>$</code>α<code>$</code>)을 더한 공간만을 차지하므로, 스토리지 비용을 획기적으로 절감하고 단일 호스트에 더 많은 컨테이너를 배포할 수 있게 한다. 이처럼 OverlayFS의 아키텍처는 컨테이너의 민첩성과 효율성이라는 비즈니스 가치를 기술적으로 직접 구현한 것이며, 이것이 없었다면 오늘날의 컨테이너 생태계는 존재하기 어려웠을 것이다.11</p>
<h4>3.3.1  도커 이미지 레이어와 OverlayFS 계층의 매핑</h4>
<p>도커 이미지는 <code>Dockerfile</code>에 정의된 명령어들을 기반으로 생성되는 여러 개의 읽기 전용 레이어의 집합이다.24</p>
<p><code>Dockerfile</code>의 <code>RUN</code>, <code>COPY</code>, <code>ADD</code>와 같은 각 명령어는 이전 레이어를 기반으로 파일 시스템에 변경을 가하고, 그 결과를 새로운 레이어로 저장한다.6 이 과정이 반복되면서 이미지의 계층 구조가 만들어진다.</p>
<p><code>docker pull</code> 명령어를 통해 이미지를 다운로드하면, 이 레이어들은 도커 호스트의 <code>/var/lib/docker/overlay2/</code> 디렉터리 아래에 각각 독립적인 디렉터리로 저장된다.24 도커의 <code>overlay2</code> 스토리지 드라이버는 이 이미지 레이어 디렉터리들을 OverlayFS의 <code>lowerdir</code> 스택으로 직접 매핑한다. 즉, 도커 이미지의 각 레이어는 OverlayFS의 읽기 전용 <code>lowerdir</code> 하나에 해당한다.24</p>
<h4>3.3.2  컨테이너 생성 및 실행 시 파일 시스템 구성 원리</h4>
<p><code>docker run</code> 명령어를 통해 컨테이너를 실행할 때, 도커 엔진은 다음과 같은 과정을 통해 컨테이너의 파일 시스템을 구성한다:</p>
<ol>
<li>선택된 이미지에 속한 모든 레이어 디렉터리들을 식별하여 OverlayFS의 <code>lowerdir</code> 스택으로 지정한다.</li>
<li>해당 컨테이너만을 위한 고유한 디렉터리들을 새로 생성하여, 하나는 <code>upperdir</code>로, 다른 하나는 <code>workdir</code>로 지정한다. 이 <code>upperdir</code>가 바로 컨테이너의 쓰기 가능한 레이어(container layer)가 된다.6</li>
<li>이 세 가지 디렉터리(<code>lowerdir</code> 스택, <code>upperdir</code>, <code>workdir</code>)를 사용하여 OverlayFS를 마운트하고, 그 결과를 컨테이너의 루트 파일 시스템(<code>merged</code> 뷰)으로 제공한다.</li>
</ol>
<p>이러한 방식을 통해, 수백 개의 컨테이너가 동일한 베이스 이미지(공유된 <code>lowerdir</code> 스택)를 메모리와 디스크에서 공유하면서도, 각 컨테이너 내부에서 발생하는 모든 파일 시스템 변경(파일 생성, 수정, 삭제)은 격리된 고유의 <code>upperdir</code>에만 기록된다. 이는 스토리지 효율성을 극대화하는 동시에 컨테이너 간의 완벽한 격리성을 보장하는 매우 효율적인 구조다.11</p>
<h2>4.  성능 특성 및 최적화</h2>
<p>OverlayFS는 그 구조적 특성으로 인해 독특한 성능 프로파일을 보인다. 읽기 작업은 거의 네이티브에 가까운 성능을 보이지만, 쓰기 작업, 특히 첫 쓰기 시에는 상당한 오버헤드가 발생할 수 있다. 반면, 메모리 관리 측면에서는 페이지 캐시 공유라는 강력한 이점을 제공한다.</p>
<h3>4.1  성능 오버헤드 분석: <code>copy_up</code> 연산의 영향</h3>
<ul>
<li><strong>읽기 성능:</strong> <code>merged</code> 뷰를 통해 <code>lowerdir</code>에만 존재하는 파일을 읽을 때, 파일이 열린 후의 모든 I/O 작업은 VFS(Virtual File System) 계층을 거쳐 하위 파일 시스템으로 직접 전달된다.3 이 과정에서 약간의 메타데이터 조회 오버헤드가 발생할 수는 있지만, 실제 데이터 전송 성능은 하위 파일 시스템의 네이티브 성능에 매우 가깝다.</li>
<li><strong>쓰기 성능:</strong> OverlayFS의 성능 병목 현상은 주로 첫 쓰기 작업 시 발생하는 <code>copy_up</code> 연산에서 비롯된다. <code>lowerdir</code>에 있는 파일을 처음으로 수정하려고 할 때, OverlayFS는 해당 파일 전체를 <code>upperdir</code>로 복사해야 한다.12 이 복사 작업은 파일의 크기에 비례하는 지연 시간(latency)을 유발하며, 특히 수 기가바이트에 달하는 대용량 파일의 경우 이 오버헤드는 매우 두드러질 수 있다.25 일단 <code>copy_up</code>이 완료된 후의 후속 쓰기 작업은 <code>upperdir</code>에서 직접 이루어지므로 빠르지만, 최초의 지연은 피할 수 없다.</li>
<li><strong>메타데이터 연산:</strong> <code>find.</code> 또는 <code>ls -lR</code>과 같이 디렉터리 트리를 순회하며 많은 파일의 메타데이터를 조회하는 작업은 OverlayFS에서 성능 저하를 보일 수 있다. 이는 <code>merged</code> 뷰를 구성하기 위해 <code>upperdir</code>와 모든 <code>lowerdir</code> 계층을 순차적으로 탐색하고 그 결과를 병합해야 하기 때문이다.12 각 파일에 대한 조회는 잠재적으로 여러 하위 디렉터리에 대한 조회를 유발하므로, 네이티브 파일 시스템에 비해 더 많은 I/O 및 CPU 자원을 소모하게 된다.</li>
</ul>
<h3>4.2  페이지 캐시 공유(Page Cache Sharing): 고밀도 환경의 핵심 이점</h3>
<p>OverlayFS의 가장 중요한 성능 이점 중 하나는 페이지 캐시 공유 기능이다. 이는 특히 동일한 베이스 이미지를 기반으로 수많은 컨테이너가 동시에 실행되는 고밀도 환경에서 시스템 전체의 메모리 효율성을 극대화한다.25 예를 들어, 100개의 우분투 컨테이너가 동일한 호스트에서 실행될 때, 모든 컨테이너는 공통적으로 <code>/lib/x86_64-linux-gnu/libc.so.6</code>와 같은 핵심 공유 라이브러리를 사용한다. OverlayFS 환경에서는 이 <code>libc.so.6</code> 파일의 데이터가 물리적 메모리(RAM)의 페이지 캐시에 단 한 번만 로드된다.26 이후 100개의 모든 컨테이너 프로세스는 이 공유된 단일 페이지 캐시 엔트리를 참조하여 파일을 읽게 되므로, 메모리 사용량이 획기적으로 감소한다.28</p>
<p>이러한 효율성은 OverlayFS가 파일 시스템 수준에서 동작하기에 가능하다. 반면, Device Mapper와 같은 블록 기반 스토리지 드라이버는 각 컨테이너에 고유한 가상 블록 디바이스를 할당한다. 커널의 VFS 계층 관점에서 보면, 각 컨테이너의 <code>libc.so.6</code> 파일은 서로 다른 디바이스에 존재하는 별개의 inode를 가진 완전히 다른 파일로 인식된다. 따라서 커널은 이들을 동일한 파일로 간주하지 않고, 각 컨테이너를 위해 별도의 페이지 캐시를 생성하게 된다. 결과적으로 100개의 컨테이너는 100개의 <code>libc.so.6</code> 복사본을 메모리에 올리게 되어 심각한 메모리 낭비를 초래한다.26 이처럼 OverlayFS의 페이지 캐시 공유 능력은 ‘읽기 전용’ <code>lowerdir</code> 설계에서 파생된 직접적인 결과이며, 메모리 효율성 측면에서 블록 기반 스토리지 드라이버에 비해 압도적인 우위를 점하게 하는 근본적인 차별점이다. 이는 고밀도 PaaS(Platform as a Service) 환경 구축에 OverlayFS가 더 적합한 이유를 설명해준다.</p>
<h3>4.3  성능 튜닝 전략</h3>
<p>OverlayFS의 성능을 최적화하기 위해서는 백엔드 파일 시스템 선택, 커널 버전, 그리고 마운트 옵션이라는 세 가지 요소를 종합적으로 고려해야 한다.</p>
<ul>
<li><strong>백엔드 파일 시스템 선택:</strong> Docker를 비롯한 다수의 컨테이너 플랫폼은 <code>overlay2</code> 드라이버의 백엔드 파일 시스템으로 XFS를 권장한다. 단, XFS 파일 시스템 생성 시 <code>ftype=1</code> 옵션(<code>mkfs.xfs -n ftype=1</code>)을 반드시 활성화해야 한다.4 이 옵션은 디렉터리 엔트리(dentry)에 파일 유형 정보(일반 파일, 디렉터리, 심볼릭 링크 등)를 포함시키는 <code>d_type</code> 지원을 활성화한다. OverlayFS는 이 정보를 활용하여 불필요한 <code>stat</code> 시스템 콜을 생략할 수 있어, 특히 메타데이터 집약적인 작업의 성능을 향상시킨다. XFS는 대용량 파일 처리와 병렬 I/O에 강점을 보여 일반적으로 선호되지만 30, 작은 파일이 매우 많은 특정 워크로드에서는 Ext4가 더 나은 성능을 보일 수도 있다는 보고도 있다.31 따라서 실제 운영 환경의 워크로드 특성을 기반으로 벤치마킹하여 최적의 파일 시스템을 선택하는 것이 바람직하다.</li>
<li><strong>커널 버전의 중요성:</strong> OverlayFS는 리눅스 커널의 일부이므로, 커널의 발전과 함께 지속적으로 개선된다. 최신 리눅스 커널을 사용하는 것은 성능 향상과 새로운 기능 활용을 위해 매우 중요하다. 예를 들어, Linux 5.10 커널에서는 <code>volatile</code> 마운트 옵션이 도입되어 특정 상황에서 쓰기 성능을 극대화할 수 있게 되었고 17, Linux 5.15에서는 RCU(Read-Copy-Update) 기반의 조회를 활성화하여 ACL(Access Control List) 조회와 관련된 성능 병목을 해결했다.33 따라서 안정성이 검증된 최신 LTS(Long-Term Support) 커널을 사용하는 것이 OverlayFS의 잠재력을 최대한 활용하는 길이다.</li>
<li><strong>마운트 옵션 활용:</strong></li>
<li><code>volatile</code>: 데이터의 영속성보다 극단적인 성능이 요구되는 시나리오(예: CI/CD 파이프라인의 임시 빌드 컨테이너)에서 이 옵션을 사용하면, <code>upperdir</code>에 대한 모든 <code>fsync</code> 호출을 생략하여 쓰기 I/O를 크게 줄이고 성능을 향상시킬 수 있다.17 단, 시스템 비정상 종료 시 데이터가 유실될 수 있음을 명확히 인지해야 한다.</li>
<li><code>xino</code>: 여러 물리적 디바이스에 걸쳐 <code>lowerdir</code>와 <code>upperdir</code>가 분산되어 있는 복잡한 환경에서 <code>xino=on</code> 또는 <code>xino=auto</code> 옵션을 사용하면, OverlayFS가 파일 시스템 ID와 inode 번호를 조합하여 고유하고 지속적인 inode 번호를 생성해준다.16 이는 NFS를 통해 OverlayFS 볼륨을 익스포트하거나, 파일 시스템 무결성을 검사하는 도구를 사용할 때 발생할 수 있는 호환성 문제를 해결하는 데 도움이 된다.15</li>
</ul>
<h2>5.  한계점, 호환성 및 보안</h2>
<p>OverlayFS는 강력하고 효율적인 파일 시스템이지만, 모든 기술과 마찬가지로 특정 한계점과 잠재적인 보안 위험을 내포하고 있다. 특히 POSIX 표준과의 완전한 호환성을 제공하지 않는다는 점은 특정 애플리케이션에서 예기치 않은 동작을 유발할 수 있다.</p>
<h3>5.1  POSIX 표준 비호환성 문제</h3>
<p>OverlayFS는 성능과 단순성을 위해 POSIX 파일 시스템 표준의 일부를 의도적으로 다르게 구현하거나 지원하지 않는다. 이는 대부분의 애플리케이션에서는 문제가 되지 않지만, 파일 디스크립터나 파일 시스템의 저수준 동작에 의존하는 일부 소프트웨어에서는 호환성 문제를 일으킬 수 있다.</p>
<h4>5.1.1  <code>open(2)</code> 시스템 콜의 비일관성</h4>
<p>가장 잘 알려진 비호환성 문제 중 하나는 <code>open(2)</code> 시스템 콜의 동작과 관련이 있다. POSIX 표준에 따르면, 동일한 파일을 여러 번 열었을 때 반환되는 파일 디스크립터들은 동일한 기본 파일 객체를 참조해야 한다. 그러나 OverlayFS에서는 이 가정이 깨질 수 있다.25</p>
<p>시나리오는 다음과 같다:</p>
<ol>
<li>애플리케이션이 <code>lowerdir</code>에만 존재하는 파일 <code>foo</code>를 읽기 전용(<code>O_RDONLY</code>)으로 연다. 이 호출은 성공하고 파일 디스크립터 <code>fd1</code>을 반환한다. <code>fd1</code>은 <code>lowerdir</code>에 있는 원본 파일의 inode를 가리킨다.</li>
<li>잠시 후, 동일한 애플리케이션이 같은 파일 <code>foo</code>를 읽기-쓰기(<code>O_RDWR</code>) 모드로 다시 연다.</li>
<li>이 두 번째 <code>open</code> 호출 시, OverlayFS는 쓰기 권한이 요청되었으므로 <code>copy_up</code> 연산을 트리거한다. 파일 <code>foo</code>는 <code>upperdir</code>로 복사된다.</li>
<li>두 번째 호출은 <code>upperdir</code>에 새로 생성된 파일의 inode를 가리키는 파일 디스크립터 <code>fd2</code>를 반환한다.</li>
</ol>
<p>결과적으로, <code>fd1</code>과 <code>fd2</code>는 이름은 같지만 서로 다른 inode를 가진 별개의 파일을 참조하게 되는 비정상적인 상태가 된다.29 이는 파일 잠금이나 데이터 일관성에 의존하는 정교한 애플리케이션에서 예측 불가능한 버그를 유발할 수 있다. 이 문제를 해결하기 위한 일반적인 해결 방안은, <code>yum-plugin-ovl</code> 패키지가 사용하는 방식처럼, 파일을 본격적으로 사용하기 전에 <code>touch</code>와 같은 명령어로 파일에 먼저 쓰기 작업을 가하여 <code>copy_up</code>을 강제로 미리 수행시키는 것이다.25</p>
<h4>5.1.2  <code>rename(2)</code> 시스템 콜의 <code>EXDEV</code> 오류</h4>
<p><code>rename(2)</code> 시스템 콜 역시 OverlayFS에서 제한적으로 지원된다. <code>lowerdir</code>에만 존재하는 디렉터리나 파일을 <code>rename</code>하려고 시도하면, OverlayFS는 이를 다른 파일 시스템 간의 이동으로 간주하여 <code>EXDEV</code> (“Invalid cross-device link”) 오류를 반환하는 것이 기본 동작이다.15 이는 <code>rename</code>의 원자성을 보장하기 위한 방어적인 설계이지만, POSIX 표준을 기대하는 애플리케이션을 중단시킬 수 있다.25</p>
<p>이에 대한 대응 전략으로, 애플리케이션 개발자는 <code>rename</code> 호출이 <code>EXDEV</code> 오류로 실패할 경우를 대비하여, 파일을 새 위치에 수동으로 복사한 후 원본을 삭제하는 “copy and unlink” 방식의 대체 로직을 구현해야 한다.25 시스템 관리자 수준에서는 커널 설정(<code>CONFIG_OVERLAY_FS_REDIRECT_DIR=y</code>)이나 마운트 옵션(<code>redirect_dir=on</code>)을 사용하여 커널이 하위 레이어 디렉터리의 이름 변경을 제한적으로 처리하도록 할 수 있다. 이 옵션은 <code>upperdir</code>에 리디렉션을 나타내는 특별한 메타데이터를 기록하는 방식으로 동작한다.15</p>
<h3>5.2  커널 수준의 기술적 이슈</h3>
<ul>
<li><strong>파일 잠금(File Locking) 및 <code>fanotify</code>:</strong> <code>copy_up</code> 연산은 파일의 inode를 근본적으로 변경시키기 때문에, 파일 잠금(예: <code>fcntl</code>)이나 파일 시스템 이벤트 알림(<code>fanotify</code>)과 같은 inode 기반 메커니즘에서 의미론적 모호성을 야기한다. 예를 들어, <code>lowerdir</code>의 inode에 파일 잠금이 설정된 상태에서 해당 파일이 <code>copy_up</code> 되면, 그 잠금이 <code>upperdir</code>에 생성된 새로운 inode로 자동으로 전이되어야 하는가에 대한 명확한 답을 내리기 어렵다.26</li>
</ul>
<p><code>fanotify</code> 역시 마찬가지로, <code>lowerdir</code> inode에 설정된 감시가 <code>copy_up</code> 이후의 변경 사항을 감지하지 못할 수 있다. 이러한 복잡성 때문에 초기 커널 버전에서는 관련 기능이 제한적으로 동작하거나, 잠금 시도 시 <code>ENOLCK</code> 오류를 반환하는 등의 방어적인 접근이 이루어지기도 했다.</p>
<h3>5.3  주요 보안 취약점 심층 분석: CVE-2023-0386</h3>
<p>CVE-2023-0386은 OverlayFS가 리눅스의 다른 핵심 기능인 사용자 네임스페이스(User Namespace)와 상호작용하는 과정의 허점을 파고드는 대표적인 권한 상승 취약점이다.</p>
<ul>
<li><strong>취약점의 근원:</strong> 이 취약점의 핵심은 OverlayFS의 <code>copy_up</code> 로직이 파일의 소유자 정보(UID/GID)를 처리할 때, 해당 UID/GID가 현재 컨텍스트의 사용자 네임스페이스 내에 유효하게 매핑되어 있는지를 검증하지 않는다는 데에 있다.18 사용자 네임스페이스는 컨테이너와 같은 격리된 환경에서 프로세스가 호스트와 다른 사용자 및 그룹 ID를 갖도록 해주는 기능인데, 이 경계에서의 검증 누락이 공격의 빌미를 제공했다.</li>
<li><strong>공격 시나리오:</strong> 공격은 다음과 같은 단계로 진행된다 18:</li>
</ul>
<ol>
<li><strong>네임스페이스 생성:</strong> 공격자는 <code>unshare</code> 시스템 콜을 사용하여 권한 없는 사용자로서 새로운 사용자 네임스페이스를 생성한다. 이 네임스페이스 안에서 공격자는 가상의 <code>root</code> 권한(UID 0)을 갖게 된다.</li>
<li><strong>악성 <code>lowerdir</code> 준비:</strong> 생성된 네임스페이스 내부에서, 공격자는 FUSE(Filesystem in Userspace) 등을 이용해 가상 파일 시스템을 마운트하고, 그 안에 SUID(Set-User-ID) 비트가 설정된 실행 파일을 생성한다. 이 파일의 소유자는 네임스페이스 내부에서는 <code>root</code> (UID 0)이지만, 호스트 시스템 관점에서는 공격자의 원래 UID에 매핑된다.</li>
<li><strong>OverlayFS 마운트 및 <code>copy_up</code> 트리거:</strong> 공격자는 이 가상 파일 시스템을 <code>lowerdir</code>로, 일반 디렉터리를 <code>upperdir</code>로 하여 OverlayFS를 마운트한다. 이후 <code>chmod</code>와 같은 메타데이터 변경 명령을 통해 SUID 파일에 대한 <code>copy_up</code> 연산을 의도적으로 유발한다.</li>
<li><strong>취약점 악용:</strong> 취약한 커널의 OverlayFS 구현체는 <code>copy_up</code>을 수행하면서 파일의 메타데이터(소유권 및 SUID 비트 포함)를 <code>upperdir</code>로 복사한다. 이때, 파일의 소유자 UID가 현재 사용자 네임스페이스의 매핑 범위를 벗어나는지 확인하는 검증 절차가 누락되어, SUID 비트가 그대로 보존된 채 파일이 복사된다.</li>
<li><strong>권한 상승:</strong> 공격자는 네임스페이스를 빠져나와 호스트 시스템으로 돌아온다. 이제 <code>upperdir</code>에는 호스트 시스템의 실제 <code>root</code>가 소유하고 SUID 비트가 설정된 실행 파일이 생성되어 있다. 공격자가 이 파일을 실행하면, 프로세스는 <code>root</code> 권한으로 실행되어 시스템 전체에 대한 통제권을 장악하게 된다.</li>
</ol>
<p>이 취약점은 컨테이너 보안이 단순히 컨테이너 이미지나 네트워크 정책을 관리하는 것을 넘어, 컨테이너 런타임과 호스트 커널 간의 복잡한 상호작용에 대한 깊은 이해를 요구함을 명확히 보여준다. 컨테이너가 제공하는 격리는 커널이라는 공유 자원 위에 구축되므로, 커널 자체의 취약점, 특히 OverlayFS, 네임스페이스, cgroup과 같은 컨테이너 핵심 기술과 관련된 취약점은 격리 경계를 무너뜨리는 치명적인 공격 벡터가 될 수 있다. 따라서 진정한 컨테이너 보안(Defense-in-Depth)을 위해서는 Seccomp, AppArmor/SELinux와 같은 커널 보안 모듈을 통해 컨테이너의 시스템 콜 접근을 최소화하고, 비인가된 네임스페이스 생성을 제한하며, 무엇보다 호스트 커널을 항상 최신 상태로 유지하는 등 다층적인 방어 전략이 필수적이다. 이는 제로 트러스트(Zero Trust) 원칙을 커널과 유저스페이스의 상호작용에 적용하는 것과 같은 맥락이다.38</p>
<h3>5.4  보안 강화 방안 및 시스템 운영 모범 사례</h3>
<p>OverlayFS를 안전하게 사용하기 위해서는 다음과 같은 모범 사례를 준수해야 한다.</p>
<ul>
<li><strong>지속적인 커널 업데이트:</strong> CVE-2023-0386과 같은 알려진 취약점은 커널 업데이트를 통해 패치된다. 따라서 시스템의 리눅스 커널을 항상 안정적인 최신 버전으로 유지하는 것이 가장 기본적인 보안 조치이다.</li>
<li><strong>네임스페이스 사용 제한:</strong> 신뢰할 수 없는 사용자가 임의로 사용자 네임스페이스를 생성하는 것을 방지하기 위해, 시스템 전역적으로 커널 파라미터 <code>kernel.unprivileged_userns_clone=0</code>을 설정하는 것을 고려할 수 있다. 또는 Seccomp 프로파일을 통해 컨테이너가 <code>unshare</code>나 <code>clone</code> 시스템 콜을 특정 플래그와 함께 호출하는 것을 차단할 수 있다.</li>
<li><strong>신뢰할 수 있는 이미지 사용:</strong> 컨테이너 환경에서는 공식적으로 검증된 베이스 이미지만을 사용하고, 출처가 불분명한 이미지를 <code>lowerdir</code>로 사용하는 것을 피해야 한다.</li>
<li><strong>보안 마운트 옵션 활용:</strong> 컨테이너 외부에서 OverlayFS를 직접 사용할 경우, <code>nosuid</code>, <code>nodev</code>와 같은 보안 관련 마운트 옵션을 적절히 활용하여 위험을 완화해야 한다.</li>
</ul>
<h2>6.  다른 유니온 파일 시스템과의 비교 분석</h2>
<p>OverlayFS는 유니온 파일 시스템의 역사 속에서 여러 경쟁 기술과의 상호작용을 통해 현재의 위치에 도달했다. 특히 Aufs와의 관계는 컨테이너 기술 초기의 기술 표준 경쟁을 상징적으로 보여준다.</p>
<h3>6.1  Aufs vs. OverlayFS: 숙명의 라이벌</h3>
<p>Aufs(Another Union File System)는 Docker 초창기에 기본 스토리지 드라이버로 사용되며 널리 알려졌다. 기술적으로 Aufs는 OverlayFS보다 일부 더 유연한 기능을 제공했지만, 결정적인 차이로 인해 결국 주류에서 밀려나게 되었다. 두 파일 시스템의 핵심적인 차이점은 다음 표와 같다.</p>
<p><strong>Table 5.2: 유니온 파일 시스템 비교 (OverlayFS vs. Aufs)</strong></p>
<table><thead><tr><th>특징 (Feature)</th><th>Aufs (Another Union File System)</th><th>OverlayFS (Overlay File System)</th></tr></thead><tbody>
<tr><td><strong>커널 메인라인 통합</strong></td><td><strong>미포함.</strong> 배포판별로 별도의 커널 패치가 필요하여 유지보수가 어렵고, 커널 업데이트에 대한 대응이 느리다.9</td><td><strong>포함 (Linux 3.18+).</strong> 리눅스 커널의 표준 기능으로, 모든 주요 배포판에서 안정적으로 지원된다.2</td></tr>
<tr><td><strong>구현 복잡성</strong></td><td>코드베이스가 상대적으로 크고 복잡하며, 기능이 풍부하다.9</td><td>구현이 더 작고 단순하여 커널과의 통합 및 유지보수가 용이하다.</td></tr>
<tr><td><strong>동적 레이어 수정</strong></td><td>이미 마운트된 파일 시스템에 동적으로 브랜치(레이어)를 추가하거나 제거하는 유연한 기능을 지원한다.39</td><td>기본적으로 지원하지 않는다. 레이어 구성은 마운트 시점에 고정되며, 변경을 위해서는 언마운트 후 재마운트해야 한다.</td></tr>
<tr><td><strong>성능</strong></td><td>많은 수의 레이어가 중첩될 경우 메타데이터 조회 성능이 저하될 수 있다.9</td><td><code>copy_up</code> 오버헤드는 존재하지만, 페이지 캐시 공유 효율이 뛰어나고 전반적인 성능이 우수하다.</td></tr>
<tr><td><strong>xattr 지원</strong></td><td>지원한다.42</td><td>지원한다.</td></tr>
<tr><td><strong>현재 상태</strong></td><td>대부분의 리눅스 배포판에서 지원이 중단되었으며, 사실상 사용되지 않는(deprecated) 기술로 간주된다.9</td><td>Docker의 공식 권장 스토리지 드라이버이며, 컨테이너 환경의 사실상의 표준(de facto standard)이다.</td></tr>
</tbody></table>
<p>Aufs가 제공하는 동적 레이어 수정 기능은 특정 사용 사례에서 매우 매력적이었지만, 그 복잡한 코드베이스는 리눅스 커널 메인라인에 병합되는 데 큰 걸림돌이 되었다.9 커널 개발 커뮤니티는 유지보수성과 안정성을 이유로 Aufs의 통합을 거부했다. 반면, OverlayFS는 더 단순하고 명료한 설계를 바탕으로 커널에 성공적으로 통합될 수 있었다. 장기적인 관점에서 볼 때, 커널과의 통합은 안정적인 업데이트, 넓은 호환성, 그리고 커뮤니티의 지속적인 지원을 의미한다. 결국 이러한 ’커널 메인라인’이라는 결정적 요인이 Docker를 포함한 전체 컨테이너 생태계가 Aufs를 버리고 OverlayFS를 표준으로 채택하게 만든 가장 큰 이유가 되었다.9 이는 기술 생태계에서 개별 기능의 우수성보다 표준화와 지속 가능성이 얼마나 중요한지를 보여주는 대표적인 사례다.</p>
<h3>6.2  초기 유니온 파일 시스템: UnionFS의 유산</h3>
<p>UnionFS는 리눅스에서 유니온 마운트 개념을 처음으로 구현한 선구자적인 파일 시스템이다.10 여러 디렉터리를 하나로 합쳐 보여준다는 혁신적인 아이디어를 제시했지만, 초기 구현은 성능과 안정성 측면에서 여러 문제점을 안고 있었다.9 이러한 한계를 극복하기 위해 Aufs가 개발되었고, 이후 커널 통합을 목표로 더 단순화된 접근법을 취한 OverlayFS가 등장하게 되었다. 즉, OverlayFS는 UnionFS의 핵심 아이디어를 계승하되, 리눅스 VFS와의 더 나은 통합과 실용적인 설계를 통해 안정성과 성능을 확보한 결과물이라고 볼 수 있다. UnionFS는 비록 현재는 거의 사용되지 않지만, 그 개념적 유산은 OverlayFS와 현대 컨테이너 기술 속에 깊이 남아있다.</p>
<h2>7.  미래 전망 및 결론</h2>
<h3>7.1  불변 인프라(Immutable Infrastructure) 패러다임의 핵심 구현 기술</h3>
<p>불변 인프라는 현대 클라우드 네이티브 운영의 핵심 패러다임 중 하나로, 운영 중인 프로덕션 서버를 직접 수정(패치, 설정 변경)하는 대신, 변경 사항이 적용된 새로운 서버 이미지를 생성하여 기존 인스턴스를 완전히 교체하는 방식을 의미한다.44 이 접근법은 ’구성 드리프트(configuration drift)’를 방지하고, 배포의 예측 가능성과 재현성을 높이며, 롤백을 단순화하는 등 수많은 이점을 제공한다.46</p>
<p>OverlayFS의 아키텍처는 이러한 불변 인프라의 철학과 완벽하게 부합한다. 변경이 불가능한 읽기 전용 <code>lowerdir</code>는 테스트와 검증이 완료된 ’골든 이미지(golden image)’에 해당하며, 읽기-쓰기가 가능한 <code>upperdir</code>는 각 인스턴스가 실행되면서 발생하는 고유한 변경 사항이나 상태(state)를 저장하는 공간에 해당한다.7 이 구조는 ’기반은 고정하고 차이점만 관리한다’는 불변 인프라의 핵심 원칙을 파일 시스템 수준에서 자연스럽게 구현한 것이다.</p>
<p>따라서 OverlayFS는 단순히 컨테이너 기술을 넘어, 클라우드 네이티브 운영 모델 전체를 지탱하는 기술적 초석으로 평가받아야 한다. 클라우드 네이티브의 핵심 원칙 중 하나는 개별 서버를 애완동물(Pets)처럼 관리하는 대신 가축(Cattle)처럼 취급하는 불변성이다. 이 원칙을 구현하기 위해서는 인프라를 코드(Infrastructure as Code, IaC)로 정의하고, 배포 단위를 이미지화해야 한다. OverlayFS는 바로 이 ’이미지’를 효율적으로 저장하고 실행하는 기술적 기반을 제공한다. 베이스 이미지를 <code>lowerdir</code>로, 실행 중 변경 사항을 <code>upperdir</code>로 분리함으로써 이미지의 불변성을 보장하고, CoW를 통해 새로운 인스턴스를 빠르고 효율적으로 생성할 수 있게 한다. 이러한 특성 덕분에 OverlayFS는 Docker 컨테이너뿐만 아니라, 가상머신 이미지 관리, IoT 기기의 안전한 펌웨어 업데이트, 서버리스 컴퓨팅 환경의 실행 레이어 구성 등 불변성을 요구하는 모든 현대적 배포 모델에서 핵심적인 역할을 수행할 잠재력을 지니고 있다.</p>
<h3>7.2  OverlayFS의 발전 방향과 리눅스 커널의 동향</h3>
<p>리눅스 커널 개발 커뮤니티는 OverlayFS의 기능과 성능을 지속적으로 개선하고 있다. 최근 커널 릴리스에서는 다음과 같은 발전이 이루어졌다:</p>
<ul>
<li><strong>성능 개선:</strong> RCU 기반 조회 도입, <code>volatile</code> 마운트 옵션 추가 등을 통해 특정 워크로드에서의 성능을 꾸준히 향상시키고 있다.17</li>
<li><strong>호환성 및 기능 확장:</strong> 대소문자를 구분하지 않는(case-insensitive) 파일 시스템과의 호환성 작업 47, 비특권 사용자도 OverlayFS를 마운트할 수 있도록 하는 기능 추가 48 등 사용성과 호환성을 높이기 위한 노력이 계속되고 있다.</li>
<li><strong>메타데이터 처리 개선:</strong> 메타데이터 전용 <code>copy_up</code>(<code>metacopy</code>) 기능 도입으로 불필요한 데이터 복사를 줄이는 등 효율성을 높이고 있다.19</li>
</ul>
<p>향후에는 현재 지원되지 않는 하위 레이어의 변경 사항을 상위 레이어에 병합하는 ‘merge-down’ 기능이나, 파일 시스템 수준의 데이터 중복 제거(deduplication)와의 통합 등 더 진보된 기능에 대한 논의가 이루어질 가능성이 있다.</p>
<h3>7.3  종합적 고찰 및 제언</h3>
<p>OverlayFS는 단순성, 우수한 성능, 그리고 리눅스 커널 메인라인 통합이라는 강력한 이점을 바탕으로 현대 리눅스 환경에서 가장 중요한 유니온 파일 시스템으로 확고히 자리 잡았다. 특히 컨테이너화된 환경에서 스토리지 효율성, 빠른 배포 속도, 그리고 강력한 격리성을 제공하는 핵심 기술로서 그 가치가 입증되었다. 또한, 불변 인프라라는 현대적 IT 운영 패러다임을 구현하는 데 있어 가장 이상적인 파일 시스템 수준의 해결책을 제시한다.</p>
<p>그러나 OverlayFS를 효과적으로 활용하기 위해서는 그 한계를 명확히 인지하고 전략적으로 접근해야 한다. 시스템 아키텍트와 엔지니어는 다음 사항을 반드시 고려해야 한다:</p>
<ol>
<li><strong>성능 특성 이해:</strong> <code>copy_up</code>으로 인한 첫 쓰기 작업의 오버헤드를 인지하고, 쓰기 집약적인 워크로드에 대해서는 성능 테스트를 통해 영향을 평가해야 한다.</li>
<li><strong>호환성 문제 대비:</strong> <code>open(2)</code> 및 <code>rename(2)</code> 시스템 콜의 비표준 동작이 애플리케이션에 미칠 수 있는 영향을 파악하고, 필요시 애플리케이션 수정이나 우회 방안을 마련해야 한다.</li>
<li><strong>보안에 대한 지속적인 경계:</strong> OverlayFS와 다른 커널 기능(특히 사용자 네임스페이스)의 상호작용에서 발생하는 보안 취약점에 유의해야 한다. 시스템 커널을 항상 최신 상태로 유지하고, 최소 권한 원칙에 따라 컨테이너의 권한을 제한하는 등 다층적인 보안 전략을 수립하는 것이 필수적이다.</li>
<li><strong>전략적 도구로서의 인식:</strong> OverlayFS를 단순히 파일 시스템으로만 볼 것이 아니라, 컨테이너화, CI/CD, 불변 인프라와 같은 현대적인 아키텍처를 구현하고 가속화하는 핵심적인 전략적 도구로 인식하고 시스템 설계에 적극적으로 반영해야 한다.</li>
</ol>
<p>결론적으로, OverlayFS는 현대 컴퓨팅 환경의 복잡성과 요구사항을 해결하는 데 있어 필수불가결한 기술이다. 그 구조와 동작 원리, 그리고 잠재적 위험에 대한 깊이 있는 이해를 바탕으로 신중하게 적용할 때, 시스템의 효율성, 안정성, 그리고 보안을 한 차원 높은 수준으로 끌어올릴 수 있을 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>21장. 파일 시스템 | 7.2 릴리스 노트 | Red Hat Enterprise Linux | 7, https://docs.redhat.com/ko/documentation/red_hat_enterprise_linux/7/html/7.2_release_notes/technology-preview-file_systems</li>
<li>OverlayFS - Wikipedia, https://en.wikipedia.org/wiki/OverlayFS</li>
<li>Overlay filesystem - ArchWiki, https://wiki.archlinux.org/title/Overlay_filesystem</li>
<li>Chapter 21. File Systems | 7.2 Release Notes | Red Hat Enterprise Linux | 7, https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/7.2_release_notes/technology-preview-file_systems</li>
<li>[Linux] Overlayfs 개념 및 사용 방법 - Jun_ : Pwn - 티스토리, https://she11.tistory.com/241</li>
<li>Docker’s Internal - 티스토리, https://zbvs.tistory.com/14</li>
<li>Desacralizing the Linux overlay filesystem in Docker - Adaltas, https://www.adaltas.com/en/2021/06/03/linux-overlay-filesystem-docker/</li>
<li>Immutable infrastructure, containers &amp; the future of microservices [Adam Miller] - YouTube, https://www.youtube.com/watch?v=Qvr_RxaAz78</li>
<li>What is AUFS (Another Union File System)? - Artoon Solutions, https://artoonsolutions.com/glossary/aufs/</li>
<li>UnionFS - Wikipedia, https://en.wikipedia.org/wiki/UnionFS</li>
<li>컨테이너 이미지 내 overlayFS에서 Copy-on-Write가 구체적으로 …, https://potato-pg-journey.tistory.com/43</li>
<li>Demystifying Overlay File Systems - InfluentCoder, https://influentcoder.com/posts/overlayfs/</li>
<li>Prevention of a DoS Attack with Copy-on-write in the Overlay Filesystem - KSL, https://www.ksl.ci.kyutech.ac.jp/papers/2021/satou-dasc2021.pdf</li>
<li>Documentation/filesystems/overlayfs.txt - kernel/hikey-linaro - Git at Google, https://android.googlesource.com/kernel/hikey-linaro/+/master/Documentation/filesystems/overlayfs.txt</li>
<li>overlayfs.txt - The Linux Kernel Archives, https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt</li>
<li>Overlay Filesystem - The Linux Kernel documentation, https://docs.kernel.org/filesystems/overlayfs.html</li>
<li>OverlayFS Adds A “Volatile” Option - Faster Performance But All Syncs Are Omitted, https://www.phoronix.com/news/OverlayFS-Linux-5.10</li>
<li>[1-day] CVE-2023-0386(OverlayFS) 분석 - Jun_ : Pwn - 티스토리, https://she11.tistory.com/242</li>
<li>UBIFS &amp; OverlayFS Updates Hit The Linux 4.19 Kernel - Phoronix, https://www.phoronix.com/news/Linux-4.19-UBIFS-OverlayFS</li>
<li>How to use multiple lower layers in overlayfs - Stack Overflow, https://stackoverflow.com/questions/31044982/how-to-use-multiple-lower-layers-in-overlayfs</li>
<li>How to Use OverlayFS? | Baeldung on Linux, https://www.baeldung.com/linux/overlayfs-usage</li>
<li>a practical look into overlayfs - ops.tips, https://ops.tips/notes/practical-look-into-overlayfs/</li>
<li>Understanding Container Images, Part 3: Working with Overlays - Cisco Blogs, https://blogs.cisco.com/developer/373-containerimages-03</li>
<li>만들면서 이해하는 도커(Docker) 이미지: 도커 이미지 빌드 원리와 …, https://www.44bits.io/ko/post/how-docker-image-work</li>
<li>Use the OverlayFS storage driver | Docker ドキュメント - GitHub Pages, https://matsuand.github.io/docs.docker.jp.onthefly/storage/storagedriver/overlayfs-driver/</li>
<li>Overlayfs issues and experiences [LWN.net], https://lwn.net/Articles/636943/</li>
<li>Would same file from various docker images be page-cached in k8s node just once?, https://stackoverflow.com/questions/59742644/would-same-file-from-various-docker-images-be-page-cached-in-k8s-node-just-once</li>
<li>Chapter 5. Optimizing persistent storage | Scaling and Performance Guide | OpenShift Container Platform | 3.10 | Red Hat Documentation, https://docs.redhat.com/en/documentation/openshift_container_platform/3.10/html/scaling_and_performance_guide/scaling-performance-optimizing-storage</li>
<li>OverlayFS storage driver | Docker Docs, https://docs.docker.com/engine/storage/drivers/overlayfs-driver/</li>
<li>XFS vs. Ext4: Which Linux File System Is Better? | Pure Storage Blog, https://blog.purestorage.com/purely-educational/xfs-vs-ext4-which-linux-file-system-is-better/</li>
<li>리눅스 파일 시스템 EXT4 vs XFS, 뭘 골라야 할까, 뭐가 더 좋지? : r/DataHoarder - Reddit, https://www.reddit.com/r/DataHoarder/comments/11ar65f/linux_filesystems_ext4_vs_xfs_what_to_choose_what/?tl=ko</li>
<li>Splunk Indexers - ext4 vs XFS filesystem performance, https://community.splunk.com/t5/Community-Blog/Splunk-Indexers-ext4-vs-XFS-filesystem-performance/ba-p/693424</li>
<li>OverlayFS On Linux 5.15 Improves Performance, Copies Up More Attributes - Phoronix, https://www.phoronix.com/news/Linux-5.15-OverlayFS</li>
<li>Use the OverlayFS storage driver - Docker Documentation, https://docker-docs.uclv.cu/storage/storagedriver/overlayfs-driver/</li>
<li>OverlayFS limitation - HackMD, https://hackmd.io/@TuI2ECfeSiii4sWQjNf9GA/SkV_pj-18</li>
<li>Comparing aufs vs overlay - Page 2 - Puppy Linux Discussion Forum, https://www.forum.puppylinux.com/viewtopic.php?t=1910&amp;start=30</li>
<li>CISA Warns of Active Exploitation of Linux Kernel Privilege …, https://thehackernews.com/2025/06/cisa-warns-of-active-exploitation-of.html</li>
<li>Zero Trust Overlays - DoD CIO, https://dodcio.defense.gov/Portals/0/Documents/Library/ZeroTrustOverlays.pdf</li>
<li>Comparing aufs vs overlay - Puppy Linux Discussion Forum, https://forum.puppylinux.com/viewtopic.php?t=1910</li>
<li>Which union filesystem is best supported? - Ask Ubuntu, https://askubuntu.com/questions/39850/which-union-filesystem-is-best-supported</li>
<li>how about overlayfs? / Issue #21 / Tomas-M/linux-live - GitHub, https://github.com/Tomas-M/linux-live/issues/21</li>
<li>AkihiroSuda/issues-docker: :whale: Docker Issues and Tips (aufs/overlay/btrfs..) - GitHub, https://github.com/AkihiroSuda/issues-docker</li>
<li>Hmm… how is Overlayfs and Unionfs different? From the explanation I can’t find… | Hacker News, https://news.ycombinator.com/item?id=21569168</li>
<li>Part 2: Immutable Infrastructure: Best Practices for Network Professionals - ZPE Systems, https://zpesystems.com/immutable-infrastructure-best-practices-zs/</li>
<li>REL08-BP04 Deploy using immutable infrastructure - Reliability Pillar - AWS Documentation, https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/rel_tracking_change_management_immutable_infrastructure.html</li>
<li>What is Mutable vs. Immutable Infrastructure? - HashiCorp, https://www.hashicorp.com/resources/what-is-mutable-vs-immutable-infrastructure</li>
<li>New Patch Series Allows OverlayFS To Work With Casefolding - Phoronix, https://www.phoronix.com/news/OverlayFS-Case-Insensitive</li>
<li>FUSE, OverlayFS, Ceph Ready With Improvements For Linux 5.11 - Phoronix, https://www.phoronix.com/news/Linux-5.11-FUSE-Ceph-OverlayFS</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>