<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:라즈베리 파이를 위한 실시간 리눅스 구현 및 최적화에 대한 고찰</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>라즈베리 파이를 위한 실시간 리눅스 구현 및 최적화에 대한 고찰</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">시스템 (Systems)</a> / <a href="index.html">라스베리파이</a> / <span>라즈베리 파이를 위한 실시간 리눅스 구현 및 최적화에 대한 고찰</span></nav>
                </div>
            </header>
            <article>
                <h1>라즈베리 파이를 위한 실시간 리눅스 구현 및 최적화에 대한 고찰</h1>
<h2>1. 범용 운영체제의 실시간화를 향한 도전</h2>
<p>과거 산업 제어, 로보틱스, 고속 데이터 수집 시스템은 고가의 전용 하드웨어와 실시간 운영체제(RTOS)에 의존하는 것이 일반적이었다. 그러나 라즈베리 파이와 같은 저비용 고성능 단일 보드 컴퓨터(SBC)의 등장은 임베디드 시스템 개발의 패러다임을 근본적으로 바꾸어 놓았다.1 이러한 SBC는 단순한 데이터 처리를 넘어 물리적 세계와 직접 상호작용하며, 정해진 시간 내에 예측 가능한 반응을 보장해야 하는 실시간(Real-Time) 요구사항을 동반하는 경우가 많다.3</p>
<p>라즈베리 파이는 본래 교육 및 취미용으로 개발되었으며, 기본적으로 탑재되는 라즈베리 파이 OS는 리눅스 커널에 기반한 범용 운영체제(GPOS)이다. GPOS의 설계 목표는 시스템의 평균 처리량(Throughput)을 극대화하는 데 초점이 맞춰져 있다. 이는 최악의 경우 응답 시간(Worst-Case Response Time) 보장을 최우선으로 하는 실시간 시스템의 목표와 본질적으로 상충된다.5 범용 리눅스 커널은 평균 성능을 위해 스케줄링, 인터럽트 처리, 메모리 관리 등에서 비결정적(Non-deterministic) 지연 요소를 내포하고 있기 때문이다.</p>
<p>본 안내서는 라즈베리 파이라는 범용 하드웨어 플랫폼에서, 범용 운영체제인 리눅스의 커널을 수정하고 시스템 전반을 최적화하여 신뢰성 있는 실시간 시스템을 구축하는 전 과정을 이론적, 실증적으로 고찰하는 것을 목적으로 한다. 이를 위해 실시간 시스템의 핵심 개념 정의부터 시작하여, 리눅스를 실시간 운영체제로 변환하는 핵심 기술인 PREEMPT_RT 커널의 아키텍처와 구현 방법, 하드웨어부터 애플리케이션에 이르는 다계층적 최적화 전략, 그리고 구축된 시스템의 성능을 객관적으로 검증하는 방법론을 심도 있게 다룬다. 최종적으로는 실제 산업 현장에서의 적용 사례를 통해 라즈베리 파이 기반 실시간 시스템의 가능성과 한계를 종합적으로 조망한다.</p>
<h2>2.  실시간 시스템의 이론적 토대</h2>
<p>실시간 시스템을 성공적으로 구현하기 위해서는 그 기반이 되는 핵심 개념들에 대한 명확한 이해가 선행되어야 한다. 이는 단순히 시스템을 ‘빠르게’ 만드는 것을 넘어, ‘예측 가능하게’ 만드는 과정이며, 결정성, 지연시간, 지터라는 세 가지 핵심 지표를 통해 평가된다.</p>
<h3>2.1  결정성(Determinism), 지연시간(Latency), 지터(Jitter)의 정의와 상호관계</h3>
<p>실시간 시스템의 성능은 평균적인 속도가 아닌, 최악의 경우에도 주어진 시간 제약을 만족시킬 수 있는지의 여부로 판단된다. 이러한 특성은 결정성, 지연시간, 지터라는 세 가지 밀접하게 연관된 개념으로 설명된다.</p>
<ul>
<li>
<p><strong>결정성 (Determinism)</strong>: 결정성은 실시간 시스템의 가장 핵심적인 속성으로, 시스템이 주어진 입력과 조건 하에서 항상 예측 가능한 시간 범위 내에 태스크를 완료하는 능력을 의미한다.7 이는 ’빠르다’는 것과는 다른 개념으로, ’예측 가능성’과 ’시간 제약 준수’에 중점을 둔다.9 예를 들어, 로봇 팔 제어 시스템은 10ms 이내에 모터에 명령을 전달해야 한다는 마감 시간(Deadline)이 있다면, 이 마감 시간을 100%의 확률로 준수할 수 있을 때 결정성을 확보했다고 말할 수 있다.7</p>
</li>
<li>
<p><strong>지연시간 (Latency)</strong>: 지연시간은 특정 이벤트가 발생한 시점부터 시스템이 해당 이벤트에 대한 반응을 완료하기까지 걸리는 총 시간을 의미한다.11 실시간 시스템에서는 평균 지연시간보다 최악의 경우 최대 지연시간(Worst-Case Latency)을 관리하고 상한을 보장하는 것이 무엇보다 중요하다. 시스템의 총 지연시간</p>
</li>
</ul>
<p><span class="math math-inline">L</span>은 인터럽트 인지 지연, 스케줄링 지연, 태스크 실행 시간 등 다양한 요소의 합으로 표현될 수 있다.<br />
<span class="math math-display">
  L = L_{interrupt} + L_{scheduling} + L_{execution}
</span></p>
<ul>
<li><strong>지터 (Jitter)</strong>: 지터는 지연시간의 변동성, 즉 응답 시간의 일관성을 나타내는 척도이다.11 동일한 작업을 반복 수행할 때 응답 시간이 매번 달라진다면 지터가 크다고 말하며, 이는 시스템의 응답 시간을 예측하기 어렵게 만들어 결정성을 해치는 주요 원인이 된다.14 수학적으로 지터 <span class="math math-inline">J</span>는 특정 기간 동안 측정된 지연시간의 최대값(<span class="math math-inline">L_{max}</span>)과 최소값(<span class="math math-inline">L_{min}</span>)의 차이로 단순하게 정의할 수 있다.13<br />
<span class="math math-display">
J = L_{max} - L_{min}
</span><br />
이 세 가지 개념은 유기적으로 연결되어 있다. 실시간 시스템의 궁극적인 목표는 결정성을 확보하는 것이며, 이를 위해서는 시스템의 최대 지연시간을 마감 시간 이내로 제어하고, 지터를 최소화하여 응답 시간의 예측 가능성을 높여야 한다. 낮은 평균 지연시간을 갖는 시스템이라도 간헐적으로 매우 큰 지연시간 스파이크(spike)가 발생한다면(즉, 지터가 크다면) 실시간 시스템으로서는 부적합하다. 따라서 실시간 시스템의 성능 평가는 ’평균’이 아닌 ’최악의 경우’에 초점을 맞춰야 하며, 이는 <code>cyclictest</code>와 같은 벤치마크 도구가 평균값(Avg)보다 최대값(Max)을 더 중요한 지표로 삼는 이유이기도 하다.</li>
</ul>
<h3>2.2  경성 실시간(Hard Real-Time)과 연성 실시간(Soft Real-Time) 시스템</h3>
<p>실시간 시스템은 마감 시간을 준수하지 못했을 때 발생하는 결과의 심각성에 따라 경성 실시간과 연성 실시간으로 분류된다.</p>
<ul>
<li><strong>경성 실시간 시스템 (Hard Real-Time Systems)</strong>: 마감 시간을 단 한 번이라도 놓치는 것이 시스템 전체의 치명적인 오류(catastrophic failure)로 이어지는 시스템을 말한다.10 예를 들어, 항공기 비행 제어 시스템, 자동차의 에어백 전개 시스템, 원자력 발전소의 안전 시스템 등이 여기에 해당한다.3 이러한 시스템은 어떠한 상황에서도 시간 제약을 반드시 지켜야 하므로, 최악 실행 시간(WCET) 분석을 통한 시간 보장이 필수적이다. PREEMPT_RT 패치는 리눅스를 이러한 경성 실시간 요구사항을 만족시킬 수 있는 운영체제로 변환하는 것을 목표로 한다.15</li>
<li><strong>연성 실시간 시스템 (Soft Real-Time Systems)</strong>: 마감 시간을 놓치더라도 시스템 전체가 실패하지는 않지만, 서비스 품질(Quality of Service, QoS)이 저하되는 시스템을 의미한다.10 예를 들어, 실시간 비디오 스트리밍에서 간헐적인 프레임 드롭이 발생하거나, VoIP 통화 중 음성이 잠시 끊기는 현상은 사용자 경험을 저하시키지만 시스템 전체를 마비시키지는 않는다.3 리눅스의 실시간 스케줄링 정책인 <code>SCHED_FIFO</code>와 <code>SCHED_RR</code>은 주로 연성 실시간 태스크를 구현하는 데 사용된다.16</li>
</ul>
<p>라즈베리 파이에 실시간 리눅스를 구현하는 것은 이러한 경성 또는 연성 실시간 요구사항을 저비용 플랫폼에서 달성하려는 시도이며, 적용 분야에 따라 요구되는 결정성의 수준이 달라진다.</p>
<h2>3.  리눅스 커널의 실시간화 접근법</h2>
<p>표준 리눅스 커널을 실시간 시스템에 적용하기 어려운 근본적인 이유는 커널 내부에 존재하는 예측 불가능한 지연 요소 때문이다. 이를 해결하기 위해 커널의 구조를 변경하는 다양한 접근법이 시도되어 왔으며, 대표적으로 단일 커널을 수정하는 PREEMPT_RT와 이중 커널 구조를 채택하는 Xenomai가 있다.</p>
<h3>3.1  표준 리눅스 커널의 한계: 비선점 구간과 스케줄링 지연</h3>
<p>표준 리눅스 커널은 시스템의 전반적인 처리량을 높이는 데 최적화되어 있다. 이를 위해 커널 코드의 특정 임계 영역(Critical Section)을 실행하는 동안에는 다른 태스크가 끼어드는 선점(Preemption)을 허용하지 않는다. 대표적인 비선점 구간으로는 인터럽트 핸들러(Interrupt Handler)와 스핀락(Spinlock)으로 보호되는 영역이 있다.17</p>
<p>이러한 구조는 심각한 문제를 야기한다. 예를 들어, 우선순위가 매우 높은 실시간 태스크가 실행될 준비가 되더라도, 우선순위가 낮은 태스크가 커널 모드에서 스핀락을 잡고 있다면, 낮은 우선순위의 태스크가 락을 해제할 때까지 무기한 대기해야 할 수 있다. 이러한 예측 불가능한 대기 시간이 바로 스케줄링 지연시간(Scheduling Latency)을 증가시키고 결정성을 해치는 주된 원인이다.</p>
<h3>3.2  단일 커널 접근법: PREEMPT_RT 패치</h3>
<p>PREEMPT_RT(Real-Time Preemption)는 기존 리눅스 커널의 소스 코드를 직접 수정하여 커널의 거의 모든 영역을 선점 가능하게 만드는 패치셋(Patch Set)이다.5 이 접근법은 리눅스의 단일 커널 구조와 풍부한 생태계를 그대로 유지하면서 경성 실시간 운영체제로 변환하는 것을 목표로 한다.18 PREEMPT_RT의 핵심적인 구조 변경 사항은 다음과 같다.</p>
<h4>3.2.1  구조적 변경: 스레드 기반 인터럽트 처리와 슬리핑 스핀락(RT-Mutex)</h4>
<ul>
<li>
<p><strong>스레드 기반 인터럽트 핸들러 (Threaded IRQs)</strong>: PREEMPT_RT는 대부분의 인터럽트 핸들러(IRQ Handler) 실행을 별도의 커널 스레드로 분리한다.20 하드웨어 인터럽트가 발생하면, 커널은 하드웨어 상태를 저장하는 최소한의 작업(Top-half)만 신속하게 처리한 후, 나머지 복잡한 처리 로직(Bottom-half)을 담당하는 커널 스레드를 깨운다. 이 스레드는 일반 스레드와 마찬가지로 우선순위에 따라 스케줄링되므로, 인터럽트를 처리하는 도중에도 더 높은 우선순위의 실시간 태스크가 있다면 즉시 선점될 수 있다. 또한, 각 인터럽트 스레드에 우선순위를 부여하여 중요도에 따라 처리 순서를 제어할 수 있게 된다.5</p>
</li>
<li>
<p><strong>슬리핑 스핀락 (Sleeping Spinlocks) 및 RT-Mutex</strong>: 표준 커널의 스핀락은 락을 기다리는 동안 CPU를 계속 점유하며 대기(Busy-waiting)하고, 이 구간 동안 선점을 비활성화한다. PREEMPT_RT는 이러한 스핀락을 RT-Mutex라는 새로운 동기화 메커니즘으로 대체한다.21 RT-Mutex를 획득하려는 태스크는 락이 해제될 때까지 CPU를 낭비하지 않고 수면 상태(Sleep)로 전환된다. 이 과정에서</p>
</li>
</ul>
<p><strong>우선순위 상속(Priority Inheritance)</strong> 프로토콜이 핵심적인 역할을 한다. 만약 낮은 우선순위의 태스크(L)가 락을 점유한 상태에서 높은 우선순위의 태스크(H)가 동일한 락을 기다리게 되면, 커널은 일시적으로 태스크 L의 우선순위를 태스크 H의 수준으로 끌어올린다. 이로써 중간 우선순위의 태스크(M)가 태스크 L을 선점하여 락 해제를 지연시키는 <strong>우선순위 역전(Priority Inversion)</strong> 문제를 방지하고, 높은 우선순위 태스크의 대기 시간을 최소화한다.5</p>
<h3>3.3  이중 커널 접근법: Xenomai 개요 및 PREEMPT_RT와의 비교 분석</h3>
<p>Xenomai는 PREEMPT_RT와는 근본적으로 다른 이중 커널(Dual-kernel) 아키텍처를 사용한다.13</p>
<ul>
<li><strong>구조</strong>: Xenomai는 표준 리눅스 커널과 나란히 동작하는 작고 독립적인 실시간 마이크로커널(Microkernel)을 시스템에 추가한다. 하드웨어 인터럽트가 발생하면, Xenomai의 인터럽트 파이프라인(I-pipe) 계층이 이를 먼저 가로채어 실시간성이 요구되는 작업은 Xenomai 커널이 직접 처리한다. 실시간 처리가 필요 없는 인터럽트만이 나중에 표준 리눅스 커널로 전달된다.17 이 구조는 실시간 태스크를 비실시간 리눅스 커널의 비결정적 동작으로부터 원천적으로 ’격리’시키는 효과를 가져온다.</li>
<li><strong>성능 및 개발 편의성 비교</strong>: 일반적으로 Xenomai는 리눅스 커널의 간섭을 완전히 배제하므로 PREEMPT_RT보다 더 낮은 지연시간과 지터를 제공하며, 수 마이크로초 수준의 극단적인 경성 실시간 요구사항에 더 적합한 것으로 알려져 있다.13 반면, PREEMPT_RT는 표준 POSIX API(예: pthread)를 그대로 사용하므로 기존 리눅스 개발자들이 별도의 학습 없이 쉽게 접근할 수 있다는 큰 장점이 있다.20 Xenomai는 실시간 태스크 개발을 위해 ’skin’이라고 불리는 고유의 API 에뮬레이션 계층을 사용해야 하므로 개발 복잡성이 더 높다.20</li>
</ul>
<p>이 두 접근법의 선택은 단순한 성능 지표 비교를 넘어선 아키텍처적 트레이드오프(Trade-off) 결정이다. PREEMPT_RT는 ’통합’과 ’개발 용이성’을 우선시하는 반면, Xenomai는 ’격리’를 통한 ’극한의 결정성’을 추구한다. 최근 PREEMPT_RT의 상당 부분이 리눅스 메인라인 커널에 통합되고 지속적으로 개선되면서, 잘 튜닝된 PREEMPT_RT 시스템은 많은 실제 애플리케이션 환경에서 Xenomai와 필적하는 성능을 보이기도 한다.19 따라서 풍부한 리눅스 생태계(드라이버, 네트워크 스택, 파일 시스템 등)를 적극적으로 활용하면서 수십~수백 마이크로초 수준의 실시간성을 요구하는 애플리케이션에는 PREEMPT_RT가, 리눅스 기능 의존도가 낮고 수 마이크로초 수준의 정밀도가 최우선인 애플리케이션에는 Xenomai가 더 적합한 선택이 될 수 있다.</p>
<table><thead><tr><th>구분</th><th>PREEMPT_RT (단일 커널)</th><th>Xenomai (이중 커널)</th></tr></thead><tbody>
<tr><td><strong>아키텍처</strong></td><td>표준 리눅스 커널 직접 수정 (통합형)</td><td>실시간 마이크로커널 + 비실시간 리눅스 (격리형)</td></tr>
<tr><td><strong>인터럽트 처리</strong></td><td>스레드화된 IRQ, 우선순위 기반 스케줄링</td><td>I-pipe가 인터럽트 선점 후 실시간 커널 우선 처리</td></tr>
<tr><td><strong>최소 지연시간</strong></td><td>수십 µs ~ 수백 µs</td><td>수 µs ~ 수십 µs (일반적으로 더 우수)</td></tr>
<tr><td><strong>지터</strong></td><td>Xenomai에 비해 상대적으로 클 수 있음</td><td>매우 낮음 (높은 결정성)</td></tr>
<tr><td><strong>API</strong></td><td>표준 POSIX API (pthread 등)</td><td>고유 API (Alchemy, psos+, etc.) 또는 POSIX 에뮬레이션(‘skin’)</td></tr>
<tr><td><strong>개발 편의성</strong></td><td>높음 (기존 리눅스 개발 경험 활용 가능)</td><td>상대적으로 낮음 (별도 학습 및 커널 관리 필요)</td></tr>
<tr><td><strong>커뮤니티/지원</strong></td><td>리눅스 커널 메인라인에 통합 중, 거대 커뮤니티</td><td>별도 커뮤니티, 상대적으로 규모 작음</td></tr>
<tr><td><strong>적합 애플리케이션</strong></td><td>로보틱스, 산업 자동화, 실시간 오디오 등</td><td>고속 데이터 수집(DAQ), 하드웨어-인더-루프(HIL) 시뮬레이션</td></tr>
</tbody></table>
<h2>4.  라즈베리 파이 PREEMPT_RT 커널 구축 실습</h2>
<p>라즈베리 파이에서 PREEMPT_RT 커널을 사용하기 위해서는 커널 소스를 직접 컴파일하고 설치하는 과정이 필요하다. 이 장에서는 교차 컴파일 환경을 구축하고, 커널을 설정, 빌드, 배포하는 전체 과정을 단계별로 상세히 설명한다.</p>
<h3>4.1  교차 컴파일(Cross-compile) 개발 환경 설정</h3>
<p>라즈베리 파이와 같은 저사양 SBC에서 직접 커널을 컴파일하는 것은 매우 오랜 시간이 소요되므로 비효율적이다. 따라서 일반적으로 더 강력한 성능의 x86 기반 PC에서 라즈베리 파이용(ARM 아키텍처) 코드를 컴파일하는 교차 컴파일(Cross-compile) 방식을 사용한다.23</p>
<p>개발 환경의 복잡성과 의존성 문제를 해결하기 위해 Docker를 활용하는 것이 효과적이다. Docker는 빌드에 필요한 모든 도구(컴파일러, 라이브러리 등)를 컨테이너 이미지 하나에 패키징하여, 어떤 환경에서든 동일한 빌드 결과를 재현할 수 있게 해준다. <code>jonhpark7966/rpi-rt-kernel</code>과 같은 공개된 저장소는 이러한 Docker 기반 교차 컴파일 환경을 쉽게 구축할 수 있는 스크립트와 Dockerfile을 제공한다.23</p>
<h3>4.2  커널 소스 다운로드 및 PREEMPT_RT 패치 적용</h3>
<p>커널 빌드의 첫 단계는 대상 하드웨어와 운영체제 버전에 맞는 커널 소스 코드와 PREEMPT_RT 패치를 준비하는 것이다.</p>
<ol>
<li>
<p><strong>커널 소스 다운로드</strong>: 라즈베리 파이 재단이 유지보수하는 공식 리눅스 커널 소스 저장소에서 원하는 버전의 소스 코드를 <code>git clone</code> 명령으로 내려받는다.</p>
</li>
<li>
<p><strong>PREEMPT_RT 패치 다운로드</strong>: 리눅스 커널 공식 아카이브의 RT 프로젝트 페이지에서 커널 소스 버전과 정확히 일치하는 버전의 PREEMPT_RT 패치 파일을 다운로드한다.23</p>
</li>
<li>
<p><strong>패치 적용</strong>: 다운로드한 커널 소스 디렉터리 내에서 <code>patch</code> 명령어를 사용하여 RT 패치를 적용한다. 예를 들어, 압축된 패치 파일을 파이프로 연결하여 적용할 수 있다.</p>
<pre><code class="language-Bash">xzcat../patch-5.15.60-rt49.patch.xz | patch -p1
</code></pre>
</li>
</ol>
<pre><code>
`rpi-rt-kernel`과 같은 자동화 스크립트는 이 과정을 내부적으로 수행해준다.23

### 4.3  커널 설정(`menuconfig`) 주요 항목 상세 해설


패치가 성공적으로 적용되었다면, `make menuconfig` 명령어를 실행하여 텍스트 기반의 커널 설정 인터페이스에 진입한다. 여기서 실시간 성능에 최적화된 커널을 만들기 위해 몇 가지 중요한 옵션을 설정해야 한다.

- **실시간 선점 모델 활성화**: 가장 핵심적인 설정으로, PREEMPT_RT 패치의 기능을 활성화한다.23
- 경로: `General setup` ---&gt; `Preemption Model`
- 선택: `(X) Fully Preemptible Kernel (PREEMPT_RT)`
- **CPU 주파수 스케일링**: 동적인 CPU 클럭 변경은 예측 불가능한 지연을 유발할 수 있다. 일관된 성능을 위해 CPU 주파수를 최고 속도로 고정하는 것이 권장된다.
- 경로: `CPU Power Management` ---&gt; `CPU Frequency scaling`
- 설정: `Default CPUFreq governor`를 `performance`로 변경하거나, 해당 기능을 완전히 비활성화(`disable`)한다.
- **타이머 주파수 (Timer frequency)**: 타이머 인터럽트의 주기. 높은 값은 시간 정밀도를 향상시키지만 시스템 오버헤드를 증가시킨다. 실시간 시스템에서는 일반적으로 1000Hz와 같은 높은 값을 선호한다.
- 경로: `Kernel features` ---&gt; `Timer frequency`
- 선택: `(X) 1000 Hz`

이 외에도 시스템 디버깅 관련 옵션(`Kernel hacking` 메뉴 등)이나 불필요한 전력 관리 기능들은 비활성화하여 시스템 노이즈를 최소화하는 것이 좋다.

### 4.4  커널 빌드 및 라즈베리 파이 배포 절차


커널 설정이 완료되면, 교차 컴파일러를 지정하여 실제 빌드를 진행하고 결과물을 라즈베리 파이에 설치한다.

1. **커널 빌드**: 다음 명령어를 사용하여 커널 이미지(`Image`), 커널 모듈(`modules`), 그리고 디바이스 트리 바이너리(`dtbs`)를 컴파일한다. `ARCH`는 타겟 아키텍처를, `CROSS_COMPILE`은 교차 컴파일러의 접두사를 지정한다.23

   ```Bash
   make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs
</code></pre>
<ol start="2">
<li>
<p><strong>결과물 전송</strong>: 빌드가 완료되면 생성된 파일들을 라즈베리 파이로 전송해야 한다. <code>scp</code>나 <code>rsync</code>와 같은 네트워크 파일 전송 도구를 사용하여 빌드된 커널 소스 디렉터리 전체를 라즈베리 파이로 복사한다.</p>
</li>
<li>
<p><strong>라즈베리 파이에서 설치</strong>: 라즈베리 파이에 접속하여 전송된 디렉터리로 이동한 후, 다음 명령어들을 순서대로 실행하여 커널 모듈과 디바이스 트리를 시스템에 설치한다.23</p>
<pre><code class="language-Bash">sudo make modules_install
sudo make dtbs_install
</code></pre>
</li>
</ol>
<pre><code>
4. **부트 파티션 업데이트**: 마지막으로, 새로 빌드된 커널 이미지와 디바이스 트리 파일들을 부트 파티션(`/boot` 또는 `/boot/firmware`)에 복사하여 시스템이 새로운 커널로 부팅되도록 설정한다. 기존 커널과 구별하기 위해 새로운 이름(예: `kernel_rt.img`)으로 저장하는 것이 안전하다.23

   ```Bash
   sudo cp arch/arm64/boot/Image /boot/firmware/kernel_rt.img
   sudo cp arch/arm64/boot/dts/broadcom/*.dtb /boot/firmware/
   sudo cp -r arch/arm64/boot/dts/overlays/*.dtb* /boot/firmware/overlays/
</code></pre>
<p>이후 <code>/boot/firmware/config.txt</code> 파일에 <code>kernel=kernel_rt.img</code>와 같은 라인을 추가하여 부팅할 커널을 지정한다.</p>
<ol start="5">
<li><strong>검증</strong>: 라즈베리 파이를 재부팅한 후, 터미널에서 <code>uname -a</code> 명령어를 실행한다. 출력된 커널 버전 정보에 <code>PREEMPT_RT</code>라는 문자열이 포함되어 있다면 성공적으로 실시간 커널이 설치된 것이다.23</li>
</ol>
<h2>5.  시스템 수준 최적화를 통한 결정성 확보</h2>
<p>PREEMPT_RT 커널을 설치하는 것은 실시간 시스템 구축의 첫걸음일 뿐이다. 진정한 결정성을 확보하기 위해서는 커널뿐만 아니라 하드웨어, 펌웨어, 시스템 설정 등 다계층에 걸친 종합적인 최적화가 필수적이다. 이러한 최적화의 핵심 원리는 ’격리(Isolation)’로 요약될 수 있다. 즉, 실시간 태스크의 실행을 방해할 수 있는 모든 비실시간적 요소를 최대한 분리하고 차단하는 것이다.</p>
<p>4.1. 하드웨어 및 펌웨어(BIOS) 설정 튜닝</p>
<p>실시간 성능은 소프트웨어뿐만 아니라 하드웨어 및 펌웨어 수준의 동작 방식에 크게 좌우된다. CPU의 동적인 전력 관리 기능(C-states, P-states), 메모리 오류 감지 및 수정(ECC) 기능, 그리고 운영체제가 제어할 수 없는 시스템 관리 인터럽트(SMI) 등은 예측 불가능한 지연시간을 유발하는 주요 원인이다.24 따라서 고성능 서버급 시스템에서는 BIOS/UEFI 설정에 진입하여 이러한 기능들을 비활성화하거나 최소화하는 것이 일반적인 튜닝의 시작이다. 라즈베리 파이는 전통적인 BIOS가 없지만, <code>/boot/firmware/config.txt</code> 파일을 통해 CPU 클럭 고정, 특정 하드웨어 기능 비활성화 등 유사한 수준의 제어가 가능하다.</p>
<h3>5.1  커널 부팅 파라미터를 이용한 CPU 및 인터럽트 격리</h3>
<p>리눅스 커널은 부팅 시 특정 파라미터를 전달받아 동작 방식을 변경할 수 있다. 실시간 시스템에서는 다음 파라미터들을 조합하여 실시간 태스크를 위한 전용 실행 환경을 구축한다. 이 파라미터들은 라즈베리 파이의 <code>/boot/firmware/cmdline.txt</code> 파일에 추가하여 적용한다.</p>
<ul>
<li><strong><code>isolcpus</code></strong>: 이 파라미터에 지정된 CPU 코어는 리눅스 스케줄러의 일반적인 부하 분산 대상에서 제외된다. 즉, 일반적인 사용자 프로세스나 커널 스레드들이 이 코어에 할당되지 않는다. 이렇게 격리된 코어에는 <code>taskset</code>이나 <code>cgroups</code> 같은 도구를 사용하여 중요한 실시간 애플리케이션을 명시적으로 할당함으로써, 다른 프로세스들의 간섭을 원천적으로 차단할 수 있다.26</li>
<li><strong><code>nohz_full</code></strong>: <code>isolcpus</code>로 격리된 CPU의 결정성을 더욱 향상시키기 위한 파라미터이다. 이 옵션이 적용된 CPU에서는 실행 중인 태스크가 단 하나일 경우, 주기적으로 발생하여 컨텍스트 스위칭을 유발하는 타이머 틱(Timer Tick) 인터럽트가 중단된다. 타이머 틱이 사라지면 불필요한 스케줄러 호출, RCU 처리 등의 커널 오버헤드가 제거되어 시스템 노이즈(Jitter)가 극적으로 감소한다.26</li>
<li><strong><code>rcu_nocbs</code></strong>: RCU(Read-Copy-Update)는 커널 내 데이터 구조를 락 없이 안전하게 읽기 위해 널리 사용되는 동기화 메커니즘이다. 하지만 RCU 업데이트 후 발생하는 콜백(callback) 처리 작업이 지연을 유발할 수 있다. <code>rcu_nocbs</code> 파라미터는 이 콜백 처리 부담을 지정된 CPU에서 다른 ‘하우스키핑’ CPU로 이전(offload)시킨다. <code>nohz_full</code> 파라미터를 사용하면 이 기능이 자동으로 활성화되는 경우가 많아, 격리된 CPU는 순수하게 애플리케이션 코드 실행에만 집중할 수 있게 된다.28</li>
</ul>
<p>이러한 파라미터들을 통해 실시간 태스크를 다른 프로세스로부터(CPU 격리), 커널 내부 활동으로부터(시간적 격리), 그리고 하드웨어 인터럽트로부터(이벤트 격리) 다층적으로 보호하는 것이 가능하다.</p>
<h3>5.2  시스템 데몬 및 IRQ 밸런싱 제어</h3>
<ul>
<li><strong><code>irqbalance</code> 데몬 비활성화</strong>: 대부분의 리눅스 배포판은 기본적으로 <code>irqbalance</code> 데몬을 활성화한다. 이 데몬은 시스템 부하에 따라 하드웨어 인터럽트(IRQ) 처리 부담을 여러 CPU 코어에 동적으로 분산시켜 평균적인 시스템 성능을 향상시킨다. 그러나 실시간 시스템에서는 이러한 동적 재분배가 오히려 캐시 효율을 떨어뜨리고 예측 불가능한 지연을 유발할 수 있다. 따라서 IRQ 처리를 특정 코어에 고정하여 예측 가능성을 높이는 것이 중요하므로, <code>irqbalance</code> 데몬은 반드시 비활성화해야 한다.24</li>
<li><strong>IRQ 선호도(Affinity) 수동 설정</strong>: <code>irqbalance</code>를 비활성화한 후에는 <code>/proc/irq/&lt;IRQ_NUMBER&gt;/smp_affinity</code> 파일을 직접 수정하여 각 인터럽트가 어느 CPU에서 처리될지 수동으로 지정해야 한다. 핵심 전략은 네트워크, 산업용 버스 카드 등 실시간 데이터 처리와 관련된 중요한 IRQ를 <code>isolcpus</code>로 격리되지 않은 ‘하우스키핑’ CPU에 할당하는 것이다. 반대로, 실시간 태스크가 실행될 격리된 CPU에서는 타이머와 같은 필수적인 IRQ를 제외한 모든 IRQ를 제거하여, 하드웨어 인터럽트로 인한 간섭을 최소화해야 한다.24</li>
</ul>
<h3>5.3  라즈베리 파이 하드웨어 아키텍처 고찰: 공유 I/O 버스에서 RP1 컨트롤러까지</h3>
<ul>
<li><strong>이전 모델의 구조적 한계</strong>: 라즈베리 파이 4 이전 모델들은 이더넷과 USB 포트들이 내부적으로 단일 USB 2.0 버스를 공유하는 아키텍처를 가졌다.30 이는 고질적인 성능 병목 현상을 유발했다. 예를 들어, 이더넷을 통해 대용량 파일을 전송하는 동시에 USB 저장 장치에 데이터를 기록하면, 두 작업이 제한된 버스 대역폭을 놓고 경쟁하여 양쪽 모두의 성능이 저하되고 응답 시간이 예측 불가능해졌다. 이러한 하드웨어적 한계는 실시간 시스템의 결정성을 확보하는 데 심각한 제약 요인이었다.33</li>
<li><strong>라즈베리 파이 5의 구조적 혁신</strong>: 라즈베리 파이 5는 이러한 문제를 해결하기 위해 아키텍처에 근본적인 변화를 주었다. 메인 SoC(BCM2712)와는 별도로 I/O 기능을 전담하는 RP1 “사우스브릿지” 칩을 도입한 것이다.34 RP1은 USB 3.0/2.0 포트, 기가비트 이더넷 컨트롤러, MIPI 카메라/디스플레이 인터페이스 등 대부분의 I/O를 독립적으로 제어하며, 메인 SoC와는 고속의 PCI Express(PCIe) 2.0 인터페이스로 연결된다.37</li>
<li><strong>실시간 성능에 미치는 긍정적 영향</strong>: 이 분리된 I/O 아키텍처는 I/O 장치 간의 대역폭 경쟁 문제를 원천적으로 해결한다.36 이제 이더넷 트래픽이 USB 장치의 데이터 전송 속도나 응답 시간에 영향을 주지 않으며, 그 반대도 마찬가지다. 이는 I/O 작업으로 인해 발생하던 예측 불가능한 지연(지터)을 크게 감소시켜 시스템 전체의 결정성을 획기적으로 향상시킨다. 이러한 하드웨어적 격리 구조는 라즈베리 파이 5를 이전 세대 모델들보다 훨씬 더 신뢰성 있는 실시간 플랫폼으로 만들어주는 핵심적인 개선점이다.</li>
</ul>
<table><thead><tr><th>파라미터</th><th>목표</th><th>동작 원리</th><th>사용 예시 (<code>cmdline.txt</code>)</th><th>상호작용 및 주의사항</th></tr></thead><tbody>
<tr><td><code>isolcpus</code></td><td>CPU 격리</td><td>특정 CPU를 일반 스케줄러의 로드 밸런싱에서 제외.</td><td><code>isolcpus=2,3</code></td><td>격리된 CPU에 실시간 태스크를 <code>taskset</code> 등으로 명시적으로 할당해야 함.</td></tr>
<tr><td><code>nohz_full</code></td><td>타이머 틱 제거</td><td>격리된 CPU에 실행 가능한 태스크가 1개일 때 주기적인 타이머 인터럽트를 중단하여 OS 지터 감소.</td><td><code>nohz_full=2,3</code></td><td><code>isolcpus</code>와 동일한 CPU 목록을 지정하는 것이 일반적. 완벽한 tickless를 위해선 애플리케이션 조건(posix timer 미사용 등)이 충족되어야 함.</td></tr>
<tr><td><code>rcu_nocbs</code></td><td>RCU 콜백 오프로드</td><td>RCU 콜백 처리 작업을 격리된 CPU가 아닌 다른 CPU의 <code>rcuo</code> 커널 스레드로 이전.</td><td><code>rcu_nocbs=2,3</code></td><td><code>nohz_full</code> 사용 시 자동으로 해당 CPU에 대해 활성화되므로 명시적으로 지정할 필요가 없는 경우가 많음.</td></tr>
<tr><td><code>irqaffinity</code></td><td>IRQ 처리 CPU 지정</td><td>부팅 시 기본 IRQ 처리 CPU를 지정. 특정 CPU를 IRQ 처리에서 제외하는 데 사용.</td><td><code>irqaffinity=0-1</code></td><td><code>isolcpus</code>로 지정된 CPU는 이 목록에서 제외하여 IRQ 간섭을 최소화.</td></tr>
</tbody></table>
<h2>6.  애플리케이션 수준 최적화 기법</h2>
<p>커널과 시스템 수준의 최적화가 완료되었다면, 다음 단계는 실시간 애플리케이션 자체를 최적화하여 시스템의 잠재력을 최대한 활용하는 것이다. 이는 올바른 스케줄링 정책을 선택하고 메모리 관리로 인한 지연을 방지하는 두 가지 핵심 기법으로 이루어진다.</p>
<h3>6.1  실시간 스케줄링 정책 심층 분석: <code>SCHED_FIFO</code> 대 <code>SCHED_RR</code></h3>
<p>리눅스는 실시간 태스크를 위해 두 가지 주요 스케줄링 정책을 제공한다. 이 정책들은 일반 정책인 <code>SCHED_OTHER</code>(CFS 스케줄러가 사용)보다 항상 높은 우선순위를 가지며, 1(가장 낮음)부터 99(가장 높음)까지의 정적 우선순위 값을 사용한다.39</p>
<ul>
<li><strong><code>SCHED_FIFO</code> (First-In, First-Out)</strong>: 이 정책은 가장 단순하고 강력한 실시간 스케줄링 방식이다. 일단 <code>SCHED_FIFO</code> 태스크가 CPU를 점유하면, 더 높은 우선순위의 태스크가 나타나거나, 스스로 I/O 대기 등의 이유로 실행을 멈추지 않는 한 계속해서 실행된다. 동일한 우선순위를 가진 다른 <code>SCHED_FIFO</code> 태스크가 있더라도 선점되지 않는다. 즉, 타임 슬라이스(Time Slice)나 시간 할당량(Quantum) 개념이 없다.16</li>
<li><strong>적용 시나리오</strong>: 시스템에서 가장 중요한 단일 제어 루프나 데이터 처리 파이프라인과 같이, 다른 태스크의 간섭을 최소화하고 최대한 빨리 작업을 완료해야 하는 경우에 적합하다. 잘못 사용하면 낮은 우선순위의 모든 태스크(심지어 시스템 관리 태스크까지)가 기아(Starvation) 상태에 빠질 수 있으므로 신중하게 사용해야 한다.43</li>
<li><strong><code>SCHED_RR</code> (Round-Robin)</strong>: 이 정책은 <code>SCHED_FIFO</code>의 변형이다. 우선순위에 따라 스케줄링되는 점은 동일하지만, 동일한 우선순위를 가진 태스크들 사이에서는 정해진 타임 슬라이스만큼만 실행한 후, 실행 큐의 다음 태스크에게 CPU를 양보하는 라운드 로빈 방식을 사용한다.16</li>
<li><strong>적용 시나리오</strong>: 동일한 중요도를 가진 여러 개의 실시간 태스크가 공평하게 CPU 시간을 나누어 가져야 할 때 유용하다. 예를 들어, 여러 개의 모터를 동시에 제어하는 로봇 애플리케이션에서 각 모터 제어 스레드를 동일한 우선순위의 <code>SCHED_RR</code>로 설정하면, 모든 모터가 주기적으로 제어 신호를 받을 수 있도록 보장할 수 있다.43</li>
</ul>
<p>애플리케이션의 특성을 정확히 파악하고, 태스크 간의 관계를 고려하여 <code>SCHED_FIFO</code>와 <code>SCHED_RR</code>을 적절히 조합하는 것이 중요하다. <code>chrt</code> 유틸리티나 <code>sched_setscheduler()</code> 시스템 콜을 사용하여 프로세스나 스레드의 스케줄링 정책과 우선순위를 동적으로 변경할 수 있다.39</p>
<h3>6.2  메모리 페이지 폴트(Page Fault) 방지: <code>mlockall</code> 함수의 원리와 적용</h3>
<ul>
<li>
<p><strong>문제점: 페이지 폴트의 비결정성</strong>: 현대 운영체제는 물리적 RAM보다 큰 주소 공간을 사용하기 위해 가상 메모리 시스템을 활용한다. 애플리케이션이 특정 메모리 주소에 접근하려 할 때, 해당 데이터가 담긴 메모리 페이지가 물리적 RAM에 존재하지 않고 디스크(스왑 공간)에 내려가 있을 수 있다. 이 경우 ’페이지 폴트(Page Fault)’라는 예외가 발생하고, 커널은 디스크 I/O를 통해 해당 페이지를 RAM으로 다시 읽어 들여와야 한다. 이 디스크 I/O 작업은 수 밀리초(ms)에 달하는 매우 길고 예측 불가능한 지연을 유발하며, 이는 실시간 시스템의 결정성을 심각하게 훼손하는 주범이다.</p>
</li>
<li>
<p><strong>해결책: <code>mlockall()</code> 시스템 콜</strong>: 이러한 페이지 폴트로 인한 지연을 원천적으로 방지하기 위해 <code>mlockall()</code> 시스템 콜을 사용한다.45 이 함수는 호출한 프로세스가 사용하는 모든 메모리 페이지(코드, 데이터, 스택, 공유 라이브러리 등)를 물리적 RAM에 강제로 고정(Lock)하여, 운영체제가 해당 페이지들을 디스크로 스왑 아웃(Swap-out)하는 것을 금지한다.46</p>
</li>
<li>
<p><strong>사용법 및 주요 플래그</strong>: 실시간 애플리케이션의 초기화 코드 부분에서 <code>mlockall()</code>을 호출하는 것이 일반적이다.</p>
<pre><code class="language-C">#include &lt;sys/mman.h&gt;

int main(void) {
    //... 초기화 코드...

    // 현재 매핑된 메모리와 앞으로 매핑될 모든 메모리를 RAM에 고정한다.
    if (mlockall(MCL_CURRENT | MCL_FUTURE)!= 0) {
        perror("mlockall failed");
        // 오류 처리
    }

    //... 실시간 핵심 로직...

    munlockall(); // 프로그램 종료 전 메모리 락 해제
    return 0;
}
</code></pre>
</li>
</ul>
<pre><code>
- `MCL_CURRENT`: 함수 호출 시점에 이미 프로세스의 주소 공간에 매핑되어 있는 모든 페이지를 잠근다.45
- `MCL_FUTURE`: 함수 호출 이후에 `malloc()`, `mmap()` 등을 통해 동적으로 할당되거나 매핑될 모든 페이지도 자동으로 잠기도록 설정한다.45

실시간 애플리케이션에서 `mlockall(MCL_CURRENT | MCL_FUTURE)`를 사용하는 것은 페이지 폴트로 인한 예측 불가능한 지연을 제거하여 시스템의 결정성을 확보하기 위한 필수적인 프로그래밍 기법이다.45

## 7.  실시간 성능 측정 및 분석


실시간 시스템을 구축하고 최적화하는 과정은 지속적인 측정과 분석을 통해 검증되어야 한다. 하드웨어 자체의 한계를 파악하는 것부터 시작하여, 다양한 부하 조건에서 시스템의 스케줄링 지연시간을 정량적으로 평가하는 것이 중요하다.

### 7.1  하드웨어 고유 지연시간 측정: `hwlatdetect` 활용 및 결과 해석


- **목적**: `hwlatdetect`는 운영체제(OS)나 애플리케이션의 영향을 배제하고, 순수하게 하드웨어 아키텍처나 펌웨어(BIOS, SMI 등) 자체에서 발생하는 고유한 지연시간을 측정하는 도구이다.25 이는 특정 하드웨어 플랫폼이 실시간 워크로드를 실행하기에 근본적으로 적합한지 여부를 판단하는 첫 번째 관문 역할을 한다.

- **동작 원리**: `hwlatdetect`는 내부적으로 커널 스레드를 실행하여 CPU의 타임스탬프 카운터(TSC)를 매우 짧은 주기로 반복해서 읽는다. 정상적인 상황에서는 연속된 읽기 값의 차이가 일정해야 한다. 만약 이 시간 값에 비정상적인 '점프'나 '공백'이 발견된다면, 이는 시스템 관리 인터럽트(SMI)와 같이 OS가 제어할 수 없는 이벤트로 인해 CPU가 잠시 멈췄음을 의미한다.48

- **사용법 및 결과 해석**: 일반적으로 시스템에 다른 부하를 주지 않은 상태에서 장시간(수 분 ~ 수 시간) 실행하여 최대 지연시간을 관찰한다.

  ```Bash
  sudo hwlatdetect --duration=300s
</code></pre>
<p>실행 결과에서 가장 중요한 지표는 <code>Max Latency</code>이다. 예를 들어, <code>Max Latency: 18us</code>라는 결과는 펌웨어나 하드웨어로 인해 최대 18 마이크로초의 예측 불가능한 지연이 발생할 수 있음을 의미한다. 만약 구축하려는 시스템이 10 마이크로초 미만의 지연시간을 요구한다면, 이 하드웨어는 부적합하다고 판단할 수 있다. 이 경우, BIOS 설정 변경(전력 관리 기능 비활성화 등)이나 시스템 공급업체를 통한 펌웨어 업데이트를 고려해야 한다.25</p>
<h3>7.2  스케줄링 지연시간 벤치마킹: <code>cyclictest</code> 주요 옵션 및 결과 분석</h3>
<ul>
<li>
<p><strong>목적</strong>: <code>cyclictest</code>는 PREEMPT_RT 개발자들이 커널의 실시간 성능을 측정하기 위해 만든 표준 벤치마크 도구이다. 이 도구는 실시간 스레드가 주기적으로 깨어나도록 설정된 시간과, 운영체제 스케줄러에 의해 실제로 깨어난 시간 사이의 차이, 즉 스케줄링 지연시간을 정밀하게 측정한다.49</p>
</li>
<li>
<p><strong>주요 옵션</strong>: <code>cyclictest</code>는 매우 다양한 옵션을 제공하지만, 실시간 성능 측정 시 필수적으로 사용되는 옵션은 다음과 같다.49</p>
</li>
<li>
<p><code>--smp</code> (<code>-S</code>): SMP 시스템에서 각 CPU 코어별로 측정 스레드를 생성하고 해당 코어에 고정(pinning)하여 코어별 성능을 측정한다.</p>
</li>
<li>
<p><code>--priority=&lt;p&gt;</code> (<code>-p &lt;p&gt;</code>): 측정 스레드의 실시간 우선순위를 1에서 99 사이의 값으로 설정한다.</p>
</li>
<li>
<p><code>--interval=&lt;i&gt;</code> (<code>-i &lt;i&gt;</code>): 스레드가 깨어나는 주기를 마이크로초(µs) 단위로 설정한다.</p>
</li>
<li>
<p><code>--histogram=&lt;val&gt;</code> (<code>-h &lt;val&gt;</code>): 측정된 지연시간의 분포를 히스토그램 형태로 출력하여 데이터의 분포를 시각적으로 분석할 수 있게 한다.</p>
</li>
<li>
<p><code>--mlockall</code> (<code>-m</code>): 페이지 폴트로 인한 측정 오류를 방지하기 위해 <code>mlockall()</code>을 호출하여 메모리를 잠근다.</p>
</li>
<li>
<p><strong>결과 분석</strong>: <code>cyclictest</code>를 실행하면 각 스레드별로 <code>Min</code>, <code>Act</code>, <code>Avg</code>, <code>Max</code> 지연시간이 실시간으로 출력된다.</p>
<pre><code># T: 0 ( 959) P:95 I:1000 C: 34650 Min: 1 Act: 8 Avg: 12 Max: 377
</code></pre>
</li>
</ul>
<pre><code>
- **Max Latency의 중요성**: 이 결과에서 가장 주목해야 할 값은 단연 `Max`이다.49

`Avg`(평균) 지연시간이 아무리 낮더라도, 단 한 번의 긴 `Max` 지연시간이 발생하면 경성 실시간 시스템의 마감 시간을 놓칠 수 있기 때문이다. 실시간 시스템 튜닝의 목표는 바로 이 `Max` 값을 애플리케이션이 허용하는 범위 내로 안정적으로 유지하는 것이다.

- **히스토그램 분석**: 히스토그램은 지연시간 값의 분포를 보여준다. 이상적인 실시간 시스템의 히스토그램은 대부분의 값이 낮은 지연시간 쪽에 집중되어 있고, 오른쪽으로 긴 꼬리(long tail)가 없는 형태를 띤다. 만약 특정 값에서 빈도가 높게 나타나거나 긴 꼬리가 관찰된다면, 이는 시스템에 간헐적으로 지연을 유발하는 특정 노이즈 소스가 존재함을 시사한다.

- **현실적인 부하 테스트**: `cyclictest`는 실제 애플리케이션과 유사한 부하(네트워크 트래픽, 디스크 I/O, 그래픽 작업 등)를 동시에 가하면서 측정해야만 의미 있는 결과를 얻을 수 있다.52 부하가 없는 상태에서의

`Max` 값은 시스템의 잠재력을 보여줄 뿐, 실제 운영 환경에서의 성능을 보장하지 않는다. 또한, 측정된 최대값은 테스트 기간 동안의 최대값일 뿐 시스템의 이론적인 최악 실행 시간(WCET)을 보장하는 것은 아니라는 점을 인지해야 한다.52

| 항목              | 레이블      | 설명                           | 실시간 성능 해석 가이드라인                                  |
| ----------------- | ----------- | ------------------------------ | ------------------------------------------------------------ |
| 스레드 정보       | T           | 측정 스레드의 인덱스 및 ID.    | SMP 테스트 시 각 코어의 성능을 개별적으로 확인하는 데 사용.  |
| 우선순위          | P           | 측정 스레드의 실시간 우선순위. | 실제 애플리케이션의 우선순위와 동일하게 설정하여 테스트.     |
| 측정 횟수         | C           | 총 측정된 샘플의 수.           | 신뢰도 있는 Max 값을 얻으려면 충분히 긴 시간(수 시간~수 일) 동안 실행하여 C 값을 높여야 함. |
| 최소 지연시간     | Min         | 측정된 가장 짧은 지연시간.     | 시스템이 이상적으로 동작할 때의 응답 시간. 일반적으로 10µs 미만. |
| 평균 지연시간     | Avg         | 모든 측정값의 산술 평균.       | 시스템의 전반적인 응답성을 나타내지만, 최악의 경우를 보장하지 않으므로 실시간 평가에서는 참고용. |
| **최대 지연시간** | **Max**     | **측정된 가장 긴 지연시간.**   | **가장 중요한 지표.** 이 값이 시스템의 결정성을 좌우하며, 애플리케이션의 마감 시간 요구사항을 충족해야 함. 수십 µs 수준을 목표로 튜닝. |
| 히스토그램        | (별도 출력) | 지연시간 값의 빈도 분포.       | 분포가 좁고 왼쪽으로 치우칠수록 좋음. 오른쪽으로 긴 꼬리가 있다면 간헐적인 지연 유발 요인이 있음을 시사. |

## 8.  활용 사례 및 결론


라즈베리 파이에 PREEMPT_RT 커널을 적용하고 시스템을 최적화하는 기술은 이론에만 머무르지 않고, 이미 다양한 산업 및 연구 분야에서 실질적인 가치를 창출하고 있다. 저비용, 고성능, 높은 접근성을 바탕으로 과거에는 상상하기 어려웠던 영역까지 그 활용 범위를 넓혀가고 있다.

### 8.1  산업 자동화 및 로보틱스 분야 적용 사례 연구


- **협동 로봇 및 로보틱스**: 라즈베리 파이는 저렴한 비용과 강력한 컴퓨팅 성능, 풍부한 I/O 인터페이스 덕분에 차세대 성장 동력으로 꼽히는 협동 로봇의 '두뇌' 역할을 하는 제어기로 각광받고 있다.1 로봇의 정밀한 모터 제어, 다중 센서 데이터의 동기화된 처리, 그리고 안전을 위한 빠른 반응 속도를 보장하기 위해서는 PREEMPT_RT 커널을 통한 실시간 성능 확보가 필수적이다.4
- **산업용 IoT 및 스마트 팩토리**: 스마트 팩토리, 스마트 팜과 같은 산업용 사물인터넷(IIoT) 분야에서도 라즈베리 파이의 활약이 두드러진다. 공장 자동화 라인의 센서 데이터를 실시간으로 모니터링하거나 54, 비닐하우스의 온도와 습도를 정밀하게 제어하는 시스템 55 등은 모두 시간적 정확성이 중요한 애플리케이션이다. PREEMPT_RT 커널은 데이터 수집의 시간적 정밀도를 보장하고, 제어 루프의 예측 가능성을 높여 생산성과 안정성을 향상시키는 데 기여한다.15
- **첨단 연구 사례**: 최근 연구에서는 반능동형(semi-active) 의족의 실시간 제어를 위해 라즈베리 파이 4에 PREEMPT_RT 커널을 적용하고, 실시간 산업용 통신 프로토콜인 EtherCAT을 구현한 사례가 보고되었다. 이 시스템은 250 마이크로초($\mu s$)의 빠른 샘플링 주기를 달성했으며, 통신 주기의 지터(표준편차)를 4.51 $\mu s$라는 매우 낮은 수준으로 제어하는 데 성공했다.56 이는 라즈베리 파이가 적절한 소프트웨어 최적화를 통해 수백 마이크로초 단위의 엄격한 경성 실시간 제어 분야에서도 충분히 활용될 수 있음을 실증적으로 보여주는 중요한 사례이다.

### 8.2  라즈베리 파이 실시간 리눅스 시스템의 종합적 평가 및 향후 과제


- **종합 평가**: 본 안내서에서 고찰한 바와 같이, PREEMPT_RT 패치의 적용과 커널 파라미터 튜닝, IRQ 및 애플리케이션 수준의 체계적인 최적화를 통해 라즈베리 파이는 수많은 연성 실시간 및 일부 경성 실시간 애플리케이션을 충분히 감당할 수 있는 강력하고 경제적인 플랫폼으로 거듭날 수 있다. 특히, I/O 병목 현상을 하드웨어적으로 해결한 RP1 컨트롤러를 탑재한 라즈베리 파이 5의 등장은 이전 세대의 근본적인 한계를 극복하고 실시간 플랫폼으로서의 가능성을 한 단계 끌어올렸다.
- **향후 과제 및 전망**:
1. **메인라인 통합 가속화**: PREEMPT_RT 패치의 리눅스 메인라인 커널 완전 통합은 계속 진행 중인 중요한 과제이다.19 통합이 완료되면 사용자는 더 이상 복잡한 패치 작업 없이 커널 설정만으로 실시간 기능을 활성화할 수 있게 되어, 실시간 리눅스의 접근성이 획기적으로 향상될 것이다.
2. **고성능 인터페이스 활용**: 라즈베리 파이 5에 도입된 PCIe 인터페이스는 NVMe SSD, 고속 네트워크 카드, FPGA 등 고성능 주변장치를 연결할 수 있는 길을 열었다.38 이러한 고속 I/O 채널을 실시간 시스템에 효과적으로 통합하고 제어하는 기술은 향후 중요한 연구 주제가 될 것이다.
3. **실시간 네트워킹**: 산업 자동화 및 분산 제어 시스템에서는 개별 노드의 실시간 성능뿐만 아니라 노드 간의 결정론적 통신이 매우 중요하다. TSN(Time-Sensitive Networking)과 같은 실시간 이더넷 기술을 라즈베리 파이 PREEMPT_RT 시스템과 접목하는 연구는 그 응용 범위를 더욱 넓히는 핵심 과제가 될 것이다.

결론적으로, 라즈베리 파이는 더 이상 교육용 및 취미용 플랫폼에 머무르지 않는다. 실시간 리눅스와의 결합을 통해, 라즈베리 파이는 산업 자동화, 로보틱스, 그리고 차세대 임베디드 시스템 개발을 위한 신뢰성 있고 경제적인 핵심 플랫폼으로 자리매김하고 있으며, 그 잠재력은 앞으로 더욱 커질 것으로 전망된다.

## 9. 참고 자료


1. '빈국의 컴퓨터' 라즈베리파이, 로봇산업의 핵심으로 [테크토크] - 아시아경제, https://cm.asiae.co.kr/article/2023101308574708047
2. 로봇공학: Raspberry Pi로 지능형 기계 만들기 - FasterCapital, [https://fastercapital.com/ko/content/%EB%A1%9C%EB%B4%87%EA%B3%B5%ED%95%99--Raspberry-Pi%EB%A1%9C-%EC%A7%80%EB%8A%A5%ED%98%95-%EA%B8%B0%EA%B3%84-%EB%A7%8C%EB%93%A4%EA%B8%B0.html](https://fastercapital.com/ko/content/로봇공학--Raspberry-Pi로-지능형-기계-만들기.html)
3. RTiK-Linux: 리눅스용 실시간 이식 커널의 설계 - Korea Science, https://koreascience.kr/article/JAKO201129349655908.pdf
4. Real-Time Performance in Linux: Harnessing PREEMPT_RT for Embedded Systems - RunTime Recruitment, https://runtimerec.com/wp-content/uploads/2024/10/real-time-performance-in-linux-harnessing-preempt-rt-for-embedded-systems_67219ae1.pdf
5. The Real-Time Linux Kernel: A Survey on PREEMPT_RT, https://re.public.polimi.it/retrieve/e0c31c12-9844-4599-e053-1705fe0aef77/11311-1076057_Reghenzani.pdf
6. Raspberry Pi Performance Analysis in Real-Time Applications with the RT-Preempt Patch, https://www.researchgate.net/publication/339653462_Raspberry_Pi_Performance_Analysis_in_Real-Time_Applications_with_the_RT-Preempt_Patch
7. Real time operating system determinism - IntervalZero, https://www.intervalzero.com/real-time-operating-system-determinism/
8. How to Achieve Deterministic Behavior in Real-Time Embedded Systems - Lance Harvie, https://www.embeddedrelated.com/showarticle/1742.php
9. Latency and Determinism - Curtiss-Wright Defense Solutions, https://www.curtisswrightds.com/media-center/blog/latency-determinism-which-more-important-application
10. Deterministic, real-time control: What does it really mean in motion control applications?, https://www.motioncontroltips.com/deterministic-real-time-control-what-does-it-really-mean-in-motion-control-applications/
11. 네트워크 지연 시간이란 무엇인가요? - AWS, https://aws.amazon.com/ko/what-is/latency/
12. Latency vs. Jitter: Understanding Network Metrics - Obkio, https://obkio.com/blog/latency-vs-jitter/
13. Performance Evaluation of GNU/Linux for Real-Time Applications - DiVA portal, https://www.diva-portal.org/smash/get/diva2:158978/FULLTEXT01.pdfGoPro
14. Determinism and Jitter in a Real-Time System - NI - National Instruments, https://www.ni.com/docs/en-US/bundle/labview-nxg-rt-module-programming-with-rt-target/page/determinism-real-time.html
15. Real-Time Performance and Response Latency Measurements of Linux Kernels on Single-Board Computers - MDPI, https://www.mdpi.com/2073-431X/10/5/64
16. Chapter 2 : Process Management and Scheduling - The SEAN's ..., https://linuxpro.readthedocs.io/ko/latest/linuxpro/chapter2.html
17. How fast is fast enough? Choosing between Xenomai and Linux for real-time applications, https://picture.iczhiku.com/resource/paper/WyIEpzspsLtjRXnc.pdf
18. (PDF) A Comparison of Real-Time Linux-Based Architectures for ..., https://www.researchgate.net/publication/358135895_A_Comparison_of_Real-Time_Linux-Based_Architectures_for_Embedded_Musical_Applications
19. Realtime Linux가 오랜 논쟁 끝에 리눅스 커널에 공식 포함 - GeekNews, https://news.hada.io/topic?id=16860
20. Real-time Linux explained, and contrasted with Xenomai and RTAI - LinuxGizmos.com, https://linuxgizmos.com/real-time-linux-explained/
21. Technical details of the real-time preemption - Wiki, https://wiki.linuxfoundation.org/realtime/documentation/technical_details/start
22. Lock types and their rules - The Linux Kernel documentation, https://docs.kernel.org/locking/locktypes.html
23. 라즈베리파이에 Real Time kernel 올리기 - sudormrf, https://sudormrf.run/2022/06/18/raspberrypi-realtime-linux/
24. 20.2. irqbalance 데몬 비활성화 | 짧은 대기 시간 작업을 위해 RHEL 9 ..., https://docs.redhat.com/ko/documentation/red_hat_enterprise_linux_for_real_time/9/html/optimizing_rhel_9_for_real_time_for_low_latency_operation/proc_disabling-the-irqbalance-daemon_assembly_binding-interrupts-and-processes
25. 짧은 대기 시간 작업을 위해 RHEL 9 for Real Time 최적화 | Red Hat ..., https://docs.redhat.com/ko/documentation/red_hat_enterprise_linux_for_real_time/9/html-single/optimizing_rhel_9_for_real_time_for_low_latency_operation/index
26. 3.13. Isolating CPUs Using tuned-profiles-realtime - Red Hat Documentation, https://docs.redhat.com/en/documentation/red_hat_enterprise_linux_for_real_time/7/html/tuning_guide/isolating_cpus_using_tuned-profiles-realtime
27. How to configure CPUs for real-time processing - Ubuntu documentation, https://documentation.ubuntu.com/real-time/latest/how-to/cpu-boot-configs/
28. CPU Isolation – Nohz_full – by SUSE Labs (part 3) | SUSE ..., https://www.suse.com/c/cpu-isolation-nohz_full-part-3/
29. Kernel configuration parameters for RCU - LWN.net, https://lwn.net/Articles/777214/
30. How to Perform Real-Time Processing on the Raspberry Pi, https://www.socallinuxexpo.org/sites/default/files/presentations/Steven_Doran_SCALE_13x.pdf
31. Raspberry Pi 3B+ USB, WiFi, Eth shared/common bus, https://forums.raspberrypi.com/viewtopic.php?t=207940
32. Getting Gigabit Networking on a Raspberry Pi 2, 3 and B+ | Jeff Geerling, https://www.jeffgeerling.com/blogs/jeff-geerling/getting-gigabit-networking
33. Is it really true, that the RPi runs faster when booting from a good USB Stick?, https://forums.raspberrypi.com/viewtopic.php?t=221160
34. Raspberry Pi - Wikipedia, https://en.wikipedia.org/wiki/Raspberry_Pi
35. (PDF) Raspberry Pi 5 : The new Raspberry Pi family with more computation power and AI integration - ResearchGate, https://www.researchgate.net/publication/375552555_Raspberry_Pi_5_The_new_Raspberry_Pi_family_with_more_computation_power_and_AI_integration
36. Testing PCIe on the Raspberry Pi 5 | Jeff Geerling, https://www.jeffgeerling.com/blog/2023/testing-pcie-on-raspberry-pi-5
37. Raspberry Pi 5 - Raspberry Pi Datasheets, https://datasheets.raspberrypi.com/rpi5/raspberry-pi-5-product-brief.pdf
38. PCIe Performance on Raspberry Pi 5 - I am Bill Meyer, https://iambillmeyer.com/posts/2025-01-02-raspberrypi5-pcie-performance/
39. 리눅스 커널 실시간 스케줄링 우선순위 - 대체로 무해함, https://lethean.github.io/2010/09/30/linux-kernel-realtime-scheduling-priority/
40. 리눅스 커널 스케줄러(Scheduler) - Rain.i, http://cloudrain21.com/linux-kernel-scheduler
41. sched(7) - Linux manual page - Michael Kerrisk, https://man7.org/linux/man-pages/man7/sched.7.html
42. Process Scheduling, https://courses.grainger.illinois.edu/cs241/sp2013/lecture/17-Sched_II_sol.pdf
43. Scheduling threads - IBM, https://www.ibm.com/docs/en/aix/7.2.0?topic=programming-scheduling-threads
44. Linux kernel schedulers - Real-time Ubuntu documentation, https://documentation.ubuntu.com/real-time/latest/explanation/schedulers/
45. mlock(2) - Linux manual page - Michael Kerrisk, https://man7.org/linux/man-pages/man2/mlock.2.html
46. mlock System Call in Unix - Tutorialspoint, https://www.tutorialspoint.com/unix_system_calls/mlock.htm
47. 2.2. Using mlock to Avoid Page I/O | Reference Guide | Red Hat Enterprise Linux for Real Time, https://docs.redhat.com/en/documentation/red_hat_enterprise_linux_for_real_time/7/html/reference_guide/using_mlock_to_avoid_page_io
48. SUSE Linux Enterprise RT 15 SP7 | SLE RT Hardware Testing, https://documentation.suse.com/en-us/sle-rt/15-SP7/html/SLE-RT-all/article-hardware-testing.html
49. realtime:documentation:howto:tools:cyclictest:start [Wiki], https://wiki.linuxfoundation.org/realtime/documentation/howto/tools/cyclictest/start
50. Latency Measurement - RVspace Doc Center, https://doc-en.rvspace.org/VisionFive2/RTLinux/VF2_RT_Linux/2_3_latency_measurement.html
51. Tools for measuring real-time metrics - Ubuntu documentation, https://documentation.ubuntu.com/real-time/latest/reference/real-time-metrics-tools/
52. Using and Understanding the Real-Time Cyclictest Benchmark, https://events.static.linuxfound.org/sites/events/files/slides/cyclictest.pdf
53. CONFIG_PREEMPT_RT on Raspberry Pi - Page 3, https://forums.raspberrypi.com/viewtopic.php?t=39951&amp;start=50
54. [논문]라즈베리파이를 이용한 스마트 홈 프로토타입 구현, https://scienceon.kisti.re.kr/srch/selectPORSrchArticle.do?cn=JAKO201532742223692
55. Raspberry Pi를 이용한 원격 제어 및 모니터링 시스템 개발과 HILS를 통한 시스템 검증 - 인하대학교, http://ecsl.inha.ac.kr/publication/ICROS2017_f.pdf
56. (PDF) Real-Time Motor Control Using a Raspberry Pi, ROS, and CANopen over EtherCAT, with Application to a Semi-Active Prosthetic Ankle - ResearchGate, https://www.researchgate.net/publication/388947362_Real-Time_Motor_Control_Using_a_Raspberry_Pi_ROS_and_CANopen_over_EtherCAT_with_Application_to_a_Semi-Active_Prosthetic_Ankle
57. Raspberry Pi 5 review: Just delightful - Pocket-lint, https://www.pocket-lint.com/raspberry-pi-5-review/
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>