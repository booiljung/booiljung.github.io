<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Android의 실시간 처리 성능</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Android의 실시간 처리 성능</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">시스템 (Systems)</a> / <a href="index.html">안드로이드 (Android)</a> / <span>Android의 실시간 처리 성능</span></nav>
                </div>
            </header>
            <article>
                <h1>Android의 실시간 처리 성능</h1>
<h2>1.  범용 OS로서의 안드로이드와 실시간 처리의 간극</h2>
<h3>1.1  실시간 시스템의 핵심 요구사항 정의</h3>
<p>실시간 운영체제(Real-Time Operating System, RTOS)는 단순히 빠른 연산 속도를 지향하는 시스템이 아니다. 그 본질은 시간적 제약 조건, 즉 ’데드라인(deadline)’을 반드시 준수하는 능력에 있다. 이러한 시간적 정확성을 보장하기 위해 RTOS는 결정성(Determinism), 예측 가능성(Predictability), 그리고 낮은 지연 시간(Latency)과 지터(Jitter)라는 세 가지 핵심 요구사항을 충족해야 한다.</p>
<h4>1.1.1 결정성과 예측 가능성</h4>
<p>결정성은 특정 입력이 주어졌을 때, 시스템이 항상 동일한 결과를 정해진 시간 안에 출력하는 특성을 의미한다.1 이는 연산의 논리적 정확성뿐만 아니라 시간적 정확성까지 포함하는 개념이다. 예측 가능성은 이 결정성의 기반이 되는 특성으로, 시스템의 모든 작업(task)이 언제 시작하고 언제 끝날지를 사전에 예측할 수 있음을 의미한다.1 일반적인 운영체제(General-Purpose Operating System, GPOS)에서는 반복적인 작업이 매번 다른 시간 내에 완료될 수 있지만, RTOS에서는 작업 수행 시간이 엄격한 경계 내에서 보장된다.1 즉, RTOS의 가치는 주어진 시간 동안 얼마나 많은 작업을 처리할 수 있는지(throughput)가 아니라, 개별 작업의 완료 시간을 얼마나 확실하게 보장할 수 있는지(guarantee)로 평가된다.3</p>
<h4>1.1.2 지연 시간과 지터</h4>
<p>지연 시간은 외부 이벤트가 발생한 시점부터 시스템이 해당 이벤트에 대한 반응을 시작하기까지 걸리는 시간을 측정한다.5 여기에는 인터럽트 지연 시간(interrupt latency)과 스레드 전환 지연 시간(thread switching latency) 등이 포함된다.3 실시간 시스템의 목표는 이 지연 시간을 최소화하고 일관되게 유지하는 것이다.7 지터는 이러한 지연 시간의 변동성, 즉 응답 시간의 불규칙성을 의미한다.5 평균 지연 시간이 아무리 낮더라도 지터가 크면 시스템의 동작을 예측할 수 없게 되어 신뢰성이 저하된다.6 특히, 로봇 제어나 정밀 통신과 같이 매우 정확한 타이밍이 요구되는 시스템에서 높은 지터는 치명적인 오류를 유발할 수 있다.9</p>
<h4>1.1.3 경성, 연성, 확고한 실시간 시스템의 구분</h4>
<p>실시간 시스템은 데드라인 미준수가 초래하는 결과의 심각성에 따라 세 가지로 분류된다.</p>
<ul>
<li><strong>경성 실시간 시스템(Hard Real-Time System):</strong> 단 한 번의 데드라인 미준수도 시스템 전체의 치명적인 실패(catastrophic failure)로 이어지는 시스템이다. 항공기 비행 제어 시스템이나 자동차의 에어백 전개 시스템이 대표적인 예다.5 이러한 시스템은 최악의 경우(worst-case)에도 반드시 데드라인을 준수하도록 설계되고 수학적으로 증명되어야 한다.</li>
<li><strong>연성 실시간 시스템(Soft Real-Time System):</strong> 데드라인을 놓치더라도 시스템 전체가 실패하지는 않지만, 서비스 품질(Quality of Service, QoS)이 저하되는 시스템이다. 온라인 비디오 스트리밍에서 발생하는 일시적인 버퍼링이나 온라인 게임의 랙(lag) 현상이 이에 해당한다.1</li>
<li><strong>확고한 실시간 시스템(Firm Real-Time System):</strong> 연성 실시간 시스템과 유사하지만, 데드라인을 놓친 결과값은 아무런 가치가 없게 되는 시스템이다. 예를 들어, 주식 거래 플랫폼에서 데드라인을 넘겨 수신된 시세 정보는 더 이상 유용하지 않다.5</li>
</ul>
<h3>1.2  표준 안드로이드의 설계 철학과 실시간 보장의 상충 관계</h3>
<p>안드로이드는 스마트폰, 태블릿, TV 등 다양한 기기에서 구동되는 세계에서 가장 널리 사용되는 범용 운영체제다. 이러한 범용성은 안드로이드의 성공 요인이지만, 동시에 실시간 시스템이 요구하는 엄격한 시간적 제약을 보장하는 데 근본적인 한계로 작용한다.</p>
<h4>1.2.1 평균 처리량 및 공정성 최적화</h4>
<p>안드로이드의 기반이 되는 표준 리눅스 커널과 안드로이드 런타임(Android Runtime, ART)의 핵심 설계 철학은 ’공정성(Fairness)’과 ’평균 처리량(Average Throughput)의 극대화’에 있다.7 시스템은 수많은 사용자 애플리케이션, 백그라운드 서비스, 시스템 프로세스들이 동시에 실행되는 환경에서, 이들 모두에게 CPU와 메모리 같은 자원을 최대한 공평하게 분배하여 전반적인 사용자 경험을 부드럽게 유지하고자 한다. 이는 특정 고우선순위 작업이 다른 모든 작업을 희생시키더라도 즉각적이고 결정적인 실행을 보장해야 하는 RTOS의 ‘우선순위 기반 선점형 스케줄링(priority-based preemptive scheduling)’ 철학과 정면으로 배치된다.2 안드로이드에서는 중요한 작업이라 할지라도 다른 덜 중요한 작업들과 자원을 나눠 써야 하므로, 실행 시간의 결정성을 보장할 수 없다.</p>
<p>이러한 철학의 차이는 “실시간“이라는 용어에 대한 흔한 오해를 명확히 보여준다. 많은 이들이 실시간을 단순히 “더 빠른 성능“으로 인식하지만, 실제로는 그렇지 않다. 안드로이드 프레임워크 엔지니어와 리눅스 커널 개발자들은 실시간 시스템이 전체적인 처리량 측면에서는 오히려 비실시간 시스템보다 느릴 수 있다고 지적한다.13 이는 실시간 시스템이 일부 중요한 작업의 ’예측 가능성’을 보장하기 위해 다른 작업들의 평균 성능을 희생하는 트레이드오프를 감수하기 때문이다. 따라서 안드로이드와 실시간 시스템의 근본적인 대립은 ’속도’의 문제가 아니라, ’공정성’과 ’예측 가능성’이라는 상충하는 설계 목표 사이의 문제다.</p>
<h4>1.2.2 범용성의 대가</h4>
<p>안드로이드는 예측 불가능한 사용자의 입력, 수천 가지가 넘는 하드웨어 조합, 그리고 수백만 개의 애플리케이션을 지원해야 하는 극도로 복잡한 시스템이다.1 이러한 범용성을 지원하기 위해 안드로이드 아키텍처는 여러 추상화 계층과 동적인 자원 관리 메커니즘을 포함하고 있으며, 이는 시스템의 동작을 예측하기 어렵게 만든다.11 반면, RTOS는 일반적으로 특정 목적을 위해 경량화되고(small footprint) 최적화되어 있으며, 시스템을 구성하는 모든 하드웨어와 소프트웨어 구성 요소가 사전에 알려져 있어 전체 시스템의 동작을 수학적으로 모델링하고 예측하는 것이 가능하다.1 안드로이드의 유연성과 확장성은 장점이지만, 실시간 처리의 관점에서는 예측 불가능성을 높이는 ’대가’로 작용하는 셈이다.</p>
<h2>2.  안드로이드 실시간 성능의 근본적 병목 현상 분석</h2>
<p>안드로이드가 경성 실시간 요구사항을 충족시키지 못하는 이유는 시스템 스택의 여러 계층에 걸쳐 존재하는 근본적인 병목 현상 때문이다. 이 문제들은 크게 리눅스 커널 수준의 스케줄링 제약과 안드로이드 런타임(ART) 수준의 실행 중단 문제로 나눌 수 있다. 이 두 가지 문제는 서로 독립적이면서도 상호작용하여 안드로이드의 실시간 성능을 저해하는 핵심 원인이 된다.</p>
<h3>2.1  리눅스 커널 수준의 제약</h3>
<p>안드로이드는 리눅스 커널을 기반으로 하며, 표준 리눅스 커널의 스케줄링 정책과 메커니즘은 실시간 처리에 여러 가지 구조적인 제약을 내포하고 있다.</p>
<h4>2.1.1 Completely Fair Scheduler (CFS)의 비결정성</h4>
<p>표준 리눅스 커널의 기본 스케줄러인 CFS는 이름에서 알 수 있듯이 모든 태스크에 ‘완전하게 공정한(Completely Fair)’ CPU 시간을 할당하는 것을 목표로 한다.15 CFS는 각 태스크가 CPU를 사용한 시간을 추적하여, 가장 적게 실행된 태스크에게 다음 실행 기회를 부여하는 방식으로 동작한다. 이러한 방식은 일반적인 데스크톱이나 서버 환경에서 시스템의 전반적인 응답성과 처리량을 높이는 데 매우 효과적이다.7 하지만, 이는 우선순위가 높은 실시간 태스크가 긴급하게 실행되어야 할 때 즉시 CPU를 선점하지 못하고, 우선순위가 낮은 다른 태스크가 자신의 ‘공정한’ 할당 시간을 다 사용할 때까지 기다려야 하는 상황을 유발할 수 있다. 이는 마이크로초 단위의 데드라인 보장이 필요한 작업에는 치명적인 약점으로 작용한다.</p>
<h4>2.1.2 실시간(RT) 태스크 스로틀링(Throttling)</h4>
<p>시스템 안정성을 위해, 표준 리눅스 커널은 버그가 있거나 악의적인 실시간 태스크가 무한 루프에 빠져 CPU를 100% 점유함으로써 시스템 전체를 마비시키는 것을 방지하는 보호 메커니즘을 가지고 있다. 이를 ’실시간 스로틀링’이라 하며, 기본적으로 특정 주기(기본값 1초) 동안 실시간 태스크들이 사용할 수 있는 총 CPU 시간을 제한한다(기본값 0.95초, 즉 95%).15 이 5%의 여유 시간은 비실시간 태스크(예: 셸, 시스템 복구 프로세스)가 실행될 기회를 보장하여 시스템이 완전히 멈추는 것을 막는다. 그러나 구글의 개발자들에 따르면, 이 보호 메커니즘은 의도와 달리 너무 공격적으로 작동하여 정상적인 실시간 작업의 실행마저 방해하는 경우가 많다.16 이로 인해 안드로이드와 크롬OS에서는 실시간 스케줄링 기능이 사실상 무용지물이 되는 문제가 발생하기도 했다.16</p>
<h4>2.1.3 인터럽트 및 스케줄링 지연 시간</h4>
<p>표준 커널에서는 하드웨어 인터럽트가 발생했을 때 실행되는 인터럽트 서비스 루틴(ISR)이나, 커널의 핵심 자료구조를 보호하기 위한 임계 영역(critical section) 실행 중에는 다른 태스크로의 전환(선점, preemption)이 비활성화된다. 만약 이 비선점 구간이 길어질 경우, 우선순위가 매우 높은 실시간 태스크가 준비(ready) 상태에 있더라도 ISR이나 임계 영역 실행이 끝날 때까지 무기한 대기해야 한다. 이것이 바로 스케줄링 지연 시간(scheduling latency)의 주된 원인이다.6 예를 들어, Google Stadia 클라우드 게이밍 서비스의 초기 개발 과정에서 개발자들은 리눅스 커널 스케줄러로 인해 발생하는 수 밀리초 단위의 예측 불가능한 끊김(hitch) 현상으로 큰 어려움을 겪었다.18 60fps 게임 환경에서는 한 프레임을 16ms 안에 처리해야 하는데, 1ms의 무작위 지연만 발생해도 프레임 드롭으로 이어지기 때문이다.18</p>
<h3>2.2  안드로이드 런타임(ART)의 비결정성 요인</h3>
<p>커널 수준의 문제와 더불어, 안드로이드 애플리케이션이 실행되는 환경인 ART 역시 실시간 성능을 저해하는 중요한 요소를 포함하고 있다. 가장 대표적인 것이 가비지 컬렉션(Garbage Collection, GC)이다.</p>
<h4>2.2.1 가비지 컬렉션(GC)과 ‘Stop-the-World’ 문제</h4>
<p>GC는 자바나 코틀린과 같은 관리형 언어(managed language)에서 프로그래머 대신 사용되지 않는 메모리(객체)를 자동으로 찾아 회수하는 필수적인 기능이다.19 그러나 이 과정에서 발생하는 ‘Stop-the-World’(STW) 현상은 실시간 시스템에 심각한 문제를 야기한다. STW는 GC가 정확한 메모리 상태를 파악하기 위해 애플리케이션의 모든 실행 스레드를 일시적으로 멈추는 단계를 의미한다.21 안드로이드의 초기 런타임이었던 Dalvik의 GC는 이 STW 시간이 수십에서 수백 밀리초에 달했으며, 이는 애니메이션 끊김(jank)이나 오디오 드롭아웃과 같은 사용자 경험 저하의 주된 원인이었다.21 이러한 예측 불가능하고 긴 실행 중단은 실시간 시스템의 결정성이라는 기본 전제를 완전히 파괴한다.</p>
<h4>2.2.2 최신 ART의 완화 기술 - 동시 병렬 복사(Concurrent Copying) GC</h4>
<p>구글은 이 문제를 해결하기 위해 ART의 GC를 지속적으로 개선해왔다. 특히 안드로이드 8.0(Oreo)에서 도입된 동시 병렬 복사(Concurrent Copying, CC) GC는 획기적인 발전을 이루었다.23 CC GC는 애플리케이션 스레드가 실행되는 동안 거의 동시에(concurrently) 힙(heap)을 압축(compaction)하고 살아있는 객체들을 새로운 메모리 공간으로 복사한다.23 이 덕분에 STW 시간은 힙 크기와 무관하게 수 밀리초 수준의 짧고 일정한 시간으로 크게 단축되었다.23 안드로이드 10부터는 여기에 세대별 GC(Generational GC) 개념을 다시 도입하여, 수명이 짧은 젊은 세대(young generation) 객체들을 더 빠르고 효율적으로 수거함으로써 전체적인 GC 처리량을 향상시켰다.23</p>
<p>이러한 발전은 GC가 실시간 시스템에 미치는 영향을 극적으로 완화했다. 과거 Dalvik 시절의 GC가 경성 실시간 시스템의 ’살인자(killer)’였다면, 현재 ART의 CC GC는 연성 실시간 시스템의 ‘도전 과제(challenge)’ 수준으로 문제를 격하시켰다고 평가할 수 있다. 하지만 여전히 스레드의 실행 상태를 파악하기 위한 스레드 루트(thread roots) 처리 과정에서 짧은 STW 중단이 존재하며, 객체 참조를 가로채기 위한 리드 배리어(read-barrier) 메커니즘으로 인한 약간의 런타임 오버헤드가 발생한다.23 따라서 극도로 엄격한 경성 실시간 요구사항을 충족하기에는 여전히 한계가 있다.</p>
<h4>2.2.3 JIT 컴파일과 앱 수명주기 관리의 복잡성</h4>
<p>현대 ART는 설치 시점에 코드를 네이티브 코드로 변환하는 AOT(Ahead-Of-Time) 컴파일과, 실행 중에 자주 사용되는 코드를 동적으로 최적화하는 JIT(Just-In-Time) 컴파일을 혼용하는 하이브리드 방식을 사용한다.26 여기에 앱의 실행 상태(cold start, warm start)와 시스템의 부하 상태에 따라 성능이 동적으로 변하고, 복잡한 안드로이드 프레임워크의 수명주기 관리 로직이 더해져 시스템 전체의 동작을 예측하는 것을 더욱 어렵게 만든다.28 이러한 동적 최적화와 복잡성은 평균적인 성능을 높이는 데는 기여하지만, 최악의 경우 실행 시간(Worst-Case Execution Time, WCET)을 예측하고 보장해야 하는 실시간 시스템의 관점에서는 비결정성을 높이는 요소로 작용한다.</p>
<p>결론적으로, 안드로이드의 실시간 성능 문제는 커널의 비결정적 스케줄링과 런타임의 예측 불가능한 실행 중단이라는 두 가지 근본적인 문제에서 비롯된다. 따라서 안드로이드에서 의미 있는 수준의 실시간 성능을 확보하기 위해서는 이 두 가지 문제를 모두 해결할 수 있는 다각적인 접근이 필수적이다.</p>
<h2>3.  안드로이드 실시간 성능 확보를 위한 아키텍처별 접근법</h2>
<p>표준 안드로이드가 가진 근본적인 한계를 극복하고 실시간 성능을 확보하기 위해, 업계와 학계에서는 다양한 아키텍처적 접근법을 발전시켜왔다. 이 방법들은 크게 세 가지 범주로 나눌 수 있다: (1) 리눅스 커널 자체를 강화하여 경성 실시간 성능을 구현하는 <code>PREEMPT_RT</code> 패치 적용, (2) 하이퍼바이저를 통해 안드로이드와 RTOS를 물리적으로 격리하여 함께 실행하는 가상화 기반 혼합 임계 시스템 구축, (3) 애플리케이션 수준에서 NDK와 스레딩 기법을 활용하여 연성 실시간 성능을 개선하는 최적화. 이 세 가지 접근법은 서로 경쟁하는 관계라기보다는, 요구되는 실시간 보장 수준, 구현 복잡성, 그리고 비용의 스펙트럼 위에서 각기 다른 지점을 차지하는 상호 보완적인 해결책으로 이해해야 한다.</p>
<h3>3.1  접근법 1: 커널 강화를 통한 하드 실시간(Hard Real-Time) 구현 - PREEMPT_RT</h3>
<p><code>PREEMPT_RT</code>는 표준 리눅스 커널을 완전 선점형(fully preemptible) 실시간 커널로 변환하는 것을 목표로 하는 패치셋(patchset)이다.29 이는 안드로이드 시스템 전체에 결정론적 스케줄링 기반을 제공하는 가장 근본적인 해결책 중 하나다.</p>
<h4>3.1.1 <code>PREEMPT_RT</code> 패치의 핵심 기술</h4>
<p><code>PREEMPT_RT</code>는 커널 내에서 선점을 방해하는 요소를 최소화하기 위해 여러 핵심적인 수정을 가한다.</p>
<ul>
<li><strong>슬리핑 스핀락(Sleeping Spinlocks):</strong> 표준 커널에서 사용되는 스핀락(spinlock)은 락을 획득할 때까지 CPU를 계속 소모하며(busy-waiting), 이 기간 동안 선점이 비활성화된다. <code>PREEMPT_RT</code>는 대부분의 스핀락을 우선순위 상속(priority inheritance) 기능을 지원하는 뮤텍스(rt_mutex)로 대체한다.29 이를 통해 락을 기다리는 고우선순위 태스크는 CPU를 낭비하지 않고 잠들게(sleep) 되며, 그 동안 다른 태스크가 실행될 수 있어 시스템의 반응성이 향상된다.</li>
<li><strong>인터럽트 스레드화(Threaded IRQs):</strong> 기존에는 인터럽트 핸들러(Interrupt Service Routine, ISR)가 모든 다른 프로세스보다 높은 우선순위로 실행되어 긴급한 실시간 태스크의 실행을 방해할 수 있었다. <code>PREEMPT_RT</code>는 인터럽트 핸들러의 긴급하지 않은 후반부(bottom-half) 작업을 일반 커널 스레드로 분리한다.30 이 스레드들은 스케줄러의 통제를 받으며 우선순위를 가질 수 있게 되어, 인터럽트 처리로 인한 시스템 전체의 지연 시간을 예측 가능하게 만든다.32</li>
<li><strong>우선순위 상속(Priority Inheritance):</strong> 실시간 시스템에서 흔히 발생하는 우선순위 역전(priority inversion) 문제를 해결하기 위한 핵심 메커니즘이다. 우선순위 역전은 낮은 우선순위의 태스크가 높은 우선순위 태스크가 필요로 하는 자원(예: 뮤텍스)을 점유하고 있을 때, 중간 우선순위의 다른 태스크가 실행되면서 고우선순위 태스크가 무기한 대기하게 되는 현상이다.32 우선순위 상속은 자원을 점유한 저우선순위 태스크의 우선순위를 일시적으로 고우선순위 태스크의 수준으로 끌어올려, 해당 자원이 신속하게 해제되도록 보장한다.29</li>
</ul>
<h4>3.1.2 성능 특성과 트레이드오프</h4>
<p><code>PREEMPT_RT</code>를 적용하면 최악 지연 시간(worst-case latency)과 지터가 극적으로 감소하여 시스템의 결정성이 크게 향상된다. 하지만 이러한 결정성을 얻는 데에는 대가가 따른다. 슬리핑 스핀락과 인터럽트 스레드화는 추가적인 컨텍스트 스위칭과 락 관리 오버헤드를 발생시켜, 시스템의 전체적인 평균 처리량(throughput)을 다소 감소시킨다.33 또한, CPU가 유휴 상태에 들어가는 것을 방해하여 전력 효율이 저하될 수도 있다.33 이는 “실시간“이 반드시 “더 빠른 성능“을 의미하지 않으며, 오히려 예측 가능성을 위해 평균 성능을 희생하는 선택임을 명확히 보여준다.13</p>
<h4>3.1.3 메인라인 커널 통합의 의미</h4>
<p>20년이 넘는 긴 개발 기간 끝에, <code>PREEMPT_RT</code>의 핵심 기능들이 마침내 리눅스 커널 6.12 버전부터 메인라인에 완전히 통합되었다.34 이는 과거처럼 복잡한 패치 적용과 관리 과정 없이, 커널 빌드 시 <code>CONFIG_PREEMPT_RT</code> 옵션을 활성화하는 것만으로 실시간 커널을 사용할 수 있게 되었음을 의미한다.36 이 변화는 안드로이드 OEM과 개발자들이 실시간 커널을 채택하는 기술적 장벽을 획기적으로 낮추는 패러다임의 전환이다. 이를 통해 <code>PREEMPT_RT</code> 커널을 기반으로 하는 안드로이드 시스템은 과거보다 훨씬 쉽게 구현될 수 있으며, NDK를 사용하는 애플리케이션이 이전에는 불가능했던 수준의 확고한 실시간(firm real-time) 보장을 받을 수 있는 기반을 마련해준다.</p>
<h3>3.2  접근법 2: 가상화를 통한 혼합 임계(Mixed-Criticality) 시스템 구축 - 하이퍼바이저</h3>
<p>자동차, 항공, 의료 기기와 같이 안전이 절대적으로 중요한 시스템에서는, 안드로이드와 같은 범용 OS의 오류가 치명적인 제어 기능에 영향을 미치는 것을 원천적으로 차단해야 한다. 이를 위해 하이퍼바이저(Hypervisor)를 이용한 가상화 기술이 사용된다.</p>
<h4>3.2.1 타입-1 하이퍼바이저의 역할</h4>
<p>타입-1 하이퍼바이저는 운영체제 없이 하드웨어(bare metal) 위에서 직접 실행되는 경량의 소프트웨어 계층이다. 이 하이퍼바이저는 물리적인 하드웨어 자원(CPU 코어, 메모리, 주변 장치)을 가상의 머신(Virtual Machine, VM)들에게 분할하여 할당하고, 각 VM이 서로에게 영향을 미치지 않도록 완벽하게 격리하는 역할을 수행한다.38</p>
<h4>3.2.2 안드로이드와 RTOS의 병행 실행</h4>
<p>하이퍼바이저 아키텍처에서는 하나의 멀티코어 SoC(System-on-a-Chip) 위에 여러 개의 독립적인 운영체제를 동시에 실행할 수 있다. 예를 들어, 일부 CPU 코어에는 계기판 표시나 차량 제어와 같은 안전 필수(safety-critical) 기능을 담당하는 경성 실시간 OS(예: QNX, Green Hills INTEGRITY)를 VM으로 실행하고, 나머지 코어에는 인포테인먼트나 사용자 인터페이스를 담당하는 안드로이드를 또 다른 VM으로 실행하는 방식이다.38 이는 가장 강력한 수준의 실시간 보장과 안정성을 제공하는 아키텍처로, 한쪽 OS에서 커널 패닉과 같은 심각한 오류가 발생하더라도 다른 쪽 OS는 아무런 영향을 받지 않고 정상적으로 동작한다.38</p>
<h4>3.2.3 자원 격리 및 통신</h4>
<p>하이퍼바이저는 각 VM이 할당된 메모리 영역과 주변 장치에만 접근할 수 있도록 하드웨어의 메모리 관리 유닛(MMU)과 I/O MMU(IOMMU)를 통해 엄격하게 통제한다. 예를 들어, 안드로이드 VM이 차량 제어 네트워크(CAN)에 직접 접근하는 것을 막고, RTOS VM만이 접근할 수 있도록 설정할 수 있다. 두 VM 간의 통신이 필요한 경우(예: 안드로이드 앱에서 차량 속도 정보를 요청), 하이퍼바이저가 제공하는 안전한 공유 메모리나 가상화된 통신 채널(para-virtualized devices)과 같은 제어된 메커니즘을 통해서만 데이터 교환이 이루어진다.38</p>
<p>안드로이드 플랫폼 자체도 보안 강화를 목적으로 pKVM(protected Kernel-based Virtual Machine)이라는 경량 하이퍼바이저 기술을 도입하고 있다.41 Qualcomm의 Gunyah와 같은 상용 하이퍼바이저 역시 안드로이드 가상화 프레임워크(AVF)를 지원하며, 이는 향후 안드로이드 생태계 내에서 실시간 VM과 비실시간 VM을 함께 운영하는 혼합 임계 시스템 구축이 더욱 보편화될 수 있음을 시사한다.42</p>
<h3>3.3  접근법 3: 애플리케이션 최적화를 통한 소프트 실시간(Soft Real-Time) 개선 - NDK 및 스레딩</h3>
<p>경성 실시간 보장까지는 필요 없지만, 일반적인 안드로이드 앱보다 훨씬 낮은 지연 시간이 요구되는 연성 실시간 애플리케이션(예: 프로 오디오, 실시간 통신, 고성능 게임)의 경우, 애플리케이션 수준의 최적화를 통해 성능을 개선할 수 있다.</p>
<h4>3.3.1 NDK(Native Development Kit) 활용</h4>
<p>NDK는 안드로이드 앱에서 C/C++ 코드를 사용할 수 있게 해주는 도구 모음이다.43 자바나 코틀린으로 작성된 코드는 ART 위에서 실행되므로 GC와 같은 비결정적 요소의 영향을 받는다. 반면, NDK를 사용하여 C/C++로 작성된 네이티브 코드는 이러한 런타임의 제약에서 벗어나 하드웨어에 더 가깝게 동작한다.44 따라서 오디오 신호 처리나 물리 엔진 연산과 같이 지연 시간에 매우 민감하고 계산량이 많은 부분은 네이티브 코드로 구현하고, JNI(Java Native Interface)를 통해 ART와 연동하는 것이 효과적이다.45 이는 ART의 비결정성을 국소적으로 우회하는 가장 직접적이고 비용 효율적인 방법이다.</p>
<h4>3.3.2 안드로이드 스레드 우선순위 관리</h4>
<p>안드로이드는 <code>Process.setThreadPriority()</code> API를 통해 개별 스레드의 우선순위를 리눅스 커널 수준에서 조절할 수 있는 기능을 제공한다. 안드로이드는 <code>THREAD_PRIORITY_DEFAULT</code>부터 <code>THREAD_PRIORITY_URGENT_AUDIO</code>(-16), <code>THREAD_PRIORITY_URGENT_DISPLAY</code>(-8)에 이르기까지 다양한 우선순위 상수를 정의하고 있다.46 시간에 민감한 작업을 수행하는 스레드(예: 오디오 콜백 스레드)의 우선순위를 <code>THREAD_PRIORITY_URGENT_AUDIO</code>와 같이 높게 설정하면, 커널 스케줄러가 다른 일반 스레드보다 이 스레드에게 더 많은 실행 기회를 부여하여 응답성을 개선할 수 있다.47 하지만 이는 시스템 전체의 실시간성을 보장하는 것이 아니라, 단지 스케줄링될 확률을 높이는 기법일 뿐이다.</p>
<h4>3.3.3 우선순위 역전(Priority Inversion) 회피</h4>
<p>스레드 우선순위를 사용하는 시스템에서는 우선순위 역전 문제에 항상 주의해야 한다. 안드로이드 오디오 시스템(AudioFlinger)에서는 이 문제가 고질적으로 발생하는데, 예를 들어 높은 우선순위의 fast mixer 스레드가 낮은 우선순위의 일반 mixer 스레드가 점유하고 있는 뮤텍스를 기다리면서 오디오 끊김(glitch)이나 드롭아웃이 발생하는 현상이다.48 이러한 문제를 피하기 위해서는 고우선순위 스레드와 저우선순위 스레드가 공유하는 자원의 임계 영역(critical section)을 최대한 짧게 유지하고, 락 없는(lock-free) 자료구조를 사용하거나, 우선순위 상속을 지원하는 뮤텍스를 신중하게 사용하는 등의 프로그래밍 기법이 요구된다.48</p>
<p>결론적으로, 이 세 가지 접근법은 각각 다른 수준의 실시간 보장을 제공한다. NDK 최적화는 특정 앱의 연성 실시간 성능을 개선하는 전술적 해법이며, <code>PREEMPT_RT</code>는 시스템 전체에 확고한 실시간 기반을 제공하는 시스템적 해법이다. 그리고 하이퍼바이저는 안전이 필수적인 혼합 임계 시스템을 위한 가장 강력하고 완전한 아키텍처적 해법이다. 따라서 개발자와 시스템 설계자는 자신의 애플리케이션이 요구하는 실시간 보장 수준과 허용 가능한 비용 및 복잡성을 고려하여 가장 적합한 접근법을 선택하거나 조합해야 한다.</p>
<h2>4.  주요 산업 분야별 적용 사례 및 과제</h2>
<p>안드로이드의 실시간 처리 능력에 대한 요구는 특정 산업 분야에서 더욱 두드러지게 나타난다. 자동차, 산업 제어, 프로페셔널 오디오는 각각 다른 수준의 실시간 제약 조건을 가지며, 이를 해결하기 위해 앞서 논의된 아키텍처적 접근법들이 실제로 어떻게 적용되는지를 보여주는 대표적인 사례다. 이들 사례를 통해 공통적으로 발견되는 패턴은, 안드로이드 전체를 실시간 OS로 만들려는 시도보다는, ‘관심사의 분리(separation of concerns)’ 원칙에 입각하여 시간 민감형 작업과 비민감형 작업을 격리하는 아키텍처가 지배적으로 사용된다는 점이다.</p>
<h3>4.1  자동차(Automotive): 안드로이드 오토모티브 OS와 혼합 임계 시스템</h3>
<p>자동차 산업은 안드로이드가 실시간 요구사항과 만나는 가장 복잡하고 중요한 영역 중 하나다.</p>
<h4>4.1.1 IVI(In-Vehicle Infotainment) 플랫폼으로서의 AAOS</h4>
<p>안드로이드 오토모티브 OS(AAOS)는 스마트폰을 연결하는 안드로이드 오토와 달리, 차량 내 하드웨어에서 직접 실행되는 독립적인 운영체제다.49 AAOS는 구글 지도, 구글 어시스턴트, 그리고 다양한 미디어 및 메시징 앱을 차량 환경에 최적화된 형태로 제공하며, 많은 자동차 제조사들이 차세대 IVI 플랫폼으로 채택하고 있다.50</p>
<h4>4.1.2 실시간 요구사항</h4>
<p>AAOS 자체는 실시간 OS가 아니지만, 차량 시스템과 깊이 연동되면서 실시간 또는 그에 준하는 빠른 응답성이 요구되는 기능들이 존재한다. 예를 들어, 차량의 후진 기어가 들어가면 후방 카메라 영상이 지체 없이 즉시 화면에 표시되어야 한다. 또한, 운전자가 터치스크린으로 공조 장치(climate control)를 조작했을 때의 반응이나, 계기판(instrument cluster)에 표시되는 속도, RPM, 경고등과 같은 정보는 실시간으로 정확하게 업데이트되어야 한다.50 이러한 기능들의 지연은 운전자의 안전과 직결될 수 있다.</p>
<h4>4.1.3 솔루션: 하이퍼바이저 아키텍처</h4>
<p>자동차 산업에서 안전은 타협할 수 없는 가치이므로, IVI 시스템의 오류가 차량의 핵심 제어 기능에 영향을 미치는 것을 원천적으로 차단해야 한다. 이를 위해 업계 표준으로 자리 잡은 해결책이 바로 하이퍼바이저 기반의 혼합 임계(mixed-critality) 아키텍처다.38 이 구조에서는 Green Hills Software의 INTEGRITY Multivisor나 BlackBerry의 QNX Hypervisor와 같은 타입-1 하이퍼바이저가 SoC 위에 실행된다.38 그리고 하이퍼바이저는 시스템 자원을 분할하여, 안전 필수(safety-critical) 기능인 디지털 계기판, 첨단 운전자 보조 시스템(ADAS), 게이트웨이 등은 검증된 RTOS(예: INTEGRITY, QNX)가 담당하는 VM에서 실행하고, 비안전(non-safety-critical) 기능인 인포테인먼트는 AAOS가 담당하는 별도의 VM에서 실행한다.39 이로써 AAOS 앱이 충돌하거나 시스템이 멈추더라도 계기판이나 ADAS 기능은 전혀 영향을 받지 않는 완벽한 격리(isolation)를 달성할 수 있다.</p>
<h3>4.2  산업 제어 시스템(ICS): HMI와 실시간 제어의 결합</h3>
<p>산업 자동화 및 제어 시스템(Industrial Control System, ICS) 분야에서도 안드로이드의 활용 가능성이 탐색되고 있다.</p>
<h4>4.2.1 안드로이드의 HMI(Human-Machine Interface) 활용</h4>
<p>안드로이드 플랫폼은 풍부하고 직관적인 UI/UX 프레임워크, 강력한 네트워킹 기능, 그리고 상대적으로 저렴하고 구하기 쉬운 하드웨어라는 장점을 가지고 있다.51 이러한 특성 덕분에 공장 자동화, 장비 모니터링, 데이터 수집 등의 분야에서 HMI(인간-기계 인터페이스) 장치로 널리 활용되고 있다.52 특히, 원격 모니터링 및 제어(Remote Monitoring and Control, RMC) 시스템에서는 태블릿이나 스마트폰을 클라이언트로 사용하여 현장 데이터를 시각화하고 간단한 제어 명령을 내리는 사례가 증가하고 있다.53</p>
<h4>4.2.2 실시간 제어의 한계와 과제</h4>
<p>하지만 HMI로서의 역할과 달리, 로봇 팔의 정밀 제어나 고속 생산 라인의 동기화와 같이 엄격한 시간 제약이 따르는 실시간 제어 로직을 표준 안드로이드에서 직접 수행하는 것은 매우 위험하다.54 앞서 분석한 커널 스케줄러의 비결정성과 ART의 GC 문제로 인해, 표준 안드로이드는 산업 제어에 요구되는 안전성과 신뢰성을 보장할 수 없기 때문이다.54</p>
<h4>4.2.3 솔루션: 듀얼 커널/하이브리드 접근법</h4>
<p>이 문제를 해결하기 위해, 하이퍼바이저와 유사한 개념을 커널 수준에서 구현하려는 연구들이 진행되었다. 대표적인 예가 Xenomai나 RTDroid와 같은 듀얼 커널(dual-kernel) 접근법이다.54 이 방식에서는 실시간성이 요구되는 제어 태스크는 Xenomai와 같은 실시간 마이크로커널(또는 나노커널)의 제어 하에 실행되고, 비실시간 작업인 HMI 애플리케이션은 표준 리눅스 커널(안드로이드) 위에서 실행된다. 두 커널은 하드웨어 인터럽트를 공유하며, 실시간 커널이 더 높은 우선순위를 가져 모든 인터럽트를 먼저 처리하고, 실시간 작업과 관련 없는 인터럽트만 리눅스 커널로 전달하는 방식으로 동작한다. 이는 안드로이드의 풍부한 생태계를 활용하면서도 경성 실시간 제어를 동시에 달성하려는 하이브리드 접근법이다.</p>
<h3>4.3  프로페셔널 오디오: 저지연 오디오 경로 확보</h3>
<p>프로페셔널 오디오 분야는 경성 실시간 수준의 엄격함은 아니지만, 수십 밀리초(ms) 이하의 매우 낮은 지연 시간이 서비스 품질을 결정하는 대표적인 연성 실시간 영역이다.</p>
<h4>4.3.1 저지연의 중요성</h4>
<p>디지털 오디오 워크스테이션(DAW), 가상 악기, 실시간 이펙터, 네트워크 오디오 스트리밍(예: SonoBus 55)과 같은 프로 오디오 애플리케이션에서는 사용자의 입력(예: 키보드 연주)과 시스템의 출력(소리) 사이의 지연 시간, 즉 왕복 지연 시간(round-trip latency)이 인지 한계인 수십 밀리초 이하로 유지되어야 자연스러운 작업이 가능하다.</p>
<h4>4.3.2 <code>android.hardware.audio.pro</code> 기능</h4>
<p>이러한 요구사항을 충족시키기 위해, 안드로이드는 호환성 정의 문서(Compatibility Definition Document, CDD)를 통해 <code>android.hardware.audio.pro</code>라는 하드웨어 기능 플래그를 정의하고 있다. 이 플래그가 선언된 기기는 20ms 이하의 연속적인 왕복 오디오 지연 시간을 보장해야 한다.56 또한, <code>android.hardware.audio.low_latency</code> 플래그는 45ms 이하의 출력 지연 시간을 보장한다.56 앱 개발자는 런타임에 이 플래그들을 확인하여, 기기가 프로 오디오 작업을 수행할 수 있는지를 판별하고 저지연 오디오 경로를 활성화하는 등의 최적화를 수행할 수 있다.56</p>
<h4>4.3.3 프로그래밍 기법</h4>
<p><code>audio.pro</code> 기능을 지원하는 하드웨어라 할지라도, 저지연 성능을 최대한 활용하기 위해서는 애플리케이션 수준에서 세심한 프로그래밍이 필수적이다. 핵심 기법은 다음과 같다.56</p>
<ul>
<li><strong>NDK 사용:</strong> 오디오 처리 로직의 핵심은 GC의 영향을 받지 않는 C/C++ 코드로 작성한다.</li>
<li><strong>저지연 경로(Fast Track) 사용:</strong> 안드로이드 오디오 프레임워크는 최소한의 신호 처리만을 거치는 ’Fast Track’이라는 저지연 출력 경로를 제공한다. 이 경로를 사용하기 위해서는 이퀄라이저나 베이스 부스트와 같은 추가적인 오디오 이펙트를 사용하지 않아야 한다.</li>
<li><strong>최적의 오디오 파라미터 사용:</strong> <code>AudioManager</code> API를 통해 기기의 네이티브 샘플 레이트(native sample rate)와 버퍼 사이즈(buffer size)를 쿼리하여, 오디오 스트림을 생성할 때 이 값들을 사용해야 불필요한 리샘플링이나 버퍼 변환으로 인한 지연을 피할 수 있다.</li>
<li><strong><code>VOICE_RECOGNITION</code> 프리셋 활용:</strong> 녹음 시 <code>VOICE_RECOGNITION</code> 오디오 소스 프리셋을 사용하면, 에코 캔슬레이션이나 노이즈 감소와 같은 내장 신호 처리 알고리즘을 우회하여 가장 낮은 입력 지연 시간을 얻을 수 있다.</li>
</ul>
<p>이처럼 각 산업 분야는 안드로이드를 활용하되, 실시간 요구사항을 충족시키기 위해 하이퍼바이저, 듀얼 커널, NDK 등 다양한 격리 및 최적화 기법을 적용하고 있다. 이는 안드로이드가 단일 실시간 OS로 진화하기보다는, 다양한 실시간 솔루션과 결합하여 유연한 혼합 임계 플랫폼의 일부로 기능하는 방향으로 발전하고 있음을 보여준다.</p>
<h2>5.  실시간 성능 측정 및 벤치마킹</h2>
<p>안드로이드 시스템의 실시간 성능을 평가하고 개선하기 위해서는 적절한 도구를 사용하여 성능을 정량적으로 측정하는 것이 필수적이다. 이때, 일반적인 성능 벤치마크와 실시간 벤치마크의 근본적인 차이를 이해하는 것이 매우 중요하다. 일반 성능 벤치마크는 ’평균 처리량’을 측정하는 반면, 실시간 벤치마크는 ’최악 지연 시간’과 ’예측 가능성’을 측정한다.</p>
<h3>5.1  커널 스케줄링 지연 시간 측정: <code>cyclictest</code></h3>
<p><code>cyclictest</code>는 리눅스 기반 시스템의 실시간 성능, 특히 커널 스케줄링 지연 시간을 측정하는 데 사용되는 업계 표준 벤치마크 도구다.58</p>
<h4>5.1.1 작동 원리</h4>
<p><code>cyclictest</code>의 작동 원리는 비교적 간단하다. 먼저, 측정을 위한 하나 이상의 실시간 스레드를 생성하고 이들에게 높은 실시간 우선순위(예: <code>SCHED_FIFO</code>)를 부여한다. 그 후, 각 스레드는 고정밀 타이머(<code>clock_nanosleep</code>)를 사용하여 정확히 특정 시간(예: 200 마이크로초) 후에 깨어나도록 설정하고 잠든다. 스레드가 실제로 깨어났을 때, 현재 시각을 다시 측정하여 예정된 기상 시각과 실제 기상 시각 사이의 차이를 계산한다. 이 차이가 바로 ’스케줄링 지연 시간’이다.58 이 과정은 수백만 번 반복되며, 이 지연 시간 값들을 통계적으로 분석하여 시스템의 실시간 응답성을 평가한다. 이 지연은 커널의 비선점 구간, 다른 인터럽트의 방해, 스케줄러 자체의 오버헤드 등 다양한 원인에 의해 발생한다.60</p>
<h4>5.1.2 실행 및 옵션</h4>
<p><code>cyclictest</code>로 의미 있는 결과를 얻기 위해서는 신중한 옵션 설정이 필요하다. 일반적인 SMP(Symmetric Multi-Processing) 실시간 시스템 테스트를 위한 권장 명령은 다음과 같다.58</p>
<pre><code># cyclictest --mlockall --smp --priority=80 --interval=200 --distance=0
</code></pre>
<ul>
<li><code>--mlockall</code>: 테스트 프로그램의 메모리를 물리 RAM에 고정시켜 페이징으로 인한 지연을 방지한다.</li>
<li><code>--smp</code>: 멀티코어 시스템에서 모든 CPU를 대상으로 테스트를 실행하고, 코어 간 지연 시간도 고려한다.</li>
<li><code>--priority=80</code>: 테스트 스레드에 높은 실시간 우선순위(1-99 범위)를 부여한다. <code>PREEMPT_RT</code> 커널에서는 대부분의 커널 스레드와 IRQ 스레드가 우선순위 50 근처에서 실행되므로, 이보다 높은 우선순위를 설정해야 정확한 측정이 가능하다.61</li>
<li><code>--interval=200</code>: 스레드의 기상 주기를 200 마이크로초로 설정한다.</li>
<li><code>--distance=0</code>: SMP 시스템에서 타이머와 스레드가 다른 코어에서 실행될 때 발생하는 지연 시간 측정을 위한 옵션이다.</li>
</ul>
<h4>5.1.3 결과 해석</h4>
<p><code>cyclictest</code> 결과에서 가장 주목해야 할 지표는 평균(Avg) 지연 시간이 아니라 최댓값(Max) 지연 시간이다.58 경성 실시간 시스템의 성능은 평균적인 응답 시간이 아니라, 최악의 경우에도 데드라인을 준수할 수 있는지에 의해 결정되기 때문이다. 따라서 <code>Max</code> 값이 시스템이 보장할 수 있는 최악 지연 시간(worst-case latency)의 근사치로 해석될 수 있다.62 또한, 결과의 히스토그램을 분석하면 지연 시간의 분포를 시각적으로 확인할 수 있어, 시스템의 지터(jitter) 경향성을 파악하는 데 큰 도움이 된다.60</p>
<h3>5.2  <code>PREEMPT_RT</code> 적용 전후 성능 비교 분석</h3>
<p>다수의 학술 연구 및 기술 문서에서 <code>cyclictest</code>를 사용하여 <code>PREEMPT_RT</code> 패치를 적용한 리눅스 커널과 표준 리눅스 커널의 실시간 성능을 비교 분석했다.59</p>
<h4>5.2.1 벤치마크 연구 사례</h4>
<p>이러한 연구들은 ARM 기반 임베디드 보드나 x86 서버 등 다양한 하드웨어 플랫폼에서 시스템에 부하(CPU, 메모리, 네트워크 I/O 등)를 가하면서 <code>cyclictest</code>를 실행하여, 각 커널의 지연 시간 통계를 수집하는 방식으로 진행된다.17</p>
<h4>5.2.2 결과 요약</h4>
<p>결과는 거의 모든 경우에 일관되게 나타난다. <code>PREEMPT_RT</code> 커널은 표준 커널에 비해 최악 지연 시간(Max)과 평균 지연 시간(Avg)을 수십 배에서 수백 배까지 현저하게 감소시킨다.62 예를 들어, 표준 커널에서 수 밀리초(ms)에 달했던 최악 지연 시간이 <code>PREEMPT_RT</code> 커널에서는 수십 마이크로초(µs) 수준으로 줄어드는 것을 확인할 수 있다. 이는 <code>PREEMPT_RT</code>가 커널 내 비선점 구간을 최소화하고 인터럽트 처리를 스케줄링 가능하게 만들어, 고우선순위 태스크가 방해받는 시간을 극적으로 줄였기 때문이다. 지연 시간의 표준 편차 역시 크게 감소하여, 예측 가능하고 안정적인 시스템 응답(낮은 지터)을 보장함을 보여준다.</p>
<h3>5.3  애플리케이션 수준의 벤치마킹 및 프로파일링</h3>
<p>커널 수준의 지연 시간 측정과 별개로, 안드로이드 애플리케이션 자체의 성능 병목을 분석하기 위한 도구들도 존재한다.</p>
<h4>5.3.1 Android Profiler</h4>
<p>Android Studio에 내장된 프로파일러는 개발자가 앱의 CPU 사용량, 메모리 할당, 네트워크 트래픽 등을 실시간으로 모니터링할 수 있게 해준다.14 특히 CPU 프로파일러의 시스템 트레이스(System Trace) 기능은 UI 스레드(메인 스레드)의 작업을 추적하여, UI 버벅거림(jank)을 유발하는 긴 작업이나 불필요한 지연을 시각적으로 식별하는 데 매우 유용하다.63</p>
<h4>5.3.2 Macrobenchmark/Microbenchmark</h4>
<p>안드로이드 제트팩(Jetpack)의 벤치마킹 라이브러리는 두 가지 유형의 테스트를 제공한다.64</p>
<ul>
<li><strong>Macrobenchmark:</strong> 앱 시작 시간, 리스트 스크롤 성능, 화면 전환 애니메이션과 같이 사용자가 직접 체감하는 거시적인 성능을 측정한다.</li>
<li><strong>Microbenchmark:</strong> 특정 함수나 알고리즘의 실행 시간을 반복적으로 측정하여 CPU 연산 성능을 미시적으로 분석한다. 이는 특정 코드의 최적화 효과를 검증하는 데 유용하다.</li>
</ul>
<h4>5.3.3 범용 벤치마크 앱</h4>
<p>3DMark, Geekbench, AnTuTu, PassMark와 같은 상용 벤치마크 애플리케이션들은 주로 CPU와 GPU의 연산 능력, 메모리 대역폭, 스토리지 속도 등 시스템의 전반적인 처리 성능(throughput)을 측정하여 점수로 환산한다.65 이러한 벤치마크들은 서로 다른 기기의 일반적인 성능을 비교하는 데는 유용하지만, 스케줄링 지연 시간이나 지터와 같은 실시간 결정성을 직접 측정하지는 않는다.</p>
<p>이처럼, 시스템의 실시간 성능을 올바르게 평가하기 위해서는 목적에 맞는 도구를 선택하는 것이 결정적이다. Geekbench 점수가 높은 시스템이 <code>cyclictest</code>에서는 높은 지연 시간을 보일 수 있으며, 이는 해당 시스템이 평균 처리량은 높지만 예측 가능성은 낮다는 것을 의미한다. 따라서 실시간 시스템 아키텍처를 결정할 때는 <code>cyclictest</code>와 같은 지연 시간 측정 도구를 통한 분석이 반드시 선행되어야 한다.</p>
<h2>6.  결론 및 종합적 고찰</h2>
<p>본 안내서는 안드로이드 플랫폼의 실시간 처리 성능을 다각도에서 심층적으로 분석했다. 분석 결과, 표준 안드로이드는 범용 운영체제로서의 설계 철학으로 인해 태생적으로 경성 실시간 요구사항을 충족하기 어렵다는 점이 명확해졌다. 커널 수준에서는 공정성 위주의 스케줄러와 비선점 구간이, 런타임 수준에서는 가비지 컬렉션으로 인한 실행 중단이 예측 가능성을 저해하는 핵심적인 병목으로 작용한다.</p>
<p>이러한 한계를 극복하기 위해 <code>PREEMPT_RT</code> 커널, 하이퍼바이저, 그리고 NDK 기반 최적화라는 세 가지 주요 아키텍처 접근법이 발전해왔다. 이들은 각각 다른 수준의 실시간 보장, 복잡성, 그리고 비용을 가지며, 특정 산업 분야의 요구사항에 맞춰 선택적으로 혹은 조합하여 사용되고 있다. 자동차 산업에서는 안전을 위해 하이퍼바이저를 통한 완전한 격리가, 산업 제어에서는 <code>PREEMPT_RT</code>나 듀얼 커널을 통한 경성 실시간 보장이, 프로 오디오 분야에서는 NDK를 통한 연성 실시간 최적화가 주된 해결책으로 자리 잡고 있다.</p>
<h3>6.1  접근법별 장단점 및 적용 시나리오 요약</h3>
<p>세 가지 핵심 접근법의 특성을 종합적으로 비교하면 다음과 같다. 이 표는 시스템 아키텍트가 특정 프로젝트의 요구사항에 가장 적합한 기술적 경로를 선택하는 데 있어 전략적인 의사결정 프레임워크를 제공한다.</p>
<table><thead><tr><th><strong>항목 (Criteria)</strong></th><th><strong>접근법 1: PREEMPT_RT 커널</strong></th><th><strong>접근법 2: 하이퍼바이저</strong></th><th><strong>접근법 3: NDK 및 스레딩</strong></th></tr></thead><tbody>
<tr><td><strong>실시간 보장 수준</strong></td><td>경성/확고한 실시간 (Hard/Firm)</td><td>경성 실시간 (Hard)</td><td>연성 실시간 (Soft)</td></tr>
<tr><td><strong>구현 복잡도</strong></td><td>중간 (커널 재컴파일 및 설정 필요)</td><td>높음 (시스템 아키텍처 설계, BSP 수정)</td><td>낮음 (애플리케이션 수준 코드 수정)</td></tr>
<tr><td><strong>성능 오버헤드</strong></td><td>처리량 약간 감소 33</td><td>중간 (가상화 오버헤드, I/O 에뮬레이션)</td><td>낮음 (JNI 호출 오버헤드 최소화 필요)</td></tr>
<tr><td><strong>격리 수준</strong></td><td>없음 (단일 커널)</td><td>매우 높음 (HW 강제 격리)</td><td>낮음 (프로세스 수준 격리)</td></tr>
<tr><td><strong>적합한 사용 사례</strong></td><td>산업용 로봇, 데이터 수집 장비</td><td>자동차, 항공, 의료 등 안전 필수 시스템</td><td>프로 오디오, 고성능 게임, 실시간 통신</td></tr>
</tbody></table>
<p>이 표는 각 접근법이 단순한 기술적 대안이 아니라, 근본적으로 다른 문제들을 해결하기 위한 도구임을 명확히 보여준다. 연성 실시간이 필요한 단일 앱의 성능 개선에는 NDK가 가장 비용 효율적인 해법이다. 시스템 전반에 걸쳐 확고한 실시간 보장이 필요하지만 안전 필수 수준의 격리가 요구되지 않는 경우(예: 산업 자동화)에는 <code>PREEMPT_RT</code>가 강력한 대안이 될 수 있다. 마지막으로, 단일 실패 지점도 허용되지 않는 안전 필수 혼합 임계 시스템(예: 자동차 콕핏)에서는 하이퍼바이저가 유일하고 가장 신뢰할 수 있는 아키텍처다.</p>
<h3>6.2  미래 안드로이드 플랫폼의 실시간 성능 발전 방향성</h3>
<p>안드로이드의 실시간 처리 능력은 앞으로도 계속해서 진화할 것이며, 그 방향성은 다음과 같이 예측할 수 있다.</p>
<ul>
<li><strong><code>PREEMPT_RT</code> 메인라인화의 영향:</strong> 20년 만에 <code>PREEMPT_RT</code>가 리눅스 커널 메인라인에 통합된 것은 가장 중요한 변화다.34 이는 안드로이드 OEM들이 별도의 복잡한 패치 관리 없이도 실시간 커널을 손쉽게 채택할 수 있는 길을 열었다. 향후 구글이 <code>PREEMPT_RT</code>를 활성화한 공식 안드로이드 커널 빌드를 제공하거나, 안드로이드 공용 커널(Android Common Kernel)의 일부로 통합할 가능성도 있다. 이는 하이퍼바이저와 같은 무거운 솔루션 없이도 더 넓은 범위의 산업 및 임베디드 시장에서 안드로이드가 실시간 플랫폼으로 활용될 수 있는 기반을 마련할 것이다.</li>
<li><strong>가상화 기술의 진화:</strong> 현재 안드로이드의 pKVM은 주로 보안 강화를 위한 목적으로 사용되고 있다.41 하지만 이 기술은 향후 실시간성 보장을 위한 목적으로 확장될 잠재력을 가지고 있다. 안드로이드 가상화 프레임워크(AVF)가 발전함에 따라, 신뢰할 수 있는 경량 RTOS를 안드로이드와 함께 하나의 VM으로 안전하게 실행하고, 두 OS 간의 저지연 통신을 보장하는 표준화된 방식이 등장할 수 있다.42 이는 현재의 상용 하이퍼바이저 솔루션을 대체하거나 보완하는 더 가볍고 통합된 형태의 혼합 임계 시스템으로 이어질 수 있다.</li>
<li><strong>하드웨어 가속의 역할:</strong> SoC(System-on-a-Chip) 제조사들이 실시간 처리를 위한 전용 하드웨어 지원을 강화하는 추세다. 예를 들어, ARM의 Cortex-R 시리즈와 같은 실시간 전용 코어를 애플리케이션 프로세서인 Cortex-A 시리즈와 함께 SoC에 통합하고, 이들 간의 통신을 위한 저지연 인터커넥트 패브릭을 제공하는 것이다. 미래의 안드로이드는 이러한 이기종 컴퓨팅(heterogeneous computing) 아키텍처를 인식하고, 실시간 태스크를 자동으로 전용 RT 코어에 오프로드하는 표준 API를 제공하는 방향으로 발전할 수 있다.</li>
</ul>
<p>궁극적으로, 미래의 안드로이드는 단일 운영체제가 모든 실시간 요구사항을 처리하는 ’만능 실시간 OS’가 되기보다는, 다양한 수준의 실시간 요구에 유연하게 대응하는 ’혼합 임계 플랫폼’으로 진화할 것이다. <code>PREEMPT_RT</code>로 강화된 커널은 시스템 전반에 견고한 실시간 기반을 제공하고, 하이퍼바이저는 최고 수준의 안전과 격리를 보장하며, NDK는 애플리케이션 개발자에게 저지연 구현을 위한 직접적인 도구를 제공하는 다층적 솔루션이 안드로이드 생태계의 표준으로 자리 잡을 것이다. 이러한 진화를 통해 안드로이드는 스마트폰을 넘어 자동차, 산업 자동화, 의료, 로보틱스 등 더욱 다양한 임베디드 시스템 영역에서 핵심적인 플랫폼으로 그 영향력을 확장해 나갈 것으로 전망된다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>What Is A Real-Time Operating Systems (RTOS) | Wind River, https://www.windriver.com/solutions/learning/rtos</li>
<li>What is a Real-Time Operating System (RTOS)? | IBM, https://www.ibm.com/think/topics/real-time-operating-system</li>
<li>Real-time operating system - Wikipedia, https://en.wikipedia.org/wiki/Real-time_operating_system</li>
<li>Real-Time Operating Systems: A Comprehensive Overview | Lenovo US, https://www.lenovo.com/us/en/glossary/real-time-operating-system/</li>
<li>What Is a Real-Time System? - Intel, https://www.intel.com/content/www/us/en/learn/what-is-a-real-time-system.html</li>
<li>Addressing Latency and Jitter in Time-Critical Firmware Applications | by Lance Harvie, https://medium.com/@lanceharvieruntime/addressing-latency-and-jitter-in-time-critical-firmware-applications-b1a03172981a</li>
<li>www.suse.com, https://www.suse.com/c/what-is-a-real-time-operating-system/</li>
<li>Mastering Jitter in Real-Time Systems - Number Analytics, https://www.numberanalytics.com/blog/mastering-jitter-real-time-systems</li>
<li>Mastering Jitter in RTOS - Number Analytics, https://www.numberanalytics.com/blog/mastering-jitter-in-rtos</li>
<li>Features of Hard Real Time Determinism - IntervalZero, https://www.intervalzero.com/features-of-hard-real-time-determinism/</li>
<li>Real Time Operating System (RTOS) - GeeksforGeeks, https://www.geeksforgeeks.org/operating-systems/real-time-operating-system-rtos/</li>
<li>General RTOS Concepts - TI Developer Zone, https://dev.ti.com/tirex/explore/node?node=ANdU1j-Zr4psEgM09wv25g__BSEc4rl__LATEST</li>
<li>Real time kernel support in Android - Google Groups, https://groups.google.com/g/android-kernel/c/-_f5TYD16yw</li>
<li>Most Common Android Development Challenges and How to Overcome Them - MoldStud, https://moldstud.com/articles/p-most-common-android-development-challenges-and-how-to-overcome-them</li>
<li>Real-Time group scheduling — The Linux Kernel documentation, https://docs.kernel.org/scheduler/sched-rt-group.html</li>
<li>Fixing Real-Time Scheduler Throttling in the Linux Kernel - Joel Fernandes, Google, https://www.youtube.com/watch?v=FQsZjFFQdto</li>
<li>Latency Comparisons for Linux-RT - RocketBoards.org, https://www.rocketboards.org/foswiki/pub/Documentation/AlteraSoCLTSIRTKernel/ELC-Linux-RT.pdf</li>
<li>The Linux Kernel’s Scheduler Apparently Causing Issues For Google Stadia Game Developers - Reddit, https://www.reddit.com/r/Stadia/comments/eipgu2/the_linux_kernels_scheduler_apparently_causing/</li>
<li>Overview of memory management | App quality - Android Developers, https://developer.android.com/topic/performance/memory-overview</li>
<li>Garbage collection (computer science) - Wikipedia, https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</li>
<li>Garbage Collection Workload for Android* A New Way to Measure Android Garbage Collection Performance, https://www.intel.cn/content/dam/develop/external/us/en/documents/garbage-collection-workload-for-android-621779.pdf</li>
<li>Collecting the Garbage: A brief history of GC over Android versions - ProAndroidDev, https://proandroiddev.com/collecting-the-garbage-a-brief-history-of-gc-over-android-versions-f7f5583e433c</li>
<li>Debug ART garbage collection - Android Open Source Project, https://source.android.com/docs/core/runtime/gc-debug</li>
<li>Android 8.0 ART improvements | Android Open Source Project, https://source.android.com/docs/core/runtime/improvements</li>
<li>The Revolution in Android Performance: The Enhanced Android Runtime (ART) | by Christian Baghai, https://christianbaghai.medium.com/the-revolution-in-android-performance-the-enhanced-android-runtime-art-9dc24434f59c</li>
<li>Configure ART - Android Open Source Project, https://source.android.com/docs/core/runtime/configure</li>
<li>Android Internals: ART vs DVM deep dive | by Ayusch Jain | AndroidPub - Medium, https://medium.com/android-news/android-internals-art-vs-dvm-deep-dive-def34cf664d7</li>
<li>Overview of measuring app performance | App quality - Android Developers, https://developer.android.com/topic/performance/measuring-performance</li>
<li>What is real-time Linux? Part III - Ubuntu, https://ubuntu.com/blog/what-is-real-time-linux-part-iii</li>
<li>what is RT_PREEMPT? how is it different from preempt rt ?does these mean same real time patch to linux? [closed] - Stack Overflow, https://stackoverflow.com/questions/26311757/what-is-rt-preempt-how-is-it-different-from-preempt-rt-does-these-mean-same-re</li>
<li>Technical details of the real-time preemption - Wiki, https://wiki.linuxfoundation.org/realtime/documentation/technical_details/start</li>
<li>The Real-Time Linux Kernel: A Survey on PREEMPT_RT, https://re.public.polimi.it/retrieve/e0c31c12-9844-4599-e053-1705fe0aef77/11311-1076057_Reghenzani.pdf</li>
<li>linux-image-rt now that real-time patches have been merged into the kernel : r/debian, https://www.reddit.com/r/debian/comments/1j51d7t/linuximagert_now_that_realtime_patches_have_been/</li>
<li>PREEMPT_RT: Real Time Linux is finally part of the Linux Kernel - Managed Server, https://www.managedserver.eu/preempt_rt-real-time-linux-and-finally-part-of-the-linux-kernel/</li>
<li>PREEMPT_RT - Wikipedia, https://en.wikipedia.org/wiki/PREEMPT_RT</li>
<li>The realtime preemption end game — for real this time - LWN.net, https://lwn.net/Articles/989212/</li>
<li>Linux Kernel Mainline Real-Time History, Support and Experience Based on Robotic and Automotive Projects - FOSDEM 2025, https://fosdem.org/2025/schedule/event/fosdem-2025-5411-linux-kernel-mainline-real-time-history-support-and-experience-based-on-robotic-and-automotive-projects/</li>
<li>QNX Hypervisor | Embedded Virtualization, https://blackberry.qnx.com/en/products/foundation-software/qnx-hypervisor</li>
<li>INTEGRITY Multivisor - Green Hills Software, https://www.ghs.com/products/rtos/integrity_virtualization.html</li>
<li>Green Hills: Secure Hypervisor For Safety Integrated Cockpits - NXP Community, https://community.nxp.com/t5/Connects-Training-Material/Green-Hills-Secure-Hypervisor-For-Safety-Integrated-Cockpits/ta-p/1126145</li>
<li>AVF architecture | Android Open Source Project, https://source.android.com/docs/core/virtualization/architecture</li>
<li>Gunyah Hypervisor Software - Supporting Protected VMs in Android Virtualization Framework - Qualcomm, https://www.qualcomm.com/developer/blog/2024/01/gunyah-hypervisor-software-supporting-protected-vms-android-virtualization-framework</li>
<li>Get started with the NDK - Android Developers, https://developer.android.com/ndk/guides</li>
<li>Android NDK: Using C/C++ Native Libraries to Write Android Apps | by JetRuby Agency, https://expertise.jetruby.com/android-ndk-using-c-c-native-libraries-to-write-android-apps-21550cdd86a</li>
<li>Mastering the NDK Proven Strategies for Success - MoldStud, https://moldstud.com/articles/p-mastering-the-ndk-proven-strategies-for-success</li>
<li>Thread Priority in Android - GeeksforGeeks, https://www.geeksforgeeks.org/android/thread-priority-in-android/</li>
<li>Better performance for a Service by setting the Thread with a higher priority? : r/androiddev, https://www.reddit.com/r/androiddev/comments/1aqqaf6/better_performance_for_a_service_by_setting_the/</li>
<li>Avoid priority inversion - Android Open Source Project, https://source.android.com/docs/core/audio/avoiding_pi</li>
<li>What is Android Automotive? | Android Open Source Project, https://source.android.com/docs/automotive/start/what_automotive</li>
<li>Android Automotive - Wikipedia, https://en.wikipedia.org/wiki/Android_Automotive</li>
<li>Control of industrial systems using Android-based devices | Request PDF - ResearchGate, https://www.researchgate.net/publication/261261767_Control_of_industrial_systems_using_Android-based_devices</li>
<li>Supervisory Monitoring and Control Solution on Android Mobile Devices for the Water Industry 4.0 - MDPI, https://www.mdpi.com/2071-1050/15/22/16022</li>
<li>Case Studies on the Use of Remote Monitoring and Control Systems to Solve Problems Efficiently | SCS Engineers, https://www.scsengineers.com/wp-content/uploads/2017/04/Case-Studies-on-the-Use-of-Remote-Monitoring-and-Control-Systems-to-Solve-Problems-Efficiently.pdf</li>
<li>Safe and Policy Oriented Secure Android-Based Industrial Embedded Control System, https://www.mdpi.com/2076-3417/10/8/2796</li>
<li>SonoBus, https://sonobus.net/</li>
<li>Audio latency | Android NDK | Android Developers, https://developer.android.com/ndk/guides/audio/audio-latency</li>
<li>How To Fix Audio Latency On My Android? - The Hardware Hub - YouTube, https://www.youtube.com/watch?v=heyJ_q0WYzs</li>
<li>realtime:documentation:howto:tools:cyclictest:start [Wiki], https://wiki.linuxfoundation.org/realtime/documentation/howto/tools/cyclictest/start</li>
<li>A Comparison of Scheduling Latency in Linux, PREEMPT RT, and LITMUSRT - People at MPI-SWS, https://people.mpi-sws.org/~bbb/papers/pdf/ospert13.pdf</li>
<li>Using and Understanding the Real-Time Cyclictest Benchmark – Frank Rowand (Sony), https://mindlinux.wordpress.com/2013/10/25/using-and-understanding-the-real-time-cyclictest-benchmark-frank-rowand-sony/</li>
<li>Cyclictest for RT patched Linux Kernel - Stack Overflow, https://stackoverflow.com/questions/17812548/cyclictest-for-rt-patched-linux-kernel</li>
<li>Performance Assessment of Linux Kernels with PREEMPT_RT on ARM-Based Embedded Devices - ResearchGate, https://www.researchgate.net/publication/352041533_Performance_Assessment_of_Linux_Kernels_with_PREEMPT_RT_on_ARM-Based_Embedded_Devices</li>
<li>How to detect and solve android application performance issues? - Stack Overflow, https://stackoverflow.com/questions/67107834/how-to-detect-and-solve-android-application-performance-issues</li>
<li>Benchmark your app | App quality - Android Developers, https://developer.android.com/topic/performance/benchmarking/benchmarking-overview</li>
<li>3DMark Android Benchmark, https://benchmarks.ul.com/3dmark-android</li>
<li>Geekbench 6 - Apps on Google Play, https://play.google.com/store/apps/details?id=com.primatelabs.geekbench6</li>
<li>Android Benchmarks, https://www.androidbenchmark.net/</li>
<li>Ranking - Smartphone Performance - AnTuTu Benchmark - Know Your Android Better, https://www.antutu.com/en/ranking/rank11.htm</li>
<li>PassMark PerformanceTest Mobile - Android and Apple iPhone Benchmark Software, https://www.passmark.com/products/pt_mobile/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>