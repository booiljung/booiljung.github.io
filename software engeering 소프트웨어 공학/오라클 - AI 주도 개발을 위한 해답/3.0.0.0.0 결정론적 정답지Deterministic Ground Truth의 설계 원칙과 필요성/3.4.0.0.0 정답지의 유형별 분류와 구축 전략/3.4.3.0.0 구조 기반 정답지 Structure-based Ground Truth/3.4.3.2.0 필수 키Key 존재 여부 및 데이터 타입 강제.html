<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.4.3.2 필수 키(Key) 존재 여부 및 데이터 타입 강제</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.4.3.2 필수 키(Key) 존재 여부 및 데이터 타입 강제</h1>
                    <nav class="breadcrumbs"><a href="../../../../../index.html">Home</a> / <a href="../../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../../index.html">Chapter 3. 결정론적 정답지(Deterministic Ground Truth)의 설계 원칙과 필요성</a> / <a href="../index.html">3.4 정답지의 유형별 분류와 구축 전략</a> / <a href="index.html">3.4.3 구조 기반 정답지 (Structure-based Ground Truth)</a> / <span>3.4.3.2 필수 키(Key) 존재 여부 및 데이터 타입 강제</span></nav>
                </div>
            </header>
            <article>
                <h1>3.4.3.2 필수 키(Key) 존재 여부 및 데이터 타입 강제</h1>
<p>대규모 언어 모델(LLM)을 엔터프라이즈 소프트웨어 아키텍처의 핵심 컴포넌트로 통합할 때 직면하는 가장 치명적이고 빈번한 장벽은 모델 출력의 비결정성(Nondeterminism)이다. 자연어 처리, 문서 요약, 창의적 텍스트 생성과 같은 전통적인 인공지능 작업에서는 모델의 확률론적 변동성이 유연성과 창의성이라는 긍정적인 지표로 해석될 수 있다. 그러나 생성된 데이터가 다운스트림(Downstream) 애플리케이션, 관계형 데이터베이스, 외부 API, 또는 다른 자율 에이전트(Autonomous Agent)에 의해 파싱되고 처리되어야 하는 기계 대 기계(Machine-to-Machine) 통신 환경에서는 이러한 변동성이 곧바로 치명적인 시스템 장애를 유발한다.</p>
<p>결정론적 소프트웨어 환경은 입력 데이터가 사전에 정의된 엄격한 스키마(Schema)를 완벽하게 준수할 것을 요구한다. 이러한 맥락에서 JSON Schema나 Pydantic 모델과 같은 구조화된 포맷을 활용한 데이터 명세는 AI 소프트웨어 개발에서 선택이 아닌 필수가 되었다. 그러나 단순히 프롬프트 엔지니어링을 통해 모델에게 특정 포맷을 지시하는 것만으로는 충분한 신뢰성을 확보할 수 없다. 언어 모델은 빈번하게 필수적인 키(Key)를 누락하거나, 요구되는 데이터 타입(Data Type)을 위반하며, 심지어 존재하지 않는 임의의 필드를 창조해내는 구조적 환각(Structural Hallucination)을 발생시키기 때문이다.</p>
<p>이 절에서는 AI 소프트웨어 개발 환경에서 결정론적 정답지를 제공하는 오라클(Oracle)의 개념을 깊이 있게 차용하여, LLM의 구조화된 출력(Structured Output)에서 필수 키의 존재 여부를 100% 보장하고 데이터 타입을 엄격하게 강제하는 이론적 배경, 기술적 구현 매커니즘, 평가 지표, 그리고 실무적인 프레임워크 적용 전략을 심도 있게 해부한다.</p>
<h2>1.  구조적 환각(Structural Hallucination)의 해부학</h2>
<p>언어 모델의 출력에서 발생하는 환각(Hallucination)은 대체로 모델이 사실과 다르거나 근거가 없는 정보를 생성하는 ’사실적 환각(Factual Hallucination)’에 초점이 맞춰져 연구되어 왔다. 그러나 구조화된 데이터를 추출하거나 생성하는 태스크에서는 데이터의 내용적 진실성 못지않게 데이터를 담고 있는 컨테이너의 형태, 즉 ’구조적 환각(Structural Hallucination)’이 실질적인 런타임 에러의 주범이 된다.</p>
<p>언어 모델은 본질적으로 통계적 확률 분포에 기반하여 다음 토큰(Next Token)을 예측하는 오토회귀(Autoregressive) 프로세스를 따른다. 훈련 데이터의 방대한 말뭉치 속에서 언어 모델은 JSON, XML, YAML과 같은 마크업 및 데이터 교환 포맷의 문법적 패턴을 학습하지만, 이는 어디까지나 확률적인 모방일 뿐 데이터 구조에 대한 결정론적 이해나 컴파일러 수준의 문법 검증 능력을 내재하고 있는 것은 아니다. 수학적 프레임워크로 살펴보면, 입력 프롬프트 <span class="math math-inline">x</span>와 출력 스키마 조건 <span class="math math-inline">f</span>가 주어졌을 때, 모델은 파라미터 <span class="math math-inline">\theta</span>에 기반하여 출력 <span class="math math-inline">y</span>에 대한 조건부 확률 <span class="math math-inline">P(y \vert x, f; \theta)</span>를 계산한다. 이 확률 분포 모델링 과정에서 모델이 구조적 제약 조건 <span class="math math-inline">f</span>보다 언어적 자연스러움이나 내부적인 어텐션(Attention) 가중치에 더 크게 영향을 받을 때 구조적 환각이 발현된다.</p>
<p>구조적 환각은 시스템 통합의 관점에서 크게 두 가지 치명적인 유형으로 분류되며, 각각의 원인과 결과는 엔터프라이즈 파이프라인에 심각한 타격을 입힌다.</p>
<h3>1.1  필수 키(Mandatory Key) 누락과 임의 속성 생성</h3>
<p>소프트웨어 모듈 간의 통신, 특히 RESTful API 통신이나 데이터베이스 트랜잭션에서는 특정 필드의 존재 자체가 시스템의 상태 전이를 결정하는 핵심 요소다. 그러나 언어 모델은 프롬프트에 명시된 필수 키를 누락하거나, 지시받지 않은 임의의 키(예: <code>notes</code>, <code>metadata</code>, <code>additional_info</code>)를 독단적으로 생성하는 경향을 보인다.</p>
<p>이러한 현상이 발생하는 근본적인 원인은 모델의 어텐션 메커니즘이 프롬프트 상단에 위치한 복잡한 스키마 정의보다 입력 텍스트의 구체적인 맥락(Context)이나 가장 최근에 생성된 토큰들에 과적합(Overfitting)되기 때문이다. 모델은 텍스트를 생성해 나가는 과정에서 “JSON 형식을 맞춰야 한다“는 지시사항의 가중치를 점차 망각하게 되며, 문맥상 자연스럽게 이어질 법한 키-값 쌍을 통계적으로 추론해버린다. 예를 들어, 사용자가 고객 불만 사항 텍스트를 입력하고 이를 파싱하여 <code>customer_id</code>, <code>complaint_category</code>, <code>urgency_level</code>이라는 세 개의 필수 키를 가진 JSON으로 출력하라고 지시했다고 가정하자. 만약 입력 텍스트에 고객 ID를 유추할 만한 정보가 전혀 없다면, 이상적인 시스템은 <code>customer_id</code>를 <code>null</code>로 반환하거나 에러를 발생시켜야 한다. 그러나 확률적 모델은 빈칸을 채우려는 경향성(Over-helpfulness)으로 인해 임의의 가짜 ID를 지어내거나, 아예 <code>customer_id</code> 키 자체를 결과 객체에서 삭제해버리는 선택을 한다. 이는 스키마 유효성 검사기에서 즉각적인 키 누락 에러(KeyError)를 발생시키며 전체 워크플로우를 중단시킨다.</p>
<h3>1.2  데이터 타입 불일치(Data Type Mismatch)와 포맷 붕괴</h3>
<p>데이터 타입 불일치는 구조적 환각 중에서도 디버깅이 극도로 까다롭고, 파서(Parser)를 무력화하며, 때로는 런타임 후반에 심각한 논리적 오류를 유발하는 현상이다. 언어 모델은 JSON 데이터를 생성할 때 특정 값의 의미(Semantics)는 훌륭하게 이해할지라도, 해당 값을 담는 컨테이너의 프로그래밍 언어적 타입(Type)을 일관되게 유지하는 데에는 큰 취약점을 가진다.</p>
<p>가장 빈번하게 관찰되는 사례는 문자열(String)과 숫자(Integer/Float), 그리고 불리언(Boolean) 타입 간의 혼동이다. JSON 스키마에서 특정 인물의 나이를 나타내는 <code>age</code> 필드를 정수형(<code>integer</code>)으로 명시적으로 요구했음에도 불구하고, 모델은 <code>"25"</code>와 같이 따옴표로 둘러싸인 문자열로 반환하는 경우가 잦다. 또한, 어떤 조건의 참/거짓을 나타내는 <code>is_active</code> 필드에 대해 <code>true</code> 또는 <code>false</code>라는 엄격한 불리언 리터럴 대신 <code>"yes"</code>, <code>"True"</code>, 심지어 <code>"1"</code>과 같은 변형된 형태를 출력하기도 한다.</p>
<p>이러한 현상의 기저에는 언어 모델의 토큰화(Tokenization) 방식과 임베딩 공간(Embedding Space)의 특성이 자리 잡고 있다. 모델의 인지 체계 내에서 <code>true</code>라는 토큰과 <code>"yes"</code>라는 토큰은 의미론적으로 매우 가까운 거리에 위치하며, 주어진 문맥 내에서 두 토큰의 등장 확률은 거의 유사하게 계산된다. 모델은 이 둘 사이의 ’프로그래밍 언어적 구문(Syntax) 차이’를 인간 개발자처럼 엄격하게 구분하지 못한다. 배열(Array)과 단일 객체(Object)의 혼동 역시 마찬가지다. 스키마에서 <code>attendees</code> 필드를 객체의 배열로 요구했으나, 모델이 단순히 쉼표로 구분된 문자열 하나(<code>"Sarah, John"</code>)를 반환하거나 문자열 배열(``)로 반환하는 현상도 널리 보고된다. 파이썬(Python)이나 자바스크립트(JavaScript)와 같은 동적 타입 언어 환경에서는 이러한 미세한 타입 위반이 JSON 파싱 단계에서는 통과되지만, 이후 데이터를 가공하거나 연산하는 단계에서 <code>TypeError</code>를 발생시키기 때문에 장애의 원인을 추적하는 데 막대한 개발 리소스가 낭비된다.</p>
<h2>2.  다중 에이전트 시스템과 프로덕션 환경에서의 파급 효과</h2>
<p>단순한 질의응답 시스템을 넘어, 다수의 LLM이 서로 협력하여 복잡한 과업을 수행하는 다중 에이전트 시스템(Multi-Agent System, MAS)이나 CI/CD 파이프라인과 결합된 프로덕션 환경에서 이러한 구조적 비결정성의 파급 효과는 기하급수적으로 증폭된다.</p>
<p>최근의 산업계 및 학계 연구에 따르면, 프로덕션 환경에 배포된 다중 에이전트 시스템은 41%에서 최대 86.7%에 이르는 높은 실패율을 보이며, 이들 실패의 상당수가 에이전트 간의 역할 오해, 작업 중복, 그리고 통신 프로토콜의 구조적 붕괴에서 기인한다. 사람들의 협업 과정에서 명확한 작업 지시서와 결과물 양식이 필요한 것처럼, 에이전트 간의 정보 교환에도 엄격하게 타입이 강제된 JSON과 같은 구조화된 메시지 버스가 필수적이다.</p>
<table><thead><tr><th><strong>에이전트 시스템의 실패 범주</strong></th><th><strong>구조적 불일치로 인한 세부 실패 모드 (Failure Modes)</strong></th><th><strong>시스템에 미치는 영향 및 결과</strong></th></tr></thead><tbody>
<tr><td><strong>작업 검증 (Task Verification) 실패</strong></td><td>오라클 부재로 인한 검증 누락 (No or Incomplete Verification), 부적절한 검증 기준 적용</td><td>불완전하거나 타입이 어긋난 데이터가 다음 에이전트로 전달되어 오염(Context Pollution)이 발생함.</td></tr>
<tr><td><strong>명세 및 시스템 설계 (Specification) 실패</strong></td><td>작업 명세 불복종 (Disobey Task Specification), 에이전트 역할 및 반환 타입 망각</td><td>에이전트가 예상된 JSON 구조 대신 자연어 서술을 반환하여 파이프라인의 직렬화(Serialization)를 붕괴시킴.</td></tr>
<tr><td><strong>에이전트 간 정렬 (Inter-Agent Misalignment) 실패</strong></td><td>추론-행동 불일치 (Reasoning-Action Mismatch), 타 에이전트의 구조화된 입력 무시</td><td>도구 호출(Tool Calling) 시 필수 매개변수를 누락하여 무한 재시도 루프(Infinite Retry Loop)에 빠지거나 API 할당량을 소진함.</td></tr>
</tbody></table>
<p>특히 도구 호출(Tool Use) 시나리오에서 필수 키 누락과 데이터 타입 불일치의 위험성은 극명하게 드러난다. 실제 고객 관계 관리(CRM) 시스템과 연동된 에이전트의 실패 사례를 살펴보면 그 심각성을 알 수 있다. 한 사용자가 “Sarah가 방금 계약서에 서명했어. Terminator 계정에 기록해 줘“라고 요청했을 때, LLM 기반 에이전트는 CRM의 <code>addInteraction</code> API를 호출하기 위해 페이로드를 생성한다. 이 API는 대상 계정을 식별하기 위해 <code>account_id</code>라는 필수 키를 요구하며, 이 값의 타입은 반드시 고유 식별자 문자열(UUID)이어야 한다. 그러나 에이전트는 사용자의 자연어 발화에만 의존하여 <code>account_id</code>의 값으로 <code>"Terminator"</code>라는 일반 문자열(Account Name)을 매핑하는 구조적 환각을 일으켰다. 나아가 참석자를 나타내는 <code>attendees</code> 배열에 객체(<code>) 대신 단순 문자열(</code>)을 할당하는 데이터 타입 불일치를 동시에 범했다.</p>
<p>그 결과 서버는 즉각적으로 “Account not found” 및 “Invalid data type“이라는 예외를 반환하며 작업을 거부했다. 비록 최신 에이전트 프레임워크들이 이러한 에러 메시지를 파싱하여 스스로 오류를 복구하려는 재시도(Retry) 로직을 갖추고 있지만, 이 과정에서 발생하는 레이턴시(Latency) 증가, 불필요한 토큰 소비, 그리고 연쇄적인 타임아웃(Cascading Timeouts)은 대규모 프로덕션 시스템의 가용성을 심각하게 위협한다. 자연어 이해(Natural Language Understanding) 능력은 완벽하더라도, 구조적 실행(Structured Execution)에서의 취약성은 시스템 전체의 붕괴로 이어진다.</p>
<p><img src="./3.4.3.2.0%20%ED%95%84%EC%88%98%20%ED%82%A4Key%20%EC%A1%B4%EC%9E%AC%20%EC%97%AC%EB%B6%80%20%EB%B0%8F%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20%EA%B0%95%EC%A0%9C.assets/image-20260222121044804.jpg" alt="image-20260222121044804" /></p>
<h2>3.  결정론적 정답지 기반의 검증 오라클(Deterministic Verification Oracle)의 도입</h2>
<p>확률론적 언어 모델의 한계를 극복하고 예측 가능한 소프트웨어 개발을 달성하기 위해, 아키텍처는 통제 불가능한 텍스트 생성 계층과 이를 검열하는 확고한 검증 계층으로 분리되어야 한다. 여기서 구조적 검증을 담당하는 핵심 컴포넌트가 바로 ’결정론적 검증 오라클(Deterministic Verification Oracle)’이다.</p>
<p>소프트웨어 공학의 테스트 이론에서 차용된 오라클(Oracle)의 개념은, 주어진 시스템의 출력이 올바른지 판별할 수 있는 절대적인 진리값(Ground Truth)의 원천을 의미한다. AI 모델의 맥락에서, 논리적이고 결정론적인 오라클은 확률의 지배를 받는 LLM의 생성 결과물을 검증하여 다음과 같은 역할을 수행한다.</p>
<ol>
<li><strong>확정적 참/거짓(Boolean) 판별:</strong> 오라클의 평가는 80%의 신뢰도나 확률적 근사치를 가지지 않는다. 생성된 JSON 객체 내에 <code>user_email</code>이라는 필수 키가 존재하는지, 해당 값의 타입이 정규식(Regex)을 만족하는 문자열인지는 오직 확정적인 참(True) 또는 거짓(False)으로만 판별된다.</li>
<li><strong>타입 안전성(Type-Safety)의 수학적 보장:</strong> 오라클은 생성된 페이로드가 마이크로서비스 또는 데이터베이스와 같은 다운스트림 시스템으로 전파되기 전에, 모든 데이터 필드가 스키마에서 요구하는 프로그래밍 언어 수준의 타입(<code>String</code>, <code>Integer</code>, <code>Float</code>, <code>Boolean</code>, <code>Array</code> 등)을 완벽히 충족함을 공식적으로 검증(Formal Verification)한다.</li>
<li><strong>오염의 차단과 롤백 매커니즘:</strong> 오라클은 유효하지 않은 출력을 발견하는 즉시 프로세스를 차단함으로써, 잘못된 포맷의 데이터가 후속 에이전트의 문맥을 오염(Context Pollution)시키거나 데이터베이스를 훼손하는 것을 방지하는 무결점 방화벽으로 기능한다.</li>
</ol>
<p>이러한 오라클을 실제 시스템에 구현하여 데이터 구조를 100% 강제하기 위해서는 단순한 프롬프트 엔지니어링의 영역을 벗어나야 한다. 프롬프트에 “반드시 JSON으로 출력할 것”, “키워드를 빼먹지 말 것“이라고 아무리 강조해도, 프롬프트 자체가 결국 확률적 임베딩 공간으로 투영되는 입력값일 뿐이므로 모델의 구조적 환각을 원천 차단할 수 없다. 따라서 모델의 추론(Inference) 단계 자체를 제어하거나 프레임워크 수준의 강제 매커니즘을 동원하는 세 가지 주요 전략이 산업계에서 활용되고 있다.</p>
<h2>4.  구조적 정합성을 보장하기 위한 3가지 강제화 전략</h2>
<p>현대 AI 소프트웨어 개발에서 LLM 출력의 필수 키 존재 여부와 데이터 타입을 강제하기 위해 도입되는 전략은 크게 시스템의 개입 시점에 따라 세 가지로 분류된다. 시스템 아키텍트는 요구되는 신뢰성(Reliability) 수준, 허용 가능한 지연 시간(Latency), 그리고 사용할 언어 모델의 인프라 통제 권한에 따라 최적의 전략을 선택해야 한다.</p>
<h3>4.1  사후 유효성 검사 및 피드백 루프 (Post-Generation Validation and Feedback Loop)</h3>
<p>가장 직관적이고 널리 채택되는 초기 접근 방식은 모델에게 텍스트 생성을 완전히 맡긴 후, 결과물을 애플리케이션 계층에서 파싱하여 사전에 정의된 스키마 오라클과 대조하는 방식이다.</p>
<p>이러한 패턴의 워크플로우는 다음과 같이 진행된다.</p>
<ol>
<li><strong>스키마 주입:</strong> 프롬프트 시스템 메시지를 통해 목표하는 JSON 스키마 명세를 언어 모델에게 제공한다.</li>
<li><strong>생성 및 파싱 시도:</strong> LLM이 반환한 텍스트 문자열을 프로그래밍 언어의 내장 JSON 파서(예: 파이썬의 <code>json.loads</code>)를 이용해 객체로 변환(역직렬화) 시도한다.</li>
<li><strong>오라클 검증:</strong> 객체를 Pydantic 모델이나 JSON Schema 검증기에 통과시킨다. 이때 필수 키가 누락되었거나 타입이 불일치하면 오라클은 <code>ValidationError</code> 예외를 발생시킨다.</li>
<li><strong>피드백 루프 작동:</strong> 애플리케이션은 발생한 에러 메시지(예: “Error: field ‘amount’ expected type integer, got string”)를 프롬프트에 덧붙여 LLM에게 재수정을 요청하는 피드백 루프를 가동한다.</li>
</ol>
<p><strong>한계 및 고려사항:</strong> 이 방식은 OpenAI, Anthropic, 오픈소스 모델 등 어떠한 LLM API에서도 구현할 수 있다는 높은 범용성을 가진다. 그러나 치명적인 단점들이 존재한다. 모델이 한 번의 요청으로 완벽한 구조를 생성하지 못할 경우 재시도(Retry)를 반복해야 하므로 응답 지연 시간(Latency)이 급격히 증가하며 토큰 사용 비용이 중복으로 발생한다. 더욱 심각한 문제는, 모델이 에러 메시지를 이해하지 못하고 동일한 구조적 환각을 반복하는 무한 루프에 빠질 위험이 도사리고 있다는 점이다.</p>
<h3>4.2  제약 기반 디코딩 (Constrained Decoding / Structured Generation)</h3>
<p>사후 검사가 가지는 성능적 비효율성과 확률적 불안정성을 근본적으로 해결하기 위해 학계와 오픈소스 진영에서 발전시킨 기술이 바로 ’제약 기반 디코딩(Constrained Decoding)’이다. 이 방식은 출력이 완료된 후 검증하는 것이 아니라, LLM이 텍스트를 한 토큰(Token)씩 생성해 나가는 추론(Inference) 엔진 내부에 결정론적 오라클을 직접 이식하는 방식이다.</p>
<ul>
<li><strong>구현 매커니즘:</strong> LLM은 매 추론 스텝마다 어휘 사전(Vocabulary)에 존재하는 수만 개의 토큰에 대한 로짓(Logits, 정규화되지 않은 확률 점수) 분포를 출력한다. 제약 기반 디코딩 엔진은 파이프라인 중간에 위치하여, 사용자가 정의한 정규 표현식(Regular Expression)이나 문맥 자유 문법(Context-Free Grammar, CFG)에 기반한 상태 머신(Finite State Machine)을 실시간으로 구동한다.</li>
<li><strong>확률의 마스킹(Logit Masking):</strong> 모델이 다음 토큰으로 <code>}</code>(객체 닫기 기호)에 가장 높은 확률을 부여했더라도, 오라클의 상태 머신이 “현재까지 생성된 텍스트를 분석한 결과, 스키마에 정의된 필수 키 <code>"author"</code>가 아직 생성되지 않았다“고 판단하면, 해당 <code>}</code> 토큰을 비롯하여 스키마를 위반하는 모든 토큰의 확률을 강제로 <span class="math math-inline">-\infty</span> (음의 무한대)로 마스킹(Masking)해버린다.</li>
<li>결과적으로 언어 모델은 자신에게 주어진 차선책 중, 오라클이 허용하는(즉, 스키마 규칙을 위반하지 않는) 토큰들(이 경우 <code>"author"</code>) 속에서만 확률적 선택을 수행하게 된다.</li>
</ul>
<p><strong>이론적 기반과 성능:</strong> 연산 부하를 최소화하기 위해 제약 기반 디코딩 프레임워크들은 트라이(Trie) 자료구조를 활용하여 허용된 토큰 공간을 대수 시간(Logarithmic Time) 내에 탐색하고 가지치기(Pruning)를 수행한다. 연구 논문 <em>Grammar-Constrained Decoding Makes Large Language Models Better Logical Parsers</em> 에 따르면, 이러한 문법 제약적 디코딩은 모델을 완벽에 가까운 논리적 파서로 탈바꿈시키며, 형식 언어(Formal Language)나 고도로 구조화된 데이터 추출 작업에서 문법 에러를 원천 차단하여 시스템의 정확성을 극적으로 끌어올린다. 이는 수학적으로 제약 조건 지시자 함수(Indicator Function) <span class="math math-inline">I(y_t, f)</span>를 곱하여 허용 범위를 벗어나는 분기를 완전히 소거하는 과정으로 모델링할 수 있다. 결과적으로 스키마 이탈(Schema Drift) 현상을 0%로 수렴시킬 수 있다.</p>
<h3>4.3  API 레벨의 엄격한 구조화 출력 (Strict Structured Outputs API)</h3>
<p>가장 최근에 등장한 패러다임은 제약 기반 디코딩의 복잡한 추론 엔진 조작을 클라우드 제공업체가 API 레벨로 캡슐화하여 제공하는 ‘엄격한 구조화 출력(Strict Structured Outputs)’ 기능이다. OpenAI, Cohere 등 주요 상용 모델 제공자들은 이러한 기능을 통해 엔터프라이즈 환경의 결정론적 요구사항에 부응하고 있다.</p>
<p>개발자가 API를 호출할 때 프롬프트 텍스트뿐만 아니라 원하는 JSON Schema 포맷을 페이로드의 <code>response_format</code> 매개변수로 전달하고 <code>strict: true</code> 옵션을 활성화하면, API 백엔드 서버에서 앞서 설명한 오라클 매커니즘(문법 변환 및 로짓 마스킹)이 투명하게 실행된다. 이를 통해 제공업체는 다음과 같은 결과를 SLA(Service Level Agreement) 수준으로 보장한다.</p>
<ol>
<li><strong>환각 억제:</strong> 스키마에 정의되지 않은 임의의 키나 도구(Tool) 이름이 생성되지 않음.</li>
<li><strong>필수 조건 강제:</strong> <code>required</code> 필드 배열에 명시된 모든 매개변수가 예외 없이 생성 결과에 포함됨.</li>
<li><strong>타입 무결성:</strong> 모든 키의 값이 스키마에 명시된 데이터 타입의 범위를 엄격하게 준수함.</li>
</ol>
<p>이러한 API 수준의 강제화는 개발자가 별도의 재시도 루프 로직을 작성하거나, 거대한 언어 모델 추론 엔진(vLLM, TGI 등)을 직접 호스팅하고 커스텀 디코딩 로직을 끼워 넣는 막대한 엔지니어링 비용을 지불할 필요 없이, 가장 신속하게 안전한 시스템을 구축할 수 있는 경로를 제공한다.</p>
<p><img src="./3.4.3.2.0%20%ED%95%84%EC%88%98%20%ED%82%A4Key%20%EC%A1%B4%EC%9E%AC%20%EC%97%AC%EB%B6%80%20%EB%B0%8F%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%20%EA%B0%95%EC%A0%9C.assets/image-20260222121104193.jpg" alt="image-20260222121104193" /></p>
<h2>5.  구조화된 출력의 신뢰성 평가 지표 체계</h2>
<p>결정론적 오라클을 도입하여 구조적 무결성을 확보했다 하더라도, 그 강제화 수준이 자연어 생성 본질에 미치는 영향을 객관적으로 수치화하고 모니터링하기 위한 체계적인 지표(Metrics)가 수반되어야 한다. 이 과정에서 널리 활용되는 평가 프레임워크인 SLOT(Structured Large Language Model Output Testing) 벤치마크 모델은 구조화 출력을 평가하는 두 가지 핵심 차원을 제시한다.</p>
<h3>5.1  스키마 정확도 (Schema Accuracy, <span class="math math-inline">As</span>)</h3>
<p>스키마 정확도 <span class="math math-inline">As(y&#39; \vert f)</span>는 LLM이 생성한 최종 데이터 객체 <span class="math math-inline">y&#39;</span>가 개발자가 요구한 포맷 명세서 <span class="math math-inline">f</span>와 한 치의 오차도 없이 완벽하게 부합하는지를 검증하는 결정론적 지표다. 이 지표는 부분 점수를 인정하지 않는 엄격한 이진(Binary) 통과 기준을 따른다.</p>
<ul>
<li><strong>구문 유효성(Syntax Validity):</strong> 응답 <span class="math math-inline">y&#39;</span> 그 자체의 텍스트가 파싱 가능한 완전한 JSON 포맷이어야 한다. 괄호가 닫히지 않았거나 쉼표가 누락된 경우 즉시 실패로 판정된다.</li>
<li><strong>키 일치성(Key String Matching):</strong> 스키마 <span class="math math-inline">f</span>에 명시된 필수 키가 하나라도 누락되거나, 스펠링이 틀린 키가 생성된 경우 정확도는 0으로 처리된다.</li>
<li><strong>타입 정합성(Value Type Agreement):</strong> 스키마에서 강제한 데이터 타입이 어긋난 경우(예를 들어, 숫자형 필드에 <code>"N/A"</code>나 <code>"10.5"</code>와 같은 문자열 삽입) 역시 스키마 정확도 평가를 통과할 수 없다.</li>
</ul>
<h3>5.2  내용 유사도 (Content Similarity, <span class="math math-inline">simC</span>)와 편향성(Bias)의 패러독스</h3>
<p>구조를 100% 강제하는 제약 기반 디코딩 메커니즘을 적용하더라도 주의해야 할 중대한 함정이 존재한다. 오라클이 모델의 토큰 생성 궤적(Trajectory)을 물리적으로 비틀어 구조적 규칙에 욱여넣을 때, 생성 결과물은 형태적으론 완벽하지만 원래 입력된 텍스트의 본래 문맥적 의미나 사실성을 상실해버리는 부작용이 발생할 수 있다. 이를 정보이론에서는 강제 디코딩으로 인한 분포 편향(Distributional Bias) 문제라고 부른다.</p>
<p>예를 들어, 프롬프트에서 주어진 정보에는 “사용자의 나이를 알 수 없음“이라고 암시되어 있으나, 스키마에서는 <code>age</code>를 반드시 정수(Integer)로 입력해야 하는 필수 키로 강제해 둔 경우를 생각해 보자. 모델은 자신의 내부 지식과 문맥을 종합했을 때 정보 없음을 의미하는 자연어를 내보내고 싶어 하지만, 오라클 엔진이 오직 숫자 토큰만을 강제하기 때문에 결국 <code>0</code>이나 <code>99</code>와 같은 허위 데이터를 맹목적으로 삽입(Over-helpfulness)하는 ’내용적 환각’을 일으키게 된다. 구조를 지키려다 데이터의 진실성을 희생하는 역설적인 상황이 발생하는 것이다.</p>
<p>따라서 학계와 실무에서는 구조적 정확도뿐만 아니라 내용 유사도(<span class="math math-inline">simC</span>)를 동시에 평가한다. 내용 유사도는 생성된 구조화 데이터(<span class="math math-inline">y&#39;</span>)가 원본 입력 텍스트(<span class="math math-inline">x</span>) 또는 정답 데이터(<span class="math math-inline">y</span>)와 얼마나 의미론적으로 부합하는지를 평가한다.</p>
<ul>
<li><strong>의미론적 유사도 측정:</strong> Sentence-BERT 모델과 같은 임베딩 모델을 활용하여 예측된 값과 정답 값 사이의 코사인 유사도를 계산한다.</li>
<li><strong>소프트 정밀도(Soft-Precision, <span class="math math-inline">simP</span>)와 소프트 재현율(Soft-Recall, <span class="math math-inline">simR</span>):</strong> 단순히 글자 수가 긴 문자열이 높은 점수를 독점하는 것을 방지하기 위해 각 필드 값의 유사도를 균등하게 가중 평균하며, 키 값이 서로 뒤바뀌는 경우(예: 이름 필드에 위치 정보가 들어가는 경우)를 강력하게 페널티 처리하기 위해 정확한 키 매칭을 요구한다.</li>
</ul>
<p>결국 완벽한 구조 강제 시스템은, 모델이 원래 전달하고자 했던 내용적 유사도를 훼손하지 않는 선에서, 즉 스키마를 모델이 표현할 수 있는 논리적 범위에 맞춰 유연하게 설계하는 고도의 스키마 엔지니어링 능력을 전제로 한다.</p>
<h2>6.  실전 예제: 타입 안전성 프레임워크를 활용한 오라클 구축 시나리오</h2>
<p>본 절의 이론적 논의를 구체화하기 위해, 금융 부문에서 고객의 계약 요청 이메일 텍스트를 파싱하여 내부 ERP 데이터베이스에 적재하는 비즈니스 파이프라인을 가정해 본다. 이 시나리오에서 확률론적 텍스트를 구조화된 타입 시스템으로 변환하는 과정이 어떻게 결정론적 오라클로 동작하는지 파이썬(Python) 환경의 코드를 통해 분석한다.</p>
<h3>6.1  비정형 텍스트 분석의 한계와 타입 불일치 위협</h3>
<p>시스템이 사용자로부터 다음과 같은 자연어 텍스트를 수신했다고 가정하자.</p>
<p>“Sarah Connor 고객이 어제 보내온 연장 계약서에 방금 서명했습니다. 계약 갱신 금액은 기존 대비 10% 인상된 약 1억 5천만 원이며, 담당 부서 매니저는 John입니다.”</p>
<p>이 데이터를 기반으로 단순 프롬프트를 통해 JSON 출력을 유도할 경우, 앞서 언급한 구조적 환각에 노출된 언어 모델은 다음과 같은 비결정적인 출력을 뱉어낼 가능성이 농후하다.</p>
<pre><code class="language-JSON">{
  "client_name": "Sarah Connor",
  "signed": "yes",
  "amount": "1억 5천만",
  "contract_date": "yesterday",
  "notes": "기존 대비 10% 인상됨"
}
</code></pre>
<p>이 출력물은 ERP 시스템의 데이터 적재 인터페이스 관점에서 재앙에 가까운 데이터 타입 위반을 다수 내포하고 있다.</p>
<ol>
<li><code>signed</code> 필드는 데이터베이스 스키마 상 불리언(<code>boolean</code>)이어야 하나, 모델은 문자열 <code>"yes"</code>를 출력했다.</li>
<li><code>amount</code> 필드는 연산을 위해 정수형(<code>integer</code>, <code>150000000</code>)이어야 하나, 한글이 섞인 문자열 <code>"1억 5천만"</code>으로 출력되었다.</li>
<li><code>contract_date</code>는 ISO 8601 형식의 날짜(<code>YYYY-MM-DD</code>)여야 하나, 자연어 상대 시점인 <code>"yesterday"</code>로 출력되었다.</li>
<li>결정적으로, 데이터베이스 무결성을 위해 반드시 필요한 외래 키(Foreign Key) 성격의 <code>manager_uuid</code>가 완전히 누락되었다. 반면 스키마에 정의되지 않은 <code>notes</code> 필드는 자의적으로 추가되었다.</li>
</ol>
<p>이 데이터가 오라클의 검증 없이 파이프라인을 통과할 경우, SQL INSERT 구문 실행 단계에서 즉각적인 런타임 에러(Data Type Mismatch)가 발생하여 시스템 프로세스가 중단된다.</p>
<h3>6.2  Python Pydantic을 이용한 결정론적 스키마 오라클의 선언</h3>
<p>최신 AI 엔지니어링에서는 파이썬의 Pydantic 라이브러리나 TypeScript의 Zod, TS-DSPy와 같은 타입 안전성(Type-Safety) 프레임워크가 결정론적 오라클의 기준점을 선언하는 역할을 훌륭히 수행한다. 이러한 클래스 기반의 선언은 모델이 통과해야 할 엄격한 “데이터 거푸집(Mold)“을 제공한다.</p>
<pre><code class="language-Python">from pydantic import BaseModel, Field
from datetime import date

class ContractRecord(BaseModel):
    client_name: str = Field(..., description="고객의 전체 이름")
    signed: bool = Field(..., description="계약 서명 완료 여부 (True/False)")
    amount: int = Field(..., description="계약 금액(원화 기준 절대 정수 값, 예: 150000000)")
    contract_date: date = Field(..., description="계약 체결일 (ISO 8601 형식, YYYY-MM-DD)")
    manager_uuid: str = Field(..., description="담당자의 시스템 고유 식별자(UUID)")
</code></pre>
<p>위와 같이 선언된 Pydantic 모델은 런타임 환경에서 언어 모델에게 전달될 수 있는 JSON Schema 규격으로 자동 치환된다. 이 변환된 스키마 내부에는 <code>required: ["client_name", "signed", "amount", "contract_date", "manager_uuid"]</code> 속성이 명시적으로 포함되어 있어 필수 키를 확정하며, 각 키에 대한 데이터 타입이 강력하게 바인딩된다.</p>
<h3>6.3  제약 기반 오라클의 개입과 완벽한 정합성 보장</h3>
<p>TS-DSPy나 Orchestral, 혹은 Outlines와 같은 프레임워크는 이렇게 생성된 JSON Schema를 모델의 추론 엔진 또는 API(예: OpenAI의 <code>response_format</code> 인자)로 전달하여 ‘제약 기반 디코딩’ 또는 ’엄격한 API 모드’를 활성화한다.</p>
<p>이 파이프라인에 텍스트가 인입되면, 모델은 더 이상 자유로운 확률적 작문가가 아닌, 오라클의 감시를 받는 규칙 기반의 논리 파서(Logical Parser)로 동작하게 된다. 그 결과 생성되는 JSON 데이터는 다음과 같이 완벽한 정합성을 지닌다.</p>
<pre><code class="language-JSON">{
  "client_name": "Sarah Connor",
  "signed": true,
  "amount": 150000000,
  "contract_date": "2026-02-21",
  "manager_uuid": "550e8400-e29b-41d4-a716-446655440000"
}
</code></pre>
<p>오라클의 제약 아래서 언어 모델은 자신의 추론 능력을 최대한 발휘하여 데이터 타입을 스키마의 요구사항에 맞게 자가 변환(Self-Transformation)한다. <code>"1억 5천만"</code>이라는 자연어를 정수 <code>150000000</code>으로 변환하고, 어제(<code>yesterday</code>)라는 상대적 시점을 현재 시스템의 컨텍스트 날짜를 기준으로 계산하여 <code>"2026-02-21"</code>이라는 ISO 포맷으로 출력한다. 무엇보다, 필수 키인 <code>manager_uuid</code>가 스키마 상 누락 불가 속성임을 인지하고, 앞선 문맥에서 언급된 “John“이라는 이름을 기반으로 시스템 내에 제공된 검색 도구(Tool)를 간접 호출하여 올바른 UUID를 찾아 채워 넣는 정교한 동작을 완수하게 된다. 이로써 파이프라인의 다운스트림 컴포넌트는 어떠한 타입 캐스팅이나 추가 검증 로직 없이 데이터를 안전하게 소비할 수 있다.</p>
<h2>7.  스키마 강제화 설계 시의 안티패턴(Anti-Patterns)과 고려사항</h2>
<p>결정론적 오라클을 통해 필수 키의 존재 여부와 데이터 타입을 강제하는 매커니즘은 매우 강력한 도구이지만, 데이터 아키텍트가 이를 오남용할 경우 시스템의 유연성을 파괴하고 오히려 환각을 부추기는 역효과를 초래할 수 있다. 성공적인 오라클 구축을 위해서는 다음의 안티패턴을 회피해야 한다.</p>
<ol>
<li><strong>동적 스키마의 남용 (Abuse of Dynamic Schemas):</strong> 런타임 상황이나 사용자의 입력 내용에 따라 오라클의 기준이 되는 JSON Schema 자체를 동적으로 변경하여 주입하는 설계는 피해야 한다. 데이터 타입과 필수 키는 데이터베이스의 스키마처럼 정적으로 선언 및 관리되어야 하며, 변경 사항은 형상 관리 시스템(Version Control)을 통해 추적 가능해야 한다. 스키마가 비결정적이면 오라클의 검증 논리 또한 흔들리게 된다.</li>
<li><strong>모호한 타입 지정 (Loose Typing or Any Type):</strong> JSON Schema에서 특정 필드에 대해 <code>type: "object"</code> 또는 <code>type: "any"</code>와 같이 하위 데이터 구조를 명시하지 않고 모호하게 남겨두는 것은 오라클의 방어망에 거대한 구멍을 뚫는 행위다. 이는 본질적으로 언어 모델에게 “이 안에는 자유롭게 아무 포맷이나 채워 넣으라“는 허가를 주는 것과 같으므로, 구조적 강제화가 가져다주는 신뢰성의 이점이 소멸된다.</li>
<li><strong>예외 없는 필수 키의 과도한 강제 (Over-constraining):</strong> 모든 필드를 예외 없이 필수 키(Required Key)로 지정하는 것은 실무에서 범하기 쉬운 가장 위험한 안티패턴이다. 입력된 원본 비정형 문서에 특정 필드에 대응하는 정보가 실제로 존재하지 않는 경우, 모델은 스키마의 규칙(반드시 해당 키와 특정 타입의 값을 채워 넣어야 함)을 만족시키기 위해 강박적으로 거짓 정보(Hallucinated Data)를 날조하여 빈칸을 채우게 된다. 이러한 강제적 환각을 방지하기 위해서는 정보가 부재한 경우를 명확히 처리할 수 있는 <code>null</code> 허용 타입(Nullable Type, 예: <code>type: ["string", "null"]</code>)의 도입이나, 필수 키를 시스템 구동에 반드시 필요한 최소한으로 축소하고 나머지는 선택적 키(Optional Key)로 분리하는 유연한 설계가 병행되어야 한다.</li>
</ol>
<p>결론적으로, 필수 키 존재 여부 및 데이터 타입을 강제하는 기술은 확률론적 언어 모델을 예측 가능하고 신뢰할 수 있는 엔터프라이즈 소프트웨어의 부품으로 탈바꿈시키는 가장 기초적이면서도 핵심적인 오라클 매커니즘이다. 이를 올바르게 이해하고 적절한 제약의 수준을 설계하는 것은, 향후 AI 기반 소프트웨어 아키텍처의 안정성과 성패를 가르는 중대한 척도가 될 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Structured Data with LLMs Done Right, https://papers.ssrn.com/sol3/Delivery.cfm/5636430.pdf?abstractid=5636430&amp;mirid=1</li>
<li>Why Multi-Agent LLM Systems Fail (and How to Fix Them), https://www.augmentcode.com/guides/why-multi-agent-llm-systems-fail-and-how-to-fix-them</li>
<li>LLM Output Parsing and Structured Generation Guide - Tetrate, https://tetrate.io/learn/ai/llm-output-parsing-structured-generation</li>
<li>SLOT: Structuring the Output of Large Language … - ACL Anthology, https://aclanthology.org/2025.emnlp-industry.32.pdf</li>
<li>When Two AIs Talk: A Case Study in Tool Call Hallucinations, https://bogdanripa.medium.com/when-two-ais-talk-a-case-study-in-tool-call-hallucinations-32c2680d1566</li>
<li>Survey and analysis of hallucinations in large language models, https://www.frontiersin.org/journals/artificial-intelligence/articles/10.3389/frai.2025.1622292/full</li>
<li>Constrained Decoding of Diffusion LLMs with Context-Free Grammars, https://arxiv.org/pdf/2508.10111</li>
<li>Logically Constrained Decoding - ResearchGate, https://www.researchgate.net/publication/397419142_Logically_Constrained_Decoding</li>
<li>LLM-based Agents Suffer from Hallucinations: A Survey of … - arXiv, https://arxiv.org/html/2509.18970v1</li>
<li>How Do LLMs Fail In Agentic Scenarios? A Qualitative Analysis of, https://arxiv.org/html/2512.07497v1</li>
<li>| Meta Data Type Mismatch error encountered when making an API, https://drdroid.io/integration-diagnosis-knowledge/meta-data-type-mismatch-error-encountered-when-making-an-api-request</li>
<li>(PDF) Why Do Multi-Agent LLM Systems Fail? - ResearchGate, https://www.researchgate.net/publication/389947144_Why_Do_Multi-Agent_LLM_Systems_Fail</li>
<li>Oracle Forms Modernization: Why Deterministic Conversion Matters, https://renaps.com/en/blog/oracle-forms-modernization-Deterministic-vs-AI</li>
<li>Deterministic AI for Predictable Coding | Augment Code, https://www.augmentcode.com/guides/deterministic-ai-for-predictable-coding</li>
<li>Large Language Model-Driven Structured Output - MDPI, https://www.mdpi.com/2220-9964/13/11/405</li>
<li>Structured outputs | LLM Inference Handbook - Bento, https://bentoml.com/llm/getting-started/tool-integration/structured-outputs</li>
<li>Reinforcement Strategy for Strict LLM Schema Adherence - arXiv, https://arxiv.org/html/2502.14905v1</li>
<li>How do Structured Outputs Work? | Cohere, https://docs.cohere.com/docs/structured-outputs</li>
<li>Generating Structured Outputs from Language Models: Benchmark, https://arxiv.org/html/2501.10868v1</li>
<li>Logically Constrained Decoding - ACL Anthology, https://aclanthology.org/2025.mathnlp-main.11.pdf</li>
<li>otriscon/llm-structured-output - GitHub, https://github.com/otriscon/llm-structured-output</li>
<li>Grammar-Constrained Decoding Makes Large Language Models, https://aclanthology.org/2025.acl-industry.34.pdf</li>
<li>Towards Consistent Language Models Using Controlled Prompting, https://research.engr.oregonstate.edu/idea/sites/research.engr.oregonstate.edu.idea/files/consistent_llms_deem.pdf</li>
<li>Efficient and Asymptotically Unbiased Constrained Decoding for, https://raw.githubusercontent.com/mlresearch/v258/main/assets/ye25b/ye25b.pdf</li>
<li>Orchestral AI: A Framework for Agent Orchestration - ResearchGate, https://www.researchgate.net/publication/399522382_Orchestral_AI_A_Framework_for_Agent_Orchestration</li>
<li>ardada2468/LLMTypeSafe - GitHub, https://github.com/ardada2468/LLMTypeSafe</li>
<li>SlackAgents: Scalable Collaboration of AI Agents in Workspaces, https://aclanthology.org/2025.emnlp-demos.76.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>