<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.3.2 테스트 불가능한 프로그램(Non-testable Programs)의 특징</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.3.2 테스트 불가능한 프로그램(Non-testable Programs)의 특징</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 2. 소프트웨어 테스트에서의 오라클(Oracle) 개념과 AI 시대의 역할</a> / <a href="index.html">2.3 오라클 문제(The Oracle Problem)와 자동화의 한계</a> / <span>2.3.2 테스트 불가능한 프로그램(Non-testable Programs)의 특징</span></nav>
                </div>
            </header>
            <article>
                <h1>2.3.2 테스트 불가능한 프로그램(Non-testable Programs)의 특징</h1>
<h2>1.  서론: 소프트웨어 테스팅의 인식론적 한계와 오라클 가정의 붕괴</h2>
<p>소프트웨어 공학의 역사에서 ’테스팅(Testing)’은 오랫동안 결정론적 세계관에 기반하여 발전해 왔다. “프로그램 <span class="math math-inline">P</span>에 입력 <span class="math math-inline">I</span>를 주입했을 때, 관측된 출력 <span class="math math-inline">O</span>가 기대되는 출력 <span class="math math-inline">E</span>와 일치하는가?“라는 질문은 테스팅의 가장 근원적인 질문이자, 품질 보증(QA) 활동의 대전제였다. 이 대전제가 성립하기 위해서는 필수적인 요소가 하나 존재하는데, 바로 <span class="math math-inline">O</span>와 <span class="math math-inline">E</span>의 일치 여부를 판별해 줄 수 있는 신뢰할 수 있는 결정 메커니즘, 즉 **‘오라클(Oracle)’**의 존재이다.</p>
<p>전통적인 소프트웨어 개발 방법론은 오라클이 언제나 존재하며, 테스터가 합리적인 노력과 비용으로 이를 획득하거나 구축할 수 있다는 <strong>‘오라클 가정(The Oracle Assumption)’</strong> 위에 세워졌다. 예를 들어, 급여 계산 시스템이나 재고 관리 시스템과 같은 트랜잭션 처리 시스템(TPS)에서는 비즈니스 로직이 명확하고, 정답을 계산하는 것이 어렵지 않다. <span class="math math-inline">2+2</span>는 항상 <span class="math math-inline">4</span>여야 하며, 데이터베이스의 레코드는 정확히 갱신되어야 한다. 이러한 환경에서 테스팅의 초점은 ’정답을 아는 것’이 아니라, ’프로그램이 그 정답을 도출하는 경로(Path)를 제대로 따르는가’를 확인하는 커버리지(Coverage) 문제에 집중되었다.</p>
<p>그러나 현대의 컴퓨팅 환경은 이러한 고전적 가정을 근본적으로 위협하고 있다. 일레인 웨유커(Elaine Weyuker)가 1982년 그녀의 기념비적인 논문 “On Testing Non-Testable Programs“에서 처음 제기했던 **‘테스트 불가능한 프로그램(Non-testable Programs)’**의 개념은, 오늘날 인공지능(AI), 머신러닝(ML), 자율주행 시스템, 그리고 대규모 분산 시스템의 등장과 함께 그 중요성이 재조명되고 있다. 여기서 ’테스트 불가능하다’는 것은 프로그램의 실행 자체가 불가능하다는 기술적 결함을 의미하는 것이 아니다. 이는 <strong>프로그램의 출력 결과가 올바른지 판단할 수 있는 오라클이 존재하지 않거나, 존재하더라도 이를 활용하는 데 천문학적인 비용이나 시간이 소요되어 실질적으로 검증이 불가능한 상태</strong>를 지칭하는 인식론적(Epistemic) 개념이다.</p>
<p>본 절에서는 웨유커의 고전적 정의에서 출발하여, 카너(Kaner)와 바흐(Bach)가 제시한 휴리스틱 접근법, 그리고 최신 LLM(Large Language Models)이 제기하는 의미론적 개방성(Semantic Openness)의 문제에 이르기까지, 테스트 불가능한 프로그램이 갖는 다차원적인 특징들을 심층적으로 분석한다. 이는 단순한 ’버그’의 문제가 아니라, 우리가 다루는 문제 공간(Problem Space)의 복잡성이 인간의 인지 능력과 검증 도구의 한계를 초과했을 때 발생하는 현상이다. 우리는 이 현상을 <strong>인식론적 불확실성</strong>, <strong>비결정론적 변동성</strong>, 그리고 <strong>의미론적 모호성</strong>이라는 세 가지 축을 중심으로 해부할 것이다.</p>
<h2>2.  오라클의 부재와 인식론적 불확실성 (The Absence of Oracle and Epistemic Uncertainty)</h2>
<p>테스트 불가능한 프로그램의 가장 근원적인 특징은 ’정답을 모른다’는 인식론적 한계에서 비롯된다. 이는 테스터의 무능력이 아니라, 해결하려는 문제의 본질적인 성격에 기인한다. 웨유커는 이를 두 가지 조건으로 정식화하였다: (1) 오라클이 존재하지 않는 경우, (2) 이론적으로는 가능하지만 실제로는 너무 어려운 경우.</p>
<h3>2.1  미지의 해를 탐색하는 프로그램 (Programs Written to Determine the Answer)</h3>
<p>소프트웨어 개발의 목적 중 하나는 인간이 계산하기 어려운 문제를 해결하는 것이다. 역설적이게도, 프로그램이 가장 필요한 순간이 바로 그 프로그램을 테스트하기 가장 어려운 순간이 된다. 웨유커는 이를 **“정답을 구하기 위해 작성된 프로그램”**이라고 정의했다. 만약 우리가 <span class="math math-inline">f(x)</span>의 정확한 값을 이미 알고 있다면, 굳이 복잡한 프로그램을 작성하여 계산할 필요가 없을 것이다.</p>
<p>이러한 특징은 과학적 시뮬레이션(Scientific Simulation) 분야에서 가장 극명하게 드러난다. 예를 들어, 고에너지 물리학 실험을 시뮬레이션하거나, 기후 변화 모델을 통해 50년 후의 지구 온도를 예측하는 소프트웨어를 생각해 보자.</p>
<ul>
<li><strong>검증의 순환 논리:</strong> 테스터가 시뮬레이션 결과의 정확성을 검증하려면, 시뮬레이션보다 더 정확한 ’참값(Ground Truth)’을 가지고 있어야 한다. 그러나 그 참값은 미래에 존재하거나, 실험이 불가능한 물리적 현상일 수 있다.</li>
<li><strong>복잡성의 장벽:</strong> 나비에-스토크스 방정식(Navier-Stokes equations)과 같은 편미분 방정식을 수치 해석적으로 풀 때, 근사 해(Approximate Solution)의 오차 범위를 검증하는 것은 수학적으로 매우 난해한 작업이다. 테스터는 코드를 검증하는 것이 아니라, 수치 해석 알고리즘의 수렴성(Convergence)과 안정성(Stability)을 검증해야 하는 상황에 놓인다.</li>
</ul>
<p>이 경우, 오라클은 존재하지 않거나, 유일한 검증 수단인 ’실제 실험(Physical Experiment)’은 소프트웨어 테스트 단계에서 수행하기에는 비용이 너무 많이 들거나 불가능하다(Infeasible). 따라서 이러한 프로그램은 ‘절대적 정확성’ 대신 ’이론적 모델과의 일관성’이나 ’기존 데이터와의 통계적 유사성’을 통해 간접적으로만 검증될 수 있다.</p>
<h3>2.2  계산 복잡성과 오라클의 비현실성 (Computational Complexity)</h3>
<p>이론적으로는 오라클이 존재하더라도, 실용적인 관점에서는 존재하지 않는 것과 다름없는 경우가 있다. 이는 계산 복잡성 이론(Computational Complexity Theory)과 밀접한 관련이 있다. 어떤 문제의 정답을 검증하는 데 걸리는 시간이 문제의 크기에 따라 지수함수적으로 증가한다면(예: NP-Complete 문제), 테스터는 유한한 시간 내에 테스트를 완료할 수 없다.</p>
<ul>
<li><strong>암호화 및 최적화 문제:</strong> 암호화 알고리즘의 경우, ’복호화 가능성’은 쉽게 테스트할 수 있지만, ’해독 불가능성(Security)’을 테스트하는 것은 불가능에 가까운 난제이다. “이 암호 알고리즘이 100년 내에 깨지지 않는가?“라는 질문에 대한 오라클은 존재하지 않는다.</li>
<li><strong>게임 인공지능:</strong> 체스나 바둑 프로그램에서 ’신의 한 수(God’s Move)’라 불리는 최적의 수가 존재할 수 있지만, 이를 계산하기 위해서는 우주의 수명보다 긴 시간이 필요하다. 따라서 테스터는 ’절대적 승리’를 검증하는 대신, ’인간 고수와의 대결’이나 ’다른 엔진과의 대결’이라는 상대적이고 불완전한 오라클에 의존하게 된다.</li>
</ul>
<h3>2.3  사람의 주관과 해석의 개입 (Subjectivity in Interpretation)</h3>
<p>결과값이 객관적인 수치가 아니라, 이미지, 소리, 또는 자연어 텍스트일 경우, ’정답’의 정의 자체가 모호해진다. 웨유커는 이를 “테스터의 오해(Misconception)” 가능성과 연결하여 설명하였다.</p>
<ul>
<li><strong>멀티미디어 처리:</strong> 3D 렌더링 엔진이 생성한 이미지가 ‘사실적인가?’ 혹은 음성 합성 시스템(TTS)이 생성한 목소리가 ’자연스러운가?’를 판단하는 기준은 수학적으로 정의하기 어렵다. 픽셀 단위의 비교(Pixel-perfect comparison)는 렌더링 알고리즘의 미세한 변화(예: 부동 소수점 연산 차이)로 인해 실패할 수 있으며, 이러한 차이가 시각적으로 의미 있는 오류인지 판단하기 위해서는 인간의 주관적 **‘육안 검사(Eyeballing)’**가 개입되어야 한다.</li>
<li><strong>번역 및 요약:</strong> 기계 번역 시스템의 결과를 평가할 때, “The cat sat on the mat“을 “고양이가 매트 위에 앉았다“로 번역하든 “매트 위에 고양이가 앉아 있다“로 번역하든 둘 다 정답이 될 수 있다. 정답 집합이 하나가 아니라 복수 개이거나, 명확한 경계가 없는 경우 오라클은 무력화된다.</li>
</ul>
<h2>3.  결과의 비가시성과 대용량 출력의 문제 (High Volume and Invisibility)</h2>
<p>현대 소프트웨어 시스템은 인간의 인지 능력을 초과하는 막대한 양의 데이터를 처리하고 출력한다. 웨유커는 “너무 많은 출력을 생성하여 그 모든 것을 검증하는 것이 비현실적인 경우“를 테스트 불가능한 프로그램의 주요 범주로 분류했다.</p>
<h3>3.1  검증 불가능한 데이터 볼륨 (Volume Effect)</h3>
<p>빅데이터 분석 시스템이나 로그 모니터링 시스템을 예로 들어보자. 하루에 10억 건의 트랜잭션을 처리하는 금융 사기 탐지 시스템(FDS)이 “어제 발생한 10억 건 중 5,000건이 의심 거래입니다“라고 보고했다고 가정하자.</p>
<p>테스터가 직면하는 문제는 이중적이다:</p>
<ol>
<li><strong>False Positive 확인의 어려움:</strong> 5,000건의 의심 거래가 실제로 사기인지 일일이 확인하는 데 엄청난 인력이 소모된다.</li>
<li><strong>False Negative의 불가시성:</strong> 더 심각한 문제는, 시스템이 ’정상’이라고 판정한 나머지 9억 9,999만 5천 건 중에 사기 거래가 섞여 있지 않다는 것을 어떻게 보장할 것인가이다.</li>
</ol>
<p>전수 조사가 불가능한 상황에서 테스터는 **샘플링(Sampling)**이나 **통계적 프로파일링(Statistical Profiling)**에 의존하게 된다. 그러나 샘플링은 필연적으로 오류 가능성을 내포하며, “테스트를 통과했다“는 선언은 “우리가 확인한 샘플 내에서는 오류가 없었다“는 제한적 의미로 축소된다.</p>
<h3>3.2  숨겨진 결함과 우연한 정답 (Coincidental Correctness)</h3>
<p>테스트 불가능한 프로그램에서는 오류가 발생했음에도 불구하고 결과값이 우연히 정답과 일치하거나, 오류가 겉으로 드러나지 않는 현상이 발생할 수 있다. 웨유커는 이를 **‘우연한 정답(Coincidental Correctness)’**의 위험성으로 경고했다.</p>
<p>예를 들어, <span class="math math-inline">y = 2x</span>를 계산해야 하는 프로그램이 실수로 <span class="math math-inline">y = x + 2</span>로 구현되었다고 하자. 만약 테스터가 입력값으로 <span class="math math-inline">x=2</span>를 선택한다면, 두 식 모두 <span class="math math-inline">4</span>를 출력하므로 테스트는 성공한 것으로 간주된다. 오라클이 없는 상태에서 테스터는 내부 로직의 결함을 감지할 수 있는 ’직관’이나 ’이론적 배경’이 부족할 수 있으며, 이는 결함이 프로덕션 환경까지 누출되는 원인이 된다.</p>
<h2>4.  비결정론(Non-determinism)과 재현 불가능성의 위기</h2>
<p>전통적인 테스트는 결정론적(Deterministic)이다. 즉, 시스템 <span class="math math-inline">S</span>는 동일한 입력 <span class="math math-inline">X</span>와 동일한 초기 상태 <span class="math math-inline">Q</span>에서 언제나 동일한 출력 <span class="math math-inline">Y</span>를 반환해야 한다. 그러나 현대의 분산 시스템, 클라우드 아키텍처, 그리고 사이버-물리 시스템(CPS)은 본질적으로 비결정론적 특성을 가지며, 이는 테스트의 핵심 전제인 **‘재현성(Reproducibility)’**을 파괴한다.</p>
<h3>4.1  비결정론의 4가지 유형과 오라클 문제</h3>
<p>최근 연구들은 소프트웨어 테스트를 어렵게 만드는 비결정론을 크게 네 가지 유형으로 분류한다.</p>
<ol>
<li><strong>물리적 비결정론 (Physical Non-determinism):</strong> 양자 역학적 현상이나 하드웨어 센서의 노이즈, 열잡음 등으로 인해 발생하는 진정한 의미의 무작위성이다. 자율주행 자동차의 센서 데이터나 IoT 장비의 입력값은 미세하게 변동하며, 이를 완벽하게 통제된 테스트 환경으로 복제하는 것은 불가능에 가깝다.</li>
<li><strong>창발적 비결정론 (Emergent Non-determinism):</strong> 개별 구성 요소는 결정론적으로 작동하더라도, 이들이 결합하여 상호작용할 때 시스템 전체 수준에서 예측 불가능한 행동이 나타나는 현상이다. 군집 로봇(Swarm Robotics)이나 대규모 마이크로서비스 아키텍처(MSA)에서 개별 서비스의 정상적인 지연(Latency)들이 결합되어 시스템 전체의 타임아웃이나 연쇄적인 실패(Cascading Failure)를 유발할 수 있다. 오라클은 개별 컴포넌트의 동작은 검증할 수 있어도, 이러한 창발적 상호작용의 결과까지 예측하기는 어렵다.</li>
<li><strong>동시적 비결정론 (Concurrent Non-determinism):</strong> 멀티코어 프로세서와 멀티스레드 환경에서 스레드 스케줄링(Thread Scheduling)의 순서는 실행할 때마다 달라진다. 이로 인해 발생하는 경쟁 조건(Race Condition), 교착 상태(Deadlock) 등은 간헐적으로만 발생하며, 디버거를 연결하거나 로그를 남기려는 순간 사라지는 <strong>‘하이젠버그(Heisenbug)’</strong> 현상을 유발한다. 오라클이 있어도 오류 상황 자체를 재현할 수 없기 때문에 테스트는 무력화된다.</li>
<li><strong>예외적 비결정론 (Exceptional Non-determinism):</strong> 하드웨어 고장, 네트워크 단절 등 외부 요인에 의한 예외 상황은 예측 불가능하게 발생한다. 시스템이 이러한 예외 상황에서 올바르게 복구(Recovery)되는지를 테스트하려면, 무작위적인 장애 주입(Chaos Engineering)이 필요하지만, 이 또한 결과의 정확성을 보장하는 오라클을 정의하기 어렵게 만든다.</li>
</ol>
<h3>4.2  모델 테스팅(Model Testing)의 필요성과 한계</h3>
<p>이러한 비결정론적이고 테스트 불가능한 시스템을 다루기 위해 **모델 테스팅(Model Testing)**이라는 개념이 대두되었다. 이는 실제 운영 시스템(Operational System)을 직접 테스트하는 것이 불가능하거나 위험할 때, 시스템의 행동과 환경을 추상화한 ’실행 가능한 모델(Executable Model)’을 대상으로 테스트를 수행하는 전략이다.</p>
<ul>
<li><strong>추상화의 이점:</strong> 모델은 불필요한 물리적 노이즈를 제거하고, 관심 있는 상태(State)와 전이(Transition)에 집중하게 함으로써 오라클 정의를 가능하게 한다.</li>
<li><strong>새로운 오라클 문제:</strong> 그러나 모델 자체의 정확성(Validation)은 어떻게 보장할 것인가? 모델이 현실 세계를 너무 단순화했다면, 모델 테스트는 통과했지만 실제 시스템은 실패하는 ‘모델-현실 괴리(Gap)’ 문제가 발생한다. 따라서 모델 테스팅은 테스트 불가능성을 ’관리 가능한 수준’으로 낮추는 도구일 뿐, 오라클 문제를 완전히 해결하지는 못한다.</li>
</ul>
<h2>5.  인공지능과 LLM: 의미론적 개방성(Semantic Openness)의 시대</h2>
<p>2020년대 들어 급격히 발전한 대규모 언어 모델(LLM)과 생성형 AI(Generative AI)는 ’테스트 불가능한 프로그램’의 정의를 새로운 차원으로 확장시키고 있다. 전통적인 소프트웨어가 입력과 출력의 관계가 닫혀 있는 **‘의미론적 폐쇄 시스템(Semantically Closed System)’**이라면, LLM은 **‘의미론적 개방 시스템(Semantically Open System)’**이다.</p>
<h3>5.1  정답 공간의 무한성과 개방성 (Open-Ended Output Space)</h3>
<p>전통적인 컴파일러는 내부적으로 복잡한 최적화를 수행하더라도, 산출된 기계어 코드는 원본 소스 코드와 의미적으로 동일(Semantically Equivalent)해야 한다는 명확한 수학적 닫힘(Closure) 속성을 가진다. 따라서 컴파일러 테스트는 결정론적이며 오라클 구축이 가능하다.</p>
<p>반면, LLM에게 “창의적인 마케팅 문구를 작성해 줘“라고 요청했을 때, 산출될 수 있는 ‘유효한(Valid)’ 출력의 집합은 사실상 무한하다. “고객의 마음을 사로잡으세요“와 “당신의 비즈니스를 혁신하세요” 중 무엇이 정답인가? 둘 다 정답일 수도, 둘 다 오답일 수도 있다. 이러한 **‘개방된 자연어 공간(Open Natural Language Space)’**에서는 기존의 정확한 매칭(Exact Match) 기반 오라클이 작동하지 않는다.</p>
<p>테스터는 이제 “출력이 <span class="math math-inline">E</span>와 일치하는가?“가 아니라, “출력이 의미적으로 적절한가?“라는 훨씬 더 모호하고 고차원적인 질문을 던져야 한다. 이를 해결하기 위해 **‘LLM-as-a-Judge’**와 같이 또 다른 LLM을 평가자로 사용하는 방법이 제안되고 있지만, 이는 검증 도구 자체의 신뢰성을 담보할 수 없는 **순환 참조(Circular Reference)**의 딜레마를 낳는다.</p>
<h3>5.2  확률적 앵무새와 환각 (Hallucination)</h3>
<p>AI 시스템의 비테스트(Non-testable) 특성 중 가장 치명적인 것은 **‘환각(Hallucination)’**이다. LLM은 통계적으로 가장 그럴듯한(Plausible) 다음 단어를 예측하도록 훈련되었을 뿐, 진리값(Truth Value)을 검증하는 메커니즘을 내재하고 있지 않다.</p>
<ul>
<li><strong>부식성 환각 (Corrosive Hallucination):</strong> 단순히 틀린 답을 내놓는 것이 아니라, 겉보기에 매우 논리적이고 권위 있는 어조로 거짓 정보를 생성한다는 점이 문제다. 가상의 판례를 인용하거나, 존재하지 않는 논문을 참조하는 식이다. 이는 웨유커가 경고했던 “그럴듯해 보이는 오답“의 최첨단 형태이다.</li>
<li><strong>검증 불가능성:</strong> 모델이 생성한 정보의 진위 여부를 확인하려면 테스터는 모델이 학습한 것보다 더 방대한 지식을 가지고 있어야 한다. 이는 ’오라클을 획득하는 데 비현실적인 비용이 든다’는 웨유커의 정의와 정확히 일치한다. 모든 생성된 문장에 대해 팩트 체크를 수행하는 것은 실시간 시스템에서 불가능하기 때문이다.</li>
</ul>
<h3>5.3  확률적 변동성과 프롬프트 민감도</h3>
<p>LLM 애플리케이션은 **확률적 변동성(Stochastic Variance)**을 내재하고 있다. 동일한 프롬프트에 대해서도 실행 시점, 모델 버전, 무작위성 매개변수(Temperature, Top-P)에 따라 다른 결과를 내놓는다. 이는 카오스 이론의 초기 조건 민감성(Butterfly Effect)과 유사하게, 프롬프트의 미세한 어순 변화나 공백 추가가 출력의 거대한 의미적 차이를 만들어낼 수 있다. 이러한 환경에서는 “어제 통과한 테스트 케이스가 오늘 실패“하는 것이 자연스러운 현상이 되며, 전통적인 회귀 테스트(Regression Testing)의 통과/실패 기준을 무너뜨린다.</p>
<h2>6.  대응 전략: 부분 오라클과 휴리스틱 (Partial Oracles and Heuristics)</h2>
<p>완벽한 오라클이 부재한 상황에서, 소프트웨어 엔지니어링은 ’정답 확인’에서 ’결함 탐지’로, 그리고 ’절대적 검증’에서 ’신뢰도 확보’로 목표를 수정해 왔다. 이에 따라 테스트 불가능한 프로그램을 다루기 위한 다양한 대안적 접근법이 개발되었다.</p>
<h3>6.1  메타모픽 테스팅 (Metamorphic Testing)</h3>
<p>오라클 문제에 대한 가장 강력한 이론적 대안 중 하나는 **메타모픽 테스팅(Metamorphic Testing)**이다. 이는 입력값 <span class="math math-inline">x</span>에 대한 정답 <span class="math math-inline">f(x)</span>를 몰라도, 입력값의 변화가 출력값의 변화와 맺는 **관계(Relation)**는 알 수 있다는 점에 착안한다.</p>
<ul>
<li><strong>개념:</strong> 복잡한 알고리즘 <span class="math math-inline">f(x)</span>의 결과값은 검증하기 어렵지만, <span class="math math-inline">f(x)</span>가 가져야 할 필수적인 속성(Property)은 검증할 수 있다. 예를 들어, <span class="math math-inline">sin(x)</span>의 값은 모르지만, <span class="math math-inline">sin(x) = sin(180^\circ - x)</span>라는 관계(메타모픽 관계, MR)는 항상 성립해야 한다.</li>
<li><strong>적용:</strong> 검색 엔진 테스트에서 “AI Testing“을 검색한 결과 집합 <span class="math math-inline">A</span>와, “AI Testing AND Methodology“를 검색한 결과 집합 <span class="math math-inline">B</span>가 있다면, <span class="math math-inline">B</span>는 <span class="math math-inline">A</span>의 부분집합이어야 한다는 관계(<span class="math math-inline">B \subseteq A</span>)를 검증한다. 이를 통해 검색 결과의 정확성을 몰라도 검색 엔진의 논리적 오류를 검출할 수 있다.</li>
</ul>
<h3>6.2  유사 오라클(Pseudo-Oracle)과 이중 구현(Dual Coding)</h3>
<p>웨유커는 오라클이 없을 때 **‘유사 오라클’**을 사용할 것을 제안했다. 이는 동일한 기능을 수행하는 다른 프로그램(독립적으로 개발된)을 오라클로 사용하는 방법이다.</p>
<ul>
<li><strong>N-Version Programming:</strong> 항공 우주 분야와 같이 고신뢰성이 요구되는 시스템에서는 동일한 명세를 바탕으로 서로 다른 팀이 개발한 소프트웨어 3개를 동시에 실행하고, 다수결(Majority Voting)로 결과를 채택한다.</li>
<li><strong>Regression Oracle:</strong> 이전 버전의 소프트웨어를 오라클로 사용한다. 새로운 버전의 결과가 이전 버전과 다르다면, 그것이 의도된 변경인지 버그인지 검토하는 방식이다. 이는 ’정답’을 알려주지는 않지만, ’변화’를 감지하게 해 준다.</li>
</ul>
<h3>6.3  개연성 테스트 (Testing for Plausibility)와 ARMED</h3>
<p>사회적 시뮬레이션이나 복잡계 모델링에서는 오라클이 ‘본질적으로 알 수 없는(Inherently Unknowable)’ 상태이다. 여기서는 **ARMED(Association Rules Mining based Evaluation)**와 같은 접근법을 통해 ‘정답’ 대신 **‘개연성(Plausibility)’**을 테스트한다.</p>
<ul>
<li>시스템의 실행 로그에서 연관 규칙(Association Rules)을 마이닝하여 “A가 발생하면 B가 발생한다“는 패턴을 학습한다.</li>
<li>새로운 실행 결과가 이 학습된 패턴에서 크게 벗어나면(Suspicious), 이를 잠재적 결함으로 간주한다. 이는 “이 결과가 맞는가?“가 아니라 **“이 결과가 과거의 행동 패턴과 일관성이 있는가?”**를 묻는 것이다. 이는 오라클이 없는 상황에서 데이터 기반으로 이상 징후를 탐지하는 현대적인 접근법이다.</li>
</ul>
<h3>6.4  인간의 역할: 휴리스틱 오라클</h3>
<p>기계적 오라클이 실패할 때, 결국 최후의 보루는 인간이다. 카너와 바흐는 이를 **‘휴리스틱 오라클(Heuristic Oracle)’**이라고 불렀다.</p>
<ul>
<li><strong>“Goldilocks” Heuristic:</strong> 결과값이 너무 크지도, 너무 작지도 않은 적절한 범위 내에 있는가?</li>
<li><strong>Inconsistency Heuristic:</strong> 동일한 작업을 수행했을 때 결과가 달라지지는 않는가? (비결정론적 시스템에서 유용)</li>
<li><strong>Metamorphic Heuristic:</strong> 관련된 데이터 간의 관계가 깨지지는 않았는가?</li>
</ul>
<p>이러한 접근은 완벽하지 않지만(Fallible), 오라클이 없는 상황에서 테스터가 의사결정을 내릴 수 있도록 돕는 실용적인 도구이다.</p>
<h2>7.  결론</h2>
<p>테스트 불가능한 프로그램의 특징을 분석한 결과, 우리는 “테스트 불가능성“이 고정된 속성이 아니라 **스펙트럼(Spectrum)**임을 알 수 있다. 이는 결정론적 영역(Testable)에서 시작하여, 계산 비용이 높은 영역(Practically Non-testable), 정답을 모르는 인식론적 영역(Epistemically Non-testable), 그리고 확률적이고 의미론적으로 개방된 영역(Stochastically Non-testable)으로 확장된다.</p>
<p>현대 소프트웨어 공학의 흐름은 결정론적 영역에서 확률적 영역으로 급격히 이동하고 있다. 따라서 “테스트 불가능한 프로그램“이라는 용어는 이제 “테스트하지 말아야 할 프로그램“이 아니라, **“새로운 검증 패러다임이 필요한 프로그램”**으로 재해석되어야 한다. 테스터는 더 이상 단순한 ’비교자(Comparator)’가 아니라, 통계적 추론과 메타모픽 관계, 그리고 도메인 지식을 활용하여 불확실성 속에서 신뢰를 구축하는 **‘탐구자(Investigator)’**가 되어야 한다. 오라클은 죽지 않았다. 다만, 절대적 진리의 심판관에서 확률적 힌트를 제공하는 조언자로 그 역할이 진화했을 뿐이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>On Testing Non-testable Programs - Elaine J. Weyuker, https://homes.cs.washington.edu/~rjust/courses/CSE503/2021_02_12-reading1.pdf</li>
<li>(PDF) On Testing Non-Testable Programs - ResearchGate, https://www.researchgate.net/publication/31504539_On_Testing_Non-Testable_Programs</li>
<li>On Testing Non-Testable Programs - R Discovery, https://discovery.researcher.life/article/on-testing-non-testable-programs/acf588730f2035e988e32a8ec0505bc4</li>
<li>Testing Non-Deterministic Research Software, https://bssw.io/items/testing-non-deterministic-research-software</li>
<li>The Challenges of Testing in a Non-Deterministic World, https://www.sei.cmu.edu/blog/the-challenges-of-testing-in-a-non-deterministic-world/</li>
<li>Testing the Untestable*, https://people.svv.lu/sabetzadeh/pub/V2025.pdf</li>
<li>LLMs could be, but shouldn’t be compilers - Hacker News, https://news.ycombinator.com/item?id=46912781</li>
<li>The discussions around this point are taking it too seriously, even, https://news.ycombinator.com/item?id=46912882</li>
<li>Rethinking Testing for LLM Applications: Characteristics … - arXiv, https://arxiv.org/pdf/2508.20737</li>
<li>New sources of inaccuracy? A conceptual framework for studying AI, https://misinforeview.hks.harvard.edu/article/new-sources-of-inaccuracy-a-conceptual-framework-for-studying-ai-hallucinations/</li>
<li>Why Language Models Hallucinate - OpenAI, https://cdn.openai.com/pdf/d04913be-3f6f-4d2b-b283-ff432ef4aaa5/why-language-models-hallucinate.pdf</li>
<li>Hallucination, reliability, and the role of generative AI in science, https://arxiv.org/pdf/2504.08526</li>
<li>AI Hallucinations in Research: What They Are &amp; How to Stop - INRA, https://www.inra.ai/blog/ai-hallucinations</li>
<li>Metamorphic Testing: Testing the Untestable, https://research.nottingham.edu.cn/files/31438001/293_combinepdf_2_.pdf</li>
<li>Test your Machine Learning Algorithm with Metamorphic Testing, https://medium.com/trustableai/testing-ai-with-metamorphic-testing-61d690001f5c</li>
<li>Automatic System Testing of Programs without Test Oracles, https://academiccommons.columbia.edu/doi/10.7916/D86D60VH/download</li>
<li>The Oracle Problem and the Teaching of Software Testing, https://kaner.com/?p=190</li>
<li>Testing non-testable programs using association rules, https://robertoverdecchia.github.io/papers/AST_2022.pdf</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>