<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:2.3.1 오라클 문제의 정의: 예상 결과를 산출하기 어렵거나 불가능한 상황</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>2.3.1 오라클 문제의 정의: 예상 결과를 산출하기 어렵거나 불가능한 상황</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 2. 소프트웨어 테스트에서의 오라클(Oracle) 개념과 AI 시대의 역할</a> / <a href="index.html">2.3 오라클 문제(The Oracle Problem)와 자동화의 한계</a> / <span>2.3.1 오라클 문제의 정의: 예상 결과를 산출하기 어렵거나 불가능한 상황</span></nav>
                </div>
            </header>
            <article>
                <h1>2.3.1 오라클 문제의 정의: 예상 결과를 산출하기 어렵거나 불가능한 상황</h1>
<p>소프트웨어 공학의 역사에서 ’테스트 오라클(Test Oracle)’은 개발자가 작성한 코드가 의도한 대로 동작하는지를 판단하는 절대적인 심판관의 역할을 수행해 왔다. 전통적인 결정론적(Deterministic) 알고리즘의 세계에서 오라클의 존재는 자명한 것으로 여겨졌다. <span class="math math-inline">2+2</span>는 반드시 <span class="math math-inline">4</span>여야 했고, 데이터베이스에 저장된 레코드는 정확히 조회되어야 했다. 그러나 소프트웨어의 복잡도가 기하급수적으로 증가하고, 특히 딥러닝과 거대 언어 모델(LLM)과 같은 비결정론적(Nondeterministic) AI 시스템이 소프트웨어 개발의 중심에 서게 됨에 따라, 우리는 심판관이 부재하거나 심판관 자체가 모호한 상황에 직면하게 되었다. 이것이 바로 “오라클 문제(The Oracle Problem)“의 본질이다. 본 절에서는 오라클 문제의 엄밀한 정의와 그 유형, 그리고 왜 이 문제가 현대 AI 기반 소프트웨어 개발에서 가장 치명적인 병목 구간으로 부상했는지를 심층적으로 분석한다.</p>
<h2>1.  오라클 문제의 본질적 정의와 이론적 배경</h2>
<p>오라클 문제는 단순히 “정답을 모른다“는 무지의 상태를 의미하는 것이 아니다. 이는 시스템의 실행 결과가 올바른지 판단하는 메커니즘이 부재하거나, 해당 메커니즘을 구현하는 데 드는 비용이 실제 테스트 수행 비용을 초과하여 경제적으로 불가능한 상태를 총칭한다. 소프트웨어 테스트의 자동화가 비약적으로 발전했음에도 불구하고, 테스트 오라클의 자동화는 여전히 난제로 남아 있으며, 이는 전체 테스트 프로세스의 자동화를 저해하는 주요 병목 요인으로 작용한다.</p>
<h3>1.1  오라클 메커니즘의 수학적 형식화 (Formalization)</h3>
<p>오라클 문제를 엄밀한 수학적 관점에서 정의하기 위해, 테스트 대상 시스템(SUT, System Under Test)을 하나의 함수 <span class="math math-inline">P</span>로 가정한다. 입력 도메인 <span class="math math-inline">D</span>에서 선택된 입력값 <span class="math math-inline">x \in D</span>에 대해 프로그램은 출력값 <span class="math math-inline">y = P(x)</span>를 생성한다. 이때 테스트 오라클 <span class="math math-inline">O</span>는 입력 <span class="math math-inline">x</span>와 관측된 출력 <span class="math math-inline">y</span>를 받아, 그 결과의 정당성을 판별하는 2항 술어 함수(binary predicate function)로 정의될 수 있다.<br />
<span class="math math-display">
O(x, y) \rightarrow \{ \text{Pass}, \text{Fail} \}
</span><br />
이상적인 오라클(Ideal Oracle)은 모든 <span class="math math-inline">x \in D</span>에 대해 <span class="math math-inline">P(x)</span>의 참(Ground Truth) 값인 <span class="math math-inline">y_{expected}</span>를 알고 있어야 하며, 따라서 다음과 같은 비교 연산을 수행한다.<br />
<span class="math math-display">
O(x, y) = \begin{cases}  \text{Pass} &amp; \text{if } y \equiv y_{expected} \\ \text{Fail} &amp; \text{if } y \not\equiv y_{expected}  \end{cases}
</span><br />
여기서 <span class="math math-inline">\equiv</span>는 단순한 등가(Equality)를 넘어, 시스템의 요구사항 명세(Specification)에 정의된 동치 관계(Equivalence Relation)를 의미한다. 예를 들어, 부동소수점 연산에서는 절대적인 일치 대신 허용 오차 <span class="math math-inline">\epsilon</span> 내의 근사 일치를 사용하며, 객체 지향 프로그래밍에서는 객체의 상태(State) 동등성을 비교한다.</p>
<p>**오라클 문제(The Oracle Problem)**는 다음 두 가지 조건 중 하나 이상이 성립할 때 발생한다.</p>
<ol>
<li><strong>오라클의 부재 (Absence):</strong> <span class="math math-inline">y_{expected}</span>를 결정할 수 있는 이론적 또는 실질적인 방법이 존재하지 않는 경우이다. 즉, 함수 <span class="math math-inline">O</span> 자체를 정의할 수 없거나, 정의하더라도 그 신뢰성을 담보할 수 없다. 이는 “정답을 알면 프로그램을 짤 필요가 없는” 역설적 상황에서 자주 발생한다.</li>
<li><strong>오라클 비용의 초과 (Cost Prohibitiveness):</strong> 오라클 함수 <span class="math math-inline">O(x, y)</span>를 계산하는 데 필요한 연산 복잡도나 시간 비용 <span class="math math-inline">C(O)</span>가 프로그램 <span class="math math-inline">P(x)</span>를 실행하는 비용 <span class="math math-inline">C(P)</span>보다 현저히 크거나, 인간의 개입이 필수적이어서 자동화가 불가능한 경우 (<span class="math math-inline">C(O) \gg C(P)</span>)이다. 예를 들어, 암호화 알고리즘의 결과를 검증하기 위해 전수 조사를 수행해야 한다면, 이는 오라클 비용이 기하급수적으로 높아 실현 불가능한 상태가 된다.</li>
</ol>
<p>이러한 정의는 소프트웨어 테스팅의 초기 연구부터 지속적으로 제기되어 왔으며, 특히 분산 시스템이나 비동기 시스템과 같은 복잡한 환경에서 오라클 문제는 NP-Hard 수준의 계산 복잡도를 요구하기도 한다.</p>
<h3>1.2  역사적 기원: Weyuker의 “테스트 불가능한 프로그램”</h3>
<p>오라클 문제에 대한 학문적 논의는 Elaine Weyuker의 1982년 기념비적인 연구 “On Testing Non-testable Programs“에서 본격화되었다. Weyuker는 “테스트 불가능한 프로그램(Non-testable programs)“이라는 용어를 도입하여, 오라클이 존재하지 않거나 오라클을 구축하는 것이 너무 복잡하여 실질적으로 불가능한 프로그램들을 체계적으로 분류하였다.</p>
<p>Weyuker가 제시한 테스트 불가능한 프로그램의 대표적인 예시와 그 함의는 다음과 같다:</p>
<ul>
<li><strong>답을 알 수 없는 문제 (Inherently Unknown Answer):</strong> 복잡한 물리 시뮬레이션, 기상 예측, 또는 새로운 수학적 가설을 검증하는 프로그램이 이에 해당한다. 이러한 프로그램은 정확한 결과값을 사전에 알 수 없기 때문에 작성된다. 만약 정답을 미리 안다면 프로그램을 짤 필요가 없다는 근본적인 모순이 발생한다. 예를 들어, <span class="math math-inline">\sin(42^\circ)</span>의 정확한 값을 모르는 상태에서 <span class="math math-inline">\sin(x)</span> 함수를 테스트해야 하는 상황과 유사하다. 테스터는 결과값이 <span class="math math-inline">-1</span>과 <span class="math math-inline">1</span> 사이여야 한다는 것과 같은 속성은 알 수 있지만, 정확한 값이 무엇인지는 단언할 수 없다.</li>
<li><strong>결과 검증이 불가능한 대량의 출력 (Unverifiable Volume of Output):</strong> 프로그램이 생성하는 데이터의 양이 너무 방대하여 인간이나 다른 기계가 일일이 검증하는 것이 불가능한 경우이다. 예를 들어, 시스템 로그를 10GB 이상 생성하는 프로그램이나, 거대 언어 모델이 생성한 수천 줄의 코드가 여기에 해당한다. 데이터의 양적인 측면이 검증의 질적인 한계를 초래하는 경우로, 이는 현대의 빅데이터 및 생성형 AI 환경에서 더욱 두드러진다.</li>
<li><strong>오해(Misconception)에 의한 오라클 실패:</strong> 테스터가 예상 결과를 잘못 알고 있는 경우, 프로그램이 올바르게 동작하더라도 오라클이 이를 ’실패’로 판정하거나 그 반대의 상황이 발생한다. 이는 “누가 오라클을 검증하는가?(Who tests the oracle?)“라는 재귀적인 질문을 던진다.</li>
</ul>
<p>이러한 고전적인 정의는 현대의 AI 시스템, 특히 생성형 AI(Generative AI)가 직면한 문제와 정확히 맞닿아 있다. 생성형 AI가 작성한 에세이의 ’정답’은 존재하지 않으며, AI가 생성한 수백만 줄의 코드를 인간이 일일이 검증하는 것은 불가능에 가깝다. Weyuker의 통찰은 수십 년이 지난 지금, AI 테스팅이라는 새로운 영역에서 다시금 그 중요성이 부각되고 있다.</p>
<h2>2.  오라클 문제의 현대적 분류와 AI 시대의 심화</h2>
<p>Barr 등이 2015년 “The Oracle Problem in Software Testing: A Survey“에서 집대성한 연구에 따르면, 오라클 문제는 단순히 하나의 현상이 아니라 다양한 원인에 의해 발생하는 다층적인 문제이다. 특히 AI 기반 개발 환경에서는 기존의 결정론적 오라클 부재 문제가 확률론적 불확실성(Probabilistic Uncertainty)과 결합하여 더욱 심화된다.</p>
<h3>2.1  결정론적 오라클의 부재 (The Absence of Deterministic Ground Truth)</h3>
<p>가장 근본적인 오라클 문제는 ‘정답(Ground Truth)’ 자체가 정의되지 않거나 정의하기 매우 어려운 경우이다. 이는 주로 과학적 연산이나 머신러닝 모델에서 관찰된다.</p>
<ul>
<li><strong>과학적 연산 및 시뮬레이션:</strong> 복잡한 편미분 방정식을 푸는 과학 소프트웨어의 경우, 참값(True Value)을 알 수 없기 때문에 수치 해석적 방법을 통해 근사해를 구한다. 이때 프로그램의 출력이 ‘정확한지’ 판단할 수 있는 상위의 오라클은 존재하지 않는다. 단지 결과가 수렴하는지, 물리 법칙에 위배되지 않는지와 같은 간접적인 지표만을 확인할 수 있을 뿐이다.</li>
<li><strong>머신러닝과 비정형 데이터:</strong> 이미지 분류 모델을 테스트할 때, “이 이미지는 고양이이다“라는 라벨은 절대적인 진리가 아니라 인간 어노테이터(Annotator)의 주관적 판단일 뿐이다. 인간 오라클 자체가 오류를 포함할 수 있으며(Label Noise), 관점에 따라 다르게 해석될 수 있는 모호한 데이터의 경우 정답 자체가 존재하지 않는다. 머신러닝 모델의 성능을 평가할 때 ’정확도(Accuracy)’라는 지표를 사용하지만, 이는 오라클의 신뢰성에 전적으로 의존하는 수치이다.</li>
</ul>
<h3>2.2  오라클 비용의 딜레마 (The Cost Dilemma)</h3>
<p>오라클이 이론적으로 존재하더라도, 이를 확보하는 비용이 과도하게 높다면 실질적인 오라클 문제로 간주된다. Barr 등은 이를 “오라클 비용 문제(Oracle Cost Problem)“라고 명명하며, 테스트 자동화의 가장 큰 장애물로 지목했다.</p>
<ul>
<li><strong>인간 오라클(Human Oracle)의 병목:</strong> Barr 등의 설문 조사에 따르면, 자동화된 테스트 도구가 발전했음에도 불구하고 최종적인 판단은 여전히 인간에게 의존하는 경우가 많다. 예를 들어, AI가 생성한 UI 디자인이 “사용자 친화적인가?“를 판단하기 위해서는 인간 전문가의 개입이 필수적이다. 이는 테스트 속도를 저하시키고 자동화 파이프라인(CI/CD)의 흐름을 끊는 주요 원인이 된다. 인간은 피로를 느끼고, 일관성이 부족하며, 처리 속도가 느리다는 점에서 ‘비싼’ 오라클이다.</li>
<li><strong>계산적 난제:</strong> 암호화 알고리즘이나 최적화 문제를 테스트할 때, 주어진 입력에 대한 최적 해를 구하는 것 자체가 NP-Hard 문제일 수 있다. 이 경우 오라클을 실행하는 것이 테스트 대상 프로그램을 실행하는 것보다 더 많은 자원을 소모하게 된다. 분산 시스템 테스팅에서 전체 시스템의 상태 일관성을 검증하는 것 역시 통신 지연과 상태 폭발 문제로 인해 막대한 비용을 유발한다.</li>
</ul>
<h3>2.3  모호성과 주관성의 문제 (Ambiguity and Subjectivity)</h3>
<p>생성형 AI의 등장은 오라클 문제를 ’정확성(Correctness)’의 영역에서 ’적절성(Appropriateness)’과 ’유용성(Utility)’의 영역으로 확장시켰다. 이는 기존의 이진(Binary) 판별 논리로는 해결할 수 없는 새로운 차원의 문제이다.</p>
<ul>
<li><strong>주관적 결과물:</strong> “아름다운 시를 써라“라는 프롬프트에 대한 ChatGPT의 응답이 ‘맞는지’ 틀린지’를 판별하는 결정론적 기준은 없다. 이는 <span class="math math-inline">P(x) = y</span>라는 함수적 관계가 성립하지 않음을 의미한다. 예술적 창작물, 대화의 맥락적 적절성, 윤리적 판단 등은 정량화하기 어려운 주관적 영역에 속하며, 여기서는 “정답” 대신 “선호(Preference)“가 오라클의 역할을 대신한다.</li>
<li><strong>환각(Hallucination)과 그럴듯함:</strong> LLM은 사실이 아닌 내용을 매우 논리적이고 그럴듯하게 생성하는 ‘환각’ 문제를 가지고 있다. 이는 오라클(인간 또는 자동화 도구)이 거짓 양성(False Positive) 판정을 내리게 만든다. 즉, 잘못된 결과를 올바른 것으로 착각하게 만드는 ’기만적 오라클 문제’가 발생한다. 인간 평가자조차 AI의 유창함에 속아 오류를 발견하지 못하는 경우가 빈번하며, 이는 오라클의 신뢰도를 심각하게 훼손한다.</li>
</ul>
<h2>3.  테스트 불가능한 프로그램의 유형학 (Typology of Non-testable Programs)</h2>
<p>Weyuker의 고전적 분류를 현대적 관점, 특히 AI 개발 맥락에서 재해석하면 다음과 같은 세부 유형으로 나눌 수 있다. 이 분류는 우리가 어떤 종류의 오라클 문제에 직면해 있는지 파악하고 적절한 검증 전략을 수립하는 데 필수적이다.</p>
<h3>3.1  결과 예측 불가능형 (Inherently Unknowable Outcome)</h3>
<p>프로그램의 목적 자체가 미지의 값을 찾는 것일 때 발생한다. 이는 ’탐색적 프로그래밍’이나 ’과학적 발견’을 위한 소프트웨어에서 흔히 나타난다.</p>
<ul>
<li><strong>사례:</strong> 새로운 소수의 발견, 복잡한 유체 역학 시뮬레이션, 주가 예측 AI.</li>
<li><strong>특징:</strong> 예상 결과값(<span class="math math-inline">y_{expected}</span>)이 존재하지 않는다. 만약 존재한다면 해당 프로그램은 필요하지 않다.</li>
<li><strong>AI 개발에서의 양상:</strong> 강화학습(Reinforcement Learning) 에이전트가 복잡한 환경(예: 스타크래프트 게임, 자율주행)에서 보여주는 창발적(Emergent) 행동은 사전에 예측할 수 없다. 에이전트가 인간이 생각하지 못한 독창적인 전략으로 승리할 경우, 이를 ’버그’로 볼 것인지 ’혁신’으로 볼 것인지 판단하기 어렵다.</li>
</ul>
<h3>3.2  결과 검증 불가능형 (Verify-Impossible Volume)</h3>
<p>결과는 결정론적일 수 있으나, 그 양이나 복잡도가 인간의 인지 능력을 초과하는 경우이다.</p>
<ul>
<li><strong>사례:</strong> 수 테라바이트의 로그 데이터 분석 결과, LLM이 생성한 100페이지 분량의 법률 문서 검토.</li>
<li><strong>특징:</strong> 오라클 비용(<span class="math math-inline">C(O)</span>)이 무한대로 발산한다. 모든 출력을 전수 검사하는 것은 물리적으로 불가능하므로, 샘플링 검사나 휴리스틱 검사에 의존해야 한다.</li>
<li><strong>AI 개발에서의 양상:</strong> 코드 생성 AI(Copilot 등)가 작성한 복잡한 함수가 겉보기에는 정상적이나, 특정 엣지 케이스(Edge Case)에서 보안 취약점을 포함하고 있는지 검증하기 위해서는 전문 인력이 코드를 한 줄씩 분석해야 한다. 이는 AI가 가져다주는 생산성의 이점을 상쇄시키는 결과를 낳으며, 검증되지 않은 코드가 시스템에 통합되는 리스크를 증가시킨다.</li>
</ul>
<h3>3.3  비결정론적 동작형 (Nondeterministic Behavior)</h3>
<p>동일한 입력에 대해 실행 시마다 다른 결과를 출력하는 시스템이다.</p>
<ul>
<li><strong>사례:</strong> 병렬 처리 시스템, 분산 시스템, 확률적 알고리즘(Monte Carlo simulation).</li>
<li><strong>특징:</strong> <span class="math math-inline">P(x)_t \neq P(x)_{t+1}</span> 일 수 있다. 따라서 단일 실행 결과만으로는 Pass/Fail을 판정할 수 없다. 오라클은 단일 값이 아닌 결과값들의 집합이나 확률 분포를 검증해야 한다.</li>
<li><strong>AI 개발에서의 양상:</strong> Temperature 파라미터가 0이 아닌 LLM은 동일 프롬프트에 대해 매번 다른 응답을 생성한다. 이는 회귀 테스트(Regression Testing)를 극도로 어렵게 만든다. 어제 통과한 프롬프트가 오늘은 실패할 수 있으며, 이것이 모델의 성능 저하(Regression)인지 단순한 확률적 변동(Stochastic Fluctuation)인지 구분하기 어렵다. 이러한 비결정성은 소프트웨어의 재현성(Reproducibility)을 저해하고 디버깅을 어렵게 만든다.</li>
</ul>
<h3>3.4  오라클 편향 및 오류형 (Biased/Error-Prone Oracle)</h3>
<p>오라클(주로 인간)이 편향되거나 오류를 범하는 경우이다.</p>
<ul>
<li><strong>사례:</strong> 주관적인 UI/UX 평가, 크라우드소싱을 통한 데이터 라벨링.</li>
<li><strong>특징:</strong> 오라클의 신뢰도가 <span class="math math-inline">100%</span>가 아니다. <span class="math math-inline">O(x, y)</span> 자체가 확률 변수이다.</li>
<li><strong>AI 개발에서의 양상:</strong> RLHF(Reinforcement Learning from Human Feedback) 과정에서 인간 평가자가 AI의 그럴듯한 거짓말(Sycophancy)에 속아 높은 점수를 주는 경우, 잘못된 오라클 신호가 모델을 잘못된 방향으로 학습시킨다. 또한, 인간 평가자들 사이의 의견 불일치(Inter-annotator Disagreement)는 오라클 자체의 모호성을 드러내며, 모델이 학습해야 할 ’정답’이 무엇인지 혼란스럽게 만든다.</li>
</ul>
<h2>4.  오라클 문제 해결을 위한 타협: 부분 오라클과 근사 오라클</h2>
<p>완벽한 결정론적 오라클을 확보하는 것이 불가능한 상황에서, 소프트웨어 엔지니어링은 ’부분적인 정답’을 찾는 방향으로 진화해 왔다. 이는 오라클 문제의 완전한 해결이 아닌, 현실적인 완화(Mitigation) 전략이다. 이러한 전략들은 오라클의 정확성을 일부 희생하는 대신, 테스트 가능성을 확보하려는 실용적인 접근법이다.</p>
<h3>4.1  부분 오라클 (Partial Oracle)</h3>
<p>부분 오라클은 출력값의 정확한 값을 검증하는 대신, 출력값이 반드시 만족해야 하는 **필수 속성(Necessary Properties)**을 검증한다. 이는 전체적인 정답을 모를 때 유용하다.</p>
<ul>
<li><strong>예시:</strong> <span class="math math-inline">\sin(x)</span>를 계산하는 프로그램에서, <span class="math math-inline">x=30^\circ</span>일 때 정확히 <span class="math math-inline">0.5</span>가 나오는지 확인하는 대신, <span class="math math-inline">-1 \leq \sin(x) \leq 1</span> 범위 내에 있는지 확인한다. 또한, <span class="math math-inline">x</span>가 증가할 때 <span class="math math-inline">\sin(x)</span>도 특정 구간에서 증가해야 한다는 단조성(Monotonicity)을 검증할 수 있다.</li>
<li><strong>한계:</strong> 틀린 답이 범위 내에 존재할 경우(예: <span class="math math-inline">\sin(30^\circ)=0.7</span>), 오류를 검출할 수 없다(False Negative). 즉, 부분 오라클은 필요조건을 검사할 뿐 충분조건을 검사하지 못한다.</li>
</ul>
<h3>4.2  메타모픽 오라클 (Metamorphic Oracle)</h3>
<p>메타모픽 테스팅은 입력값의 변화에 따른 출력값의 **변화 관계(Metamorphic Relation)**를 검증한다. 이는 정답을 몰라도 시스템의 논리적 일관성을 검증할 수 있는 강력한 도구이다.</p>
<ul>
<li><strong>원리:</strong> <span class="math math-inline">P(x)</span>의 정답은 모르지만, <span class="math math-inline">P(x)</span>와 <span class="math math-inline">P(f(x))</span> 사이의 관계는 알 수 있다. 예를 들어, 검색 엔진에서 “AI“를 검색한 결과 집합 <span class="math math-inline">A</span>와, “AI AND Testing“을 검색한 결과 집합 <span class="math math-inline">B</span>가 있다면, 논리적으로 <span class="math math-inline">B \subseteq A</span>여야 한다. 검색 결과의 정확성은 몰라도, 이 포함 관계가 깨지면 오류가 있음을 알 수 있다.</li>
<li><strong>AI 적용:</strong> 자율주행 AI에게 “맑은 날의 도로 이미지(<span class="math math-inline">x</span>)“를 입력했을 때와 “비 오는 날의 도로 이미지(<span class="math math-inline">x&#39;</span>)“를 입력했을 때, 차량 인식 결과는 일관성을 유지해야 한다. 여기서 ’일관성’이 바로 메타모픽 오라클이 된다. 번역 시스템에서 원문(<span class="math math-inline">x</span>)을 번역(<span class="math math-inline">P(x)</span>)하고 다시 역번역(<span class="math math-inline">P&#39;(P(x))</span>)했을 때, 의미가 보존되는지를 확인하는 것도 메타모픽 오라클의 일종이다.</li>
</ul>
<h3>4.3  통계적 오라클 (Statistical Oracle)</h3>
<p>단일 실행 결과의 참/거짓을 판별하는 대신, 다수 실행 결과의 <strong>통계적 분포</strong>를 검증한다. 이는 비결정론적 시스템이나 확률적 알고리즘을 테스트할 때 필수적이다.</p>
<ul>
<li><strong>원리:</strong> 충분히 많은 수의 테스트 케이스를 실행하고, 그 결과의 평균, 분산, 확률 분포가 예상되는 이론적 분포와 일치하는지 통계적 가설 검정(Hypothesis Testing)을 통해 확인한다.</li>
<li><strong>AI 적용:</strong> 챗봇의 응답 품질을 측정할 때, 단일 응답의 정확성을 따지는 대신 1,000개의 응답에 대한 사용자 만족도 점수의 평균이 이전 버전보다 유의미하게(Significantly) 높은지를 검증한다. 이미지 생성 모델의 경우, 생성된 이미지들의 통계적 특성(예: FID score)이 실제 이미지 데이터셋의 분포와 얼마나 유사한지를 측정하여 오라클로 활용한다.</li>
</ul>
<h2>5.  결론: AI 시대, 오라클의 재정의</h2>
<p>2.3.1절에서 살펴본 바와 같이, 오라클 문제는 단순히 테스트 자동화의 걸림돌 수준을 넘어 AI 소프트웨어 개발의 근본적인 불확실성을 대변한다. 전통적인 소프트웨어 공학이 “오라클은 존재한다“는 가정 하에 ’어떻게 효율적으로 테스트할 것인가’에 집중했다면, AI 시대의 엔지니어링은 “오라클은 존재하지 않거나 불완전하다“는 전제 하에 **‘어떻게 신뢰를 구축할 것인가’**로 질문을 전환해야 한다.</p>
<p>예상 결과를 산출하기 어렵거나 불가능한 상황은 이제 예외(Exception)가 아니라 표준(Norm)이 되었다. 특히 생성형 AI의 확산은 오라클 문제를 ’결과 검증’의 문제에서 ’가치 판단’의 문제로 확장시켰다. 따라서 우리는 결정론적 정답지(Deterministic Ground Truth)에 대한 집착을 버리고, 확률적 검증, 속성 기반 검증, 메타모픽 관계 검증, 그리고 인간-AI 협업을 통한 하이브리드 오라클 구축으로 나아가야 한다. 이러한 새로운 패러다임 하에서 오라클은 고정된 ’정답’이 아닌, 시스템의 품질을 지속적으로 모니터링하고 보증하는 동적인 ’프로세스’로 재정의된다. 다음 절들에서는 이러한 오라클 문제가 구체적인 테스트 비용 문제와 부분 오라클의 한계로 어떻게 연결되는지 더 깊이 파고들어 본다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>The Oracle Problem in Software Testing: A Survey - Earl Barr, https://earlbarr.com/publications/testoracles.pdf</li>
<li>The Oracle Problem in Software Testing: A Survey - Semantic Scholar, https://www.semanticscholar.org/paper/The-Oracle-Problem-in-Software-Testing%3A-A-Survey-Barr-Harman/0e17ab6c9d31a481c641f2b1760e09ea51ab76cc</li>
<li>Oracles for Distributed Testing - Brunel University Research Archive, https://bura.brunel.ac.uk/bitstream/2438/4659/3/Fulltext.pdf</li>
<li>The Oracle Problem in Software Testing: A Survey, http://www0.cs.ucl.ac.uk/staff/m.harman/tse-oracle.pdf</li>
<li>Testing from Structured Algebraic Specifications: The Oracle Problem, https://www.lfcs.inf.ed.ac.uk/reports/00/ECS-LFCS-00-423/ECS-LFCS-00-423.pdf</li>
<li>On Testing Non-testable Programs - Elaine J. Weyuker, https://homes.cs.washington.edu/~rjust/courses/CSE503/2021_02_12-reading1.pdf</li>
<li>(PDF) On Testing Non-Testable Programs - ResearchGate, https://www.researchgate.net/publication/31504539_On_Testing_Non-Testable_Programs</li>
<li>Testing non-testable programs using association rules - CNR-IRIS, https://iris.cnr.it/retrieve/cd845d9c-e9ab-4cee-8e0b-d1070d2f063b/prod_469241-doc_189977.pdf</li>
<li>On Testing Non-Testable Programs | The Computer Journal, https://academic.oup.com/comjnl/article/25/4/465/366384?source=post_page—————————</li>
<li>Techniques for Testing Scientific Programs Without an Oracle, https://www.cs.colostate.edu/~bieman/Pubs/kanewalaBieman_icsews13secse_preprint.pdf</li>
<li>[2105.01407] A Review on Oracle Issues in Machine Learning - arXiv, https://arxiv.org/abs/2105.01407</li>
<li>Machine Learning Implementation in Automated Software Testing, https://dergipark.org.tr/en/download/article-file/4636250</li>
<li>GenAi: Subjective vs objective outcomes - Orchestrated, https://www.getorchestrated.com/blog/genai-subjective-vs-objective-outcomes</li>
<li>AI Hallucinations 101: It Can’t Handle the Truth • NEOBADGER, https://neobadger.com/resources/ai-hallucinations-101-it-cant-handle-the-truth/</li>
<li>What Are AI Hallucinations? Real Risks in QA - BugBug.io, https://bugbug.io/blog/software-testing/ai-hallucinations/</li>
<li>Using Machine Learning to Generate Test Oracles - arXiv.org, https://arxiv.org/pdf/2107.00906</li>
<li>The Challenges of Testing in a Non-Deterministic World, https://www.sei.cmu.edu/blog/the-challenges-of-testing-in-a-non-deterministic-world/</li>
<li>Can artificial intelligence solve the blockchain oracle problem, https://www.frontiersin.org/journals/blockchain/articles/10.3389/fbloc.2025.1682623/full</li>
<li>Underspecification of Oracle AI - LessWrong, https://www.lesswrong.com/posts/aBRS3x4sPSJ9G6xkj/underspecification-of-oracle-ai</li>
<li>Automatic System Testing of Programs without Test Oracles, https://www.cs.columbia.edu/wp-content/uploads/sites/7/2011/03/3479-Murphy-Amsterdam-ISSTA2009.pdf</li>
<li>(PDF) Test Oracles Using Statistical Methods. - ResearchGate, https://www.researchgate.net/publication/221388345_Test_Oracles_Using_Statistical_Methods</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>