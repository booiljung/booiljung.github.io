<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.2.5 모델 업데이트와 버전 드리프트(Model Drift): API 제공자의 잠수함 패치(Silent Patch)가 미치는 영향</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.2.5 모델 업데이트와 버전 드리프트(Model Drift): API 제공자의 잠수함 패치(Silent Patch)가 미치는 영향</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.2 비결정성(Nondeterminism)의 기술적 근원과 이해</a> / <span>1.2.5 모델 업데이트와 버전 드리프트(Model Drift): API 제공자의 잠수함 패치(Silent Patch)가 미치는 영향</span></nav>
                </div>
            </header>
            <article>
                <h1>1.2.5 모델 업데이트와 버전 드리프트(Model Drift): API 제공자의 잠수함 패치(Silent Patch)가 미치는 영향</h1>
<p>대규모 언어 모델(LLM)을 기반으로 하는 소프트웨어 개발 시스템에서 개발자가 마주하는 가장 까다로운 비결정성의 원천은 외부 API 제공자에 의해 발생하는 모델의 가변성이다. 전통적인 소프트웨어 공학에서 라이브러리의 업데이트는 버전 번호의 변경, 릴리스 노트의 제공, 그리고 개발자의 명시적인 승인 하에 이루어진다. 그러나 서비스형 AI(AI-as-a-Service) 환경에서는 모델의 내부 가중치나 추론 로직이 예고 없이 변경되는 이른바 ’잠수함 패치(Silent Patch)’가 빈번하게 발생하며, 이는 운영 중인 시스템의 성능과 행동 양식을 근본적으로 뒤흔드는 ‘모델 드리프트(Model Drift)’ 현상을 야기한다. 이러한 드리프트는 단순한 성능 저하를 넘어, 고도로 정제된 프롬프트와 비즈니스 로직 간의 정합성을 파괴하며, 결과적으로 결정론적 정답지를 지향하는 소프트웨어 오라클 체계를 무력화한다.</p>
<h2>1. 모델 드리프트의 개념적 정의와 발생 기제</h2>
<p>모델 드리프트란 운영 환경에 배포된 인공지능 모델이 시간의 흐름에 따라 입력 데이터에 대한 출력 분포나 성능 특성이 변화하는 현상을 통칭한다. LLM의 맥락에서 모델 드리프트는 크게 데이터 드리프트(Data Drift)와 개념 드리프트(Concept Drift), 그리고 모델 자체의 업데이트로 인한 버전 드리프트(Version Drift)로 구분된다. 데이터 드리프트는 사용자의 입력 패턴이나 언어 사용 방식이 변하는 외부적 요인에 기인하며, 개념 드리프트는 정답에 대한 기준이나 사용자 기대치가 변하는 주관적 요인을 포함한다. 반면, 버전 드리프트는 API 제공자가 모델의 효율성, 안전성, 혹은 비용 최적화를 위해 수행하는 내부적인 변경 사항에 의해 발생한다.</p>
<p>잠수함 패치는 이러한 버전 드리프트의 가장 악의적인 형태 중 하나로 간주된다. 제공자는 공식적인 버전 식별자(예: gpt-4)를 유지하면서도 내부적으로는 양자화(Quantization) 기술을 적용하거나, 안전 가드레일을 강화하기 위한 미세 조정(Fine-tuning)을 수행하며, 혹은 시스템 프롬프트를 보이지 않게 수정한다. 이러한 패치는 겉보기에 동일한 모델을 호출하고 있음에도 불구하고, 동일한 입력에 대해 어제와는 다른 답변을 내놓게 만든다. 이는 소프트웨어 엔지니어가 통제할 수 없는 변동성을 시스템에 주입하는 행위이며, 결정론적 정답을 검증해야 하는 테스트 시스템 입장에서는 오라클 자체가 움직이는 표적이 되는 것과 같다.</p>
<h3>1.1 모델 드리프트를 유발하는 기술적 요인 분석</h3>
<p>API 제공자가 잠수함 패치를 단행하는 동기는 다양하며, 각 동기에 따른 기술적 조치는 모델의 비결정적 특성을 강화하는 결과를 낳는다.</p>
<table><thead><tr><th><strong>기술적 조치</strong></th><th><strong>목적</strong></th><th><strong>소프트웨어 시스템에 미치는 영향</strong></th></tr></thead><tbody>
<tr><td>양자화 (Quantization)</td><td>추론 속도 향상 및 운영 비용 절감</td><td>미세한 논리적 추론 정밀도 하락 및 출력 분포의 변화</td></tr>
<tr><td>RLHF 재학습</td><td>안전성 강화 및 인간 선호도 일치</td><td>과도한 거부 응답 발생 및 기존 프롬프트의 지시 이행 능력 약화</td></tr>
<tr><td>시스템 프롬프트 주입</td><td>모델 행동 제어 및 브랜드 아이덴티티 강화</td><td>사용자 프롬프트와의 논리적 충돌 및 출력 형식 오염</td></tr>
<tr><td>KV 캐싱 및 하드웨어 최적화</td><td>동시 처리량(Throughput) 증대</td><td>하드웨어 병렬 연산 특성에 의한 미세한 부동소수점 오차 누적</td></tr>
</tbody></table>
<p>이 중 양자화는 특히 심각한 부작용을 초래할 수 있다. 16비트 정밀도의 모델 가중치를 4비트 혹은 그 이하로 압축할 경우, 전체적인 벤치마크 점수는 유지될지언정 특정 엣지 케이스(Edge Case)에서의 추론 능력은 급격히 저하될 수 있다. 연구에 따르면, 양자화 오류는 모델의 후반부 레이어에서 발생하는 잔차 활성화(Residual Activation)의 정밀도에 크게 의존하며, 이는 복잡한 수리적 판단이나 엄격한 데이터 포맷 생성이 필요한 작업에서 결정론적 정답을 벗어나는 원인이 된다.</p>
<h2>2. 잠수함 패치의 실증적 사례 연구</h2>
<p>모델 드리프트의 실체를 규명하기 위한 가장 대표적인 연구 중 하나는 Chen et al. (2023)의 “How is ChatGPT’s behavior changing over time?“이다. 이 연구는 2023년 3월과 6월 사이의 GPT-4 및 GPT-3.5 성능 변화를 정밀하게 분석하였다.</p>
<h3>2.1 수리적 판단 능력의 급격한 변동</h3>
<p>GPT-4의 경우, 2023년 3월 버전은 소수(Prime Number) 판별 과제에서 97.6%의 높은 정확도를 보였으나, 단 3개월 뒤인 6월 버전에서는 2.4%로 정확도가 폭락하였다. 이는 모델이 더 이상 연쇄 생각(Chain-of-Thought) 프롬프트에 따라 단계적으로 사고하지 않고, 결론을 성급하게 도출하는 방식으로 행동 양식이 변했음을 시사한다.</p>
<table><thead><tr><th><strong>평가 모델 (버전)</strong></th><th><strong>수학 문제 정확도</strong></th><th><strong>코드 포맷 오류율</strong></th><th><strong>민감 질문 거부율</strong></th></tr></thead><tbody>
<tr><td>GPT-4 (March 2023)</td><td>97.6%</td><td>낮음</td><td>상대적 낮음</td></tr>
<tr><td>GPT-4 (June 2023)</td><td>2.4%</td><td>높음</td><td>상대적 높음</td></tr>
<tr><td>GPT-3.5 (March 2023)</td><td>7.4%</td><td>낮음</td><td>보통</td></tr>
<tr><td>GPT-3.5 (June 2023)</td><td>86.8%</td><td>높음</td><td>높음</td></tr>
</tbody></table>
<p>이 데이터에서 주목할 점은 성능이 단순히 하락하는 것이 아니라, 특정 영역에서는 개선되고 특정 영역에서는 퇴보하는 ‘드리프트’ 현상이 무작위적으로 발생한다는 것이다. GPT-3.5의 경우 수학 문제 해결 능력은 비약적으로 향상되었으나, 코드 생성 시에는 실행 불가능한 포맷을 출력하는 빈도가 높아졌다. 이러한 비일관성은 개발자가 모델을 신뢰할 수 있는 하부 구조로 취급하는 것을 불가능하게 만든다.</p>
<h3>2.2 코드 생성 및 구조화된 데이터 출력의 붕괴</h3>
<p>소프트웨어 개발 과정에서 LLM을 사용하여 JSON 객체를 생성하거나 코드 스니펫을 작성할 때, 잠수함 패치는 시스템 전체의 장애로 이어진다. Chen et al.의 연구에 따르면, 6월 버전의 모델들은 코드 생성 시 마크다운 코드 블록 안에 불필요한 설명을 덧붙이거나, 코드 자체에 문법적 오류를 포함하는 경우가 잦아졌다. 이는 “JSON 형식으로만 대답하라“는 엄격한 지시(Instruction)가 모델 내부의 안전 가드레일이나 시스템 프롬프트 업데이트에 의해 무력화되었음을 의미한다.</p>
<h3>2.3 Anthropic Claude와 Google Gemini의 사례</h3>
<p>Claude 모델 역시 유사한 품질 저하 논란에서 자유롭지 못하다. 2025년 중반, Reddit과 같은 개발자 커뮤니티에서는 Claude 3.5 Sonnet과 Haiku 3.5 모델의 출력 품질이 한 달간 비정상적으로 하락했다는 보고가 잇따랐다. Anthropic 측은 이후 두 가지 독립적인 이슈가 모델의 출력 품질에 영향을 미쳤음을 인정하고 이를 수정했다고 밝혔다. 이는 제공자가 의도하지 않았더라도, 서비스 최적화 과정에서 발생하는 미세한 변화가 사용자 환경에서는 파괴적인 결과로 나타날 수 있음을 보여주는 사례다.</p>
<p>Google의 Gemini 모델 역시 ’LLM Grooming’이라 불리는 과정을 통해 특정 정치적 성향이나 안전성 기준에 맞게 지속적으로 미세 조정되며, 이 과정에서 이전에는 잘 수행하던 복잡한 논리 추론 작업이 거부되거나 성능이 저하되는 현상이 보고되고 있다. 이러한 변화는 개발자가 작성한 단위 테스트가 통과되지 않게 만들며, 지속적 통합(CI) 파이프라인에서 예기치 못한 실패를 유발한다.</p>
<h2>3. 모델 드리프트가 소프트웨어 엔지니어링에 미치는 영향</h2>
<p>전통적인 소프트웨어 엔지니어링의 관점에서 모델 드리프트는 극심한 ’기술 부채’의 원천이다. 구글의 연구원들이 발표한 “Machine Learning: The High-Interest Credit Card of Technical Debt” 논문은 이러한 상황을 예견하며, ML 시스템에서 ’무엇 하나를 바꾸면 모든 것이 변한다(CACE: Changing Anything Changes Everything)’는 원칙을 강조한다.</p>
<h3>3.1 프롬프트 취약성 (Prompt Brittleness)</h3>
<p>개발자는 특정 모델 버전의 특성에 맞춰 프롬프트를 미세하게 튜닝한다. 이를 프롬프트 엔지니어링이라 부르지만, 실제로는 모델의 특정 가중치 분포에 운 좋게 맞춘 ’프롬프트 해킹’에 가까운 경우가 많다. 잠수함 패치로 인해 모델의 내부 분포가 변하면, 기존에 완벽하게 작동하던 프롬프트는 즉시 취약해진다. 모델이 더 이상 특정 키워드에 반응하지 않거나, 답변의 길이가 짧아지거나, 혹은 지나치게 보수적으로 답변하게 되는 것이다. 이는 개발자가 코드를 수정하지 않았음에도 시스템이 망가지는 결과를 초래하며, 이를 수정하기 위해 프롬프트를 다시 작성하고 검증하는 데 막대한 비용이 소요된다.</p>
<h3>3.2 도구 과잉과 선택 오류 (Tool Sprawl and Selection Errors)</h3>
<p>최근의 LLM 애플리케이션은 모델이 외부 API나 도구를 직접 호출하는 ‘에이전틱(Agentic)’ 구조를 취한다. 잠수함 패치는 모델이 도구를 선택하는 능력에도 영향을 미친다. 모델이 유사한 기능을 가진 여러 도구 중에서 잘못된 것을 선택하거나, 도구에 전달할 파라미터를 잘못 해석하는 등의 오류가 발생한다. 이는 특히 복잡한 비즈니스 로직을 자동화하는 시스템에서 심각한 데이터 오염이나 잘못된 트랜잭션을 유발할 수 있는 보안 위협이 된다.</p>
<h3>3.3 품질 보증(QA) 및 회귀 테스트의 무력화</h3>
<p>전통적인 단위 테스트는 정적인 입력과 출력을 비교한다. 그러나 모델 드리프트가 발생하면, 동일한 입력에 대해 출력이 확률적으로 변할 뿐만 아니라 그 확률 분포 자체가 이동한다. 이는 기존의 회귀 테스트 데이터셋이 더 이상 모델의 성능을 대표하지 못하게 만든다. 개발자는 모델이 업데이트될 때마다 수천 개의 골든 데이터셋(Golden Dataset)을 다시 실행하고, 정답 여부를 수동으로 재확인해야 하는 늪에 빠지게 된다.</p>
<h2>4. 모델 드리프트의 정량적 측정과 수학적 모델링</h2>
<p>엔지니어링적 대응을 위해서는 드리프트를 ’느낌’이 아닌 수치로 파악해야 한다. 이를 위해 확률 분포 간의 거리를 측정하는 통계적 기법이 도입된다.</p>
<h3>4.1 옌센-섀넌 거리 (Jensen-Shannon Distance, JSD)</h3>
<p>JSD는 두 확률 분포 사이의 유사성을 측정하는 대표적인 지표로, 쿨백-라이블러 발산(KL Divergence)의 대칭적 변형이다. 모델 <span class="math math-inline">P</span>가 업데이트된 모델 <span class="math math-inline">Q</span>로 변했을 때, 출력 토큰의 분포 변화를 다음과 같이 계산한다.<br />
<span class="math math-display">
M = \frac{P + Q}{2}
</span></p>
<p><span class="math math-display">
D_{JS}(P \Vert Q) = \frac{1}{2} D_{KL}(P \Vert M) + \frac{1}{2} D_{KL}(Q \Vert M)
</span></p>
<p>여기서 <span class="math math-inline">D_{JS}</span> 값이 0이면 두 모델의 행동이 완전히 일치함을, 1에 가까워질수록 모델의 성격이 근본적으로 변했음을 의미한다. IBM의 Watsonx.governance와 같은 플랫폼은 이를 활용하여 실시간으로 모델의 예측 드리프트를 모니터링한다.</p>
<h3>4.2 임베딩 거리 (Embedding Distance)</h3>
<p>텍스트 형태의 출력을 벡터 공간으로 투영하여 의미론적 변화를 감지할 수도 있다.</p>
<ul>
<li>유클리드 거리 (<span class="math math-inline">Euclidean\ Distance</span>): 두 응답 벡터 사이의 직선 거리를 계산하여 출력의 중심점이 얼마나 이동했는지 측정한다.</li>
<li>코사인 유사도 (<span class="math math-inline">Cosine\ Similarity</span>): 응답의 방향성을 비교하여 주제나 톤의 변화를 감지한다.</li>
</ul>
<p><span class="math math-display">
Distance_{Euclidean} = \sqrt{\sum_{i=1}^{n} (P_i - Q_i)^2}
</span></p>
<p>이러한 수치적 지표는 시스템이 잠수함 패치에 의해 영향을 받고 있는지 여부를 자동화된 모니터링 알람으로 알려주는 오라클의 하부 구조가 된다.</p>
<h2>5. 드리프트 환경에서의 결정론적 오라클 구축 전략</h2>
<p>잠수함 패치의 위협 속에서 AI 소프트웨어의 신뢰성을 유지하기 위해서는 비결정적인 모델을 결정론적으로 검증할 수 있는 다층적인 방어 체계가 필요하다.</p>
<h3>5.1  골든 데이터셋과 회귀 테스트 자동화</h3>
<p>가장 기본적이면서도 강력한 전략은 ’골든 데이터셋’의 구축이다. 이는 시스템이 반드시 정답을 맞춰야 하는 핵심 질문과 그에 대한 확정적 정답(Ground Truth)의 집합이다. 모델의 잠수함 패치가 의심될 때마다 이 데이터셋을 실행하여 정확도, 지시 이행 능력, 출력 포맷 정합성을 즉시 평가해야 한다. 단순히 통과/실패를 따지는 것을 넘어, 모델의 답변이 이전 버전과 얼마나 유사한지를 BLEU, ROUGE, 혹은 코사인 유사도 지표를 통해 지속적으로 추적해야 한다.</p>
<h3>5.2  LLM-as-a-Judge와 하이브리드 오라클</h3>
<p>모델의 출력이 주관적이거나 요약과 같이 정해진 정답이 없는 경우, 더 강력한 상위 모델(예: GPT-4o나 Claude 3 Opus)을 사용하여 현재 모델의 출력을 평가하는 ‘LLM-as-a-Judge’ 방식을 도입할 수 있다. 그러나 평가 모델 자체도 드리프트의 영향을 받을 수 있으므로, 소수의 샘플에 대해서는 반드시 인간이 개입하여 평가 모델의 정합성을 보정하는 하이브리드 루프(Human-in-the-loop)를 갖추어야 한다.</p>
<h3>5.3  고정 버전 엔드포인트의 사용 및 폴백(Fallback) 설계</h3>
<p>제공자가 “최신 모델“이라며 권장하는 별칭(예: <code>gpt-4-turbo</code>)을 사용하는 대신, 특정 시점의 스냅샷 버전(예: <code>gpt-4-turbo-2024-04-09</code>)을 명시적으로 호출해야 한다. 비록 이 모델도 일정 기간 후에는 지원이 중단되지만, 개발자는 그 사이 업데이트된 모델에 맞춰 시스템을 안정적으로 리팩토링할 시간을 벌 수 있다. 또한, 주 모델에서 드리프트나 성능 저하가 감지될 경우 즉시 다른 제공자의 모델로 전환하거나(Multi-LLM Strategy), 이전 버전의 결과를 캐싱하여 사용하는 폴백 로직을 설계해야 한다.</p>
<h3>5.4  구조화된 출력(Structured Outputs) 강제화</h3>
<p>비결정적인 텍스트 생성의 범위를 좁히기 위해 JSON Schema나 강제 구조화 출력 옵션을 적극적으로 활용해야 한다. 모델이 잠수함 패치 이후에도 반드시 준수해야 하는 ’데이터 계약(Data Contract)’을 명시함으로써, 출력의 형식적 정합성만큼은 결정론적으로 보장받을 수 있다. 만약 모델이 스키마를 준수하지 못하는 응답을 내놓는다면, 이는 즉시 시스템의 오라클에 의해 오류로 감지되어 재시도되거나 차단되어야 한다.</p>
<h2>6. 결론: 비결정성과의 동행을 위한 엔지니어링</h2>
<p>모델 업데이트와 그에 따른 버전 드리프트는 AI 소프트웨어 개발에서 피할 수 없는 숙명이다. API 제공자는 비용과 안전이라는 명목하에 앞으로도 끊임없이 잠수함 패치를 단행할 것이며, 이는 우리가 공들여 세운 소프트웨어의 논리를 수시로 위협할 것이다. 그러나 이러한 비결정성은 결코 무작위적인 혼돈이 아니다. 정량적인 모니터링 지표를 도입하고, 엄격한 골든 데이터셋을 운영하며, 구조화된 데이터 계약을 통해 모델의 행동 범위를 제어한다면, 우리는 움직이는 타겟 위에서도 견고한 소프트웨어를 구축할 수 있다.</p>
<p>결국 모델 드리프트에 대한 대응은 기술적인 문제를 넘어 소프트웨어 개발의 패러다임 변화를 수용하는 과정이다. 정적인 코드가 아닌 역동적인 지능을 부품으로 사용하는 시대에, 엔지니어의 역할은 단 한 번의 정답을 맞추는 것이 아니라, 지속적으로 변화하는 모델의 성능 곡선을 관측하고 이를 비즈니스 요구사항에 맞게 정렬하는 오라클 시스템을 유지 관리하는 것이다. 이것이 바로 비결정성의 한계를 극복하고 AI 소프트웨어의 신뢰성을 극대화하는 실전 엔지니어링의 핵심이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Human-anchored longitudinal comparison of generative AI with a bias-calibrated LLM-as-judge - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC12863567/</li>
<li>arXiv:2307.09009v3 [cs.CL] 31 Oct 2023, https://arxiv.org/abs/2307.09009</li>
<li>You’ve Changed: Detecting Modification of Black-Box Large Language Models - arXiv, https://arxiv.org/html/2504.12335v1</li>
<li>Hidden Technical Debt of GenAI Systems | Databricks Blog, https://www.databricks.com/blog/hidden-technical-debt-genai-systems</li>
<li>Human-in-the-Loop Evals at Scale: Golden Sets, Review Queues &amp; Drift Watch - Kinde, https://kinde.com/learn/ai-for-software-engineering/ai-devops/human-in-the-loop-evals-at-scale-golden-sets-review-queues-drift-watch/</li>
<li>Why AI Projects Fail: Technical Reasons Most Teams Discover Too Late, https://www.clickittech.com/ai/why-ai-projects-fail/</li>
<li>Why AI Output Sometimes Gets Worse After Updates (and How …, https://medium.com/@theDevDesigns/why-ai-output-sometimes-gets-worse-after-updates-and-how-creators-can-protect-their-workflows-05fc32079400</li>
<li>How Quantization Reduces LLM Latency - Latitude.so, https://latitude.so/blog/how-quantization-reduces-llm-latency</li>
<li>Variance-Aware LLM Annotation for Strategy Research: Sources, Diagnostics, and a Protocol for Reliable Measurement - arXiv, https://arxiv.org/html/2601.02370v3</li>
<li>Why Do Some Inputs Break Low-Bit LLM Quantization? - ACL Anthology, https://aclanthology.org/2025.emnlp-main.168.pdf</li>
<li>A Survey of Reinforcement Learning from Human Feedback - Open Access LMU, https://epub.ub.uni-muenchen.de/id/document/675015</li>
<li>AI/ML GPU workload issues - Scouts by Yutori, https://scouts.yutori.com/12c21920-4272-42ab-839f-abb611965c88</li>
<li>How is ChatGPT’s behavior changing over time? - ResearchGate, https://www.researchgate.net/publication/372445224_How_is_ChatGPT’s_behavior_changing_over_time</li>
<li>Lingjiao Chen’s research works | Stanford University and other places - ResearchGate, https://www.researchgate.net/scientific-contributions/Lingjiao-Chen-2176374106</li>
<li>Is the Claude 3.5 sonnet still the most advanced so far? Is there an up-to-date specific comparison receipt for the major LLM? : r/ClaudeAI - Reddit, https://www.reddit.com/r/ClaudeAI/comments/1fxwj8u/is_the_claude_35_sonnet_still_the_most_advanced/</li>
<li>Weekly Cybersecurity Recap: Exploits, Malware, and Breaches | SSOJet News Central - Breaking Boundaries. Building Tomorrow, https://ssojet.com/news/weekly-cybersecurity-recap-exploits-malware-and-breaches</li>
<li>Alerts | Pillar Tech Partners, https://www.ptechcyber.com/alerts</li>
<li>Prediction drift evaluation metric - IBM, https://www.ibm.com/docs/en/waasfgm?topic=metrics-prediction-drift</li>
<li>Input metadata drift evaluation metric - IBM, https://www.ibm.com/docs/en/waasfgm?topic=metrics-input-metadata-drift</li>
<li>Monitoring Embedding/Vector Drift Using Euclidean Distance - Arize AI, https://arize.com/blog-course/embedding-drift-euclidean-distance/</li>
<li>LLM evaluation metrics and methods - Evidently AI, https://www.evidentlyai.com/llm-guide/llm-evaluation-metrics</li>
<li>(PDF) Evaluating Large Language Models in Scientific Discovery - ResearchGate, https://www.researchgate.net/publication/398806449_Evaluating_Large_Language_Models_in_Scientific_Discovery</li>
<li>Feedback on Deprecation of ChatGPT-4o Feb 17, 2026 API Endpoint, https://community.openai.com/t/feedback-on-deprecation-of-chatgpt-4o-feb-17-2026-api-endpoint/1372477</li>
<li>r/kimimania - Reddit, https://www.reddit.com/r/kimimania/</li>
<li>From LLMs to Agents: A Comparative Evaluation of LLMs and LLM-based Agents in Security Patch Detection - ResearchGate, https://www.researchgate.net/publication/397521672_From_LLMs_to_Agents_A_Comparative_Evaluation_of_LLMs_and_LLM-based_Agents_in_Security_Patch_Detection</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>