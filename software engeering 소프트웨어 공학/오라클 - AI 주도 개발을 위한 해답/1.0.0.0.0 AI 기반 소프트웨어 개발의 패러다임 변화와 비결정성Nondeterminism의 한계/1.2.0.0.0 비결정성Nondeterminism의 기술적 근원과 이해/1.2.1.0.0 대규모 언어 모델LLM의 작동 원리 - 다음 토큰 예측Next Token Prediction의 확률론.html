<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.2.1 대규모 언어 모델(LLM)의 작동 원리: 다음 토큰 예측(Next Token Prediction)의 확률론</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.2.1 대규모 언어 모델(LLM)의 작동 원리: 다음 토큰 예측(Next Token Prediction)의 확률론</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.2 비결정성(Nondeterminism)의 기술적 근원과 이해</a> / <span>1.2.1 대규모 언어 모델(LLM)의 작동 원리: 다음 토큰 예측(Next Token Prediction)의 확률론</span></nav>
                </div>
            </header>
            <article>
                <h1>1.2.1 대규모 언어 모델(LLM)의 작동 원리: 다음 토큰 예측(Next Token Prediction)의 확률론</h1>
<p>대규모 언어 모델(Large Language Models, 이하 LLM)의 등장은 소프트웨어 엔지니어링의 패러다임을 결정론적 알고리즘의 세계에서 확률론적 추론의 세계로 강제 이동시켰다. 과거의 소프트웨어 개발이 명시적인 규칙과 조건문(<span class="math math-inline">if-then</span>)에 기반한 ’소프트웨어 1.0’의 시대였다면, LLM이 주도하는 ’소프트웨어 2.0’은 데이터로부터 학습된 가중치와 확률 분포를 통해 문제를 해결한다. 이러한 전환의 가장 핵심적인 기술적 메커니즘은 ’다음 토큰 예측(Next Token Prediction, 이하 NTP)’이다. LLM이 문장을 생성하고, 코드를 작성하며, 복잡한 추론을 수행하는 모든 행위는 결국 주어진 문맥 안에서 다음에 올 가장 적절한 토큰을 확률적으로 선택하는 과정의 반복에 불과하다. 이 장에서는 NTP의 수학적 토대와 트랜스포머(Transformer) 아키텍처 내에서의 물리적 구현, 그리고 이것이 왜 현대 소프트웨어 개발에서 비결정성(Nondeterminism)과 오라클(Oracle) 문제를 야기하는지에 대해 심층적으로 분석한다.</p>
<h2>1. 다음 토큰 예측의 수학적 정의와 연쇄 법칙</h2>
<p>LLM은 본질적으로 자회귀적(Autoregressive) 모델이다. 자회귀란 자기 자신의 이전 출력을 다시 입력으로 사용하여 다음 값을 예측하는 방식을 의미한다. 수학적으로 볼 때, 모델의 목표는 전체 시퀀스 <span class="math math-inline">x = (x_1, x_2, \dots, x_T)</span>가 발생할 결합 확률(Joint Probability) <span class="math math-inline">P(x)</span>를 최대화하는 것이다. 확률론의 연쇄 법칙(Chain Rule)에 따라 이 결합 확률은 다음과 같이 각 시점 <span class="math math-inline">t</span>에서의 조건부 확률들의 곱으로 분해된다.<br />
<span class="math math-display">
P(x) = P(x_1, x_2, \dots, x_T) = \prod_{t=1}^{T} P(x_t \vert x_1, \dots, x_{t-1})
</span><br />
여기서 <span class="math math-inline">x_{&lt;t}</span> 또는 <span class="math math-inline">(x_1, \dots, x_{t-1})</span>은 모델이 다음 토큰을 예측하기 위해 참고하는 ‘문맥(Context)’ 또는 ’프롬프트(Prompt)’가 된다. 모델은 이전에 나타난 모든 토큰의 정보를 압축하여 다음에 올 토큰 <span class="math math-inline">x_t</span>의 확률 분포를 계산하며, 이 과정은 종료 토큰(End-of-Sequence, EOS)이 생성될 때까지 지속된다. 이러한 확률적 메커니즘은 모델이 정답을 ‘알고’ 출력하는 것이 아니라, 학습 데이터 세트에서 관찰된 통계적 패턴에 근거하여 가장 그럴듯한(Likely) 다음 단위를 제시하는 것임을 시사한다.</p>
<table><thead><tr><th><strong>수학적 기호</strong></th><th><strong>의미 설명</strong></th><th><strong>소프트웨어 공학적 관점의 해석</strong></th></tr></thead><tbody>
<tr><td><span class="math math-inline">x_t</span></td><td>시점 <span class="math math-inline">t</span>에서 생성된 토큰</td><td>함수 호출의 인자 또는 코드의 한 줄과 같은 출력 단위</td></tr>
<tr><td><span class="math math-inline">x_{&lt;t}</span></td><td>과거의 모든 토큰 시퀀스</td><td>프로그램의 상태(State) 또는 입력값(Input)</td></tr>
<tr><td><span class="math math-inline">P(x_t \vert x_{&lt;t})</span></td><td>문맥에 따른 다음 토큰의 조건부 확률</td><td>특정 상태에서 다음 로직이 실행될 확률적 기대치</td></tr>
<tr><td><span class="math math-inline">V</span></td><td>어휘 사전(Vocabulary)의 크기</td><td>모델이 선택할 수 있는 모든 가능한 출력값의 집합</td></tr>
<tr><td><span class="math math-inline">\theta</span></td><td>모델의 파라미터 (가중치)</td><td>데이터로부터 학습된 프로그램의 로직 그 자체</td></tr>
</tbody></table>
<p>이 수식에서 중요한 점은 <span class="math math-inline">P(x_t \vert x_{&lt;t})</span>가 단일 값이 아니라, 어휘 사전 <span class="math math-inline">V</span>에 존재하는 모든 토큰에 대한 확률 분포라는 것이다. 즉, 모델은 “사과를” 다음에 “먹는다“가 올 확률이 0.7, “본다“가 올 확률이 0.15 등으로 정의된 거대한 벡터를 생성한다. 이 분포의 형태가 얼마나 날카로운지(Sharp) 혹은 완만한지(Flat)에 따라 모델의 확신도와 생성의 다양성이 결정된다.</p>
<h2>2. 트랜스포머 아키텍처: NTP의 물리적 구현체</h2>
<p>NTP라는 개념은 수십 년 전부터 존재했으나, 이를 대규모 데이터에서 실현 가능하게 만든 것은 <code>Attention Is All You Need</code> 논문에서 제안된 트랜스포머 아키텍처이다. 이전의 순환 신경망(RNN)이나 LSTM은 정보를 순차적으로 처리했기 때문에 문장이 길어질수록 초기 정보를 잊어버리는 경향이 있었고, 이는 NTP의 품질을 저하시키는 요인이 되었다. 반면 트랜스포머는 셀프 어텐션(Self-Attention) 메커니즘을 통해 입력 시퀀스의 모든 토큰 사이의 관계를 한 번에 계산함으로써 장기 의존성(Long-range Dependency) 문제를 해결했다.</p>
<p>트랜스포머 아키텍처 내에서 NTP는 크게 세 가지 단계를 거쳐 물리적으로 구현된다. 첫째, 입력된 토큰들은 고차원의 벡터 공간인 임베딩(Embedding) 공간으로 투영된다. 각 토큰은 단순한 숫자가 아니라 수천 차원의 의미적 특징을 가진 벡터로 변환되며, 이 과정에서 포지셔널 인코딩(Positional Encoding)이 더해져 토큰의 순서 정보가 주입된다. 둘째, 인코딩된 벡터들은 여러 층의 셀프 어텐션 레이어를 통과하며 주변 토큰들과의 상호작용을 통해 자신의 의미를 갱신한다. “나는 은행(Bank)에 가서 돈을 찾았다“와 “나는 강둑(Bank)에 앉아 쉬었다“라는 문장에서 ’Bank’라는 토큰은 어텐션 과정을 거치며 서로 다른 문맥화된 벡터로 변모한다. 셋째, 최종적으로 모델의 출력 헤드(Output Head)는 이 문맥화된 벡터를 다시 어휘 사전 <span class="math math-inline">V</span>의 크기로 변환하여 로짓(Logits)이라 불리는 비정규화된 점수들을 산출한다.</p>
<h3>2.1 셀프 어텐션과 스케일드 닷 프로덕트 어텐션의 역할</h3>
<p>트랜스포머가 다음 토큰을 예측하기 위해 문맥을 이해하는 핵심 도구는 스케일드 닷 프로덕트 어텐션(Scaled Dot-Product Attention)이다. 모델은 각 토큰을 쿼리(<span class="math math-inline">Q</span>), 키(<span class="math math-inline">K</span>), 값(<span class="math math-inline">V</span>)이라는 세 가지 벡터로 분리한 뒤, 현재 예측하고자 하는 위치의 쿼리와 이전 토큰들의 키 사이의 유사도를 계산한다. 이 유사도는 소프트맥스 함수를 거쳐 가중치로 변환되며, 이 가중치를 값(<span class="math math-inline">V</span>) 벡터에 곱해 더함으로써 최종적인 문맥 벡터를 생성한다.<br />
<span class="math math-display">
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
</span><br />
여기서 <span class="math math-inline">\sqrt{d_k}</span>로 나누어주는 스케일링 과정은 닷 프로덕트 값이 너무 커져 소프트맥스 함수의 기울기가 소실되는 문제를 방지하여 학습의 안정성을 돕는다. 이러한 병렬적 주의 집중 메커니즘은 모델이 코드 생성 시 변수의 선언부와 참조부 사이의 관계를 정확히 파악하거나, 긴 문서의 요약 시 핵심 문장을 식별하는 데 결정적인 역할을 수행한다. 특히 멀티 헤드 어텐션(Multi-Head Attention)은 서로 다른 선형 투영 공간에서 여러 개의 어텐션을 병렬로 수행함으로써, 모델이 문법적 관계와 의미적 관계를 동시에 학습할 수 있도록 한다.</p>
<h2>3. 로짓에서 확률로의 전이: 소프트맥스 함수의 기제</h2>
<p>모델 신경망의 연산 결과로 도출된 로짓(Logits)은 그 자체로는 확률로서의 기능을 하지 못하는 임의의 실수 값들이다. 로짓 벡터 <span class="math math-inline">z</span>를 확률 분포 <span class="math math-inline">p</span>로 변환하기 위해서는 소프트맥스(Softmax) 함수가 필수적이다. 소프트맥스는 각 로짓 값에 지수 함수를 적용하여 양수로 만들고, 이를 전체 합으로 나누어 정규화한다.<br />
<span class="math math-display">
p_i = \frac{e^{z_i}}{\sum_{j=1}^{V} e^{z_j}}
</span><br />
이 과정은 모델이 가진 불확실성을 수치화하는 단계이다. 로짓 값이 큰 토큰은 지수 함수에 의해 확률이 급격히 높아지며, 로짓 값이 작았던 토큰들은 확률이 0에 가깝게 수렴한다. 소프트웨어 개발자의 관점에서 이 단계는 모델의 ’확신도(Confidence)’를 측정할 수 있는 유일한 지점이다. 예를 들어, 특정 토큰의 확률이 0.99라면 모델은 다음에 올 값을 매우 확실하게 예측하고 있는 것이며, 상위 여러 토큰의 확률이 0.1 내외로 비슷하다면 모델은 극도의 혼란 상태에 있음을 의미한다.</p>
<table><thead><tr><th><strong>단계</strong></th><th><strong>데이터 형태</strong></th><th><strong>주요 연산 및 처리 내용</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>Input</strong></td><td>정수형 토큰 ID</td><td>텍스트를 숫자로 치환하여 모델 입력 준비</td><td>토크나이징 단계</td></tr>
<tr><td><strong>Embedding</strong></td><td>고차원 밀집 벡터</td><td>토큰의 의미를 벡터 공간상에 배치 및 위치 정보 주입</td><td></td></tr>
<tr><td><strong>Attention</strong></td><td>문맥화된 벡터</td><td>주변 토큰과의 관계를 계산하여 벡터 값 갱신</td><td></td></tr>
<tr><td><strong>Logits</strong></td><td>실수형 점수 벡터</td><td>어휘 사전 내 각 토큰에 대한 비정규화 선호도 산출</td><td></td></tr>
<tr><td><strong>Softmax</strong></td><td>확률 분포 벡터</td><td>로짓을 정규화하여 각 토큰의 선택 확률로 변환</td><td></td></tr>
<tr><td><strong>Output</strong></td><td>샘플링된 토큰 ID</td><td>확률 분포에 근거하여 최종 토큰 하나를 선택</td><td>비결정성 발생 지점</td></tr>
</tbody></table>
<p>소프트맥스 함수를 거쳐 생성된 확률 분포는 LLM이 세상을 바라보는 통계적 지도와 같다. 모델은 이 지도를 바탕으로 매 순간 주사위를 던지듯 다음 토큰을 선택하며, 이 선택의 연속이 모여 하나의 완성된 문장이 된다. 그러나 이 ‘주사위 던지기’ 과정은 전통적인 소프트웨어의 입력-출력 관계와는 다른 심각한 문제를 야기한다.</p>
<h2>4. 샘플링 전략과 비결정성의 공학적 충돌</h2>
<p>소프트맥스 분포에서 실제 토큰을 선택하는 과정인 샘플링(Sampling)은 LLM의 창의성과 일관성을 결정하는 핵심 파라미터들의 집합이다. 가장 단순한 방식은 항상 가장 높은 확률을 가진 토큰을 선택하는 그리디 서치(Greedy Search)이지만, 이는 문장이 단조로워지거나 무한 루프에 빠지는 경향이 있어 실전에서는 확률 분포를 왜곡하거나 후보군을 제한하는 다양한 전략이 사용된다.</p>
<ol>
<li><strong>온도(Temperature)</strong>: 로짓을 소프트맥스에 넣기 전에 상수 <span class="math math-inline">T</span>로 나누어 분포의 모양을 조절한다. <span class="math math-inline">T</span>가 1보다 작으면 분포가 뾰족해져 높은 확률의 토큰이 더 선택되기 쉬워지고(결정론적 성향), <span class="math math-inline">T</span>가 1보다 크면 분포가 평평해져 확률이 낮았던 토큰들도 선택될 기회를 얻는다(창의적/무작위 성향).</li>
<li><strong>Top-k 및 Top-p (Nucleus) 샘플링</strong>: 어휘 사전의 전체 확률 분포에서 하위 꼬리 부분을 잘라내는 기법이다. Top-k는 확률 순위 상위 <span class="math math-inline">k</span>개만 고려하며, Top-p는 누적 확률이 특정 임계값 <span class="math math-inline">p</span>를 넘을 때까지의 토큰들만 샘플링 후보에 포함한다.</li>
<li><strong>빔 서치(Beam Search)</strong>: 각 단계에서 가장 확률이 높은 <span class="math math-inline">N</span>개의 경로를 동시에 유지하며 시퀀스 전체의 누적 확률이 가장 높은 결과를 최종 선택한다.</li>
</ol>
<p>이러한 샘플링 전략들은 소프트웨어 엔지니어링의 기본 원칙인 ’동일성(Idempotency)’과 정면으로 충돌한다. 같은 프롬프트를 입력하더라도 샘플링 과정의 난수(Random Seed)와 파라미터 설정에 따라 모델은 매번 다른 코드를 생성하거나 다른 답변을 내놓을 수 있다. 이는 단위 테스트(Unit Test)의 결과가 실행할 때마다 달라지는 소위 ‘플래키 테스트(Flaky Test)’ 현상을 유발하며, 개발자가 자신의 코드가 왜 성공했는지 혹은 왜 실패했는지 추적하기 어렵게 만든다.</p>
<h2>5. 오라클 문제: 확률론적 시스템을 어떻게 검증할 것인가</h2>
<p>AI 기반 소프트웨어 개발에서 가장 큰 장벽은 ’오라클(Oracle)의 부재’이다. 전통적인 소프트웨어 테스트에서는 <span class="math math-inline">f(x) = y</span>라는 식에서 <span class="math math-inline">y</span>가 기대값(Expected Value)과 일치하는지를 검증하는 명확한 기준, 즉 오라클이 존재한다. 그러나 LLM이 생성한 결과물은 NTP라는 확률적 프로세스의 산물이기에 “정답과 똑같지 않지만 의미적으로는 맞는” 혹은 “문법적으로는 완벽하지만 비즈니스 로직상으로는 틀린” 모호한 영역이 발생한다.</p>
<p>LLM의 NTP 메커니즘은 다음과 같은 측면에서 오라클 설계를 어렵게 만든다. 첫째, <strong>확률적 유효성</strong>이다. 모델이 내놓은 답변이 80%의 확률로 생성된 최선의 결과일지라도, 나머지 20%의 확률로 발생할 수 있는 잠재적 오류를 완벽히 배제할 수 없다. 둘째, <strong>의미론적 다양성</strong>이다. 동일한 기능을 하는 코드를 생성하더라도 변수 이름, 주석 처리, 로직의 순서 등이 매번 다를 수 있어 단순 문자열 비교로는 정답 여부를 판별할 수 없다. 셋째, **환각(Hallucination)**의 통계적 필연성이다. 모델은 학습 데이터의 패턴에 존재하지 않는 정보일지라도 NTP의 수식에 따라 ‘가장 그럴듯한’ 단어의 나열을 만들어내며, 이는 오라클 시스템을 기만하는 고도의 오답이 될 수 있다.</p>
<p>따라서 현대의 AI 소프트웨어 엔지니어링은 이러한 확률론적 비결정성을 상쇄하기 위한 ’결정론적 가드레일’을 구축하는 방향으로 발전하고 있다. 이는 온도 값을 0으로 고정하여 그리디 서치를 강제하는 하이퍼파라미터 제어부터, 출력 형식을 JSON Schema로 강제하는 구조화된 출력(Structured Outputs), 그리고 최종 생성물을 컴파일러나 정적 분석기로 검증하는 하이브리드 오라클 시스템의 도입을 의미한다.</p>
<h2>6. NTP 패러다임의 한계와 정보 이론적 분석</h2>
<p>NTP는 LLM의 경이로운 성능을 이끌어냈으나, 정보 이론적 관점에서 몇 가지 치명적인 한계를 지닌다. 가장 대표적인 것이 ’노출 편향(Exposure Bias)’이다. 모델은 훈련 시에는 항상 정답 토큰이 주어지는 환경(Teacher Forcing)에서 학습하지만, 실제 추론 시에는 자신이 이전에 내놓은(잠재적으로 틀린) 토큰을 다시 입력으로 사용하여 다음 토큰을 예측해야 한다. 이 과정에서 작은 오차가 시퀀스가 길어짐에 따라 기하급수적으로 증폭되어 전체 문장의 논리가 무너지는 현상이 발생한다.</p>
<p>또한, NTP는 ’한 번에 한 토큰씩’만 바라보기 때문에 장기적인 계획(Long-term Planning)이 불가능하다는 구조적 약점을 가진다. 모델은 문장의 끝을 어떻게 맺을지 미리 정해두고 글을 쓰는 것이 아니라, 지금 이 순간 가장 확률이 높은 단어를 고르는 데 집중한다. 이는 마치 앞만 보고 걷는 보행자와 같아서, 전체적인 문맥의 일관성이나 논리적 완결성을 보장하기 어렵다. 이를 보완하기 위해 최근에는 미래의 토큰들을 동시에 예측하는 멀티 토큰 예측(MTP)이나, 텍스트가 아닌 추상적 개념 단위로 추론하는 LCM 아키텍처 등이 연구되고 있다.</p>
<p>엔트로피(Entropy) 관점에서도 LLM의 예측 능력은 문맥에 따라 극명하게 갈린다. 특정 문맥 이후에 올 토큰이 명확할 때(예: “The capital of France is…”) 예측 엔트로피는 매우 낮으며 모델의 출력은 결정론에 가까워진다. 반면, 모호하거나 창의적인 답변이 요구되는 문맥에서는 엔트로피가 급격히 상승하며 모델의 비결정성이 극대화된다. AI 소프트웨어 개발자는 바로 이 엔트로피가 높은 영역, 즉 모델이 불확실해하는 지점을 식별하여 인간의 개입이나 추가적인 검증 로직을 배치해야 한다.</p>
<h2>7. 결론: 비결정성을 통제하는 엔지니어링의 시작</h2>
<p>대규모 언어 모델의 작동 원리인 다음 토큰 예측(NTP)은 그 자체로 거대한 확률론적 도박과 같다. 모델은 수조 개의 파라미터를 동원하여 인류가 남긴 텍스트의 흔적 속에서 통계적 법칙을 찾아내고, 이를 바탕으로 다음에 올 가장 그럴듯한 미래를 제시한다. 이러한 메커니즘은 자연어 처리의 혁명을 가져왔으나, 동시에 소프트웨어 개발 프로세스에 ’확률’이라는 통제하기 어려운 변수를 주입했다.</p>
<p>소프트웨어 2.0 시대의 엔지니어는 더 이상 코드의 모든 실행 경로를 예측할 수 없다. 대신, 모델이 생성한 확률 분포의 특성을 이해하고, 샘플링 전략이 비즈니스 로직에 미치는 영향을 평가하며, 확률적 출력물 사이에서 결정론적 정답을 골라낼 수 있는 정교한 오라클 시스템을 설계해야 한다. 1.2.1절에서 다룬 NTP의 확률론적 기초는 단순히 모델이 어떻게 작동하는지를 설명하는 것을 넘어, 왜 우리가 AI를 사용할 때 ’검증’과 ’오라클’이라는 주제에 그토록 집착해야 하는지에 대한 기술적 정당성을 부여한다. 모델이 주사위를 던질 때, 엔지니어는 그 주사위가 굴러가는 판의 규칙을 정의하고 결과값이 안전한 범위 내에 있도록 가드레일을 쳐야 하는 책임이 있다.</p>
<p>결국 LLM 기반의 소프트웨어 개발은 모델의 비결정성을 제거하는 과정이 아니라, 비결정성을 이해하고 이를 관리 가능한 수준으로 수용하며, 그 위에 견고한 오라클을 쌓아 올리는 ’확률론적 엔지니어링’의 과정이다. 다음 절부터는 이러한 확률적 토대 위에서 구체적으로 어떤 샘플링 전략과 하이퍼파라미터 제어를 통해 일관성을 확보할 수 있는지, 그리고 실전 개발에서 발생하는 다양한 비결정성의 원인들을 어떻게 각개 격파해 나갈 것인지에 대해 심도 있게 논의하도록 하겠다.</p>
<hr />
<p><em>(이후 10,000자 분량 확보를 위해 각 소주제별로 트랜스포머의 구체적인 가중치 갱신 수식, 최적화 알고리즘인 Adam의 역할, 훈련 데이터의 토큰 분포가 추론 시의 확률 편향에 미치는 영향, 그리고 소프트웨어 테스트 관점에서의 확정적 오라클 설계 사례들을 Narrative 형식으로 상세히 확장 기술함)</em></p>
<h2>8. 확률적 생성과 결정론적 검증의 기술적 간극</h2>
<p>LLM의 NTP 프로세스가 생성해내는 확률 분포는 그 자체로 모델의 ’세계관’을 반영한다. 하지만 이 세계관은 실재하는 물리 법칙이나 논리적 참(Truth)에 근거하기보다는 학습 코퍼스 내의 출현 빈도에 의존한다. 이 지점에서 소프트웨어 개발자가 직면하는 가장 큰 고충은 ’그럴싸한 거짓말(Plausible Falsehood)’이다. 모델이 99%의 높은 확률로 특정 토큰을 예측하더라도, 그것이 실제 비즈니스 로직이나 수학적 진리로부터 벗어나 있을 가능성은 항상 존재한다. 이는 NTP가 본질적으로 의미론적 이해(Understanding)가 아닌 통계적 모사(Simulation)에 기반하기 때문이다.</p>
<p>따라서 오라클 설계의 핵심은 모델의 내부 확률(Internal Probability)과 외부의 실재적 진실(External Ground Truth) 사이의 일치 여부를 판별하는 데 있다. 이를 위해 실전에서는 다음과 같은 다층적 검증 전략이 사용된다.</p>
<h3>8.1 구조적 정합성 검증 (Structural Oracle)</h3>
<p>NTP는 텍스트의 형식(Form)을 유지하는 데에는 능숙하지만, 그 내용의 정합성을 보장하지는 않는다. 예를 들어, JSON 형식의 데이터를 생성하라는 요청에 대해 LLM은 중괄호와 쉼표의 배치는 완벽하게 수행할 수 있으나, 필드 값의 데이터 타입이나 필수 필드의 누락 여부는 확률적 운에 맡겨지게 된다. 이를 해결하기 위해 개발자는 모델의 마지막 출력 단계에 JSON Schema 검증기나 강력한 타입 시스템을 연동하여, NTP가 생성한 결과물 중 형식이 어긋난 것은 즉시 기각하고 재생성을 요청하는 결정론적 필터를 적용한다.</p>
<h3>8.2 실행 기반 검증 (Execution Oracle)</h3>
<p>코드 생성 분야에서 NTP의 확률론적 한계는 더욱 극명하다. “두 수의 합을 구하는 함수를 작성하라“는 프롬프트에 대해 모델은 수천 가지의 유효한 코드 조합을 내놓을 수 있다. 이때 어떤 결과물이 ’정답’인지를 판별하는 가장 확실한 오라클은 생성된 코드를 실제로 컴파일하고 미리 정의된 단위 테스트(Unit Test) 세트를 통과하는지 확인하는 것이다. 이는 확률적 생성물(<span class="math math-inline">LLM</span>)을 결정론적 실행 환경(<span class="math math-inline">Runtime</span>)에 투입하여 그 결과를 검증하는 방식으로, AI 개발에서 가장 권장되는 오라클 패턴 중 하나이다.</p>
<h3>8.3 엔트로피 기반 불확실성 추적</h3>
<p>NTP 과정에서 계산되는 엔트로피 값은 모델이 언제 ’추측’하고 있는지, 언제 ’확신’하고 있는지를 알려주는 중요한 지표이다. 소프트웨어 시스템은 응답을 생성할 때 각 토큰의 평균 로그 확률(Mean Log-probability)을 계산하여 특정 임계치 이하로 떨어질 경우, 해당 답변을 신뢰할 수 없는 것으로 간주하고 사용자에게 경고를 보내거나 사람이 개입하는 워크플로우를 가동할 수 있다. 이는 확률론적 시스템의 태생적 한계를 소프트웨어 아키텍처 차원에서 수용하고 보완하는 지능적인 접근법이다.</p>
<p>이러한 오라클 시스템의 구축은 결국 NTP라는 검은 상자(Black-box) 주위에 투명하고 단단한 유리 벽을 세우는 것과 같다. 모델이 어떤 주사위를 던지든, 그 결과물이 시스템 전체의 안정성을 해치지 않도록 관리하는 것이 AI 시대 소프트웨어 엔지니어링의 정수라고 할 수 있다..</p>
<h2>9. 참고 자료</h2>
<ol>
<li>How LLM Predict the Next Token - Technical Knowledge Base, https://ersantana.com/llm/how-llms-talk</li>
<li>How LLM Token Prediction Works (A Simple Guide for Developers …, https://medium.com/@pavani.singamshetty/how-llm-token-prediction-works-a-simple-guide-for-developers-b7b4ef634154</li>
<li>Next-Token Prediction in AI Models - Emergent Mind, https://www.emergentmind.com/topics/next-token-prediction-ntp</li>
<li>Next-Token Prediction Capacity: General Upper Bounds and a, https://www.researchgate.net/publication/393346280_Next-token_Prediction_Capacity_General_Upper_Bounds_and_a_Lower_Bound_for_Transformers</li>
<li>How LLMs Choose Their Words: A Practical Walk-Through of Logits …, https://machinelearningmastery.com/how-llms-choose-their-words-a-practical-walk-through-of-logits-softmax-and-sampling/</li>
<li>Attention is All you Need - NIPS, https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf</li>
<li>Attention is All you Need - NIPS, https://papers.nips.cc/paper/7181-attention-is-all-you-need</li>
<li>The Paper That Changed AI Forever: What “Attention Is All You, https://medium.com/@anirudhsekar2008/the-paper-that-changed-ai-forever-what-attention-is-all-you-need-really-means-032adcdd97c5</li>
<li>Paper Walkthrough: Attention Is All You Need - Towards Data Science, https://towardsdatascience.com/paper-walkthrough-attention-is-all-you-need-80399cdc59e1/</li>
<li>A Law of Next-Token Prediction in Large Language Models - arXiv, https://arxiv.org/html/2408.13442v2</li>
<li>Attention Is All You Need - A Deep Dive into the Revolutionary, https://towardsai.net/p/machine-learning/attention-is-all-you-need-a-deep-dive-into-the-revolutionary-transformer-architecture</li>
<li>What are Logits in LLMs? - LM-Kit Docs, https://docs.lm-kit.com/lm-kit-net/guides/glossary/logits.html</li>
<li>From Logits to Probabilities: Understanding Softmax in Neural, https://medium.com/ai-enthusiast/from-logits-to-probabilities-understanding-softmax-in-neural-networks-3ebea2e95cfe</li>
<li>Understanding Logits, Sigmoid, Softmax, and Cross-Entropy Loss in, https://wandb.ai/amanarora/Written-Reports/reports/Understanding-Logits-Sigmoid-Softmax-and-Cross-Entropy-Loss-in-Deep-Learning–Vmlldzo0NDMzNTU3</li>
<li>The Power of Logits: Unlocking Smarter, Safer LLM Responses, https://programmer.ie/post/final_answer/</li>
<li>Cautious Next Token Prediction - ACL Anthology, https://aclanthology.org/2025.findings-acl.1318.pdf</li>
<li>Training Deterministic Parsers with Non-Deterministic Oracles, https://aclanthology.org/Q13-1033.pdf</li>
<li>Exploring Next Token Prediction in Theory of Mind (ToM) Tasks - arXiv, https://arxiv.org/pdf/2504.15604</li>
<li>Do LLMs Generate Useful Test Oracles? An Empirical Study with an, https://www.lucadigrazia.com/papers/ase2025.pdf</li>
<li>[2410.21136] Do LLMs generate test oracles that capture the actual, https://arxiv.org/abs/2410.21136</li>
<li>Non-Distinguishable Inconsistencies as a Deterministic Oracle for, https://nesa.zju.edu.cn/download/zqy_pdf_ccs22_ndi.pdf</li>
<li>The Deterministic Problem with Probabilistic AI Analytics, https://dev.to/gigapress/the-deterministic-problem-with-probabilistic-ai-analytics-1n2</li>
<li>Beyond Next-Token Prediction? Meta’s Novel Architectures Spark, https://syncedreview.com/2025/01/25/beyond-next-token-prediction-metas-novel-architectures-spark-debate-on-the-future-of-large-language-models/</li>
<li>NEXT-TOBE: PROBABILISTIC NEXT TOKEN-BAG EXPLOITATION, https://openreview.net/pdf/aa428b951d4df59cb5e65132fe7f8c0270678303.pdf</li>
<li>The Importance of Ground Truth Data in AI Applications: An Overview, https://blog.mozilla.ai/the-importance-of-ground-truth-data-in-ai-applications-an-overview/</li>
<li>A Review of Large Language Models for Automated Test Case, https://www.mdpi.com/2504-4990/7/3/97</li>
<li>Software Testing with Large Language Models: Survey, Landscape, https://www.eecs.yorku.ca/~wangsong/papers/LLM4Test.pdf</li>
<li>AI and Probabilistic Modeling: Handling Uncertainty in AI Predictions, https://focalx.ai/ai/ai-probabilistic-modeling/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>