<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.2.4 하드웨어 및 병렬 연산에 의한 비결정성: GPU 부동소수점 연산의 비순차적 처리 특성</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.2.4 하드웨어 및 병렬 연산에 의한 비결정성: GPU 부동소수점 연산의 비순차적 처리 특성</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.2 비결정성(Nondeterminism)의 기술적 근원과 이해</a> / <span>1.2.4 하드웨어 및 병렬 연산에 의한 비결정성: GPU 부동소수점 연산의 비순차적 처리 특성</span></nav>
                </div>
            </header>
            <article>
                <h1>1.2.4 하드웨어 및 병렬 연산에 의한 비결정성: GPU 부동소수점 연산의 비순차적 처리 특성</h1>
<h2>1. 부동소수점 산술의 수학적 한계와 결합법칙의 붕괴</h2>
<p>현대 인공지능 발전의 중추적 역할을 수행하는 그래픽 처리 장치(GPU)는 수만 개의 코어를 활용하여 대규모 병렬 연산을 수행하지만, 이러한 병렬성이 역설적으로 시스템의 결정론(Determinism)을 저해하는 핵심 요인이 된다. 인공지능 모델의 추론과 학습 과정에서 발생하는 비결정성의 가장 근본적인 물리적 원인은 부동소수점 산술의 비결합적(Non-associative) 특성과 GPU의 비순차적 하드웨어 스케줄링이 결합된 결과다.</p>
<p>수학적으로 실수의 덧셈은 결합법칙($ (a + b) + c = a + (b + c) $)을 만족하지만, 컴퓨터가 숫자를 표현하는 방식인 IEEE-754 부동소수점 표준에서는 이 법칙이 성립하지 않는다. 컴퓨터는 무한한 실수를 유한한 비트(Bit) 내에 담기 위해 가수(Mantissa)와 지수(Exponent)를 사용하는 과학적 표기법을 채택하며, 이 과정에서 정밀도를 넘어서는 정보는 반올림(Rounding)되거나 유실된다. 특히 지수부가 크게 차이 나는 두 숫자를 더할 때, 작은 숫자의 하위 비트가 큰 숫자의 정밀도 범위 밖으로 밀려나는 ‘정보 소멸’ 현상이 발생한다.</p>
<p>이러한 수치적 특성은 연산이 수행되는 ’순서’를 결과값의 결정 인자로 만든다. 덧셈의 순서가 바뀌면 중간 단계에서 발생하는 반올림 오차의 양상이 달라지며, 이는 최종 결과값에서 비트 수준의 차이를 유발한다. 대규모 언어 모델(LLM)과 같이 수십억 개의 파라미터를 가진 신경망에서는 이러한 미세한 오차가 각 레이어를 거치며 증폭(Amplify)되고 전파(Propagate)된다.</p>
<p>아래의 테이블은 부동소수점 정밀도에 따른 구조적 차이와 비결정성에 대한 취약성을 요약하여 보여준다.</p>
<table><thead><tr><th><strong>포맷</strong></th><th><strong>총 비트</strong></th><th><strong>가수부 (Precision)</strong></th><th><strong>지수부 (Range)</strong></th><th><strong>비결정성 민감도</strong></th><th><strong>수식 지표 예시 ($ \vert f_{ND} / f_{D} \vert $)</strong></th></tr></thead><tbody>
<tr><td>FP64</td><td>64</td><td>52 bits</td><td>11 bits</td><td>매우 낮음</td><td>$ 1 - \vert f_{ND} / f_{D} \vert \approx 0 $</td></tr>
<tr><td>FP32</td><td>32</td><td>23 bits</td><td>8 bits</td><td>중간</td><td>$ 1 - \vert f_{ND} / f_{D} \vert &lt; 1e-7 $</td></tr>
<tr><td>BF16</td><td>16</td><td>7 bits</td><td>8 bits</td><td>매우 높음</td><td>$ 1 - \vert f_{ND} / f_{D} \vert &gt; 1e-3 $</td></tr>
<tr><td>FP16</td><td>16</td><td>10 bits</td><td>5 bits</td><td>높음</td><td>$ 1 - \vert f_{ND} / f_{D} \vert \approx 1e-4 $</td></tr>
<tr><td>FP8</td><td>8</td><td>2~3 bits</td><td>4~5 bits</td><td>극도로 높음</td><td>$ 1 - \vert f_{ND} / f_{D} \vert \gg 1e-3 $</td></tr>
</tbody></table>
<p>부동소수점 연산에서 발생하는 오차의 정량적 지표인 $ 1 - \vert f_{ND} / f_{D} \vert $를 통해 확인할 수 있듯이, 정밀도가 낮은 BF16이나 FP8 포맷을 사용할수록 연산 순서에 따른 결과값의 변동 폭은 기하급수적으로 커진다. 인공지능 모델들이 성능 향상을 위해 저정밀도 연산을 적극적으로 도입함에 따라, 하드웨어적 비결정성 문제는 무시할 수 없는 엔지니어링적 난제가 되었다.</p>
<h2>2. GPU 아키텍처와 비결정적 스케줄링의 기제</h2>
<p>하드웨어 수준에서 비결정성을 유발하는 직접적인 원인은 GPU의 고도로 병렬화된 실행 모델인 SIMT(Single Instruction, Multiple Threads) 아키텍처에 있다. GPU는 수천 개의 스레드를 동시에 실행하기 위해 복잡한 하드웨어 스케줄러를 사용하며, 이 스케줄러는 처리량(Throughput)을 극대화하기 위해 설계되었다. 이 과정에서 각 스레드나 워프(Warp)의 실행 완료 순서는 매번 동일하게 보장되지 않는다.</p>
<p>GPU 내부의 스트리밍 멀티프로세서(SM)는 수많은 실행 단위를 관리하며, 메모리 접근 지연(Latency), 캐시 히트율, 하드웨어 유닛의 가용성 및 심지어 GPU의 온도 상태에 따라 스레드의 실행 우선순위를 동적으로 조정한다. 이는 스레드들이 전역 메모리나 공유 메모리에 접근하여 값을 업데이트하는 순서를 매 실행마다 미세하게 변화시킨다.</p>
<p>특히 여러 스레드가 하나의 메모리 지점에 결과값을 누적하는 리덕션(Reduction) 연산에서 이러한 스케줄링의 비순차성은 결정론을 무너뜨리는 결정적인 역할을 한다. 비록 <code>atomicAdd</code>와 같은 원자적 연산 명령어가 데이터 레이스(Data Race)를 방지하여 메모리 오염을 막아주지만, ’어떤 값이 먼저 더해질지’에 대한 순서는 보장하지 못하기 때문이다. 부동소수점의 비결합적 특성과 결합된 이 ’순서의 경합(Order Race)’은 동일한 입력에 대해 다른 비트 패턴의 출력을 만들어내는 근본적인 원인이 된다.</p>
<h2>3. 병렬 리덕션 알고리즘과 원자적 연산의 상충 관계</h2>
<p>GPU 프로그래밍에서 대량의 데이터를 합산하거나 통계량을 구하는 리덕션 알고리즘은 성능과 결정론 사이의 치열한 트레이드오프를 보여준다. 개발자가 선택할 수 있는 리덕션 전략은 크게 세 가지 범주로 나뉘며, 각 전략은 비결정성에 노출되는 방식이 다르다.</p>
<p>첫째, 원자적 연산 기반 리덕션(Atomic-based Reduction)은 가장 단순하고 빠르지만 비결정성이 가장 크다. 개별 스레드가 계산한 부분합을 전역 메모리의 특정 위치에 <code>atomicAdd</code>를 사용하여 직접 더하는 방식이다. 이 방식은 메모리 일관성 모델이 약한 GPU에서 스레드 간의 도착 순서에 전적으로 의존하므로, 매번 다른 누적 순서를 갖게 되어 수치적 오차의 발산을 초래한다.</p>
<p>둘째, 트리 기반 리덕션(Tree-based Reduction)은 데이터를 계층적으로 합산하여 논리적인 연산 순서를 고정하는 방식이다. 워프 내 셔플 명령어(<code>__shfl_down_sync</code>)나 공유 메모리를 활용하여 단계별로 합산하기 때문에 이론적으로는 결정론적 결과 유도가 가능하다. 그러나 커널 내부의 동기화 지점(<code>__syncthreads</code>) 증가로 인해 성능 저하가 발생하며, 스레드 블록 간의 최종 합산 과정에서 다시 원자적 연산을 사용할 경우 비결정성이 재유입된다.</p>
<p>셋째, 커널 분할 리덕션(Kernel Decomposition)은 대규모 데이터를 처리할 때 여러 번의 커널 호출로 나누어 각 단계의 결과를 명시적으로 동기화하는 방식이다. 커널 실행 종료 자체가 강력한 전역 동기화 지점이 되므로 재현성이 가장 높지만, 커널 런치 오버헤드로 인해 실시간 성능이 중요한 애플리케이션에서는 기피되기도 한다.</p>
<p>아래 테이블은 리덕션 구현 방식에 따른 성능과 결정론의 상관관계를 비교한다.</p>
<table><thead><tr><th><strong>리덕션 방식</strong></th><th><strong>구현 복잡도</strong></th><th><strong>성능 (Throughput)</strong></th><th><strong>결정론 보장 수준</strong></th><th><strong>비결정성 발생 지점</strong></th></tr></thead><tbody>
<tr><td>Atomic-only</td><td>매우 낮음</td><td>매우 높음</td><td>매우 낮음</td><td>전역 메모리 원자적 업데이트 순서</td></tr>
<tr><td>Shared Memory Tree</td><td>중간</td><td>높음</td><td>중간</td><td>블록 간 최종 결과 합산 시점</td></tr>
<tr><td>Kernel Launch Sync</td><td>높음</td><td>낮음</td><td>매우 높음</td><td>사실상 없음 (하드웨어 레벨 동기화)</td></tr>
<tr><td>Warp-Shuffle</td><td>중간</td><td>매우 높음</td><td>중간</td><td>워프 간 결과 취합 및 기록 순서</td></tr>
</tbody></table>
<h2>4. 딥러닝 라이브러리의 최적화 휴리스틱과 가변성</h2>
<p>하드웨어의 비결정적 특성은 상위 소프트웨어 라이브러리인 NVIDIA cuDNN 및 cuBLAS를 거치면서 더욱 증폭된다. 이러한 라이브러리들은 특정 연산(예: Convolution, Matrix Multiplication)을 처리하기 위해 수십 가지의 서로 다른 알고리즘 커널을 보유하고 있다. 라이브러리는 실행 시점에 텐서의 형태, 메모리 레이아웃, 심지어 GPU의 연산 자원 점유 상태를 분석하여 가장 빠른 알고리즘을 선택하는 휴리스틱 엔진을 작동시킨다.</p>
<p>문제는 이 휴리스틱이 선택하는 알고리즘들이 수치적으로 동일하지 않다는 점이다. 예를 들어, 합성곱(Convolution) 연산에서 Winograd 기반 알고리즘은 성능은 뛰어나지만 부동소수점 오차에 더 민감하며, FFT(Fast Fourier Transform) 기반 알고리즘은 전혀 다른 수치적 특성을 갖는다. <code>torch.backends.cudnn.benchmark = True</code> 설정을 사용하면, cuDNN은 동일한 연산에 대해 여러 알고리즘을 직접 벤치마킹하여 동적으로 커널을 교체한다. 이 과정에서 알고리즘이 바뀌면, 비록 입력값이 동일하더라도 출력값은 비트 수준에서 변동하게 된다.</p>
<p>또한, 배치 크기(Batch Size)의 변화는 라이브러리가 선택하는 최적화 전략을 완전히 바꿀 수 있다. 배치 크기가 1일 때와 128일 때 GPU는 서로 다른 타일링(Tiling) 전략과 리덕션 구조를 가진 커널을 로드할 가능성이 높으며, 이는 결과값의 ‘배치 가변성(Batch Variance)’ 문제를 야기한다. 사용자는 동일한 모델과 입력을 사용한다고 믿지만, 하위 하드웨어와 라이브러리 수준에서는 이미 서로 다른 연산 그래프가 실행되고 있는 것이다.</p>
<h2>5. 텐서 코어(Tensor Cores)와 누적 정밀도의 수치적 영향</h2>
<p>최신 NVIDIA GPU의 핵심 연산 유닛인 텐서 코어는 혼합 정밀도(Mixed Precision) 연산을 가속하기 위해 설계되었다. 텐서 코어는 행렬 곱셈 연산 $ D = C + A \times B $를 수행할 때, 입력인 <span class="math math-inline">A</span>와 <span class="math math-inline">B</span>는 FP16/BF16으로 받되 중간 누적(Accumulation) 과정은 FP32 정밀도로 수행하여 수치적 안정성을 도모한다. 하지만 이러한 하드웨어 가속기 역시 연산 순서에 대한 비결정성에서 자유롭지 못하다.</p>
<p>텐서 코어 내부의 하드웨어 구현 디테일에 따르면, 부분곱(Partial Products)을 합산하는 순서는 공식적으로 지정되어 있지 않으며, 아키텍처 세대(Volta, Ampere, Hopper, Blackwell)에 따라 최적의 하위 알고리즘이 다르게 적용된다. 특히 텐서 코어는 연산 속도를 위해 정밀한 IEEE-754 표준의 반올림 규칙 대신 성능에 최적화된 절단(Truncation)이나 특수한 수치 처리 방식을 사용할 수 있으며, 이는 고도로 병렬화된 환경에서 연산 순서에 따른 결과의 민감도를 높이는 결과를 초래한다.</p>
<p>NVIDIA는 CUDA 13.1과 같은 최신 릴리스에서 <code>NVIDIA CCCL</code>을 통해 ‘GPU-to-GPU’ 재현성 옵션을 강화하고 있지만, 이는 여전히 성능과의 심각한 트레이드오프를 전제로 한다. 성능을 보장하기 위해 도입된 하드웨어 기능들이 역설적으로 결과의 재현성을 방해하는 장애물이 된 셈이다.</p>
<h2>6. LLM 추론 엔진의 최적화가 비결정성에 미치는 영향</h2>
<p>대규모 언어 모델(LLM)을 서비스하는 추론 엔진(vLLM, TensorRT-LLM 등)에서 성능을 높이기 위해 도입하는 기술들은 하드웨어 기반 비결정성을 더욱 심화시키는 촉매제가 된다. 가장 대표적인 사례가 Attention 메커니즘의 최적화 기법들이다.</p>
<p>FlashAttention이나 FlashDecoding과 같은 기법들은 메모리 대역폭 한계를 극복하기 위해 텐서를 작은 조각(Tile)으로 나누어 병렬로 처리한 뒤 합산한다. 이때 ’Split-KV’와 같은 기법을 사용하면 시스템의 부하 상황이나 사용 가능한 SM의 개수에 따라 데이터를 나누는 조각의 개수와 합산하는 순서가 동적으로 변할 수 있다. 이는 개별 토큰의 어텐션 스코어를 계산할 때마다 미세한 수치적 차이를 유발한다.</p>
<p>이러한 수치적 불안정성은 LLM의 자기회귀적(Autoregressive) 특성과 결합되어 거대한 결과의 왜곡으로 이어진다. 모델이 다음 토큰을 선택할 때, 아주 작은 로짓(Logit) 값의 차이로 인해 1순위 후보 토큰이 바뀌게 되면, 그 이후에 생성되는 모든 문장은 원래 의도와 전혀 다른 방향으로 전개된다. 특히 ’Chain of Thought(CoT)’를 수행하는 추론 모델의 경우, 중간 단계의 아주 작은 오차가 논리적 전개의 이탈을 불러일으켜 최종 정답률에 치명적인 영향을 미친다.</p>
<p>“Impacts of floating-point non-associativity on reproducibility for HPC and deep learning applications” 연구와 최근의 LLM 재현성 실험에 따르면, 이러한 하드웨어적 요인으로 인한 결과의 변동성은 다음과 같은 충격적인 데이터를 보여준다.</p>
<table><thead><tr><th><strong>모델 및 정밀도</strong></th><th><strong>하드웨어 환경 변동</strong></th><th><strong>정확도(Accuracy) 변동 폭</strong></th><th><strong>응답 길이 변동 (Tokens)</strong></th></tr></thead><tbody>
<tr><td>DeepSeek-R1 (BF16)</td><td>GPU 개수 및 종류 변경</td><td>최대 9%</td><td>최대 9,000</td></tr>
<tr><td>Llama-3 (FP16)</td><td>배치 크기 변경</td><td>약 1.5%</td><td>약 200</td></tr>
<tr><td>GPT-2 (FP32)</td><td>커널 융합 여부</td><td>&lt; 0.1%</td><td>&lt; 10</td></tr>
</tbody></table>
<p>이 데이터는 하드웨어와 연산 순서에 의한 비결정성이 단순한 ‘오차’ 수준을 넘어 모델의 신뢰성을 근본적으로 뒤흔들 수 있음을 시사한다. 특히 복잡한 사고 과정을 거치는 모델일수록 이러한 비결정성의 파급력은 더욱 강력하게 나타난다.</p>
<h2>7. 결정론적 하드웨어 아키텍처를 향한 시도</h2>
<p>GPU의 구조적 한계를 인식하고 이를 해결하려는 시도 중 하나는 아키텍처 설계 단계부터 결정론을 최우선 가치로 두는 것이다. Groq의 LPU(Language Processing Unit)가 대표적인 사례다. LPU는 GPU와 달리 하드웨어 스케줄러가 없으며, 컴파일러가 모든 연산의 순서와 데이터 이동을 나노초 단위로 미리 결정하여 정적 일정을 수립한다. 이러한 방식은 처리 속도를 보장하면서도 동일한 입력에 대해 비트 수준의 100% 동일한 출력을 보장하는 ’자동 결정론(Automatic Determinism)’을 구현한다.</p>
<p>반면 기존 GPU 진영에서도 이러한 비결정성을 억제하기 위한 노력이 이어지고 있다. 학계에서 제안된 ’Deterministic Atomic Buffering(DAB)’과 같은 구조는 원자적 연산의 결과를 전용 하드웨어 버퍼에 격리한 뒤 정해진 순서대로 가시화함으로써, 성능 저하를 최소화하면서도 결정론적 결과를 얻을 수 있음을 시뮬레이션을 통해 증명하였다. 이는 현재의 GPU 스케줄링 방식이 가진 비결정성이 해결 불가능한 운명이 아니라, 설계의 우선순위에 따른 선택의 문제임을 보여준다.</p>
<h2>8. AI 소프트웨어 엔지니어링의 새로운 오라클 대응 전략</h2>
<p>하드웨어와 병렬 연산에 의한 비결정성은 현대 AI 개발자가 직면한 ’피할 수 없는 진실’이다. 소프트웨어 엔지니어링 1.0의 시대에는 코드의 로직이 동일하면 결과가 동일하다는 가정이 유효했지만, AI 2.0의 시대에는 하드웨어의 미세한 상태 변화까지도 결과의 일부분으로 수용해야 한다.</p>
<p>따라서 결정론적 정답지를 제공해야 하는 오라클(Oracle)을 설계할 때, 엔지니어는 다음과 같은 기술적 대응 전략을 수립해야 한다.</p>
<p>첫째, 수치적 허용 오차(Tolerance)의 동적 정의다. 단순한 비트 매칭 검증 대신, 모델의 정밀도 포맷과 레이어 깊이를 고려한 통계적 오차 범위를 설정하고, 그 범위 내에서의 일관성을 검증하는 적응형 오라클이 필요하다.</p>
<p>둘째, 결정론적 연산 모드의 전략적 활용이다. 성능이 최우선이 아닌 테스트 및 품질 검증 환경에서는 <code>torch.use_deterministic_algorithms(True)</code>와 같은 설정을 강제하고, FP32 이상의 고정밀도 연산을 사용하여 하드웨어 기인 노이즈를 최대한 배제한 ’골든 데이터셋(Golden Dataset)’을 생성해야 한다.</p>
<p>셋째, 하드웨어 추상화 계층에서의 재현성 관리다. GPU 드라이버, CUDA 버전, cuDNN 알고리즘 선택 등을 고정된 컨테이너 환경에서 관리함으로써, 소프트웨어 스택의 변화로 인한 비결정성 전이를 차단해야 한다.</p>
<p>넷째, 비결정성을 감안한 회귀 테스트 설계다. 단일 실행 결과에 의존하기보다 여러 번의 추론 결과를 수집하여 분포의 안정성을 확인하는 다중 실행 검증(Multi-run Verification) 기법을 도입하여, 하드웨어적 일시적 변동성(Transient Variability)을 엔지니어링적으로 격리해야 한다.</p>
<p>하드웨어 수준의 비결정성에 대한 깊은 이해는 AI 기반 소프트웨어의 신뢰성을 확보하기 위한 첫걸음이다. GPU 부동소수점 연산의 비순차적 처리 특성을 명확히 인지하고 그 영향을 정량화할 수 있을 때, 비로소 불확실한 하드웨어 위에서 확정적인 비즈니스 가치를 창출하는 견고한 시스템을 구축할 수 있을 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Presentation - SC24 Schedule, https://sc24.conference-program.com/presentation/?id=ws_corr108&amp;sess=sess759</li>
<li>Solving Reproducibility Challenges in Deep Learning and LLMs: Our Journey - Ingonyama, https://www.ingonyama.com/post/solving-reproducibility-challenges-in-deep-learning-and-llms-our-journey</li>
<li>Defeating Nondeterminism in LLM Inference - Thinking Machines Lab, https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference/</li>
<li>Effects of Floating-Point non-Associativity on Numerical Computations on Massively Multithreaded Systems, https://www.sci.utah.edu/~beiwang/teaching/cs6210-fall-2016/nonassociativity.pdf</li>
<li>Floating Point Precision: Understanding FP64, FP32, and FP16 in Large Language Models, https://dev.to/lukehinds/floating-point-precision-understanding-fp64-fp32-and-fp16-in-large-language-models-3gk6</li>
<li>Floating-point arithmetic - Wikipedia, https://en.wikipedia.org/wiki/Floating-point_arithmetic</li>
<li>Can we prove that floating point addition is not associative? - Quora, https://www.quora.com/Can-we-prove-that-floating-point-addition-is-not-associative</li>
<li>Example of non associative floating point addition - Stack Overflow, https://stackoverflow.com/questions/46769671/example-of-non-associative-floating-point-addition</li>
<li>Deterministic Atomic Buffering - IEEE/ACM International Symposium …, https://www.microarch.org/micro53/papers/738300a981.pdf</li>
<li>(PDF) Impacts of floating-point non-associativity on reproducibility …, https://www.researchgate.net/publication/387848485_Impacts_of_floating-point_non-associativity_on_reproducibility_for_HPC_and_deep_learning_applications</li>
<li>NestedFP: High-Performance, Memory-Efficient Dual-Precision Floating Point Support for LLMs - arXiv, https://arxiv.org/html/2506.02024v2</li>
<li>Achieving Consistency and Reproducibility in Large Language Models (LLMs) | AI Mind, https://pub.aimind.so/creating-deterministic-consistent-and-reproducible-text-in-llms-e589ba230d44</li>
<li>Understanding and Mitigating Numerical Sources of … - OpenReview, https://openreview.net/forum?id=Q3qAsZAEZw</li>
<li>Understanding and Mitigating Numerical Sources of Nondeterminism in LLM Inference, https://arxiv.org/html/2506.09501v2</li>
<li>Non-deterministic behaviour when ran on GPU · Issue #805 · openai/baselines - GitHub, https://github.com/openai/baselines/issues/805</li>
<li>ML Tidbits: Nondeterminism on the GPU | by Tom B Brown - Medium, https://medium.com/tom-b-brown/tensorflow-nondeterminism-on-the-gpu-a0e86125fd06</li>
<li>No, this is not true for GPUs. https://www.twosigma.com/articles/a-workaround-fo… | Hacker News, https://news.ycombinator.com/item?id=37007811</li>
<li>From Von Neumann to CUDA: Do We Need Deterministic CPUs for Real-Time Systems?, https://forums.developer.nvidia.com/t/from-von-neumann-to-cuda-do-we-need-deterministic-cpus-for-real-time-systems/344312</li>
<li>Is TensorRT “floating-point 16 precision mode” non-deterministic on Jetson TX2? - NVIDIA Developer Forums, https://forums.developer.nvidia.com/t/is-tensorrt-ldquo-floating-point-16-precision-mode-rdquo-non-deterministic-on-jetson-tx2/78378</li>
<li>Determinism in Deep Learning (S9911) | NVIDIA, https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9911-determinism-in-deep-learning.pdf</li>
<li>GPU MODE Lecture 9: Reductions - Christian Mills, https://christianjmills.com/posts/cuda-mode-notes/lecture-009/</li>
<li>7 Step Optimization of Parallel Reduction with CUDA | by Rimika Dhara | Medium, https://medium.com/@rimikadhara/7-step-optimization-of-parallel-reduction-with-cuda-33a3b2feafd8</li>
<li>Optimizing Parallel Reduction in CUDA | NVIDIA Developer Technology, https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf</li>
<li>Voting and Shuffling to Optimize Atomic Operations | NVIDIA Technical Blog, https://developer.nvidia.com/blog/voting-and-shuffling-optimize-atomic-operations/</li>
<li>CUDA Deep Neural Network (cuDNN) | NVIDIA Developer, https://developer.nvidia.com/cudnn</li>
<li>cudnn_cnn Library — NVIDIA cuDNN Backend, https://docs.nvidia.com/deeplearning/cudnn/backend/latest/api/cudnn-cnn-library.html</li>
<li>What is the differenc between cudnn.deterministic and .cudnn.benchmark?, https://discuss.pytorch.org/t/what-is-the-differenc-between-cudnn-deterministic-and-cudnn-benchmark/38054</li>
<li>Significantly Different Results Using cuDNN - vision - PyTorch Forums, https://discuss.pytorch.org/t/significantly-different-results-using-cudnn/214089</li>
<li>Why Do I Get Different Results with the Same Deep Learning Model on Different Hardware? - Reddit, https://www.reddit.com/r/deeplearning/comments/1enhqvl/why_do_i_get_different_results_with_the_same_deep/</li>
<li>Release Notes — NVIDIA cuDNN v9.0.0 documentation, https://docs.nvidia.com/deeplearning/cudnn/backend/v9.0.0/release-notes.html</li>
<li>Numerical behavior of NVIDIA tensor cores - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC7959640/</li>
<li>
<ol>
<li>Introduction — PTX ISA 9.1 documentation, https://docs.nvidia.com/cuda/parallel-thread-execution/</li>
</ol>
</li>
<li>Release Notes — NVIDIA cuDNN v9.1.1 documentation, https://docs.nvidia.com/deeplearning/cudnn/backend/v9.1.1/release-notes.html</li>
<li>Release Notes — NVIDIA cuDNN Backend, https://docs.nvidia.com/deeplearning/cudnn/backend/v9.8.0/release-notes.html</li>
<li>NVIDIA CUDA 13.1 Powers Next-Gen GPU Programming with NVIDIA CUDA Tile and Performance Gains | NVIDIA Technical Blog, https://developer.nvidia.com/blog/nvidia-cuda-13-1-powers-next-gen-gpu-programming-with-nvidia-cuda-tile-and-performance-gains/</li>
<li>Release Notes — NVIDIA cuDNN Backend, https://docs.nvidia.com/deeplearning/cudnn/backend/latest/release-notes.html</li>
<li>torch.use_deterministic_algorithms — PyTorch 2.10 documentation, https://docs.pytorch.org/docs/stable/generated/torch.use_deterministic_algorithms.html</li>
<li>Odds and Ends — NVIDIA cuDNN Backend, https://docs.nvidia.com/deeplearning/cudnn/backend/latest/developer/misc.html</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>