<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.2.3 시드(Seed) 값과 난수 생성기의 한계: 동일 시드에서도 발생하는 미세한 차이</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.2.3 시드(Seed) 값과 난수 생성기의 한계: 동일 시드에서도 발생하는 미세한 차이</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.2 비결정성(Nondeterminism)의 기술적 근원과 이해</a> / <span>1.2.3 시드(Seed) 값과 난수 생성기의 한계: 동일 시드에서도 발생하는 미세한 차이</span></nav>
                </div>
            </header>
            <article>
                <h1>1.2.3 시드(Seed) 값과 난수 생성기의 한계: 동일 시드에서도 발생하는 미세한 차이</h1>
<h2>1. 결정론적 소프트웨어의 종언과 의사 난수의 역설</h2>
<p>현대 소프트웨어 공학의 근간은 결정론(Determinism)이라는 확고한 원칙 위에 세워졌다. 특정 입력값이 주어졌을 때 시스템은 언제나 동일한 내부 상태 전이를 거쳐 예측 가능한 동일한 출력값을 산출해야 한다는 이 원칙은 디버깅, 회귀 테스트, 그리고 시스템의 신뢰성 보증을 가능하게 하는 핵심 요소였다. 그러나 인공지능, 특히 딥러닝과 대규모 언어 모델(LLM)이 주도하는 소프트웨어 2.0의 시대에 접어들면서, 이러한 결정론적 세계관은 심각한 도전에 직면한다. 개발자들은 모델의 가중치 초기화나 데이터 샤플링 과정에서 발생하는 무작위성을 통제하기 위해 ’시드(Seed)’라는 도구를 사용하지만, 현실의 복잡한 컴퓨팅 환경에서 시드는 더 이상 완전한 재현성을 보장하지 못하는 불완전한 방어 기제에 불과하다.</p>
<p>시드 값은 의사 난수 생성기(Pseudo-Random Number Generator, PRNG)의 초기 상태를 결정하는 수치적 입력이다. 컴퓨터는 본질적으로 논리적인 연산 장치이기에 진정한 의미의 물리적 무작위성을 생성하는 데 한계가 있으며, 대신 수학적 알고리즘을 통해 무작위처럼 보이는 결정론적 수열을 생성한다. 이론적으로 동일한 PRNG 알고리즘에 동일한 시드 값을 부여하면, 그 결과로 도출되는 난수열은 비트 단위까지 일치해야 한다. 하지만 딥러닝 프레임워크와 병렬 컴퓨팅 하드웨어가 결합된 현대의 인공지능 개발 환경에서는 시드 고정만으로 해결할 수 없는 미세한 수치적 편차가 발생하며, 이는 결과적으로 모델의 출력값을 완전히 바꿔버리는 거대한 비결정성으로 확장된다.</p>
<h2>2. 의사 난수 생성기의 메커니즘과 딥러닝 스택에서의 난수 제어</h2>
<p>딥러닝 파이프라인 전반에는 수많은 확률적 요소가 산재해 있다. 모델의 학습을 시작할 때 가중치를 어떤 분포로 초기화할 것인지, 학습 데이터를 에포크마다 어떤 순서로 섞을 것인지, 드롭아웃 레이어에서 어떤 뉴런을 비활성화할 것인지 등이 모두 난수에 의존한다. 이를 통제하기 위해 개발자들은 보통 소스 코드의 최상단에 전역적인 시드 고정 함수를 배치한다.</p>
<p>다음 표는 딥러닝 프로젝트에서 재현성을 확보하기 위해 통제해야 하는 주요 난수 생성기들과 그 설정 방법을 나타낸다.</p>
<table><thead><tr><th><strong>라이브러리/범주</strong></th><th><strong>설정 함수 및 환경 변수</strong></th><th><strong>통제 대상 및 목적</strong></th></tr></thead><tbody>
<tr><td>Python Built-in</td><td><code>random.seed(seed)</code></td><td>기본 <code>random</code> 모듈의 리스트 샘플링 및 난수 생성 통제</td></tr>
<tr><td>NumPy</td><td><code>np.random.seed(seed)</code></td><td>데이터 전처리 및 행렬 연산 시의 난수 수열 고정</td></tr>
<tr><td>PyTorch (CPU)</td><td><code>torch.manual_seed(seed)</code></td><td>CPU 상에서의 텐서 초기화 및 연산 재현성 확보</td></tr>
<tr><td>PyTorch (GPU)</td><td><code>torch.cuda.manual_seed_all(seed)</code></td><td>모든 GPU 장치에서의 난수 생성기 상태 통일</td></tr>
<tr><td>TensorFlow</td><td><code>tf.random.set_seed(seed)</code></td><td>그래프 실행 및 가중치 초기화 시의 일관성 보장</td></tr>
<tr><td>Python Environment</td><td><code>PYTHONHASHSEED</code></td><td>딕셔너리 객체 등의 해시 생성 시 발생하는 임의성 제거</td></tr>
<tr><td>CUDA Backend</td><td><code>CUBLAS_WORKSPACE_CONFIG</code></td><td>cuBLAS 라이브러리의 결정론적 워크스페이스 설정</td></tr>
</tbody></table>
<p>이처럼 다층적인 시드 고정에도 불구하고, 실제 실행 시에는 미세한 차이가 발생한다. 이는 난수 생성기 자체가 고장 났기 때문이 아니라, 생성된 난수가 실제 연산에 투입되어 하드웨어에서 처리되는 과정이 비결정적이기 때문이다. 특히 멀티 스레딩 환경이나 분산 컴퓨팅 환경에서는 각 스레드나 프로세스가 난수 생성기를 공유하거나 독립적으로 사용하는 과정에서 시퀀스의 순서가 뒤섞일 위험이 상존한다.</p>
<h2>3. 부동소수점 연산의 비결합성과 하드웨어적 수치 불안정성</h2>
<p>동일한 시드에서 결과가 달라지는 가장 근본적이고 물리적인 원인은 부동소수점 산술(Floating-point Arithmetic)의 고유한 특성에서 찾을 수 있다. IEEE 754 표준에 따르는 부동소수점 연산은 실수를 이진수로 근사하여 표현하므로 필연적으로 정밀도의 한계를 지닌다. 가장 결정적인 문제는 부동소수점 덧셈이 수학적으로 결합 법칙(Associative Law)을 만족하지 않는다는 점이다.</p>
<p>수학적으로는 <span class="math math-inline">(a + b) + c</span>와 <span class="math math-inline">a + (b + c)</span>가 동일하지만, 컴퓨터 연산에서는 연산 순서에 따라 반올림 오차(Rounding Error)가 다르게 누적된다. 예를 들어, 매우 큰 수와 매우 작은 수를 더하는 순서가 바뀌면 작은 수의 정보가 사라지는 ‘정밀도 손실(Loss of Significance)’ 현상이 다르게 나타날 수 있다. 딥러닝 모델은 수억 개 이상의 파라미터에 대해 행렬 곱셈과 합산(Reduction)을 반복하므로, 이러한 미세한 오차는 계층을 통과할 때마다 증폭된다.</p>
<p>GPU 아키텍처는 수천 개의 코어가 병렬로 연산을 수행하는 구조를 가지고 있다. 연산의 효율성을 극대화하기 위해 GPU는 스레드의 실행 순서를 엄격하게 보장하지 않으며, 특히 원자적 가산(Atomic Addition)과 같은 연산은 여러 스레드가 공유 메모리에 접근하는 찰나의 순서 차이에 따라 결과값이 달라질 수 있다. 동일한 난수 시드를 사용하여 동일한 초기 가중치를 생성했더라도, 이를 업데이트하는 역전파(Backpropagation) 과정에서 스레드 스케줄링이 달라지면 가중치에 반영되는 수치적 미분값은 비트 단위에서 차이가 발생한다.</p>
<h2>4. GPU 가속 라이브러리의 최적화와 비결정성 알고리즘</h2>
<p>소프트웨어 스택의 상위에 위치한 딥러닝 프레임워크(PyTorch, TensorFlow 등)는 하부에서 NVIDIA의 cuDNN이나 cuBLAS와 같은 가속 라이브러리를 호출한다. 이러한 라이브러리들은 연산 속도를 높이기 위해 다양한 알고리즘을 제공하며, 그중 일부는 본질적으로 비결정적이다.</p>
<p>특히 cuDNN의 컨볼루션 연산은 사용자가 <code>cudnn.benchmark = True</code> 설정을 활성화할 경우, 현재 하드웨어 환경에서 가장 빠른 알고리즘을 찾기 위해 여러 알고리즘을 실제로 실행해 보고 벤치마킹한다. 이 과정에서 선택되는 알고리즘은 시스템의 부하 상태나 미세한 하드웨어 응답 속도에 따라 달라질 수 있으며, 선택된 알고리즘 중 일부는 병렬 합산 순서를 제어하지 않아 결과의 일관성을 해친다.</p>
<table><thead><tr><th><strong>요소</strong></th><th><strong>비결정성 유발 메커니즘</strong></th><th><strong>재현성을 위한 대응책</strong></th></tr></thead><tbody>
<tr><td>cuDNN Convolution</td><td>성능 최적화를 위한 알고리즘 자동 선택(Autotuning)</td><td><code>torch.backends.cudnn.benchmark = False</code></td></tr>
<tr><td>Atomic Operations</td><td>병렬 스레드 간의 비순차적 메모리 쓰기 경쟁</td><td><code>torch.use_deterministic_algorithms(True)</code></td></tr>
<tr><td>cuBLAS Workspace</td><td>행렬 곱셈 연산 시 사용하는 임시 메모리의 가변성</td><td>환경 변수 <code>CUBLAS_WORKSPACE_CONFIG=:4096:8</code> 설정</td></tr>
<tr><td>Sparse Tensors</td><td>희소 텐서 연산 시의 비결정적 인덱싱 및 합산</td><td>전용 결정론적 커널 사용 강제</td></tr>
</tbody></table>
<p>NVIDIA의 연구원들이 발표한 <code>A Stochastic Approach to Handle Non-Determinism in Deep Learning-Based Design Rule Violation Predictions</code> 등에 따르면, 이러한 라이브러리 수준의 비결정성은 특히 미세한 수치 변화에 민감한 회귀 문제나 설계 규칙 위반 예측 모델에서 심각한 오류를 야기할 수 있다. Two Sigma의 엔지니어들은 <code>A Workaround for Non-Determinism in TensorFlow</code>를 통해 <code>tf.reduce_sum</code>과 같은 연산이 GPU 상에서 비결정적으로 작동함을 확인하고, 이를 재현 가능한 행렬 곱셈(<code>matmul</code>) 연산으로 대체하는 기법을 제안하기도 했다.</p>
<h2>5. LLM의 자기회귀적 특성과 수치적 나비 효과</h2>
<p>비결정성의 문제는 최근의 대규모 언어 모델(LLM) 환경에서 더욱 치명적인 양상으로 나타난다. LLM은 이전 토큰들을 기반으로 다음 토큰의 확률 분포를 계산하고 하나를 선택하는 자기회귀적(Autoregressive) 생성 방식을 취한다. 만약 GPU의 병렬 연산 과정에서 발생한 <span class="math math-inline">10^{-7}</span> 수준의 미세한 수치 편차가 특정 토큰의 로짓(Logit) 값을 아주 미세하게 뒤흔든다면, 확률 분포의 최상단에 위치한 두 토큰의 순위가 뒤바뀔 수 있다.</p>
<p>일단 한 번 다른 토큰이 선택되면(예를 들어 ‘A’ 대신 ’The’가 선택되면), 그 이후의 모든 문맥 정보가 달라지며 모델은 완전히 다른 문장을 생성하게 된다. 이는 소위 ’수치적 나비 효과’라고 불리는 현상으로, <span class="math math-inline">Temperature = 0</span>인 그리디 디코딩(Greedy Decoding) 설정을 사용하더라도 동일한 시드 하에 다른 답변이 나오는 근본 원인이 된다. 특히 Mixture of Experts(MoE) 구조를 가진 GPT-4와 같은 모델은 토큰을 여러 전문가 네트워크로 배분하는 라우팅 과정이 수치적 오차에 매우 민감하여 비결정성이 더욱 심화된다.</p>
<p><code>Numerical Precision and Reproducibility in LLM Inference</code> 논문은 BF16이나 FP16과 같은 저정밀도 수치 형식을 사용할 때 이러한 재현성 문제가 더욱 빈번하게 발생함을 입증했다. 이 연구는 추론 엔진인 vLLM이나 Hugging Face Transformers 라이브러리 자체의 문제가 아니라 하드웨어 레벨의 비결합적 연산이 근본 원인임을 밝혀내었으며, 재현성을 위해 특정 구간의 연산을 FP32로 수행하는 <code>LayerCast</code> 기법을 제안했다.</p>
<h2>6. 재현성 위기와 학계의 경고: 실제 사례와 통계</h2>
<p>인공지능 분야의 재현성 위기는 학계에서도 심각하게 다루어지는 주제다. <code>Investigating Reproducibility in Deep Learning-Based Software Fault Prediction</code> 연구는 소프트웨어 결함 예측 분야의 논문 56편을 분석한 결과, 대다수의 연구가 하이퍼파라미터 튜닝이나 전처리 과정의 시드 고정 미흡으로 인해 결과를 재현하는 데 실패했음을 지적했다. 또한 Nature 지에 실린 설문 조사에 따르면, 연구자의 70% 이상이 다른 과학자의 실험을 재현하는 데 실패했으며, 50% 이상은 본인의 과거 실험 결과조차 재현하지 못했다는 충격적인 통계를 보여준다.</p>
<p>특히 보안 분야와 같이 정확성이 생명인 영역에서는 이러한 미세한 차이가 심각한 위협이 된다. <code>Get in Researchers; We're Measuring Reproducibility: A Reproducibility Study of Machine Learning Papers in Tier 1 Security Conferences</code> 논문은 지난 10년간 발표된 머신러닝 보안 논문들을 검토하며, 코드와 데이터가 공유되더라도 하드웨어 및 라이브러리 버전의 비결정성으로 인해 ’비트 단위 재현성(Bit-wise Reproducibility)’을 달성하는 것이 얼마나 불가능에 가까운지 역설한다.</p>
<table><thead><tr><th><strong>연구 제목</strong></th><th><strong>주요 발견 및 통계</strong></th><th><strong>시사점</strong></th></tr></thead><tbody>
<tr><td><code>Reproducibility in Machine Learning-Based Research: Overview, Barriers, and Drivers</code></td><td>ML 연구의 민감도와 무작위성 소스로 인해 대다수 논문이 원칙적으로 재현 불가</td><td>인공지능 연구의 신뢰성 검증 체계 혁신 필요</td></tr>
<tr><td><code>Numerical Precision and Reproducibility in LLM Inference</code></td><td>저정밀도(BF16) 연산이 LLM 추론 결과의 발산을 가속화함</td><td>고정밀도 연산과 결정론적 알고리즘의 트레이드오프 고려</td></tr>
<tr><td><code>On the Reproducibility of Deep Learning</code> (Series)</td><td>코드 공유만으로는 부족하며 실행 환경(HW/SW Stack)의 완전한 고정이 필수적</td><td>컨테이너화 및 환경 명세의 중요성 대두</td></tr>
</tbody></table>
<h2>7. 엔지니어링적 대응: 결정론적 오라클을 향한 실전 기법</h2>
<p>동일한 시드에서도 미세한 차이가 발생한다는 사실은 AI 소프트웨어 개발자들에게 “어떻게 하면 완벽한 정답지를 만들 것인가?“라는 질문 대신 “어떻게 하면 이러한 변동성을 관리 가능한 범위 내로 통제할 것인가?“라는 질문을 던지게 한다. 이를 해결하기 위해 실전 개발에서는 다음과 같은 고도화된 엔지니어링 기법을 도입한다.</p>
<p>첫째, 하드웨어 아키텍처와 라이브러리 버전을 고정하는 것이다. 앞서 언급했듯이 RTX 3090과 RTX 4090은 동일한 코드와 시드에서도 서로 다른 PTX(Parallel Thread Execution) 명령어를 생성하여 결과의 차이를 만든다. 따라서 CI/CD 파이프라인에서 수행되는 모든 테스트는 동일한 GPU 모델, 동일한 드라이버 버전, 그리고 동일한 Docker 이미지 환경에서 실행되어야 한다. Ingonyama의 엔지니어들은 <code>solving-reproducibility-challenges-in-deep-learning-and-llms-our-journey</code> 블로그를 통해, 텐서 코어(Tensor Cores) 대신 상대적으로 하위 호환성이 좋은 일반 CUDA 코어를 사용하고 커스텀 GEMM 커널을 작성하여 하드웨어 간 결과 차이를 극복한 사례를 공유했다.</p>
<p>둘째, 수치적 오차에 강건한 테스트 기법을 도입하는 것이다. 비트 단위의 완벽한 일치(Exact Match)를 검증하는 대신, <code>numpy.allclose</code>와 같은 함수를 사용하여 허용 오차(<span class="math math-inline">\epsilon</span>) 범위 내에 결과값이 들어오는지를 확인하는 방식이다. 이는 부동소수점의 물리적 한계를 인정하면서도 논리적 정합성을 유지하려는 실용적인 접근이다.</p>
<p>셋째, 메타모픽 테스팅(Metamorphic Testing)을 활용하여 오라클 문제를 우회하는 전략이다. 정답(Ground Truth)이 모호하거나 수시로 변하는 AI 시스템에서, 입력값의 특정 변환(예: 이미지 회전, 유의어 교체)에 대해 출력값이 논리적으로 예측 가능한 관계를 유지하는지 검증함으로써 비결정성으로 인한 품질 저하를 탐지할 수 있다.</p>
<h2>8. 결론: 비결정성과의 동행과 새로운 품질 표준</h2>
<p>시드 값과 난수 생성기는 인공지능의 무작위성을 제어하기 위한 가장 기초적인 도구이지만, 그것만으로는 현대 컴퓨팅이 가진 수치적 불안정성을 완전히 극복할 수 없다. 동일한 시드에서도 발생하는 미세한 차이는 하드웨어의 병렬 구조, 부동소수점 수학의 한계, 그리고 가속 라이브러리의 최적화 전략이 얽혀 만들어낸 필연적인 결과물이다.</p>
<p>AI 기반 소프트웨어 개발에서 결정론적 오라클을 구축한다는 것은, 이러한 비결정적 요소를 완전히 제거하는 것이 아니라 그 원천과 범위를 명확히 이해하고 시스템적으로 수용하는 과정을 의미한다. 개발자는 시드 고정을 재현성의 ’보증’이 아닌 ’최소한의 성의’로 보아야 하며, 비트 단위의 일관성보다는 모델의 행동 패턴과 논리적 일관성에 집중한 검증 체계를 설계해야 한다. 인공지능이 가져온 이 확률론적 패러다임 변화는 소프트웨어 테스팅의 대상을 ’확정된 결과’에서 ’통계적 신뢰도’와 ’논리적 변하지 않는 성질(Invariants)’로 전이시키고 있으며, 이는 소프트웨어 공학이 인공지능의 불확실성을 수용하며 한 단계 더 성숙해지는 과정이라 할 수 있다.</p>
<p>결국 1.2.3절에서 논의한 시드의 한계는 개발자에게 겸손함을 요구한다. 우리가 설계한 알고리즘이 아무리 정교하더라도, 그 밑바닥에서 흐르는 전자의 이동과 수천 개의 스레드가 얽히는 병렬 연산의 춤사위는 완벽하게 통제될 수 없다. 이러한 불완전함을 인정하고 그 위에서 견고한 오라클을 쌓아 올리는 것이야말로 AI 시대를 살아가는 엔지니어의 핵심 덕목이 될 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Improving the Reproducibility of Deep Learning Software: An Initial Investigation through a Case Study Analysis - arXiv, https://arxiv.org/html/2505.03165v1</li>
<li>Understanding Determinism Part 1: Intro and Floating Points - Shader Fun, https://shaderfun.com/2020/10/25/understanding-determinism-part-1-intro-and-floating-points/</li>
<li>Solving Reproducibility Challenges in Deep Learning and LLMs …, https://www.ingonyama.com/post/solving-reproducibility-challenges-in-deep-learning-and-llms-our-journey</li>
<li>Deterministic Decoding in Transformer Models: Challenges and Solutions - Medium, https://medium.com/@gwrx2005/deterministic-decoding-in-transformer-models-challenges-and-solutions-3ede45b3d039</li>
<li>Ensuring Consistent Random Outputs for Reproducibility in Machine Learning - Medium, https://medium.com/@stacymacbrains/ensuring-consistent-random-outputs-for-reproducibility-in-machine-learning-9bb23165f5c1</li>
<li>Reproducibility in PyTorch - GeeksforGeeks, https://www.geeksforgeeks.org/deep-learning/reproducibility-in-pytorch/</li>
<li>Reproducibility with Multiple GPUs not working - distributed - PyTorch Forums, https://discuss.pytorch.org/t/reproducibility-with-multiple-gpus-not-working/209583</li>
<li>Inconsistent reproducibility - PyTorch Forums, https://discuss.pytorch.org/t/inconsistent-reproducibility/131335</li>
<li>No, this is not true for GPUs. https://www.twosigma.com/articles/a-workaround-fo… | Hacker News, https://news.ycombinator.com/item?id=37007811</li>
<li>Interlude: Getting reproducible training results with Fast.ai + PyTorch - dronelab.dev, https://dronelab.dev/posts/getting-reproducible-results/</li>
<li>How can floating point calculations be made deterministic? - Stack Overflow, https://stackoverflow.com/questions/7365790/how-can-floating-point-calculations-be-made-deterministic</li>
<li>Are floating point operations deterministic when running in multiple threads?, https://stackoverflow.com/questions/72244777/are-floating-point-operations-deterministic-when-running-in-multiple-threads</li>
<li>Towards Training Reproducible Deep Learning Models - arXiv, https://arxiv.org/pdf/2202.02326</li>
<li>Deterministic Atomic Buffering - IEEE/ACM International Symposium on Microarchitecture, https://www.microarch.org/micro53/papers/738300a981.pdf</li>
<li>A Workaround for Non-Determinism in TensorFlow - Two Sigma, https://www.twosigma.com/articles/a-workaround-for-non-determinism-in-tensorflow/</li>
<li>Reproducibility — PyTorch 2.10 documentation, https://docs.pytorch.org/docs/stable/notes/randomness.html</li>
<li>Rongjian LIANG | Texas A&amp;M University, College Station | TAMU | Department of Computer Science and Engineering | Research profile - ResearchGate, https://www.researchgate.net/profile/Rongjian-Liang-2</li>
<li>Understanding and Mitigating Numerical Sources of Nondeterminism in LLM Inference, https://openreview.net/forum?id=Q3qAsZAEZw</li>
<li>Investigating Reproducibility in Deep Learning-Based Software Fault Prediction - arXiv, https://arxiv.org/abs/2402.05645</li>
<li>The Unreasonable Effectiveness of Open Science in AI: A Replication Study - AAAI Publications, https://ojs.aaai.org/index.php/AAAI/article/view/34818/36973</li>
<li>A Reproducibility Study of machine Learning Papers in Tier 1 Security Conferences - Department of Computer &amp; Information Science &amp; Engineering, https://www.cise.ufl.edu/~butler/pubs/ccs23-olszewski.pdf</li>
<li>Reproducibility in Machine Learning-based Research: Overview, Barriers and Drivers, https://arxiv.org/html/2406.14325v2</li>
<li>Reproducibility in machine‐learning‐based research: Overview, barriers, and drivers, https://www.researchgate.net/publication/390764273_Reproducibility_in_machine-learning-based_research_Overview_barriers_and_drivers</li>
<li>Evaluating the method reproducibility of deep learning models in biodiversity research - PeerJ, https://peerj.com/articles/cs-2618/</li>
<li>Towards Enhancing the Reproducibility of Deep Learning Bugs: An Empirical Study - arXiv, https://arxiv.org/html/2401.03069v1</li>
<li>Why Do I Get Different Results with the Same Deep Learning Model on Different Hardware? - Reddit, https://www.reddit.com/r/deeplearning/comments/1enhqvl/why_do_i_get_different_results_with_the_same_deep/</li>
<li>What is Metamorphic Testing of AI? - testRigor AI-Based Automated Testing Tool, https://testrigor.com/blog/what-is-metamorphic-testing-of-ai/</li>
<li>Testing AI Systems: Handling the Test Oracle Problem - DEV Community, https://dev.to/qa-leaders/testing-ai-systems-handling-the-test-oracle-problem-3038</li>
<li>Reproducibility of Machine Learning: Terminology, Recommendations and Open Issues - ProCAncer-I, https://www.procancer-i.eu/wp-content/uploads/2023/11/2302.12691.pdf</li>
<li>The Oracle Problem - YLD, https://www.yld.io/blog/the-oracle-problem</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>