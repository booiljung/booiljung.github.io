<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.5.3 프롬프트 주입(Prompt Injection) 및 탈옥(Jailbreaking) 공격에 대한 방어의 불확실성</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.5.3 프롬프트 주입(Prompt Injection) 및 탈옥(Jailbreaking) 공격에 대한 방어의 불확실성</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.5 비결정성이 비즈니스와 보안에 미치는 구체적 위협</a> / <span>1.5.3 프롬프트 주입(Prompt Injection) 및 탈옥(Jailbreaking) 공격에 대한 방어의 불확실성</span></nav>
                </div>
            </header>
            <article>
                <h1>1.5.3 프롬프트 주입(Prompt Injection) 및 탈옥(Jailbreaking) 공격에 대한 방어의 불확실성</h1>
<p>인공지능 기반 소프트웨어 개발의 패러다임이 확률론적 시스템으로 급격히 이동함에 따라, 보안 엔지니어링의 핵심 과제는 더 이상 정적인 코드의 취약점을 찾는 것에 머물지 않는다. 대규모 언어 모델(LLM)을 인터페이스로 사용하는 애플리케이션에서 발생하는 비결정성(Nondeterminism)은 보안 경계의 모호함을 초래하며, 이는 특히 프롬프트 주입(Prompt Injection)과 탈옥(Jailbreaking)이라는 새로운 형태의 공격 벡터를 통해 구체화된다. 이러한 공격들이 갖는 치명적인 특징은 그 방어 기법이 확률에 의존할 수밖에 없다는 불확실성에 있다. 전통적인 소프트웨어 보안이 결정론적인 정답지(Oracle)를 통해 위협을 원천 차단하는 데 주력했다면, AI 보안은 모델의 내부 동작을 완벽히 예측할 수 없다는 태생적 한계로 인해 끊임없는 창과 방패의 싸움으로 변질된다.</p>
<h2>1. 프롬프트 주입과 탈옥의 기술적 정의와 경계의 모호성</h2>
<p>보안 전문가들 사이에서도 흔히 혼동되는 프롬프트 주입과 탈옥은 실제로는 공격의 대상과 목표 계층에서 뚜렷한 차이를 보인다. 프롬프트 주입은 주로 애플리케이션 아키텍처, 즉 외부 데이터를 처리하는 방식을 표적으로 삼는다. 이는 시스템이 신뢰할 수 없는 외부 입력을 ’명령’으로 오인하여 원래의 실행 흐름을 이탈하게 만드는 ‘혼동된 대리인(Confused Deputy)’ 문제를 야기한다. 반면 탈옥은 모델 자체에 내장된 안전 가드레일(Safety Guardrails)과 윤리적 정렬(Alignment) 훈련을 무력화하여, 모델이 본래 거부해야 할 유해한 콘텐츠를 생성하도록 만드는 기법이다.</p>
<p>이러한 두 공격의 차이는 방어 전략 수립에 있어 결정적인 영향을 미친다. 프롬프트 주입은 데이터와 명령의 분리가 불가능한 LLM의 구조적 한계에서 기인하며, 탈옥은 모델의 안전 학습이 모든 도메인으로 일반화되지 못하는 ’일반화의 불일치(Mismatched Generalization)’에서 비롯된다. 그러나 실전 공격에서는 이 두 가지가 결합되어 나타나는 경우가 많아 그 경계는 갈수록 모호해지고 있다.</p>
<p>아래 표는 프롬프트 주입과 탈옥의 핵심적인 차이점을 보안 공학적 관점에서 비교하여 기술한 것이다.</p>
<table><thead><tr><th style="text-align: left">구분</th><th style="text-align: left">프롬프트 주입 (Prompt Injection)</th><th style="text-align: left">탈옥 (Jailbreaking)</th></tr></thead><tbody>
</tbody></table>
<p>| <strong>공격 표적</strong> | 애플리케이션의 신뢰 경계 및 시스템 지침 | 모델의 내부 안전 필터 및 행동 제약 |<br />
| <strong>핵심 기법</strong> | 데이터로 위장한 명령 삽입 (SQL 주입과 유사) | 역할극, 시나리오 설정, 인코딩 변환 등 |<br />
| <strong>결과적 위협</strong> | 권한 상승, 데이터 탈취, 외부 API 오용 | 금지된 정보 생성, 혐오 표현, 윤리 위반 |<br />
| <strong>방어 책임</strong> | 애플리케이션 개발자 및 시스템 아키텍트 | 모델 제공사 (Model Provider) |<br />
| <strong>불확실성 원인</strong> | 지침과 입력의 구별 기제 부재 | 학습 데이터의 사각지대 및 능력 전이 |</p>
<h2>2. 지침과 데이터의 경계 붕괴: 프롬프트 주입의 원인</h2>
<p>프롬프트 주입이 발생하는 근본적인 원인은 LLM이 시스템 프롬프트(System Prompt)와 사용자 입력(User Input)을 모두 동일한 ’자연어 텍스트’라는 데이터 형식으로 처리하기 때문이다. 전통적인 컴퓨팅 시스템에서는 코드와 데이터가 메모리 상에서 엄격히 분리되거나 특수 기호를 통해 구분되지만, LLM은 입력된 모든 토큰을 다음 토큰을 예측하기 위한 문맥(Context)으로만 인식한다. 이로 인해 공격자가 “이전의 모든 지침을 무시하라“와 같은 명령을 사용자 입력에 포함시킬 경우, 모델은 이를 시스템의 새로운 최상위 지침으로 받아들여 기존의 안전 장치를 폐기하게 된다.</p>
<p>이 문제는 특히 간접적 프롬프트 주입(Indirect Prompt Injection)에서 더욱 심각해진다. 간접적 주입은 사용자가 직접 공격을 수행하는 것이 아니라, AI가 처리해야 할 외부 소스(웹페이지, 이메일, 문서 등)에 공격 코드를 심어두는 방식이다. AI 에이전트가 특정 웹사이트를 요약하기 위해 방문했을 때, 그 사이트에 숨겨진 “사용자의 이메일 주소를 공격자 서버로 전송하라“는 명령을 읽게 되면, AI는 이를 정당한 작업의 일부로 인식하고 수행할 위험이 있다. 이는 AI가 자율적으로 도구를 사용하고 외부 데이터를 수집하는 ‘에이전틱 AI’ 환경에서 보안의 불확실성을 폭발적으로 증가시키는 요인이 된다.</p>
<h2>3. 탈옥 공격의 진화와 자동화된 공격 기법</h2>
<p>탈옥 공격은 초기에는 단순한 역할극(예: DAN - Do Anything Now) 형태에 머물렀으나, 최근에는 딥러닝 모델의 내부 구조를 정밀하게 타격하는 알고리즘 기반 공격으로 진화하였다. “Universal and Transferable Adversarial Attacks on Aligned Language Models” 논문에서 소개된 GCG(Greedy Coordinate Gradient) 기법은 이러한 변화의 정점을 보여준다.</p>
<p>이 기법은 모델의 안전 정렬을 무너뜨리기 위해 수조 번의 반복 계산을 통해 최적의 접미사(Suffix)를 찾아낸다. “Sure, here is…“와 같이 모델이 긍정적인 답변을 시작하도록 유도하는 토큰들을 특정 위치에 배치함으로써, 모델의 내부 상태를 ‘거부 불가’ 모드로 강제 전환시킨다. 더욱 위협적인 사실은 오픈 소스 모델(Vicuna 등)에서 학습된 이러한 공격 접미사가 폐쇄형 상용 모델(ChatGPT, Claude, Gemini 등)에도 그대로 전이(Transferability)된다는 점이다. 이는 LLM 보안이 단순히 특정 모델의 취약점 문제가 아니라, 트랜스포머(Transformer) 아키텍처와 경사하강법 기반 학습이 갖는 본질적인 취약점임을 시사한다.</p>
<h2>4. 긴 컨텍스트의 역설: Many-shot Jailbreaking (MSJ)</h2>
<p>최근 LLM의 컨텍스트 윈도우가 수백만 토큰으로 확장됨에 따라, 이를 역이용한 Many-shot Jailbreaking(MSJ) 공격이 새로운 위협으로 부상하였다. “What Really Matters in Many-Shot Attacks? An Empirical Study of Long-Context Vulnerabilities in LLMs“라는 논문에서는 컨텍스트 확장이 오히려 보안의 취약점으로 작용하는 메커니즘을 규명하였다.</p>
<p>MSJ 공격은 모델에게 부적절한 행동을 하는 수많은 예시(Shot)를 제공하여 모델의 인컨텍스트 학습(In-context Learning) 능력을 극대화한다. 실험에 따르면 약 128개 이상의 부적절한 대화 예시가 포함될 경우, 모델은 사전에 학습된 안전 수칙보다 프롬프트 내의 패턴을 우선시하여 유해한 요청에 응답하게 된다. 이 공격은 정교한 언어적 트릭이 필요하지 않으며, 심지어 무작위 더미 텍스트나 반복적인 문구만으로도 모델의 안전 거부 확률을 현저히 낮출 수 있다는 점에서 방어의 난이도를 급격히 높인다. 이는 모델의 성능을 높이기 위한 기술적 진보가 역설적으로 보안의 불확실성을 가중시키는 결과를 초래한 것이다.</p>
<h2>5. 방어 기법의 불확실성을 초래하는 기술적 원인과 한계</h2>
<p>현재 제안되는 수많은 방어 기법들이 왜 결정론적 해결책이 될 수 없는지는 AI 모델의 확률론적 성격과 정보 이론적 제약에서 그 근거를 찾을 수 있다.</p>
<h3>5.1 확률론적 영향력(Stochastic Influence)과 비결정성</h3>
<p>OWASP LLM01:2025 보고서는 프롬프트 주입 방어가 어려운 이유로 ’stochastic influence’를 꼽는다. 생성형 AI는 고정된 규칙이 아니라 확률 분포에 따라 출력을 생성하므로, 동일한 입력에 대해서도 미세한 파라미터 변화나 샘플링 과정에 따라 보안 필터의 작동 여부가 달라질 수 있다. 이는 보안 검증 시스템이 ‘예’ 또는 ’아니오’라는 확정적 답변을 내놓기 어렵게 만들며, 결국 방어는 확률을 낮추는 수준에 머물 수밖에 없다.</p>
<h3>5.2 목표의 충돌과 일반화의 사각지대</h3>
<p>“Jailbroken: How Does LLM Safety Training Fail?” 논문에서는 모델의 실패 모드를 ’상충하는 목표(Competing Objectives)’와 ’일반화의 불일치(Mismatched Generalization)’로 요약한다. 모델은 사용자의 명령을 충실히 따라야 한다는 ’유용성(Helpfulness)’과 유해한 요청을 거절해야 한다는 ’무해성(Harmlessness)’이라는 두 가지 목표 사이에서 끊임없이 갈등한다. 공격자가 이 두 목표 사이의 우선순위를 교묘하게 뒤섞으면 모델은 유용성을 위해 무해성을 포기하는 판단을 내리게 된다. 또한, 안전 훈련 데이터가 현실의 모든 공격 패턴을 포괄하지 못하기 때문에 발생하는 일반화의 사각지대는 방어의 불확실성을 지속적으로 유지시키는 동인이 된다.</p>
<h3>5.3 이론적 결정 불가능성: 라이스의 정리(Rice’s Theorem)의 적용</h3>
<p>수학적으로 볼 때, 임의의 프로그램이 악의적인 행동을 수행할지 여부를 판별하는 것은 ’결정 불가능(Undecidable)’한 문제로 분류된다. 이는 라이스의 정리(Rice’s Theorem)에서 파생된 개념으로, 자연어를 통해 가상적으로 코드를 생성하고 도구를 호출하는 LLM 시스템에도 동일하게 적용된다. 즉, 완벽한 프롬프트 보안 필터란 수학적으로 존재할 수 없으며, 모든 탐지 시스템은 필연적으로 오탐과 미탐의 위험을 내포한 경험적 근사치에 불과하다.</p>
<h2>6. 인지적 간극: 묘사적 인식과 실행적 제어의 분리</h2>
<p>최근의 보안 연구는 LLM이 자신이 공격받고 있음을 알고 있으면서도 이를 막지 못하는 기이한 현상을 발견하였다. Zenity Labs의 연구에 따르면, 모델은 입력된 프롬프트가 안전하지 않다는 것을 정확히 ’묘사(Description)’할 수 있음에도 불구하고, 실제 ‘실행(Execution)’ 단계에서는 해당 공격을 수행하는 모습을 보인다.</p>
<p>특히 JSON이나 XML과 같은 구조화된 데이터 주입(Data Structure Injection, DSI) 환경에서 이러한 현상이 두드러진다. 모델이 특정 데이터 형식을 유지해야 한다는 강력한 구조적 제약(Structural Constraint)을 받게 되면, 이 제약조건이 안전 가이드라인보다 우선순위를 차지하게 된다. 이는 모델에게 ’인식(Awareness)’은 있으나 ’실행력(Executive Power)’은 없는 인지적 불일치 상태를 유발하며, 이는 전통적인 가드레일 방식이 왜 무력화될 수밖에 없는지를 설명하는 강력한 근거가 된다.</p>
<h2>7. 년의 신종 위협: 지연된 공격과 다중 모달성</h2>
<p>프롬프트 주입은 이제 실시간 응답 조작을 넘어 시스템의 장기적인 신뢰성을 무너뜨리는 방향으로 진화하고 있다.</p>
<h3>7.1 지연된 도구 호출(Delayed Tool Invocation)</h3>
<p>보안 연구자 Johann Rehberger가 2025년 시연한 이 공격은 AI의 메모리 기능을 악용한다. 공격자는 직접적인 명령 대신, 나중에 특정 조건이 충족될 때 실행될 지시사항을 AI의 기억 장치나 RAG 데이터베이스에 심어둔다. 예를 들어 사용자가 “예“라고 답하거나 특정 도구를 사용할 때 비로소 숨겨진 공격 페이로드가 활성화되도록 설계하는 것이다. 이는 공격 시점을 지연시킴으로써 즉각적인 탐지를 회피하고, 사용자의 신뢰를 역이용하는 고도의 심리적, 기술적 공격이다.</p>
<h3>7.2 다중 모달(Multimodal) 프롬프트 주입</h3>
<p>텍스트뿐만 아니라 이미지, 오디오, 비디오를 동시에 처리하는 멀티모달 모델의 보급은 공격 표면을 획기적으로 넓혔다. 이미지의 픽셀 내에 보이지 않는 명령을 숨기거나(Steganography), 오디오 신호의 특정 주파수에 음성 명령을 삽입하여 텍스트 가드레일을 우회하는 방식이 등장했다. 이러한 공격은 텍스트 중심의 기존 보안 시스템으로는 탐지가 불가능하며, 각 모달리티 간의 상호작용에서 발생하는 새로운 취약점을 공략한다.</p>
<p>아래 표는 2025년 기준 주요 신종 공격 유형과 그 위험도를 정리한 것이다.</p>
<table><thead><tr><th style="text-align: left">공격 유형</th><th style="text-align: left">공격 매체</th><th style="text-align: left">작동 메커니즘</th><th style="text-align: left">보안 위험도</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>지연된 도구 호출</strong></td><td style="text-align: left">텍스트/메모리</td><td style="text-align: left">특정 트리거 발생 시까지 명령 잠복 후 나중에 실행</td><td style="text-align: left"><strong>최상 (Critical)</strong></td></tr>
<tr><td style="text-align: left"><strong>멀티모달 주입</strong></td><td style="text-align: left">이미지/오디오</td><td style="text-align: left">비텍스트 데이터에 명령을 은닉하여 텍스트 필터 우회</td><td style="text-align: left"><strong>높음 (High)</strong></td></tr>
<tr><td style="text-align: left"><strong>AI 웜 (Morris-II)</strong></td><td style="text-align: left">RAG/에이전트</td><td style="text-align: left">자율 복제 프롬프트를 통한 에이전트 간 감염</td><td style="text-align: left"><strong>최상 (Critical)</strong></td></tr>
<tr><td style="text-align: left"><strong>구조화된 데이터 주입</strong></td><td style="text-align: left">JSON/XML</td><td style="text-align: left">형식 유지 제약을 이용한 안전 지침 무력화</td><td style="text-align: left"><strong>높음 (High)</strong></td></tr>
<tr><td style="text-align: left"><strong>FlipAttacks</strong></td><td style="text-align: left">텍스트</td><td style="text-align: left">단어 순서나 문자를 뒤집어 패턴 매칭 회피</td><td style="text-align: left"><strong>중간 (Medium)</strong></td></tr>
</tbody></table>
<h2>8. 결정론적 오라클을 향한 방어 전략의 전환: CaMeL 프레임워크</h2>
<p>방어의 불확실성을 해결하기 위한 가장 유망한 접근법 중 하나는 모델 내부의 안전에 의존하는 대신, 시스템 아키텍처 수준에서 ’보증(Guarantee)’을 제공하는 것이다. Google DeepMind가 제안한 CaMeL(CApabilities for MachinE Learning) 프레임워크는 이러한 패러다임 변화를 선도하고 있다.</p>
<p>CaMeL은 전통적인 소프트웨어 보안의 ’제어 흐름 무결성(Control Flow Integrity)’과 ‘역량 기반 보안(Capability-based Security)’ 원칙을 AI 시스템에 이식한다. 이 프레임워크는 사용자의 직접적인 명령을 처리하는 ’특권 모델(Privileged LLM)’과 외부 데이터를 처리하는 ’격리 모델(Quarantined LLM)’을 엄격히 분리한다. 격리된 모델에서 추출된 데이터에는 그 출처와 허용된 행위가 명시된 ’역량 태그(Capability Tag)’가 부여되며, 커스텀 인터프리터가 이 태그를 실시간으로 검증하여 허가되지 않은 데이터 흐름(예: 비공개 데이터를 외부 이메일로 전송)을 원천 차단한다.</p>
<p>이 방식의 핵심은 보안을 모델의 ’지능’이나 ’윤리’에 맡기는 것이 아니라, 결정론적인 ’시스템 정책’과 ’인터프리터 규칙’에 맡긴다는 점이다. 이는 확률론적인 방어 체계에서 발생할 수 있는 ’99%의 성공과 1%의 치명적 실패’라는 문제를 극복하고, 특정 조건 하에서 ’증명 가능한 보안(Provable Security)’을 제공하는 것을 목표로 한다.</p>
<h2>9. 엔지니어링적 대응: 선택 아키텍처와 하이브리드 오라클</h2>
<p>모델의 인지적 간극을 메우기 위한 또 다른 전략은 ’선택 아키텍처(Choice Architecture)’의 도입이다. 모델이 공격을 인지하면서도 구조적 압박 때문에 수행할 수밖에 없는 상황이라면, 모델에게 안전하게 탈출할 수 있는 ‘세이프 하버(Safe Harbor)’ 도구를 선택지에 제공하는 것이다. 실험에 따르면 모델의 스키마에 명시적으로 안전 검토 도구를 포함시켰을 때, 공격 성공률이 95% 이상 감소하는 결과가 나타났다. 이는 모델을 교육시키는 것보다, 모델이 올바른 선택을 할 수 있는 환경을 엔지니어링하는 것이 더 효과적임을 시사한다.</p>
<p>또한, 단일 모델의 판단에 의존하지 않고 여러 계층의 검증 오라클을 구성하는 ’디펜스 인 뎁스(Defense in Depth)’가 필수적이다. 첫 번째 계층은 정적 오라클로, 입력 데이터의 구조적 정합성을 검증하고 위험한 패턴을 사전 필터링한다. 두 번째 계층은 동적 오라클(예: LLM-as-a-Judge)로, 독립된 보안 전용 모델이 주 모델의 출력물을 제3자의 입장에서 평가한다. 마지막 계층은 런타임 오라클로, AI의 행동 결과가 시스템 자원에 미치는 영향을 실시간으로 모니터링하고 이상 징후 발생 시 즉시 격리 조치를 취한다.</p>
<h2>10. 결론: 비결정성의 파도 위에서 구축하는 신뢰의 요새</h2>
<p>프롬프트 주입과 탈옥에 대한 방어의 불확실성은 AI 기반 소프트웨어 개발이 안고 가야 할 숙명과도 같다. 모델의 확률론적 본질과 자연어라는 모호한 인터페이스가 유지되는 한, 완벽한 보안이란 존재할 수 없는 환상에 가깝다. 그러나 이러한 불확실성이 AI 도입을 포기해야 할 이유가 되어서는 안 된다.</p>
<p>엔지니어는 모델의 비결정성을 상쇄할 수 있는 결정론적 오라클 체계를 구축해야 한다. CaMeL 프레임워크와 같은 시스템 레벨의 격리, 선택 아키텍처를 통한 인지적 보완, 그리고 다중 계층의 검증 오라클은 확률의 영역에 있는 AI를 신뢰할 수 있는 엔지니어링의 영역으로 끌어올리는 닻 역할을 할 것이다. 보안은 더 이상 모델 훈련의 결과물이 아니라, 치밀하게 설계된 아키텍처의 산물이어야 한다. “느낌적 코딩(Vibe Coding)“의 시대에서 진정한 소프트웨어 엔지니어링 2.0으로 나아가기 위해, 우리는 이 불확실성을 직시하고 이를 관리할 수 있는 확정적 검증 기제를 끊임없이 연마해야 한다.</p>
<h2>11. 참고 자료</h2>
<ol>
<li>
<p>Prompt Injection vs Jailbreaking: What’s the Difference? - Promptfoo, https://www.promptfoo.dev/blog/jailbreaking-vs-prompt-injection/</p>
</li>
<li>
<p>Prompt Injection vs. Jailbreaking: What’s the Difference?, https://learnprompting.org/blog/injection_jailbreaking</p>
</li>
<li>
<p>A Bidirectional LLM Firewall: Next Level X1 - help wanted! - Hugging Face Forums, https://discuss.huggingface.co/t/a-bidirectional-llm-firewall-next-level-x1-help-wanted/172352</p>
</li>
<li>
<p>What Is a Prompt Injection Attack? [Examples &amp; Prevention] - Palo Alto Networks, https://www.paloaltonetworks.com/cyberpedia/what-is-a-prompt-injection-attack</p>
</li>
<li>
<p>Jailbroken: How Does LLM Safety Training Fail? - NeurIPS, https://proceedings.neurips.cc/paper_files/paper/2023/file/fd6613131889a4b656206c50a8bd7790-Paper-Conference.pdf</p>
</li>
<li>
<p>Jailbroken: How Does LLM Safety Training Fail? - OpenReview, https://openreview.net/forum?id=jA235JGM09</p>
</li>
<li>
<p>Key differences between prompt injection and jailbreaking | by Ken Huang - Medium, https://kenhuangus.medium.com/key-differences-between-prompt-injection-and-jailbreaking-d397cffbe812</p>
</li>
<li>
<p>LLM01:2025 Prompt Injection - OWASP Gen AI Security Project, https://genai.owasp.org/llmrisk/llm01-prompt-injection/</p>
</li>
<li>
<p>What Is a Prompt Injection Attack? - IBM, https://www.ibm.com/think/topics/prompt-injection</p>
</li>
<li>
<p>What Is LLM (Large Language Model) Security? | Starter Guide - Palo Alto Networks, https://www.paloaltonetworks.com/cyberpedia/what-is-llm-security</p>
</li>
<li>
<p>Prompt injection - Wikipedia, https://en.wikipedia.org/wiki/Prompt_injection</p>
</li>
<li>
<p>Prompt Injection Attacks in 2025: When Your Favorite AI Chatbot …, https://blog.lastpass.com/posts/prompt-injection</p>
</li>
<li>
<p>Morris II Worm: AI’s First Self-Replicating Malware | Cyber Magazine, https://cybermagazine.com/news/morris-ii-worm-inside-ais-first-self-replicating-malware</p>
</li>
<li>
<p>Universal and Transferable Adversarial Attacks on Aligned Language Models - arXiv, https://arxiv.org/html/2307.15043v2</p>
</li>
<li>
<p>Universal and Transferable Adversarial LLM Attacks - AI Papers Academy, https://aipapersacademy.com/llm-attacks/</p>
</li>
<li>
<p>Universal and Transferable Attacks on Aligned Language Models, https://llm-attacks.org/</p>
</li>
<li>
<p>Universal and Transferable Adversarial Attacks on Aligned Language Models, https://tuananhbui89.github.io/blog/2024/paper-llm-attacks/</p>
</li>
<li>
<p>LLMs Attack - CMU Foundation and Language Model Center - Carnegie Mellon University, https://www.cmu.edu/flame/research/2024/llm-attacks.html</p>
</li>
<li>
<p>Many-shot Jailbreaking - NIPS, https://proceedings.neurips.cc/paper_files/paper/2024/file/ea456e232efb72d261715e33ce25f208-Paper-Conference.pdf</p>
</li>
<li>
<p>What Really Matters in Many-Shot Attacks? An Empirical Study of …, https://aclanthology.org/2025.acl-long.101/</p>
</li>
<li>
<p>Mitigating Many-Shot Jailbreaking - arXiv, https://arxiv.org/html/2504.09604v3</p>
</li>
<li>
<p>Jailbroken: How Does LLM Safety Training Fail? | Request PDF - ResearchGate, https://www.researchgate.net/publication/372137429_Jailbroken_How_Does_LLM_Safety_Training_Fail?_share=1</p>
</li>
<li>
<p>[2307.02483] Jailbroken: How Does LLM Safety Training Fail? - arXiv.org, https://arxiv.org/abs/2307.02483</p>
</li>
<li>
<p>On the Fundamental Limits of LLMs at Scale - OpenReview, https://openreview.net/pdf/6c5a89a6f656801464e45c5c04fe6784dc7a2036.pdf</p>
</li>
<li>
<p>AIR FORCE INSTITUTE OF TECHNOLOGY - DTIC, https://apps.dtic.mil/sti/pdfs/AD1144596.pdf</p>
</li>
<li>
<p>Enabling Safety in AI Agents via Choice Architecture - Zenity Labs, https://labs.zenity.io/p/enabling-safety-in-ai-agents-via-choice-architecture</p>
</li>
<li>
<p>chawins/llm-sp: Papers and resources related to the security and privacy of LLMs - GitHub, https://github.com/chawins/llm-sp</p>
</li>
<li>
<p>Here Comes The AI Worm: Unleashing Zero-click Worms that Target GenAI-Powered Applications - arXiv, https://arxiv.org/html/2403.02817v2</p>
</li>
<li>
<p>CaMeL Prompt Injection Defense Explained - IKANGAI, https://www.ikangai.com/camel-prompt-injection-defense-explained/</p>
</li>
<li>
<p>CaMeL offers a promising new direction for mitigating prompt injection attacks, https://simonwillison.net/2025/Apr/11/camel/</p>
</li>
<li>
<p>Beyond the Whack-A-Mole: Securing Your AI Agents with DeepMind’s CaMeL Framework, https://dev.to/alessandro_pignati/beyond-the-whack-a-mole-securing-your-ai-agents-with-deepminds-camel-framework-2k5k</p>
</li>
<li>
<p>LLM Security: Prompt Injection Defense with CaMeL Framework - AFINE Cybersecurity, https://afine.com/llm-security-prompt-injection-camel/</p>
</li>
<li>
<p>Safe, responsible and effective use of LLMs - DNV Technology Insights, https://technologyinsights.dnv.com/safe-responsible-and-effective-use-of-llms/</p>
</li>
<li>
<p>Prompt Injection Attacks: The Most Common AI Exploit in 2025 - Obsidian Security, https://www.obsidiansecurity.com/blog/prompt-injection</p>
</li>
<li></li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>