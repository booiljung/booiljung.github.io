<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.5.2 사용자 경험(UX)의 일관성 저해: 같은 질문에 대해 매번 다른 어조와 포맷으로 응답</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.5.2 사용자 경험(UX)의 일관성 저해: 같은 질문에 대해 매번 다른 어조와 포맷으로 응답</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">소프트웨어 공학 (Software Engineering)</a> / <a href="../../index.html">오라클: AI 주도 개발을 위한 해답</a> / <a href="../index.html">Chapter 1. AI 기반 소프트웨어 개발의 패러다임 변화와 비결정성(Nondeterminism)의 한계</a> / <a href="index.html">1.5 비결정성이 비즈니스와 보안에 미치는 구체적 위협</a> / <span>1.5.2 사용자 경험(UX)의 일관성 저해: 같은 질문에 대해 매번 다른 어조와 포맷으로 응답</span></nav>
                </div>
            </header>
            <article>
                <h1>1.5.2 사용자 경험(UX)의 일관성 저해: 같은 질문에 대해 매번 다른 어조와 포맷으로 응답</h1>
<p>인공지능 기반의 소프트웨어 시스템에서 사용자 경험(UX)은 전통적인 결정론적 시스템과는 근본적으로 다른 도전에 직면한다. 소프트웨어 엔지니어링의 황금률 중 하나는 ’동일한 입력에 대해 시스템은 항상 동일하고 예측 가능한 응답을 내놓아야 한다’는 것이다. 그러나 거대 언어 모델(LLM)을 주축으로 하는 현대의 인공지능 시스템은 이러한 원칙을 정면으로 위배한다. 동일한 질문을 던졌음에도 불구하고 시스템이 어떤 때는 정중한 비서처럼, 어떤 때는 냉소적인 전문가처럼 응답하거나, 데이터 포맷을 JSON에서 Markdown으로 임의로 변경하는 행위는 단순한 기술적 결함을 넘어 사용자 신뢰의 근간을 뒤흔드는 심각한 위협이 된다.</p>
<h2>1. 비결정성의 기술적 메커니즘과 가변성 유발 요인</h2>
<p>대규모 언어 모델의 응답이 일관성을 잃는 근본적인 이유는 모델의 아키텍처와 추론 인프라에 내재된 비결정성(Nondeterminism)에 있다. 이론적으로는 온도를 0으로 설정하여 가장 높은 확률의 토큰만을 선택하게 함으로써 결정론적인 결과를 도출할 수 있을 것으로 기대하지만, 실제 운영 환경에서의 결과는 이와 다르다.</p>
<h3>1.1 하드웨어와 연산의 미시적 불일치</h3>
<p>가장 하위 계층에서 발생하는 일관성 저해의 원인은 부동 소수점 연산의 비결합성(Floating-Point Non-associativity)이다. GPU와 같은 병렬 처리 장치는 수만 개의 코어를 사용하여 행렬 연산을 수행하는데, 이 과정에서 연산의 순서가 미세하게 달라질 수 있다. 수학적으로는 <span class="math math-inline">(a + b) + c = a + (b + c)</span>가 성립하지만, 컴퓨터의 부동 소수점 연산에서는 정밀도의 한계로 인해 두 식의 결과값이 동일하지 않을 수 있다. 이러한 미세한 수치적 차이는 소프트맥스(Softmax) 함수를 거치며 특정 토큰의 선택 확률을 미묘하게 변화시키고, 결국 문장 전체의 구조나 어조를 뒤바꾸는 나비효과를 일으킨다.</p>
<p>또한, Mixture-of-Experts(MoE) 아키텍처를 사용하는 최신 모델들은 추론 시점에 토큰마다 서로 다른 전문가 모델을 할당한다. 이때 공유 자원에 대한 토큰들의 경쟁이나 배치(Batch) 처리 방식에 따라 전문가 할당 경로가 달라질 수 있으며, 이는 응답의 일관성을 더욱 저해하는 요인이 된다.</p>
<h3>1.2 디코딩 전략과 확률적 샘플링의 영향</h3>
<p>모델이 다음 토큰을 선택하는 디코딩 과정에서도 무작위성이 개입한다. 온도가 0이 아닌 상황에서는 다음과 같은 확률 분포 식에 따라 토큰이 선택된다.<br />
<span class="math math-display">
p_i = \frac{\exp(z_i / T)}{\sum_{j=1}^{N} \exp(z_j / T)}
</span><br />
여기서 <span class="math math-inline">T</span>는 온도를 나타내며, <span class="math math-inline">T</span>가 높을수록 확률 분포가 평탄해져 덜 지배적인 토큰이 선택될 가능성이 커진다. 이외에도 상위 <span class="math math-inline">k</span>개의 토큰만을 고려하는 Top-k 샘플링이나 누적 확률 분포가 <span class="math math-inline">p</span> 이하인 토큰 집합에서 선택하는 Top-p(Nucleus) 샘플링은 모델의 창의성을 높이는 데 기여하지만, 비즈니스 애플리케이션에서는 일관성을 해치는 양날의 검으로 작용한다.</p>
<p>다음 표는 비결정성을 유발하는 주요 기술적 요인들을 정리한 것이다.</p>
<table><thead><tr><th><strong>구분 \vert 요인</strong></th><th><strong>설명</strong></th><th><strong>영향 범위 \vert 결과</strong></th></tr></thead><tbody>
<tr><td>수치 연산 \vert 부동 소수점 비결합성</td><td>연산 순서에 따른 미세한 오차 발생</td><td>로짓(Logits) 값의 미세 변화 및 토큰 선택 영향</td></tr>
<tr><td>하드웨어 \vert 병렬 처리 가변성</td><td>GPU 코어의 실행 순서 및 스케줄링 차이</td><td>실행 시점마다 다른 출력 결과 도출 가능성</td></tr>
<tr><td>아키텍처 \vert MoE(Mixture of Experts)</td><td>토큰별 전문가 할당 로직의 무작위성</td><td>복잡한 추론 과정에서의 논리 전개 방식 변동</td></tr>
<tr><td>매개변수 \vert 샘플링 전략(T, Top-p, Top-k)</td><td>확률 분포 내에서의 무작위 선택 허용</td><td>응답 어조의 창의성 증대 혹은 일관성 결여</td></tr>
<tr><td>인프라 \vert 배치 및 부하 분산 정책</td><td>여러 요청을 묶어 처리하는 과정에서의 자원 경쟁</td><td>서버 상태에 따른 간헐적 포맷 깨짐 및 응답 지연</td></tr>
</tbody></table>
<h2>2. 사용자 경험에서의 심리적 영향과 신뢰의 조용한 붕괴</h2>
<p>일관되지 않은 AI의 응답은 단순한 불편함을 넘어 사용자의 인지 체계와 시스템에 대한 신뢰에 심각한 타격을 준다. 사용자는 시스템이 자신의 의도를 정확히 파악하고 일정한 규칙에 따라 반응할 것이라고 기대하지만, AI의 변덕스러운 반응은 이러한 기대를 배신한다.</p>
<h3>2.1 인지 부하의 증대와 검증 피로도</h3>
<p>사용자가 AI 시스템과 상호작용할 때 발생하는 인지 부하는 시스템의 신뢰도와 직결된다. 동일한 질문에 대해 매번 다른 포맷이나 어조로 답하는 시스템은 사용자로 하여금 매 응답을 비판적으로 검토하게 만든다. 이는 ’검증 피로도’를 유발하며, 사용자가 시스템을 도구로서 편안하게 활용하는 대신 감시자로서 긴장하게 만든다.</p>
<p><code>The Effects of Trust and Cognitive Load on Human-Generative AI Communication</code> 연구에 따르면, 사용자가 AI를 신뢰할수록 인지 부하가 낮아지며 대화는 더욱 효율적이고 창의적으로 변한다. 반면, 예측 불가능한 응답은 사용자의 뇌가 시스템의 패턴을 학습하는 것을 방해하여 정서적 피로감을 가중시킨다.</p>
<h3>2.2 Gell-Mann Amnesia 효과와 권위의 상실</h3>
<p>AI의 불일치는 <code>Gell-Mann Amnesia Effect</code>와 유사한 현상을 일으킨다. 사용자는 자신이 잘 아는 분야에서 AI가 어조를 바꾸며 틀린 정보를 제공하거나 포맷을 어기는 것을 목격하면, 시스템 전체의 유능함을 의심하게 된다. 반대로 자신이 모르는 분야에서는 AI의 일관성 없는 응답을 맹목적으로 수용하다가 나중에야 그 오류를 깨닫게 되며, 이는 결과적으로 서비스 이탈로 이어진다. 신뢰는 쌓기 어렵지만 무너지는 것은 순식간이며, 한 번 깨진 예측 가능성은 사용자가 시스템을 ‘장난감’ 수준으로 격하시키는 원인이 된다.</p>
<h2>3. 브랜드 정체성 훼손과 어조의 편향성 문제</h2>
<p>기업의 관점에서 어조의 일관성은 브랜드 보이스(Brand Voice)를 유지하는 핵심이다. AI가 제품의 철학이나 브랜드 지침을 무시하고 인터넷의 평균적인 어조로 회귀하는 현상은 브랜드 가치를 서서히 갉아먹는다.</p>
<h3>3.1 브랜드 보이스의 누출(Leakage)</h3>
<p>LLM은 학습 데이터의 거대한 바다에서 얻은 ’평균적인 글쓰기’를 기본값으로 갖는다. 따라서 특별한 제어 장치가 없다면 핀테크 스타트업의 친근한 AI가 갑자기 관공서의 안내문 같은 딱딱한 문투로 응답하거나, 의료 앱의 진중한 AI가 농담을 섞는 일이 발생한다. 이러한 ’브랜드 보이스 누출’은 사용자에게 일관된 브랜드 경험을 제공하는 데 실패했음을 의미한다.</p>
<p><code>7 Non-obvious Consequences of AI in UX</code>에서 언급된 사례처럼, 청년을 위한 금융 서비스가 “너의 돈, 너의 규칙!“이라는 슬로건을 유지하다가 AI가 “효율적인 자산 관리를 위해 다음 절차를 이행하십시오“라고 말하는 순간, 서비스의 정체성은 사라진다.</p>
<h3>3.2 AI의 내재적 어조 편향</h3>
<p>최근의 학술적 연구인 <code>Bias Beneath the Tone: Empirical Characterisation of Tone Bias in LLM-Driven UX Systems</code>는 중립적인 프롬프트에 대해서도 LLM이 특정한 어조 편향을 보인다는 사실을 밝혀냈다. 모델들은 대체로 지나치게 정중하거나(Overly Polite), 낙관적(Cheerful), 혹은 회피적인(Cautious) 성향을 띠는 경향이 있다. 이러한 내재적 편향은 사용자에게 인위적인 느낌을 주며, 특히 심각한 상황이나 중립적인 정보 전달이 필요한 맥락에서 부적절한 사용자 경험을 제공하게 된다.</p>
<table><thead><tr><th><strong>어조 편향 유형</strong></th><th><strong>설명</strong></th><th><strong>UX에 미치는 부정적 영향</strong></th></tr></thead><tbody>
<tr><td>과도한 공손함</td><td>모든 요청에 대해 필요 이상으로 사과하거나 낮춤</td><td>시스템의 권위 저하 및 의사소통 효율성 저해</td></tr>
<tr><td>강요된 낙관주의</td><td>부정적인 피드백에도 밝은 어조 유지</td><td>사용자의 불만 상황에서 공감 능력 부족으로 비침</td></tr>
<tr><td>회피적 완곡어법</td><td>명확한 답변 대신 모호한 표현 반복</td><td>정보의 신뢰도 하락 및 불확실성 증대</td></tr>
<tr><td>로봇적 평면화</td><td>감정이 배제된 기계적인 문체 사용</td><td>인간적 유대감 형성 실패 및 서비스 이용 재미 반감</td></tr>
</tbody></table>
<h2>4. 포맷의 불일치와 소프트웨어 통합의 장애</h2>
<p>UX의 일관성은 시각적인 어조뿐만 아니라 데이터 구조의 정합성까지 포함한다. 현대의 소프트웨어 아키텍처에서 AI의 출력은 다른 시스템의 입력으로 사용되는 경우가 많으며, 이때 포맷의 미세한 변화는 전체 파이프라인을 파괴한다.</p>
<h3>4.1 구조적 파싱 오류와 경제적 손실</h3>
<p>LLM이 생성하는 Markdown이나 JSON 데이터는 종종 구문 오류를 포함하거나, 개발자가 의도하지 않은 텍스트 래핑을 수반한다. 예를 들어, “여기에 JSON 데이터를 생성했습니다:“와 같은 서술적인 문장이 데이터 앞에 붙거나, 필드 이름이 <code>userId</code>에서 <code>user_id</code>로 임의로 변경되는 현상이 그것이다. 이러한 불일치는 API 소비자에게 치명적인 영향을 미치며, checkout 성공률을 70%까지 떨어뜨리거나 운영팀이 24시간 장애 대기 상태에 놓이게 하는 원인이 된다.</p>
<p><code>StructEval</code> 벤치마크에 따르면, 텍스트를 JSON이나 YAML로 변환하는 작업에서 모델의 정확도는 입력의 복잡도에 따라 현저히 달라진다. 특히 엔터프라이즈 환경에서 수천 건의 문서를 파싱할 때 발생하는 포맷 불일치는 단순한 버그를 넘어 데이터 무결성을 해치는 심각한 기술적 부채로 축적된다.</p>
<h2>5. 일관성 확보를 위한 UX 패턴과 엔지니어링 전략</h2>
<p>비결정성이라는 인공지능의 야생성을 길들이기 위해서는 시스템 설계와 UX 인터페이스 양면에서 엄격한 제어 장치를 도입해야 한다.</p>
<h3>5.1 Microsoft HAX 및 Google PAIR 가이드라인의 적용</h3>
<p>주요 기술 기업들은 AI의 불확실성을 관리하기 위한 디자인 가이드라인을 제시하고 있다. 마이크로소프트의 <code>HAX Toolkit</code>은 시스템의 능력을 명확히 하고(Make clear how well the system can do what it can do), 오류가 발생했을 때 사용자가 이를 쉽게 수정할 수 있도록 보장할 것을 강조한다. 구글의 <code>PAIR Guide</code> 역시 AI가 확률적으로 동작함을 인정하고, 사용자에게 결과의 확신도를 보여주거나 대안을 선택할 수 있는 기회를 제공함으로써 예측 가능성을 보완하도록 권장한다.</p>
<h3>5.2 기술적 해결책: Structured Outputs와 Self-Consistency</h3>
<p>엔지니어링 측면에서는 모델의 자율성을 제한하는 기법들이 사용된다. OpenAI의 <code>Structured Outputs</code> 기능은 유한 상태 기계(FSM)를 사용하여 생성되는 각 토큰이 미리 정의된 JSON 스키마를 100% 준수하도록 강제한다. 이는 프롬프트 엔지니어링만으로 해결할 수 없었던 포맷 불일치 문제를 해결하는 강력한 도구가 된다.</p>
<p>또한, <code>Self-Consistency Improves Chain of Thought Reasoning in Language Models</code> 논문에서 제시된 전략은 일관성 문제를 역이용하여 정확도를 높인다. 모델에게 동일한 문제에 대해 여러 개의 추론 경로(Reasoning Paths)를 생성하게 한 뒤, 가장 많이 도출된 답변을 선택하는 다수결(Majority Vote) 방식을 취함으로써 단일 응답이 가질 수 있는 무작위 오류를 효과적으로 억제한다.<br />
<span class="math math-display">
\hat{a} = \text{argmax}_{a_i} \sum_{i=1}^{m} \mathbb{1}(a_i = a)
</span><br />
위 식은 <span class="math math-inline">m</span>개의 샘플 중 가장 빈번하게 등장하는 정답 <span class="math math-inline">a</span>를 최종 결과로 선택하는 과정을 나타낸다. 이러한 접근은 연산 비용을 증가시키지만, 금융이나 법률 등 높은 수준의 일관성과 정확성이 요구되는 분야에서는 필수적인 전략이 된다.</p>
<h2>6. 결론: 결정론적 UX를 향한 여정</h2>
<p>사용자 경험의 일관성 저해는 인공지능을 소프트웨어 제품으로 승화시키는 과정에서 반드시 넘어야 할 산이다. 같은 질문에 매번 다르게 답하는 AI는 매력적인 실험실의 결과물일 수는 있으나, 신뢰할 수 있는 비즈니스 인프라가 될 수는 없다.</p>
<p>개발자는 비결정성이라는 모델의 본질을 이해하고, 이를 보완하기 위한 결정론적 오라클(Deterministic Oracle)과 엄격한 UX 디자인 패턴을 구축해야 한다. 어조의 가변성을 통제하기 위한 시스템 메시지의 정교화, 포맷의 정합성을 보장하는 구조화된 출력 기능, 그리고 사용자의 인지 부하를 줄여주는 투명한 인터페이스 설계가 결합될 때 비로소 인공지능은 변덕스러운 기계에서 예측 가능한 도구로 진화할 수 있다. 인류가 도구를 신뢰해 온 역사는 언제나 ’동일한 행동에 대한 동일한 반응’이라는 물리적 일관성에 기반해 왔음을 잊지 말아야 한다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Why Temperature=0 Doesn’t Guarantee Determinism in LLMs …, https://mbrenndoerfer.com/writing/why-llms-are-not-deterministic</li>
<li>Non Determinism &amp; Prompt Optimization in LLMs for AI Apps, https://futureagi.com/blogs/non-deterministic-llm-prompts-2025</li>
<li>Defeating Nondeterminism in LLM Inference: What It Unlocks for, https://www.propelcode.ai/blog/defeating-nondeterminism-in-llm-inference-ramifications</li>
<li>Non-Determinism of “Deterministic” LLM System Settings in Hosted, https://aclanthology.org/2025.eval4nlp-1.12.pdf</li>
<li>Defeating Nondeterminism in LLM Inference - Thinking Machines Lab, https://thinkingmachines.ai/blog/defeating-nondeterminism-in-llm-inference/</li>
<li>UX Patterns That Increase Trust in AI | Blog - Goji Labs, https://gojilabs.com/blog/ux-patterns-that-increase-trust-in-ai/</li>
<li>The Effects of Trust and Cognitive Load on Human-Generative AI, https://www.researchgate.net/publication/400472591_The_Effects_of_Trust_and_Cognitive_Load_on_Human-Generative_AI_Communication_in_Higher_Education_Evidence_from_Indonesian_Undergraduate_Students</li>
<li>Building and calibrating trust in AI | by Dr. Janna Lipenkova, https://uxdesign.cc/building-and-calibrating-trust-in-ai-717d996652ef</li>
<li>The UX of Uncertainty: When AI Isnâ€™t Sure, Say So - giorgio patrini, https://giorgiopatrini.org/the-ux-of-uncertainty-when-ai-isnt-sure-say-so</li>
<li>7 Non-Obvious Consequences of AI in UX | by Anton Abramovich …, https://medium.com/@abramovichanton/7-non-obvious-consequences-of-ai-in-ux-d5ba0d6dd815</li>
<li>Empirical Characterisation of Tone Bias in LLM-Driven UX Systems, https://arxiv.org/html/2512.19950v1</li>
<li>How Output Parsers Save Your LLM From Formatting Disaster, https://dev.to/alex_aslam/taming-the-chaos-how-output-parsers-save-your-llm-from-formatting-disaster-120o</li>
<li>Mastering Structured Output in LLMs 1: JSON output with LangChain, https://medium.com/@docherty/mastering-structured-output-in-llms-choosing-the-right-model-for-json-output-with-langchain-be29fb6f6675</li>
<li>Get consistent, well-formatted Markdown/JSON outputs from LLMs, https://community.n8n.io/t/get-consistent-well-formatted-markdown-json-outputs-from-llms/80749</li>
<li>Benchmarking LLMs’ Capabilities to Generate Structural Outputs, https://arxiv.org/html/2505.20139v1</li>
<li>LLM APIs Aren’t Complete Document Parsers: Why - LlamaIndex, https://www.llamaindex.ai/blog/llm-apis-are-not-complete-document-parsers</li>
<li>Guidelines for Human-AI Interaction - Microsoft, https://www.microsoft.com/en-us/research/wp-content/uploads/2019/01/Guidelines-for-Human-AI-Interaction-camera-ready.pdf</li>
<li>HAX Toolkit: Guidelines, Patterns, and Real-World Examples for, https://www.youtube.com/watch?v=l34vjk4SU-w</li>
<li>People + AI Guidebook - Principles &amp; Patterns, https://pair.withgoogle.com/guidebook/patterns</li>
<li>Structured Outputs: Everything You Should Know - Humanloop, https://humanloop.com/blog/structured-outputs</li>
<li>Self-Consistency Improves Chain of Thought Reasoning - Portkey, https://portkey.ai/blog/self-consistency-improves-chain-of-thought-reasoning-in-language-models-summary/</li>
<li>SELF-CONSISTENCY IMPROVES CHAIN OF THOUGHT, http://webdocs.cs.ualberta.ca/~dale/papers/iclr23b.pdf</li>
<li>(PDF) Self-Consistency Improves Chain of Thought Reasoning in, https://scispace.com/papers/self-consistency-improves-chain-of-thought-reasoning-in-11cskg6j</li>
<li>Self-Consistency with Chain of Thought (CoT-SC) - Johannes Köppern, https://betterofjohn.com/uncategorized/self-consistency-with-chain-of-thought-cot-sc/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>