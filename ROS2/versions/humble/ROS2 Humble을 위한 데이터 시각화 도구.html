<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS2 Humble을 위한 데이터 시각화 도구</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS2 Humble을 위한 데이터 시각화 도구</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">ROS2 (Robot Operating System 2)</a> / <a href="../index.html">ROS2 Versions</a> / <a href="index.html">ROS2 Humble</a> / <span>ROS2 Humble을 위한 데이터 시각화 도구</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS2 Humble을 위한 데이터 시각화 도구</h1>
<h2>1. 서론: 로보틱스 개발에서 데이터 시각화의 중요성</h2>
<h3>1.1 시각화의 본질적 가치</h3>
<p>로봇 시스템은 다수의 센서, 액추에이터, 그리고 복잡한 알고리즘이 유기적으로 결합된 집합체이다. 이러한 시스템의 내부 상태와 외부 환경과의 상호작용은 수치 데이터, 로그 메시지, 행렬과 같은 추상적인 데이터 스트림의 형태로 끊임없이 생성된다. 그러나 개발자는 이 데이터의 홍수 속에서 시스템의 거동을 직관적으로 파악하고, 알고리즘의 결함을 진단하며, 성능을 정량적으로 평가해야 하는 과제에 직면한다. 데이터 시각화는 바로 이 지점에서 추상적인 데이터를 인간이 인지할 수 있는 시각적 형태로 변환함으로써, 복잡성에 대한 통찰력을 제공하는 가장 강력한 수단이다.1</p>
<p>시각화는 단순히 데이터를 예쁘게 표현하는 것을 넘어, 로봇 개발의 본질적인 부분으로서 다음과 같은 핵심적인 가치를 제공한다. 첫째, 로봇의 현재 상태(state), 환경 인식(perception), 그리고 의사 결정(decision-making) 과정을 직관적으로 이해하게 한다. 예를 들어, 3D 시각화 도구를 통해 로봇이 라이다 센서로 주변 환경을 어떻게 인식하고 있는지, 경로 계획 알고리즘이 어떤 경로를 생성했는지를 직접 눈으로 확인함으로써, 복잡한 알고리즘의 동작 원리를 즉각적으로 파악할 수 있다. 둘째, 알고리즘의 결함을 신속하게 진단하는 디버깅 도구로서 기능한다. 텍스트 기반 로그만으로는 발견하기 어려운 문제, 예를 들어 좌표계 변환 오류나 센서 데이터의 노이즈 등을 시각화를 통해 단번에 발견할 수 있다. 셋째, 시스템의 성능을 정량적으로 분석하고 개선하는 데 기여한다. 시계열 데이터 플로팅 도구를 사용하면 제어 시스템의 응답 특성이나 상태 추정 필터의 오차를 시간에 따라 분석하여 알고리즘의 파라미터를 정밀하게 튜닝할 수 있다.</p>
<h3>1.2 ROS2 Humble 생태계의 시각화 도구</h3>
<p>ROS2 Humble Hawksbill은 장기 지원(Long-Term Support, LTS) 릴리즈로서, 이전 버전에 비해 성능, 보안, 모듈성 측면에서 상당한 개선을 이루었다.1 이 안정적인 개발 환경 위에서 로봇 애플리케이션의 개발 효율성을 극대화하기 위해 다양한 데이터 시각화 도구들이 발전해왔다. 본 안내서는 ROS2 Humble 생태계에서 가장 핵심적인 역할을 수행하는 네 가지 시각화 도구—<strong>RViz2</strong>, <strong>RQT 도구 모음</strong>, <strong>PlotJuggler</strong>, <strong>Foxglove Studio</strong>—를 심층적으로 분석한다.</p>
<p>이 도구들은 각기 다른 개발 철학과 목적을 가지고 설계되었다. <strong>RViz2</strong>는 ROS2와의 깊은 통합을 바탕으로 한 표준 3D 시각화 도구이며, <strong>RQT 도구 모음</strong>은 경량 플러그인들의 조합을 통해 시스템의 상태를 신속하게 확인하는 데 초점을 맞춘다. <strong>PlotJuggler</strong>는 시계열 데이터의 고성능 분석과 처리에 특화된 전문 도구이며, <strong>Foxglove Studio</strong>는 웹 기술을 기반으로 이 모든 기능을 통합하고 팀 협업을 지원하는 현대적인 플랫폼을 지향한다. 본 안내서는 각 도구의 아키텍처, 핵심 기능, 장단점을 상세히 분석하고, 실제 로보틱스 개발 시나리오에 맞춰 이들을 가장 효과적으로 선택하고 조합하는 전략적 가이드를 제시하는 것을 최종 목표로 한다.</p>
<h2>2. RViz2: ROS2 생태계의 표준 3D 시각화 도구</h2>
<h3>2.1 핵심 철학 및 아키텍처</h3>
<p>RViz2는 ROS1의 성공적인 3D 시각화 도구였던 RViz를 ROS2 환경에 맞게 이식(porting)한 결과물이다.4 그 핵심 설계 철학은 ROS2 시스템과의 **깊은 통합(Deep Integration)**에 기반한다. 이는 단순히 ROS2 토픽을 구독하여 데이터를 표시하는 수준을 넘어, ROS2의 근간을 이루는 핵심 개념들과 유기적으로 연동됨을 의미한다. 대표적으로, RViz2는 TF2(Transform Library 2) 변환 계층을 완벽하게 지원하여 로봇의 복잡한 좌표계(frame) 관계를 자동으로 계산하고 모든 시각화 요소에 정확하게 반영한다. 이를 통해 개발자는 각 센서 데이터가 어떤 좌표계를 기준으로 생성되었는지 신경 쓸 필요 없이, 통합된 3D 월드에서 모든 정보를 직관적으로 확인할 수 있다.</p>
<p>RViz2의 아키텍처는 **플러그인 기반 확장성(Plugin-based Extensibility)**이라는 강력한 특징을 가진다.1 RViz2에서 사용자가 보는 거의 모든 시각화 기능—센서 데이터를 표시하는 ‘디스플레이(Displays)’, 3D 뷰와 상호작용하는 ‘도구(Tools)’, 카메라 시점을 제어하는 ‘뷰 컨트롤러(View Controllers)’, 그리고 GUI 창을 구성하는 ‘패널(Panels)’—는 모두 독립적인 플러그인 형태로 구현되어 있다.6 이러한 구조는 두 가지 중요한 장점을 제공한다. 첫째, 기본 기능이 매우 모듈화되어 있어 유지보수가 용이하다. 둘째, 사용자는 C++를 사용하여 자신만의 커스텀 플러그인을 개발함으로써 RViz2의 기능을 무한히 확장할 수 있다.7 예를 들어, 표준 ROS 메시지 타입이 아닌 독자적인 데이터 구조를 시각화하거나, 특정 로봇 애플리케이션에 특화된 상호작용 도구를 직접 만들어 RViz2에 통합하는 것이 가능하다.</p>
<h3>2.2 설치 및 실행</h3>
<p>RViz2는 ROS2 Humble의 데스크톱 버전(<code>ros-humble-desktop</code>)을 설치할 경우 기본적으로 함께 설치된다.4 따라서 대부분의 개발 환경에서는 별도의 설치 과정이 필요 없다. 설치 여부를 확인하고 RViz2를 실행하는 가장 간단한 방법은 새 터미널에서 다음 명령어를 입력하는 것이다.</p>
<pre><code class="language-Bash">ros2 run rviz2 rviz2
</code></pre>
<p>만약 <code>ros-humble-ros-base</code>와 같이 최소 버전의 ROS2를 설치하여 RViz2가 시스템에 없는 경우, <code>apt</code> 패키지 관리자를 통해 간단하게 개별 설치할 수 있다.5</p>
<pre><code class="language-Bash">sudo apt update
sudo apt install ros-humble-rviz2
</code></pre>
<p>설치가 완료되면 위 <code>ros2 run</code> 명령어를 통해 RViz2를 실행할 수 있다.</p>
<h3>2.3 사용자 인터페이스 분석</h3>
<p>RViz2를 처음 실행하면 여러 개의 패널로 구성된 창이 나타난다. 각 패널은 고유한 역할을 수행하며, 이들의 조합을 통해 복잡한 로봇 데이터를 시각화하고 분석하게 된다.2</p>
<ul>
<li>
<p><strong>3D View:</strong> 인터페이스의 가장 큰 중앙 영역을 차지하는 화면으로, 로봇 모델, 센서 데이터, 가상 객체 등 모든 3차원 시각적 요소가 렌더링되는 주 무대이다. 사용자는 마우스를 사용하여 이 공간을 회전, 이동, 확대/축소하며 원하는 시점에서 로봇과 환경을 관찰할 수 있다.2</p>
</li>
<li>
<p><strong>Displays Panel:</strong> 좌측에 위치하며, RViz2에서 가장 핵심적인 역할을 하는 패널이다. 사용자는 이 패널의 ‘Add’ 버튼을 통해 시각화할 데이터의 종류, 즉 ’디스플레이 플러그인’을 추가할 수 있다. 추가된 각 디스플레이 항목은 특정 ROS 토픽을 구독하며, 해당 토픽의 메시지 타입을 해석하여 3D View에 시각화한다. 각 디스플레이 항목을 펼치면 토픽 이름, 색상, 크기 등 세부 속성을 설정할 수 있다.2</p>
</li>
<li>
<p><strong>Toolbar:</strong> 상단에 위치한 도구 모음으로, 3D View와 상호작용하는 방식을 선택하는 데 사용된다. 기본 도구인 <code>Move Camera</code> 외에도, 3D 공간의 객체와 상호작용하는 <code>Interact</code>, 특정 지점의 좌표를 측정하는 <code>Measure</code>, 2D 내비게이션 목표 지점을 설정하는 <code>2D Pose Estimate</code>와 <code>2D Nav Goal</code> 등의 도구가 제공된다.8</p>
</li>
<li>
<p><strong>Views Panel:</strong> 우측에 위치하며, 3D View의 카메라 시점과 투영 방식을 제어한다. 기본값인 <code>Orbit (RViz)</code> 뷰는 특정 초점을 중심으로 공전하는 시점을 제공하며, 이 외에도 로봇의 시점에서 바라보는 <code>FPS (First-Person Shooter)</code>, 위에서 수직으로 내려다보는 <code>TopDown Ortho</code> 등 다양한 카메라 타입을 선택하고 설정할 수 있다.8</p>
</li>
<li>
<p><strong>Time Panel:</strong> 하단에 위치하며, 현재 시스템 시간(Wall Time)과 ROS 시간(ROS Time)을 표시한다. <code>ros2 bag play</code>를 사용하여 데이터를 재생할 때, ROS 시간의 진행 상황을 확인하고 데이터가 올바르게 동기화되고 있는지 파악하는 데 중요한 역할을 한다.2</p>
</li>
</ul>
<h3>2.4 핵심 디스플레이 플러그인 상세 분석</h3>
<p>RViz2의 진정한 강력함은 다양한 종류의 ROS 메시지를 시각화할 수 있는 내장 디스플레이 플러그인에서 나온다. 각 플러그인은 특정 메시지 타입에 대한 ‘시각적 해석기’ 역할을 수행하며, 로봇 개발의 거의 모든 측면을 지원한다.8</p>
<p>RViz2의 디스플레이 기능은 단순히 데이터를 화면에 그리는 행위를 넘어선다. 이는 ROS 메시지 타입에 담긴 데이터 구조를 물리 세계의 의미와 연결하는 ‘해석’ 과정에 가깝다. 예를 들어, <code>sensor_msgs/msg/LaserScan</code> 메시지는 본질적으로 거리 값을 담은 부동소수점 숫자 배열(<code>ranges</code>)과 각도 정보(<code>angle_min</code>, <code>angle_max</code>, <code>angle_increment</code>)의 조합이다. <code>LaserScan</code> 디스플레이는 이 숫자 배열을 3D 공간상의 극좌표계로 해석하여 일련의 점들로 변환하고, 이를 3D View에 렌더링한다. 마찬가지로 <code>nav_msgs/msg/Path</code> 메시지는 <code>geometry_msgs/msg/PoseStamped</code> 메시지들의 배열이지만, <code>Path</code> 디스플레이는 이를 단순히 여러 개의 좌표계로 그리는 대신, 각 포즈의 위치(position)를 순서대로 연결한 부드러운 선으로 시각화한다.</p>
<p>이러한 관점에서 볼 때, RViz2에서 데이터가 의도한 대로 올바르게 시각화된다는 것은 두 가지 중요한 사실을 동시에 검증하는 과정이다. 첫째, 해당 토픽으로 데이터가 정상적으로 발행되고 있다. 둘째, 발행되는 메시지의 내용이 ROS 생태계에서 통용되는 표준적인 의미론(semantics)에 부합한다. 만약 경로 데이터가 엉뚱한 곳에 그려진다면, 이는 경로 계획 알고리즘의 문제일 수도 있지만, 경로를 구성하는 각 포즈의 좌표계(<code>frame_id</code>)가 잘못 설정되었을 가능성도 있다. 이처럼 RViz2는 단순한 시각화 도구를 넘어, ROS 메시지의 의미론적 정확성을 검증하는 강력한 **‘의미론적 디버거(Semantic Debugger)’**로서 기능한다.</p>
<p>아래 표는 RViz2에 내장된 주요 디스플레이 플러그인과 그 역할을 정리한 것이다. 이 표는 개발자가 특정 데이터를 시각화하고자 할 때 어떤 디스플레이를 사용해야 하며, 이를 위해 어떤 ROS 메시지 타입을 발행해야 하는지에 대한 실용적인 가이드를 제공한다.</p>
<table><thead><tr><th>플러그인 (Plugin)</th><th>대응 메시지 타입 (Messages Used)</th><th>주요 역할 및 기능</th><th>관련 Snippet</th></tr></thead><tbody>
<tr><td><code>TF</code></td><td>(tf2 transform hierarchy)</td><td>로봇의 각 좌표계(frame) 간의 관계를 화살표로 시각화한다. 로봇 모델의 링크들이 올바른 위치에 있는지 디버깅하는 데 필수적이다.</td><td>4</td></tr>
<tr><td><code>RobotModel</code></td><td>(URDF/SDF description)</td><td>로봇의 URDF(Unified Robot Description Format) 파일을 기반으로 3D 모델을 렌더링한다. TF 정보와 결합하여 로봇의 현재 자세를 실시간으로 보여준다.</td><td>5</td></tr>
<tr><td><code>LaserScan</code></td><td><code>sensor_msgs/msg/LaserScan</code></td><td>2D/3D 라이다(LIDAR) 센서 데이터를 점(point) 형태로 시각화한다. 장애물 감지 및 환경 인식을 확인하는 데 사용된다.</td><td>4</td></tr>
<tr><td><code>PointCloud2</code></td><td><code>sensor_msgs/msg/PointCloud2</code></td><td>3D 라이다, 깊이 카메라 등에서 생성된 3차원 점 구름 데이터를 시각화한다. 3D 환경 모델링 및 객체 인식을 디버깅하는 데 핵심적이다.</td><td>8</td></tr>
<tr><td><code>Image</code> / <code>Camera</code></td><td><code>sensor_msgs/msg/Image</code></td><td>카메라 토픽의 이미지 데이터를 2D 창 또는 3D 공간에 투영하여 보여준다. 컴퓨터 비전 알고리즘의 입력과 출력을 확인하는 데 사용된다.</td><td>4</td></tr>
<tr><td><code>Map</code></td><td><code>nav_msgs/msg/OccupancyGrid</code></td><td>SLAM이나 지도 서버가 생성한 2D 점유 격자 지도를 평면에 표시한다. 로봇의 위치 추정 및 경로 계획의 기준이 되는 지도를 확인한다.</td><td>5</td></tr>
<tr><td><code>Path</code></td><td><code>nav_msgs/msg/Path</code></td><td>내비게이션 스택이 생성한 로봇의 계획 경로를 선으로 표시한다. 경로 계획 알고리즘의 결과를 직관적으로 평가할 수 있다.</td><td>8</td></tr>
<tr><td><code>Odometry</code></td><td><code>nav_msgs/msg/Odometry</code></td><td>로봇의 주행 기록계(Odometry) 데이터를 누적하여 이동 경로를 시각화한다. 위치 추정 알고리즘의 정확도를 평가하는 데 유용하다.</td><td>8</td></tr>
<tr><td><code>Markers</code></td><td><code>visualization_msgs/msg/MarkerArray</code></td><td>개발자가 코드 내에서 정의한 큐브, 구, 화살표 등 임의의 기하학적 형태를 시각화한다. 알고리즘의 내부 상태나 가상 객체를 표현하는 데 매우 유용하다.</td><td>8</td></tr>
<tr><td><code>GridCells</code></td><td><code>nav_msgs/msg/GridCells</code></td><td>내비게이션 스택의 비용 지도(costmap)에서 장애물로 간주되는 셀들을 시각화한다. 로봇이 경로 계획 시 어떤 영역을 위험하게 인식하는지 파악할 수 있다.</td><td>8</td></tr>
</tbody></table>
<h3>2.5 장단점 및 활용 시나리오</h3>
<p>RViz2는 ROS2 개발에 없어서는 안 될 필수 도구이지만, 모든 상황에 최적인 만능 해결책은 아니다. 그 장단점을 명확히 이해하고 적절한 시나리오에 활용하는 것이 중요하다.</p>
<h4>2.5.1 장점</h4>
<ul>
<li>
<p><strong>ROS2와의 완벽한 통합:</strong> TF, 파라미터, 액션 등 ROS2의 핵심 기능과 완벽하게 연동되어 시스템의 상태를 가장 정확하게 반영한다.1</p>
</li>
<li>
<p><strong>강력한 3D 시각화:</strong> 로봇 모델, 센서 데이터, 좌표계, 가상 객체 등 3차원 공간 정보를 종합적으로 시각화하는 능력은 타의 추종을 불허한다.1</p>
</li>
<li>
<p><strong>높은 확장성:</strong> C++ 플러그인 아키텍처를 통해 사용자가 원하는 거의 모든 종류의 데이터 시각화 기능을 추가할 수 있어, 특정 도메인에 고도로 특화된 시각화 환경 구축이 가능하다.6</p>
</li>
</ul>
<h4>2.5.2 단점</h4>
<ul>
<li>
<p><strong>가파른 학습 곡선:</strong> 다양한 패널과 복잡한 설정 옵션은 ROS나 RViz2를 처음 접하는 사용자에게 다소 어렵게 느껴질 수 있다.10</p>
</li>
<li>
<p><strong>시계열 데이터 분석의 한계:</strong> 시간에 따른 특정 수치 데이터의 변화를 정밀하게 분석하는 기능, 예를 들어 그래프 플로팅, 확대/축소, 미분/적분 등의 기능이 내장되어 있지 않다.</p>
</li>
<li>
<p><strong>독립 실행의 어려움:</strong> 저장된 rosbag 데이터를 시각화하기 위해서는 별도의 터미널에서 <code>ros2 bag play</code> 명령어를 실행해야 하는 등, 독립적인 데이터 분석 도구로서의 사용성이 다소 떨어진다.11</p>
</li>
</ul>
<h4>2.5.3 최적 활용 시나리오</h4>
<ul>
<li>
<p><strong>내비게이션 및 SLAM 디버깅:</strong> 로봇의 현재 위치(TF), 주변 환경(LaserScan/PointCloud2), 생성된 지도(Map), 계획된 경로(Path), 그리고 장애물 회피를 위한 비용 지도(GridCells)를 하나의 3D 공간에 동시에 시각화하여 자율주행 시스템의 복합적인 문제를 진단하는 데 가장 이상적인 도구이다.5</p>
</li>
<li>
<p><strong>센서 데이터 검증:</strong> 라이다, 카메라, IMU 등 다양한 센서로부터 수신되는 데이터가 올바른 좌표계에서, 올바른 주기로, 왜곡 없이 정상적으로 수신되는지를 실시간으로 확인하는 데 필수적이다.4</p>
</li>
<li>
<p><strong>매니퓰레이션 및 모션 플래닝:</strong> 로봇 팔의 동작 계획 결과를 3D 모델 상에서 미리 확인하고, 주변 장애물과의 충돌 여부를 검사하며, 목표 지점을 설정하는 등 로봇 조작과 관련된 작업을 직관적으로 검증하고 디버깅하는 데 매우 효과적이다.5</p>
</li>
</ul>
<h2>3. RQT 도구 모음: 경량 모듈형 GUI 프레임워크</h2>
<h3>3.1 RQT의 역할과 철학</h3>
<p>RQT는 RViz2와 같이 단일 목적을 가진 애플리케이션이 아니라, 다양한 GUI 도구(플러그인)를 담는 <strong>컨테이너(Container) 또는 프레임워크</strong>이다.12 RQT의 핵심 철학은 **‘모듈성(Modularity)’**에 있다. 즉, 개발자가 당면한 과제에 필요한 도구 플러그인만 선택하여 자신만의 맞춤형 디버깅 대시보드를 구성할 수 있도록 지원하는 것이다. RQT의 가장 큰 특징 중 하나는 여러 플러그인을 하나의 창 안에 자유롭게 배치하고 도킹(docking)할 수 있다는 점이다. 이를 통해 제한된 화면 공간을 매우 효율적으로 관리하며, 여러 측면의 시스템 정보를 동시에 모니터링할 수 있다.15</p>
<p>RQT는 RViz2처럼 복잡한 3D 공간을 시각화하거나 PlotJuggler처럼 심층적인 시계열 데이터를 분석하는 데 특화되어 있지는 않다. 대신, 실행 중인 ROS2 시스템의 전반적인 **상태를 신속하게 확인하고(Introspection), 시스템과 간단하게 상호작용(Interaction)**하는 데 초점을 맞춘 가볍고 빠른 도구들의 모음이다.12</p>
<h3>3.2 설치 및 실행</h3>
<p>RQT 프레임워크와 <code>rqt_graph</code>, <code>rqt_plot</code>, <code>rqt_console</code> 등과 같은 주요 플러그인들은 <code>ros-humble-rqt*</code>라는 메타패키지를 통해 한 번에 설치하는 것이 가장 편리하다.12</p>
<pre><code class="language-Bash">sudo apt update
sudo apt install ros-humble-rqt*
</code></pre>
<p>설치 후, RQT를 실행하는 방법은 두 가지가 있다. 첫 번째는 RQT 메인 컨테이너를 실행한 후, 상단 메뉴의 <code>Plugins</code>에서 원하는 플러그인을 선택하여 로드하는 방식이다.12</p>
<pre><code class="language-Bash">rqt
</code></pre>
<p>두 번째는 각 플러그인을 독립적인 애플리케이션처럼 직접 실행하는 방식이다. 이 방법은 특정 도구 하나만 빠르게 사용하고 싶을 때 유용하다.17</p>
<pre><code class="language-Bash"># rqt_graph를 직접 실행
ros2 run rqt_graph rqt_graph

# rqt_console을 직접 실행
ros2 run rqt_console rqt_console
</code></pre>
<h3>3.3 주요 플러그인 기능 분석</h3>
<p>RQT의 실질적인 기능은 개별 플러그인에 의해 제공된다. 다음은 ROS2 개발에서 가장 빈번하게 사용되는 핵심 RQT 플러그인들이다.</p>
<h4>3.3.1 rqt_graph</h4>
<ul>
<li>
<p><strong>기능:</strong> 현재 실행 중인 ROS2 시스템의 계산 그래프(computation graph)를 시각화한다. 이 그래프에서 노드(Node)는 타원, 토픽(Topic)은 직사각형으로 표시되며, 이들 간의 발행(publish)/구독(subscribe) 관계가 화살표로 연결된다.12 이를 통해 시스템 내 데이터가 어떤 노드에서 생성되어 어떤 노드로 흘러가는지를 한눈에 직관적으로 파악할 수 있다.17</p>
</li>
<li>
<p><strong>활용:</strong> <code>rqt_graph</code>는 시스템 통합 및 디버깅의 첫 단계에서 매우 강력한 도구이다. 예를 들어, 새로 작성한 센서 노드가 데이터를 정상적으로 발행하고 있는지, 제어 노드가 해당 토픽을 제대로 구독하고 있는지 등을 시각적으로 즉시 확인할 수 있다. 복잡한 시스템에서 특정 토픽에 데이터가 전달되지 않거나, 예상치 못한 노드가 특정 토픽을 구독하는 등의 연결 문제를 진단하는 데 결정적인 역할을 한다.12</p>
</li>
</ul>
<h4>3.3.2 rqt_plot</h4>
<ul>
<li><strong>기능:</strong> ROS2 토픽으로 발행되는 숫자 형식의 데이터를 2D 그래프로 실시간 플로팅한다.19</li>
</ul>
<p><code>geometry_msgs/msg/Twist</code> 메시지의 <code>linear.x</code> 필드 값처럼, 메시지 내의 특정 필드를 지정하여 시간 축에 따른 변화를 그래프로 그릴 수 있다.</p>
<ul>
<li><strong>한계점:</strong> <code>rqt_plot</code>은 간단한 값의 변화 추이를 빠르게 확인하는 용도로는 유용하지만, 전문적인 데이터 분석 도구인 PlotJuggler에 비하면 기능과 성능 면에서 상당한 한계를 가진다. 대용량 데이터를 처리할 때 성능 저하가 발생할 수 있으며, 데이터 확대/축소, 이동, 수학적 변환 등 고급 분석 기능이 매우 제한적이다.20 실제로 GitHub 이슈 트래커에도 ROS2 환경에서의 성능 및 사용성 문제들이 다수 보고된 바 있다.21</li>
</ul>
<h4>3.3.3 rqt_console</h4>
<ul>
<li>
<p><strong>기능:</strong> 실행 중인 모든 ROS2 노드에서 출력하는 로그 메시지(<code>rcl_interfaces/msg/Log</code>)를 하나의 통합된 GUI 창에서 수집하고 표시한다.22</p>
</li>
<li>
<p><strong>핵심 기능:</strong> 이 플러그인의 강점은 강력한 필터링과 관리 기능에 있다.</p>
</li>
<li>
<p><strong>심각도 필터링(Severity Level Filtering):</strong> <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>FATAL</code>의 5단계 심각도에 따라 메시지를 선택적으로 보거나 숨길 수 있다. 예를 들어, 시스템의 오류 상황을 분석할 때는 <code>WARN</code> 이상의 메시지만 필터링하여 집중적으로 확인할 수 있다.22</p>
</li>
<li>
<p><strong>문자열 필터링 및 하이라이팅:</strong> 특정 문자열(예: 특정 노드 이름, 에러 코드)을 포함하는 메시지만 필터링하거나, 해당 문자열을 포함하는 메시지를 특정 색상으로 강조하여 가독성을 높일 수 있다.22</p>
</li>
<li>
<p><strong>로그 저장 및 불러오기:</strong> 현재까지 수집된 로그를 파일로 저장했다가 나중에 다시 불러와 분석할 수 있다.</p>
</li>
<li>
<p><strong>활용:</strong> 여러 노드가 동시에 실행되는 복잡한 시스템에서 터미널 창에 빠르게 지나가는 로그 메시지를 놓치지 않고 체계적으로 분석할 때 필수적인 도구이다. <code>rqt_logger_level</code> 플러그인과 함께 사용하면, 실행 중인 특정 노드의 로그 출력 수준을 동적으로 변경(예: 평소에는 <code>INFO</code> 수준으로 운영하다가, 문제 발생 시 <code>DEBUG</code> 수준으로 변경)하여 디버깅 효율을 극대화할 수 있다.23</p>
</li>
</ul>
<h4>3.3.4 기타 유용한 플러그인</h4>
<ul>
<li>
<p><strong>Service Caller:</strong> GUI를 통해 ROS2 서비스를 목록에서 선택하고, 요청(request) 메시지를 입력하여 호출한 뒤, 그 응답(response)을 확인할 수 있다. CLI 명령어를 사용하는 것보다 직관적이다.16</p>
</li>
<li>
<p><strong>Publisher:</strong> GUI 상에서 토픽 이름과 메시지 타입을 선택하고, 필드 값을 입력하여 직접 메시지를 발행할 수 있다. 특정 노드의 동작을 테스트하기 위해 임시로 데이터를 주입할 때 유용하다.</p>
</li>
<li>
<p><strong>Parameter Reconfigure:</strong> 실행 중인 노드가 선언한 동적 파라미터(dynamic parameters)의 목록을 보여주고, GUI를 통해 실시간으로 그 값을 변경할 수 있다. 알고리즘의 파라미터를 튜닝할 때 노드를 재시작할 필요가 없어 매우 편리하다.</p>
</li>
</ul>
<h3>3.4 장단점 및 활용 시나리오</h3>
<p>RQT 도구 모음은 그 자체로 완결된 솔루션이라기보다는, 다른 전문 도구들을 보완하는 경량 디버깅 도구로서의 가치가 크다.</p>
<h4>3.4.1 장점</h4>
<ul>
<li>
<p><strong>경량성 및 신속성:</strong> 각 플러그인은 가볍고 빠르게 실행되므로, 시스템의 특정 부분을 즉각적으로 확인하고 싶을 때 부담 없이 사용할 수 있다.</p>
</li>
<li>
<p><strong>모듈성:</strong> 필요한 기능의 플러그인만 골라 하나의 창에 배치함으로써, 자신만의 맞춤형 디버깅 대시보드를 효율적으로 구성할 수 있다.15</p>
</li>
<li>
<p><strong>다양한 디버깅 관점 제공:</strong> 노드 그래프, 데이터 플롯, 로그, 서비스, 파라미터 등 시스템의 여러 측면을 동시에 점검할 수 있는 종합적인 도구 모음을 제공한다.</p>
</li>
</ul>
<h4>3.4.2 단점</h4>
<ul>
<li>
<p><strong>분석 기능의 한계:</strong> 각 플러그인이 제공하는 기능은 RViz2나 PlotJuggler와 같은 전문 도구에 비해 상대적으로 단순하여, 깊이 있는 데이터 분석이나 복잡한 시각화에는 부적합하다.</p>
</li>
<li>
<p><strong>시각적 표현력 부족:</strong> UI가 기능성에만 초점을 맞추고 있어 시각적으로 세련되지 않으며, 복잡한 데이터를 효과적으로 표현하는 데는 한계가 있다.</p>
</li>
</ul>
<h4>3.4.3 최적 활용 시나리오</h4>
<ul>
<li>
<p><strong>시스템 초기 통합 테스트:</strong> 새로 작성한 노드들이 ROS 그래프에 정상적으로 연결되고, 의도한 대로 토픽을 통해 데이터를 주고받는지 <code>rqt_graph</code>로 확인하는 단계.</p>
</li>
<li>
<p><strong>간단한 센서 값 실시간 모니터링:</strong> 로봇의 배터리 전압, 모터의 현재 속도, 온도 센서 값과 같이 변화 추이만 간단히 확인하면 되는 단일 숫자 값을 <code>rqt_plot</code>으로 실시간 모니터링하는 경우.</p>
</li>
<li>
<p><strong>통합 로그 분석 및 오류 진단:</strong> 여러 노드에서 동시에 발생하는 경고(WARN)나 오류(ERROR) 메시지를 <code>rqt_console</code>에서 집중적으로 모니터링하여 문제의 원인을 추적하는 상황.</p>
</li>
</ul>
<h2>4. PlotJuggler: 고성능 시계열 데이터 분석 전문 도구</h2>
<h3>4.1 핵심 철학 및 기능</h3>
<p>PlotJuggler의 핵심 개발 철학은 명확하다: **“시계열 데이터에 대한 빠르고, 직관적이며, 강력한 분석 환경을 제공하는 것”**이다.20 이는<code>rqt_plot</code>과 같은 기본 도구가 제공하지 못하는 고성능 시각화와 심층적인 데이터 분석 기능에 대한 필요성에서 출발했다. 여러 로보틱스 기업의 추천사에서 언급되듯이, PlotJuggler는 디버깅 시간을 단축하고, 기존 도구로는 발견하기 어려운 문제를 찾아내는 데 기여하는 필수적인 도구로 평가받는다.20</p>
<p>PlotJuggler의 강력함은 다음과 같은 핵심 기능들의 조합에서 비롯된다.</p>
<ul>
<li>
<p><strong>직관적인 사용자 인터페이스:</strong> PlotJuggler의 가장 큰 특징은 <strong>드래그 앤 드롭(Drag &amp; Drop)</strong> 기반의 워크플로우이다. 좌측의 시계열 데이터 목록에서 분석하고 싶은 데이터를 마우스로 끌어다 중앙의 플롯 영역에 놓기만 하면 즉시 그래프가 그려진다. 이러한 직관적인 방식은 사용자가 복잡한 설정 과정 없이 데이터 탐색과 분석 자체에만 집중할 수 있게 해준다.20</p>
</li>
<li>
<p><strong>실시간 데이터 스트리밍 및 다중 소스 지원:</strong> ROS1/ROS2 토픽 구독과 같은 로보틱스 표준 프로토콜은 물론, MQTT, ZeroMQ, Websockets 등 산업계에서 널리 사용되는 다양한 실시간 데이터 스트리밍 프로토콜을 플러그인 형태로 지원한다.20 이는 로봇 내부의 데이터뿐만 아니라 외부 서버나 다른 장치로부터 오는 데이터를 통합하여 분석할 수 있음을 의미한다.</p>
</li>
<li>
<p><strong>강력한 데이터 변환 및 분석 기능:</strong> PlotJuggler는 단순히 데이터를 그리는 것을 넘어, 데이터를 적극적으로 가공하고 분석할 수 있는 강력한 도구를 제공한다.</p>
</li>
<li>
<p><strong>내장 변환(Built-in Transformations):</strong> 데이터에 대한 미분, 적분, 이동 평균, 스케일링 등 자주 사용되는 수학적 변환을 메뉴에서 선택하는 것만으로 간단하게 적용할 수 있다.20 예를 들어, 위치 데이터를 미분하여 속도를, 속도 데이터를 미분하여 가속도를 실시간으로 계산하고 플로팅할 수 있다.</p>
</li>
<li>
<p><strong>사용자 정의 함수(Custom Functions):</strong> PlotJuggler의 가장 강력한 기능 중 하나로, <strong>Lua 스크립팅 언어</strong>를 내장하여 여러 시계열 데이터를 입력으로 받아 새로운 시계열 데이터를 출력하는 복잡한 사용자 정의 함수를 작성할 수 있다.20 예를 들어, 로봇의 목표 위치(</p>
</li>
</ul>
<p><code>target_x</code>, <code>target_y</code>)와 현재 위치(<code>current_x</code>, <code>current_y</code>)라는 4개의 시계열 데이터를 입력으로 받아, 실시간으로 유클리드 거리 오차(<code>sqrt((target_x - current_x)^2 + (target_y - current_y)^2)</code>)를 계산하여 새로운 그래프로 플로팅하는 것이 가능하다. 이는 알고리즘의 성능을 정량적으로 평가하는 데 무한한 가능성을 열어준다.</p>
<h3>4.2 ROS2 연동 및 워크플로우</h3>
<p>PlotJuggler는 ROS2 환경과 매우 긴밀하게 통합되어 효율적인 분석 워크플로우를 제공한다.</p>
<ul>
<li>
<p><strong>rosbag 파일 분석:</strong> <code>ros2 bag record</code> 명령어로 기록된 <code>.db3</code> 또는 최신 표준인 <code>.mcap</code> 형식의 rosbag 파일을 직접 열 수 있다.20 파일이 로드되면, bag 파일 내에 기록된 모든 토픽과 그 메시지 필드들이 좌측 트리 뷰에 자동으로 표시되며, 사용자는 원하는 데이터를 드래그 앤 드롭하여 즉시 분석을 시작할 수 있다.</p>
</li>
<li>
<p><strong>실시간 토픽 구독:</strong> 실행 중인 ROS2 시스템에 직접 연결하여 실시간으로 발행되는 토픽을 구독하고 플로팅할 수 있다.20 데이터 소스 선택 메뉴에서 ’ROS Topic Subscriber’를 선택하면 현재 활성화된 토픽 목록이 나타나며, 이들을 선택하여 실시간 분석이 가능하다.</p>
</li>
<li>
<p><strong>레이아웃 저장 및 재사용:</strong> 복잡하게 구성된 플롯, 여러 개의 탭, 적용된 데이터 변환 및 사용자 정의 함수 등 현재의 분석 환경 전체를 하나의 XML 레이아웃 파일로 저장할 수 있다.24 이는 특정 제어기 튜닝이나 센서 검증과 같이 반복적으로 수행되는 분석 작업을 위해 미리 정의된 대시보드를 만들어두고, 필요할 때마다 즉시 불러와 사용할 수 있게 함으로써 작업 효율을 극적으로 향상시킨다.</p>
</li>
</ul>
<h3>4.3 설치 및 실행</h3>
<p>PlotJuggler를 ROS2 Humble 환경에 설치하고 실행하는 방법은 여러 가지가 있지만, Debian 패키지를 이용하는 것이 가장 간편하고 안정적이다.</p>
<ul>
<li>
<p><strong>Debian 패키지 (권장):</strong> ROS2 배포판에 맞춰 빌드된 패키지를 <code>apt</code>를 통해 설치한다. 이 방식은 ROS2 연동에 필요한 플러그인까지 한 번에 설치해준다.24</p>
<pre><code class="language-Bash">sudo apt update
sudo apt install ros-humble-plotjuggler-ros
</code></pre>
</li>
</ul>
<pre><code>
- **Snap 패키지:** ROS 환경과 독립적으로 항상 최신 버전의 PlotJuggler를 사용하고 싶을 때 유용한 방법이다. ROS2 지원이 포함된 버전을 설치해야 한다.24

  ```Bash
  sudo snap install plotjuggler
</code></pre>
<ul>
<li>
<p><strong>실행:</strong> 설치 방식에 따라 실행 명령어가 다르다.</p>
<pre><code class="language-Bash"># Debian 패키지로 설치한 경우 (ROS 연동 버전)
ros2 run plotjuggler plotjuggler

# Snap 패키지로 설치한 경우
plotjuggler
</code></pre>
</li>
</ul>
<pre><code>
### 4.4 장단점 및 활용 시나리오


PlotJuggler는 시계열 데이터 분석이라는 특정 목적에 고도로 특화된 도구로서, 그 활용 시나리오를 명확히 이해하는 것이 중요하다.

RViz2가 로봇의 최종적인 상태나 알고리즘의 '결과'(예: 생성된 경로, 인식된 객체의 위치)를 3D 공간상에서 시각화하는 데 강점을 가진다면, PlotJuggler는 그 결과에 도달하기까지의 동적인 '과정'을 시간 축 상에서 분석하는 데 특화되어 있다. 예를 들어, RViz2는 내비게이션 스택이 생성한 최종 경로를 `Path` 디스플레이로 보여주지만, PlotJuggler는 해당 경로를 로봇이 추종하는 과정에서 발생하는 횡 방향 오차(cross-track error)와 속도 프로파일의 변화를 밀리초 단위로 추적하여 보여줄 수 있다. 또한, 상태 추정 필터가 새로운 센서 측정값을 받았을 때, 필터의 상태 변수(state variable)와 공분산(covariance)이 어떻게 수렴해 나가는지를 정밀하게 분석할 수 있다. 이는 PlotJuggler가 단순히 데이터를 보여주는 '뷰어(viewer)'가 아니라, 동적 시스템의 내부 거동을 이해하고 알고리즘을 개선하기 위한 필수적인 '분석기(analyzer)'임을 명확히 보여준다.

#### 4.4.1 장점


- **압도적인 성능:** OpenGL 기반의 빠른 렌더링을 통해 수백만 개의 데이터 포인트로 구성된 대용량 시계열 데이터도 지연 없이 부드럽게 처리한다.24

- **뛰어난 사용성:** 매우 직관적인 UI와 드래그 앤 드롭 기반의 워크플로우는 사용자가 데이터 분석에만 집중할 수 있는 환경을 제공한다.25

- **강력한 분석 기능:** 내장된 다양한 수학적 변환 기능과 Lua 스크립트를 통한 사용자 정의 함수 기능은 거의 무한한 데이터 가공 및 분석 가능성을 제공한다.20

- **높은 확장성 및 호환성:** ROS를 포함한 다양한 실시간 스트리밍 소스와 CSV, ULog 등 여러 파일 포맷을 지원하여 높은 호환성을 자랑한다.20

#### 4.4.2 단점


- **3D 시각화 기능 부재:** 시계열 데이터 분석에만 집중하므로, 로봇 모델이나 3D 센서 데이터와 같은 공간적, 기하학적 정보를 시각화하는 기능은 전혀 없다.

- **ROS 그래프 상호작용 부재:** `rqt_graph`처럼 노드 간의 연결 관계를 보여주거나 시스템의 전체적인 구조를 분석하는 기능은 제공하지 않는다.

#### 4.4.3 최적 활용 시나리오


- **제어 시스템 튜닝:** PID 제어기나 모델 예측 제어(MPC)와 같은 제어 시스템의 게인 값을 변경하면서, 시스템의 응답 특성(상승 시간, 정착 시간, 오버슈트 등)을 실시간으로 플로팅하고 분석하여 최적의 파라미터를 찾는다.

- **센서 데이터 정밀 분석:** IMU 센서에서 출력되는 각속도 및 가속도 값의 노이즈 특성(예: 표준편차, 바이어스)을 분석하거나, GPS와 IMU 데이터 간의 시간 지연(latency)을 정밀하게 측정한다.

- **알고리즘 성능 비교:** 두 가지 다른 상태 추정 알고리즘(예: 확장 칼만 필터 vs 파티클 필터)을 동시에 실행하고, 각 필터가 추정한 위치와 실제 값(ground truth) 사이의 오차(RMSE)를 플로팅하여 성능을 정량적으로 비교 분석한다.

- **상태 추정 필터 디버깅:** 확장 칼만 필터(EKF)나 무향 칼만 필터(UKF)의 내부 상태, 예를 들어 예측 값과 측정 값 간의 차이인 이노베이션(innovation)과 그 공분산을 플로팅하여 필터의 수렴성과 안정성을 검증하고, 발산 원인을 분석한다.

## 5. Foxglove Studio: 현대적 통합 시각화 및 디버깅 플랫폼


### 5.1 핵심 철학 및 아키텍처


Foxglove Studio의 핵심 개발 철학은 **"로보틱스 데이터 시각화 및 디버깅의 현대화"**로 요약할 수 있다.3 이는 기존 ROS 중심의 도구들이 가진 한계, 예를 들어 특정 플랫폼(주로 Linux)에 대한 의존성, 다소 오래된 UI/UX, 그리고 팀 단위 협업 기능의 부재 등을 극복하려는 시도에서 출발한다. Foxglove는 이러한 문제들을 해결하기 위해 최신 웹 기술(TypeScript/JavaScript)을 적극적으로 채택하였으며, 그 결과 다음과 같은 아키텍처적 특징을 가진다.

- **크로스플랫폼 지원:** Electron 프레임워크를 기반으로 한 독립적인 데스크톱 애플리케이션(Linux, Windows, macOS 지원)과, 별도의 설치가 필요 없는 웹 브라우저 기반 애플리케이션을 모두 제공한다.30 이를 통해 개발자는 자신의 주력 운영체제와 상관없이 일관된 개발 및 분석 환경을 사용할 수 있다.

- **모듈형 패널(Panel) 기반 레이아웃:** Foxglove의 UI는 고도로 모듈화된 '패널'들의 조합으로 구성된다. 각 패널은 3D 뷰, 이미지 뷰, 데이터 플롯 등 특정 목적을 수행하는 독립적인 컴포넌트이다. 사용자는 이러한 패널들을 자유롭게 추가, 제거, 배치하여 자신만의 맞춤형 대시보드를 구성할 수 있으며, 이 레이아웃을 저장하고 팀원들과 쉽게 공유할 수 있다.11

- **팀 협업 기능:** Foxglove는 개인 사용을 넘어 팀 단위의 개발 워크플로우를 지원하는 데 중점을 둔다. 팀원들이 공유하는 표준 레이아웃을 만들어 디버깅 환경을 통일하거나, 클라우드에 저장된 데이터를 함께 분석하고 주석을 다는 등의 협업 기능을 제공한다.11

아키텍처 관점에서 RViz2가 ROS 생태계 내에서의 깊은 통합을 최우선으로 하는 반면, Foxglove는 ROS를 중요한 데이터 소스 중 하나로 취급하면서도, 비(非)ROS 데이터 소스와의 연동도 고려하는 보다 범용적이고 개방적인 구조를 지향한다.11

### 5.2 `foxglove_bridge`를 이용한 ROS2 연동


Foxglove Studio가 실행 중인 ROS2 시스템과 실시간으로 통신하기 위해 권장되는 방법은 `foxglove_bridge`라는 고성능 C++ 노드를 사용하는 것이다.33 이는 기존에 널리 사용되던

`rosbridge_suite`와 비교하여 몇 가지 중요한 장점을 가진다. `foxglove_bridge`는 WebSocket 프로토콜을 사용하지만, JSON 직렬화에 의존하는 `rosbridge`와 달리 바이너리 기반의 효율적인 데이터 전송이 가능하며, ROS2의 메시지 정의(.msg,.idl), 파라미터 시스템, 노드 그래프 정보 등 ROS2의 내부 구조를 더 깊이 있게 지원하도록 설계되었다.34

- **설치:** ROS2 Humble 배포판을 사용하는 경우, `apt` 패키지 관리자를 통해 매우 간단하게 설치할 수 있다.33

  ```Bash
  sudo apt update
  sudo apt install ros-humble-foxglove-bridge
</code></pre>
<ul>
<li>
<p><strong>실행:</strong> 아래의 launch 파일을 실행하면, <code>foxglove_bridge</code> 노드가 현재 ROS2 네트워크에서 활성화된 모든 토픽을 자동으로 감지하고, 이를 외부에서 접속할 수 있는 WebSocket 서버를 통해 중계하기 시작한다.33</p>
<pre><code class="language-Bash">ros2 launch foxglove_bridge foxglove_bridge_launch.xml
</code></pre>
</li>
</ul>
<pre><code>
- **연결:** Foxglove Studio 애플리케이션(웹 또는 데스크톱)을 열고, 데이터 소스 연결 메뉴에서 "Open connection" -&gt; "Foxglove WebSocket"을 선택한다. 이후 서버 주소를 입력하는 란에 로컬 머신에서 브릿지를 실행했다면 `ws://localhost:8765`, 로봇과 다른 PC에서 접속한다면 `ws://&lt;ROBOT_IP&gt;:8765`와 같이 브릿지가 실행 중인 기기의 주소를 입력하면 실시간 데이터 스트림에 연결된다.33

### 5.3 주요 패널(Panel) 기능 분석


Foxglove Studio의 모든 기능은 사용자가 조합하여 구성하는 **패널(Panel)**을 통해 제공된다. 각 패널은 특정 유형의 데이터를 시각화하거나 시스템과 상호작용하는 독립적인 모듈로서, RViz2의 디스플레이, RQT의 플러그인, PlotJuggler의 플롯 기능을 통합하고 재구성한 형태라고 볼 수 있다.31

Foxglove의 패널 시스템은 기존 도구들과는 다른 접근 방식을 보여준다. RViz2가 3D 공간이라는 단일한 컨텍스트를 중심으로 모든 데이터를 통합하려는 '공간 중심(space-centric)' 접근 방식을 취한다면, Foxglove는 `3D`, `Plot`, `Image`, `Log` 등 각기 다른 데이터 유형에 최적화된 독립적인 패널들을 제공하고, 사용자가 이를 자유롭게 조합하여 '데이터 중심(data-centric)'의 맞춤형 대시보드를 구성하게 한다. 예를 들어, 개발자는 로봇의 3D 모델과 주변 환경을 보여주는 `3D` 패널, 주행 속도와 배터리 잔량을 보여주는 `Plot` 패널, 전방 카메라 영상을 실시간으로 스트리밍하는 `Image` 패널, 그리고 제어 노드의 디버그 메시지를 출력하는 `Log` 패널을 하나의 화면에 그리드 형태로 배치할 수 있다. 이를 통해 특정 시점에서 로봇의 물리적 상태, 성능 지표, 외부 인식, 내부 로직 등 다중 모달리티(multi-modality) 정보를 통합적으로 분석하는 것이 가능해진다. 이는 모든 것을 단일 3D 뷰에 투영하려는 RViz2와는 근본적으로 다른 패러다임이며, 다양한 종류의 데이터를 동시에 다루어야 하는 현대 로보틱스 개발 환경에 더 적합한 유연성을 제공한다.

다음은 Foxglove Studio의 핵심적인 패널들이다.

- **3D Panel:** RViz2의 3D View와 가장 유사한 패널이다. `TF` 좌표계, `PointCloud2` 점 구름, `LaserScan`, `MarkerArray`, `OccupancyGrid` 등 ROS의 표준 3D 공간 데이터를 시각화하는 대부분의 기능을 지원한다. 토픽별로 색상, 크기 등 시각적 속성을 상세하게 설정할 수 있다.31

- **Plot Panel:** PlotJuggler와 유사한 기능을 제공하는 시계열 데이터 플로팅 패널이다. 여러 토픽의 특정 필드 값을 하나의 그래프에 중첩하여 그리거나, x축을 시간 대신 다른 토픽의 값으로 설정하는 등 유연한 구성이 가능하다. rosbag 파일 재생 시 전체 시간 범위의 데이터를 미리 로드하여 부드러운 탐색을 지원한다.31

- **Image Panel:** `sensor_msgs/msg/Image` 및 `sensor_msgs/msg/CompressedImage` 토픽을 표시한다. 단순히 이미지를 보여주는 것을 넘어, 2D 주석(annotation) 메시지를 오버레이하거나, 3D 마커를 이미지 평면에 투영하여 증강 현실(AR)과 같은 시각화를 구현하는 등 RViz2의 Image 디스플레이보다 향상된 기능을 제공한다.31

- **Log Panel:** `rqt_console`과 유사하게 ROS2 노드의 로그 메시지를 수집하고 표시한다. 심각도 수준 및 노드 이름에 따른 필터링 기능을 제공하여 디버깅을 용이하게 한다.31

- **Topic Graph Panel:** `rqt_graph`와 동일한 역할을 수행하는 패널로, 현재 시스템의 노드-토픽-서비스 간의 연결 관계를 그래프 형태로 시각화한다.31

- **Diagnostics Panel:** `diagnostic_msgs/msg/DiagnosticArray` 메시지를 구독하여 시스템을 구성하는 각 하드웨어나 소프트웨어 컴포넌트의 상태(OK, WARN, ERROR, STALE)를 체계적으로 보여준다. 시스템의 전반적인 건전성(health)을 모니터링하는 데 매우 유용하다.31

- **Teleop Panel:** GUI 상의 조이스틱이나 버튼을 통해 `geometry_msgs/msg/Twist` 메시지를 특정 토픽으로 발행하여 로봇을 원격으로 조종할 수 있게 해준다.31

### 5.4 장단점 및 활용 시나리오


Foxglove Studio는 기존 도구들의 장점을 통합하려는 강력한 시도이지만, 그에 따른 트레이드오프도 존재한다.

#### 5.4.1 장점


- **뛰어난 사용자 경험(UX):** 현대적이고 매우 직관적인 UI를 제공한다. 패널 기반의 레이아웃을 자유롭게 구성하고, 이를 JSON 파일로 저장하거나 팀원들과 URL로 공유하는 과정이 매우 편리하다.32

- **크로스플랫폼 및 높은 접근성:** 웹 브라우저만 있으면 OS에 상관없이 어디서든 로봇 데이터에 접근할 수 있어, 원격 디버깅이나 재택근무 환경에서의 팀 협업에 매우 유리하다.30

- **통합된 기능성:** RViz2의 3D 시각화, RQT의 시스템 인트로스펙션, PlotJuggler의 시계열 분석 등 여러 핵심 기능을 별도의 애플리케이션 전환 없이 단일 환경 내에서 패널 형태로 제공한다.

- **용이한 확장성:** JavaScript/TypeScript 기반의 확장 API를 제공하여 사용자가 자신만의 커스텀 패널을 개발할 수 있다. 이는 네이티브 C++로 플러그인을 개발해야 하는 RViz2에 비해 진입 장벽이 현저히 낮고, 웹 개발자들에게 친숙하다.11

- **네이티브 `rosbag` 재생:** 별도의 CLI 명령어 없이, `.bag`, `.db3`, `.mcap` 파일을 탐색기에서 드래그 앤 드롭하는 것만으로 즉시 데이터를 재생하고 분석할 수 있어 매우 편리하다.11

#### 5.4.2 단점


- **제한적인 3D 상호작용:** `InteractiveMarker`와 같이 3D 씬 내의 가상 객체를 마우스로 직접 조작하여 로봇의 목표 자세를 설정하거나 모션 플래닝을 트리거하는 일부 고급 상호작용 기능은 C++ 기반으로 깊게 통합된 RViz2에 비해 제한적일 수 있다.10

- **잠재적인 성능 한계:** 웹 기반 기술의 근본적인 특성상, 매우 높은 주파수로 발행되는 대용량 3D 데이터(예: 여러 대의 라이다 포인트 클라우드)를 동시에 처리할 때, 네이티브 C++ 애플리케이션인 RViz2에 비해 성능 저하가 발생할 수 있다. (물론, 고성능 C++ 노드인 `foxglove_bridge`가 이러한 성능 저하를 상당 부분 완화해준다.)

#### 5.4.3 최적 활용 시나리오


- **팀 단위 협업 프로젝트:** 표준화된 디버깅 레이아웃을 팀 전체에 공유하여 개발 환경을 통일하고, 원격지에 있는 동료와 실시간으로 동일한 데이터를 함께 보며 페어 디버깅(pair debugging)을 수행하는 경우.11

- **통합 데이터 대시보드 구축:** 로봇의 3D 상태(`3D` 패널), 주요 성능 지표(예: CPU 사용률, 경로 추종 오차 등) 그래프(`Plot` 패널), 전방 및 측면 카메라 영상(`Image` 패널), 그리고 시스템의 주요 이벤트 로그(`Log` 패널)를 하나의 화면에서 동시에 모니터링하는 중앙 관제 시스템을 구축할 때.

- **발표 및 데모:** 웹 기반으로 쉽게 접근하고 공유할 수 있다는 장점을 활용하여, 로봇의 작동 상태나 알고리즘의 성능을 외부 관계자나 비전문가에게 시연하거나, 학회 발표 자료로 활용하기에 매우 용이하다.

## 6. 핵심 시각화 도구 비교 분석 및 선택 가이드


지금까지 ROS2 Humble 생태계의 네 가지 핵심 시각화 도구인 RViz2, RQT, PlotJuggler, Foxglove Studio를 각각 심층적으로 분석했다. 각 도구는 고유한 강점과 약점을 가지고 있으며, 특정 개발 시나리오에 더 적합한 특성을 보인다. 이 섹션에서는 이 도구들을 종합적으로 비교하고, 개발자가 자신의 프로젝트 요구사항과 현재 개발 단계에 맞춰 최적의 도구를 선택하고 조합하는 전략적인 가이드를 제공한다.

### 6.1 종합 비교 테이블


아래 표는 네 가지 도구의 핵심적인 특징을 여러 평가 기준에 따라 비교하여 한눈에 파악할 수 있도록 정리한 것이다. 이 표는 개발자가 자신의 요구사항에 가장 부합하는 도구가 무엇인지 전략적인 결정을 내리는 데 중요한 기준점을 제공한다. 각 평가 기준은 실제 로봇 개발자가 시각화 도구를 선택할 때 현실적으로 고려하는 핵심 요소들로 구성되었다.

| 평가 기준           | RViz2                               | RQT 도구 모음                                   | PlotJuggler                                 | Foxglove Studio                                   |
| --------------- | ----------------------------------- | ------------------------------------------- | ------------------------------------------- | ------------------------------------------------- |
| **주요 사용 사례**    | 3D 공간/기하학 데이터 시각화, 내비게이션/매니퓰레이션 디버깅 | 시스템 연결 상태 확인, 간단한 토픽 값/로그 모니터링, 서비스/파라미터 제어 | 고성능 시계열 데이터 분석, 제어/추정 알고리즘 튜닝, 센서 데이터 정밀 검증 | 통합 데이터 대시보드, 팀 협업, 원격 디버깅, `rosbag` 분석            |
| **UI / UX**     | 기능적이지만 복잡하고 다소 구식임 10               | 간단하고 가볍지만, 통합성이 부족하고 시각적으로 투박함              | 직관적인 드래그 앤 드롭, 반응성이 뛰어남 20                  | 현대적이고 세련되며, 사용자 커스터마이징이 매우 유연함 31                 |
| **성능**          | 대용량 3D 데이터 처리에 최적화된 네이티브 성능         | 매우 가볍지만, `rqt_plot` 등 일부 플러그인은 성능 한계 명확     | 대용량 시계열 데이터 처리에 매우 빠름 24                    | `foxglove_bridge`를 통해 우수한 성능을 보이나, 웹 기반 한계 가능성 존재 |
| **확장성**         | C++ 플러그인 (진입 장벽 높음, 강력한 기능) 7       | Python/C++ 플러그인 (간단한 위젯 추가 용이) 15           | C++ 플러그인 (데이터 소스/포맷 추가) 20                  | JavaScript/TypeScript 확장 (진입 장벽 낮음, 빠른 개발) 11     |
| **ROS 통합 수준**   | 최상 (TF, 파라미터 등 모든 핵심 기능과 완벽 연동)     | 높음 (노드, 토픽, 서비스 등 기본 개념과 연동)                | 높음 (토픽 구독, `rosbag` 로딩 등)                   | 매우 높음 (`foxglove_bridge`를 통한 깊은 연동)               |
| **`rosbag` 처리** | 외부 `ros2 bag play` 명령어 필요 11        | 불가능                                         | 내장 기능으로 직접 파일 로드 및 분석 가능 20                 | 내장 기능으로 드래그 앤 드롭 방식의 손쉬운 재생 및 분석 11               |

### 6.2 상황별 최적 도구 조합 추천


효율적인 로보틱스 개발 워크플로우는 단 하나의 '만능 도구'에 의존하는 것이 아니라, 당면한 과제의 특성에 맞춰 여러 도구의 장점을 유기적으로 결합하는 **'도구 체인(Toolchain)'**을 구성하는 데서 비롯된다. 각 도구는 명확한 강점과 약점을 가지고 있어, 하나의 도구만으로는 모든 개발 및 디버깅 요구사항을 완벽하게 충족시키기 어렵다. 예를 들어, 시스템의 노드 연결 상태에 문제가 의심될 때는 `rqt_graph`를 가장 먼저 확인하고(1단계), 로봇의 3D 공간상 움직임에 이상이 보이면 RViz2에서 TF 트리와 센서 데이터를 관찰하며(2단계), 동시에 PlotJuggler로 해당 움직임을 제어하는 액추에이터의 명령 값과 실제 응답 값을 플로팅하여 제어기의 성능을 정량적으로 분석하는(3단계) 워크플로우는 각 도구의 장점을 극대화하는 효과적인 접근 방식이다. Foxglove Studio는 이러한 여러 도구의 기능을 하나의 통합된 플랫폼으로 제공하려는 훌륭한 시도이지만, 3D 공간과의 깊은 상호작용이나 고도로 복잡한 시계열 데이터 분석과 같은 각 전문 분야에서는 여전히 RViz2나 PlotJuggler가 더 깊이 있는 기능을 제공할 수 있다. 따라서 숙련된 개발자는 '만능 도구'를 찾기보다, 당면한 문제의 본질을 파악하고 그에 맞춰 여러 도구를 유연하게 연계하는 '도구 체인'을 구축하는 능력을 갖추어야 한다.

다음은 일반적인 개발 단계와 상황에 따른 최적의 도구 조합 추천이다.

#### 6.2.1 초기 개발 및 노드 통합 단계


- **추천 조합:** **`rqt_graph` + `rqt_console` + RViz2**

- **이유:** 이 단계의 주된 목표는 새로 개발한 노드들이 ROS2 계산 그래프에 올바르게 통합되고, 기본적인 통신이 정상적으로 이루어지는지 확인하는 것이다. `rqt_graph`를 사용하여 노드 간의 발행/구독 관계가 의도대로 설정되었는지 시각적으로 확인한다. `rqt_console`을 통해 노드 초기화 과정에서 발생하는 `INFO` 또는 `ERROR` 로그를 분석하여 설정 파일 로딩 등의 문제를 진단한다. 마지막으로, RViz2의 `TF`와 `RobotModel` 디스플레이를 통해 로봇의 기본 좌표계와 3D 모델이 올바르게 로드되고 표시되는지 검증한다.

#### 6.2.2 자율주행 및 내비게이션 알고리즘 개발


- **추천 조합:** **RViz2 + PlotJuggler**

- **이유:** 자율주행 알고리즘 디버깅은 공간적 정보와 시간적 정보를 동시에 분석해야 하는 복합적인 작업이다. RViz2를 메인 시각화 도구로 사용하여 지도(Map), 로봇의 위치(TF), 라이다 데이터(LaserScan), 계획된 전역 경로(Path), 실시간으로 생성되는 지역 경로(Local Path), 그리고 장애물 회피를 위한 비용 지도(Costmap) 등 공간 정보를 종합적으로 시각화한다. 동시에, 별도의 모니터에 PlotJuggler를 실행하여 경로 추종 오차(cross-track error), 목표 속도와 실제 속도의 차이, 제어기 출력 값의 변화 등 핵심 성능 지표(KPI)를 시계열 그래프로 정밀하게 분석한다. 이 조합을 통해 "로봇이 왜 저 지점에서 경로를 이탈했는가?"라는 질문에 대해 "경로의 곡률이 급격히 변하는 구간에서 속도 제어기의 오버슈트가 발생했기 때문"이라는 깊이 있는 답변을 얻을 수 있다.

#### 6.2.3 원격 모니터링 및 팀 협업 환경


- **추천 조합:** **Foxglove Studio**

- **이유:** 여러 명의 개발자가 참여하는 프로젝트나, 로봇이 있는 현장과 개발자의 사무실이 물리적으로 떨어져 있는 경우에 가장 이상적인 솔루션이다. `foxglove_bridge`만 로봇 측 PC에서 실행해두면, 팀원들은 각자의 컴퓨터에서 별도의 ROS2 설치 없이 웹 브라우저를 통해 로봇의 모든 데이터에 실시간으로 접근할 수 있다. 사전에 정의된 표준 레이아웃을 팀 전체에 공유함으로써, 모든 팀원이 동일한 시각화 환경에서 데이터를 분석하고 소통하여 문제 해결의 효율성을 높일 수 있다.

#### 6.2.4 데이터 분석 및 알고리즘 성능 보고


- **추천 조합:** **PlotJuggler + Foxglove Studio**

- **이유:** `rosbag`에 기록된 대규모 실험 데이터를 심층적으로 분석하고, 그 결과를 안내서 형태로 정리하는 데 최적화된 조합이다. 먼저, PlotJuggler의 강력한 데이터 변환 및 분석 기능(Lua 스크립트 등)을 사용하여 `rosbag` 파일에서 의미 있는 성능 지표들을 추출하고 분석하여 핵심적인 인사이트를 도출한다. 그 다음, 분석 결과를 CSV 파일 등으로 내보내거나, 분석에 사용된 핵심 그래프들을 Foxglove의 `Plot` 패널에서 재구성한다. 최종적으로 Foxglove의 유연한 레이아웃 기능을 활용하여, 분석 그래프(`Plot` 패널), 관련 이미지나 동영상(`Image` 패널), 그리고 분석 내용에 대한 설명(`Markdown` 패널)을 조합하여 시각적으로 풍부하고 이해하기 쉬운 통합 분석 안내서를 작성하고 팀원들과 공유한다.

## 7. 결론: 목적 지향적 도구 선택을 통한 개발 효율성 극대화


본 안내서는 ROS2 Humble 생태계의 네 가지 핵심 시각화 도구인 RViz2, RQT 도구 모음, PlotJuggler, 그리고 Foxglove Studio를 심층적으로 분석하고 비교했다. 분석 결과, 이 도구들은 서로를 대체하는 경쟁 관계가 아니라, 각기 다른 강점을 가지고 로봇 개발의 다양한 측면을 지원하는 **상호 보완적 관계**에 있다는 점이 명확해졌다.

각 도구의 역할을 비유적으로 표현하자면 다음과 같다.

- **RViz2**는 로봇의 3차원 물리적 세계를 들여다보는 **'디지털 트윈 창'**으로, 공간적 인지와 기하학적 관계를 파악하는 데 필수적인 표준 도구이다.

- **RQT 도구 모음**은 시스템의 내부 데이터 흐름과 상태를 신속하게 진단하는 의사의 **'청진기'**와 같으며, 시스템의 전반적인 건강 상태를 빠르고 가볍게 점검하는 데 사용된다.

- **PlotJuggler**는 동적 시스템의 미세한 시간적 변화를 정밀하게 분석하는 **'오실로스코프' 또는 '심전도(EKG) 분석기'**에 비유할 수 있으며, 제어 및 추정 알고리즘의 성능을 극한까지 튜닝하는 데 특화되어 있다.

- **Foxglove Studio**는 이 모든 정보를 하나의 화면에 통합하여 보여주는 **'현대적인 중앙 관제실'**로서, 특히 팀 단위의 협업과 원격 모니터링 환경에서 그 가치를 발휘한다.

결론적으로, 성공적인 로보틱스 개발자는 특정 도구 하나에만 얽매이는 대신, 현재의 개발 단계와 해결하고자 하는 문제의 본질을 명확히 파악하고, 그에 맞춰 이러한 도구들을 유연하게 조합하여 사용하는 **'폴리글랏(Polyglot)' 접근법**을 취해야 한다. 시스템의 뼈대를 세울 때는 RQT와 RViz2를, 알고리즘의 성능을 다듬을 때는 RViz2와 PlotJuggler를, 그리고 팀과 함께 결과를 공유하고 원격으로 시스템을 관리할 때는 Foxglove Studio를 활용하는 지혜가 필요하다. 이 안내서가 ROS2 Humble을 사용하는 모든 개발자들이 자신의 목적에 맞는 최적의 시각화 워크플로우를 구축하고, 이를 통해 개발 효율성을 극대화하는 데 견고한 이론적, 실용적 토대가 되기를 바란다.

## 8. 참고 자료


1. 6) RViz 2​ - Olive Robotics, https://olive-robotics.com/docs2/rviz-2/
2. 3 Rviz2 usage · GitBook, https://docs.elephantrobotics.com/docs/Mercury_B1_en/11-ApplicationBaseROS/11.2-ROS2/11.2.3-Rviz2Introduction.html
3. ROS 2 Humble Hawksbill Release! - Open Robotics, https://www.openrobotics.org/blog/2022/5/24/ros-2-humble-hawksbill-release
4. Rviz2 · User Manual - GitHub Pages, https://turtlebot.github.io/turtlebot4-user-manual/software/rviz.html
5. ROS2 Part 15 - RViz2 - RoboticsUnveiled, https://www.roboticsunveiled.com/ros2-rviz2/
6. ros2/rviz: ROS 3D Robot Visualizer - GitHub, https://github.com/ros2/rviz
7. Building a Custom RViz Display — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Intermediate/RViz/RViz-Custom-Display/RViz-Custom-Display.html
8. RViz User Guide — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Intermediate/RViz/RViz-User-Guide/RViz-User-Guide.html
9. Robot Operating System: How to Model Point Cloud Data in ROS2 | by Sebastian - Medium, https://medium.com/geekculture/robot-operating-system-how-to-model-point-cloud-data-in-ros2-d36674619078
10. Comparing Robotics Visualization Tools: RViz, Foxglove, Rerun | ReductStore, https://www.reduct.store/blog/comparison-rviz-foxglove-rerun
11. Foxglove vs. RViz., https://foxglove.dev/blog/foxglove-vs-rviz
12. RoArm-M1 Tutorial VIII: Use of rqt in ROS2 - Waveshare Wiki, https://www.waveshare.com/wiki/RoArm-M1_Tutorial_VIII:_Use_of_rqt_in_ROS2
13. Overview and usage of RQt — ROS 2 Documentation: Foxy 文档, https://daobook.github.io/ros2-docs/foxy/Concepts/About-RQt.html
14. Overview and usage of RQt — ROS 2 Documentation: Foxy documentation, https://docs.ros.org/en/foxy/Concepts/About-RQt.html
15. Overview and usage of RQt — ROS 2 Documentation: Humble ..., https://docs.ros.org/en/humble/Concepts/Intermediate/About-RQt.html
16. Using turtlesim, ros2, and rqt — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Introducing-Turtlesim/Introducing-Turtlesim.html
17. Understanding topics — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html
18. Understanding topics — ROS 2 Documentation: Rolling documentation, https://docs.ros.org/en/rolling/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html
19. rqt_plot - ROS Wiki, http://wiki.ros.org/rqt_plot
20. PlotJuggler, https://plotjuggler.io/
21. Issues · ros-visualization/rqt_plot - GitHub, https://github.com/ros-visualization/rqt_plot/issues
22. Using rqt_console to view logs — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Using-Rqt-Console/Using-Rqt-Console.html
23. Using rqt_console and roslaunch - ROS Wiki, http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch
24. plotjuggler: Humble 3.10.11 documentation, https://docs.ros.org/en/humble/p/plotjuggler/
25. Basics: how to visualize your data - PlotJuggler, https://facontidavide.github.io/PlotJuggler/visualization_howto/index.html
26. plotjuggler_ros: Humble 2.3.1 documentation, https://docs.ros.org/en/ros2_packages/humble/api/plotjuggler_ros/
27. ROS2 Plotting Tutorial with PlotJuggler - A Simple Way to Plot in ROS - YouTube, https://www.youtube.com/watch?v=MnMGjvYxlUk
28. ROS Package: plotjuggler_ros, https://index.ros.org/p/plotjuggler_ros/
29. 5) Plot Juggler​ - Olive Robotics, https://olive-robotics.com/docs2/plot-juggler/
30. FoxgloveStudio - ROS Wiki, http://wiki.ros.org/FoxgloveStudio
31. Visualizing ROS 2 data with Foxglove Studio - ROS documentation, https://docs.ros.org/en/humble/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.html
32. Layouts | Foxglove Docs, https://docs.foxglove.dev/docs/visualization/layouts
33. ROS 2 | Foxglove Docs, https://docs.foxglove.dev/docs/getting-started/frameworks/ros2
34. Foxglove WebSocket bridge for ROS 1 - GitHub, https://github.com/foxglove/ros-foxglove-bridge
35. Panels | Foxglove Docs, https://docs.foxglove.dev/docs/visualization/panels
36. Visualizing ROS 2 data with Foxglove - ROS documentation, https://docs.ros.org/en/rolling/Related-Projects/Visualizing-ROS-2-Data-With-Foxglove.html
37. Image panel | Foxglove Docs, https://docs.foxglove.dev/docs/visualization/panels/image
38. Extensions | Foxglove Docs, https://docs.foxglove.dev/docs/extensions</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>