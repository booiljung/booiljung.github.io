<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS 2 Humble package.xml 완벽 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS 2 Humble package.xml 완벽 안내서</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">ROS2 (Robot Operating System 2)</a> / <a href="../index.html">ROS2 Versions</a> / <a href="index.html">ROS2 Humble</a> / <span>ROS 2 Humble package.xml 완벽 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS 2 Humble package.xml 완벽 안내서</h1>
<h2>1. <code>package.xml</code>의 진정한 역할</h2>
<p>ROS 2 패키지를 다루다 보면 <code>package.xml</code> 파일을 마주하게 된다. 많은 개발자들이 이를 단순히 패키지 이름, 버전, 작성자 정보 등을 담는 메타데이터 파일로 취급하곤 한다. 하지만 이는 <code>package.xml</code>의 역할을 과소평가하는 것이다. 이 파일은 단순한 정보의 나열이 아니라, ROS 2 생태계 전체와 소통하는 패키지의 **공식 명세서(public API)**이자 <strong>계약서</strong>다.</p>
<p><code>package.xml</code>은 패키지의 정체성을 정의하고, 시스템의 다른 부분들과 어떻게 상호작용할지를 명시하는 핵심적인 역할을 수행한다. 예를 들어, 빌드 도구인 <code>colcon</code>은 이 파일을 읽어 패키지 간의 빌드 순서를 결정한다. 의존성 관리 도구인 <code>rosdep</code>은 이 파일을 참조하여 필요한 시스템 라이브러리를 설치한다. <code>ros2 launch</code>나 <code>ros2 run</code> 같은 커맨드 라인 도구들 역시 이 파일을 통해 패키지의 위치와 실행에 필요한 정보를 파악한다.1</p>
<p>이처럼 <code>package.xml</code>은 ROS 2의 다양한 도구들이 각자의 역할을 수행할 수 있도록 표준화된 인터페이스를 제공하는 중심축이다. <code>colcon</code>이 <code>CMakeLists.txt</code>나 <code>setup.py</code>의 복잡한 문법을 직접 해석할 필요 없이 빌드 순서를 알 수 있는 것도, <code>rosdep</code>이 C++ 코드의 내용을 몰라도 필요한 라이브러리를 설치할 수 있는 것도 모두 <code>package.xml</code>이라는 잘 정의된 계약서 덕분이다. 이러한 설계는 ROS 2 생태계의 각 도구들이 서로 느슨하게 결합(decoupled)되어 독립적으로 발전할 수 있게 만드는 핵심 원리다.4</p>
<p>이 안내서는 <code>package.xml</code>의 모든 것을 다룬다. 기본적인 파일 구조와 필수 태그부터 시작하여, 복잡한 의존성 관계를 정의하는 방법, 빌드 시스템과의 연동, 고급 기능 활용법, 그리고 실제 프로젝트에서 적용할 수 있는 모범 사례와 흔히 발생하는 문제들의 해결책까지 깊이 있게 파고들 것이다. 이 문서를 끝까지 읽고 나면, <code>package.xml</code>을 단순한 설정 파일이 아닌, ROS 2 패키지의 잠재력을 최대한으로 이끌어내는 강력한 도구로 활용할 수 있게 될 것이다.</p>
<h2>2.  <code>package.xml</code> 포맷 3: 해부학</h2>
<p>ROS 2 Humble은 <code>package.xml</code> 포맷 3을 표준으로 사용한다. 이 포맷은 REP-149에 명시되어 있으며, 이전 포맷에 비해 조건부 의존성 선언과 같은 강력한 기능들이 추가되었다.7 패키지를 생성하면 다음과 같은 기본 구조를 가진 <code>package.xml</code> 파일이 만들어진다.1</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
&lt;package format="3"&gt;
  &lt;name&gt;my_package&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;TODO: Package description&lt;/description&gt;
  &lt;maintainer email="user@todo.todo"&gt;user&lt;/maintainer&gt;
  &lt;license&gt;TODO: License declaration&lt;/license&gt;

  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;

  &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;

  &lt;export&gt;
    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;
  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<h3>2.1  XML 프롤로그와 스키마 선언</h3>
<p>파일의 가장 첫 두 줄은 XML 문서의 표준 선언과 스키마 정의를 담고 있다.</p>
<ul>
<li><code>&lt;?xml version="1.0"?&gt;</code>: 이 파일이 표준 XML 1.0 형식임을 선언한다.</li>
<li><code>&lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;</code>: 이 줄은 <code>package.xml</code> 파일의 구조와 유효성을 검증하는 데 사용될 XSD(XML Schema Definition) 파일의 위치를 지정한다.8 즉, 이 파일은 <code>package.xml</code>이 따라야 할 “설계도“와 같다. <code>ament_xmllint</code>와 같은 린팅 도구는 이 스키마를 기준으로 파일의 문법적 정확성을 검사하므로, 이 선언은 매우 중요하다.11</li>
</ul>
<h3>2.2  루트 태그: <code>&lt;package format="3"&gt;</code></h3>
<p>모든 내용은 <code>&lt;package&gt;</code> 루트 태그 안에 위치한다. 여기서 <code>format="3"</code> 속성은 이 파일이 REP-149에 명시된 포맷 3 사양을 따른다는 것을 명확히 한다.7 이 속성이 있어야만 <code>&lt;group_depend&gt;</code>나 <code>condition</code> 속성 같은 포맷 3의 새로운 기능들을 올바르게 사용할 수 있다. ROS 2는 이전 버전인 포맷 2도 지원하지만, 특별한 이유가 없다면 Humble에서는 포맷 3을 사용하는 것이 표준이다.13</p>
<h3>2.3  필수 태그: 패키지의 신분증</h3>
<p>모든 ROS 2 패키지는 자신의 정체성을 나타내는 최소한의 정보를 반드시 포함해야 한다. 이 정보들은 패키지의 “신분증“과 같은 역할을 한다.7</p>
<ul>
<li>
<p><strong><code>&lt;name&gt;</code></strong>: 패키지의 고유한 이름이다. 이 이름은 ROS 생태계 전체에서 유일해야 하며, 다른 패키지들이 이 패키지를 참조하거나 <code>ros2 run &lt;package_name&gt; &lt;executable_name&gt;</code>과 같이 커맨드 라인에서 사용할 때 식별자로 사용된다. 패키지 이름은 소문자, 숫자, 그리고 밑줄(<code>_</code>)만으로 구성하는 것이 규칙이다.1</p>
</li>
<li>
<p><strong><code>&lt;version&gt;</code></strong>: 패키지의 현재 버전을 나타낸다. ROS 커뮤니티는 유의적 버전(Semantic Versioning)을 따를 것을 강력히 권장한다. 버전은 <code>MAJOR.MINOR.PATCH</code> (예: <code>1.2.3</code>) 형식으로 구성되며, 각 숫자는 API 호환성과 변경 사항의 종류를 나타낸다.14</p>
</li>
</ul>
<p><code>bloom</code>과 같은 배포 도구는 이 버전 정보를 사용하여 릴리스를 관리하고 Git 태그와 연동하므로 정확하게 관리하는 것이 매우 중요하다.7</p>
<ul>
<li>
<p><strong><code>&lt;description&gt;</code></strong>: 패키지의 기능과 목적을 설명하는 텍스트다. 다른 개발자들이 이 패키지가 무엇을 하는지 빠르고 명확하게 이해할 수 있도록 작성해야 한다. 여러 줄에 걸쳐 상세한 설명도 가능하다.7</p>
</li>
<li>
<p><strong><code>&lt;maintainer&gt;</code></strong>: 패키지를 유지보수하는 책임자를 명시한다. <code>email</code> 속성은 필수로 포함해야 하며, 패키지에 문제가 발생했을 때 사용자들이 연락할 수 있는 공식적인 창구 역할을 한다. 프로젝트의 규모가 크거나 여러 사람이 관리하는 경우, 여러 개의 <code>&lt;maintainer&gt;</code> 태그를 사용하여 다수의 책임자를 지정할 수 있다.7</p>
</li>
<li>
<p><strong><code>&lt;license&gt;</code></strong>: 패키지에 적용되는 소프트웨어 라이선스를 명시한다. 오픈소스 프로젝트의 경우, 라이선스를 명확히 하는 것은 법적으로 매우 중요하다. Apache-2.0, BSD, MIT 등 SPDX 표준 라이선스 식별자를 사용하는 것이 일반적이다. <code>ros2 pkg create</code> 명령어에 <code>--license Apache-2.0</code>와 같은 옵션을 주면 자동으로 해당 라이선스 태그와 <code>LICENSE</code> 파일이 생성된다.1</p>
</li>
</ul>
<h3>2.4  선택적 메타데이터 태그</h3>
<p>필수 태그 외에도 패키지에 대한 추가 정보를 제공하여 사용자의 이해를 돕고 커뮤니티 참여를 유도하는 여러 선택적 태그가 있다.</p>
<ul>
<li><strong><code>&lt;author&gt;</code></strong>: 패키지를 처음 개발한 사람이나 기여자를 명시한다. 유지보수 담당자(<code>maintainer</code>)와 작성자는 다를 수 있다. 여러 명의 작성자가 있다면 여러 개의 <code>&lt;author&gt;</code> 태그를 사용할 수 있다.17</li>
<li><strong><code>&lt;url&gt;</code></strong>: 패키지와 관련된 웹사이트 주소를 제공한다. <code>type</code> 속성을 사용하여 URL의 성격을 명확히 할 수 있다.</li>
<li><code>website</code>: 패키지 공식 웹사이트나 위키 페이지 (예: <code>http://wiki.ros.org/my_package</code>)</li>
<li><code>repository</code>: 소스 코드가 저장된 Git 저장소 주소 (예: <code>https://github.com/my_org/my_package</code>)</li>
<li>bugtracker: 버그나 이슈를 보고할 수 있는 이슈 트래커 주소 (예: https://github.com/my_org/my_package/issues) 이러한 정보는 사용자가 패키지에 대한 더 깊은 정보를 얻거나 프로젝트에 기여하고자 할 때 매우 유용하다.7</li>
</ul>
<h2>3.  핵심 기능: 의존성(Dependency) 선언</h2>
<p><code>package.xml</code>의 가장 중요하고 핵심적인 기능은 바로 의존성 관리다. 패키지가 올바르게 빌드되고 실행되기 위해 필요한 다른 패키지나 시스템 라이브러리가 무엇인지 명시하는 역할을 한다.</p>
<h3>3.1  왜 두 번 선언해야 하는가? (<code>package.xml</code> vs. <code>CMakeLists.txt</code>/<code>setup.py</code>)</h3>
<p>ROS 개발을 처음 접하는 사람들이 가장 흔하게 던지는 질문 중 하나는 “왜 <code>package.xml</code>과 <code>CMakeLists.txt</code>에 의존성을 두 번씩이나 선언해야 하는가?“이다. 이는 중복 작업처럼 보일 수 있지만, 실제로는 두 파일이 서로 다른 대상과 목적을 위해 의존성을 선언하기 때문에 발생하는 의도된 설계다.4</p>
<ul>
<li>package.xml의 역할: 생태계 도구를 위한 선언</li>
</ul>
<p>package.xml에 명시된 의존성은 ROS 2 생태계의 고수준 도구들을 위한 것이다.</p>
<ul>
<li><strong><code>rosdep</code></strong>: <code>rosdep install --from-paths src --ignore-src -y</code> 명령을 실행하면, <code>rosdep</code>은 <code>src</code> 폴더 내 모든 패키지의 <code>package.xml</code> 파일을 스캔한다. 그리고 파일에 선언된 의존성 ’키(key)’들을 <code>rosdistro</code> 데이터베이스와 비교하여, 현재 운영체제에 맞는 시스템 패키지(예: <code>libboost-dev</code>, <code>python3-numpy</code>)를 <code>apt</code>나 <code>dnf</code> 같은 시스템 패고지 관리자를 통해 자동으로 설치해준다.6</li>
<li><strong><code>colcon</code></strong>: <code>colcon build</code> 명령을 실행하면, <code>colcon</code> 역시 <code>package.xml</code>을 읽어 워크스페이스 내 패키지들 간의 의존성 그래프를 그린다. 이 그래프를 바탕으로 어떤 패키지를 먼저 빌드해야 하는지 위상 정렬(topological sort)을 수행하여 올바른 순서로 빌드를 진행한다. 예를 들어, 패키지 A가 패키지 B에 의존한다면, <code>colcon</code>은 반드시 B를 먼저 빌드한 후에 A를 빌드한다.4</li>
</ul>
<p>이처럼 <code>package.xml</code>은 패키지 외부의 도구들에게 “이 패키지를 빌드하고 실행하려면 <strong>무엇이</strong> 필요한가?“에 대한 정보를 제공하는 <strong>선언적 명세</strong>다.</p>
<ul>
<li>CMakeLists.txt / setup.py의 역할: 빌드 시스템을 위한 선언</li>
</ul>
<p>반면, CMakeLists.txt의 find_package()나 setup.py의 install_requires는 실제 컴파일러와 링커, 즉 빌드 시스템 자체를 위한 것이다.</p>
<ul>
<li><strong><code>find_package(rclcpp REQUIRED)</code> (in <code>CMakeLists.txt</code>)</strong>: 이 구문은 CMake에게 <code>rclcpp</code> 패키지를 찾아달라고 요청한다. CMake는 이 요청을 받아 해당 패키지가 제공하는 헤더 파일의 경로, 라이브러리 파일의 경로 등의 정보를 찾아내어 컴파일러와 링커에게 전달한다.</li>
<li><strong><code>install_requires=['rclpy']</code> (in <code>setup.py</code>)</strong>: 이 구문은 Python의 <code>setuptools</code>에게 이 패키지가 <code>rclpy</code> 라이브러리를 필요로 하니, 설치 시 함께 고려해달라고 알려준다.</li>
</ul>
<p>이들은 생태계 도구들이 이미 준비해준 의존성을 “<strong>어떻게</strong> 찾아서 코드와 연결할 것인가?“에 대한 구체적인 <strong>절차적 지시</strong>다.</p>
<p>이러한 이중 선언 구조는 ROS 2의 유연성과 확장성의 핵심이다. <code>colcon</code>과 <code>rosdep</code>은 <code>package.xml</code>이라는 표준화된 명세만 이해하면 되므로, 내부적으로 CMake를 쓰든, Python setuptools를 쓰든, 혹은 미래에 나올 새로운 빌드 시스템을 쓰든 상관없이 일관되게 동작할 수 있다. 이 설계 덕분에 ROS 2는 ROS 1의 <code>catkin</code>이 CMake에 강하게 종속되었던 한계를 극복하고 다양한 빌드 시스템을 포용하는 현대적인 빌드 환경을 구축할 수 있었다.20</p>
<h3>3.2  의존성 태그 상세 분석</h3>
<p><code>package.xml</code>에는 여러 종류의 의존성 태그가 있으며, 각 태그는 의존성이 필요한 시점과 범위에 따라 명확히 구분된다. 올바른 태그를 사용하는 것은 패키지의 의도를 명확히 하고, 불필요한 의존성 전파를 막으며, 효율적인 패키징을 위해 매우 중요하다.6</p>
<ul>
<li>
<p><strong><code>&lt;buildtool_depend&gt;</code></strong>: 패키지를 빌드하는 데 사용되는 <strong>빌드 도구</strong> 자체에 대한 의존성을 선언한다. C++ 패키지의 경우, <code>ament</code>가 제공하는 CMake 매크로들을 사용하기 위해 거의 항상 <code>&lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;</code>를 포함한다.22 순수 Python 패키지의 경우, 빌드 타입이 <code>&lt;export&gt;</code> 태그 안에 <code>ament_python</code>으로 명시되므로 이 태그는 보통 사용되지 않는다.</p>
</li>
<li>
<p><strong><code>&lt;build_depend&gt;</code></strong>: <strong>빌드 시에만</strong> 필요한 의존성을 선언한다. 이 의존성은 패키지의 소스 코드(<code>.cpp</code>)나 내부적으로만 사용되는 비공개 헤더 파일(<code>.hpp</code>)에서만 필요하며, 패키지를 사용하는 다른 패키지에게는 노출되지 않는다. 예를 들어, 어떤 알고리즘 구현을 위해 <code>Boost</code> 라이브러리를 내부적으로만 사용하고 그 내용이 공개 API(헤더 파일)에 드러나지 않는다면 <code>&lt;build_depend&gt;</code>가 적합하다. 이렇게 선언된 의존성은 최종적으로 생성된 바이너리 패키지를 설치할 때 함께 설치될 필요가 없다.6</p>
</li>
<li>
<p><strong><code>&lt;build_export_depend&gt;</code></strong>: **전이 의존성(Transitive Dependency)**을 관리하기 위한 매우 중요한 태그다. 만약 내 패키지(P1)의 <strong>공개 헤더 파일</strong>(<code>include/p1/my_header.hpp</code>)이 다른 패키지(P2)의 헤더 파일(예: <code>geometry_msgs/msg/pose.hpp</code>)을 <code>#include</code>하고 있다면, 내 패키지(P1)를 사용하는 제3의 패키지(P3)는 P1을 빌드하기 위해 P2의 헤더 파일도 필요로 하게 된다. 이 관계를 명시하지 않으면 P3는 컴파일 오류를 겪게 된다. <code>&lt;build_export_depend&gt;</code>는 바로 이럴 때 “P1을 빌드하기 위해 사용하는 패키지는 P2도 필요하다“는 정보를 P3에게 전달(export)하는 역할을 한다. 주로 헤더 파일이나 CMake 설정 파일을 통해 다른 패키지의 기능이 전파될 때 사용된다.6</p>
</li>
<li>
<p><strong><code>&lt;exec_depend&gt;</code></strong>: <strong>실행 시에만</strong> 필요한 의존성을 선언한다. 빌드 과정과는 무관하지만, 노드를 실행할 때 필요한 라이브러리나 다른 패키지의 실행 파일 등이 여기에 해당한다. 대표적인 예는 다음과 같다:</p>
</li>
<li>
<p>순수 Python 패키지가 <code>import rclpy</code>나 <code>import numpy</code>를 할 때, <code>rclpy</code>와 <code>numpy</code>는 실행 시점에 필요하다.</p>
</li>
<li>
<p>런치 파일(<code>*.launch.py</code>)에서 다른 패키지의 노드(예: <code>demo_nodes_cpp</code>의 <code>talker</code>)를 실행할 때, <code>demo_nodes_cpp</code>는 실행 시점 의존성이다.24</p>
</li>
<li>
<p>실행 시 동적으로 로드되는 공유 라이브러리(.so 파일)가 필요할 때.</p>
</li>
</ul>
<p>순수 Python 패키지는 컴파일 단계가 없으므로 대부분의 의존성을 &lt;exec_depend&gt;로 선언한다.6</p>
<ul>
<li><strong><code>&lt;test_depend&gt;</code></strong>: <strong>테스트 코드를 빌드하고 실행할 때만</strong> 필요한 의존성을 선언한다. <code>gtest</code>나 <code>pytest</code> 같은 테스트 프레임워크, <code>ament_lint_auto</code>나 <code>ament_lint_common</code> 같은 코드 품질 검사 도구들이 여기에 해당한다.25 이 태그로 선언된 의존성은 일반적인 빌드나 실행에는 전혀 영향을 주지 않으며, 오직</li>
</ul>
<p><code>colcon test</code>와 같은 테스트 관련 작업을 할 때만 사용된다. <code>&lt;build_depend&gt;</code>나 <code>&lt;exec_depend&gt;</code>에 이미 선언된 패키지를 <code>&lt;test_depend&gt;</code>에 중복해서 선언해서는 안 된다.6</p>
<ul>
<li><strong><code>&lt;depend&gt;</code></strong>: <strong>빌드, 빌드-익스포트, 실행 시점 모두</strong>에 필요한 의존성을 한 번에 선언하는 가장 강력하고 일반적인 태그다. C++ 패키지에서 <code>rclcpp</code>나 <code>std_msgs</code>와 같이 헤더 파일을 인클루드하여 빌드하고, 라이브러리에 링크하며, 실행 시점에도 해당 기능이 필요한 경우에 사용한다. 어떤 태그를 써야 할지 헷갈릴 때는 일단 <code>&lt;depend&gt;</code>를 사용하면 대부분의 경우 문제가 해결되므로 안전한 선택지가 될 수 있다. 하지만 패키지의 의도를 명확하게 하고 불필요한 의존성 전파를 막기 위해서는 각 목적에 맞는 특정 태그를 사용하는 것이 권장된다.6</li>
</ul>
<h4>3.2.1 의존성 태그 선택 가이드</h4>
<p>다음 표는 다양한 상황에서 어떤 의존성 태그를 선택해야 하는지에 대한 빠른 참조 가이드다.</p>
<table><thead><tr><th>태그</th><th>목적 (언제 사용하는가?)</th><th>C++ 패키지 예시</th><th>Python 패키지 예시</th></tr></thead><tbody>
<tr><td><code>&lt;buildtool_depend&gt;</code></td><td>패키지를 빌드하는 데 필요한 도구 자체</td><td><code>ament_cmake</code></td><td>(사용 안 함)</td></tr>
<tr><td><code>&lt;build_depend&gt;</code></td><td>소스코드(.cpp)나 비공개 헤더에서만 필요한 의존성</td><td><code>Boost</code> (내부 구현용)</td><td>(거의 사용 안 함)</td></tr>
<tr><td><code>&lt;build_export_depend&gt;</code></td><td>공개 헤더(.hpp)에서 <code>#include</code>하는 의존성 (전이 의존성)</td><td><code>geometry_msgs</code> (공개 API에 사용)</td><td>(거의 사용 안 함)</td></tr>
<tr><td><code>&lt;exec_depend&gt;</code></td><td>노드나 스크립트를 실행할 때만 필요한 의존성</td><td>런치 파일에서 실행하는 다른 패키지</td><td><code>rclpy</code>, <code>numpy</code></td></tr>
<tr><td><code>&lt;depend&gt;</code></td><td>빌드, 링크, 실행 전반에 걸쳐 모두 필요한 의존성</td><td><code>rclcpp</code>, <code>std_msgs</code></td><td>(사용 안 함, <code>exec_depend</code> 선호)</td></tr>
<tr><td><code>&lt;test_depend&gt;</code></td><td>테스트를 빌드하고 실행할 때만 필요한 의존성</td><td><code>ament_cmake_gtest</code></td><td><code>ament_flake8</code>, <code>pytest</code></td></tr>
</tbody></table>
<h3>3.3  고급 의존성 속성</h3>
<p>포맷 3에서는 의존성을 더욱 정교하게 제어할 수 있는 속성들을 제공한다.</p>
<ul>
<li>
<p><strong>버전 제한 (<code>version_lt</code>, <code>version_lte</code>, <code>version_eq</code>, <code>version_gte</code>, <code>version_gt</code>)</strong>: 특정 패키지의 버전을 제한할 수 있다. 이는 의존하는 패키지의 API가 변경되어 하위 호환성이 깨졌을 때 매우 유용하다. 예를 들어, <code>my_lib</code> 패키지의 <code>2.0.0</code> 버전부터 API가 변경되었다면 다음과 같이 선언하여 호환되지 않는 버전의 사용을 막을 수 있다.7</p>
<pre><code class="language-XML">&lt;depend version_lt="2.0.0"&gt;my_lib&lt;/depend&gt;
</code></pre>
</li>
</ul>
<pre><code>
- `version_lt`: ~보다 작은 (`&lt;`)
- `version_lte`: ~보다 작거나 같은 (`&lt;=`)
- `version_eq`: ~와 같은 (`==`)
- `version_gte`: ~보다 크거나 같은 (`&gt;=`)
- `version_gt`: ~보다 큰 (`&gt;`)

- **조건부 의존성 (`condition`)**: `package.xml` 포맷 3의 가장 강력한 기능 중 하나로, 특정 조건이 만족될 때만 의존성이 활성화되도록 할 수 있다. 이 조건은 Python 표현식으로 평가되며, `$ROS_VERSION`과 같은 환경 변수를 사용할 수 있다. 가장 대표적인 사용 사례는 ROS 1과 ROS 2를 동시에 지원하는 패키지를 만드는 것이다.7

  ```XML
  &lt;depend condition="$ROS_VERSION == 1"&gt;roscpp&lt;/depend&gt;
  &lt;depend condition="$ROS_VERSION == 2"&gt;rclcpp&lt;/depend&gt;
</code></pre>
<p><code>ros_environment</code> 패키지를 설치하면 ROS 환경을 소싱할 때 <code>$ROS_VERSION</code> 환경 변수가 <code>1</code> 또는 <code>2</code>로 설정된다. 이를 통해 하나의 <code>package.xml</code> 파일로 두 ROS 버전에 대한 의존성을 깔끔하게 관리할 수 있다.28</p>
<h2>4.  생태계와의 연결고리: <code>&lt;export&gt;</code> 태그</h2>
<p><code>&lt;export&gt;</code> 태그는 패키지가 자신의 정보를 ROS 생태계의 다른 부분(빌드 시스템, 툴 등)에 “수출(export)“하는 데 사용된다. 이 태그 안에 포함된 정보는 패키지가 어떻게 빌드되어야 하는지, 어떤 특별한 속성을 가지고 있는지 등을 알려주는 중요한 메타데이터다.19</p>
<h3>4.1  빌드 타입 선언: <code>&lt;build_type&gt;</code></h3>
<p><code>&lt;export&gt;</code> 섹션에서 가장 중요하고 필수적인 태그는 <code>&lt;build_type&gt;</code>이다. 이 태그는 <code>colcon</code>에게 이 패키지를 어떤 빌드 시스템을 사용하여 빌드해야 하는지를 명시적으로 알려준다.3</p>
<ul>
<li><strong><code>&lt;build_type&gt;ament_cmake&lt;/build_type&gt;</code></strong>: 이 패키지가 <code>ament_cmake</code>를 사용하는 C++ 기반 패키지임을 나타낸다. <code>colcon</code>은 이 태그를 보고 해당 패키지 디렉토리에서 <code>CMakeLists.txt</code> 파일을 찾아 CMake 빌드 프로세스를 실행한다.3</li>
<li><strong><code>&lt;build_type&gt;ament_python&lt;/build_type&gt;</code></strong>: 이 패키지가 순수 Python 패키지임을 나타낸다. <code>colcon</code>은 이 태그를 보고 <code>setup.py</code>와 <code>setup.cfg</code> 파일을 사용하여 Python의 표준 <code>setuptools</code> 기반으로 패키지를 빌드하고 설치한다.20</li>
</ul>
<p>만약 C++과 Python 코드가 함께 있는 하이브리드 패키지를 만들고 싶다면, 기본 빌드 타입은 <code>ament_cmake</code>로 설정해야 한다. 그리고 <code>CMakeLists.txt</code> 안에서 <code>ament_cmake_python</code> 패키지가 제공하는 함수들을 사용하여 Python 코드를 처리하도록 설정한다. 이 경우 <code>package.xml</code>에는 <code>&lt;buildtool_depend&gt;ament_cmake_python&lt;/buildtool_depend&gt;</code> 의존성을 추가해야 한다.26</p>
<h3>4.2  그룹 의존성: <code>&lt;member_of_group&gt;</code>과 <code>&lt;group_depend&gt;</code></h3>
<p>이는 <code>package.xml</code> 포맷 3에서 도입된 고급 기능으로, 여러 패키지를 논리적인 그룹으로 묶어 관리할 수 있게 해준다. 개별 패키지 이름을 일일이 나열하는 대신, 특정 “그룹“에 대한 의존성을 선언하는 방식이다.7</p>
<ul>
<li><strong><code>&lt;member_of_group&gt;</code></strong>: 특정 패키지가 어떤 그룹의 멤버임을 선언한다.</li>
<li><strong><code>&lt;group_depend&gt;</code></strong>: 특정 그룹에 속한 모든 멤버 패키지들에 대한 의존성을 선언한다.</li>
</ul>
<p>가장 대표적인 사용 사례는 ROS 인터페이스(메시지, 서비스, 액션) 패키지들이다.</p>
<ol>
<li>
<p><code>std_msgs</code>, <code>geometry_msgs</code>와 같이 <code>.msg</code>, <code>.srv</code>, <code>.action</code> 파일을 포함하는 모든 인터페이스 패키지들은 자신의 <code>package.xml</code>에 다음과 같이 선언한다:</p>
<pre><code class="language-XML">&lt;export&gt;
  &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;
&lt;/export&gt;
</code></pre>
</li>
</ol>
<pre><code>
2. `ros1_bridge`나 `rosidl_default_generators`와 같이 워크스페이스에 있는 모든 인터페이스 정의를 알아야 하는 패키지들은 개별 인터페이스 패키지 이름을 나열하는 대신, 다음과 같이 그룹 전체에 대한 의존성을 선언한다:

   ```XML
   &lt;group_depend&gt;rosidl_interface_packages&lt;/group_depend&gt;
</code></pre>
<p>이 메커니즘을 통해 <code>colcon</code>은 <code>rosidl_interface_packages</code> 그룹의 멤버인 모든 패키지들을 먼저 빌드한 후, 이 그룹에 의존하는 <code>ros1_bridge</code> 같은 패키지를 빌드하도록 순서를 보장할 수 있다. 이는 워크스페이스에 어떤 인터페이스 패키지가 추가되거나 제거되더라도 <code>ros1_bridge</code>의 <code>package.xml</code>을 수정할 필요가 없게 만들어주므로, 시스템의 모듈성과 확장성을 크게 향상시킨다.7</p>
<h3>4.3  기타 <code>&lt;export&gt;</code> 태그</h3>
<ul>
<li>
<p><strong><code>&lt;architecture_independent&gt;</code></strong>: 이 태그가 존재하면, 해당 패키지가 CPU 아키텍처에 종속적이지 않음을 나타낸다. 순수 Python 패키지, 런치 파일이나 설정 파일만 담고 있는 패키지, 메시지 정의만 담고 있는 패키지 등이 여기에 해당한다. 빌드 팜에서는 이 정보를 활용하여 여러 아키텍처에 대한 빌드를 한 번만 수행하는 등 최적화를 할 수 있다.</p>
<pre><code class="language-XML">&lt;export&gt;
  &lt;architecture_independent/&gt;
&lt;/export&gt;
</code></pre>
</li>
</ul>
<pre><code>
- **`&lt;deprecated&gt;`**: 패키지가 더 이상 사용되지 않거나 새로운 패키지로 대체되었음을 알릴 때 사용한다. 이 태그가 있으면 `colcon`이 빌드 시 경고 메시지를 출력하여 사용자에게 알려준다.

  ```XML
  &lt;export&gt;
    &lt;deprecated&gt;This package is deprecated, please use 'new_package' instead.&lt;/deprecated&gt;
  &lt;/export&gt;
</code></pre>
<ul>
<li><strong>Pluginlib Export</strong>: ROS 1에서는 플러그인을 등록하기 위해 <code>package.xml</code>의 <code>&lt;export&gt;</code> 태그 안에 플러그인 설명 XML 파일의 경로를 명시했다. 하지만 ROS 2에서는 이 방식이 변경되었다. 이제는 <code>CMakeLists.txt</code> 파일 안에서 <code>pluginlib_export_plugin_description_file()</code>이라는 CMake 매크로를 사용하여 플러그인을 등록하고 내보낸다. 따라서 ROS 2에서 <code>pluginlib</code>를 사용할 때 <code>package.xml</code>의 <code>&lt;export&gt;</code> 태그는 직접적인 역할을 하지 않는다. 이 변경점은 빌드 시스템과의 통합을 더 강화하기 위한 것이다.35</li>
</ul>
<h2>5.  유형별 <code>package.xml</code> 실전 예제</h2>
<p>이론적인 설명을 넘어, 실제 프로젝트에서 사용되는 <code>package.xml</code> 예제를 통해 각 태그가 어떻게 활용되는지 살펴보자.</p>
<h3>5.1  <code>ament_cmake</code> C++ 패키지 예제</h3>
<p>간단한 <code>rclcpp</code> 기반의 퍼블리셔 노드를 포함하는 C++ 패키지의 <code>package.xml</code> 예제다.</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
&lt;package format="3"&gt;
  &lt;name&gt;cpp_pubsub&lt;/name&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;description&gt;A simple C++ publisher and subscriber example.&lt;/description&gt;
  &lt;maintainer email="dev@example.com"&gt;Jane Doe&lt;/maintainer&gt;
  &lt;license&gt;Apache-2.0&lt;/license&gt;

  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;

  &lt;depend&gt;rclcpp&lt;/depend&gt;
  &lt;depend&gt;std_msgs&lt;/depend&gt;

  &lt;test_depend&gt;ament_cmake_gtest&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;

  &lt;export&gt;
    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;
  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p><strong>해설</strong>:</p>
<ul>
<li><code>&lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;</code>: <code>ament_cmake</code>가 제공하는 CMake 함수들(예: <code>ament_target_dependencies</code>, <code>ament_package</code>)을 <code>CMakeLists.txt</code>에서 사용하기 때문에 필수적이다.5</li>
<li><code>&lt;depend&gt;rclcpp&lt;/depend&gt;</code>와 <code>&lt;depend&gt;std_msgs&lt;/depend&gt;</code>: 소스 코드에서 <code>rclcpp/rclcpp.hpp</code>와 <code>std_msgs/msg/string.hpp</code>를 <code>#include</code>하고, 생성된 실행 파일은 <code>rclcpp</code>와 <code>std_msgs</code> 라이브러리에 링크되며, 실행 시점에도 이 라이브러리들이 필요하다. 따라서 빌드, 익스포트, 실행 모든 단계에 걸친 의존성이므로 <code>&lt;depend&gt;</code> 태그가 가장 적합하다.38</li>
<li><code>&lt;test_depend&gt;</code>: <code>ament_cmake_gtest</code>는 Google Test 프레임워크를 CMake와 통합해주는 역할을 한다. <code>ament_lint_auto</code>와 <code>ament_lint_common</code>은 <code>cpplint</code>, <code>cppcheck</code> 등 다양한 린터를 실행하여 코드 스타일과 잠재적 오류를 검사한다. 이들은 제품 코드의 빌드나 실행과는 무관하므로 <code>&lt;test_depend&gt;</code>로 선언하는 것이 올바르다.25</li>
<li><code>&lt;export&gt;</code>의 <code>&lt;build_type&gt;</code>: <code>colcon</code>이 이 패키지를 빌드할 때 <code>cmake</code> 명령어를 사용해야 함을 알려준다.3</li>
</ul>
<h3>5.2  <code>ament_python</code> Python 패키지 예제</h3>
<p>간단한 <code>rclpy</code> 기반의 노드를 포함하는 순수 Python 패키지의 <code>package.xml</code> 예제다.</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
&lt;package format="3"&gt;
  &lt;name&gt;py_pubsub&lt;/name&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;description&gt;A simple Python publisher and subscriber example.&lt;/description&gt;
  &lt;maintainer email="dev@example.com"&gt;John Doe&lt;/maintainer&gt;
  &lt;license&gt;Apache-2.0&lt;/license&gt;

  &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;

  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;
  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;

  &lt;export&gt;
    &lt;build_type&gt;ament_python&lt;/build_type&gt;
  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p><strong>해설</strong>:</p>
<ul>
<li><code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</code>와 <code>&lt;exec_depend&gt;std_msgs&lt;/depend&gt;</code>: Python 패키지는 별도의 컴파일/링크 단계가 없다. 의존성은 스크립트가 실행될 때 <code>import</code> 구문을 통해 해결된다. 따라서 빌드 시점 의존성인 <code>&lt;build_depend&gt;</code>는 필요 없고, 실행 시점 의존성인 <code>&lt;exec_depend&gt;</code>를 사용한다. 이것이 C++ 패키지와의 가장 큰 차이점이다.6</li>
<li><code>&lt;test_depend&gt;</code>: Python 코드의 테스트에는 <code>pytest</code>가 주로 사용되며, 코드 스타일 검사를 위해 <code>flake8</code>, 문서 문자열(docstring) 검사를 위해 <code>pep257</code> 등을 사용한다. 이들은 모두 테스트 과정에서만 필요하다.</li>
<li><code>&lt;export&gt;</code>의 <code>&lt;build_type&gt;</code>: <code>colcon</code>이 이 패키지를 빌드할 때 <code>setup.py</code>를 실행해야 함을 알려준다.31</li>
</ul>
<h3>5.3  메타패키지(Metapackage) 예제</h3>
<p>ROS 2에서 메타패키지는 여러 관련 패키지를 하나의 논리적 단위로 묶어 사용자가 편리하게 설치하고 관리할 수 있도록 돕는 역할을 한다. ROS 1에서는 <code>&lt;metapackage/&gt;</code>라는 전용 태그가 있었지만, ROS 2에서는 이 태그가 사라졌다. 대신, 실제 코드나 빌드 로직 없이 오직 다른 패키지에 대한 실행 시점 의존성(<code>exec_depend</code>)만을 포함하는 일반 패키지로 메타패키지를 구성한다.13</p>
<p><code>ros_gz</code> 메타패키지의 <code>package.xml</code> 예제를 살펴보자. 이 패키지는 ROS 2와 Gazebo 시뮬레이터를 연동하는 데 필요한 핵심 패키지들을 묶어준다.40</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;?xml-model href="http://download.ros.org/schema/package_format2.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?&gt;
&lt;package format="2"&gt; &lt;name&gt;ros_gz&lt;/name&gt;
  &lt;version&gt;2.1.6&lt;/version&gt;
  &lt;description&gt;Meta-package containing interfaces for using ROS 2 with Gazebo simulation.&lt;/description&gt;
  &lt;maintainer email="adityapande@intrinsic.ai"&gt;Aditya Pande&lt;/maintainer&gt;
  &lt;license&gt;Apache 2.0&lt;/license&gt;

  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;

  &lt;exec_depend&gt;ros_gz_bridge&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros_gz_sim&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros_gz_sim_demos&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros_gz_image&lt;/exec_depend&gt;

  &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;

  &lt;export&gt;
    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;
  &lt;/export&gt;
&lt;/package&gt;
</code></pre>
<p><strong>해설</strong>:</p>
<ul>
<li><strong>핵심은 <code>&lt;exec_depend&gt;</code></strong>: 이 패키지는 <code>ros_gz_bridge</code>, <code>ros_gz_sim</code> 등 Gazebo 연동에 필수적인 패키지들을 <code>&lt;exec_depend&gt;</code>로 포함하고 있다. 사용자가 <code>sudo apt install ros-humble-ros-gz</code> 명령을 실행하면, 패키지 관리자는 이 의존성 목록을 보고 명시된 모든 패키지를 함께 설치해준다.</li>
<li><strong>빈 <code>CMakeLists.txt</code></strong>: 메타패키지의 <code>CMakeLists.txt</code>는 거의 비어 있으며, <code>ament_package()</code>를 호출하여 ROS 2 패키지 시스템에 자신을 등록하는 최소한의 내용만 담고 있다. 컴파일할 소스 코드가 없기 때문이다.41</li>
<li><strong>용도</strong>: <code>navigation2</code>, <code>slam_toolbox</code>, <code>moveit</code> 등 복잡한 기능을 제공하는 대규모 프로젝트들은 사용자가 수십 개의 개별 패키지를 일일이 설치하는 불편을 겪지 않도록 최상위 메타패키지를 제공하는 것이 일반적이다.</li>
</ul>
<h2>6.  모범 사례(Best Practices) 및 흔한 실수</h2>
<p>잘 작성된 <code>package.xml</code>은 프로젝트의 유지보수성, 재사용성, 협업 효율성을 크게 향상시킨다. 다음은 다년간의 ROS 개발 경험을 통해 정립된 모범 사례와 초보자들이 흔히 저지르는 실수들이다.</p>
<h3>6.1  패키지 구성 전략</h3>
<p>효과적인 <code>package.xml</code> 작성은 올바른 패키지 구성에서부터 시작된다.</p>
<ul>
<li><strong>단일 책임 원칙 (Single Responsibility Principle)</strong>: 하나의 패키지는 하나의 명확한 목적을 가져야 한다. 예를 들어, 로봇의 URDF 모델, 실제 하드웨어 드라이버, 시뮬레이션 설정, SLAM 알고리즘, 경로 계획 알고리즘은 각각 별개의 패키지로 분리하는 것이 좋다. 너무 많은 기능을 하나의 패키지에 담으면 의존성이 복잡해지고, 일부 기능만 재사용하기가 어려워지며, 여러 개발자가 동시에 작업할 때 충돌이 발생하기 쉽다.42</li>
<li><strong>인터페이스 패키지 분리</strong>: 로봇 프로젝트에서 사용되는 커스텀 메시지(<code>.msg</code>), 서비스(<code>.srv</code>), 액션(<code>.action</code>) 정의는 <code>my_robot_msgs</code>와 같은 별도의 전용 패키지에 모아두는 것이 매우 좋은 전략이다. 이렇게 하면, 인터페이스 정의와 이를 사용하는 로직(C++ 또는 Python 코드)이 분리된다. 만약 인터페이스와 로직이 같은 패키지에 있다면, 두 패키지가 서로의 메시지를 사용해야 할 경우 피할 수 없는 순환 의존성(circular dependency)이 발생하게 된다. 인터페이스를 별도 패키지로 분리하면 모든 로직 패키지들이 이 인터페이스 패키지에만 의존하는 단방향 의존성 구조를 만들 수 있어 프로젝트 전체의 안정성이 높아진다.42</li>
<li><strong>런치 파일 및 설정 패키지 분리</strong>: 로봇을 구동하기 위한 복잡한 런치 파일들과 파라미터 설정 파일(<code>.yaml</code>)들은 <code>my_robot_bringup</code>과 같은 전용 패키지에 모아서 관리하는 것이 좋다. 각 기능 패키지마다 런치 파일을 흩어 놓으면, 하나의 런치 파일이 다른 패키지의 런치 파일을 <code>include</code>하고, 또 다른 패키지의 설정 파일을 참조하는 등 의존 관계가 거미줄처럼 얽히게 된다. 모든 시작 절차를 <code>bringup</code> 패키지에 중앙화하면, 시스템 전체의 구동 방식을 한눈에 파악하기 쉽고, 의존성 관리가 단순해진다. 이 <code>bringup</code> 패키지의 <code>package.xml</code>에는 런치 파일에서 실행하는 모든 노드가 속한 패키지들을 <code>&lt;exec_depend&gt;</code>로 명시해야 한다.24</li>
</ul>
<h3>6.2  의존성 관리 모범 사례</h3>
<ul>
<li><strong>최소한의 원칙</strong>: 패키지에 꼭 필요한 최소한의 의존성만 선언해야 한다. 불필요한 의존성은 빌드 시간을 늘리고, 패키지 배포를 복잡하게 만들며, 다른 패키지와의 충돌 가능성을 높인다.</li>
<li><strong>정확한 태그 사용</strong>: <code>&lt;depend&gt;</code>는 편리하지만 남용해서는 안 된다. 의존성의 성격에 맞게 <code>&lt;build_depend&gt;</code>, <code>&lt;build_export_depend&gt;</code>, <code>&lt;exec_depend&gt;</code>, <code>&lt;test_depend&gt;</code>를 정확히 구분하여 사용하면 패키지의 의도를 명확하게 전달할 수 있다. 이는 특히 바이너리 데비안 패키지를 생성할 때, 실행에 불필요한 개발용 라이브러리(-dev 패키지)가 함께 패키징되는 것을 막아주어 더 가볍고 효율적인 배포를 가능하게 한다.6</li>
<li><strong>순환 의존성 금지</strong>: 패키지 A가 패키지 B에 의존하고, 동시에 패키지 B가 패키지 A에 의존하는 순환 의존성 구조는 절대적으로 피해야 한다. <code>colcon</code>은 이러한 구조의 워크스페이스를 빌드할 수 없다. 순환 의존성이 발생했다면, 이는 패키지 설계가 잘못되었다는 강력한 신호이며, 공통 기능을 별도의 패키지로 분리하는 등 리팩토링이 필요하다.42</li>
</ul>
<h3>6.3  버전 관리와 배포</h3>
<ul>
<li>
<p><strong>유의적 버전(Semantic Versioning) 준수</strong>: <code>package.xml</code>의 <code>&lt;version&gt;</code> 태그는 유의적 버전 규칙을 따라야 한다.14</p>
</li>
<li>
<p><code>PATCH</code> 버전 (x.y.Z): 하위 호환성을 유지하는 버그 수정.</p>
</li>
<li>
<p><code>MINOR</code> 버전 (x.Y.z): 하위 호환성을 유지하면서 새로운 기능이 추가됨.</p>
</li>
<li>
<p>MAJOR 버전 (X.y.z): 하위 호환성이 깨지는 API 변경이 발생함.</p>
</li>
</ul>
<p>이 규칙을 따르면 다른 사용자들이 버전 번호만 보고도 업데이트의 심각성을 파악하고 자신의 코드에 미칠 영향을 예측할 수 있다.45</p>
<ul>
<li><strong><code>package.xml</code>과 Git 태그의 동기화</strong>: ROS 패키지를 공식적으로 배포할 때는 <code>bloom</code>이라는 도구를 사용한다. <code>bloom</code>은 Git 저장소의 태그를 기준으로 릴리스를 생성한다. 일반적인 워크플로우는 다음과 같다 15:</li>
</ul>
<ol>
<li>
<p><code>CHANGELOG.rst</code> 파일을 업데이트하여 변경 사항을 기록한다.</p>
</li>
<li>
<p><code>package.xml</code> 파일의 <code>&lt;version&gt;</code> 태그를 새로운 릴리스 버전(예: <code>1.1.0</code>)으로 수정한다.</p>
</li>
<li>
<p>변경된 두 파일을 커밋한다.</p>
</li>
<li>
<p>해당 커밋에 <code>package.xml</code>의 버전과 동일한 이름의 Git 태그(예: <code>1.1.0</code>)를 생성한다.</p>
</li>
<li>
<p>이 태그를 원격 저장소에 푸시한 후 bloom-release 명령을 실행한다.</p>
</li>
</ol>
<p>이 과정을 통해 코드의 특정 상태(Git 태그)와 패키지 버전(package.xml)이 명확하게 연결되어, 재현 가능하고 신뢰할 수 있는 배포가 가능해진다.</p>
<h3>6.4  흔히 저지르는 실수와 해결책</h3>
<ul>
<li><strong>실수: 잘못된 의존성 태그 사용</strong></li>
<li><strong>증상</strong>: Python 노드 패키지의 <code>rclpy</code> 의존성을 <code>&lt;build_depend&gt;</code>로 선언했다. <code>colcon build</code>는 통과하지만 <code>ros2 run</code>으로 노드를 실행하면 <code>ModuleNotFoundError</code>가 발생한다.</li>
<li><strong>원인</strong>: Python 의존성은 실행 시점에 필요하므로 <code>&lt;exec_depend&gt;</code>로 선언해야 한다.</li>
<li><strong>해결</strong>: <code>&lt;build_depend&gt;rclpy&lt;/build_depend&gt;</code>를 <code>&lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;</code>로 수정한다.</li>
<li><strong>실수: 전이 의존성 누락</strong></li>
<li><strong>증상</strong>: 내 라이브러리 패키지(P1)는 잘 빌드되지만, 이 라이브러리를 사용하는 다른 패키지(P3)를 빌드할 때 <code>geometry_msgs/msg/pose.hpp: No such file or directory</code>와 같은 컴파일 오류가 발생한다.</li>
<li><strong>원인</strong>: P1의 공개 헤더 파일이 <code>geometry_msgs</code>의 헤더를 <code>#include</code>하고 있지만, <code>package.xml</code>에 <code>&lt;build_export_depend&gt;geometry_msgs&lt;/build_export_depend&gt;</code>를 선언하지 않았다.</li>
<li><strong>해결</strong>: P1의 <code>package.xml</code>에 <code>&lt;build_export_depend&gt;geometry_msgs&lt;/build_export_depend&gt;</code>를 추가하여 의존성 정보를 P3에게 올바르게 전파한다.</li>
<li><strong>실수: <code>package.xml</code>과 빌드 스크립트의 불일치</strong></li>
<li><strong>증상</strong>: <code>rosdep install</code>은 성공적으로 완료되지만, <code>colcon build</code>를 실행하면 <code>CMake Error: Could not find a package configuration file provided by "some_package"</code> 오류가 발생한다.</li>
<li><strong>원인</strong>: <code>package.xml</code>에는 <code>&lt;depend&gt;some_package&lt;/depend&gt;</code>가 선언되어 있지만, <code>CMakeLists.txt</code>에서 <code>find_package(some_package REQUIRED)</code> 호출을 누락했다.</li>
<li><strong>해결</strong>: <code>package.xml</code>과 <code>CMakeLists.txt</code>(또는 <code>setup.py</code>)의 의존성 목록을 항상 일치시킨다.</li>
<li><strong>실수: XML 문법 오류</strong></li>
<li><strong>증상</strong>: <code>colcon build</code> 실행 시 패키지를 아예 인식하지 못하거나 XML 파싱 오류가 발생한다.</li>
<li><strong>원인</strong>: 태그를 닫지 않았거나(<code>&lt;/depend&gt;</code>), 속성 값에 따옴표를 빠뜨리는 등 단순한 문법 오류가 있다.</li>
<li><strong>해결</strong>: <code>ament_lint</code>의 일부인 <code>ament_xmllint</code>를 사용하여 <code>package.xml</code> 파일의 유효성을 검사할 수 있다. <code>colcon test</code>를 실행하면 이 검사가 자동으로 수행된다. 또한, XSD 스키마를 지원하는 VS Code와 같은 편집기를 사용하면 실시간으로 오류를 발견하는 데 도움이 된다.11</li>
</ul>
<h2>7.  문제 해결(Troubleshooting) 가이드</h2>
<p>개발 과정에서 <code>package.xml</code>과 관련된 다양한 문제에 직면할 수 있다. 다음은 가장 흔하게 발생하는 오류들과 그 원인 및 해결 방법이다.</p>
<h3>7.1  <code>rosdep install</code> 실패: “Cannot locate rosdep definition for [key_name]”</h3>
<p>이 오류는 <code>rosdep</code>이 <code>package.xml</code>에 명시된 의존성 키에 해당하는 시스템 패키지를 <code>rosdistro</code> 데이터베이스에서 찾지 못할 때 발생한다.49</p>
<ul>
<li>원인 1: 단순 오타 또는 잘못된 키 이름</li>
</ul>
<p>가장 흔한 원인이다. rosdep 키는 실제 시스템 패키지 이름(예: libpcl-dev)과 다를 수 있다. 예를 들어, libpcl-dev에 대한 올바른 rosdep 키는 pcl_ros 또는 libpcl-all-dev일 수 있으며, 이는 ROS 배포판과 상황에 따라 다르다.</p>
<ul>
<li><strong>해결책</strong>:</li>
</ul>
<ol>
<li>의심되는 키 이름에 오타가 없는지 확인한다.</li>
<li><code>rosdep keys &lt;key_name&gt;</code> 명령어로 해당 키가 존재하는지, 존재한다면 어떤 시스템 패키지에 매핑되는지 확인한다.</li>
<li>ROS Index 웹사이트(index.ros.org)나 <code>rosdistro</code> GitHub 저장소의 <code>rosdep/base.yaml</code> 또는 <code>rosdep/python.yaml</code> 파일을 직접 검색하여 올바른 키 이름을 찾는다.52</li>
</ol>
<ul>
<li>원인 2: rosdistro 데이터베이스에 없는 키</li>
</ul>
<p>비교적 새로운 라이브러리나 ROS 생태계에서 자주 사용되지 않는 라이브러리는 rosdistro에 등록되어 있지 않을 수 있다.</p>
<ul>
<li><strong>해결책</strong>:</li>
</ul>
<ol>
<li><strong>(권장)</strong> <code>rosdistro</code> 저장소에 풀 리퀘스트(Pull Request)를 보내 새로운 <code>rosdep</code> 규칙을 추가한다. 이는 커뮤니티에 기여하는 가장 좋은 방법이다.6</li>
<li><strong>(임시/로컬)</strong> 로컬 <code>rosdep</code> 소스 파일을 만들어 개인적으로 사용하는 키를 정의할 수 있다. 예를 들어, <code>my_rules.yaml</code> 파일을 만들고 <code>/etc/ros/rosdep/sources.list.d/50-local.list</code> 파일에 해당 파일의 경로를 추가한 후 <code>rosdep update</code>를 실행하면 로컬 규칙이 적용된다.55</li>
</ol>
<ul>
<li>원인 3: ROS_DISTRO 환경 변수 누락</li>
</ul>
<p>rosdep은 어떤 ROS 배포판을 기준으로 의존성을 해결해야 하는지 알아야 한다. 이 정보가 없으면 ROS 관련 키를 찾지 못한다.</p>
<ul>
<li><strong>해결책</strong>:</li>
</ul>
<ol>
<li>터미널에서 <code>source /opt/ros/humble/setup.bash</code> 명령을 실행하여 ROS 환경을 올바르게 설정했는지 확인한다. <code>echo $ROS_DISTRO</code>를 실행했을 때 <code>humble</code>이 출력되어야 한다.</li>
<li>환경 설정이 어려운 경우, <code>rosdep install</code> 명령어에 <code>--rosdistro humble</code> 옵션을 명시적으로 추가하여 배포판을 지정해준다.57</li>
</ol>
<h3>7.2  <code>colcon build</code> 실패: “Package ‘package_name’ not found”</h3>
<p><code>colcon</code>이 워크스페이스 내에서 특정 패키지를 인식하지 못할 때 발생하는 오류다.</p>
<ul>
<li>원인 1: 잘못된 워크스페이스 구조</li>
</ul>
<p>colcon은 특정 디렉토리 구조를 기대한다. 패키지 소스 코드는 워크스페이스 루트의 src 디렉토리 아래에 위치해야 한다.</p>
<ul>
<li>
<p><strong>해결책</strong>: 패키지가 <code>~/ros2_ws/src/my_package</code>와 같이 올바른 위치에 있는지 확인하고, <code>colcon build</code> 명령은 워크스페이스의 루트 디렉토리(<code>~/ros2_ws</code>)에서 실행해야 한다.</p>
</li>
<li>
<p>원인 2: package.xml 파일의 부재 또는 오류</p>
</li>
</ul>
<p>colcon은 디렉토리 안에 package.xml 파일이 있어야만 해당 디렉토리를 ROS 패키지로 인식한다.</p>
<ul>
<li><strong>해결책</strong>:</li>
</ul>
<ol>
<li>패키지 디렉토리 최상단에 <code>package.xml</code> 파일이 존재하는지 확인한다.</li>
<li>파일 이름이 정확한지 확인한다.</li>
<li><code>package.xml</code> 파일의 내용에 심각한 XML 문법 오류가 없는지 확인한다. 특히 <code>&lt;name&gt;</code> 태그의 이름이 실제 패키지 디렉토리 이름과 달라서 발생하는 경우가 많다. <code>package.xml</code>의 <code>&lt;name&gt;</code>과 <code>CMakeLists.txt</code>의 <code>project()</code> 이름, 그리고 실제 폴더 이름은 일치시키는 것이 좋다.58</li>
</ol>
<ul>
<li>원인 3: 의존하는 패키지의 빌드 실패</li>
</ul>
<p>–packages-select 옵션으로 특정 패키지만 빌드할 때, 해당 패키지가 의존하는 다른 패키지가 아직 빌드되지 않았거나 빌드에 실패한 경우 이 오류가 발생할 수 있다.</p>
<ul>
<li><strong>해결책</strong>: <code>--packages-up-to &lt;package_name&gt;</code> 옵션을 사용하면 해당 패키지와 그 패키지가 의존하는 모든 패키지들을 함께 빌드해주므로 이 문제를 해결할 수 있다.</li>
</ul>
<h3>7.3  <code>colcon build</code> 실패: CMake/Python 관련 오류</h3>
<p>빌드 과정 자체에서 발생하는 오류로, <code>package.xml</code>과 빌드 스크립트 간의 불일치로 인해 발생하는 경우가 많다.</p>
<ul>
<li><strong>원인: <code>package.xml</code>과 빌드 스크립트의 의존성 불일치</strong></li>
<li><code>CMake Error at CMakeLists.txt:10 (find_package): Could not find a package configuration file...</code>: <code>package.xml</code>에는 의존성을 선언했지만, <code>CMakeLists.txt</code>에서 <code>find_package()</code>를 호출하는 것을 잊었거나, 그 반대의 경우다.</li>
<li><code>ModuleNotFoundError: No module named 'some_ros_package'</code>: Python 패키지에서 발생하는 경우로, <code>package.xml</code>에 <code>&lt;exec_depend&gt;</code>를 선언했지만 <code>setup.py</code>의 <code>install_requires</code>에 누락되었거나, 혹은 그 반대의 경우다.</li>
<li><strong>해결책</strong>: <code>package.xml</code>의 의존성 목록과 <code>CMakeLists.txt</code>의 <code>find_package()</code> 목록, <code>setup.py</code>의 <code>install_requires</code> 목록이 항상 일관성을 유지하도록 철저히 확인해야 한다. <code>catkin_lint</code>와 같은 ROS 1 도구가 ROS 2에서는 아직 완벽하게 지원되지 않으므로, 이 부분은 개발자가 직접 주의를 기울여야 한다.11</li>
</ul>
<h2>8. 결론: 잘 작성된 <code>package.xml</code>의 가치</h2>
<p>지금까지 ROS 2 Humble의 <code>package.xml</code>에 대해 깊이 있게 탐구했다. 이 파일이 단순한 메타데이터의 집합이 아니라, ROS 2 생태계의 모든 도구와 소통하며 패키지의 빌드, 테스트, 배포, 실행의 모든 과정을 관장하는 핵심적인 “계약서“임을 확인했다.</p>
<p>정확하고 명료하게 작성된 <code>package.xml</code>은 다음과 같은 가치를 제공한다.</p>
<ul>
<li><strong>자동화된 의존성 관리</strong>: <code>rosdep</code>을 통해 단 한 번의 명령으로 복잡한 시스템 의존성을 해결하여 개발 환경 설정을 극적으로 단순화한다.</li>
<li><strong>신뢰할 수 있는 빌드</strong>: <code>colcon</code>이 패키지 간의 관계를 명확히 파악하여 항상 올바른 순서로 빌드를 수행하도록 보장하며, 순환 의존성과 같은 잠재적 문제를 사전에 방지한다.</li>
<li><strong>향상된 협업과 재사용성</strong>: 패키지의 목적, 라이선스, 유지보수 정보, 그리고 의존성을 명확히 함으로써 다른 개발자들이 패키지를 쉽게 이해하고 안전하게 재사용할 수 있는 기반을 마련한다.</li>
<li><strong>체계적인 배포</strong>: 유의적 버전 관리와 <code>bloom</code> 도구와의 연동을 통해, 코드의 특정 버전을 안정적으로 패키징하고 배포하는 체계적인 릴리스 파이프라인을 구축할 수 있게 한다.</li>
</ul>
<p>결론적으로, <code>package.xml</code>을 능숙하게 다루는 능력은 ROS 2 개발자의 핵심 역량 중 하나다. 이 안내서에서 다룬 원칙과 모범 사례들을 꾸준히 적용한다면, 더 안정적이고, 유지보수하기 쉬우며, 확장 가능한 로봇 소프트웨어를 개발하는 데 큰 도움이 될 것이다. <code>package.xml</code>은 사소한 설정 파일이 아니라, 훌륭한 로봇 공학 프로젝트를 지탱하는 견고한 초석이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Creating a package - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html</li>
<li>Creating a package - ROS 2 Documentation: Foxy documentation, accessed July 27, 2025, https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html</li>
<li>The build system - ROS 2 Documentation: Iron documentation, accessed July 27, 2025, https://docs.ros.org/en/iron/Concepts/Advanced/About-Build-System.html</li>
<li>ros - Dependency management in ROS2: CMakeLists.txt, package …, accessed July 27, 2025, https://robotics.stackexchange.com/questions/96942/dependency-management-in-ros2-cmakelists-txt-package-xml-colcon-build-make</li>
<li>The build system - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/Concepts/Advanced/About-Build-System.html</li>
<li>Managing Dependencies with rosdep - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/Tutorials/Intermediate/Rosdep.html</li>
<li>REP 149 – Package Manifest Format Three Specification (ROS.org), accessed July 27, 2025, https://ros.org/reps/rep-0149.html</li>
<li>ROS Cheat Sheet | Clearpath Robotics Documentation, accessed July 27, 2025, https://docs.clearpathrobotics.com/docs/ros/tutorials/cheat_sheet</li>
<li>https://ros2-tutorial.readthedocs.io/en/latest/_downloads/d105360c187244c8f4ad65b892cff4c1/package.xml, accessed July 27, 2025, https://ros2-tutorial.readthedocs.io/en/latest/_downloads/d105360c187244c8f4ad65b892cff4c1/package.xml</li>
<li>ros1_bridge/package.xml at master - GitHub, accessed July 27, 2025, https://github.com/ros2/ros1_bridge/blob/master/package.xml</li>
<li>How do you validate your package.xmls in ROS2? - General - ROS Discourse, accessed July 27, 2025, https://discourse.ros.org/t/how-do-you-validate-your-package-xmls-in-ros2/23875</li>
<li>ROS2 C++ Package Creation Guide | ROS2 Tutorial - The Construct, accessed July 27, 2025, https://www.theconstruct.ai/ros2-cpp-package-creation-guide-ros2-tutorial/</li>
<li>Migrating Packages - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/How-To-Guides/Migrating-from-ROS1/Migrating-Packages.html</li>
<li>Semantic Versioning 2.0.0 | Semantic Versioning, accessed July 27, 2025, https://semver.org/</li>
<li>How to release a ROS 2 binary package - Part 3 - The Construct, accessed July 27, 2025, https://www.theconstruct.ai/how-to-release-a-ros-2-binary-package-part-3/</li>
<li>nav2_behavior_tree/package.xml / main / undefined / GitLab, accessed July 27, 2025, https://git.tu-berlin.de/ecschuetz/navigation2/-/blob/main/nav2_behavior_tree/package.xml?ref_type=heads</li>
<li>example_interfaces/package.xml at rolling / ros2 … - GitHub, accessed July 27, 2025, https://github.com/ros2/example_interfaces/blob/rolling/package.xml</li>
<li>pluginlib - ROS Wiki, accessed July 27, 2025, http://wiki.ros.org/pluginlib</li>
<li>Package manifest XML tags reference - ROS, accessed July 27, 2025, http://ros.org/doc/independent/api/rospkg/html/manifest_xml.html</li>
<li>The build system “ament_cmake” and the meta build tool “ament_tools” - ROS2 Design, accessed July 27, 2025, https://design.ros2.org/articles/ament.html</li>
<li>Managing Dependencies with rosdep - ROS 2 Documentation: Foxy documentation, accessed July 27, 2025, https://docs.ros.org/en/foxy/Tutorials/Intermediate/Rosdep.html</li>
<li>catkin/package.xml - ROS Wiki, accessed July 27, 2025, http://wiki.ros.org/catkin/package.xml</li>
<li>Migration guide from ROS 1 - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://ftp.udx.icscoe.jp/ros/ros_docs_mirror/en/humble/Contributing/Migration-Guide.html</li>
<li>ROS2 XML Launch File Example - The Robotics Back-End, accessed July 27, 2025, https://roboticsbackend.com/ros2-xml-launch-file/</li>
<li>Guidelines and Best Practices, accessed July 27, 2025, https://autowarefoundation.gitlab.io/autoware.auto/AutowareAuto/contributor-guidelines.html</li>
<li>ament_cmake_python user documentation - the official ROS docs, accessed July 27, 2025, https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Python-Documentation.html</li>
<li>Ability to query build or exec dependencies only / Issue #587 / ros-infrastructure/rosdep, accessed July 27, 2025, https://github.com/ros-infrastructure/rosdep/issues/587</li>
<li>Use identical package.xml for ROS1 and ROS2 pkgs - Robotics Stack Exchange, accessed July 27, 2025, https://robotics.stackexchange.com/questions/86231/use-identical-package-xml-for-ros1-and-ros2-pkgs</li>
<li>Support for format three package.xml conditions / Issue #653 / ros-infrastructure/rosdep - GitHub, accessed July 27, 2025, https://github.com/ros-infrastructure/rosdep/issues/653</li>
<li>About the build system - ROS 2 Documentation: Foxy documentation, accessed July 27, 2025, https://docs.ros.org/en/foxy/Concepts/About-Build-System.html</li>
<li>Migrating a Python Package Example - ROS 2 Documentation …, accessed July 27, 2025, https://docs.ros.org/en/humble/How-To-Guides/Migrating-from-ROS1/Migrating-Python-Package-Example.html</li>
<li>Create a ROS2 package for Both Python and Cpp Nodes - The Robotics Back-End, accessed July 27, 2025, https://roboticsbackend.com/ros2-package-for-both-python-and-cpp-nodes/</li>
<li>ament_cmake_python user documentation - ROS 2 Documentation, accessed July 27, 2025, https://ftp.udx.icscoe.jp/ros/ros_docs_mirror/en/humble/How-To-Guides/Ament-CMake-Python-Documentation.html</li>
<li>Dependency from rmw_cyclonedds_cpp on fastrtps via rmw_dds_common #16 - GitHub, accessed July 27, 2025, https://github.com/ros2/rmw_dds_common/issues/16</li>
<li>Creating and Using Plugins (C++) - ROS 2 Documentation: Xin 文档, accessed July 27, 2025, https://daobook.github.io/ros2-docs/xin/Tutorials/Pluginlib.html</li>
<li>Question about how to export plugin.xml files / Issue #198 / ros/pluginlib - GitHub, accessed July 27, 2025, https://github.com/ros/pluginlib/issues/198</li>
<li>Creating and using plugins (C++) - ROS 2 Documentation: Foxy documentation, accessed July 27, 2025, https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Pluginlib.html</li>
<li>ament_cmake user documentation - ROS 2 Documentation: Humble documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Documentation.html</li>
<li>ROS 2 metapackages/variants support / Issue #408 - GitHub, accessed July 27, 2025, https://github.com/ros2/ros2/issues/408</li>
<li>package.xml - gazebosim/ros_gz - GitHub, accessed July 27, 2025, https://github.com/gazebosim/ros_gz/blob/ros2/ros_gz/package.xml</li>
<li>Using variants - Galactic documentation - the official ROS docs, accessed July 27, 2025, https://docs.ros.org/en/galactic/How-To-Guides/Using-Variants.html</li>
<li>Package Organization For a ROS Stack [Best Practices] - The Robotics Back-End, accessed July 27, 2025, https://roboticsbackend.com/package-organization-for-a-ros-stack-best-practices/</li>
<li>ROS2 Part 9 - ROS2 Launch Files - RoboticsUnveiled, accessed July 27, 2025, https://www.roboticsunveiled.com/ros2-launch-files/</li>
<li>REP 140 – Package Manifest Format Two Specification (ROS.org), accessed July 27, 2025, https://www.ros.org/reps/rep-0140.html</li>
<li>Using Git Tags for Semantic Versioning (Step-by-Step Guide) - Medium, accessed July 27, 2025, https://medium.com/@wealthiscertain/using-git-tags-for-semantic-versioning-step-by-step-guide-02b18d73a7b9</li>
<li>Managing Releases with Semantic Versioning and Git Tags - GitKraken, accessed July 27, 2025, https://www.gitkraken.com/gitkon/semantic-versioning-git-tags</li>
<li>Bloom release from a specific tag in a specific branch - ROS Discourse, accessed July 27, 2025, https://discourse.ros.org/t/bloom-release-from-a-specific-tag-in-a-specific-branch/37922</li>
<li>Invalid package.xml suppresses error and silently succeeds if setup.py present / Issue #146, accessed July 27, 2025, https://github.com/colcon/colcon-ros/issues/146</li>
<li>How to solve the ERROR Cannot locate rosdep definition for [PCL] in ROS2 Humble?, accessed July 27, 2025, https://robotics.stackexchange.com/questions/107920/how-to-solve-the-error-cannot-locate-rosdep-definition-for-pcl-in-ros2-humble</li>
<li>ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies: I’m using Ubuntu 18.04; ROS Melodic - Reddit, accessed July 27, 2025, https://www.reddit.com/r/ROS/comments/1ac4t7f/error_the_following_packagesstacks_could_not_have/</li>
<li>Cannot locate rosdep definition - ROS Answers archive, accessed July 27, 2025, http://answers.ros.org/question/320734/</li>
<li>Managing Dependencies with rosdep - ROS 2 Documentation: Rolling documentation, accessed July 27, 2025, https://docs.ros.org/en/rolling/Tutorials/Intermediate/Rosdep.html</li>
<li>Managing Dependencies with rosdep - documentación de ROS 2 Documentation, accessed July 27, 2025, https://ros-spanish-users-group.github.io/ros2_documentation/humble/Tutorials/Intermediate/Rosdep.html</li>
<li>rosdistro/REVIEW_GUIDELINES.md at master - GitHub, accessed July 27, 2025, https://github.com/ros/rosdistro/blob/master/REVIEW_GUIDELINES.md</li>
<li>rostooling/cc-rosdep - Docker Image, accessed July 27, 2025, https://hub.docker.com/r/rostooling/cc-rosdep</li>
<li>Generate deb from dependent res package locally - Robotics Stack Exchange, accessed July 27, 2025, https://robotics.stackexchange.com/questions/84788/generate-deb-from-dependent-res-package-locally</li>
<li>Cannot locate rosdep definition for [ament_lint_common] - ROS Answers archive, accessed July 27, 2025, https://answers.ros.org/question/371969/</li>
<li>colcon can not find my package - ROS Answers archive, accessed July 27, 2025, https://answers.ros.org/question/364278/</li>
<li>[feature] CI job to verify dependencies package.xml / Issue #29685 / ros/rosdistro - GitHub, accessed July 27, 2025, https://github.com/ros/rosdistro/issues/29685</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>