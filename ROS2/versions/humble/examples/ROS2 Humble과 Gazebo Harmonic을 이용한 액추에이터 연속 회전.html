<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS2 Humble과 Gazebo Harmonic을 이용한 액추에이터 연속 회전</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS2 Humble과 Gazebo Harmonic을 이용한 액추에이터 연속 회전</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">ROS2 (Robot Operating System 2)</a> / <a href="../../index.html">ROS2 Versions</a> / <a href="../index.html">ROS2 Humble</a> / <a href="index.html">ROS2 Humble 예제</a> / <span>ROS2 Humble과 Gazebo Harmonic을 이용한 액추에이터 연속 회전</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS2 Humble과 Gazebo Harmonic을 이용한 액추에이터 연속 회전</h1>
<p>이 안내서는 ROS2 Humble과 최신 Gazebo 시뮬레이터인 Gazebo Harmonic을 사용하여 단일 액추에이터(회전 관절)를 지속적으로 회전시키는 완전한 예제를 제공한다. 전체 시스템 아키텍처, 환경 설정, 필수 코드 파일(URDF, YAML, Launch, Python), 실행 및 검증 절차, 그리고 시스템 동작의 이론적 배경까지 심도 있게 다룬다.</p>
<h2>1. 시스템 아키텍처 및 환경 설정</h2>
<p>성공적인 시뮬레이션을 위해서는 먼저 구성 요소들이 어떻게 상호작용하는지 이해하고, 호환되는 환경을 올바르게 구축해야 한다.</p>
<h3>1.1 제어 파이프라인 개요</h3>
<p>본 예제에서 구현할 제어 시스템의 데이터 흐름은 다음과 같다.</p>
<ol>
<li><strong>Python 퍼블리셔 노드</strong>: 일정한 속도 명령(<code>std_msgs/msg/Float64MultiArray</code> 타입)을 생성하여 특정 토픽으로 발행한다.</li>
<li><strong>ROS2 토픽 (<code>/velocity_controller/commands</code>)</strong>: 퍼블리셔 노드와 컨트롤러 사이의 통신 채널 역할을 한다.</li>
<li><strong><code>ros2_control</code> 컨트롤러 (<code>velocity_controllers/JointGroupVelocityController</code>)</strong>: 토픽을 구독하여 속도 명령을 수신한다.1</li>
<li><strong>컨트롤러 매니저 (<code>ros2_control_node</code>)</strong>: 컨트롤러의 생명주기를 관리하고, 실시간 제어 루프를 실행하여 컨트롤러의 <code>update()</code> 함수를 주기적으로 호출한다.2</li>
<li><strong>Gazebo 시스템 플러그인 (<code>gz_ros2_control</code>)</strong>: <code>ros2_control</code>을 위한 하드웨어 인터페이스 역할을 한다. 컨트롤러로부터 받은 명령을 Gazebo 시뮬레이션이 이해할 수 있는 형태로 변환하여 전달한다.4</li>
<li><strong>Gazebo Harmonic</strong>: 물리 엔진을 통해 로봇 모델의 관절에 명령을 적용하고, 그 결과를 시뮬레이션한다.</li>
<li><strong>상태 피드백</strong>: <code>gz_ros2_control</code> 플러그인은 시뮬레이션으로부터 관절의 현재 상태(위치, 속도 등)를 읽어와 <code>ros2_control</code>의 상태 인터페이스(state interface)를 통해 컨트롤러 매니저와 다른 ROS 노드에 제공한다. 이 정보는 <code>/joint_states</code>와 같은 토픽으로 발행된다.6</li>
</ol>
<h3>1.2 핵심 사항: ROS2 Humble &amp; Gazebo Harmonic 호환성 매트릭스 탐색</h3>
<p>가장 먼저 해결해야 할 중요한 문제는 ROS2 Humble과 Gazebo Harmonic의 호환성이다. 공식적으로 ROS2 Humble은 Gazebo Fortress를 지원한다.7 따라서 표준적인 <code>sudo apt install ros-humble-ros-gz</code> 명령은 Gazebo Fortress를 설치하게 된다.</p>
<p>하지만 사용자의 요구사항은 Gazebo Harmonic이다. 이 비표준 조합을 사용하기 위해서는 Gazebo 프로젝트에서 직접 제공하는 패키지 저장소를 이용해야 한다. 이 방법은 Humble의 공식 Gazebo 패키지(<code>ros-humble-ros-gz-fortress</code> 등)와 충돌을 일으킬 수 있으므로, 기존에 Gazebo Fortress 관련 패키지를 설치했다면 제거하거나 깨끗한 환경에서 시작하는 것이 좋다.7</p>
<p>다음 단계에 따라 ROS2 Humble 환경에 Gazebo Harmonic을 설치한다.</p>
<ol>
<li>Gazebo 패키지 저장소 추가:</li>
</ol>
<p>Gazebo의 GPG 키를 등록하고 패키지 소스를 시스템에 추가한다.</p>
<pre><code class="language-Bash">sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list &gt; /dev/null
</code></pre>
<ol start="2">
<li>Gazebo Harmonic 설치:</li>
</ol>
<p>패키지 목록을 업데이트하고 Gazebo Harmonic을 설치한다.</p>
<pre><code class="language-Bash">sudo apt-get update
sudo apt-get install gz-harmonic
</code></pre>
<ol start="3">
<li>비공식 ROS2-Gazebo 연동 패키지 설치:</li>
</ol>
<p>Gazebo Harmonic과 ROS2 Humble을 연결하는 비공식 브릿지 패키지를 설치한다.7</p>
<pre><code class="language-Bash">sudo apt-get install ros-humble-ros-gzharmonic
</code></pre>
<h3>1.3 <code>ros2_control</code> 및 필수 패키지 설치</h3>
<p>다음으로 <code>ros2_control</code> 프레임워크와 컨트롤러, 그리고 Gazebo 연동을 위한 플러그인을 설치해야 한다. <code>ros2_control</code>은 로봇 하드웨어를 추상화하고 제어기들을 관리하는 프레임워크다.8</p>
<p>Gazebo 연동 플러그인은 두 가지가 존재하는데, <code>gazebo_ros2_control</code>은 구버전인 Gazebo Classic(11.x 이하)용이며 더 이상 유지보수되지 않는다.10 최신 Gazebo(Garden, Harmonic, Ionic 등)에서는 <code>gz_ros2_control</code>을 사용해야 한다.4 이 예제는 Gazebo Harmonic을 사용하므로 <code>gz_ros2_control</code> 관련 패키지를 설치한다.</p>
<pre><code class="language-Bash">sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gz-ros2-control ros-humble-gz-ros2-control-demos
</code></pre>
<p>이 명령은 다음을 설치한다:</p>
<ul>
<li><code>ros-humble-ros2-control</code>: <code>ros2_control</code>의 핵심 구성요소(컨트롤러 매니저, 리소스 매니저 등).</li>
<li><code>ros-humble-ros2-controllers</code>: <code>ForwardCommandController</code>, <code>JointTrajectoryController</code> 등 널리 사용되는 표준 컨트롤러 모음.8</li>
<li><code>ros-humble-gz-ros2-control</code>: 최신 Gazebo와 <code>ros2_control</code>을 연동하는 플러그인.</li>
<li><code>ros-humble-gz-ros2-control-demos</code>: <code>gz_ros2_control</code>의 사용법을 보여주는 예제 패키지.</li>
</ul>
<h2>2. 물리적 구현: 로봇 URDF 정의</h2>
<p>URDF(Unified Robot Description Format)는 로봇의 물리적 구조(링크, 관절)와 <code>ros2_control</code> 및 Gazebo와의 연동 설정을 정의하는 XML 파일이다.</p>
<h3>2.1 패키지 및 파일 구조 생성</h3>
<p>먼저 이 예제를 위한 ROS2 패키지를 생성한다.</p>
<pre><code class="language-Bash">cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python simple_velocity_robot
cd simple_velocity_robot
mkdir urdf config launch
</code></pre>
<p>생성된 패키지는 다음과 같은 파일 구조를 갖게 된다.</p>
<pre><code>simple_velocity_robot/
├── config/
│   └── controllers.yaml
├── launch/
│   └── robot_launch.py
├── src/
│   └── simple_velocity_robot/
│       └── velocity_publisher.py
├── urdf/
│   └── robot.urdf.xacro
├── package.xml
└── setup.py
</code></pre>
<h3>2.2 로봇의 청사진: <code>robot.urdf.xacro</code></h3>
<p><code>urdf/robot.urdf.xacro</code> 파일에 로봇의 구조를 정의한다. 이 로봇은 고정된 <code>base_link</code>와 회전하는 <code>rotating_link</code>, 그리고 두 링크를 연결하는 <code>revolute_joint</code>로 구성된 매우 간단한 모델이다.</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="simple_velocity_robot"&gt;

  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.5 0.5 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin xyz="0 0 0.1" rpy="0 0 0"/&gt;
      &lt;material name="grey"&gt;
        &lt;color rgba="0.5 0.5 0.5 1.0"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;box size="0.5 0.5 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin xyz="0 0 0.1" rpy="0 0 0"/&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass value="1.0"/&gt;
      &lt;inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;

  &lt;link name="rotating_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder radius="0.05" length="0.4"/&gt;
      &lt;/geometry&gt;
      &lt;origin xyz="0 0 0.2" rpy="0 0 0"/&gt;
      &lt;material name="blue"&gt;
        &lt;color rgba="0.1 0.1 0.8 1.0"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder radius="0.05" length="0.4"/&gt;
      &lt;/geometry&gt;
      &lt;origin xyz="0 0 0.2" rpy="0 0 0"/&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass value="0.5"/&gt;
      &lt;inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;

  &lt;joint name="revolute_joint" type="revolute"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="rotating_link"/&gt;
    &lt;origin xyz="0 0 0.2" rpy="0 0 0"/&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;limit lower="-3.14" upper="3.14" effort="10.0" velocity="10.0"/&gt;
  &lt;/joint&gt;

  &lt;xacro:include filename="$(find simple_velocity_robot)/urdf/robot.ros2_control.xacro" /&gt;
  &lt;xacro:rrbot_ros2_control /&gt;

&lt;/robot&gt;
</code></pre>
<p>편의를 위해 <code>ros2_control</code>과 Gazebo 관련 태그는 별도의 파일(<code>robot.ros2_control.xacro</code>)로 분리하여 포함시킨다.</p>
<h3>2.3 <code>ros2_control</code> 인터페이스 태그</h3>
<p><code>urdf/robot.ros2_control.xacro</code> 파일을 생성하고 <code>ros2_control</code>과의 연동을 위한 핵심 설정을 추가한다.</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;robot xmlns:xacro="http://www.ros.org/wiki/xacro"&gt;

  &lt;xacro:macro name="rrbot_ros2_control"&gt;
    &lt;ros2_control name="GazeboSimSystem" type="system"&gt;
      &lt;hardware&gt;
        &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;
      &lt;/hardware&gt;
      &lt;joint name="revolute_joint"&gt;
        &lt;command_interface name="velocity"&gt;
          &lt;param name="min"&gt;-10.0&lt;/param&gt;
          &lt;param name="max"&gt;10.0&lt;/param&gt;
        &lt;/command_interface&gt;
        &lt;state_interface name="position"/&gt;
        &lt;state_interface name="velocity"/&gt;
      &lt;/joint&gt;
    &lt;/ros2_control&gt;
  &lt;/xacro:macro&gt;

&lt;/robot&gt;
</code></pre>
<p>이 설정의 각 부분은 다음과 같은 의미를 가진다.</p>
<ul>
<li><code>&lt;ros2_control name="GazeboSimSystem" type="system"&gt;</code>: <code>ros2_control</code> 설정 블록을 정의한다. <code>type="system"</code>은 여러 관절과 센서를 포함하는 로봇 전체 시스템을 위한 하드웨어 인터페이스를 의미한다.3</li>
<li><code>&lt;hardware&gt;&lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;&lt;/hardware&gt;</code>: 컨트롤러 매니저의 리소스 매니저가 로드할 하드웨어 인터페이스 플러그인을 지정한다. <code>GazeboSimSystem</code>은 최신 Gazebo 시뮬레이터와 연동하기 위한 올바른 플러그인이다.4</li>
<li><code>&lt;joint name="revolute_joint"&gt;</code>: 이 제어 설정을 URDF에 정의된 <code>revolute_joint</code>에 연결한다.</li>
<li><code>&lt;command_interface name="velocity"&gt;</code>: 이 관절에 대해 “velocity” 타입의 명령 인터페이스를 노출시킨다. 컨트롤러는 이 인터페이스를 ’점유(claim)’하여 제어 명령을 내릴 수 있다. <code>position</code>, <code>effort</code> 등 다른 타입도 가능하다.6</li>
<li><code>&lt;param name="min/max"&gt;</code>: 명령 인터페이스에 대한 최소/최대값을 설정한다.</li>
<li><code>&lt;state_interface name="position/velocity"&gt;</code>: 하드웨어 인터페이스(Gazebo 플러그인)가 시뮬레이터로부터 관절의 위치와 속도 상태를 읽어와 ROS2 시스템에 제공하도록 지시한다. 이 값들은 <code>joint_state_broadcaster</code>에 의해 토픽으로 발행된다.6</li>
</ul>
<h3>2.4 Gazebo 시뮬레이션 플러그인 태그</h3>
<p>마지막으로, Gazebo가 시뮬레이션을 시작할 때 <code>ros2_control</code> 시스템을 로드하도록 지시하는 플러그인을 <code>robot.urdf.xacro</code>의 <code>&lt;xacro:macro&gt;</code> 내부에 추가한다.</p>
<pre><code class="language-XML">&lt;gazebo&gt;
  &lt;plugin filename="libgz_ros2_control-system.so" name="gz_ros2_control::GazeboSimROS2ControlPlugin"&gt;
    &lt;parameters&gt;$(find simple_velocity_robot)/config/controllers.yaml&lt;/parameters&gt;
  &lt;/plugin&gt;
&lt;/gazebo&gt;
</code></pre>
<ul>
<li><code>&lt;plugin filename="libgz_ros2_control-system.so" name="gz_ros2_control::GazeboSimROS2ControlPlugin"&gt;</code>: Gazebo 시뮬레이션 내에서 실행될 플러그인을 지정한다. 이 플러그인은 URDF 내의 <code>&lt;ros2_control&gt;</code> 태그를 파싱하고, 컨트롤러 매니저를 포함한 <code>ros2_control</code> 프레임워크를 시뮬레이션 환경 내에 인스턴스화하는 역할을 한다.4</li>
<li><code>&lt;parameters&gt;...&lt;/parameters&gt;</code>: 컨트롤러 매니저가 로드될 때 필요한 컨트롤러 설정 파일의 경로를 전달한다. 이를 통해 런치 파일에서 별도로 파라미터를 로드할 필요 없이 URDF만으로 컨트롤러 설정까지 한 번에 처리할 수 있어 편리하다.4</li>
</ul>
<h2>3. 제어 로직: 컨트롤러 설정</h2>
<p>컨트롤러의 종류, 파라미터, 그리고 컨트롤러 매니저의 동작 방식을 YAML 파일을 통해 설정한다.</p>
<h3>3.1 <code>controllers.yaml</code> 파일</h3>
<p><code>config/controllers.yaml</code> 파일을 생성하고 다음 내용을 작성한다.</p>
<pre><code class="language-YAML">controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    # The list of controllers to be loaded and activated
    # This is not strictly necessary, as we spawn them from the launch file
    # but it's good practice to list them here.
    # joint_state_broadcaster:
    #   type: joint_state_broadcaster/JointStateBroadcaster
    # velocity_controller:
    #   type: velocity_controllers/JointGroupVelocityController

# Controller configurations
joint_state_broadcaster:
  type: joint_state_broadcaster/JointStateBroadcaster

velocity_controller:
  type: velocity_controllers/JointGroupVelocityController
  ros__parameters:
    joints:
      - revolute_joint
    # The 'interface_name' is implicitly 'velocity' for this controller type
    # interface_name: velocity
</code></pre>
<h3>3.2 컨트롤러 매니저 설정</h3>
<ul>
<li><code>controller_manager: ros__parameters: update_rate: 100</code>: 컨트롤러 매니저의 주된 <code>read-update-write</code> 제어 루프의 실행 주기를 100 Hz로 설정한다. 이 값이 높을수록 로봇의 반응성이 향상되지만, 계산 부하도 증가한다.14</li>
</ul>
<h3>3.3 브로드캐스터 설정</h3>
<ul>
<li><code>joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster</code>: <code>joint_state_broadcaster</code>는 <code>ros2_control</code>의 필수적인 유틸리티 컨트롤러다. URDF의 <code>&lt;state_interface&gt;</code>에 등록된 모든 관절의 상태(위치, 속도 등)를 읽어와 표준 ROS 메시지 형태로 <code>/joint_states</code> 및 <code>/dynamic_joint_states</code> 토픽에 발행하는 역할을 한다. RViz나 MoveIt과 같은 다른 ROS 도구들이 로봇의 현재 자세를 인지하기 위해 이 토픽을 구독한다.16</li>
</ul>
<h3>3.4 속도 컨트롤러 설정</h3>
<ul>
<li><code>velocity_controller: type: velocity_controllers/JointGroupVelocityController</code>: 목표를 달성하기 위해 사용할 컨트롤러다. <code>ros2_controllers</code> 패키지는 <code>forward_command_controller</code>라는 범용 컨트롤러를 제공하지만 18,</li>
</ul>
<p><code>velocity</code>, <code>position</code>, <code>effort</code> 등 특정 인터페이스에 특화된 컨트롤러들도 제공한다. <code>velocity_controllers/JointGroupVelocityController</code>는 속도 인터페이스를 사용하도록 미리 설정된 특화 컨트롤러로, 코드가 더 명시적이고 설정이 간결해지는 장점이 있다.1</p>
<ul>
<li>
<p><code>ros__parameters: joints: - revolute_joint</code>: 이 컨트롤러가 제어할 관절의 목록을 지정한다. 여기서는 <code>revolute_joint</code> 하나만 제어한다.1</p>
</li>
<li>
<p><code>interface_name: velocity</code>: 이 컨트롤러 타입은 내부적으로 <code>velocity</code> 인터페이스를 사용하도록 기본 설정되어 있어 명시적으로 작성할 필요는 없다. 이 설정은 컨트롤러가 URDF에 정의된 <code>revolute_joint</code>의 <code>command_interface</code> 중 <code>name="velocity"</code>인 것을 찾아 점유하도록 지시한다.</p>
</li>
</ul>
<h3>3.5 핵심 설정 파라미터 요약</h3>
<p>다음 표는 로봇을 제어하기 위해 URDF와 YAML 파일에서 설정한 핵심 파라미터들을 요약한 것이다.</p>
<table><thead><tr><th>파라미터</th><th>파일 위치</th><th>섹션</th><th>목적</th></tr></thead><tbody>
<tr><td><code>plugin</code></td><td><code>robot.urdf.xacro</code></td><td><code>&lt;ros2_control&gt;&lt;hardware&gt;</code></td><td>하드웨어 인터페이스 플러그인(<code>gz_ros2_control/GazeboSimSystem</code>)을 지정한다.</td></tr>
<tr><td><code>command_interface</code></td><td><code>robot.urdf.xacro</code></td><td><code>&lt;ros2_control&gt;&lt;joint&gt;</code></td><td>관절이 수용할 명령의 종류(예: <code>velocity</code>)를 정의한다.</td></tr>
<tr><td><code>state_interface</code></td><td><code>robot.urdf.xacro</code></td><td><code>&lt;ros2_control&gt;&lt;joint&gt;</code></td><td>하드웨어로부터 읽어올 상태 변수(예: <code>position</code>, <code>velocity</code>)를 정의한다.</td></tr>
<tr><td><code>plugin</code></td><td><code>robot.urdf.xacro</code></td><td><code>&lt;gazebo&gt;</code></td><td>Gazebo가 <code>ros2_control</code>을 로드하기 위해 사용할 플러그인(<code>libgz_ros2_control-system.so</code>)을 지정한다.</td></tr>
<tr><td><code>update_rate</code></td><td><code>controllers.yaml</code></td><td><code>controller_manager</code></td><td><code>ros2_control</code> 제어 루프의 주기를 설정한다.</td></tr>
<tr><td><code>type</code></td><td><code>controllers.yaml</code></td><td><code>velocity_controller</code></td><td>사용할 컨트롤러 알고리즘(<code>velocity_controllers/JointGroupVelocityController</code>)을 정의한다.</td></tr>
<tr><td><code>joints</code></td><td><code>controllers.yaml</code></td><td><code>velocity_controller</code></td><td>해당 컨트롤러가 관리할 관절 목록을 지정한다.</td></tr>
</tbody></table>
<h2>4. 오케스트레이터: 시스템 런치 파일</h2>
<p>런치 파일은 Gazebo 시뮬레이터, 로봇 모델, <code>ros2_control</code> 노드 등 여러 구성요소를 순서에 맞게 실행시키는 역할을 한다.</p>
<h3>4.1 <code>robot_launch.py</code> 파일</h3>
<p><code>launch/robot_launch.py</code> 파일을 생성하고 다음 코드를 작성한다.</p>
<pre><code class="language-Python">import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, RegisterEventHandler
from launch.event_handlers import OnProcessExit
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
import xacro

def generate_launch_description():
    pkg_path = os.path.join(get_package_share_directory('simple_velocity_robot'))

    # Process the URDF file
    xacro_file = os.path.join(pkg_path, 'urdf', 'robot.urdf.xacro')
    robot_description_config = xacro.process_file(xacro_file)
    robot_description = {'robot_description': robot_description_config.toxml()}

    # Create a robot_state_publisher node
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        output='screen',
        parameters=[robot_description]
    )

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([os.path.join(
            get_package_share_directory('ros_gz_sim'), 'launch', 'gz_sim.launch.py')]),
        launch_arguments={'gz_args': '-r -v 4 empty.sdf'}.items()
    )

    # Spawn robot
    spawn_entity = Node(
        package='ros_gz_sim',
        executable='create',
        arguments=['-topic', 'robot_description',
                   '-entity', 'simple_robot'],
        output='screen'
    )

    # Spawn controllers
    joint_state_broadcaster_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["joint_state_broadcaster", "--controller-manager", "/controller_manager"],
    )

    velocity_controller_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["velocity_controller", "--controller-manager", "/controller_manager"],
    )
    
    # Ensure controllers are spawned after Gazebo is ready
    # This is a robust way to handle startup race conditions.
    # We wait for the spawn_entity node to finish, which implies Gazebo is running and the robot model is loaded.
    # Then we spawn the controllers.
    delay_broadcaster_after_spawn = RegisterEventHandler(
        event_handler=OnProcessExit(
            target_action=spawn_entity,
            on_exit=[joint_state_broadcaster_spawner],
        )
    )

    delay_controller_after_broadcaster = RegisterEventHandler(
        event_handler=OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[velocity_controller_spawner],
        )
    )


    return LaunchDescription([
        gazebo,
        robot_state_publisher_node,
        spawn_entity,
        delay_broadcaster_after_spawn,
        delay_controller_after_broadcaster,
    ])
</code></pre>
<h3>4.2 로봇 디스크립션 로딩</h3>
<ul>
<li>XACRO 파일을 처리하여 완전한 URDF XML 문자열을 생성하고, 이를 <code>robot_description</code> 파라미터로 만든다. 이는 ROS2에서 로봇 모델을 전달하는 표준 방식이다.20</li>
<li><code>robot_state_publisher</code> 노드는 <code>/joint_states</code> 토픽을 구독하고 <code>robot_description</code>을 사용하여 로봇의 각 링크 간의 좌표 변환 정보(TF)를 <code>/tf</code> 토픽으로 발행한다. 이 정보는 RViz와 같은 시각화 도구에서 로봇 모델을 올바르게 표시하는 데 필수적이다.21</li>
</ul>
<h3>4.3 Gazebo 실행 및 로봇 스폰</h3>
<ul>
<li><code>IncludeLaunchDescription</code>을 사용하여 <code>ros_gz_sim</code> 패키지에서 제공하는 런치 파일을 포함시켜 Gazebo 시뮬레이터를 실행한다.22</li>
<li><code>ros_gz_sim</code>의 <code>create</code> 실행 파일을 사용하는 <code>spawn_entity</code> 노드는 <code>robot_description</code> 토픽을 구독하여 해당 모델을 실행 중인 Gazebo 월드에 스폰(생성)한다.21</li>
</ul>
<h3>4.4 <code>ros2_control</code> 시스템 시작</h3>
<ul>
<li>
<p><code>controller_manager</code>의 <code>spawner</code> 실행 파일은 컨트롤러 매니저의 서비스(<code>/controller_manager/load_and_start_controller</code>)를 호출하여 YAML 파일에 정의된 컨트롤러를 로드하고 활성화하는 유틸리티다.6</p>
</li>
<li>
<p>단순히 모든 노드를 동시에 시작하면, 컨트롤러 매니저가 준비되기 전에 스포너가 실행되어 실패하는 등의 경쟁 상태(race condition)가 발생할 수 있다. <code>ros2_control_demos</code>의 런치 파일들에서 볼 수 있듯이 24,</p>
</li>
</ul>
<p><code>RegisterEventHandler</code>와 <code>OnProcessExit</code>를 사용하는 것이 훨씬 안정적이다. 이 예제에서는 로봇 스폰(<code>spawn_entity</code>)이 완료된 후에 <code>joint_state_broadcaster</code>를 스폰하고, 그것이 완료된 후에 <code>velocity_controller</code>를 스폰하도록 하여, 각 구성요소가 순서대로 안전하게 시작되도록 보장한다.</p>
<h2>5. 원동력: 속도 명령 퍼블리셔</h2>
<p>이제 로봇을 실제로 움직이게 할 속도 명령을 보내는 간단한 Python 노드를 작성한다.</p>
<h3>5.1 <code>velocity_publisher.py</code> 스크립트</h3>
<p><code>src/simple_velocity_robot/velocity_publisher.py</code> 파일을 생성하고 다음 코드를 작성한다.</p>
<pre><code class="language-Python">import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray

class VelocityPublisher(Node):
    def __init__(self):
        super().__init__('velocity_publisher')
        self.publisher_ = self.create_publisher(
            Float64MultiArray,
            '/velocity_controller/commands',
            10)
        timer_period = 0.1  # 10 Hz
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.get_logger().info('Velocity publisher has been started.')

    def timer_callback(self):
        msg = Float64MultiArray()
        # Set a constant velocity command of 1.5 rad/s
        msg.data = [1.5]
        self.publisher_.publish(msg)
        # self.get_logger().info('Publishing velocity: "%s"' % msg.data)

def main(args=None):
    rclpy.init(args=args)
    velocity_publisher = VelocityPublisher()
    rclpy.spin(velocity_publisher)
    velocity_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
</code></pre>
<h3>5.2 코드 분석</h3>
<ul>
<li><strong>임포트</strong>: <code>rclpy</code>와 <code>Node</code>, 그리고 컨트롤러가 수신할 메시지 타입인 <code>Float64MultiArray</code>를 <code>std_msgs.msg</code>로부터 임포트한다.25</li>
<li><strong>퍼블리셔 생성</strong>: <code>create_publisher</code>를 사용하여 퍼블리셔를 초기화한다. 토픽 이름은 <code>&lt;controller_name&gt;/commands</code> 규칙에 따라 <code>/velocity_controller/commands</code>로 지정해야 한다. 메시지 타입은 <code>Float64MultiArray</code>이며, 이는 여러 관절을 동시에 제어할 수 있도록 설계되었기 때문이다.16</li>
<li><strong>타이머 콜백</strong>: <code>create_timer</code>를 사용하여 0.1초(10 Hz)마다 <code>timer_callback</code> 함수를 호출한다. 이를 통해 지속적인 명령 발행이 가능하다.27</li>
<li><strong>메시지 발행</strong>: 콜백 함수 내에서 <code>Float64MultiArray</code> 메시지 객체를 생성하고, <code>data</code> 필드에 원하는 속도값을 리스트 형태로 할당한다. 관절이 하나뿐이라도 반드시 리스트(<code>[1.5]</code>)로 전달해야 한다. <code>publish</code> 함수를 호출하여 메시지를 발행한다.29</li>
<li><strong>main 함수</strong>: ROS2 Python 노드의 표준적인 초기화, 실행(spin), 종료 코드로 구성된다.27</li>
</ul>
<h2>6. 조립 및 실행</h2>
<p>모든 구성 파일이 준비되었으므로, 패키지를 빌드하고 시뮬레이션을 실행한다.</p>
<h3>6.1 ROS2 패키지 최종 설정</h3>
<ol>
<li>package.xml 설정:</li>
</ol>
<p>패키지의 의존성을 명시한다. rclpy, std_msgs와 ros2_control 관련 패키지들을 추가한다.</p>
<pre><code class="language-XML">&lt;?xml version="1.0"?&gt;
&lt;package format="3"&gt;
  &lt;name&gt;simple_velocity_robot&lt;/name&gt;
  &lt;version&gt;0.0.0&lt;/version&gt;
  &lt;description&gt;Example of continuous actuator rotation with ros2_control and Gazebo&lt;/description&gt;
  &lt;maintainer email="user@todo.todo"&gt;user&lt;/maintainer&gt;
  &lt;license&gt;Apache-2.0&lt;/license&gt;

  &lt;buildtool_depend&gt;ament_python&lt;/buildtool_depend&gt;

  &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros2_control&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros2_controllers&lt;/exec_depend&gt;
  &lt;exec_depend&gt;gz_ros2_control&lt;/exec_depend&gt;
  &lt;exec_depend&gt;robot_state_publisher&lt;/exec_depend&gt;
  &lt;exec_depend&gt;ros_gz_sim&lt;/exec_depend&gt;

  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;
  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;
&lt;/package&gt;
</code></pre>
<ol start="2">
<li>setup.py 설정:</li>
</ol>
<p>Python 노드를 실행 파일로 등록하기 위해 entry_points를 설정한다.</p>
<pre><code class="language-Python">from setuptools import find_packages, setup
import os
from glob import glob

package_name = 'simple_velocity_robot'

setup(
    name=package_name,
    version='0.0.0',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'urdf'), glob('urdf/*')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='user',
    maintainer_email='user@todo.todo',
    description='Example of continuous actuator rotation with ros2_control and Gazebo',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'velocity_publisher = simple_velocity_robot.velocity_publisher:main',
        ],
    },
)
</code></pre>
<h3>6.2 시뮬레이션 빌드 및 실행</h3>
<ol>
<li>워크스페이스 빌드:</li>
</ol>
<p>ros2_ws 디렉토리로 이동하여 colcon으로 패키지를 빌드한다.</p>
<pre><code class="language-Bash">cd ~/ros2_ws
colcon build --symlink-install --packages-select simple_velocity_robot
</code></pre>
<ol start="2">
<li>워크스페이스 소싱:</li>
</ol>
<p>빌드된 패키지를 현재 터미널 환경에 등록한다.</p>
<pre><code class="language-Bash">source install/setup.bash
</code></pre>
<ol start="3">
<li>시뮬레이션 실행:</li>
</ol>
<p>작성한 런치 파일을 실행하여 Gazebo와 ros2_control 시스템을 시작한다.</p>
<pre><code class="language-Bash">ros2 launch simple_velocity_robot robot_launch.py
</code></pre>
<p>Gazebo 창이 열리고, 로봇 모델이 스폰되는 것을 확인할 수 있다.</p>
<ol start="4">
<li>명령 퍼블리셔 실행:</li>
</ol>
<p>별도의 터미널을 열고 워크스페이스를 소싱한 후, 속도 명령 퍼블리셔 노드를 실행한다.</p>
<pre><code class="language-Bash">source ~/ros2_ws/install/setup.bash
ros2 run simple_velocity_robot velocity_publisher
</code></pre>
<p>이제 Gazebo 시뮬레이션에서 로봇의 <code>rotating_link</code>가 일정한 속도로 회전하기 시작한다.</p>
<h3>6.3 검증 및 내부 상태 확인</h3>
<p>시스템이 올바르게 동작하는지 확인하기 위해 <code>ros2 control</code> 및 <code>ros2 topic</code> CLI 도구를 사용한다.</p>
<ul>
<li>
<p><strong>컨트롤러 상태 확인</strong>:</p>
<pre><code class="language-Bash">ros2 control list_controllers
</code></pre>
</li>
</ul>
<pre><code>
`joint_state_broadcaster`와 `velocity_controller`가 모두 `active` 상태로 표시되어야 한다.16

- **하드웨어 인터페이스 상태 확인**:

  ```Bash
  ros2 control list_hardware_interfaces
</code></pre>
<p><code>revolute_joint</code>의 <code>velocity</code> 명령 인터페이스가 <code>[claimed]</code> 상태로 표시되어 <code>velocity_controller</code>에 의해 점유되었음을 확인해야 한다.16</p>
<ul>
<li>
<p><strong>관절 상태 토픽 확인</strong>:</p>
<pre><code class="language-Bash">ros2 topic echo /joint_states
</code></pre>
</li>
</ul>
<pre><code>
`position` 값이 지속적으로 증가(또는 감소)하는 것을 통해 관절이 실제로 회전하고 있음을 확인할 수 있다.

## 7. 이론적 토대 및 심층 분석


이 간단한 예제는 `ros2_control`과 Gazebo의 상호작용에 대한 중요한 이론적 개념을 내포하고 있다.

### 7.1 `ros2_control` 실시간 루프


컨트롤러 매니저는 `update_rate`에 맞춰 주기적으로 실시간 제어 루프를 실행한다. 이 루프는 세 단계로 구성된다.2

1. **`read()`**: `gz_ros2_control` 플러그인이 Gazebo의 물리 엔진으로부터 현재 관절 상태(위치, 속도)를 읽어와 `ros2_control`의 상태 인터페이스를 갱신한다.
2. **`update()`**: 활성화된 모든 컨트롤러의 `update()` 함수가 호출된다. 이 예제에서 `velocity_controller`는 `/velocity_controller/commands` 토픽에서 수신한 최신 명령값을 자신의 출력으로 설정한다.
3. **`write()`**: `gz_ros2_control` 플러그인이 컨트롤러의 출력(명령 인터페이스의 값)을 읽어와 Gazebo의 관절에 적용한다.

### 7.2 숨겨진 제어 법칙: 시뮬레이션 내부의 PID


여기서 한 가지 중요한 질문이 생긴다. 우리는 `velocity` (rad/s)를 명령했지만, 물리 시뮬레이터인 Gazebo는 실제로 관절에 `force`나 `torque`를 가해야 움직임을 만들어낼 수 있다. 그렇다면 속도 명령은 어떻게 토크로 변환되는가?

그 해답은 `gz_ros2_control` 플러그인 내부에 숨겨진 PID(Proportional-Integral-Derivative) 제어기에 있다.11 사용자가 속도, 위치 등 상위 레벨의 명령을 내리면, Gazebo 플러그인은 내부적으로 이 목표값을 달성하기 위한 저수준의 힘/토크를 계산한다.

이 과정은 다음과 같다.

1. 사용자가 `velocity_controller`를 통해 목표 속도(q˙desired)를 명령한다.

2. `gz_ros2_control` 플러그인은 `read()` 단계에서 Gazebo 물리 엔진으로부터 현재 실제 속도(q˙actual)를 측정한다.

3. 플러그인은 목표 속도와 실제 속도 간의 오차 `$e(t) = \dot{q}_{desired}(t) - \dot{q}_{actual}(t)$`를 계산한다.

4. 내장된 PID 제어기는 이 오차를 기반으로 관절에 적용할 토크 `$u(t)$`를 다음의 표준적인 PID 제어 법칙에 따라 계산한다.
   $$
   u(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt}
$$
계산된 토크 `$u(t)$`가 `write()` 단계에서 Gazebo의 관절에 최종적으로 적용된다.

여기서 `$K_p$`, `$K_i$`, `$K_d$`는 각각 비례, 적분, 미분 이득(gain)으로, 플러그인 내부에 기본값이 설정되어 있다. 이처럼 `ros2_control`과 Gazebo 시뮬레이션의 조합은 사용자가 고수준의 제어(속도 제어)에 집중할 수 있도록 저수준의 동역학 제어(토크 제어)를 추상화하여 제공한다. 이는 시뮬레이션 환경을 실제 하드웨어와 유사하게 만들어주며, 제어기 개발 및 테스트를 매우 효율적으로 만들어주는 핵심적인 기능이다.

## 8. 참고 자료


1. velocity_controllers - ROS2_Control: Rolling Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/rolling/doc/ros2_controllers/velocity_controllers/doc/userdoc.html
2. Getting Started - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/getting_started/getting_started.html
3. Getting Started - ROS2_Control: Foxy Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/foxy/doc/getting_started/getting_started.html
4. gz_ros2_control - ROS2_Control: Rolling Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/rolling/doc/gz_ros2_control/doc/index.html
5. gz_ros2_control - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/gz_ros2_control/doc/index.html
6. ros2_control Concepts &amp; Simulation - Articulated Robotics, accessed July 27, 2025, https://articulatedrobotics.xyz/tutorials/mobile-robot/applications/ros2_control-concepts/
7. Installing Gazebo with ROS - Gazebo ionic documentation, accessed July 27, 2025, https://gazebosim.org/docs/latest/ros_installation/
8. Welcome to the ros2_control documentation - Humble!, accessed July 27, 2025, https://control.ros.org/humble/index.html
9. Welcome to the ros2_control documentation! - ROS2_Control: Rolling Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/
10. ros-controls/gazebo_ros2_control: Wrappers, tools and additional API's for using ros2_control with Gazebo Classic - GitHub, accessed July 27, 2025, https://github.com/ros-controls/gazebo_ros2_control
11. gazebo_ros2_control - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/gazebo_ros2_control/doc/index.html
12. Demos - ROS2_Control: Rolling Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/rolling/doc/ros2_control_demos/doc/index.html
13. Example 7: Full tutorial with a 6DOF robot - ROS2_Control, accessed July 27, 2025, https://control.ros.org/rolling/doc/ros2_control_demos/example_7/doc/userdoc.html
14. Using a URDF in Gazebo - ROS 2 Documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/Using-a-URDF-in-Gazebo.html
15. Controller Manager - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/ros2_control/controller_manager/doc/userdoc.html
16. Example 3: Robots with multiple interfaces - ROS2_Control: Rolling Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/rolling/doc/ros2_control_demos/example_3/doc/userdoc.html
17. Example 9: Simulation with RRBot - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/ros2_control_demos/example_9/doc/userdoc.html
18. forward_command_controller - ROS2_Control: Humble Jul 2025 ..., accessed July 27, 2025, https://control.ros.org/humble/doc/ros2_controllers/forward_command_controller/doc/userdoc.html
19. velocity_controllers - ROS2_Control: Humble Jul 2025 documentation, accessed July 27, 2025, https://control.ros.org/humble/doc/ros2_controllers/velocity_controllers/doc/userdoc.html
20. ros2_control extra bits - Articulated Robotics, accessed July 27, 2025, https://articulatedrobotics.xyz/tutorials/mobile-robot/applications/ros2_control-extra/
21. Tutorial: How to Spawn a Robot in a Custom Gazebo World using ROS2 Humble - Medium, accessed July 27, 2025, https://medium.com/@ayaan.cdry/tutorial-how-to-spawn-a-robot-in-a-custom-gazebo-world-using-ros2-humble-e4a2f3c6e95b
22. Spawn a Gazebo model from ROS 2, accessed July 27, 2025, https://gazebosim.org/docs/latest/ros2_spawn_model/
23. Launch Gazebo from ROS 2, accessed July 27, 2025, https://gazebosim.org/docs/latest/ros2_launch_gazebo/
24. rrbot.launch.py - ros-controls/ros2_control_demos - GitHub, accessed July 27, 2025, https://github.com/ros-controls/ros2_control_demos/blob/master/example_1/bringup/launch/rrbot.launch.py
25. std_msgs/msg/Float64MultiArray Message - ROS Documentation, accessed July 27, 2025, https://docs.ros2.org/foxy/api/std_msgs/msg/Float64MultiArray.html
26. Float64MultiArray - std_msgs: Humble 4.9.0 documentation - ROS 2, accessed July 27, 2025, https://docs.ros.org/en/humble/p/std_msgs/msg/Float64MultiArray.html
27. Writing a simple publisher and subscriber (Python) - ROS 2 Documentation, accessed July 27, 2025, https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html
28. ROS2 Python Publisher Example - The Robotics Back-End, accessed July 27, 2025, https://roboticsbackend.com/ros2-python-publisher-example/
29. ROS publishing array from python node - Stack Overflow, accessed July 27, 2025, https://stackoverflow.com/questions/31369934/ros-publishing-array-from-python-node
30. How To Write a ROS2 Publisher and Subscriber (Python) – Foxy, accessed July 27, 2025, https://automaticaddison.com/how-to-write-a-ros2-publisher-and-subscriber-python-foxy/
31. ros2_control_demos/example_2/doc/userdoc.rst at master / ros-controls ... - GitHub, accessed July 27, 2025, https://github.com/ros-controls/ros2_control_demos/blob/master/example_2/doc/userdoc.rst
32. Example 7: Full tutorial with a 6DOF robot - ROS2_Control, accessed July 27, 2025, https://control.ros.org/humble/doc/ros2_control_demos/example_7/doc/userdoc.html
33. Tutorial : ROS control - Gazebo Classic, accessed July 27, 2025, https://classic.gazebosim.org/tutorials?tut=ros_control
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>