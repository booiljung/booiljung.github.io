<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Cruise Webviz</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Cruise Webviz</h1>
                    <nav class="breadcrumbs"><a href="../index.html">Home</a> / <a href="index.html">ROS2 (Robot Operating System 2)</a> / <span>Cruise Webviz</span></nav>
                </div>
            </header>
            <article>
                <h1>Cruise Webviz</h1>
<h2>1.  소개</h2>
<p>이 안내서는 자율주행 기술 기업 Cruise가 개발한 오픈소스 로봇 데이터 시각화 도구 Webviz에 대한 종합적인 분석을 다루었다. Webviz는 기존의 복잡하고 비효율적인 데스크탑 기반 도구들(<code>RViz</code>, <code>rqt</code>)의 한계를 극복하고, 로봇 데이터 시각화의 패러다임을 웹 기반으로 전환한 선구적인 역할을 수행하였다. 본 분석은 Webviz가 로봇 공학 워크플로우에 가져온 혁신적 가치를 조명하는 데 중점을 두었다.</p>
<p>또한, Webviz의 포크(fork) 프로젝트인 Foxglove의 등장과 성장을 함께 탐구함으로써, 오픈소스 프로젝트가 기술적 진화를 거치며 상업적 플랫폼으로 발전해 가는 과정을 심층적으로 분석하였다. 이 안내서는 Webviz의 기술적 의의와 시장 내 위상을 종합적으로 평가하여, 로봇 공학자, 엔지니어, 그리고 관련 산업 종사자들에게 실질적인 통찰을 제공하고자 한다.</p>
<h2>2.  Webviz의 태동과 기술적 가치</h2>
<h3>2.1  개발 배경: 기존 로봇 시각화 도구의 한계와 Webviz의 탄생</h3>
<p>Webviz의 개발은 Cruise 내부 해커톤 프로젝트에서 시작되었다.1 이는 당시 로봇 공학자들이 당면했던 핵심적인 비효율성을 해소하기 위함이었다. 기존의 ROS(Robot Operating System) 커뮤니티에서 사용되던 시각화 도구들은 강력한 기능을 제공하였으나, 특정 플랫폼에 완전한 개발 환경을 구축해야만 사용할 수 있었다.2 예를 들어, 엔지니어들은 로그 메시지를 확인하고, 그래프를 그리며, 카메라 이미지를 보는 등 다양한 작업을 위해 여러 개의 창을 수동으로 배열해야만 했다.2 더욱이, 개인이 구축한 맞춤형 시각화 설정을 팀 동료와 공유하고 복제하는 과정은 상당한 시간을 소모하는 작업이었다.2</p>
<p>이러한 개발 배경은 Webviz가 단순히 기능적 개선을 넘어, 로봇 공학 워크플로우의 근본적인 문제점을 해결하려 했다는 점을 시사한다. 기존 도구들의 한계는 기능 자체의 부족이 아니라, 사용자 경험(UX)과 휴대성(Portability)의 부재에 있었다. Webviz는 이처럼 파편화된 도구들을 단일 웹 기반 애플리케이션으로 통합함으로써, 복잡한 설치나 환경 설정 과정 없이 브라우저를 통해 즉시 데이터를 탐색할 수 있는 획기적인 접근성을 제공하였다.3 이는 자율주행 기술 개발팀의 협업 효율을 대폭 향상하고, 궁극적으로 Cruise의 자율주행 차량 개발을 가속화하는 핵심 동력이 되었다.1</p>
<h3>2.2  Webviz의 핵심 기능 및 장점</h3>
<p>Webviz의 핵심 강점은 웹 브라우저를 통해 로봇 데이터를 시각화하는 데 있다.3 이 도구는 <code>ROS bag</code> 파일의 재생을 지원할 뿐만 아니라, <code>rosbridge_server</code>를 통해 실시간 로봇 데이터와도 연결된다.4 특히, Webviz는 사용자가 3D 시각화, 플롯, 이미지 디스플레이 등 다양한 패널을 사용하여 자신만의 레이아웃을 구성할 수 있는 모듈형 구조를 채택하였다.3</p>
<p>이러한 모듈형 구조는 단순히 UI를 맞춤화하는 것을 넘어, 도구의 범용성을 크게 확장하였다. 예를 들어, 자율주행 분야와는 무관한 에너지 기업 Equinor는 지질학 데이터 분석에 Webviz를 활용하여 연간 30,000시간에 달하는 수작업을 자동화하였다.6 이는 Webviz가 특정 목적의 도구가 아닌, 다양한 산업 분야의 대량 데이터를 시각화하고 분석할 수 있는 범용적인 프레임워크로서의 잠재력을 가졌음을 의미한다. Webviz의 모듈형 아키텍처는 Cruise와 Equinor 같은 이질적인 도메인의 요구사항에 유연하게 대응함으로써, 데이터 분석 워크플로우의 효율성을 획기적으로 개선하는 데 기여하였다.</p>
<h3>2.3  기술 스택 및 아키텍처 분석</h3>
<p>Webviz의 프런트엔드 개발은 주로 <code>JavaScript</code> (96.6%)와 <code>TypeScript</code> (1.4%)를 기반으로 하였다.5 3D 렌더링을 위해 <code>regl-worldview</code>라는 <code>React</code> 라이브러리를 사용하며, 이는 <code>regl</code> 기반으로 2D 및 3D 장면을 렌더링한다.5</p>
<p><code>regl</code>은 <code>WebGL</code>의 프로그래밍 복잡성을 간소화하는 <code>함수형 추상화(functional abstraction)</code> 라이브러리이다.8 일반적인 <code>WebGL</code> 코딩은 공유 상태(shared state) 관리 문제로 인해 복잡성이 높아지는 경향이 있다.10 그러나 <code>regl</code>은 이러한 공유 상태를 제거하여 프로그래밍을 간소화하며, <code>React</code>에서 영감을 받은 <code>함수형 데이터 중심 스타일</code>을 채택하였다.8</p>
<p>이러한 기술 선택은 단순히 성능 향상을 위한 것이 아니었다. Webviz의 핵심 가치는 모듈형 패널을 통해 사용자 맞춤형 레이아웃을 제공하는 데 있었다. 각 패널은 독립적인 컴포넌트처럼 작동해야 하며, <code>regl</code>의 상태 비공유 특성과 <code>React</code>의 컴포넌트 기반 접근법은 이 요구사항을 완벽하게 충족하였다. <code>regl-worldview</code>는 이 둘을 결합하여, 개발자들이 복잡한 3D 렌더링 로직이나 상태 관리에 몰두하는 대신, 포인트 클라우드나 마커 같은 3D 요소를 선언적으로 정의하고 렌더링하는 것을 가능하게 하였다. 이는 Webviz가 기술적 혁신을 통해 로봇 데이터 시각화의 사용자 경험을 근본적으로 개선한 중요한 사례로 평가된다.</p>
<p>Webviz의 배포 및 개발 환경은 <code>docker-compose</code>를 통해 프런트엔드와 백엔드를 함께 구성하는 방식으로 효율성을 높였다.12 이 구조는 개발자들이 손쉽게 환경을 구축하고 코드를 수정할 수 있게 하였다.</p>
<h2>3.  로봇 데이터 시각화 시장 분석: Webviz의 위상</h2>
<h3>3.1  Webviz와 RViz 및 <code>rqt</code>의 비교 분석</h3>
<p>Webviz가 등장하기 전, ROS 커뮤니티에서 가장 보편적으로 사용되던 시각화 도구는 <code>RViz</code>와 <code>rqt</code>였다.13</p>
<p><code>RViz</code>는 주로 3D 데이터 시각화에 특화된 도구이며, <code>rqt</code>는 다양한 플러그인을 통해 로봇의 상태를 모니터링하고 데이터를 플로팅하는 데 사용되었다.14</p>
<p>Webviz의 등장은 이 두 도구의 파편화된 사용성을 해결하는 전환점이었다. Webviz는 3D 시각화, 플롯, 이미지 디스플레이 등 여러 기능을 하나의 통합된 웹 환경으로 가져왔다.3 이로써 엔지니어들은 여러 창을 오가며 작업하는 번거로움(<code>context switching</code>)을 없애고, 모든 시각화 작업을 단일한 환경에서 수행할 수 있게 되었다. Webviz는 기능적인 측면에서 <code>RViz</code>와 유사한 시각화 기능을 제공하였으나, <code>더 뛰어난 휴대성</code>과 <code>통합된 워크플로우</code>를 통해 개발 생산성을 획기적으로 향상하였다.3 이러한 변화는 특히 팀 단위의 협업 환경에서 큰 이점을 제공하는 근본적인 혁신으로 작용하였다.</p>
<h3>3.2  Webviz와 Foxglove의 심층 비교</h3>
<p>Webviz의 가장 중요한 유산은 후계자인 Foxglove Studio의 탄생에 있다. Foxglove는 전직 Cruise 직원들이 시작한 <code>Webviz의 포크(fork)</code> 프로젝트로서, 초기에는 두 도구의 외관이 유사하였으나, 현재는 그 기능과 전략적 방향에서 상당한 차이를 보였다.3</p>
<p>가장 큰 차이점은 지원 및 비즈니스 모델에 있다. Cruise는 Webviz에 대한 상업적 지원을 제공하지 않으며, 커뮤니티 지원은 임시적(ad-hoc)이다.5 반면 Foxglove는 상용 플랫폼으로 발전하며 기업에 유료 플랜을 제공하고, 전문적인 기술 지원을 보장한다.3</p>
<p>또한, 지원하는 데이터 포맷의 범위에서도 차이가 뚜렷하다. Webviz는 <code>ROS bag</code> 파일과 <code>rosbridge</code>를 통한 실시간 ROS 데이터에 의존한다.3 이와 달리 Foxglove는 <code>MCAP</code>, <code>ROS 2</code>, <code>Protobuf</code>, <code>JSON</code> 등 훨씬 더 다양한 데이터 포맷을 지원하여 로봇 공학 생태계 전반을 포괄하는 범용성을 확보하였다.3</p>
<p>기능적인 측면에서, Foxglove는 Webviz에는 없는 <code>협업 기능</code>을 대폭 강화하였다. Foxglove는 팀원 간에 공유 가능한 레이아웃과 중앙 데이터 저장소 기능을 제공하며 3, <code>Foxglove Agent</code>를 통해 실시간 또는 온디맨드(on-demand) 데이터 수집 및 관리 기능을 지원한다.3 이는 Webviz가 개인 개발자나 소규모 프로젝트에 적합한 도구였다면, Foxglove는 팀 기반 협업과 대규모 데이터 관리를 위한 상용 플랫폼으로 진화하였음을 보여준다.</p>
<p>이러한 기능적, 전략적 차이는 오픈소스 포크 프로젝트가 단순히 기존 도구의 기능을 확장하는 것을 넘어, 원본 프로젝트가 해결하지 못한 상업적, 전략적 기회를 포착하여 시장의 사실상의 표준(de-facto standard)으로 자리 잡는 전형적인 사례를 보여주었다. Webviz의 유산적 가치는 인정되나, 현대적 로봇 개발 환경의 요구사항인 규모, 협업, 데이터 관리를 충족하기에는 역부족이라 판단된다.</p>
<p>다음 표는 주요 웹 기반 로봇 데이터 시각화 도구들의 특징을 비교하였다.</p>
<table><thead><tr><th>구분</th><th>Webviz</th><th>Foxglove</th><th>Rerun</th><th>ros3d.js</th></tr></thead><tbody>
<tr><td><strong>개발 주체</strong></td><td>Cruise</td><td>Foxglove (Webviz의 포크)</td><td>Rerun Robotics</td><td>Robot Web Tools</td></tr>
<tr><td><strong>상업적 지원</strong></td><td>없음</td><td>유료 플랜 및 전문 지원</td><td>없음 (오픈소스)</td><td>없음 (유지보수 중단)</td></tr>
<tr><td><strong>주요 지원데이터 포맷</strong></td><td>ROS bag, ROS 1 live</td><td>MCAP, ROS 1/2, Protobuf, JSON 등</td><td>Rust/Python SDKs,.rrd 파일</td><td>ROS 1</td></tr>
<tr><td><strong>협업 기능</strong></td><td>미흡</td><td>공유 가능한 레이아웃, 중앙 데이터 저장소, 데이터 관리</td><td>파일 공유, <code>Recording ID</code> 기반 스트리밍</td><td>미흡</td></tr>
<tr><td><strong>플랫폼 호환성</strong></td><td>웹</td><td>웹, 데스크탑 앱</td><td>웹, 데스크탑 앱</td><td>웹</td></tr>
<tr><td><strong>현재 위상</strong></td><td><strong>기술적 유산</strong>(활발한 개발 중단)</td><td><strong>주요 산업 표준</strong>(활발한 개발 및 지원)</td><td><strong>차세대 대안</strong>(로그 중심 접근법)</td><td><strong>역사적 선구자</strong>(유지보수 중단)</td></tr>
</tbody></table>
<h3>3.3  기타 웹 기반 시각화 도구와의 간략 비교 (Rerun, <code>ros3d.js</code> 등)</h3>
<p>Webviz의 성공은 이전 세대 도구의 한계를 극복한 데서 기인하였다. <code>ros3d.js</code>는 Webviz 이전에 존재했던 초기 웹 기반 ROS 1 시각화 라이브러리였으나, 현재는 유지보수가 중단되었고 <code>ROS 2</code>와 호환되지 않는다.16 Webviz는 <code>ros3d.js</code>의 한계를 극복하고 등장한 차세대 웹 기반 도구였다.</p>
<p>한편, Rerun은 Webviz/Foxglove와는 다른 독특한 접근법을 취하는 현대적 대안이다.16</p>
<p><code>Rust</code> 또는 <code>Python</code> 기반의 로깅 SDK를 통해 데이터를 수집하고 시각화하며, 녹화된 데이터의 타임라인 제어에 강점을 가진다.16 이는 <code>ROS bag</code> 파일을 재생하는 Webviz/Foxglove의 워크플로우와 근본적으로 다른 방식이다. 이러한 비교는 Webviz의 기술적 의의가 단순히 웹으로의 전환에 그치지 않고, 복잡한 ROS 생태계의 데이터 포맷을 브라우저에 통합한 데 있음을 다시금 확인시켜준다.</p>
<h2>4.  Webviz의 현재 상황과 전략적 평가</h2>
<h3>4.1  오픈소스 프로젝트로서의 현주소</h3>
<p>Webviz는 여전히 Cruise의 GitHub 저장소에서 오픈소스 프로젝트로 유지되고 있으나, 그 위상은 과거와 같지 않다. Cruise는 현재 Webviz에 대한 상업적 지원을 공식적으로 제공하지 않으며, 커뮤니티 지원 또한 임시적(ad-hoc)이다.5 이러한 지원 부재는 Webviz의 기술적 발전이 정체되는 주요 원인으로 작용하였다.</p>
<h3>4.2  Webviz의 주요 한계점: 지원, 확장성, 팀 협업</h3>
<p>Webviz는 협업 워크플로우나 디버깅 설정 공유를 위한 내장 기능이 부족하다.3 또한, 데이터 관리 기능이 전무하며, 데이터 수집 및 수집(ingestion) 기능도 ROS 생태계에 대한 의존성이 높다.3 이는 Webviz가 개인 개발자의 워크플로우 최적화에는 효과적이었으나, 대규모 데이터를 다루는 기업 환경의 복잡한 요구사항을 충족하기에는 한계가 있었음을 보여준다.</p>
<h3>4.3  결론 및 종합 평가</h3>
<p>Webviz는 로봇 데이터 시각화 분야의 혁신적인 선구자였다. 그러나 기업의 상업적 지원 부재와 오픈소스 커뮤니티의 비정기적 지원으로 인해 기술적 발전이 멈췄다. 이로 인해 Webviz는 현대 로봇 개발 환경의 요구사항인 규모, 협업, 관리 효율성을 충족하지 못하게 되었다.</p>
<p>이러한 공백을 정확히 파고든 것이 Webviz의 포크인 Foxglove였다. Foxglove는 Webviz의 유산적 가치를 계승하면서, 기업 환경의 요구에 맞춰 협업 기능, 다양한 데이터 포맷 지원, 그리고 전문적인 기술 지원을 추가하여 시장의 주도권을 가져갔다. 따라서 Webviz는 현재 활발히 사용되는 도구라기보다는, 로봇 데이터 시각화의 웹 기반 혁명을 촉발한 중요한 역사적 유물이자 기술적 유산의 가치를 갖는다.</p>
<h2>5.  결론 및 제언</h2>
<h3>5.1  주요 분석 결과 요약</h3>
<p>Webviz의 탄생은 로봇 공학 워크플로우의 비효율성을 해소한 패러다임 전환이었다. Webviz의 기술 스택은 <code>React</code>와 <code>WebGL</code>의 혁신적인 결합을 통해 복잡한 로봇 데이터를 웹에서 시각화할 수 있다는 가능성을 증명하였다. 그러나 상업적 지원 부재와 협업 및 데이터 관리 기능의 한계로 인해 기술 발전이 정체되었다. Webviz의 가장 중요한 유산은 그 한계를 극복하고 더욱 강력한 후계자인 Foxglove를 탄생시킨 데 있다.</p>
<h3>5.2  최종 제언: Webviz의 유산과 현대적 대안의 선택</h3>
<p>개인 개발자나 소규모 프로젝트에서 ROS bag 파일을 빠르게 탐색하고자 할 때, Webviz는 여전히 유용하고 가치 있는 오픈소스 도구이다. 이는 복잡한 설치 과정 없이도 직관적인 시각화 기능을 제공하기 때문이다.</p>
<p>그러나 전문적인 로봇 개발 팀이 대규모 데이터 관리, 효율적인 팀 협업, 그리고 최신 데이터 포맷(ROS 2 등) 지원을 필요로 할 경우, Webviz의 후계자인 Foxglove 또는 Rerun과 같은 현대적이고 확장성 있는 대안을 선택하는 것이 필수적이다. 이들 도구는 현대 로봇 개발의 복잡하고 방대한 요구사항을 충족하기 위해 설계된 플랫폼으로서, 궁극적으로 개발 생산성과 팀 효율성을 극대화하는 데 기여할 것이다. Webviz는 기술 역사의 중요한 이정표로서, 앞으로도 많은 개발자에게 영감을 줄 것이라 판단한다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>Using Cruise’s Webviz Tool to Visualize Autonomous RC Car System Data - Wil Selby, https://wilselby.com/2020/02/using-cruises-webviz-tool-to-visualize-autonomous-rc-car-system-data/</li>
<li>Webviz: An Open Source Platform for Robotics Data Visualization …, https://medium.com/cruise/webviz-fb5f77ebe52b</li>
<li>Foxglove vs. Webviz., https://foxglove.dev/blog/foxglove-vs-webviz</li>
<li>webviz, https://webviz.io/</li>
<li>cruise-automation/webviz: web-based visualization libraries - GitHub, https://github.com/cruise-automation/webviz</li>
<li>Webviz - web-based visualization - Ceetron Solutions, https://www.ceetronsolutions.com/projects/webviz-web-based-visualization</li>
<li>Worldview - webviz, https://webviz.io/worldview/</li>
<li>Regl, https://regl-project.github.io/</li>
<li>regl-project/regl: Functional WebGL - GitHub, https://github.com/regl-project/regl</li>
<li>regl | Functional WebGL, https://regl-project.github.io/regl/</li>
<li>github.com, <a href="https://github.com/regl-project/regl#:~:text=regl%20simplifies%20WebGL%20programming%20by,a%20texture%2C%20FBO%20or%20buffer.">https://github.com/regl-project/regl#:~:text=regl%20simplifies%20WebGL%20programming%20by,a%20texture%2C%20FBO%20or%20buffer.</a></li>
<li>equinor/webviz - GitHub, https://github.com/equinor/webviz</li>
<li>www.infoq.com, <a href="https://www.infoq.com/news/2019/11/webviz-ros-jupyter/#:~:text=Rviz%20is%20a%20well-used,RViz%2C%20but%20with%20greater%20portability.">https://www.infoq.com/news/2019/11/webviz-ros-jupyter/#:~:text=Rviz%20is%20a%20well%2Dused,RViz%2C%20but%20with%20greater%20portability.</a></li>
<li>Foxglove Studio vs. RViz - Medium, https://medium.com/@esthersweon/foxglove-studio-vs-rviz-8d83b87bc20f</li>
<li>ROS 기반 사용자 인터페이스 개발 및 통합 - wntdev - 티스토리, https://wntdev.tistory.com/203</li>
<li>Comparing Robotics Visualization Tools: RViz, Foxglove, Rerun | ReductStore, https://www.reduct.store/blog/comparison-rviz-foxglove-rerun</li>
<li>Rerun visualization - Wandelbots NOVA, https://docs.wandelbots.io/25.6/developing-python/rerun</li>
<li>Exploring Rerun — An Open-Source Logging and Visualization Tool_Derek | by Turing Inc., https://medium.com/@turingmotors/7-exploring-rerun-an-open-source-logging-and-visualization-tool-derek-4667015dc965</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>