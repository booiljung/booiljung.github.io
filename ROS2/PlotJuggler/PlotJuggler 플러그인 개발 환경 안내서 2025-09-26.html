<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:PlotJuggler 플러그인 개발 환경 안내서 (2025-09-26)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>PlotJuggler 플러그인 개발 환경 안내서 (2025-09-26)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">ROS2 (Robot Operating System 2)</a> / <a href="index.html">PlotJuggler</a> / <span>PlotJuggler 플러그인 개발 환경 안내서 (2025-09-26)</span></nav>
                </div>
            </header>
            <article>
                <h1>PlotJuggler 플러그인 개발 환경 안내서 (2025-09-26)</h1>
<h2>1. 서문</h2>
<p>이 문서는 PlotJuggler의 강력한 플러그인 아키텍처를 활용하여 자신만의 데이터 로더 및 스트리머를 개발하고자 하는 C++ 개발자를 위한 포괄적인 기술 안내서이다. 개발 환경 설정부터 소스 코드 빌드, 통합 개발 환경(IDE) 구성, 그리고 가장 중요한 디버깅 워크플로우까지 전 과정을 상세히 다룬다. 이 안내서의 목표는 단순히 흩어져 있는 정보들을 취합하는 것을 넘어, 실제 개발 현장에서 마주할 수 있는 문제들과 그 해결책, 그리고 효율적인 개발을 위한 모범 사례를 제시하는 데 중점을 둔다. 본 문서는 C++ 및 CMake에 대한 기본적인 이해를 갖춘 개발자를 대상으로 하며, ROS(Robot Operating System) 환경에서의 개발 경험은 도움이 되지만 필수적이지는 않다.</p>
<h2>2.  PlotJuggler 플러그인 아키텍처 개요</h2>
<h3>2.1  PlotJuggler의 확장성과 플러그인의 역할</h3>
<p>PlotJuggler는 시계열 데이터 시각화를 위한 빠르고 직관적인 도구로, 그 핵심적인 강력함은 플러그인 기반의 확장 가능한 아키텍처에서 비롯된다.1 이 아키텍처는 PlotJuggler의 핵심 기능은 가볍고 안정적으로 유지하면서, 플러그인을 통해 거의 모든 종류의 데이터 소스, 통신 프로토콜, 파일 형식을 지원할 수 있도록 설계되었다.2 사용자는 자신의 특정 요구사항에 맞는 기능을 직접 C++로 구현하여 애플리케이션에 통합할 수 있다.2</p>
<p>플러그인은 동적으로 로드되는 공유 라이브러리(Linux에서는 <code>.so</code>, Windows에서는 <code>.dll</code>, macOS에서는 <code>.dylib</code>) 형태로 존재한다. 이들은 PlotJuggler가 시작될 때 지정된 폴더에서 검색되어 로드된다. 이러한 동적 로딩 방식은 사용자가 새로운 데이터 형식을 지원하기 위해 PlotJuggler 핵심 애플리케이션 전체를 재컴파일할 필요 없이, 해당 플러그인만 빌드하여 추가하면 되므로 개발 및 배포 과정을 매우 효율적으로 만든다.</p>
<p>이러한 구조는 디버깅 전략에도 직접적인 영향을 미친다. 플러그인은 독립적으로 실행될 수 있는 프로그램이 아니라, PlotJuggler라는 호스트 애플리케이션의 주소 공간 내에서 실행된다. 따라서 플러그인 코드를 디버깅하기 위해서는 먼저 PlotJuggler를 실행한 후, 실행 중인 해당 프로세스에 디버거를 “연결(attach)“하는 방식이 필수적이다. 이 “Attach to Process” 기법은 본 안내서의 후반부에서 심도 있게 다룰 핵심적인 디버깅 워크플로우이다.4</p>
<h3>2.2  플러그인 유형</h3>
<p>PlotJuggler는 기능에 따라 세 가지 주요 플러그인 유형을 정의한다.6</p>
<ul>
<li>
<p><strong>DataLoaders</strong>: 파일에 저장된 정적(static) 데이터를 로드하는 데 사용된다. 사용자가 “File &gt; Open” 메뉴를 통해 특정 파일을 선택하면, PlotJuggler는 해당 파일의 확장자를 인식하고 그에 맞는 DataLoader 플러그인을 활성화하여 데이터를 읽어들인다. 대표적인 예로는 CSV 파일 로더, PX4 비행 로그 형식인 ULog 로더, 그리고 ROS 생태계에서 널리 사용되는 Rosbag 파일 로더가 있다.7</p>
</li>
<li>
<p><strong>DataStreamers</strong>: 실시간으로 연속적인 데이터를 수신하여 플로팅하는 데 사용된다. 네트워크를 통해 데이터를 스트리밍하는 대부분의 시나리오가 여기에 해당한다. 사용자가 “Streaming” 메뉴에서 특정 프로토콜을 선택하고 연결 설정을 마치면, 해당 DataStreamer 플러그인이 백그라운드 스레드에서 데이터를 수신하기 시작한다. MQTT, ZeroMQ, WebSockets, UDP와 같은 표준 프로토콜뿐만 아니라, ROS1 토픽 구독 및 ROS2 토픽 구독 기능도 DataStreamer 플러그인을 통해 구현된다.7</p>
</li>
<li>
<p><strong>StatePublishers</strong>: PlotJuggler 내부에 로드되거나 스트리밍 중인 데이터를 외부의 다른 애플리케이션으로 재발행(re-publish)하는 기능을 제공한다. 예를 들어, Rosbag 파일을 열어 특정 토픽을 시각화하면서 동시에 해당 데이터를 다시 ROS 네트워크로 발행하여 RViz와 같은 다른 ROS 도구에서 시각화하거나 로봇 시뮬레이션에 활용하는 것이 가능하다.6</p>
</li>
</ul>
<p>이 모든 기능, 특히 ROS와의 통합은 전적으로 플러그인을 통해 이루어진다. 이는 PlotJuggler의 핵심 코드가 ROS와 같은 특정 미들웨어에 대한 의존성을 갖지 않도록 하여 소프트웨어의 모듈성과 이식성을 높이는 중요한 설계 원칙이다.6</p>
<h2>3.  핵심 개발 환경 구축: PlotJuggler 소스 코드 빌드</h2>
<p>플러그인 개발은 PlotJuggler의 헤더 파일과 라이브러리에 대한 링크를 필요로 하므로, 바이너리 버전을 사용하는 것만으로는 불충분하다. 따라서 개발 환경을 구축하는 첫 단계는 PlotJuggler를 소스 코드로부터 직접 빌드하고 시스템에 설치하는 것이다.1 이 과정은 플러그인이 링크해야 할 개발 파일들을 생성하고, 이후의 플러그인 프로젝트가 이를 찾을 수 있도록 한다.</p>
<h3>3.1  운영체제별 필수 구성 요소</h3>
<p>성공적인 빌드를 위해서는 각 운영체제에 맞는 컴파일러, 빌드 시스템, 그리고 의존성 라이브러리들을 사전에 설치해야 한다. 공식 문서의 내용과 실제 빌드 성공 사례(GitHub Actions 워크플로우 및 이슈 트래커)를 종합하여 검증된 필수 구성 요소 목록은 다음과 같다.11 CI/CD 파이프라인에서 사용되는 설정은 프로젝트의 최신 상태를 가장 정확하게 반영하므로, 이를 기준으로 구성 요소를 정리하는 것이 안정적인 빌드를 보장하는 지름길이다.</p>
<p><strong>Table 1: OS-별 개발 환경 필수 구성 요소</strong></p>
<table><thead><tr><th>구성 요소 (Component)</th><th>Linux (Ubuntu 22.04 권장)</th><th>Windows 10/11</th><th>macOS (Intel &amp; Apple Silicon)</th></tr></thead><tbody>
<tr><td><strong>C++ Compiler</strong></td><td><code>g++</code> (패키지: <code>build-essential</code>)</td><td>MSVC (Visual Studio 2019 이상)</td><td>Apple Clang (Xcode Command Line Tools)</td></tr>
<tr><td><strong>CMake</strong></td><td>버전 3.16 이상</td><td>버전 3.16 이상</td><td>버전 3.20 이상</td></tr>
<tr><td><strong>Qt Version</strong></td><td>Qt 5.15 이상 (<code>qtbase5-dev</code>, <code>libqt5svg5-dev</code>)</td><td>Qt 5.15 이상 (Qt Online Installer 사용)</td><td>Qt 5.15 이상 (<code>brew install qt@5</code>)</td></tr>
<tr><td><strong>주요 의존성</strong></td><td><code>libzmq3-dev</code>, <code>libdw-dev</code>, <code>libprotobuf-dev</code>, <code>protobuf-compiler</code></td><td>Conan (C/C++ 패키지 매니저)</td><td><code>protobuf</code>, <code>mosquitto</code>, <code>zeromq</code>, <code>zstd</code> (<code>brew</code> 사용)</td></tr>
</tbody></table>
<p>이 표는 개발 환경 구축 시 가장 먼저 확인해야 할 체크리스트 역할을 한다. 특히, 오래된 배포판에서 <code>libzmq-dev</code> 대신 <code>libzmq3-dev</code>를 사용해야 하는 경우나 Windows에서 Conan 패키지 매니저를 사용하는 것과 같이 플랫폼별로 특화된 요구사항을 명확히 인지하는 것이 중요하다.14</p>
<h3>3.2  소스 코드 클론 및 의존성 라이브러리 준비</h3>
<p>PlotJuggler는 여러 외부 라이브러리를 Git 서브모듈로 관리하므로, 소스 코드를 클론할 때 반드시 <code>--recurse-submodules</code> 플래그를 사용해야 한다. 이 플래그를 생략하면 빌드 시 필요한 파일들이 누락되어 오류가 발생한다.10</p>
<p>Bash</p>
<pre><code>git clone --recurse-submodules https://github.com/facontide/PlotJuggler.git
</code></pre>
<p>클론이 완료된 후, 각 운영체제에 맞는 방식으로 의존성 라이브러리를 설치한다.</p>
<ul>
<li><strong>Linux (Ubuntu 기반):</strong></li>
</ul>
<p>Bash</p>
<pre><code>sudo apt update
sudo apt install -y build-essential cmake libdw-dev libprotobuf-dev protobuf-compiler libzmq3-dev qtbase5-dev libqt5svg5-dev
</code></pre>
<ul>
<li>Windows:</li>
</ul>
<p>Windows 환경에서는 Conan C/C++ 패키지 매니저를 사용하여 의존성을 설치하는 것이 가장 안정적이다. 먼저 Python과 Conan을 설치해야 한다. COMPILE.md 문서에 명시된 conan install 명령어의 –install-folder 인자는 구버전용이므로, 최신 Conan에서는 –output-folder로 변경해야 한다.15</p>
<p>PowerShell</p>
<pre><code># Python 및 Conan 설치 후
pip install conan
# PlotJuggler 소스 디렉토리로 이동
cd PlotJuggler
# Conan을 사용하여 의존성 설치
conan install. --output-folder=build/conan --build=missing -pr:b=default
</code></pre>
<ul>
<li>macOS:</li>
</ul>
<p>Homebrew 패키지 매니저를 사용하여 필요한 라이브러리를 설치한다.12</p>
<p>Bash</p>
<pre><code>brew install cmake qt@5 protobuf mosquitto zeromq zstd
# Qt5 경로를 환경 변수에 추가해야 할 수 있음
echo 'export PATH="/usr/local/opt/qt@5/bin:$PATH"' &gt;&gt; ~/.zshrc
source ~/.zshrc
</code></pre>
<h3>3.3  플랫폼별 컴파일 및 설치 절차</h3>
<p>의존성 설치가 완료되면, 표준 CMake 빌드 절차에 따라 컴파일 및 설치를 진행한다.</p>
<ul>
<li>Linux 및 macOS:</li>
</ul>
<p>터미널에서 다음 명령어를 순서대로 실행한다. Apple Silicon (arm64) 기반의 macOS에서는 -DCMAKE_OSX_ARCHITECTURES=“arm64” 옵션을 추가하여 아키텍처를 명시적으로 지정해야 빌드 오류를 피할 수 있다.12</p>
<p>Bash</p>
<pre><code>cd PlotJuggler
mkdir build &amp;&amp; cd build

# Intel macOS 또는 Linux
cmake..

# Apple Silicon macOS
# cmake.. -DCMAKE_OSX_ARCHITECTURES="arm64"

make -j$(nproc) # nproc은 시스템 코어 수에 따라 조절
sudo make install
</code></pre>
<p><code>sudo make install</code> 명령은 빌드된 라이브러리와 헤더 파일, 그리고 실행 파일을 시스템 경로(기본값: <code>/usr/local/</code>)에 설치하여, 다른 프로젝트(즉, 개발할 플러그인)가 <code>find_package(plotjuggler)</code> 명령으로 이를 찾을 수 있게 한다.</p>
<ul>
<li>Windows:</li>
</ul>
<p>Windows에서는 Conan이 생성한 툴체인 파일을 CMake에 알려주어야 한다. Visual Studio 2019(내부 버전 16) 이상이 필요하며, x64 Native Tools Command Prompt와 같은 개발자용 터미널에서 실행하는 것이 좋다.15</p>
<p>PowerShell</p>
<pre><code>cd PlotJuggler

# Conan 툴체인 파일 경로 설정 (이전 단계에서 생성됨)
$env:CMAKE_TOOLCHAIN_FILE = "$pwd/build/conan/conan_toolchain.cmake"

# CMake 설정
cmake -S. -B build -G "Visual Studio 16 2019" -A x64 -DBUILDING_WITH_CONAN=ON -DCMAKE_TOOLCHAIN_FILE=$env:CMAKE_TOOLCHAIN_FILE

# 빌드
cmake --build build --config RelWithDebInfo

# 설치 (관리자 권한 필요)
cmake --install build --config RelWithDebInfo
</code></pre>
<p>설치가 완료되면 PlotJuggler 실행 파일과 개발에 필요한 파일들이 <code>C:\Program Files\PlotJuggler</code> 와 같은 경로에 위치하게 된다.</p>
<h2>4.  커스텀 플러그인 프로젝트 생성</h2>
<p>PlotJuggler 본체를 성공적으로 빌드하고 설치했다면, 이제 자신만의 플러그인 프로젝트를 생성할 준비가 된 것이다. 가장 효율적인 접근 방식은 처음부터 모든 것을 만드는 대신, 잘 구조화된 공식 샘플 프로젝트를 템플릿으로 활용하는 것이다.</p>
<h3>4.1  <code>plotjuggler-sample-plugins</code>를 템플릿으로 활용하기</h3>
<p>PlotJuggler 개발팀은 플러그인 개발의 시작점을 제공하기 위해 <code>plotjuggler-sample-plugins</code>라는 별도의 저장소를 제공한다. 이 저장소에는 가장 기본적인 DataLoader와 DataStreamer의 구현 예제가 포함되어 있다.10</p>
<p>먼저, 이 저장소를 클론하여 새로운 프로젝트의 기반으로 삼는다.</p>
<p>Bash</p>
<pre><code>git clone https://github.com/PlotJuggler/plotjuggler-sample-plugins.git my_custom_plugins
cd my_custom_plugins
</code></pre>
<p>저장소 내부에는 <code>DataLoadSampleCSV</code>와 <code>DataStreamSample</code>이라는 두 개의 하위 디렉토리가 있다. 개발하고자 하는 플러그인 유형에 맞춰 이 중 하나를 복사하고, 새로운 플러그인의 이름으로 디렉토리명을 변경하여 프로젝트를 시작한다. 예를 들어, 새로운 UDS(Unified Diagnostic Services) 로그 파일을 읽는 DataLoader를 만든다면 다음과 같이 시작할 수 있다.</p>
<p>Bash</p>
<pre><code>cp -r DataLoadSampleCSV DataLoadUDSLog
</code></pre>
<p>이후 <code>DataLoadUDSLog</code> 디렉토리 내부의 소스 파일 이름(<code>dataload_simple_csv.h/cpp</code>)도 <code>dataload_uds_log.h/cpp</code>와 같이 일관성 있게 변경해주는 것이 좋다.</p>
<h3>4.2  플러그인 <code>CMakeLists.txt</code> 심층 분석</h3>
<p>플러그인 프로젝트의 빌드 과정은 최상위 디렉토리의 <code>CMakeLists.txt</code> 파일에 의해 제어된다. 이 파일의 구조를 이해하는 것은 커스텀 플러그인을 성공적으로 빌드하기 위한 핵심이다.10</p>
<ul>
<li><strong>의존성 탐색:</strong></li>
</ul>
<p>CMake</p>
<pre><code>find_package(Qt5 REQUIRED COMPONENTS Core Widgets Concurrent Xml Svg OpenGL)
</code></pre>
<p>이 부분은 플러그인이 Qt의 기능을 사용하므로, 필요한 Qt5 모듈들을 찾는다. PlotJuggler 자체가 Qt 기반 애플리케이션이므로, 이 의존성은 필수적이다.</p>
<p>CMake</p>
<pre><code>find_package(plotjuggler REQUIRED)
</code></pre>
<p>이 명령은 플러그인 개발에서 가장 중요한 부분이다. 앞선 2단계에서 <code>sudo make install</code>을 통해 시스템에 설치된 PlotJuggler 개발 파일들(<code>plotjugglerConfig.cmake</code> 등)을 찾는다. 만약 이 단계에서 “Could not find a package configuration file provided by ‘plotjuggler’” 와 같은 오류가 발생한다면, 이는 PlotJuggler 본체가 제대로 설치되지 않았음을 의미한다.11</p>
<ul>
<li><strong>플러그인 타겟 생성:</strong></li>
</ul>
<p>CMake</p>
<pre><code>add_library(PlotJugglerDataSample SHARED
            DataLoadSampleCSV/dataload_simple_csv.h
            DataLoadSampleCSV/dataload_simple_csv.cpp)
</code></pre>
<p><code>add_library</code> 명령은 소스 파일들을 컴파일하여 하나의 라이브러리 타겟을 생성한다. 여기서 <code>SHARED</code> 키워드는 이 라이브러리가 동적 공유 라이브러리(플러그인)로 빌드되어야 함을 명시한다. 새로운 플러그인을 추가했다면, 이와 유사한 구문을 <code>CMakeLists.txt</code>에 추가해야 한다.</p>
<ul>
<li><strong>라이브러리 링크:</strong></li>
</ul>
<p>CMake</p>
<pre><code>target_link_libraries(PlotJugglerDataSample ${PJ_LIBRARIES})
</code></pre>
<p>생성된 플러그인 타겟이 이전에 <code>find_package</code>를 통해 찾은 Qt와 PlotJuggler 라이브러리들에 링크되도록 설정한다. <code>PJ_LIBRARIES</code> 변수에는 <code>plotjuggler_LIBRARIES</code>와 <code>Qt5::Widgets</code> 등이 포함되어 있다.</p>
<ul>
<li><strong>설치 규칙 정의:</strong></li>
</ul>
<p>CMake</p>
<pre><code>install(TARGETS PlotJugglerDataSample
        DESTINATION ${PJ_PLUGIN_INSTALL_DIRECTORY})
</code></pre>
<p><code>make install</code> 명령 실행 시, 빌드된 플러그인 바이너리(<code>libPlotJugglerDataSample.so</code> 등)를 어디에 설치할지 지정한다. <code>PJ_PLUGIN_INSTALL_DIRECTORY</code> 변수는 빌드 환경(Standalone, ROS Catkin, ROS Ament)에 따라 적절한 경로(예: <code>bin</code>, <code>lib/my_package</code>)로 자동 설정된다.</p>
<h3>4.3  기본 플러그인 소스 코드 구조 이해</h3>
<p>플러그인의 실제 로직은 C++ 클래스로 구현된다. PlotJuggler 플러그인은 기본적으로 Qt의 플러그인 시스템을 활용하므로, Qt 개발자에게 익숙한 패턴을 따른다.</p>
<ul>
<li>헤더 파일 (.h):</li>
</ul>
<p>플러그인 클래스는 QObject와 PlotJuggler가 제공하는 기본 인터페이스 클래스(예: PlotJuggler::DataLoader, PlotJuggler::DataStreamer)를 다중 상속받아야 한다.</p>
<p>C++</p>
<pre><code>#include "plotjuggler_base/dataloader.h"

class MyDataLoader : public QObject, public PlotJuggler::DataLoader
{
    Q_OBJECT    Q_PLUGIN_METADATA(IID "facontidavide.PlotJuggler.DataLoader")
    Q_INTERFACES(PlotJuggler::DataLoader)

public:    //...
};
</code></pre>
<p><code>Q_OBJECT</code> 매크로는 Qt의 시그널/슬롯 메커니즘을 사용하기 위해 필수적이다. <code>Q_PLUGIN_METADATA</code>는 이 클래스가 어떤 인터페이스를 구현하는 플러그인인지를 Qt의 메타-오브젝트 시스템에 알리는 역할을 한다. <code>IID</code>는 플러그인의 고유 식별자이다. <code>Q_INTERFACES</code>는 상속받은 인터페이스를 명시적으로 선언한다.</p>
<ul>
<li>소스 파일 (.cpp):</li>
</ul>
<p>헤더 파일에서 선언한 인터페이스의 순수 가상 함수들을 실제로 구현하는 부분이다. 예를 들어, DataLoader의 경우, 최소한 다음과 같은 함수들을 구현해야 한다.</p>
<ul>
<li>
<p><code>const char* name() const override;</code>: 플러그인의 이름을 반환한다.</p>
</li>
<li>
<p><code>const char** compatibleFileExtensions() const override;</code>: 이 플러그인이 처리할 수 있는 파일 확장자 목록을 반환한다 (예: <code>{"csv", nullptr}</code>).</p>
</li>
<li>
<p><code>Result readDataFromFile(const std::string&amp; file_path, PlotJuggler::DataContainer&amp; container) override;</code>: 실제 파일 파싱 로직이 들어가는 가장 중요한 함수이다. 이 함수 내에서 파일을 읽고, 파싱하여 <code>PlotJuggler::Timeseries</code> 객체들을 생성한 후, <code>container.addTimeseries()</code> 메소드를 통해 PlotJuggler에 데이터를 전달한다.</p>
</li>
</ul>
<p>이러한 구조는 PlotJuggler가 다양한 플러그인들을 일관된 방식으로 로드하고 상호작용할 수 있도록 하는 계약(contract) 역할을 한다.</p>
<h2>5.  통합 개발 환경(IDE) 구성</h2>
<p>효율적인 플러그인 개발을 위해서는 소스 코드 편집, 빌드, 디버깅을 통합적으로 지원하는 IDE를 올바르게 설정하는 것이 매우 중요하다. 여기서는 C++ 개발에서 널리 사용되는 Visual Studio Code와 CLion을 중심으로 PlotJuggler 플러그인 개발 환경을 구성하는 방법을 상세히 설명한다.</p>
<p>플러그인 개발의 특수성으로 인해 IDE 설정 시 가장 유의해야 할 점은 <strong>빌드 타겟(플러그인 라이브러리)과 실행/디버그 타겟(PlotJuggler 애플리케이션)이 다르다는 것</strong>이다. 일반적인 애플리케이션 개발처럼 ‘빌드 후 실행’ 버튼을 누르는 방식은 작동하지 않는다. 대신, 플러그인을 빌드하는 작업과 PlotJuggler를 실행하고 여기에 디버거를 연결하는 작업을 명확히 분리하여 구성해야 한다.</p>
<h3>5.1  Visual Studio Code 설정</h3>
<p>VS Code는 경량적이면서도 강력한 확장 프로그램 생태계를 통해 맞춤형 개발 환경을 구축하기에 용이하다.</p>
<ul>
<li>필수 확장 프로그램 및 C/C++ 환경 구성:</li>
</ul>
<p>먼저, VS Code 마켓플레이스에서 C/C++ Extension Pack과 CMake Tools 확장을 설치한다. 이들은 C++ 인텔리센스, 디버깅, CMake 프로젝트 관리 기능을 제공하는 필수 도구이다.17 설치 후, VS Code가 시스템에 설치된 C++ 컴파일러(g++, Clang, MSVC)를 인식하도록 설정한다.</p>
<ul>
<li>tasks.json을 이용한 빌드 자동화:</li>
</ul>
<p>VS Code의 작업(Task) 기능을 사용하여 플러그인 빌드 명령을 자동화할 수 있다. .vscode/tasks.json 파일을 생성하고 다음과 같이 작성한다.</p>
<p>JSON</p>
<pre><code>{
  "version": "2.0.0",
  "tasks":,
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Build the custom PlotJuggler plugin with debug symbols."
    }
  ]
}
</code></pre>
<p>이 작업은 <code>Ctrl+Shift+B</code> 단축키를 눌렀을 때 실행되며, <code>build</code> 디렉토리에서 디버그 모드로 플러그인을 컴파일한다.</p>
<ul>
<li>launch.json을 이용한 디버깅 설정:</li>
</ul>
<p>디버깅 설정은 .vscode/launch.json 파일에서 이루어진다. 앞서 강조했듯이, request 타입을 “attach“로 설정하여 실행 중인 프로세스에 연결하도록 구성하는 것이 핵심이다.19</p>
<p>JSON</p>
<pre><code>{
  "version": "0.2.0",
  "configurations":
}
</code></pre>
<ul>
<li>
<p><code>program</code>: 디버그 심볼을 로드하기 위해 원본 실행 파일의 경로를 지정한다.</p>
</li>
<li>
<p><code>processName</code>: 디버거가 연결할 프로세스의 이름이다.</p>
</li>
<li>
<p><code>preLaunchTask</code>: 디버깅 세션을 시작하기 전에 <code>tasks.json</code>에 정의된 빌드 작업을 먼저 실행하도록 하여, 항상 최신 버전의 플러그인을 디버깅하도록 보장한다.</p>
</li>
<li>
<p><code>additionalSOLibSearchPath</code>: 디버거가 플러그인(<code>.so</code> 또는 <code>.dll</code>)의 디버그 심볼을 찾을 수 있도록 빌드 출력 디렉토리를 명시적으로 알려준다. 이 설정이 없으면 중단점이 동작하지 않을 수 있다.22</p>
</li>
</ul>
<h3>5.2  CLion 설정</h3>
<p>CLion은 JetBrains에서 개발한 강력한 C++ IDE로, CMake 기반 프로젝트를 네이티브하게 지원하여 설정이 비교적 간편하다.</p>
<ul>
<li>CMake 프로젝트 열기 및 툴체인 설정:</li>
</ul>
<p>File -&gt; Open 메뉴를 통해 my_custom_plugins 폴더의 최상위 CMakeLists.txt 파일을 직접 선택하여 프로젝트를 연다. CLion은 자동으로 CMake 프로젝트를 로드하고 소스 파일을 인덱싱한다.23</p>
<p><code>Settings/Preferences -&gt; Build, Execution, Deployment -&gt; Toolchains</code> 메뉴에서 시스템에 설치된 C++ 컴파일러와 GDB/LLDB 디버거가 올바르게 인식되었는지 확인한다.</p>
<ul>
<li>실행/디버그 구성 생성:</li>
</ul>
<p>CLion의 오른쪽 상단에 있는 실행 구성 드롭다운 메뉴를 클릭하고 Edit Configurations…를 선택한다.</p>
<ol>
<li>
<p>기본으로 생성된 플러그인 라이브러리 타겟은 실행 파일이 아니므로, 이를 실행하려고 하면 “Executable not specified” 오류가 발생한다. 이는 정상적인 동작이다.25</p>
</li>
<li>
<p>새로운 실행 구성을 생성하기 위해 <code>+</code> 버튼을 누르고 <code>CMake Application</code> 템플릿을 선택한다.</p>
</li>
<li>
<p><strong>Name:</strong> “Launch and Debug PlotJuggler“와 같이 직관적인 이름을 지정한다.</p>
</li>
<li>
<p><strong>Executable:</strong> <code>...</code> 버튼을 클릭하여 시스템에 설치된 PlotJuggler 실행 파일(예: <code>/usr/local/bin/plotjuggler</code>)을 직접 선택한다.</p>
</li>
<li>
<p><strong>Target:</strong> 빌드할 타겟은 여전히 플러그인 라이브러리(예: <code>my_plugin.so</code>)로 설정해 둔다. 이렇게 하면 이 구성을 실행할 때마다 플러그인이 먼저 빌드된다.</p>
</li>
</ol>
<p>이 구성은 PlotJuggler를 실행하는 역할만 한다. 실제 디버깅은 이 구성을 실행한 후, 별도의 “Attach to Process” 기능을 통해 이루어진다.</p>
<p>Run -&gt; Attach to Process… 메뉴를 열면 현재 실행 중인 프로세스 목록이 나타난다. 여기서 plotjuggler를 검색하여 선택하면 디버거가 연결되고, 소스 코드에 설정된 중단점이 활성화된다.4</p>
<h2>6.  플러그인 빌드, 로딩 및 디버깅 워크플로우</h2>
<p>개발 환경과 IDE 설정이 모두 완료되었다면, 이제 실제 개발-테스트-디버그 사이클을 진행할 수 있다. 이 워크플로우는 플러그인 개발의 핵심적인 반복 과정이다.</p>
<h3>6.1  커스텀 플러그인 컴파일</h3>
<p>플러그인 소스 코드를 수정한 후에는 컴파일을 통해 변경 사항을 바이너리에 반영해야 한다.</p>
<ul>
<li>
<p><strong>VS Code:</strong> <code>Ctrl+Shift+B</code>를 누르거나, Command Palette(<code>Ctrl+Shift+P</code>)에서 <code>Tasks: Run Build Task</code>를 실행하여 <code>tasks.json</code>에 정의된 “Build Plugin (Debug)” 작업을 수행한다.</p>
</li>
<li>
<p><strong>CLion:</strong> <code>Build -&gt; Build Project</code> 메뉴를 선택하거나, 상단의 망치 아이콘을 클릭하여 CMake 타겟을 빌드한다.</p>
</li>
</ul>
<p>컴파일이 성공하면 <code>build</code> 디렉토리 내에 디버그 심볼이 포함된 공유 라이브러리 파일(예: <code>libMyPlugin.so</code>)이 생성된다.</p>
<h3>6.2  PlotJuggler에서 플러그인 로딩 및 테스트</h3>
<p>PlotJuggler가 시작될 때 커스텀 플러그인을 인식하고 로드하게 하려면, 컴파일된 바이너리 파일을 올바른 위치에 두어야 한다.</p>
<ol>
<li><strong>플러그인 설치/복사:</strong> 가장 확실한 방법은 빌드된 플러그인 파일을 PlotJuggler 실행 파일이 위치한 디렉토리(예: <code>sudo make install</code> 시 기본 경로인 <code>/usr/local/bin</code>)에 복사하는 것이다.1</li>
</ol>
<p>Bash</p>
<pre><code>sudo cp build/libMyPlugin.so /usr/local/bin/
</code></pre>
<p>또는, 개발 편의를 위해 PlotJuggler의 <code>App -&gt; Preferences -&gt; Plugins</code> 메뉴에서 플러그인을 검색할 경로에 프로젝트의 <code>build</code> 디렉토리를 직접 추가할 수 있다. 이 방법을 사용하면 빌드 후 파일을 매번 복사할 필요가 없어 반복 작업이 줄어든다.27</p>
<ol start="2">
<li><strong>PlotJuggler 실행 및 확인:</strong> 터미널에서 <code>plotjuggler</code>를 실행한다. 만약 플러그인 로딩에 문제가 있다면 터미널에 관련 오류 메시지가 출력될 수 있다. DataLoader 플러그인을 개발했다면 <code>File -&gt; Open</code> 대화상자의 파일 형식 필터에 플러그인 이름과 확장자가 나타나는지 확인한다. DataStreamer의 경우 <code>Streaming</code> 메뉴에 해당 스트리밍 옵션이 추가되었는지 확인한다.</li>
</ol>
<h3>6.3  고급 기법: 실행 중인 PlotJuggler 프로세스에 디버거 연결</h3>
<p>플러그인의 로직이 복잡해지면 <code>printf</code>나 로그 출력만으로는 한계에 부딪힌다. 이때 중단점, 변수 조사, 스택 추적 등 현대적인 디버깅 기능을 활용하기 위해 실행 중인 PlotJuggler 프로세스에 디버거를 연결해야 한다.</p>
<ol>
<li>
<p><strong>1단계: PlotJuggler 실행:</strong> 먼저, 디버깅할 플러그인이 로드된 PlotJuggler 인스턴스를 정상적으로 실행한다.</p>
</li>
<li>
<p><strong>2단계: 디버거 연결:</strong></p>
</li>
</ol>
<ul>
<li>
<p><strong>VS Code:</strong> <code>Run and Debug</code> 뷰( <code>Ctrl+Shift+D</code> )로 전환한다. 상단의 드롭다운 메뉴에서 이전에 설정한 “Attach to PlotJuggler” 구성을 선택하고, 녹색 재생 버튼을 누르거나 <code>F5</code> 키를 누른다. VS Code가 실행 중인 <code>plotjuggler</code> 프로세스를 찾아 디버거를 연결한다.</p>
</li>
<li>
<p><strong>CLion:</strong> <code>Run -&gt; Attach to Process...</code> 메뉴를 선택한다. 나타나는 프로세스 목록에서 <code>plotjuggler</code>를 검색하여 선택하고 <code>Attach</code> 버튼을 클릭한다.4</p>
</li>
</ul>
<ol start="3">
<li>3단계: 중단점 설정 및 트리거:</li>
</ol>
<p>디버거가 성공적으로 연결되면, IDE는 디버깅 모드로 전환되고 플러그인 소스 코드에 설정한 중단점(breakpoint)이 활성화된다. 예를 들어, DataLoader의 readDataFromFile 함수 내부에 중단점을 설정했다면, PlotJuggler UI에서 해당 형식의 파일을 열려고 시도한다.</p>
<ol start="4">
<li>4단계: 디버깅 수행:</li>
</ol>
<p>PlotJuggler가 플러그인 코드를 실행하는 순간, 실행 흐름은 설정된 중단점에서 멈춘다. 이때부터 개발자는 다음과 같은 모든 디버깅 기능을 자유롭게 사용할 수 있다.</p>
<ul>
<li>
<p><strong>변수 검사:</strong> 현재 스코프 내의 모든 변수 값을 확인하고 실시간으로 추적한다.</p>
</li>
<li>
<p><strong>호출 스택 분석:</strong> 현재 함수가 어떤 경로를 통해 호출되었는지 확인하여 코드의 실행 흐름을 파악한다.</p>
</li>
<li>
<p><strong>단계별 실행:</strong> 코드를 한 줄씩 실행(<code>Step Over</code>), 함수 내부로 진입(<code>Step Into</code>), 또는 현재 함수를 빠져나가는(<code>Step Out</code>) 등의 제어를 통해 버그의 원인을 정밀하게 추적한다.</p>
</li>
</ul>
<p>이 워크플로우를 숙달하는 것은 복잡한 데이터 파싱 로직이나 비동기 스트리밍 처리 과정에서 발생하는 미묘한 버그를 해결하는 데 결정적인 역할을 한다.</p>
<h2>7.  문제 해결 및 모범 사례</h2>
<p>개발 환경 설정과 플러그인 개발 과정에서는 다양한 문제에 직면할 수 있다. 이 섹션에서는 흔히 발생하는 빌드 오류와 그 해결 방안, 그리고 보다 효율적인 개발을 위한 몇 가지 팁을 제공한다.</p>
<h3>7.1  일반적인 빌드 오류 및 해결 방안</h3>
<ul>
<li>
<p><strong><code>Could not find a package configuration file provided by "plotjuggler"</code></strong></p>
</li>
<li>
<p><strong>원인:</strong> 이 오류는 CMake가 PlotJuggler의 개발 파일들을 찾지 못할 때 발생한다. 가장 흔한 원인은 2단계에서 PlotJuggler를 빌드한 후 <code>sudo make install</code>을 실행하지 않았거나, 설치 경로가 표준 경로가 아니어서 CMake가 인식하지 못하는 경우이다.11</p>
</li>
<li>
<p><strong>해결책:</strong> PlotJuggler 소스 디렉토리의 <code>build</code> 폴더에서 <code>sudo make install</code>을 다시 실행한다. 만약 커스텀 경로에 설치했다면, 플러그인 프로젝트를 빌드할 때 <code>cmake -DCMAKE_PREFIX_PATH=/path/to/plotjuggler/install..</code> 와 같이 <code>CMAKE_PREFIX_PATH</code>를 명시적으로 지정해주어야 한다.</p>
</li>
<li>
<p><strong>Qt 관련 링크 오류 (예: <code>undefined reference to 'Qt5::WebSocket...'</code>)</strong></p>
</li>
<li>
<p><strong>원인:</strong> 필요한 Qt 개발 라이브러리가 시스템에 설치되지 않았을 때 발생한다. 예를 들어, 웹소켓 기능을 사용하는 플러그인을 개발하면서 <code>libqt5websockets5-dev</code> 패키지를 설치하지 않은 경우이다.29</p>
</li>
<li>
<p><strong>해결책:</strong> Table 1을 참조하여 필요한 모든 Qt 개발 패키지(<code>-dev</code> 접미사가 붙은 패키지)가 설치되었는지 확인하고, 누락된 것이 있다면 설치한다.</p>
</li>
<li>
<p><strong>macOS에서의 컴파일 실패</strong></p>
</li>
<li>
<p><strong>원인:</strong> Apple Silicon(M1/M2 등) 칩을 사용하는 macOS에서 빌드할 때 아키텍처 관련 문제가 발생하거나, Xcode Command Line Tools가 제대로 설치되지 않은 경우 발생할 수 있다.12</p>
</li>
<li>
<p><strong>해결책:</strong> <code>xcode-select --install</code> 명령을 실행하여 Command Line Tools를 설치하거나 업데이트한다. CMake 실행 시 <code>-DCMAKE_OSX_ARCHITECTURES="arm64"</code> 옵션을 추가하여 타겟 아키텍처를 명시적으로 지정한다.</p>
</li>
<li>
<p><strong>Windows에서의 <code>isnan</code> / <code>isinf</code> 컴파일 오류</strong></p>
</li>
<li>
<p><strong>원인:</strong> 일부 오래된 버전의 ROS 플러그인 등에서 Windows의 MSVC 컴파일러와의 호환성 문제로 인해 <code>isnan</code>과 같은 표준 수학 함수를 찾지 못하는 경우가 보고되었다.9</p>
</li>
<li>
<p><strong>해결책:</strong> PlotJuggler와 관련 플러그인들을 최신 버전으로 업데이트한다. 대부분의 플랫폼 호환성 문제는 최신 커밋에서 해결되었을 가능성이 높다. 문제가 지속될 경우, 해당 소스 파일 상단에 <code>&lt;cmath&gt;</code> 헤더를 직접 포함시키는 것이 도움이 될 수 있다.</p>
</li>
</ul>
<h3>7.2  효율적인 플러그인 개발을 위한 팁</h3>
<ul>
<li>
<p><strong>빠른 반복을 위한 설치 경로 설정:</strong> <code>CMakeLists.txt</code>의 <code>install</code> 명령어 <code>DESTINATION</code>을 PlotJuggler의 플러그인 검색 경로 중 하나로 직접 지정하면, <code>make install</code>을 실행하는 것만으로 플러그인이 즉시 반영된다. 이는 개발 중 <code>cp</code> 명령어를 반복적으로 사용하는 수고를 덜어준다.</p>
</li>
<li>
<p><strong>디버그 로그 활용:</strong> 디버거를 연결하는 것이 부담스러울 때, 간단한 값이나 상태를 확인하기 위해 Qt의 로깅 프레임워크를 활용할 수 있다. 플러그인 코드 내에서 <code>&lt;QDebug&gt;</code> 헤더를 포함하고 <code>qDebug() &lt;&lt; "My debug message:" &lt;&lt; some_variable;</code> 와 같이 사용하면, PlotJuggler를 실행한 터미널에 해당 메시지가 출력된다.</p>
</li>
<li>
<p><strong>ROS 플러그인 개발 시 주의사항:</strong> ROS(1 또는 2)와 연동되는 플러그인을 개발할 경우, <code>plotjuggler-sample-plugins</code> 보다는 <code>plotjuggler-ros-plugins</code> 저장소를 참조하는 것이 훨씬 유용하다. 이 저장소에는 ROS 메시지 타입 변환, 토픽 구독, Rosbag 파싱 등 ROS 환경에 특화된 수많은 예제와 유틸리티 코드가 포함되어 있다.9</p>
</li>
<li>
<p><strong>커뮤니티 리소스 적극 활용:</strong> 개발 중 발생하는 문제의 상당수는 이미 다른 누군가가 겪었을 가능성이 높다. PlotJuggler의 GitHub 저장소에 있는 ’Issues’와 ‘Discussions’ 탭은 매우 귀중한 정보 소스이다. 빌드 문제, 특정 기능 사용법, 새로운 기능 제안 등 다양한 주제에 대한 논의를 찾아볼 수 있으며, 검색을 통해 문제 해결의 실마리를 빠르게 얻을 수 있다.31</p>
</li>
</ul>
<h2>8. 참고 자료</h2>
<ol>
<li>facontidavide/PlotJuggler: The Time Series Visualization … - GitHub, https://github.com/facontidavide/PlotJuggler</li>
<li>PlotJuggler, https://plotjuggler.io/</li>
<li>PlotJuggler download | SourceForge.net, https://sourceforge.net/projects/plotjuggler.mirror/</li>
<li>How to setup CLion for ROS? - c++ - Robotics Stack Exchange, https://robotics.stackexchange.com/questions/12851/how-to-setup-clion-for-ros</li>
<li>Attach to process | CLion Documentation - JetBrains, https://www.jetbrains.com/help/clion/attach-to-process.html</li>
<li>PlotJuggler, https://facontidavide.github.io/PlotJuggler/index.html</li>
<li>ROS plugins - PlotJuggler, https://facontidavide.github.io/PlotJuggler/ros_plugins/index.html</li>
<li>plotjuggler 3.9.2 documentation, https://docs.ros.org/en/iron/p/plotjuggler/</li>
<li>plotjuggler_ros - ROS Package Overview, https://index.ros.org/p/plotjuggler_ros/</li>
<li>Learn how to develop a plugin for PlotJuggler, by example. - GitHub, https://github.com/PlotJuggler/plotjuggler-sample-plugins</li>
<li>Plotjuggler vs UAV Log Viewer - Website and Documentation errors - ArduPilot Discourse, https://discuss.ardupilot.org/t/plotjuggler-vs-uav-log-viewer/117569</li>
<li>PlotJuggler compile in MacBook Pro(Apple m2 chip) failed · Issue #845 - GitHub, https://github.com/facontidavide/PlotJuggler/issues/845</li>
<li>1월 1, 1970에 액세스, https://github.com/facontidavide/PlotJuggler/blob/main/COMPILE.md</li>
<li>Segmentation Fault Erroring when trying to load format with subplots on ROS2 · Issue #737 · facontidavide/PlotJuggler - GitHub, https://github.com/facontidavide/PlotJuggler/issues/737</li>
<li>Conan compile instructions for Windows are wrong · Issue #982 · facontidavide/PlotJuggler, https://github.com/facontidavide/PlotJuggler/issues/982</li>
<li>plotjuggler - ROS Package Overview, https://index.ros.org/p/plotjuggler/</li>
<li>Get started with CMake Tools on Linux - Visual Studio Code, https://code.visualstudio.com/docs/cpp/cmake-linux</li>
<li>Debugging C++ &amp; CMake in VSCode in the Right Way - YouTube, https://www.youtube.com/watch?v=Qng2RW_bjS8</li>
<li>Launch.JSON in vscode C++: A comprehensive debugging guide - BytePlus, https://www.byteplus.com/en/topic/504273</li>
<li>Visual Studio Code debug configuration, https://code.visualstudio.com/docs/debugtest/debugging-configuration</li>
<li>vscode debugging: launch program prior to attaching to it - Stack Overflow, https://stackoverflow.com/questions/71109808/vscode-debugging-launch-program-prior-to-attaching-to-it</li>
<li>Configure C/C++ debugging - Visual Studio Code, https://code.visualstudio.com/docs/cpp/launch-json-reference</li>
<li>CLion - Autominy, https://autominy.github.io/AutoMiny/docs/clion/</li>
<li>Quick CMake tutorial | CLion Documentation - JetBrains, https://www.jetbrains.com/help/clion/quick-cmake-tutorial.html</li>
<li>CMake and CLion: executable and debug issue - JUCE Forum, https://forum.juce.com/t/cmake-and-clion-executable-and-debug-issue/46893</li>
<li>Getting Started with CLion and CMake | by LiveRunGrow - Medium, https://liverungrow.medium.com/getting-started-with-clion-and-cmake-c985f240be2f</li>
<li>Log inspection with PlotJuggler - Blog - ArduPilot Discourse, https://discuss.ardupilot.org/t/log-inspection-with-plotjuggler/122216</li>
<li>ArduPilot/plotjuggler-apbin-plugins - GitHub, https://github.com/ArduPilot/plotjuggler-apbin-plugins</li>
<li>Difficulty compiling plotjuggler · Issue #67 - GitHub, https://github.com/facontidavide/PlotJuggler/issues/67</li>
<li>Many PlotJuggler plugins for ROS and ROS2. - GitHub, https://github.com/PlotJuggler/plotjuggler-ros-plugins</li>
<li>Issues · facontidavide/PlotJuggler - GitHub, https://github.com/facontidavide/PlotJuggler/issues</li>
<li>PlotJuggler Discussions - facontidavide - GitHub, https://github.com/facontidavide/PlotJuggler/discussions</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>