<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:PlotJuggler 안내서 (2025-09-26)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>PlotJuggler 안내서 (2025-09-26)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">ROS2 (Robot Operating System 2)</a> / <a href="index.html">PlotJuggler</a> / <span>PlotJuggler 안내서 (2025-09-26)</span></nav>
                </div>
            </header>
            <article>
                <h1>PlotJuggler 안내서 (2025-09-26)</h1>
<h2>1.  PlotJuggler 개요 및 핵심 아키텍처</h2>
<h3>1.1  PlotJuggler의 정의: 단순한 플로팅 도구를 넘어선 고성능 데이터 분석 플랫폼</h3>
<p>PlotJuggler는 시계열(time series) 데이터를 시각화하기 위한 빠르고, 강력하며, 직관적인 도구이다. 이 도구는 단순히 데이터를 그래프로 표시하는 기능을 넘어, 대규모 데이터셋을 다루는 개발자와 연구자를 위한 대화형 분석 및 디버깅 통합 환경을 제공한다. 로보틱스, 자율주행차, 드론, 데이터 과학, 자동화, 임베디드 시스템 등 데이터를 시간의 흐름에 따라 분석해야 하는 거의 모든 공학 및 과학 분야에서 그 활용 가치를 인정받고 있다.</p>
<p>PlotJuggler의 핵심 가치는 복잡한 시스템의 동작을 이해하고 문제를 진단하는 데 소요되는 시간을 획기적으로 단축시키는 데 있다. 실제로 많은 사용자들이 PlotJuggler를 도입함으로써 수많은 디버깅 시간을 절약했다고 증언한다. 이는 PlotJuggler가 단순한 유틸리티 소프트웨어를 넘어, 개발 및 연구 과정의 생산성을 극대화하는 핵심적인 분석 플랫폼임을 시사한다.</p>
<h3>1.2  핵심 철학: 직관성, 속도, 그리고 확장성</h3>
<p>PlotJuggler의 설계는 세 가지 핵심 철학을 기반으로 한다: 직관성, 속도, 그리고 확장성이다.</p>
<ul>
<li>
<p><strong>직관성 (Intuitive):</strong> PlotJuggler의 가장 큰 특징은 복잡한 메뉴나 명령어 없이, 마우스로 데이터를 끌어다 놓는(Drag &amp; Drop) 것만으로 시각화를 시작할 수 있는 사용자 인터페이스다. 이러한 설계는 사용자가 도구의 사용법을 익히는 데 드는 시간을 최소화하고, 데이터 자체의 탐색과 분석에 온전히 집중할 수 있도록 돕는다.</p>
</li>
<li>
<p><strong>속도 (Fast):</strong> 고성능 그래픽 렌더링 기술인 OpenGL을 기반으로 하여 수천 개의 시계열과 수백만 개의 데이터 포인트를 포함하는 대용량 데이터도 지연 없이 부드럽게 처리할 수 있다. 이는 고주파 센서 데이터가 포함된 대용량 로그 파일을 분석하거나, 실시간으로 쏟아지는 데이터를 모니터링할 때 발생할 수 있는 성능 병목 현상을 방지하는 결정적인 요소다.</p>
</li>
<li>
<p><strong>확장성 (Extensible):</strong> 플러그인(Plugin) 기반 아키텍처를 채택하여 사용자가 필요에 따라 새로운 기능을 쉽게 추가할 수 있도록 설계되었다. 새로운 데이터 파일 형식, 독자적인 통신 프로토콜, 혹은 특정 도메인에 특화된 데이터 변환 함수 등을 플러그인 형태로 개발하여 PlotJuggler의 기능을 무한히 확장할 수 있다.</p>
</li>
</ul>
<h3>1.3  플러그인 기반 아키텍처 심층 분석: 모듈성과 유연성의 근원</h3>
<p>PlotJuggler의 강력한 기능과 유연성은 플러그인 기반 아키텍처에서 비롯된다. 핵심적인 사실은 PlotJuggler의 코어 애플리케이션 자체는 ROS(Robot Operating System)와 같은 특정 프레임워크에 대한 의존성을 전혀 갖지 않는다는 점이다. 모든 ROS 관련 기능은 외부 플러그인을 통해 완벽하게 지원된다. 이러한 설계는 특정 기술 생태계에 종속되지 않는 범용성을 확보하면서도, 가장 중요한 타겟 시장인 로보틱스 커뮤니티의 요구는 완벽하게 충족시키는 매우 전략적인 아키텍처 선택이다. 이는 소프트웨어의 유지보수성을 높이고, 다양한 환경에서의 독립적인 사용을 보장하며, PlotJuggler의 장기적인 생존과 성장에 결정적인 역할을 한다.</p>
<p>PlotJuggler의 플러그인은 기능에 따라 세 가지 주요 유형으로 분류된다:</p>
<ul>
<li>
<p><strong>DataLoaders:</strong> 파일에 저장된 정적(static) 데이터를 로드하는 역할을 담당한다. 예를 들어, CSV 파일, PX4 드론의 ULog 파일, ROS의 rosbag 파일 등을 읽어오는 플러그인이 여기에 해당한다.</p>
</li>
<li>
<p><strong>DataStreamers:</strong> 지속적으로 스트리밍되는 실시간 데이터를 수신하고 플로팅하는 역할을 담당한다. MQTT, WebSocket, ZeroMQ와 같은 표준 프로토콜이나 ROS 토픽을 구독하는 플러그인이 이 유형에 속한다.</p>
</li>
<li>
<p><strong>StatePublishers:</strong> PlotJuggler 내부로 로드된 데이터를 기반으로 외부 시스템에 데이터를 다시 발행(re-publish)하는 역할을 한다. 예를 들어, rosbag 파일의 특정 시간대 데이터를 RViz와 같은 다른 시각화 도구로 전송하는 플러그인이 이에 해당한다.</p>
</li>
</ul>
<p>이러한 모듈식 구조 덕분에 PlotJuggler는 특정 기술 스택에 얽매이지 않고 다양한 데이터 소스를 유연하게 통합하는 강력한 데이터 허브로서 기능할 수 있다.</p>
<h2>2.  설치 및 환경 구성 가이드</h2>
<h3>2.1  운영체제별 설치 전략 개요</h3>
<p>PlotJuggler는 Linux, Windows, macOS 등 다양한 운영체제를 지원하며, 사용자의 환경과 요구사항(ROS 사용 여부, OS 버전 등)에 따라 최적의 설치 방법을 선택할 수 있다. 각 운영체제별 설치 옵션은 사용자의 기술적 배경과 생태계 의존성 수준을 반영하여 명확하게 구분된다. 독립적인 사용자를 위한 간편한 패키지부터, 특정 생태계에 깊이 통합된 방식, 그리고 개발자를 위한 소스 코드 빌드까지 다양한 경로를 제공한다.</p>
<h3>2.2  Linux (Ubuntu) 환경 설치</h3>
<p>Ubuntu 환경에서는 사용자의 편의와 목적에 따라 여러 설치 방법을 선택할 수 있으며, Snap을 이용한 설치가 가장 권장된다.</p>
<ul>
<li>
<p><strong>Snap을 이용한 간편 설치 (권장):</strong> 의존성 문제를 자동으로 해결해주며 가장 간단하게 설치할 수 있는 방법이다.</p>
</li>
<li>
<p><strong>ROS2 지원 (Ubuntu 22.04 이상):</strong> <code>sudo snap install plotjuggler</code> 명령어를 사용한다. 이 패키지는 ROS2 플러그인을 포함한다.</p>
</li>
<li>
<p><strong>ROS1 지원 (Ubuntu 20.04 등):</strong> <code>sudo snap install plotjuggler-ros</code> 명령어를 사용한다. 이 패키지는 ROS1(Noetic) 플러그인을 포함한다.</p>
</li>
<li>
<p><strong>Debian 패키지 (<code>apt</code>)를 이용한 ROS 환경 통합 설치:</strong> 기존 ROS 환경에 PlotJuggler를 완벽하게 통합하고자 할 때 사용하는 방법이다.</p>
</li>
<li>
<p><code>sudo apt install ros-$ROS_DISTRO-plotjuggler-ros</code> 명령어를 통해 현재 설치된 ROS 배포판 버전에 맞는 패키지를 설치할 수 있다.</p>
</li>
<li>
<p>이 방식으로 설치하면 <code>rosrun</code> (ROS1) 또는 <code>ros2 run</code> (ROS2) 명령어를 통해 PlotJuggler를 실행할 수 있어 ROS 워크플로우에 매끄럽게 연동된다.</p>
</li>
<li>
<p><strong>AppImage를 이용한 독립 실행 환경 구성:</strong> 시스템에 별도의 설치 과정 없이 단일 실행 파일 형태로 사용하고 싶을 때 유용한 옵션이다.</p>
</li>
<li>
<p>공식 릴리즈 페이지에서 AppImage 파일을 다운로드한 후, <code>chmod +x PlotJuggler-x86_64.AppImage</code>와 같이 실행 권한을 부여하고 <code>./PlotJuggler-x86_64.AppImage</code> 명령어로 즉시 실행할 수 있다. 이 방식은 시스템 라이브러리와의 충돌을 피하고 싶거나, 여러 버전을 동시에 관리해야 할 때 유용하다.</p>
</li>
</ul>
<h3>2.3  Windows 환경 설치</h3>
<p>Windows 사용자는 공식적으로 제공되는 바이너리 설치 프로그램을 통해 PlotJuggler를 설치할 수 있다.</p>
<ul>
<li>
<p><strong>공식 바이너리 설치 프로그램:</strong> Github 릴리즈 페이지나 SourceForge 미러에서 <code>.exe</code> 확장자를 가진 설치 파일을 다운로드하여 실행하면 된다.</p>
</li>
<li>
<p><strong>중요 제한사항:</strong> 공식 Windows 설치 프로그램에는 ROS 플러그인이 포함되어 있지 않다는 점을 반드시 인지해야 한다. 따라서 Windows 환경에서 ROS 데이터를 분석해야 하는 경우, WSL2(Windows Subsystem for Linux 2)나 가상 머신을 통해 Ubuntu 환경을 구성하고 그곳에 PlotJuggler를 설치하는 것이 권장된다.</p>
</li>
<li>
<p><strong>서드파티 플러그인 수동 추가:</strong> ArduPilot의 <code>.bin</code> 로그 파일 플러그인이나 Fast DDS 플러그인과 같이, 별도로 배포되는 플러그인은 <code>.dll</code> 파일을 다운로드하여 PlotJuggler가 인식할 수 있는 경로에 수동으로 추가해야 한다. 플러그인 검색 경로는 애플리케이션 메뉴의 <code>App &gt; Preferences &gt; Plugins</code>에서 확인하고 추가할 수 있다.</p>
</li>
</ul>
<h3>2.4  macOS 환경 설치</h3>
<p>macOS 환경에서의 설치는 다른 운영체제에 비해 다소 복잡하다. 공식적인 바이너리 배포판(DMG 파일)이 제공되지 않기 때문에, 사용자가 직접 소스 코드를 컴파일해야 하는 경우가 많다.</p>
<ul>
<li>
<p><strong>소스 코드 컴파일:</strong> 현재로서는 소스 코드를 직접 빌드하는 것이 가장 확실한 방법이다.</p>
</li>
<li>
<p><strong>의존성 설치:</strong> Homebrew와 같은 패키지 관리자를 사용하여 컴파일에 필요한 라이브러리들을 먼저 설치해야 한다. <code>brew install qt@5 protobuf zeromq zstd</code> 와 같은 명령어를 통해 필수 의존성을 설치한다.</p>
</li>
<li>
<p><strong>컴파일 과정:</strong> 소스 코드를 다운로드한 후, CMake를 사용하여 빌드한다. 특히 Apple Silicon (M1/M2 등) 환경에서는 아키텍처를 명시해주어야 할 수 있다. 예를 들어, <code>cmake.. -DCMAKE_OSX_ARCHITECTURES="arm64"</code> 와 같은 옵션을 추가하여 빌드를 진행한다. 컴파일 과정에서 발생하는 문제들은 Github 이슈 트래커나 Changelog를 참조하여 해결할 수 있다.</p>
</li>
<li>
<p><strong>특정 배포판 활용:</strong> RTI Connext DDS와 같은 일부 상용 미들웨어 배포판에서는 자체적으로 PlotJuggler를 포함한 macOS용 패키지를 제공하기도 하므로, 특정 기술 스택을 사용하는 경우 해당 배포판을 확인해볼 수 있다.</p>
</li>
</ul>
<h3>2.5  소스 코드로부터 직접 빌드 (모든 OS 공통)</h3>
<p>최신 개발 버전을 사용하거나, 코드를 직접 수정하여 커스터마이징하고 싶을 때, 또는 공식 바이너리를 지원하지 않는 환경에서는 소스 코드로부터 직접 빌드해야 한다.</p>
<ul>
<li>
<p><strong>저장소 복제:</strong> Git을 사용하여 공식 저장소를 복제한다. 이때 PlotJuggler가 사용하는 외부 라이브러리(서브모듈)들을 함께 받기 위해 <code>--recurse-submodules</code> 옵션을 사용하는 것이 중요하다. ROS 사용자의 경우, PlotJuggler 메인 저장소와 함께 <code>plotjuggler-ros-plugins</code>, <code>plotjuggler_msgs</code> 저장소도 ROS 워크스페이스 내에 함께 복제해야 한다.</p>
</li>
<li>
<p><strong>의존성 설치:</strong> 컴파일에 필요한 라이브러리들을 설치한다. ROS 환경에서는 <code>rosdep install --from-paths src --ignore-src -y</code> 명령어를 사용하여 필요한 ROS 패키지들을 자동으로 설치할 수 있다. 비 ROS 환경의 Ubuntu에서는 <code>sudo apt-get install qtbase5-dev libqt5svg5-dev...</code> 와 같이 Qt5 관련 개발 패키지들을 직접 설치해야 한다.</p>
</li>
<li>
<p><strong>컴파일 및 설치:</strong> 소스 코드 디렉토리에서 빌드 환경을 구성하고 컴파일을 진행한다. 비 ROS 환경에서는 <code>mkdir build &amp;&amp; cd build &amp;&amp; cmake.. &amp;&amp; make &amp;&amp; sudo make install</code> 과 같은 표준적인 CMake 빌드 절차를 따른다. ROS2 환경에서는 워크스페이스 최상위 디렉토리에서 <code>colcon build</code> 명령어를 사용하여 빌드한다.</p>
</li>
</ul>
<h2>3.  사용자 인터페이스 및 기본 시각화 기법</h2>
<p>PlotJuggler의 사용자 인터페이스는 복잡한 데이터를 직관적으로 탐색하고 분석할 수 있도록 설계되었다. 이는 정해진 절차에 따라 리포트를 생성하는 것이 아니라, 사용자가 데이터와 실시간으로 상호작용하며 가설을 세우고 검증하는 ’탐색적 데이터 분석(Exploratory Data Analysis, EDA)’에 최적화된 환경을 제공한다.</p>
<h3>3.1  UI 구성 요소 이해</h3>
<p>PlotJuggler의 화면은 다음과 같은 계층적 구조로 구성되어 있다 1:</p>
<ul>
<li>
<p><strong>Window:</strong> 애플리케이션의 최상위 컨테이너로, 하나의 주 창(<code>MainWindow</code>)과 필요에 따라 생성할 수 있는 여러 개의 보조 창(<code>SubWindow</code>)으로 이루어진다.</p>
</li>
<li>
<p><strong>Tab:</strong> 하나의 Window 내에서 작업 공간을 논리적으로 분리하는 단위다. 관련된 분석 작업들을 탭으로 그룹화할 수 있다.</p>
</li>
<li>
<p><strong>PlotWidget:</strong> Tab 내부에 표(grid) 형태로 배열되는 개별 그래프 영역이다. 각 PlotWidget은 하나 이상의 곡선을 담을 수 있다.</p>
</li>
<li>
<p><strong>Curve:</strong> PlotWidget에 그려지는 실제 데이터 선을 의미하며, 각각의 Curve는 하나의 시계열 데이터에 해당한다.</p>
</li>
<li>
<p><strong>Timeseries List:</strong> <code>MainWindow</code> 왼쪽에 위치한 트리(tree) 뷰 형태의 패널이다. 로드된 모든 시계열 데이터의 목록이 표시되며, 검색 기능을 통해 원하는 데이터를 빠르게 찾을 수 있다.</p>
</li>
</ul>
<h3>3.2  기본 데이터 플로팅</h3>
<p>가장 기본적인 시계열 데이터 플로팅 방법은 매우 간단하다 1:</p>
<ol>
<li>
<p>화면 왼쪽의 ’Timeseries List’에서 시각화하고 싶은 시계열을 <strong>왼쪽 마우스 버튼</strong>으로 클릭하여 선택한다.</p>
</li>
<li>
<p>여러 개의 시계열을 동시에 선택하려면 <strong>CTRL</strong> 키를 누른 채로 각각 클릭하거나, <strong>SHIFT</strong> 키를 눌러 범위를 지정한다.</p>
</li>
<li>
<p>선택한 시계열(들)을 마우스로 끌어 화면 오른쪽의 플롯 영역(PlotWidget)으로 드래그 앤 드롭한다.</p>
</li>
</ol>
<p>이 직관적인 과정은 사용자가 코드를 작성하거나 복잡한 메뉴를 탐색할 필요 없이 즉각적인 시각적 피드백을 얻게 하여 데이터 탐색의 속도를 높여준다.</p>
<h3>3.3  다중 플롯 관리</h3>
<p>복잡한 시스템을 분석할 때는 여러 데이터를 동시에 비교해야 하는 경우가 많다. PlotJuggler는 이를 위한 다양한 화면 관리 기능을 제공한다.</p>
<ul>
<li>
<p><strong>화면 분할:</strong> 툴바의 ‘Add Row’ 또는 ‘Add Column’ 버튼을 사용하여 현재 Tab의 플롯 영역을 수직 또는 수평으로 분할할 수 있다. 이를 통해 여러 개의 PlotWidget을 생성하고 각각 다른 데이터를 플로팅하여 한눈에 비교할 수 있다.</p>
</li>
<li>
<p><strong>탭 및 창 생성:</strong> 관련 있는 데이터 그룹을 별도의 탭이나 창으로 분리하여 작업 공간을 체계적으로 관리할 수 있다.</p>
</li>
<li>
<p><strong>이름 변경:</strong> 각 Tab이나 PlotWidget의 이름(기본적으로 ’…’으로 표시됨)을 더블 클릭하여 ‘로봇 자세’, ‘모터 전류’ 등 의미 있는 이름으로 변경할 수 있다.</p>
</li>
<li>
<p><strong>플롯 재배치 및 교체:</strong> PlotWidget의 이름이 표시된 영역을 마우스로 끌어 다른 위치로 이동시킬 수 있다. 또한, <strong>CTRL 키를 누른 채 오른쪽 마우스 버튼</strong>으로 한 플롯을 다른 플롯 위로 드래그하면 두 플롯의 위치를 서로 교체(Swap)할 수 있다.1</p>
</li>
</ul>
<h3>3.4  XY 플롯 생성: 두 시계열 간의 상관관계 시각화</h3>
<p>일반적인 시계열 플롯은 X축이 시간이고 Y축이 데이터 값이다. 하지만 때로는 두 변수 간의 직접적인 상관관계를 보고 싶을 때가 있다. 예를 들어, 로봇의 X 위치와 Y 위치 데이터를 플로팅하여 이동 경로를 2D 평면에 그리는 경우가 이에 해당한다. PlotJuggler는 이러한 XY 플롯 생성을 지원한다.1</p>
<ul>
<li><strong>방법:</strong> ’Timeseries List’에서 X축으로 사용할 시계열과 Y축으로 사용할 시계열을 <strong>CTRL 키를 누른 채</strong> 동시에 선택한다. 그 후, <strong>오른쪽 마우스 버튼</strong>으로 플롯 영역에 드래그 앤 드롭하면 XY 플롯이 생성된다.</li>
</ul>
<h3>3.5  플롯 조작 및 탐색</h3>
<p>데이터의 특정 구간을 상세히 들여다보거나 전체적인 추세를 파악하기 위한 다양한 인터랙션 기능이 제공된다.</p>
<ul>
<li>
<p><strong>확대/축소 (Zoom):</strong></p>
</li>
<li>
<p><strong>영역 확대:</strong> 플롯 위에서 <strong>왼쪽 마우스 버튼</strong>을 누르고 드래그하여 사각형 영역을 지정하면 해당 영역이 확대된다.1</p>
</li>
<li>
<p><strong>휠 확대/축소:</strong> <strong>마우스 휠</strong>을 위아래로 스크롤하여 부드럽게 확대/축소할 수 있다. 마우스 커서를 X축이나 Y축 위에 놓고 휠을 스크롤하면 해당 축만 독립적으로 확대/축소된다.</p>
</li>
<li>
<p><strong>동기화:</strong> 툴바의 ‘link’ 버튼을 활성화하면, 여러 플롯의 X축(시간 축)이 동기화되어 하나의 플롯을 확대/축소하면 다른 모든 플롯도 함께 변경된다.</p>
</li>
<li>
<p><strong>이동 (Pan):</strong> <strong>CTRL 키를 누른 채 왼쪽 마우스 버튼</strong>으로 플롯을 드래그하면 그래프를 상하좌우로 이동시킬 수 있다.1</p>
</li>
<li>
<p><strong>시간 추적기 (Time Tracker):</strong> <strong>SHIFT 키를 누른 채 왼쪽 마우스 버튼</strong>으로 플롯 위를 클릭하거나 드래그하면 수직선 형태의 추적기가 나타난다. 이 추적기를 좌우로 움직이면 해당 시간대의 정확한 데이터 값이 ’Timeseries List’와 모든 플롯의 범례에 실시간으로 표시된다. 이는 특정 이벤트가 발생한 시점에서 여러 센서 값들이 어떻게 변화했는지 인과 관계를 추적하는 데 매우 유용하다.</p>
</li>
<li>
<p><strong>범례 (Legend) 및 커브 스타일:</strong> 플롯의 범례에서 시계열 이름을 클릭하면 해당 커브를 일시적으로 숨기거나 다시 표시할 수 있다. 커브를 오른쪽 클릭하면 나타나는 메뉴를 통해 색상, 선 두께, 점 표시 여부 등 스타일을 변경할 수 있다.</p>
</li>
</ul>
<h3>3.6  레이아웃 관리: 작업 효율성의 극대화</h3>
<p>PlotJuggler의 가장 강력하고 생산적인 기능 중 하나는 사용자가 구성한 작업 환경 전체를 저장하고 다시 불러올 수 있는 ‘레이아웃(Layout)’ 기능이다.</p>
<p>복잡하게 분할된 플롯, 여러 개의 탭과 창, 각 플롯에 배치된 시계열, 커브 스타일, 그리고 심지어 뒤에서 다룰 사용자 정의 시계열(Custom Timeseries)까지, 현재의 모든 작업 상태를 하나의 XML 파일로 저장할 수 있다.</p>
<p>이렇게 저장된 레이아웃은 나중에 다른 데이터 파일을 분석할 때 다시 불러올 수 있다. 예를 들어, 특정 로봇의 성능을 분석하기 위해 모터 전류, 속도, 위치 오차 등을 여러 플롯에 걸쳐 구성한 레이아웃을 저장해두면, 다른 날짜에 기록된 로그 파일을 열고 저장된 레이아웃을 불러오는 것만으로 동일한 분석 환경을 즉시 구축할 수 있다. 이는 반복적인 분석 및 디버깅 작업의 효율을 극적으로 향상시키는 핵심 기능이다.</p>
<h2>4.  데이터 소스 연동 및 지원 포맷</h2>
<p>PlotJuggler는 특정 기술 스택이나 데이터 포맷에 국한되지 않고, 다양한 소스로부터 데이터를 가져와 통합 분석할 수 있는 ’데이터 허브’로서의 역할을 지향한다. 이는 지원하는 데이터 소스와 포맷의 폭넓은 다양성에서 명확하게 드러난다.</p>
<h3>4.1  정적 데이터 파일 로딩 (DataLoaders)</h3>
<p>오프라인 로그 파일 분석을 위해 다양한 파일 포맷을 지원하는 <code>DataLoader</code> 플러그인을 제공한다.</p>
<ul>
<li>
<p><strong>일반 로그 파일:</strong> 가장 널리 사용되는 <strong>CSV</strong> (Comma-Separated Values) 파일을 기본적으로 지원하며, PX4 오토파일럿 기반 드론에서 생성되는 표준 로그 포맷인 <strong>ULog</strong>도 네이티브하게 읽을 수 있다. 또한, 자동차 산업에서 사용되는 <strong>CAN.dbg</strong> 포맷 등 특정 도메인의 로그 파일도 플러그인을 통해 지원한다.</p>
</li>
<li>
<p><strong>ROS 로그 파일:</strong> 로보틱스 분야의 표준 로그 파일인 <strong>rosbag</strong> (ROS1)과 <strong>rosbag2</strong> (ROS2)를 완벽하게 지원한다.</p>
</li>
<li>
<p><strong>MCAP:</strong> MCAP (Message Capture)은 ROS1과 ROS2 환경 모두에서 사용할 수 있는 차세대 컨테이너 파일 포맷이다. 특히 ROS2의 기본 <code>rosbag2</code> 포맷(SQLite)은 메시지의 구조 정보(스키마)를 파일 내에 함께 저장하지 않아, 다른 환경에서 로그를 재생하거나 분석할 때 데이터 파싱에 어려움을 겪는 경우가 많다. MCAP은 이러한 문제를 해결하기 위해 메시지 데이터와 스키마를 하나의 파일에 함께 저장한다. PlotJuggler의 MCAP 지원은 ROS 환경에서의 데이터 이식성과 분석의 재현성을 크게 향상시키는 중요한 기능이다.</p>
</li>
</ul>
<h3>4.2  실시간 데이터 스트리밍 (DataStreamers)</h3>
<p>실시간 시스템 모니터링 및 라이브 디버깅을 위해 다양한 통신 프로토콜과 데이터 직렬화 포맷을 지원하는 <code>DataStreamer</code> 플러그인을 제공한다.</p>
<ul>
<li>
<p><strong>지원 통신 프로토콜:</strong> ROS가 없는 환경에서도 널리 사용되는 표준 프로토콜들을 폭넓게 지원한다. IoT(사물 인터넷) 분야에서 많이 쓰이는 <strong>MQTT</strong>, 웹 기반 실시간 통신을 위한 <strong>WebSockets</strong>, 고성능 메시징 라이브러리인 <strong>ZeroMQ</strong>, 그리고 간단하고 빠른 데이터 전송을 위한 <strong>UDP</strong> 등을 지원한다. 이를 통해 ROS를 사용하지 않는 임베디드 장비, 서버, 웹 애플리케이션 등 거의 모든 시스템과 쉽게 연동할 수 있다.</p>
</li>
<li>
<p><strong>지원 데이터 직렬화 포맷:</strong> 스트리밍되는 데이터의 내용을 해석하기 위해 다양한 직렬화 포맷을 지원한다. 사람이 읽기 쉬운 <strong>JSON</strong>, 바이너리 형태의 경량 포맷인 <strong>CBOR</strong>, <strong>BSON</strong>, <strong>MessagePack</strong> 등을 지원한다. 이러한 경량 바이너리 포맷들은 네트워크 대역폭이 제한적인 무선 통신 환경이나 고주파 데이터 전송 시 효율성을 높여준다.</p>
</li>
</ul>
<h3>4.3  [표 1] PlotJuggler 지원 데이터 소스 및 포맷 요약</h3>
<p>아래 표는 PlotJuggler가 지원하는 주요 데이터 소스와 포맷을 요약한 것이다. 이 표는 단순히 지원 목록을 나열하는 것을 넘어, PlotJuggler의 제품 포지셔닝과 비전을 보여준다. 사용자는 이 표를 통해 자신의 기술 스택과 PlotJuggler의 호환성을 한눈에 파악하고, 이종 시스템 간의 데이터를 통합하여 분석하는 새로운 가능성을 발견할 수 있다.</p>
<table><thead><tr><th>구분</th><th>유형</th><th>지원 포맷 / 프로토콜</th><th>관련 Snippets</th><th>비고</th></tr></thead><tbody>
<tr><td><strong>정적 파일</strong></td><td><strong>DataLoader</strong></td><td>CSV, ULog (PX4), CAN.dbg, rosbag (ROS1), rosbag2 (ROS2), MCAP</td><td>S1, S7, S12, S66</td><td>오프라인 로그 분석에 사용</td></tr>
<tr><td><strong>실시간 스트림</strong></td><td><strong>DataStreamer</strong></td><td>MQTT, WebSockets, ZeroMQ, UDP, ROS/ROS2 Topics, Lab Streaming Layer</td><td>S1, S5, S7, S65</td><td>실시간 모니터링 및 디버깅에 사용</td></tr>
<tr><td><strong>데이터 포맷</strong></td><td><strong>Parser</strong></td><td>JSON, CBOR, BSON, MessagePack</td><td>S1, S7, S8, S65</td><td>스트리밍 데이터의 직렬화/역직렬화에 사용</td></tr>
</tbody></table>
<h2>5.  ROS/ROS2 통합: 로보틱스 개발의 필수 동반자</h2>
<p>PlotJuggler는 로보틱스 개발자들 사이에서 필수 도구로 평가받으며, ROS 및 ROS2 생태계와의 완벽한 통합을 자랑한다. 이는 단순한 데이터 ’뷰어’를 넘어, ROS 생태계 내에서 데이터의 ’재생산’과 ’상호작용’을 담당하는 허브 역할을 수행하기 때문이다.</p>
<h3>5.1  ROS 지원 방식: 분리된 플러그인 구조의 이점</h3>
<p>앞서 언급했듯이, PlotJuggler의 핵심은 ROS에 독립적이며, 모든 ROS 기능은 <code>plotjuggler-ros-plugins</code>라는 별도의 저장소에서 관리되는 외부 플러그인을 통해 제공된다. 이 분리된 구조는 다음과 같은 중요한 이점을 가진다.</p>
<ul>
<li>
<p><strong>유연성:</strong> ROS1에서 ROS2로 전환되거나 새로운 ROS 배포판이 출시될 때, PlotJuggler 코어 애플리케이션의 수정 없이 플러그인만 업데이트하여 신속하게 대응할 수 있다.</p>
</li>
<li>
<p><strong>경량성:</strong> ROS를 사용하지 않는 사용자는 불필요한 ROS 관련 라이브러리를 설치할 필요가 없어, 더 가볍고 깔끔한 환경을 유지할 수 있다.</p>
</li>
<li>
<p><strong>안정성:</strong> 코어 로직과 특정 프레임워크 지원 로직이 분리되어 있어, 한쪽의 변경이 다른 쪽에 미치는 영향을 최소화하고 전체 시스템의 안정성을 높인다.</p>
</li>
</ul>
<h3>5.2  주요 ROS 플러그인 기능 심층 분석</h3>
<p>ROS 환경에서 PlotJuggler의 핵심 기능은 다음과 같은 플러그인들을 통해 구현된다.2</p>
<ul>
<li>
<p><strong><code>DataLoadROS</code> (Rosbag 로더):</strong> ROS 로그 파일인 <code>.bag</code> (ROS1) 또는 데이터베이스 파일(<code>.db3</code>)과 메타데이터(<code>.yaml</code>)로 구성된 <code>rosbag2</code> (ROS2)를 로드하는 플러그인이다. 파일을 열면 로그에 기록된 모든 토픽의 목록이 나타나며, 사용자는 이 중에서 분석하고자 하는 토픽을 선택하여 시각화할 수 있다. 특히, <code>sensor_msgs/JointState</code>나 <code>tf/tfMessage</code>와 같이 하나의 메시지 안에 여러 데이터가 배열 형태로 포함된 경우, 메시지 내의 다른 필드(예: <code>name</code> 필드) 값을 이용해 각 데이터에 의미 있는 이름을 붙여주는 ‘필드 이름 변경(renaming)’ 규칙을 XML 파일로 정의하여 적용할 수 있는 강력한 기능을 제공한다.2</p>
</li>
<li>
<p><strong><code>DataStreamROS</code> (실시간 토픽 구독):</strong> 현재 실행 중인 ROS 네트워크(ROS Master 또는 DDS 네트워크)에 연결하여 실시간으로 발행되는 토픽을 구독하고 데이터를 플로팅하는 플러그인이다. 로봇을 실제로 구동하면서 센서 데이터나 제어기 내부 변수들을 실시간으로 모니터링하는 라이브 디버깅에 필수적이다. 스트리밍을 중지한 후, 그동안 수신하여 캐시에 저장된 데이터를 <code>.bag</code> 파일로 저장하는 기능도 제공하여, 특정 상황을 재현하고 분석하는 데 도움을 준다.2</p>
</li>
<li>
<p><strong><code>RosoutPublisher</code> (데이터 재발행):</strong> PlotJuggler로 로드한 데이터(rosbag 파일 또는 스트리밍 데이터)를 다시 ROS 토픽으로 발행하는 플러그인이다. 이는 <code>rosbag play</code> 명령어와 유사한 역할을 하지만, PlotJuggler의 강력한 시간 추적기(Time Tracker)와 연동된다는 결정적인 차이가 있다. 사용자는 거대한 rosbag 파일에서 원하는 특정 구간의 데이터만 로드한 후, 시간 추적기를 마우스로 정밀하게 움직이면서 해당 시점의 센서 데이터(예: PointCloud, Image, TF)를 이 플러그인을 통해 재발행할 수 있다. 이렇게 재발행된 토픽을 RViz와 같은 다른 3D 시각화 도구에서 구독하면, 그래프의 특정 지점과 실제 로봇의 3D 상태를 정확히 일치시켜 분석할 수 있다. 이 상호작용성은 PlotJuggler를 수동적인 분석 도구가 아닌, 다른 ROS 도구와 연동하여 능동적인 디버깅을 수행하는 중심축으로 만든다.</p>
</li>
<li>
<p><strong><code>Rosout</code> 메시지 뷰어:</strong> ROS의 표준 로그 메시지인 <code>/rosout</code> 토픽을 시각화하는 플러그인이다. <code>rqt_console</code>과 유사한 인터페이스를 통해 로그 메시지를 심각도(DEBUG, INFO, WARN, ERROR), 노드 이름, 내용 등으로 필터링할 수 있다.2 가장 큰 장점은 시간 추적기와 연동되어, 시계열 그래프에서 특정 이상 신호가 감지된 시점에 어떤 로그 메시지가 발생했는지 즉시 확인할 수 있다는 점이다.</p>
</li>
</ul>
<h3>5.3  실용 예제: uORB 토픽 실시간 플로팅</h3>
<p>PlotJuggler가 ROS 생태계의 다른 도구들과 어떻게 연계하여 강력한 실시간 모니터링 시스템을 구축할 수 있는지 보여주는 좋은 예로, PX4 기반 드론의 내부 데이터(uORB 토픽)를 실시간으로 시각화하는 워크플로우를 들 수 있다.</p>
<p>이 경우 데이터는 <code>PX4 (uORB) -&gt; uXRCE-DDS Client -&gt; MicroXRCE-DDS Agent -&gt; ROS2 네트워크 (DDS) -&gt; PlotJuggler</code> 의 흐름으로 전달된다. PX4 내부의 uORB 메시지가 uXRCE-DDS 미들웨어를 통해 표준 ROS2 메시지로 변환되어 네트워크에 발행되고, PlotJuggler는 이 ROS2 토픽을 구독하여 실시간으로 데이터를 플로팅한다. 이는 PlotJuggler가 직접 지원하지 않는 데이터 소스라도, 중간에 어댑터(이 경우 uXRCE-DDS Agent)를 통해 ROS 생태계로 편입시키면 강력한 시각화 및 분석이 가능함을 보여준다.</p>
<h3>5.4  ROS 환경에서의 설치 및 실행</h3>
<p>ROS 환경에서는 <code>apt</code> 패키지 관리자를 통해 설치하는 것이 가장 일반적이다. <code>sudo apt install ros-$ROS_DISTRO-plotjuggler-ros</code> 명령어를 사용하며, 실행은 터미널에서 <code>rosrun plotjuggler plotjuggler</code> (ROS1) 또는 <code>ros2 run plotjuggler plotjuggler</code> (ROS2) 명령어를 입력하여 수행한다.</p>
<h2>6.  고급 데이터 분석 및 변환</h2>
<p>PlotJuggler는 데이터를 단순히 보여주는 것을 넘어, 사용자가 데이터를 직접 가공하고 새로운 의미를 창출할 수 있는 강력한 분석 및 변환 기능을 제공한다. 이 기능들은 PlotJuggler를 단순 시각화 도구에서 ’경량 프로토타이핑 및 분석 환경’으로 격상시킨다. 사용자는 외부 스크립팅 환경으로 데이터를 내보내고 다시 가져오는 번거로운 과정 없이, 시각화와 분석/검증 사이클을 PlotJuggler 내에서 매우 빠르게 반복할 수 있다.</p>
<h3>6.1  내장 변환 (Built-in Transformations) 기능 활용</h3>
<p>자주 사용되는 기본적인 데이터 변환 기능들은 코딩 없이 마우스 클릭 몇 번으로 적용할 수 있도록 내장되어 있다.</p>
<ul>
<li>
<p><strong>미분 (Derivative):</strong> 위치 데이터를 속도 데이터로, 속도 데이터를 가속도 데이터로 변환하는 데 사용된다.</p>
</li>
<li>
<p><strong>적분 (Integral):</strong> 가속도나 각속도 데이터를 적분하여 속도나 각도를 추정하는 데 사용된다.</p>
</li>
<li>
<p><strong>이동 평균 (Moving Average):</strong> 센서 데이터에 포함된 노이즈를 제거하고 신호의 부드러운 추세를 확인하는 데 유용하다.</p>
</li>
<li>
<p><strong>스케일 (Scale):</strong> 데이터의 단위를 변경하거나 특정 상수를 곱하는 등 선형 변환을 적용할 때 사용된다.</p>
</li>
</ul>
<p>이러한 내장 변환 기능들은 원본 데이터를 기반으로 새로운 가상 시계열을 생성하며, 원본 데이터와 변환된 데이터를 함께 플로팅하여 비교 분석할 수 있다.</p>
<h3>6.2  사용자 정의 시계열 (Custom Timeseries) 생성</h3>
<p>내장된 기능만으로 부족한 복잡한 연산이 필요할 경우, Lua 스크립트를 이용하여 거의 모든 종류의 수학적 변환을 수행하고 새로운 시계열을 생성할 수 있다. 이는 PlotJuggler의 가장 강력한 기능 중 하나다.</p>
<ul>
<li>
<p><strong>Lua 스크립트 편집기:</strong> PlotJuggler는 내장된 Lua 스크립트 편집기를 제공한다. Lua는 문법이 매우 간단하여 배우기 쉬운 스크립팅 언어로 알려져 있다. 사용자는 이 편집기에서 하나 이상의 시계열을 입력으로 받아 하나의 시계열을 출력하는 함수(Multi-input / Single-output)를 작성할 수 있다.</p>
</li>
<li>
<p>스크립트 내에서 입력 시계열은 <code>value</code>(첫 번째 입력), <code>v1</code>(두 번째 입력), <code>v2</code>(세 번째 입력)… 와 같은 이름의 변수로 접근할 수 있다.</p>
</li>
<li>
<p>해당 데이터 포인트의 타임스탬프는 <code>time</code> 변수로 접근 가능하다.</p>
</li>
<li>
<p>스크립트는 각 타임스탬프에 대해 계산된 값을 <code>return</code> 문을 통해 반환해야 하며, 이 반환값들이 모여 새로운 사용자 정의 시계열을 구성한다.</p>
</li>
<li>
<p>실용 예제: 쿼터니언(Quaternion)을 오일러 각(Euler Angles)으로 변환</p>
</li>
</ul>
<p>로보틱스 분야에서는 로봇의 자세(orientation)를 짐벌락(gimbal lock) 문제가 없는 쿼터니언(Quaternion) 형태로 표현하는 경우가 많다. 하지만 사람은 쿼터니언 값을 직관적으로 이해하기 어렵기 때문에, 이를 Roll, Pitch, Yaw와 같은 오일러 각으로 변환하여 분석하는 작업이 매우 흔하다. PlotJuggler에서는 이 변환을 외부 도구 없이 직접 수행할 수 있다.</p>
<ol>
<li>
<p>화면 왼쪽 하단의 ‘Custom Series’ 패널에서 ‘+’ 버튼을 눌러 새로운 사용자 정의 시계열 생성을 시작한다.</p>
</li>
<li>
<p>’Timeseries List’에서 쿼터니언에 해당하는 4개의 시계열(예: <code>vehicle_attitude/q.00</code>, <code>.../q.01</code>, <code>.../q.02</code>, <code>.../q.03</code>)을 선택한다.</p>
</li>
<li>
<p>선택한 시계열들을 ‘Input timeseries’ 영역으로 드래그 앤 드롭한다.</p>
</li>
<li>
<p>오른쪽 ’Function Library’에서 <code>quat_to_roll</code>, <code>quat_to_pitch</code>, <code>quat_to_yaw</code>와 같은 내장 템플릿 함수를 더블 클릭하거나, 직접 변환 수식을 Lua 코드로 작성한다. 예를 들어, Roll 각도를 계산하는 스크립트는 다음과 같을 수 있다:</p>
</li>
</ol>
<p>Lua</p>
<pre><code> ```
 -- Input 0: q_w (value)
 -- Input 1: q_x (v1)
 -- Input 2: q_y (v2)
 -- Input 3: q_z (v3)
 local q_w = value
 local q_x = v1
 local q_y = v2
 local q_z = v3
 
 local sinr_cosp = 2 * (q_w * q_x + q_y * q_z)
 local cosr_cosp = 1 - 2 * (q_x * q_x + q_y * q_y)
 
 return math.atan2(sinr_cosp, cosr_cosp)
</code></pre>
<pre><code>
5. 'Create New Timeseries' 버튼을 클릭하면 'roll'이라는 이름의 새로운 시계열이 생성되며, 이를 다른 시계열과 마찬가지로 플로팅할 수 있다.

이러한 기능은 데이터 분석 알고리즘을 빠르게 프로토타이핑하고 그 결과를 즉시 시각적으로 검증하는 것을 가능하게 하여, 개발 및 디버깅 속도를 비약적으로 향상시킨다.

## 7.  실시간 스트리밍 활용 사례 연구


PlotJuggler의 실시간 스트리밍 기능은 표준화된 프로토콜(UDP, ZMQ, WebSocket)과 데이터 포맷(JSON)을 채택함으로써, 특정 프로그래밍 언어나 플랫폼에 종속되지 않는 '느슨한 결합(Loose Coupling)'을 가능하게 한다. 이는 개발자가 자신이 가장 익숙한 환경을 그대로 사용하면서, 데이터 시각화 부분만 PlotJuggler에 위임할 수 있음을 의미하며, PlotJuggler의 적용 범위를 거의 모든 데이터 생성 환경으로 확장시킨다.

### 7.1  Python을 이용한 데이터 스트리밍


Python은 데이터 과학 및 로보틱스 분야에서 널리 사용되는 언어로, PlotJuggler와의 연동이 매우 쉽다.

- **WebSocket / ZeroMQ:** PlotJuggler의 'Streaming' 메뉴에서 'WebSocket Server'나 'ZMQ Subscriber'를 실행하여 서버(또는 수신자) 역할을 하도록 설정한다. 그 후, Python 스크립트에서 `websocket-client`나 `pyzmq` 라이브러리를 사용하여 클라이언트(또는 발행자)를 구현하고, 타임스탬프를 포함한 JSON 형식의 데이터를 주기적으로 전송하면 된다.

- **UDP:** 가장 간단하고 널리 사용되는 방법 중 하나는 UDP를 이용하는 것이다. 컨테이너화된 애플리케이션이나 원격 시스템에서 데이터를 시각화할 때 특히 유용하다.

1. **PlotJuggler 설정:** 'Streaming' 메뉴에서 'UDP Server'를 선택하고 'Start'를 클릭한다. 기본 포트는 5005 또는 9870 등이며, 메시지 프로토콜은 'json'으로 설정한다. 데이터에 타임스탬프가 포함된 경우, 해당 옵션을 활성화한다.

2. **Python 클라이언트 코드:** 아래는 UDP를 통해 사인파 데이터를 PlotJuggler로 전송하는 간단한 Python 예제 코드다.

Python

</code></pre>
<p>import socket<br />
import time<br />
import json<br />
import math</p>
<h1>PlotJuggler가 실행 중인 머신의 IP 주소</h1>
<p>UDP_IP = “127.0.0.1”<br />
UDP_PORT = 5005</p>
<p>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p>
<p>start_time = time.time()</p>
<p>while True:<br />
elapsed_time = time.time() - start_time<br />
sine_value = math.sin(elapsed_time * 2 * math.pi)</p>
<pre><code># PlotJuggler로 보낼 데이터 (JSON 형식)
data = {
    "ts": time.time(),  # 타임스탬프
    "sine_wave": sine_value,
    "time_elapsed": elapsed_time
}

# 데이터를 JSON 문자열로 변환하여 전송
sock.sendto(json.dumps(data).encode(), (UDP_IP, UDP_PORT))

time.sleep(0.01) # 100Hz로 전송
</code></pre>
<pre><code>
### 7.2  임베디드 시스템 연동: Arduino 시리얼 데이터 플로팅


ROS와 같은 복잡한 미들웨어 없이 Arduino나 다른 마이크로컨트롤러에서 생성되는 센서 데이터를 실시간으로 시각화하는 것도 가능하다.

- **워크플로우:**

1. **Arduino:** Arduino 코드에서 `Serial.println()`을 사용하여 JSON 형식의 문자열을 시리얼 포트로 출력한다.

2. **데이터 파이핑:** PC(Linux 환경)에서 `socat`이나 `netcat`과 같은 커맨드라인 도구를 사용하여 시리얼 포트(`/dev/ttyACM0` 등)로부터 데이터를 읽어들인다.

3. **UDP 전송:** 읽어들인 데이터를 파이프(`|`)를 통해 `netcat`의 UDP 전송 기능으로 연결하여 PlotJuggler의 UDP 서버로 보낸다. 예를 들어, `cat /dev/ttyACM0 | nc -u -w0 127.0.0.1 9871` 과 같은 명령어를 사용할 수 있다.

4. **PlotJuggler:** UDP 서버를 통해 수신된 데이터를 실시간으로 플로팅한다.

이 방식은 저사양 임베디드 장치의 디버깅 및 데이터 모니터링을 위한 매우 실용적이고 간단한 솔루션을 제공한다.

### 7.3  NuttX 및 NxScope 연동 사례


더 전문적인 임베디드 개발 환경에서도 PlotJuggler는 유용하게 사용될 수 있다. 실시간 운영체제(RTOS)인 NuttX 환경에서는 NxScope라는 디버깅 도구를 사용하여 시스템 내부 변수를 샘플링할 수 있다. `nxscli`라는 커맨드라인 인터페이스를 통해 이 데이터를 UDP 스트림으로 출력하고, 이를 PlotJuggler에서 수신하여 시각화하는 고급 활용 사례도 존재한다. 이는 PlotJuggler가 다양한 개발 생태계와 유연하게 통합될 수 있음을 보여준다.

## 8.  타 시각화 도구와의 비교 분석


데이터 시각화 분야에는 다양한 도구들이 존재하며, 각 도구는 특정 사용 사례에 최적화되어 있다. 모든 요구를 완벽하게 만족시키는 단일 도구는 없으며, PlotJuggler는 이들 사이에서 '고성능 인터랙티브 시계열 분석'이라는 명확한 강점을 가지고 있다. 사용자는 자신의 주요 작업에 따라 적합한 도구를 선택해야 한다.

### 8.1  PlotJuggler vs. `rqt_plot` / `rqt_bag`


`rqt_plot`과 `rqt_bag`은 ROS에 기본적으로 포함된 시각화 및 데이터 검사 도구다.

- **`rqt_plot` 대비 장점:** `rqt_plot`은 간단한 토픽 데이터를 플로팅하는 데 사용되지만 기능이 매우 제한적이다. 반면 PlotJuggler는 다중 플롯, 탭, 창을 이용한 유연한 레이아웃 구성, 작업 환경을 저장하고 다시 불러오는 레이아웃 기능, 월등한 처리 성능, XY 플롯, 데이터 변환 기능 등 거의 모든 면에서 압도적인 우위를 보인다. PlotJuggler는 사실상 `rqt_plot`의 한계를 극복하기 위해 탄생한, '스테로이드를 맞은 `rqt_plot`'이라고 할 수 있다.

- **`rqt_bag` 대비 장점:** `rqt_bag`은 rosbag 파일의 내용을 트리 형태로 보여주고 개별 메시지를 텍스트 형태로 검사하는 데 중점을 둔다. 시각화 기능은 매우 제한적이다. PlotJuggler는 `rqt_bag`의 데이터 탐색 기능과 `rqt_plot`의 시각화 기능을 통합하고, 여기에 강력한 분석 기능까지 추가한 올인원(all-in-one) 솔루션에 가깝다.

### 8.2  PlotJuggler vs. MATLAB


MATLAB은 공학 및 과학 분야에서 오랫동안 표준으로 사용되어 온 강력한 수치 해석 및 시각화 소프트웨어다.

- **PlotJuggler의 강점:** 실시간 데이터 스트리밍 처리 능력, 직관적이고 빠른 대화형 인터랙션, ROS와의 네이티브 통합, 그리고 무료 오픈소스라는 점에서 MATLAB보다 강점을 가진다. 특히 로봇을 구동하며 실시간으로 데이터를 확인하고 파라미터를 튜닝하는 라이브 디버깅 시나리오에서는 PlotJuggler가 훨씬 민첩하고 효율적이다.

- **MATLAB의 강점:** 수천 개의 함수와 전문화된 툴박스를 이용한 복잡한 수학적 분석, 정교한 출판 품질(publication-quality)의 그래프 생성, 시뮬링크(Simulink)와의 연동 등 심층적인 오프라인 분석 및 학술 연구 분야에서는 여전히 독보적인 위치를 차지하고 있다.

- **결론:** 두 도구는 경쟁 관계라기보다는 상호 보완적이다. 빠른 데이터 탐색, 대용량 로그 파일의 초기 분석, 실시간 디버깅에는 PlotJuggler를 사용하고, 이후 심층적인 알고리즘 개발, 통계 분석, 논문용 그래프 생성에는 MATLAB을 사용하는 것이 효과적인 워크플로우다.

### 8.3  PlotJuggler vs. Grafana / Foxglove


Grafana와 Foxglove Studio는 웹 기술을 기반으로 하는 현대적인 데이터 시각화 도구다.

- **아키텍처:** Grafana와 Foxglove는 웹 브라우저나 Electron 기반의 애플리케이션에서 동작하며, 대시보드 형태로 정보를 제공하는 데 중점을 둔다. 반면 PlotJuggler는 C++와 Qt 프레임워크로 개발된 네이티브 데스크톱 애플리케이션으로, 로컬 데이터 파일을 빠르고 부드럽게 처리하고, 고성능의 인터랙티브 그래픽 렌더링에 강점이 있다.

- **주요 용도:**

- **Grafana:** 주로 서버 모니터링, IoT 데이터 시각화 등 시계열 데이터베이스(TSDB, 예: InfluxDB, Prometheus)와의 연동을 통해 대시보드를 구축하는 데 특화되어 있다.

- **Foxglove Studio:** 로보틱스 데이터 시각화를 위한 통합 플랫폼을 지향한다. 시계열 플롯뿐만 아니라 3D 시각화(URDF, PointCloud), 이미지, 지도 등 다양한 형태의 데이터를 하나의 대시보드에서 통합하여 보여주는 데 매우 강력하다.

- **PlotJuggler:** 이들과 비교하여 시계열 데이터 자체의 심층 분석과 변환에 더 집중한다. Lua 스크립트를 이용한 데이터 조작 기능은 PlotJuggler의 독보적인 강점이다.

### 8.4  [표 2] 시각화 도구별 기능 비교 매트릭스


| 기능             | PlotJuggler        | `rqt_plot`     | MATLAB              | Foxglove Studio      |
| -------------- | ------------------ | -------------- | ------------------- | -------------------- |
| **플랫폼**        | 데스크톱 (Qt)          | 데스크톱 (Qt/ROS)  | 데스크톱                | 데스크톱/웹               |
| **실시간 스트리밍**   | 매우 강력 (다양한 프로토콜)   | ROS 토픽만 가능     | 제한적                 | 매우 강력 (WebSocket)    |
| **데이터 소스**     | 매우 다양 (파일, 스트림)    | ROS 토픽/bag만 가능 | 파일 위주               | ROS, MCAP, WebSocket |
| **레이아웃 관리**    | 강력 (저장/로드)         | 제한적            | 스크립트 기반             | 강력 (저장/로드)           |
| **데이터 변환**     | 강력 (내장 + Lua 스크립트) | 없음             | 매우 강력 (툴박스)         | 제한적 (사용자 스크립트)       |
| **3D/이미지 시각화** | 제한적 (플러그인 필요)      | 없음             | 강력                  | 매우 강력 (네이티브 지원)      |
| **라이선스**       | 오픈소스 (MPL 2.0)     | 오픈소스 (BSD)     | 상용                  | 오픈소스/상용              |
| **최적 사용 사례**   | 인터랙티브 시계열 분석/디버깅   | 간단한 ROS 토픽 플로팅 | 심층 오프라인 분석, 알고리즘 개발 | 통합 로보틱스 데이터 대시보드     |

## 9.  부록: 고급 팁 및 추가 정보


### 9.1  [표 3] 주요 단축키 목록


PlotJuggler의 작업 효율을 극대화하기 위해 알아두면 유용한 주요 단축키 및 마우스 조작법은 다음과 같다.1

| 기능               | 단축키 / 마우스 조작                 | 비고            |
| ---------------- | ---------------------------- | ------------- |
| **여러 시계열 선택**    | `CTRL` + 왼쪽 클릭               | 개별 선택         |
| **시계열 범위 선택**    | `SHIFT` + 왼쪽 클릭              | 범위 선택         |
| **XY 플롯 생성**     | `CTRL` + 선택 후 `오른쪽` 드래그 앤 드롭 | X-Y 관계 시각화    |
| **플롯 이동 (Pan)**  | `CTRL` + `왼쪽` 드래그            |               |
| **영역 확대 (Zoom)** | `왼쪽` 드래그                     |               |
| **전체/축 확대/축소**   | 마우스 휠                        |               |
| **시간 추적기**       | `SHIFT` + `왼쪽` 드래그           | 모든 플롯/데이터 동기화 |
| **플롯 교체 (Swap)** | `CTRL` + `오른쪽` 드래그 앤 드롭      | 두 플롯의 위치를 바꿈  |
| **실행 취소 (Undo)** | `CTRL` + `Z`                 |               |
| **다시 실행 (Redo)** | `CTRL` + `SHIFT` + `Z`       |               |

### 9.2  플롯 이미지 및 데이터 내보내기


분석 결과를 보고서에 삽입하거나 다른 사람과 공유하기 위해 데이터를 내보내는 기능이 제공된다.

- **이미지로 내보내기:** 분석 중인 플롯을 이미지 파일로 저장할 수 있다. PlotWidget 위에서 마우스 오른쪽 버튼을 클릭하고 'Save plot to file' 메뉴를 선택하면 된다. 파일 형식으로 **PNG**(래스터 이미지) 또는 **SVG**(벡터 이미지)를 선택할 수 있다. 과거 버전에서는 SVG를 선택해도 PNG로 저장되는 버그가 있었으나, 현재는 수정되었다.

- **CSV로 내보내기:** PlotJuggler로 로드한 시계열 데이터나 Lua 스크립트를 통해 생성한 사용자 정의 시계열을 CSV 파일로 내보낼 수 있다. 이는 PlotJuggler에서 1차 가공한 데이터를 다른 분석 도구(MATLAB, Python Pandas 등)에서 사용하고자 할 때 유용하다. PlotJuggler는 'CSV Exporter' 플러그인을 제공하며, 이를 통해 rosbag과 같은 소스에서 원하는 데이터를 CSV로 추출할 수 있다. 다만, 서로 다른 주기와 타임스탬프를 가진 여러 시계열을 하나의 시간 축을 기준으로 병합하여 단일 CSV 파일로 만드는 것은 기술적으로 복잡한 문제이므로, 내보내기 옵션을 잘 확인하고 사용해야 한다.

### 9.3  오픈소스 프로젝트로서의 PlotJuggler


PlotJuggler는 한 명의 핵심 개발자가 주도하는 열정적인 오픈소스 프로젝트다.

- **개발자 및 라이선스:** 이탈리아의 로보틱스 엔지니어인 Davide Faconti가 주도적으로 개발하고 유지보수하고 있다. 라이선스는 **Mozilla Public License 2.0 (MPL 2.0)**을 따르며, 이는 사용자가 PlotJuggler를 기반으로 독자적인 비공개(closed-source) 플러그인을 개발하여 상업적으로 활용하는 것을 허용한다.

- **기여 및 후원:** PlotJuggler는 Github를 통해 개발이 진행되며, 누구나 버그를 보고하거나 새로운 기능을 제안하는 이슈를 생성할 수 있고, 직접 코드를 수정하여 기여(Pull Request)할 수도 있다. 또한, 프로젝트의 지속적인 발전을 위해 Github Sponsor나 PayPal을 통한 개인 및 기업의 후원을 받고 있다.

- **SponsorWare 모델:** 프로젝트의 재정적 지속 가능성을 확보하기 위한 노력의 일환으로, 'SponsorWare'라는 독특한 개발 모델을 시도하고 있다. 이 모델에 따르면, 새롭고 혁신적인 기능들은 우선 후원자들에게만 접근이 허용되는 비공개 저장소에서 개발된다. 그리고 일정 시간(예: 90일)이 지난 후에 해당 기능들이 모든 사용자가 접근할 수 있는 공개 저장소로 병합되는 방식이다. 이는 후원을 장려하는 동시에, 장기적으로는 모든 사용자가 혜택을 볼 수 있도록 하는 균형 잡힌 전략이다.

## 10. 결론


PlotJuggler는 단순한 시계열 데이터 플로팅 도구를 넘어, 로보틱스, 자율주행, 임베디드 시스템 등 복잡한 시스템을 개발하고 디버깅하는 엔지니어와 연구자들을 위한 필수적인 분석 플랫폼으로 자리매김했다. 직관적인 드래그 앤 드롭 인터페이스, 대용량 데이터도 거뜬히 처리하는 뛰어난 성능, 그리고 플러그인을 통한 무한한 확장성은 PlotJuggler의 핵심 경쟁력이다.

특히, ROS 생태계로부터의 독립성을 유지하면서도 플러그인을 통해 완벽한 통합을 이뤄낸 아키텍처는 이 도구의 범용성과 전문성을 동시에 보장하는 현명한 설계 결정이다. 또한, Lua 스크립트를 활용한 사용자 정의 시계열 기능은 사용자가 시각화와 분석의 경계를 넘나들며 데이터로부터 더 깊은 통찰을 얻을 수 있도록 돕는다.

타 도구와의 비교를 통해 확인했듯이, PlotJuggler는 실시간 데이터 스트리밍과 인터랙티브 분석이라는 명확한 영역에서 독보적인 강점을 보인다. 이 안내서에서 다룬 다양한 기능과 활용 사례를 숙지한다면, 누구나 데이터 분석 작업의 효율을 극대화하고 시스템의 숨겨진 문제점을 발견하는 강력한 무기를 손에 쥐게 될 것이다. 오픈소스 커뮤니티의 활발한 참여와 지속적인 개발을 통해 PlotJuggler는 앞으로도 데이터 기반 엔지니어링 분야에서 더욱 중요한 역할을 수행할 것으로 기대된다.

## 11. 참고 자료


1. Basics: how to visualize your data - PlotJuggler, https://facontidavide.github.io/PlotJuggler/visualization_howto/index.html
2. ROS plugins - PlotJuggler, https://facontidavide.github.io/PlotJuggler/ros_plugins/index.html
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>