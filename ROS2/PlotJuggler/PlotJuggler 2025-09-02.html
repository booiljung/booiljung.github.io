<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:PlotJuggler (2025-09-25)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>PlotJuggler (2025-09-25)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">ROS2 (Robot Operating System 2)</a> / <a href="index.html">PlotJuggler</a> / <span>PlotJuggler (2025-09-25)</span></nav>
                </div>
            </header>
            <article>
                <h1>PlotJuggler (2025-09-25)</h1>
<h2>1.  PlotJuggler의 철학과 핵심 가치</h2>
<h3>1.1  서막: 복잡계 디버깅의 본질적 난제</h3>
<p>로보틱스, 자율주행차, 드론, 임베디드 시스템과 같은 현대의 복잡한 기술 시스템은 수많은 하위 시스템이 실시간으로 상호작용하며 동작한다. 이러한 시스템의 상태는 시간에 따라 끊임없이 변화하는 다차원적 데이터의 흐름으로 표현된다. 따라서 시스템의 예기치 않은 동작이나 오류를 분석하는 디버깅 과정은 본질적인 어려움을 내포한다. 전통적인 소프트웨어 디버깅 기법, 예를 들어 GDB(GNU Debugger)와 같은 도구를 사용하여 특정 코드 라인에 중단점(breakpoint)을 설정하고 프로그램의 실행을 일시 정지시키는 방식은 이러한 실시간 시스템에 적용하기 부적합하거나 불가능한 경우가 많다.1 드론의 비행 제어 루프나 자율주행차의 인지-판단-제어 파이프라인 중간에 중단점을 설정하는 행위는 시스템의 동적 평형을 깨뜨리고, 타이밍에 민감한 상호작용을 왜곡하여 오류의 근본 원인을 파악하기는커녕 오히려 새로운 문제를 야기할 수 있다.</p>
<p>이러한 시스템을 올바르게 이해하고 디버깅하기 위해서는 실행을 중단하고 상태를 검사하는 ‘중단과 검사(break-and-inspect)’ 패러다임에서 벗어나, 시스템의 모든 상태 변화를 빠짐없이 기록하고 사후에 그 흐름을 탐색하는 ‘기록과 탐색(record-and-explore)’ 패러다임으로의 전환이 필수적이다. 즉, 시스템의 동작을 방해하지 않고 내부 상태 변수, 센서 값, 액추에이터 명령 등 모든 유의미한 데이터를 시계열(time series) 형태로 로깅하고, 이 방대한 데이터를 효율적으로 시각화하여 상관관계를 분석하는 능력이 핵심 경쟁력이 된다.</p>
<h3>1.2  PlotJuggler의 탄생 배경: 개발자 Davide Faconti의 비전</h3>
<p>PlotJuggler는 바로 이러한 ‘기록과 탐색’ 패러다임을 현실화하기 위한 철학적 고민에서 탄생한 도구이다. 핵심 개발자인 Davide Faconti는 DARPA Robotics Challenge(DRC)에 참여했던 IHMC(Institute for Human &amp; Machine Cognition) 팀에서의 경험이 PlotJuggler 개발의 결정적인 계기가 되었다고 밝힌다.1 당시 IHMC는 널리 사용되던 ROS(Robot Operating System) 생태계의 표준 도구들을 사용하는 대신, 자체적인 고성능 로깅 및 시각화 인프라에 막대한 시간과 자원을 투자했다. 이 결정은 결과적으로 팀의 개발 생산성을 두 배 이상 향상시키는 놀라운 성과로 이어졌다.1</p>
<p>IHMC의 워크플로우는 시스템에서 발생 가능한 수천 개의 내·외부 변수를 자동으로 로깅하고, 이 방대한 데이터를 직관적인 그래픽 인터페이스를 통해 빠르고 쉽게 탐색하는 것을 골자로 했다. 문제가 발생했을 때, 현상을 재현하기 위해 시스템을 다시 실행할 필요 없이, 이미 기록된 로그 데이터만으로도 대부분의 경우 문제의 근본 원인을 정확히 찾아낼 수 있었다.1 Faconti는 이 경험을 통해 강력한 로깅 및 시각화 인프라가 복잡계 시스템 개발의 생산성을 극적으로 향상시키는 ’비밀 병기’임을 깨달았다. PlotJuggler는 바로 이 강력하고 효율적인 개발 방법론을 더 넓은 개발자 커뮤니티에 보급하고, 그 진입 장벽을 낮추고자 하는 비전에서 시작된 프로젝트이다.1 따라서 PlotJuggler는 단순한 데이터 플로팅 유틸리티를 넘어, 개발 문화와 워크플로우 자체를 개선하기 위한 매개체로서의 의미를 지닌다.</p>
<h3>1.3  핵심 가치 제안: ‘빠르고, 직관적이며, 확장 가능한’</h3>
<p>PlotJuggler의 공식 슬로건인 ’Fast, intuitive and extensible(빠르고, 직관적이며, 확장 가능한)’은 앞서 설명한 개발 철학을 구현하기 위한 구체적인 설계 원칙을 담고 있다.2</p>
<ul>
<li>
<p><strong>빠름 (Fast):</strong> 대용량 데이터 처리는 ‘기록과 탐색’ 패러다임의 전제 조건이다. PlotJuggler는 수천 개의 시계열과 수백만 개의 데이터 포인트를 포함하는 대규모 로그 파일을 다룰 때도 사용자의 조작에 즉각적으로 반응하는 높은 성능을 목표로 한다.3 이는 데이터 탐색 과정에서 발생하는 지연과 마찰을 최소화하여 사용자가 분석의 흐름을 놓치지 않고 사고를 이어나갈 수 있도록 돕는다. Greenzie, Pal Robotics와 같은 기업들은 PlotJuggler가 디버깅 시간을 수없이 절약해주었다고 증언하며 이러한 성능의 가치를 입증한다.2</p>
</li>
<li>
<p><strong>직관성 (Intuitive):</strong> 강력한 기능도 사용하기 어렵다면 무용지물이다. PlotJuggler는 사용자가 복잡한 명령어 없이 마우스 조작만으로 데이터를 시각화할 수 있도록 드래그 앤 드롭(Drag &amp; Drop) 인터페이스를 핵심으로 채택했다.2 이는 데이터 시각화의 진입 장벽을 극적으로 낮춰, 개발자들이 로깅과 분석을 일상적인 개발 습관으로 받아들이게 하는 데 기여한다. 개발자의 습관을 바꾸기 위해서는 변화가 가능한 한 단순해야 한다는 철학이 반영된 결과이다.1</p>
</li>
<li>
<p><strong>확장성 (Extensible):</strong> 로보틱스, 데이터 과학, 산업 자동화 등 각 분야는 저마다 다른 데이터 포맷과 통신 프로토콜을 사용한다. PlotJuggler는 플러그인 기반 아키텍처를 채택하여 특정 기술이나 도메인에 종속되지 않는 유연성을 확보했다.2 ROS, ROS2, CSV, ULog(PX4) 등 널리 사용되는 데이터 소스는 물론, MQTT, ZeroMQ, WebSockets와 같은 통신 프로토콜까지 플러그인을 통해 지원한다. 이는 사용자가 필요에 따라 자신만의 데이터 소스를 추가할 수 있는 길을 열어주어, 도구의 생명력과 적용 범위를 크게 넓힌다.</p>
</li>
</ul>
<p>이 세 가지 핵심 가치는 서로 유기적으로 결합하여, 개발자가 방대한 로그 데이터를 부담 없이, 그리고 깊이 있게 탐색할 수 있는 환경을 제공한다. 이는 결국 복잡한 시스템에 대한 이해도를 높이고 개발 및 디버깅 사이클을 단축하는 실질적인 생산성 향상으로 이어진다.</p>
<h2>2.  아키텍처 및 핵심 기능 분석</h2>
<h3>2.1  기술 스택: C++/Qt와 OpenGL</h3>
<p>PlotJuggler는 고성능을 최우선 목표로 설계된 네이티브 데스크톱 애플리케이션이다. 핵심 로직은 C++로 작성되었으며, 이는 메모리 관리와 연산 속도 측면에서 최적의 성능을 보장한다. 사용자 인터페이스(UI)는 크로스플랫폼 GUI 프레임워크인 Qt(현재 Qt5 및 Qt6 지원)를 기반으로 구축되었다.3 웹 기반 기술(예: Electron, JavaScript)을 사용하는 다른 시각화 도구들과 비교했을 때, 네이티브 애플리케이션으로서의 구조는 시스템 리소스에 직접 접근하여 더 빠르고 안정적인 성능을 제공하는 데 유리하다.</p>
<p>특히 대규모 시계열 데이터의 시각화 성능을 극대화하기 위해 그래픽 렌더링에 OpenGL을 적극적으로 활용한다.3 수백만 개의 데이터 포인트를 화면에 그려야 할 때, CPU 기반 렌더링은 병목 현상을 일으키기 쉽다. PlotJuggler는 GPU의 병렬 처리 능력을 활용하는 OpenGL을 통해 렌더링 파이프라인을 가속화함으로써, 사용자가 데이터를 확대, 축소, 이동(panning)할 때 부드럽고 끊김 없는 상호작용을 경험할 수 있도록 보장한다. 이 기술적 선택은 대용량 로그 파일 분석이 일상적인 로보틱스 및 데이터 과학 분야에서 PlotJuggler가 제공하는 핵심적인 경쟁 우위이다.</p>
<h3>2.2  핵심 설계 사상: 플러그인 기반 아키텍처</h3>
<p>PlotJuggler의 아키텍처에서 가장 중요한 특징은 ‘관심사의 분리(Separation of Concerns)’ 원칙을 철저히 구현한 플러그인 기반 구조이다.2 코어 애플리케이션은 데이터의 시각적 *표현(presentation)*과 사용자 상호작용 처리에만 집중하며, 데이터의</p>
<p><em>획득(acquisition)</em>, <em>파싱(parsing)</em>, *재발행(re-publishing)*과 관련된 모든 기능은 독립적인 플러그인에 위임된다. 이 모듈화된 설계는 도구의 유연성과 확장성을 극대화하는 핵심 요소이다.</p>
<p>플러그인은 크게 세 가지 유형으로 분류되며, 각각 명확한 역할을 수행한다 6:</p>
<ol>
<li>
<p><strong>DataLoaders:</strong> 정적(static) 데이터를 파일로부터 로드하는 역할을 담당한다. 예를 들어, CSV 파일 파서, ROS1/ROS2의 rosbag 파일 리더, PX4의 ULog 파일 리더 등이 여기에 해당한다. 사용자가 ’파일 열기’를 통해 데이터를 가져올 때 활성화된다.</p>
</li>
<li>
<p><strong>DataStreamers:</strong> 실시간으로 연속적인 데이터 스트림에 연결하여 데이터를 수신하는 역할을 한다. ROS 토픽 구독, MQTT 브로커 연결, ZeroMQ 또는 WebSocket 소켓 수신 등이 대표적인 예이다. 사용자가 ‘스트리밍 시작’ 메뉴를 통해 특정 프로토콜을 선택하면 해당 플러그인이 동작한다.</p>
</li>
<li>
<p><strong>StatePublishers:</strong> PlotJuggler 내부로 로드된 데이터를 외부 시스템으로 다시 발행하는 역할을 한다. 가장 대표적인 예는 <code>rosbag</code> 파일의 특정 시간대 메시지를 다시 ROS 토픽으로 발행하여 RViz와 같은 다른 ROS 도구에서 시각화할 수 있도록 하는 기능이다.</p>
</li>
</ol>
<p>이러한 구조의 가장 중요한 함의는 PlotJuggler 자체가 특정 기술, 특히 ROS에 종속되지 않는다는 점이다. 문서에서는 ROS 기능이 플러그인을 통해 “전적으로(exclusively)” 구현된다고 명시적으로 강조한다.6 이는 PlotJuggler가 ’ROS를 위한 도구’가 아니라, ’ROS를 지원하는 범용 시계열 시각화 도구’임을 명확히 하는 설계 철학이다. 이 덕분에 새로운 데이터 포맷이나 통신 프로토콜을 지원해야 할 때, 코어 애플리케이션을 수정할 필요 없이 독립적인 플러그인만 개발하면 된다. 이는 커뮤니티의 기여를 촉진하고 상업적 확장을 용이하게 하여, 도구의 장기적인 생명력과 다양한 기술 생태계에 대한 적응력을 보장한다.</p>
<h3>2.3  사용자 인터페이스(UI) 및 경험(UX) 설계</h3>
<p>PlotJuggler의 UI/UX는 개발 철학인 ’직관성’을 극대화하는 데 초점을 맞추고 있다. 핵심적인 상호작용 방식은 드래그 앤 드롭으로, 사용자는 좌측의 시계열 목록에서 원하는 항목을 선택하여 중앙의 플롯 영역으로 끌어다 놓는 것만으로 즉시 그래프를 생성할 수 있다.2</p>
<p>시각화 작업 공간은 체계적인 계층 구조로 구성되어 있어 복잡한 데이터도 질서정연하게 배열할 수 있다 7:</p>
<ul>
<li>
<p><strong>Window:</strong> 최상위 컨테이너로, 하나의 메인 윈도우(MainWindow)와 여러 개의 서브 윈도우(SubWindow)를 가질 수 있다.</p>
</li>
<li>
<p><strong>Tab:</strong> 각 윈도우는 여러 개의 탭을 포함할 수 있어, 관련된 분석들을 그룹화할 수 있다.</p>
</li>
<li>
<p><strong>PlotWidget (Grid Layout):</strong> 각 탭은 행과 열로 구성된 그리드(grid) 형태의 레이아웃을 가지며, 이 그리드의 각 셀에 해당하는 것이 <code>PlotWidget</code>이다. 사용자는 버튼 클릭으로 행과 열을 쉽게 추가하여 원하는 만큼의 플롯을 배치할 수 있다.</p>
</li>
<li>
<p><strong>Curve:</strong> 하나의 <code>PlotWidget</code>에는 여러 개의 곡선(Curve)을 중첩하여 그릴 수 있다.</p>
</li>
<li>
<p><strong>Timeserie:</strong> 각 곡선은 하나의 시계열(Timeserie) 데이터에 해당한다.</p>
</li>
</ul>
<p>이러한 유연한 레이아웃 구성 능력은 반복적인 분석 작업을 위해 필수적인 ‘레이아웃 저장 및 재사용’ 기능으로 완성된다. 사용자가 공들여 구성한 창, 탭, 플롯의 배치, 각 플롯의 시계열, 축 설정 등을 XML 형식의 파일로 저장했다가 나중에 다른 데이터 파일을 열 때 그대로 불러와 적용할 수 있다.3 이는 특정 로봇의 상태를 점검하기 위한 ’진단 대시보드’처럼 정형화된 분석 작업을 자동화하여 생산성을 크게 향상시킨다.</p>
<p>더불어, 사용자의 실수를 두려워하지 않고 자유로운 탐색적 분석을 장려하기 위해 거의 모든 조작(플롯 추가/삭제, 행/열 추가, 커브 추가 등)에 대해 완전한 실행 취소/다시 실행(Undo/Redo) 스택을 지원한다.7 이는 사소하지만 사용자의 심리적 안정감과 작업 효율에 큰 영향을 미치는 중요한 UX 요소이다.</p>
<h2>3.  데이터 처리 및 시각화 역량</h2>
<h3>3.1  데이터 소스: 정적 파일과 실시간 스트림</h3>
<p>PlotJuggler는 두 가지 주요 데이터 분석 워크플로우를 모두 지원하도록 설계되었다: 실험이 끝난 후 로그 파일을 분석하는 오프라인(off-line) 분석과, 시스템이 동작하는 동안 데이터를 실시간으로 모니터링하는 온라인(on-line) 분석이다.9</p>
<ul>
<li>
<p><strong>정적 데이터 (Static Data):</strong> 주로 로그 파일 형태로 저장된 데이터를 의미한다. <code>DataLoader</code> 타입의 플러그인을 통해 로드되며, CSV나 <code>rosbag</code>과 같은 파일이 대표적이다.9 이 모드에서는 전체 데이터가 메모리에 로드되므로, 사용자는 타임라인 전체를 자유롭게 탐색하며 확대, 축소, 이동 등의 모든 상호작용 기능을 활용할 수 있다.</p>
</li>
<li>
<p><strong>스트리밍 데이터 (Streamed Data):</strong> 실시간으로 전송되는 데이터를 의미한다. <code>DataStreamer</code> 타입의 플러그인을 통해 수신된다. 이 모드에서는 데이터가 지속적으로 유입되므로, 메모리 사용량을 제어하기 위해 사용자가 버퍼의 크기를 초 단위로 설정할 수 있다. 예를 들어 버퍼를 ’60초’로 설정하면, 항상 최신의 60초 분량의 데이터만 화면에 표시된다. 다만, 데이터가 계속해서 흘러가는 특성상 타임라인을 고정하여 탐색하는 확대/축소(zoom), 이동(pan), 시간 추적기(time tracker)와 같은 기능은 스트리밍이 활성화된 동안에는 비활성화되는 제약이 있다.9</p>
</li>
</ul>
<h3>3.2  지원 포맷 및 프로토콜 상세 분석</h3>
<p>PlotJuggler의 가장 큰 강점 중 하나는 플러그인 아키텍처를 통해 매우 광범위한 데이터 포맷과 통신 프로토콜을 지원한다는 것이다. 이는 PlotJuggler가 특정 생태계에 국한되지 않고 다양한 기술 스택을 아우르는 범용 도구로 자리매김하게 하는 원동력이다. 지원하는 주요 데이터 소스는 다음 표와 같이 체계적으로 정리할 수 있다.</p>
<p><strong>Table 1: Supported Data Sources and Protocols</strong></p>
<table><thead><tr><th>구분 (Category)</th><th>유형 (Type)</th><th>포맷 / 프로토콜 (Format / Protocol)</th><th>지원 직렬화 (Supported Serialization)</th><th>관련 플러그인 (Plugin Type)</th><th>출처 (Source)</th></tr></thead><tbody>
<tr><td><strong>정적 파일</strong></td><td>로그 파일</td><td>CSV (Comma-Separated Values)</td><td>N/A</td><td>DataLoader</td><td>2</td></tr>
<tr><td>(Static Files)</td><td></td><td>ULog (PX4 Autopilot)</td><td>N/A</td><td>DataLoader</td><td>2</td></tr>
<tr><td></td><td></td><td>rosbag (ROS1), db3/mcap (ROS2)</td><td>ROS Messages</td><td>DataLoader</td><td>2</td></tr>
<tr><td></td><td></td><td>CAN Logs (<code>candump -L</code>)</td><td>DBC, J1939, NMEA2K</td><td>DataLoader</td><td>11</td></tr>
<tr><td><strong>실시간 스트림</strong></td><td>메시지 큐</td><td>MQTT (Message Queuing Telemetry Transport)</td><td>JSON, CBOR, BSON, MessagePack</td><td>DataStreamer</td><td>2</td></tr>
<tr><td>(Real-time Streams)</td><td></td><td>ZeroMQ (PUB/SUB)</td><td>JSON, CBOR, BSON, MessagePack</td><td>DataStreamer</td><td>2</td></tr>
<tr><td></td><td>네트워크 소켓</td><td>WebSockets</td><td>JSON, CBOR, BSON, MessagePack</td><td>DataStreamer</td><td>2</td></tr>
<tr><td></td><td></td><td>UDP / TCP</td><td>JSON, CBOR, BSON, MessagePack</td><td>DataStreamer</td><td>3</td></tr>
<tr><td></td><td>로보틱스 미들웨어</td><td>ROS / ROS2 Topics</td><td>ROS Messages</td><td>DataStreamer</td><td>2</td></tr>
<tr><td></td><td>기타</td><td>Lab Streaming Layer (LSL)</td><td>N/A</td><td>DataStreamer</td><td>3</td></tr>
</tbody></table>
<p>이 표에서 볼 수 있듯이, PlotJuggler는 로보틱스 분야의 표준인 ROS/ROS2와 드론 분야의 표준인 ULog뿐만 아니라, IoT 분야의 사실상 표준인 MQTT, 고성능 컴퓨팅에서 널리 쓰이는 ZeroMQ, 웹 기술의 표준인 WebSockets 등 각 산업 분야의 핵심적인 통신 프로토콜을 폭넓게 지원한다. 또한 JSON, BSON, CBOR, MessagePack 등 다양한 데이터 직렬화 포맷을 지원함으로써, 특정 프로그래밍 언어나 플랫폼에 종속되지 않는 높은 상호운용성을 제공한다. 이는 사용자가 파이썬 스크립트, C++ 애플리케이션, 웹 서비스 등 이종(heterogeneous) 시스템에서 발생하는 데이터를 별도의 변환 과정 없이 PlotJuggler 하나로 통합하여 즉시 시각화하고 분석할 수 있음을 의미하며, 이는 복잡한 시스템의 통합 테스트 및 디버깅 효율을 극대화하는 핵심적인 장점이다.</p>
<h3>3.3  시각화 유형 및 데이터 변환</h3>
<p>PlotJuggler가 제공하는 시각화의 기본 단위는 시간에 따른 값의 변화를 나타내는 <strong>시계열(Timeseries) 플롯</strong>이다.7 사용자는 좌측 목록에서 시계열을 선택하여 플롯 위젯으로 드래그 앤 드롭하는 간단한 동작으로 데이터를 시각화할 수 있다.</p>
<p>단순한 시계열 플롯 외에도, 두 데이터 간의 관계를 직관적으로 파악할 수 있는 <strong>XY 커브 플롯</strong> 기능을 제공한다. 이는 동일한 시간 축(time axis)을 공유하는 두 개의 시계열을 결합하여 하나를 X축으로, 다른 하나를 Y축으로 사용하는 2D 플롯을 생성하는 기능이다. 예를 들어, 로봇의 위치를 나타내는 <code>position/x</code>와 <code>position/y</code> 시계열을 사용하여 로봇의 2차원 이동 경로를 그리는 데 매우 유용하다. 이 기능은 일반적인 시계열 추가(마우스 왼쪽 버튼 드래그)와 구분하기 위해, X축으로 사용할 시계열을 마우스 오른쪽 버튼으로 드래그 앤 드롭하여 활성화한다.7</p>
<p>원본 데이터를 그대로 시각화하는 것을 넘어, 데이터에 숨겨진 의미를 파악하고 분석을 용이하게 하기 위한 다양한 <strong>내장 변환(Built-in Transformations)</strong> 기능을 제공한다. 사용자는 시계열을 우클릭하여 다음과 같은 변환 함수들을 쉽게 적용할 수 있다 2:</p>
<ul>
<li>
<p><strong>미분 (Derivative):</strong> 값의 변화율(속도)을 계산한다.</p>
</li>
<li>
<p><strong>적분 (Integral):</strong> 값의 누적 합계를 계산한다.</p>
</li>
<li>
<p><strong>이동 평균 (Moving Average):</strong> 노이즈를 제거하고 데이터의 추세를 부드럽게 나타낸다.</p>
</li>
<li>
<p><strong>스케일 (Scale):</strong> 데이터에 특정 상수를 곱하여 단위를 변환하거나 크기를 조정한다.</p>
</li>
<li>
<p><strong>오프셋 (Offset):</strong> 데이터에 특정 상수를 더하거나 빼서 기준점을 조정한다.</p>
</li>
</ul>
<p>이러한 내장 변환 기능들은 복잡한 스크립팅 없이도 일반적인 데이터 전처리 및 분석 작업을 신속하게 수행할 수 있도록 지원한다.</p>
<h2>4.  Lua 스크립팅을 통한 고급 데이터 조작</h2>
<h3>4.1  커스텀 시계열: 단순 시각화를 넘어선 분석</h3>
<p>PlotJuggler의 내장 변환 기능은 일반적인 분석 요구사항을 충족시키지만, 더 복잡하고 특수한 연산이 필요한 경우가 많다. 이러한 고급 요구사항에 대응하기 위해 PlotJuggler는 Lua 스크립트 언어를 기반으로 하는 강력한 ’커스텀 함수 편집기(Custom Function Editor)’를 제공한다.2 이 기능은 PlotJuggler를 단순한 데이터 뷰어에서 경량 프로그래밍이 가능한 분석 도구로 격상시키는 핵심 요소이다.</p>
<p>커스텀 함수는 기본적으로 <strong>다중 입력-단일 출력(Multi-Input Single-Output, MISO)</strong> 구조를 가진다.3 즉, 사용자는 여러 개의 기존 시계열을 입력으로 받아, 이를 조합하고 계산하여 완전히 새로운 하나의 시계열을 생성할 수 있다. 스크립트 내에서 입력 시계열은<code>value</code>, <code>v1</code>, <code>v2</code>,… 와 같은 예약된 변수 이름으로 접근할 수 있으며, 현재 데이터 포인트의 타임스탬프는 <code>time</code> 변수를 통해 사용할 수 있다.18 이 구조를 통해 사용자는 삼각함수, 벡터 연산, 조건문 등 Lua가 제공하는 모든 프로그래밍 기능을 활용하여 자신만의 복잡한 분석 로직을 구현할 수 있다.</p>
<h3>4.2  ‘Reactive Scripts’: 동적 및 대화형 분석</h3>
<p>Lua 스크립팅의 잠재력은 ’Reactive Scripts’라는 고급 기능에서 극대화된다. 이는 정적으로 데이터를 변환하는 것을 넘어, 사용자의 상호작용과 데이터의 실시간 변화에 동적으로 반응하는 스크립트를 작성할 수 있게 해준다.19 Reactive Script는 다음 두 가지 이벤트가 발생할 때마다 자동으로 재실행된다 19:</p>
<ol>
<li>
<p><strong>새로운 데이터 수신:</strong> 데이터 스트리밍 중에 새로운 데이터 포인트가 도착했을 때.</p>
</li>
<li>
<p><strong>시간 추적기 이동:</strong> 사용자가 타임라인 슬라이더를 드래그하여 현재 시간을 변경했을 때.</p>
</li>
</ol>
<p>이 스크립트 환경에서는 더 넓은 범위의 API가 제공된다. <code>TimeseriesView.find("시계열_이름")</code> 함수를 사용하여 현재 로드된 모든 시계열에 이름으로 접근할 수 있으며, <code>ScatterXY.new("새_시리즈_이름")</code> 함수를 사용하여 시계열 플롯이 아닌 새로운 2D XY 산점도(scatter plot)를 동적으로 생성하고 데이터를 추가(<code>push_back</code>)할 수 있다.19</p>
<p>이러한 동적 실행 모델은 분석의 패러다임을 근본적으로 변화시킨다. 전통적인 분석 워크플로우가 ’데이터 로드 → 외부 도구로 후처리 → 결과 재로드’의 단방향적이고 정적인 과정이었다면, Reactive Scripts는 ’데이터 탐색과 동시에 실시간으로 파생 데이터 생성 및 검증’이 가능한 순환적이고 대화형인 과정으로 만든다. 예를 들어, 사용자가 로봇의 특정 기동 구간을 타임라인에서 반복적으로 탐색할 때, 두 센서 값의 차이를 계산하거나 로봇의 전체 이동 경로를 XY 플롯에 누적하여 그리는 스크립트가 실시간으로 함께 업데이트된다. 이 즉각적인 피드백 루프는 가설 수립과 검증 과정을 극적으로 단축시키고, 데이터에 대한 깊은 직관을 형성하는 데 결정적인 역할을 한다.</p>
<h3>4.3  활용 사례: 쿼터니언에서 오일러 각으로</h3>
<p>Lua 스크립팅의 가장 대표적이고 실용적인 활용 사례는 로봇의 자세(attitude)를 나타내는 쿼터니언(Quaternion) 값을 사람이 직관적으로 이해하기 쉬운 오일러 각(Euler angles: Roll, Pitch, Yaw)으로 변환하는 것이다.18 쿼터니언은 4개의 실수(</p>
<p><code>w</code>, <code>x</code>, <code>y</code>, <code>z</code>)로 표현되며 짐벌 락(Gimbal Lock)과 같은 문제가 없어 수학적으로 안정적이지만, 각 축에 대한 회전 각도를 직접 나타내지 않아 해석이 어렵다.</p>
<p>PlotJuggler의 커스텀 함수 편집기를 사용하면, 쿼터니언의 네 가지 성분을 입력(<code>value</code>, <code>v1</code>, <code>v2</code>, <code>v3</code>)으로 받아 Roll 각도를 계산하는 새로운 시계열을 다음과 같은 스크립트로 쉽게 생성할 수 있다.</p>
<pre><code class="language-Lua">--[[  Input timeseries:  value: quaternion.w  v1:    quaternion.x  v2:    quaternion.y  v3:    quaternion.z--]]

local w = value
local x = v1
local y = v2
local z = v3

-- Roll (x-axis rotation) calculation
-- atan2(2(wx + yz), 1 - 2(x^2 + y^2))
local sinr_cosp = 2 * (w * x + y * z)
local cosr_cosp = 1 - 2 * (x * x + y * y)
local roll = math.atan2(sinr_cosp, cosr_cosp)

return roll
</code></pre>
<p>이와 유사하게 Pitch와 Yaw를 계산하는 스크립트를 각각 생성하면, 사용자는 더 이상 이해하기 어려운 4개의 쿼터니언 그래프 대신, 직관적인 3개의 오일러 각 그래프를 보며 로봇의 자세 변화를 실시간으로 분석할 수 있다. PlotJuggler는 이러한 일반적인 변환 스크립트들을 템플릿으로 제공하여 사용자의 편의를 돕는다.18</p>
<h2>5.  ROS/ROS2 생태계 통합</h2>
<h3>5.1  ROS 플러그인의 구조와 기능</h3>
<p>PlotJuggler의 ROS/ROS2 지원은 코어 애플리케이션과 완전히 분리된 외부 플러그인 패키지(<code>plotjuggler-ros-plugins</code>)를 통해 이루어진다.17 이 아키텍처는 PlotJuggler가 ROS에 의존하지 않으면서도, ROS 생태계와 완벽하게 통합될 수 있도록 하는 핵심적인 설계 결정이다. 주요 ROS 플러그인들은 ROS 사용자의 핵심적인 데이터 분석 워크플로우를 포괄적으로 지원한다 17:</p>
<ul>
<li>
<p><strong>DataLoader for rosbags:</strong> ROS 데이터 로깅의 표준인 <code>rosbag</code> 파일을 로드하는 플러그인이다. ROS1의 <code>.bag</code> 포맷과 ROS2의 <code>.db3</code> 및 <code>.mcap</code> 포맷을 모두 지원한다. 사용자는 <code>rosbag</code> 파일 내에 기록된 여러 토픽 중 분석하고자 하는 토픽을 선택적으로 로드할 수 있다.</p>
</li>
<li>
<p><strong>ROS topic subscriber:</strong> 현재 실행 중인 ROS 마스터(ROS1) 또는 DDS 네트워크(ROS2)에 연결하여 활성화된 토픽 목록을 보여주고, 사용자가 선택한 토픽의 데이터를 실시간으로 구독하여 플로팅한다.</p>
</li>
<li>
<p><strong>Re-publisher (StatePublisher):</strong> PlotJuggler의 가장 독창적인 기능 중 하나로, 로드된 <code>rosbag</code> 파일의 데이터를 다시 ROS 토픽으로 발행(publish)한다. 사용자가 타임라인 슬라이더를 특정 시간으로 이동시키면, 해당 타임스탬프에 해당하는 모든 메시지가 원래의 토픽 이름으로 발행된다. 이 기능은 RViz와 같은 3D 시각화 도구와 연동할 때 매우 강력하다. 예를 들어, PlotJuggler에서 특정 센서 값에 이상이 감지된 시점으로 슬라이더를 옮기면, RViz에서는 그 순간의 로봇 모델(TF), 카메라 이미지, 라이다 포인트 클라우드 등을 동시에 확인할 수 있어 통합적인 상황 분석이 가능하다.24</p>
</li>
<li>
<p><strong>Logs/rosout visualizer:</strong> ROS 노드들의 표준 출력 및 로그 메시지가 발행되는 <code>/rosout</code> 토픽을 구독하여 <code>rqt_console</code>과 유사한 인터페이스로 보여준다. 심각도(severity), 노드 이름, 메시지 내용 등으로 필터링할 수 있어 시계열 데이터와 로그 메시지를 연관 지어 분석할 때 유용하다.</p>
</li>
</ul>
<h3>5.2  ROS2 데이터 처리: <code>db3</code>의 한계와 MCAP의 부상</h3>
<p>PlotJuggler의 ROS2 지원 발전 과정은 ROS2 생태계 자체의 성숙 과정을 반영하는 중요한 사례이다. ROS2의 초기 <code>rosbag</code> 포맷인 <code>db3</code>는 SQLite 데이터베이스를 기반으로 하지만, 메시지 데이터만 저장할 뿐 해당 메시지의 스키마(타입 정의, <code>.msg</code> 파일의 내용)를 파일 내에 포함하지 않는다는 근본적인 한계를 가지고 있었다.10</p>
<p>이러한 설계는 외부 도구가 <code>db3</code> 파일을 해석하는 데 큰 어려움을 야기했다. PlotJuggler가 커스텀 메시지(사용자가 정의한 메시지 타입)가 포함된 <code>db3</code> 파일을 올바르게 파싱하기 위해서는, PlotJuggler를 실행하는 터미널 환경에 해당 커스텀 메시지 패키지가 빌드되어 있고, <code>install/setup.bash</code> 스크립트가 <code>source</code>되어 있어야만 했다.26 이는 데이터 파일만 전달해서는 다른 환경에서 내용을 볼 수 없다는 의미로, 데이터의 이식성과 재현성을 심각하게 저해하는 문제였다.</p>
<p>이러한 공통의 문제를 해결하기 위해 PlotJuggler 개발자 Davide Faconti와 또 다른 주요 시각화 도구인 Foxglove Studio 팀은 협력하여 MCAP(Message Container, <code>.mcap</code>)이라는 새로운 파일 포맷의 지원을 확대했다.25 MCAP은 메시지 데이터와 함께 메시지 스키마 정보까지 파일 내에 저장하는 자기 완결적(self-contained) 포맷이다.10 덕분에 MCAP 파일은 그 자체만으로 완전한 정보를 담고 있어, 어떤 환경에서든 추가적인 설정 없이 PlotJuggler에서 즉시 열고 분석할 수 있다. 이러한 변화는 단순한 기능 개선을 넘어, 로보틱스 데이터 교환 표준을 향한 커뮤니티의 중요한 진전을 상징하며, PlotJuggler가 ROS2 생태계의 핵심 도구로 굳건히 자리매김하는 데 결정적인 역할을 했다.</p>
<h3>5.3  실용적 워크플로우: 설치 및 실행</h3>
<p>ROS 환경에서 PlotJuggler를 사용하는 방법은 간단하며, 사용자의 시스템 환경에 따라 여러 옵션이 제공된다.3</p>
<ul>
<li>
<p><strong>설치 방법:</strong></p>
</li>
<li>
<p><strong>Snap (Ubuntu 사용자에게 가장 권장되는 방식):</strong> Snap 패키지는 ROS1 또는 ROS2 지원에 필요한 모든 의존성을 포함하고 있어 설치가 매우 간편하다.</p>
</li>
<li>
<p>ROS2 환경 (Ubuntu 22.04 등): <code>sudo snap install plotjuggler</code></p>
</li>
<li>
<p>ROS1 환경 (Ubuntu 20.04 등): <code>sudo snap install plotjuggler-ros</code></p>
</li>
<li>
<p><strong>Debian Packages (apt):</strong> ROS 배포판의 공식 패키지 저장소를 통해 설치하는 방식이다.</p>
</li>
<li>
<p><code>sudo apt install ros-$ROS_DISTRO-plotjuggler-ros</code> (여기서 <code>$ROS_DISTRO</code>는 <code>humble</code>, <code>noetic</code> 등 사용자의 ROS 버전에 해당한다.)</p>
</li>
<li>
<p><strong>실행 방법:</strong></p>
</li>
<li>
<p>설치 방식에 따라 실행 명령어가 다르다. Debian 패키지로 설치한 경우, ROS 환경에 맞게 다음 명령어를 사용한다.</p>
</li>
<li>
<p>ROS1: <code>rosrun plotjuggler plotjuggler</code></p>
</li>
<li>
<p>ROS2: <code>ros2 run plotjuggler plotjuggler</code></p>
</li>
<li>
<p>Snap으로 설치한 경우, ROS 버전에 관계없이 <code>plotjuggler</code> 명령어로 실행할 수 있다.</p>
</li>
</ul>
<p>커스텀 메시지를 사용하는 경우, <code>db3</code> 파일을 열거나 실시간 토픽을 구독하기 전에 반드시 해당 메시지가 포함된 워크스페이스의 <code>setup.bash</code> 파일을 <code>source</code>해야 함을 유의해야 한다.</p>
<h2>6.  확장성: 플러그인 개발과 생태계</h2>
<h3>6.1  커스텀 플러그인 개발 방법론</h3>
<p>PlotJuggler의 핵심적인 강점인 확장성은 사용자가 직접 필요에 맞는 플러그인을 개발할 수 있는 환경을 통해 구현된다. PlotJuggler는 커스텀 플러그인 개발을 돕기 위해 <code>plotjuggler-sample-plugins</code>라는 별도의 GitHub 저장소를 제공하며, 이는 새로운 플러그인을 만들기 위한 훌륭한 템플릿 역할을 한다.28</p>
<p>커스텀 플러그인을 개발하는 과정은 다음과 같은 단계로 이루어진다:</p>
<ol>
<li>
<p><strong>개발 환경 구축:</strong> 플러그인을 빌드하기 위해서는 개발 시스템에 PlotJuggler의 헤더 파일과 라이브러리가 먼저 설치되어 있어야 한다. 이는 소스 코드를 직접 컴파일하여 <code>sudo make install</code>을 실행하는 방식으로 수행할 수 있다.11 또한, GUI 개발을 위해 Qt 라이브러리(주로 Qt5)가 필요하다.</p>
</li>
<li>
<p><strong>CMake 설정:</strong> 샘플 플러그인의 <code>CMakeLists.txt</code> 파일은 <code>find_package(PlotJuggler REQUIRED)</code>와 <code>find_package(Qt5 REQUIRED...)</code> 명령어를 사용하여 시스템에 설치된 PlotJuggler와 Qt 의존성을 찾는 방법을 보여준다.28 개발자는 이 파일을 기반으로 자신의 플러그인 소스 코드와 의존성을 명시한다.</p>
</li>
<li>
<p><strong>플러그인 구현:</strong> <code>DataLoader</code> 또는 <code>DataStreamer</code> 등 원하는 유형의 플러그인 인터페이스를 상속받는 C++ 클래스를 작성한다. 핵심은 PlotJuggler가 요구하는 가상 함수들(예: 데이터 파일을 읽고 시계열을 반환하는 함수)을 구현하는 것이다.</p>
</li>
<li>
<p><strong>빌드 및 설치:</strong> CMake와 make(또는 다른 빌드 시스템)를 사용하여 플러그인을 컴파일하면 공유 라이브러리 파일(Linux에서는 <code>.so</code>, Windows에서는 <code>.dll</code>)이 생성된다. 이 파일을 PlotJuggler가 인식할 수 있는 경로에 위치시켜야 한다. 가장 간단한 방법은 PlotJuggler 실행 파일이 있는 디렉터리에 복사하는 것이며, 또는 PlotJuggler 애플리케이션 내의 <code>App -&gt; Preferences -&gt; Plugins</code> 메뉴에서 플러그인을 검색할 추가 경로를 지정할 수도 있다.28</p>
</li>
</ol>
<h3>6.2  주요 플러그인 생태계</h3>
<p>PlotJuggler의 확장성은 <code>PlotJuggler</code>라는 GitHub 조직(organization)을 중심으로 관리되는 다양한 공식 플러그인 저장소들을 통해 구체화된다. 이는 핵심 애플리케이션을 ’허브(hub)’로, 각 기능 확장을 ’스포크(spoke)’로 하는 체계적인 생태계 모델을 보여준다.13 주요 플러그인들은 다음과 같다:</p>
<ul>
<li>
<p><strong><code>plotjuggler-ros-plugins</code>:</strong> ROS1 및 ROS2와의 통합을 담당하는 가장 핵심적인 플러그인 모음이다. <code>rosbag</code> 로더, 토픽 구독기, 메시지 재발행기 등을 포함한다.13</p>
</li>
<li>
<p><strong><code>plotjuggler-CAN-dbs</code>:</strong> 자동차 및 산업 자동화 분야에서 널리 사용되는 CAN(Controller Area Network) 버스 데이터를 시각화하기 위한 플러그인이다. <code>.dbc</code> 데이터베이스 파일을 사용하여 CAN 메시지를 해석하고, <code>candump</code>로 기록된 로그 파일이나 실시간 CAN 스트림을 분석할 수 있다.11</p>
</li>
<li>
<p><strong><code>plotjuggler-lsl</code>:</strong> 뇌파(EEG), 근전도(EMG) 등 생체 신호 연구나 심리학 실험에서 자주 사용되는 Lab Streaming Layer(LSL) 프로토콜을 지원하는 플러그인이다.13</p>
</li>
<li>
<p><strong><code>plotjuggler-mqtt</code>:</strong> IoT(사물 인터넷)의 표준 메시징 프로토콜인 MQTT를 지원하여, 수많은 IoT 장치로부터 데이터를 스트리밍받아 시각화할 수 있게 한다.13</p>
</li>
<li>
<p><strong><code>plotjuggler_msgs</code>:</strong> PlotJuggler에서의 시각화에 최적화된 데이터를 전송하기 위해 특별히 정의된 커스텀 ROS 메시지 패키지이다. 이는 데이터 전송 효율을 높이고 파싱 과정을 단순화하는 데 도움을 준다.13</p>
</li>
</ul>
<p>이러한 플러그인 생태계는 PlotJuggler가 로보틱스를 넘어 다양한 공학 및 과학 분야의 전문가들에게 유용한 도구가 될 수 있는 기반을 제공한다. 특히, PlotJuggler의 코어 라이선스인 Mozilla Public License 2.0 (MPL-2.0)은 사용자가 개발한 플러그인의 소스 코드를 공개하지 않아도 되는, 즉 독점(closed-source) 플러그인 개발을 허용한다는 점에서 중요한 전략적 의미를 갖는다.3 이는 기업들이 자사의 독자적인 데이터 포맷이나 통신 프로토콜을 지원하는 플러그인을 개발하면서도 관련 기술을 영업 비밀로 보호할 수 있게 해준다. 이러한 유연한 라이선스 정책은 상업적 활용을 촉진하고, 결과적으로 PlotJuggler 생태계 전반의 성장과 다양성에 기여하는 중요한 요소로 작용한다.</p>
<h2>7.  타 시각화 도구와의 비교 분석</h2>
<p>PlotJuggler의 가치를 정확히 평가하기 위해서는 로보틱스 및 데이터 분석 생태계에 존재하는 다른 시각화 도구들과의 비교 분석이 필수적이다. 각 도구는 고유한 철학과 목적을 가지고 설계되었으므로, 사용 사례에 따라 적합성이 달라진다.</p>
<h3>7.1  PlotJuggler vs. rqt_plot: 직접적 대체재</h3>
<p><code>rqt_plot</code>은 ROS1에 기본적으로 포함된 시계열 데이터 플로팅 도구로, PlotJuggler가 해결하고자 하는 문제들을 가장 직접적으로 공유한다. 하지만 <code>rqt_plot</code>은 몇 가지 명백한 한계를 가지고 있다. 대용량의 <code>rosbag</code> 파일이나 데이터 전송률이 높은 토픽을 시각화할 때 심각한 성능 저하를 보이며 UI가 멈추는 경우가 잦다.31 또한, UI가 단순하여 여러 플롯을 체계적으로 관리하기 어렵고, 공들여 만든 플롯 레이아웃을 저장하고 재사용하는 기능이 없어 반복적인 작업에 비효율적이다.31</p>
<p>PlotJuggler는 이러한 <code>rqt_plot</code>의 단점들을 극복하기 위해 개발된 명백한 상위 호환 도구이다.31 C++과 OpenGL 기반의 뛰어난 성능, 다중 플롯/탭/윈도우를 지원하는 유연한 레이아웃, XML 파일 기반의 레이아웃 저장/로드 기능, 그리고 내장 데이터 변환 및 Lua 스크립팅 기능 등 거의 모든 측면에서</p>
<p><code>rqt_plot</code>을 능가한다. 따라서 ROS 환경에서 시계열 데이터를 다루는 사용자에게 <code>rqt_plot</code> 대신 PlotJuggler를 사용하는 것은 특별한 이유가 없는 한 당연한 선택으로 여겨진다.34</p>
<h3>7.2  PlotJuggler vs. Foxglove Studio: 철학과 범위의 차이</h3>
<p>Foxglove Studio는 현대 로보틱스 개발에서 PlotJuggler와 함께 가장 널리 언급되는 시각화 도구이다. 두 도구 모두 ROS1/ROS2 데이터를 훌륭하게 지원하지만, 그 지향점과 핵심 기능 범위에서 뚜렷한 차이를 보인다.</p>
<ul>
<li>
<p><strong>PlotJuggler:</strong> C++ 기반의 고성능 네이티브 애플리케이션으로, <strong>시계열 데이터의 심층 분석</strong>에 극도로 특화되어 있다. 강력한 데이터 변환, 리샘플링, Lua 스크립팅 기능은 센서 데이터나 제어 알고리즘의 미세한 동작을 파헤치는 엔지니어의 로컬 디버깅 작업에 최적화되어 있다.35 비유하자면, 데이터의 특정 부분을 정밀하게 가공하고 분석하는 ’날카로운 분석용 메스’와 같다.</p>
</li>
<li>
<p><strong>Foxglove Studio:</strong> 웹 기술(Electron/TypeScript)을 기반으로 하는 <strong>통합 로보틱스 데이터 플랫폼</strong>을 지향한다. 시계열 플로팅(Plot 패널)은 그 기능의 일부일 뿐이며, RViz를 대체하는 3D 시각화, 이미지, 로그 메시지, 지도 등 다양한 유형의 데이터를 하나의 인터페이스에서 통합적으로 보여주는 데 강점이 있다.36 또한, 공유 레이아웃, 데이터 주석, 클라우드 기반 데이터 관리 등 팀 단위 협업 기능을 강조한다.38 이는 ’다양한 작업을 수행하는 스위스 군용 칼’에 비유할 수 있다.</p>
</li>
</ul>
<p>결론적으로, 두 도구는 경쟁 관계라기보다는 상호 보완적인 관계에 가깝다. 복잡한 시계열 데이터의 수학적 변환과 통계 분석이 필요할 때는 PlotJuggler가 우월한 선택이며, 로봇의 전체적인 상태(3D 공간, 이미지, 시계열)를 종합적으로 파악하고 팀원과 공유해야 할 때는 Foxglove Studio가 더 적합하다.</p>
<h3>7.3  PlotJuggler vs. Grafana: 패러다임의 차이</h3>
<p>Grafana는 시계열 데이터 시각화라는 점에서 PlotJuggler와 공통점이 있지만, 사용 목적과 시스템 아키텍처에서 근본적인 차이를 보인다.</p>
<ul>
<li>
<p><strong>PlotJuggler:</strong> <strong>로컬 파일 및 직접 스트리밍 기반의 대화형 분석 도구</strong>이다. 주된 워크플로우는 개발자의 PC에 있는 로그 파일(<code>rosbag</code>, CSV 등)을 열거나, 개발 중인 로봇/장비에서 직접 UDP, TCP, ZeroMQ 등으로 데이터를 스트리밍받아 <strong>대화형으로 탐색하고 디버깅</strong>하는 것이다.39 즉, “과거의 특정 이벤트가 왜 발생했는가?” 또는 “현재 시스템이 왜 이상하게 동작하는가?“를 파헤치는 탐정의 도구에 가깝다.</p>
</li>
<li>
<p><strong>Grafana:</strong> <strong>서버-클라이언트 구조의 지속적인 모니터링 대시보드</strong>이다. Grafana 자체는 데이터를 저장하지 않는다. 대신 Prometheus, InfluxDB와 같은 시계열 데이터베이스(TSDB)에 지속적으로 수집/저장되는 데이터를 쿼리하여 웹 기반 대시보드에 시각화한다.41 주된 목적은 운영 중인 서버, 서비스, 생산 라인의 상태를</p>
</li>
</ul>
<p><strong>실시간으로 감시하고 이상 징후를 탐지</strong>하는 것이다. 즉, “시스템이 현재 정상 상태인가?“를 24시간 감시하는 관제탑의 도구에 해당한다.</p>
<p>이처럼 PlotJuggler는 단기적이고 심층적인 분석에, Grafana는 장기적이고 광범위한 모니터링에 특화되어 있어, 서로 다른 문제 영역을 해결하는 도구로 이해해야 한다.</p>
<p><strong>Table 2: Feature Comparison of Major Visualization Tools</strong></p>
<table><thead><tr><th>특징 (Feature)</th><th>PlotJuggler</th><th>rqt_plot</th><th>Foxglove Studio</th><th>Grafana</th></tr></thead><tbody>
<tr><td><strong>아키텍처</strong></td><td>데스크톱 (C++/Qt)</td><td>ROS 플러그인 (Python/Qt)</td><td>데스크톱/웹 (Electron/TS)</td><td>웹 서버 (Go/React)</td></tr>
<tr><td><strong>주 사용 사례</strong></td><td>대화형 디버깅, 로그 파일 심층 분석</td><td>ROS 토픽 실시간 간단 모니터링</td><td>통합 데이터 시각화, 팀 협업</td><td>서버/서비스 장기 모니터링</td></tr>
<tr><td><strong>데이터 소스</strong></td><td>파일, 실시간 스트림 (다양한 프로토콜)</td><td>ROS 토픽</td><td>파일, ROS, WebSocket</td><td>시계열 데이터베이스 (Prometheus 등)</td></tr>
<tr><td><strong>3D 시각화</strong></td><td>미지원 (XY 플롯만 가능)</td><td>미지원</td><td>지원 (RViz 기능 일부 포함)</td><td>제한적 (플러그인)</td></tr>
<tr><td><strong>데이터 변환</strong></td><td>매우 강력함 (내장 함수 + Lua 스크립트)</td><td>미지원</td><td>제한적</td><td>강력함 (쿼리 언어)</td></tr>
<tr><td><strong>확장성</strong></td><td>플러그인 (C++)</td><td>미지원</td><td>확장 기능 (TypeScript)</td><td>플러그인 (Go/JS)</td></tr>
<tr><td><strong>협업 기능</strong></td><td>미지원 (레이아웃 파일 공유)</td><td>미지원</td><td>강력함 (공유 레이아웃, 주석 등)</td><td>강력함 (대시보드 공유, 팀 관리)</td></tr>
<tr><td><strong>ROS 지원</strong></td><td>매우 강력함 (ROS1/ROS2, MCAP)</td><td>ROS1 전용</td><td>매우 강력함 (ROS1/ROS2, MCAP)</td><td>미지원 (간접 연동 가능)</td></tr>
</tbody></table>
<h2>8.  실용적 고찰: 장단점 및 해결 과제</h2>
<h3>8.1  핵심 장점 요약</h3>
<p>PlotJuggler는 수년간의 개발과 커뮤니티 피드백을 통해 다듬어진 강력하고 성숙한 도구로, 다음과 같은 명확한 장점을 제공한다.</p>
<ul>
<li>
<p><strong>압도적인 성능:</strong> 컴파일된 C++ 애플리케이션의 효율성과 OpenGL 기반 하드웨어 가속 렌더링의 조합은 대용량 로그 파일을 다룰 때 타의 추종을 불허하는 빠르고 부드러운 사용자 경험을 제공한다. 수백 메가바이트에 달하는 로그 파일을 수 초 내에 로드하고, 수백만 개의 데이터 포인트를 지연 없이 탐색할 수 있는 능력은 심층 분석 작업의 생산성을 극적으로 향상시킨다.18</p>
</li>
<li>
<p><strong>탁월한 직관성:</strong> 잘 설계된 드래그 앤 드롭 인터페이스, 유연한 그리드 레이아웃, 그리고 포괄적인 Undo/Redo 기능은 데이터 시각화와 탐색 과정의 인지적 부담을 크게 줄여준다. 사용자는 복잡한 설정이나 명령어 없이도 데이터에만 집중하여 분석의 흐름을 이어갈 수 있다.2</p>
</li>
<li>
<p><strong>강력한 데이터 조작 능력:</strong> 내장된 다양한 변환 함수와 더불어, Lua 스크립팅 엔진은 거의 무한한 수준의 데이터 조작 유연성을 부여한다. 특히 사용자의 상호작용에 실시간으로 반응하는 ’Reactive Scripts’는 다른 어떤 시각화 도구에서도 찾아보기 힘든 PlotJuggler만의 독보적인 기능으로, 대화형 데이터 분석의 새로운 가능성을 제시한다.18</p>
</li>
<li>
<p><strong>광범위한 범용성:</strong> ROS/ROS2 생태계와의 깊은 통합을 유지하면서도, 플러그인 아키텍처를 통해 MQTT, ZeroMQ, CAN 등 산업계 표준 프로토콜을 폭넓게 지원한다. 이는 PlotJuggler가 로보틱스라는 특정 도메인을 넘어, 임베디드 시스템, IoT, 데이터 과학 등 시계열 데이터를 다루는 모든 분야에서 활용될 수 있는 범용 도구로서의 가치를 지니게 한다.2</p>
</li>
</ul>
<h3>8.2  알려진 한계 및 단점</h3>
<p>모든 도구가 그렇듯 PlotJuggler 역시 몇 가지 한계와 단점을 가지고 있으며, 사용자는 이를 명확히 인지하고 활용 전략을 세워야 한다.</p>
<ul>
<li>
<p><strong>3D 시각화 기능의 부재:</strong> PlotJuggler는 시계열 데이터(1D)와 XY 커브(2D) 시각화에 특화되어 있다. 로봇의 자세, 라이다 포인트 클라우드, 카메라 이미지 등 3차원 공간 데이터를 직접 시각화하는 기능은 제공하지 않는다. 이러한 요구사항을 해결하기 위해서는 RViz나 Foxglove Studio와 같은 3D 시각화 도구와 연동하여 사용해야 한다.35</p>
</li>
<li>
<p><strong>플러그인 의존성과 복잡성:</strong> 특정 데이터 포맷(예: ArduPilot <code>.bin</code> 파일, CAN <code>.dbc</code>)을 지원받기 위해서는 별도의 플러그인을 사용자가 직접 소스 코드로부터 컴파일하고 설치해야 하는 경우가 있다. 이 과정은 C++ 개발 환경에 익숙하지 않은 사용자에게는 상당한 진입 장벽이 될 수 있으며, 특히 Windows 환경에서의 컴파일은 더 복잡하고 까다로울 수 있다.18</p>
</li>
<li>
<p><strong>제한적인 UI/UX:</strong> 다수의 시계열을 입력받아 다수의 시계열을 출력하는 다중 입력-다중 출력(MIMO) 변환과 같은 복잡한 데이터 관계를 설정하는 UI가 아직 직관적이지 않다는 커뮤니티의 피드백이 존재한다. 이는 향후 개선이 필요한 부분으로 지적된다.44</p>
</li>
<li>
<p><strong>세부 시각화 제어 기능의 부족:</strong> Foxglove Studio와 같은 최신 도구와 비교했을 때, XY 플롯에서 X축과 Y축의 비율을 1:1로 고정하는 기능(axis ratio locking)과 같은 일부 세밀한 시각화 제어 옵션이 부족하다는 지적이 있다. 이는 공간적 데이터의 왜곡 없는 표현이 중요한 경우 단점이 될 수 있다.35</p>
</li>
</ul>
<h3>8.3  커뮤니티 보고 이슈 및 해결 방안</h3>
<p>실제 사용 과정에서 커뮤니티를 통해 자주 보고되는 문제들과 그 해결 방안은 다음과 같다.</p>
<ul>
<li>
<p><strong>ROS 커스텀 메시지 인식 불가:</strong> ROS2의 <code>db3</code> 파일을 열거나 실시간 토픽을 구독할 때, 사용자가 정의한 커스텀 메시지 타입을 찾지 못해 파싱에 실패하는 경우가 가장 흔한 문제 중 하나이다. 이는 <code>db3</code> 포맷의 한계에서 기인하며, 해결책은 PlotJuggler를 실행하는 터미널에서 해당 커스텀 메시지 패키지가 포함된 ROS 워크스페이스의 <code>install/setup.bash</code> 파일을 먼저 <code>source</code>하여 환경 변수를 설정해주는 것이다.26 MCAP 포맷을 사용하면 이 문제를 근본적으로 해결할 수 있다.</p>
</li>
<li>
<p><strong>파일 확장자 대소문자 구분:</strong> 일부 데이터 로더 플러그인, 특히 ArduPilot <code>.bin</code> 파일 로더는 파일 확장자의 대소문자를 구분한다. 따라서 <code>LOG.BIN</code>과 같이 대문자로 된 파일을 인식하지 못하는 경우가 발생한다. 이 경우, 파일명을 <code>log.bin</code>과 같이 소문자로 변경해주어야 한다.18</p>
</li>
<li>
<p><strong>데이터 파싱 오류:</strong> 특정 형식의 CSV 파일이나 ULog 파일에서 타임스탬프를 잘못 인식하거나, 특정 행 이후의 데이터를 누락하는 등의 파싱 관련 버그가 GitHub 이슈 트래커를 통해 꾸준히 보고되고 있다. 이러한 문제들은 대부분 커뮤니티의 보고를 통해 빠르게 인지되고 후속 릴리즈에서 지속적으로 수정되고 있다.5</p>
</li>
</ul>
<p>이러한 점들을 종합해 볼 때, PlotJuggler는 “낮은 초기 진입 장벽과 높은 잠재적 숙련도“라는 특징을 보인다. 기본적인 드래그 앤 드롭 기능은 누구나 쉽게 사용할 수 있지만, 플러그인 컴파일, ROS 환경 변수 설정, Lua 스크립팅과 같은 고급 기능을 온전히 활용하기 위해서는 상당한 수준의 기술적 이해가 요구된다. 이는 PlotJuggler가 초심자를 위한 교육용 도구라기보다는, 전문 엔지니어가 자신의 작업 환경에 맞춰 커스터마이징하며 사용하는 강력한 생산성 도구로서의 정체성을 가지고 있음을 시사한다.</p>
<h2>9.  결론 및 미래 전망</h2>
<h3>9.1  종합 평가 및 최적 활용 시나리오</h3>
<p>PlotJuggler는 복잡한 실시간 시스템에서 쏟아져 나오는 방대한 양의 시계열 데이터를 빠르고 직관적으로 탐색하고, Lua 스크립팅을 통해 심층적으로 분석할 수 있게 해주는 독보적인 도구이다. 이는 ’기록과 탐색’이라는 현대적인 디버깅 패러다임을 실천하는 데 있어 필수적인 역할을 수행한다. 성능, 직관성, 확장성이라는 세 가지 핵심 가치를 성공적으로 구현함으로써, PlotJuggler는 단순한 데이터 시각화 유틸리티를 넘어 개발자의 생산성을 근본적으로 향상시키는 분석 플랫폼으로 자리매김했다.</p>
<p>PlotJuggler의 가치를 극대화할 수 있는 최적의 활용 시나리오는 다음과 같다.</p>
<ul>
<li>
<p><strong>로봇 소프트웨어 개발자:</strong> <code>rosbag</code> 파일에 기록된 센서 데이터, 상태 추정 결과, 제어기 입출력 값 등을 분석하여 알고리즘의 문제를 디버깅한다. 실시간으로 발행되는 토픽을 모니터링하며 파라미터를 튜닝하고, Re-publisher 기능을 통해 RViz와 연동하여 3D 정보와 시계열 데이터를 동기화하여 종합적으로 분석한다.</p>
</li>
<li>
<p><strong>임베디드 시스템 엔지니어:</strong> 마이크로컨트롤러(MCU)나 임베디드 보드에서 UART, UDP, TCP 등을 통해 스트리밍되는 실시간 데이터를 PC에서 직접 시각화한다. 펌웨어의 동작을 실시간으로 검증하고 성능을 측정하는 데 활용한다.</p>
</li>
<li>
<p><strong>데이터 과학자 및 연구원:</strong> 대용량의 CSV 또는 ULog 형식의 실험 데이터를 로드하여 초기 탐색적 데이터 분석(EDA)을 신속하게 수행한다. Lua 스크립트를 이용해 복잡한 통계량을 계산하거나 데이터 필터링을 적용하는 등, 외부 도구를 사용하지 않고도 빠른 분석 프로토타이핑을 진행한다.</p>
</li>
</ul>
<h3>9.2  발전 방향: 로드맵과 커뮤니티</h3>
<p>PlotJuggler는 주도적인 개발자와 활발한 커뮤니티에 의해 지속적으로 발전하고 있다. 과거 PlotJuggler 3.0으로의 전환을 논의하며 공개된 로드맵과 최근의 개발 동향을 통해 미래 발전 방향을 예측해 볼 수 있다.44</p>
<ul>
<li>
<p><strong>코어 UX 및 UI 개선:</strong> 사용자가 레이아웃을 더욱 자유롭게 구성할 수 있도록 KDDockWidgets 기반의 새로운 도킹 시스템을 도입하는 등, 핵심적인 사용자 경험을 지속적으로 개선하려는 노력이 이어질 것이다.</p>
</li>
<li>
<p><strong>데이터 모델의 확장:</strong> 현재의 단순 시계열 중심 데이터 모델을 넘어, 이미지, 레이저 스캔, 진단 메시지 등 더 풍부한 의미(semantic)를 갖는 데이터 구조를 지원하려는 계획이 논의되었다. 이는 PlotJuggler의 중요한 진화 방향을 시사한다. 예를 들어, 특정 시점에서 로봇의 토크(시계열)가 급증했을 때, 동일한 타임스탬프의 카메라 이미지(비시계열)를 PlotJuggler 내에서 함께 보여줌으로써 문제의 원인을 직관적으로 파악하게 돕는 것이다. 이러한 기능은 PlotJuggler가 단순한 ’플로터’를 넘어, 다중 모드(multi-modal) 데이터를 시간 축 위에서 동기화하여 보여주는 ’통합 컨텍스트 분석 도구’로 발전할 가능성을 보여준다.</p>
</li>
<li>
<p><strong>MCAP 포맷 지원 강화:</strong> 로보틱스 데이터 표준으로 자리 잡고 있는 MCAP 포맷에 대한 지원을 지속적으로 강화할 것이다. 스트리밍으로 수신한 데이터를 MCAP 파일로 저장하고 다시 로드하는 기능 등이 추가될 수 있으며, 이는 데이터의 기록과 분석 워크플로우를 더욱 유연하게 만들 것이다.25</p>
</li>
</ul>
<h3>9.3  지속 가능성: 오픈소스와 상업적 지원</h3>
<p>PlotJuggler는 핵심 개발자인 Davide Faconti의 열정적인 주도하에 개발이 이루어지고 있으며, 100명이 넘는 기여자가 참여하는 건강한 오픈소스 프로젝트이다.3 프로젝트의 장기적인 지속 가능성을 확보하기 위해, 개인 및 기업 후원자를 위한 GitHub Sponsors 프로그램을 운영하고 있으며, 특정 기능 개발이나 기술 지원이 필요한 기업을 위한 상업적 지원 옵션도 제공한다.3</p>
<p>과거에 논의되었던 ‘SponsorWare’ 모델(후원자에게 신기능을 일정 기간 먼저 제공하는 방식)은 오픈소스 프로젝트가 재정적 기반을 확보하며 지속적으로 성장하기 위한 혁신적인 시도 중 하나였다.46 이러한 노력들은 PlotJuggler가 단기적인 유행에 그치지 않고, 앞으로도 오랫동안 로보틱스 및 데이터 분석 커뮤니티에 기여하는 핵심 도구로 남을 것임을 시사한다. PlotJuggler는 기술적 탁월함과 건강한 생태계, 그리고 지속 가능한 미래를 위한 비전을 모두 갖춘, 앞으로의 발전이 더욱 기대되는 프로젝트이다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>Debugging, robotics and why I built PlotJuggler | by Davide Faconti | Medium, https://medium.com/@facontidavide/debugging-robotics-and-why-i-build-plotjuggler-eb3337ef65a</li>
<li>PlotJuggler, https://plotjuggler.io/</li>
<li>facontidavide/PlotJuggler: The Time Series Visualization Tool that you deserve. - GitHub, https://github.com/facontidavide/PlotJuggler</li>
<li>plotjuggler - ROS Wiki, http://wiki.ros.org/plotjuggler</li>
<li>Issues · facontidavide/PlotJuggler - GitHub, https://github.com/facontidavide/PlotJuggler/issues</li>
<li>PlotJuggler, https://facontidavide.github.io/PlotJuggler/index.html</li>
<li>Basics: how to visualize your data - PlotJuggler, https://facontidavide.github.io/PlotJuggler/visualization_howto/index.html</li>
<li>ROS2 Plotting Tutorial with PlotJuggler - A Simple Way to Plot in ROS - YouTube, https://www.youtube.com/watch?v=MnMGjvYxlUk</li>
<li>Data Sources: Static vs streamed data - PlotJuggler, https://facontidavide.github.io/PlotJuggler/data_sources/index.html</li>
<li>ROS 2 bag data in PlotJuggler - Open Robotics Discourse, https://discourse.openrobotics.org/t/ros-2-bag-data-in-plotjuggler/27072</li>
<li>Plugin to visualize CAN .dbs files in PlotJuggler - GitHub, https://github.com/PlotJuggler/plotjuggler-CAN-dbs</li>
<li>Anyone use PlotJuggler to view canbus data? : r/ROS - Reddit, https://www.reddit.com/r/ROS/comments/17sxr6v/anyone_use_plotjuggler_to_view_canbus_data/</li>
<li>PlotJuggler - GitHub, https://github.com/PlotJuggler</li>
<li>PlotJuggler - Google Sites, https://sites.google.com/site/xinsongyan/blogs/utils/plotjuggler</li>
<li>Plotting live data with Plotjuggler - ROX Docs, https://docs.roxautomation.com/blog/2023/11/20/plotting-live-data-with-plotjuggler/</li>
<li>Plotting live data with Plotjuggler | by Jev Kuznetsov - Medium, https://medium.com/@jev.kuznetsov/plotting-live-data-with-plotjuggler-5c5fbb698477</li>
<li>Many PlotJuggler plugins for ROS and ROS2. - GitHub, https://github.com/PlotJuggler/plotjuggler-ros-plugins</li>
<li>Log inspection with PlotJuggler - Blog - ArduPilot Discourse, https://discuss.ardupilot.org/t/log-inspection-with-plotjuggler/122216</li>
<li>PlotJuggler 04: reactive scripts - Slides, https://slides.com/davidefaconti/plotjuggler-reactive-scripts</li>
<li>Log Analysis using PlotJuggler | PX4 User Guide (v1.14), https://docs.px4.io/v1.14/en/log/plotjuggler_log_analysis.html</li>
<li>plotjuggler_ros: Jazzy 2.3.1 documentation, https://docs.ros.org/en/jazzy/p/plotjuggler_ros/</li>
<li>ROS plugins - PlotJuggler, https://facontidavide.github.io/PlotJuggler/ros_plugins/index.html</li>
<li>ROS Package: plotjuggler_ros, https://index.ros.org/p/plotjuggler_ros/</li>
<li>9 awesome open-source tools to manage, edit, and visualize your rosbags | ROS | Evocargo, https://medium.com/evocargo/9-awesome-open-source-tools-to-manage-your-rosbags-b350fdb651c8</li>
<li>PlotJuggler Adds Support for MCAP - Foxglove, https://foxglove.dev/blog/plotjuggler-adds-support-for-mcap</li>
<li>ROS 2 bags in plotjuggler - Reddit, https://www.reddit.com/r/ROS/comments/119qpbl/ros_2_bags_in_plotjuggler/</li>
<li>plotjuggler 3.9.2 documentation, https://docs.ros.org/en/iron/p/plotjuggler/</li>
<li>PlotJuggler/plotjuggler-sample-plugins: Learn how to … - GitHub, https://github.com/PlotJuggler/plotjuggler-sample-plugins</li>
<li>Plotjuggler Dataflash plotting! - Blog - ArduPilot Discourse, https://discuss.ardupilot.org/t/plotjuggler-dataflash-plotting/73428</li>
<li>PlotJuggler/plotjuggler_msgs - GitHub, https://github.com/PlotJuggler/plotjuggler_msgs</li>
<li>New Package PlotJuggler - ROS robotics news, https://www.ros.org/news/2017/01/new-package-plotjuggler.html</li>
<li>Early preview: PlotJuggler (rqt_plot and rqt_bag on steroids) - ROS …, https://discourse.openrobotics.org/t/early-preview-plotjuggler-rqt-plot-and-rqt-bag-on-steroids/714</li>
<li>Visualize or plot Float32MultiArray data field - Robotics Stack Exchange, https://robotics.stackexchange.com/questions/91515/visualize-or-plot-float32multiarray-data-field</li>
<li>What is your favorite ROS plotting tools - Reddit, https://www.reddit.com/r/ROS/comments/jvyusv/what_is_your_favorite_ros_plotting_tools/</li>
<li>Comparing Robotics Visualization Tools: RViz, Foxglove, Rerun | ReductStore, https://www.reduct.store/blog/comparison-rviz-foxglove-rerun</li>
<li>Foxglove vs. RViz., https://foxglove.dev/blog/foxglove-vs-rviz</li>
<li>Foxglove Studio - visualization and debugging for ROS - Open Robotics Discourse, https://discourse.openrobotics.org/t/foxglove-studio-visualization-and-debugging-for-ros/19627</li>
<li>RViz vs Foxglove, https://foxglove.dev/robotics/rviz-vs-foxglove</li>
<li>PlotJuggler 3: fast and intuitive time series visualization | Hacker News, https://news.ycombinator.com/item?id=25357714</li>
<li>Serial data plotting SW : r/embedded - Reddit, https://www.reddit.com/r/embedded/comments/y1ycih/serial_data_plotting_sw/</li>
<li>Top 18+ Grafana Alternatives for Enhanced Data Visualization - The Knowledge Academy, https://www.theknowledgeacademy.com/blog/grafana-alternatives/</li>
<li>Top 15 data analysis tools for test engineers in 2024 | Renumics GmbH, https://renumics.com/blog/top-15-data-analysis-tools-for-test-engineers-in-2024</li>
<li>Top 11 Grafana Alternatives &amp; Competitors [2025] | SigNoz, https://signoz.io/blog/grafana-alternatives/</li>
<li>Roadmap to PlotJuggler 3.0 - ROS General - Open Robotics Discourse, https://discourse.openrobotics.org/t/roadmap-to-plotjuggler-3-0/14472</li>
<li>Plotjuggler can’t find ROS package - Reddit, https://www.reddit.com/r/ROS/comments/1kvowng/plotjuggler_cant_find_ros_package/</li>
<li>PlotJuggler 3.4.x. Tons of new features - ROS General - Open Robotics Discourse, https://discourse.openrobotics.org/t/plotjuggler-3-4-x-tons-of-new-features/24214</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>