<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS 2 Humble ros2 명령어 매뉴얼</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS 2 Humble ros2 명령어 매뉴얼</h1>
                    <nav class="breadcrumbs"><a href="../index.html">Home</a> / <a href="index.html">ROS2 (Robot Operating System 2)</a> / <span>ROS 2 Humble ros2 명령어 매뉴얼</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS 2 Humble ros2 명령어 매뉴얼</h1>
<h2>1.  <code>ros2</code> CLI 개요</h2>
<p>ROS 2 (Robot Operating System 2) Humble Hawksbill 배포판에서 <code>ros2</code> 명령어는 시스템과 상호작용하기 위한 핵심 진입점이다. 이는 단일 실행 파일이 아니라, 다양한 ROS 2 패키지에 의해 제공되는 하위 명령어들을 동적으로 발견하고 실행하는 확장 가능한 프레임워크이다.1 이 아키텍처는 ROS 2의 모듈식 설계 철학을 반영하며, 사용자가 새로운 패키지를 설치함에 따라 <code>ros2</code>의 기능이 자연스럽게 확장되도록 한다. 예를 들어, 보안 관련 기능을 제공하는 <code>sros2</code> 패키지를 설치하면 <code>ros2 security</code>라는 하위 명령어가 자동으로 추가된다.1</p>
<p>모든 <code>ros2</code> 명령어는 <code>ros2 &lt;동사&gt; &lt;하위 동사&gt; [인자/옵션]</code>의 일관된 구조를 따른다. 명령어의 어느 수준에서든 <code>--help</code> 또는 <code>-h</code> 옵션을 사용하면 해당 명령어에 대한 자세한 사용법과 옵션을 확인할 수 있어, 터미널 내에서 학습과 문제 해결이 용이하다.2</p>
<h3>1.1 ROS 2 데몬: 백그라운드 디스커버리 서비스</h3>
<p>ROS 2는 분산 디스커버리 프로세스를 사용하여 노드들이 서로를 발견하고 연결한다.1 <code>ros2 node list</code>나 <code>ros2 topic list</code>와 같은 시스템 상태 조회 명령어의 응답 속도를 높이기 위해, ROS 2는 백그라운드에서 데몬(daemon) 프로세스를 실행한다. 이 데몬은 ROS 그래프(노드, 토픽, 서비스 등의 연결 정보)에 대한 정보를 캐싱하여, 조회 요청에 신속하게 응답할 수 있도록 돕는다.1</p>
<p>이 데몬 프로세스는 사용자가 <code>ros2 node list</code>와 같은 조회 명령어를 처음 실행할 때 자동으로 시작된다.1 여기서 중요한 점은 데몬이 환경 변수인 <code>ROS_DOMAIN_ID</code>에 종속된다는 사실이다. 각기 다른 <code>ROS_DOMAIN_ID</code>를 사용하는 터미널 환경은 별개의 격리된 데몬 인스턴스를 생성하고 운영한다. 예를 들어, <code>ROS_DOMAIN_ID=10</code>으로 설정된 환경에서 실행 중인 노드들은 <code>ROS_DOMAIN_ID</code>가 설정되지 않은(기본값 0) 터미널에서 <code>ros2 node list</code>를 실행했을 때 보이지 않는다. 이는 명령어가 다른 데몬 인스턴스를 조회하기 때문이며, 복잡한 네트워크 환경에서 시스템을 디버깅할 때 반드시 이해해야 할 핵심적인 동작 방식이다.</p>
<p>사용자는 <code>ros2 daemon</code> 명령어를 통해 이 데몬 프로세스를 직접 제어할 수 있다. <code>ros2 daemon start</code>, <code>ros2 daemon stop</code>, <code>ros2 daemon status</code>와 같은 하위 명령어를 사용하여 데몬을 명시적으로 시작, 중지하거나 상태를 확인할 수 있다.1</p>
<h2>2.  패키지 관리 및 노드 실행</h2>
<p>ROS 2 개발의 기본은 패키지 단위로 코드를 구성하고 노드를 실행하는 것이다. <code>ros2</code> CLI는 패키지를 탐색하고, 패키지 내의 실행 파일을 실행하며, 여러 노드로 구성된 복잡한 시스템을 조율하는 강력한 도구를 제공한다.</p>
<h3>2.1 <code>ros2 pkg</code></h3>
<p><code>ros2 pkg</code> 명령어는 시스템에 설치된 패키지를 탐색하는 데 사용된다.</p>
<ul>
<li>
<p><code>ros2 pkg list</code>: 현재 작업 공간에서 사용 가능한 모든 패키지의 목록을 출력한다.</p>
</li>
<li>
<p><code>ros2 pkg executables &lt;패키지_이름&gt;</code>: 특정 패키지 내에 포함된 모든 실행 파일의 목록을 보여준다. 이 명령어는 <code>ros2 run</code>으로 어떤 노드를 실행할 수 있는지 확인하는 데 매우 유용하다.3</p>
</li>
<li>
<p><code>ros2 pkg create</code>: 새로운 ROS 2 패키지를 생성하는 템플릿을 제공한다. 빌드 타입(예: <code>ament_python</code>, <code>ament_cmake</code>)과 의존성을 지정할 수 있다.2</p>
</li>
</ul>
<h3>2.2 <code>ros2 run</code></h3>
<p><code>ros2 run</code>은 패키지 내의 단일 노드(실행 파일)를 실행하는 가장 기본적인 명령어이다.5</p>
<ul>
<li>
<p><strong>기본 구문</strong>: <code>ros2 run &lt;패키지_이름&gt; &lt;실행_파일_이름&gt;</code></p>
</li>
<li>
<p><strong>사용 예제</strong>: <code>turtlesim</code> 시뮬레이터를 실행하려면 다음 명령어를 사용한다.</p>
<pre><code class="language-Bash">ros2 run turtlesim turtlesim_node
</code></pre>
</li>
</ul>
<pre><code>
이 명령어는 `turtlesim` 패키지에서 `turtlesim_node`라는 실행 파일을 찾아 실행한다.5

- **ROS 인자 전달**: 노드에 파라미터나 리매핑 규칙과 같은 ROS 관련 설정을 전달하려면 `--ros-args` 플래그를 사용한다.

- 노드 이름 리매핑: ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle

이 명령어는 노드의 기본 이름인 /turtlesim을 /my_turtle로 변경하여 실행한다.5

- 파라미터 설정: ros2 run params_pkg robot_node --ros-args -p max_speed:=1.4

-p 또는 --param을 사용하여 노드 시작 시 파라미터 값을 설정할 수 있다.7

### 2.3 `ros2 launch`


`ros2 launch`는 여러 노드와 그 설정을 기술한 런치(launch) 파일을 실행하여 복잡한 시스템 전체를 한 번에 구동하는 명령어이다.8

- **기본 구문**: `ros2 launch &lt;패키지_이름&gt; &lt;런치_파일_이름&gt;`

- **사용 예제**: `turtlesim` 패키지에 포함된 `multisim.launch.py` 런치 파일을 실행하면, 파일에 정의된 대로 두 개의 `turtlesim` 노드가 각각 다른 네임스페이스로 실행된다.

  ```Bash
  ros2 launch turtlesim multisim.launch.py
</code></pre>
<p>이 단일 명령어로 전체 시스템이 구동된다.5</p>
<p>런치 파일은 Python, XML, YAML 형식으로 작성할 수 있으며, 이 중 Python이 가장 강력하고 널리 사용된다.9 런치 시스템은 단순히 프로세스를 실행하는 것을 넘어, 각 노드의 설정을 관리하고, 실행 중인 프로세스의 상태를 모니터링하며, 특정 이벤트에 반응하는 등 시스템 전체를 조율하는 역할을 담당한다.9</p>
<h3>2.4 <code>ros2 run</code> 대 <code>ros2 launch</code> 비교</h3>
<p><code>ros2 run</code>과 <code>ros2 launch</code>의 차이는 단순히 실행하는 노드의 개수에 있지 않다. 이는 두 가지 다른 규모의 작업을 위한 도구로, 하나는 개별 컴포넌트의 테스트와 디버깅을, 다른 하나는 전체 시스템의 통합과 배포를 목표로 한다. <code>ros2 run</code>이 “이 실행 파일을 지금 당장 실행하라“는 명령형(imperative) 접근 방식이라면, <code>ros2 launch</code>는 “이것이 내가 원하는 시스템의 모습이니, 그대로 구성하라“는 선언형(declarative) 접근 방식이다. 이러한 구분은 ROS 2 개발 워크플로우의 핵심적인 부분이며, 개발 생명 주기의 각기 다른 단계에서 사용된다.</p>
<table><thead><tr><th><strong>기능</strong></th><th><strong>ros2 run</strong></th><th><strong>ros2 launch</strong></th></tr></thead><tbody>
<tr><td><strong>범위</strong></td><td>단일 노드 실행</td><td>다수 노드 및 프로세스 동시 실행</td></tr>
<tr><td><strong>설정 방식</strong></td><td>명령줄 인자 (<code>--ros-args</code>)</td><td>런치 파일 (Python, XML, YAML)</td></tr>
<tr><td><strong>프로세스 모니터링</strong></td><td>지원 안 함</td><td>프로세스 상태 모니터링, 자동 재시작 등 지원</td></tr>
<tr><td><strong>파라미터 로딩</strong></td><td>개별 파라미터 설정 가능</td><td>YAML 파일에서 대량의 파라미터 로딩 가능</td></tr>
<tr><td><strong>네임스페이스/리매핑</strong></td><td>명령줄에서 설정</td><td>런치 파일 내에서 체계적으로 관리</td></tr>
<tr><td><strong>주요 사용 사례</strong></td><td>단일 노드의 개발, 빠른 테스트, 디버깅</td><td>복잡한 시스템의 통합, 배포, 재현 가능한 실험</td></tr>
</tbody></table>
<h2>3.  ROS 그래프 탐색 및 디버깅</h2>
<p>실행 중인 ROS 2 시스템의 상태를 파악하고 문제를 진단하기 위해서는 시스템의 내부 구조를 들여다보는(introspection) 도구가 필수적이다. <code>ros2</code> CLI는 현재 활성화된 노드를 식별하고 그들의 상호작용을 분석하는 강력한 기능을 제공한다.</p>
<h3>3.1 <code>ros2 node</code></h3>
<p><code>ros2 node</code>는 실행 중인 노드와 상호작용하기 위한 기본 도구이다.</p>
<ul>
<li>
<p><code>ros2 node list</code>: 현재 ROS 그래프 상에서 활성화되어 있고 데몬이 발견한 모든 노드의 이름을 나열한다. 시스템이 어떤 컴포넌트들로 구성되어 있는지 한눈에 파악할 수 있다.5</p>
<pre><code class="language-Bash">$ ros2 node list
/turtlesim
/teleop_turtle
</code></pre>
</li>
</ul>
<pre><code>
- `ros2 node info &lt;노드_이름&gt;`: 특정 노드에 대한 모든 연결 정보를 종합적으로 보여주는 가장 강력한 디버깅 명령어이다. 이 명령어의 출력은 해당 노드의 소스 코드를 보지 않고도 그 역할을 완벽하게 파악할 수 있는 "연결 명세서"와 같다. 출력에는 다음 정보가 포함된다 5:

- Subscribers: 노드가 구독하는 토픽 목록과 메시지 타입

- Publishers: 노드가 발행하는 토픽 목록과 메시지 타입

- Service Servers: 노드가 제공하는 서비스 목록과 서비스 타입

- Service Clients: 노드가 사용하는 서비스 목록과 서비스 타입

- Action Servers: 노드가 제공하는 액션 목록과 액션 타입

- Action Clients: 노드가 사용하는 액션 목록과 액션 타입

**사용 예제**:

```Bash
$ ros2 node info /turtlesim
/turtlesim
  Subscribers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /turtle1/cmd_vel: geometry_msgs/msg/Twist
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
    /turtle1/color_sensor: turtlesim/msg/Color
    /turtle1/pose: turtlesim/msg/Pose
  Service Servers:
    /clear: std_srvs/srv/Empty
    /kill: turtlesim/srv/Kill
   ...
  Action Servers:
    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute
  Action Clients:
</code></pre>
<p>시스템이 예상과 다르게 동작할 때, 가장 먼저 <code>ros2 node info</code>를 사용하여 관련 노드들의 연결 상태가 의도한 대로 구성되어 있는지 확인하는 것이 표준적인 디버깅 절차이다.</p>
<h3>3.2 <code>ros2 doctor</code></h3>
<p><code>ros2 doctor</code>는 ROS 2 설정의 잠재적인 문제를 진단하는 도구이다. 네트워크 설정, 환경 변수, 시스템 상태 등을 점검하여 일반적인 설정 오류를 찾아내고 해결 방안을 제시한다.1 시스템이 정상적으로 동작하지 않을 때 원인을 빠르게 파악하는 데 도움을 준다.</p>
<h2>4.  통신 인터페이스: 토픽</h2>
<p>토픽(Topic)은 ROS 2에서 비동기적 다대다(many-to-many) 통신을 위한 핵심 메커니즘이다. 노드들은 토픽을 통해 데이터를 발행(publish)하고 구독(subscribe)한다. <code>ros2 topic</code> 명령어는 이러한 데이터 스트림을 실시간으로 검사, 디버깅, 분석할 수 있는 완벽한 도구 모음을 제공한다.</p>
<h3>4.1 <code>ros2 topic</code></h3>
<h4>4.1.1 탐색 (Introspection)</h4>
<ul>
<li>
<p><code>ros2 topic list</code>: 현재 활성화된 모든 토픽의 목록을 보여준다. <code>-t</code> 옵션을 추가하면 각 토픽의 메시지 타입도 함께 표시된다.5</p>
</li>
<li>
<p><code>ros2 topic info &lt;토픽_이름&gt;</code>: 특정 토픽의 메시지 타입, 현재 발행자(publisher)의 수, 구독자(subscriber)의 수를 알려준다.5</p>
</li>
<li>
<p><code>ros2 topic find &lt;메시지_타입&gt;</code>: 주어진 메시지 타입을 사용하는 모든 토픽을 찾아 목록으로 보여준다.5</p>
</li>
</ul>
<h4>4.1.2 데이터 상호작용</h4>
<ul>
<li>
<p><code>ros2 topic echo &lt;토픽_이름&gt;</code>: 특정 토픽을 구독하여 수신되는 메시지를 터미널에 실시간으로 출력한다. 데이터가 올바르게 전송되는지 확인하는 가장 기본적인 디버깅 도구이다.5</p>
</li>
<li>
<p><code>ros2 topic pub &lt;토픽_이름&gt; &lt;메시지_타입&gt; '&lt;인자&gt;'</code>: 명령줄에서 직접 토픽으로 메시지를 발행한다. 메시지 내용은 반드시 YAML 형식의 문자열로 전달해야 한다.1</p>
</li>
<li>
<p><strong>사용 예제</strong>: <code>turtlesim</code>을 원을 그리며 움직이게 하는 명령을 1Hz의 속도로 계속 발행한다.</p>
<pre><code class="language-Bash">ros2 topic pub /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
</code></pre>
</li>
</ul>
<pre><code>
- **주요 옵션**:

- `--once`: 메시지를 한 번만 발행하고 종료한다.5

- `-r &lt;rate&gt;` 또는 `--rate &lt;rate&gt;`: 지정된 주기(Hz)로 메시지를 반복해서 발행한다.

#### 4.1.3 성능 분석


- `ros2 topic hz &lt;토픽_이름&gt;`: 토픽의 메시지 발행 주기(frequency)를 측정하여 평균, 최소, 최대값 등을 보여준다. 센서 드라이버가 지정된 속도로 데이터를 출력하는지 등을 검사하는 데 필수적이다.5

- `ros2 topic bw &lt;토픽_이름&gt;`: 토픽이 사용하는 네트워크 대역폭(bandwidth)을 측정하여 보여준다. 고해상도 카메라나 라이다 데이터가 네트워크에 과도한 부하를 주는지 분석할 수 있다.5

`ros2 topic`의 하위 명령어들은 개별적인 유틸리티가 아니라, 하나의 통합된 진단 워크플로우를 형성한다. 개발자는 이 도구들을 조합하여 디버거나 별도의 코드를 작성하지 않고도 토픽 기반 데이터 스트림의 거의 모든 문제를 진단할 수 있다.

## 5.  통신 인터페이스: 서비스


서비스(Service)는 동기식 요청-응답(request-response) 통신을 위한 모델이다. 클라이언트가 서비스를 요청하면, 서버는 요청을 처리한 후 반드시 하나의 응답을 반환한다. 이는 특정 작업을 수행하고 그 결과를 즉시 받아야 할 때 사용된다.

### 5.1 `ros2 service`


`ros2 service` 명령어는 시스템 내의 서비스를 발견하고, 구조를 확인하며, 직접 호출하는 기능을 제공한다.

#### 5.1.1 탐색 (Introspection)


- `ros2 service list`: 현재 활성화된 모든 서비스의 목록을 보여준다. `-t` 옵션을 사용하면 서비스 타입도 함께 표시된다.5

- `ros2 service type &lt;서비스_이름&gt;`: 특정 서비스의 타입을 확인한다.5

- `ros2 service find &lt;서비스_타입&gt;`: 주어진 서비스 타입을 사용하는 모든 서비스를 찾는다.5

#### 5.1.2 상호작용


- `ros2 service call &lt;서비스_이름&gt; &lt;서비스_타입&gt; '&lt;인자&gt;'`: 명령줄에서 직접 서비스를 호출한다. 요청 인자는 YAML 형식으로 전달한다.5

- **사용 예제 1 (인자 없음)**: `turtlesim`의 배경을 초기화하는 `/clear` 서비스를 호출한다.

    ```Bash
    ros2 service call /clear std_srvs/srv/Empty
</code></pre>
<ul>
<li>
<p><strong>사용 예제 2 (인자 있음)</strong>: 지정된 위치에 새로운 거북이를 생성하는 <code>/spawn</code> 서비스를 호출한다.</p>
<pre><code class="language-Bash">ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'turtle2'}"
</code></pre>
</li>
</ul>
<pre><code>
명령어 실행 결과로 요청 내용과 서버로부터 받은 응답이 모두 터미널에 출력되어, 서비스 호출이 성공했는지와 그 결과를 즉시 확인할 수 있다.5

`ros2 service call` 명령어는 `ros2 interface show` (IX 장에서 설명)와 결합될 때 강력한 개발 도구가 된다. 개발자는 서비스 서버를 구현한 직후, 클라이언트 코드를 한 줄도 작성하지 않고 `ros2 service list -t`로 서비스 이름과 타입을 찾고, `ros2 interface show`로 요청 구조를 확인한 뒤, `ros2 service call`로 모든 기능을 테스트할 수 있다. 이는 개발 속도를 높이고 단위 테스트를 간소화하는 효율적인 워크플로우를 제공한다.

## 6.  통신 인터페이스: 액션


액션(Action)은 완료하는 데 시간이 걸리고, 중간 피드백을 제공하며, 취소가 가능한 비동기 장기 실행 작업을 위해 설계된 통신 모델이다.12 "목표 지점까지 이동", "지정된 각도만큼 회전"과 같은 작업에 적합하다. 액션은 세 가지 주요 부분으로 구성된다: 목표(Goal), 결과(Result), 피드백(Feedback).14

### 6.1 `ros2 action`


`ros2 action` 명령어는 액션의 복잡한 생명주기(목표 전송, 수락 여부 확인, 피드백 수신, 최종 결과 확인) 전체를 명령줄에서 직접 확인하고 제어할 수 있게 해준다.

#### 6.1.1 탐색 (Introspection)


- `ros2 action list`: 현재 활성화된 모든 액션의 목록을 보여준다. `-t` 옵션으로 액션 타입을 함께 확인할 수 있다.15

- `ros2 action info &lt;액션_이름&gt;`: 특정 액션에 대한 액션 서버와 클라이언트의 정보를 보여준다.15

#### 6.1.2 상호작용


- `ros2 action send_goal &lt;액션_이름&gt; &lt;액션_타입&gt; '&lt;목표_값&gt;'`: 액션 서버에 목표를 전송한다. 목표 값은 YAML 형식으로 지정한다.15

- **사용 예제**: `turtlesim`을 1.57 라디안(약 90도) 회전시키는 목표를 전송한다.

    ```Bash
    $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"
    Waiting for an action server to become available...
    Sending goal:
     theta: 1.57
    
    Goal accepted with ID: f8db8f44410849eaa93d3feb747dd444
    
    Result:
     delta: -1.568000316619873
    
    Goal finished with status: SUCCEEDED
</code></pre>
<p>출력은 목표가 고유 ID와 함께 수락되었음을 보여주고, 작업 완료 후 최종 결과와 상태를 반환한다.15</p>
<ul>
<li>
<p><strong>피드백 수신</strong>: <code>--feedback</code> 옵션을 추가하면 액션이 실행되는 동안 서버가 보내는 중간 피드백을 실시간으로 확인할 수 있다. 이는 장기 실행 작업의 진행 상황을 모니터링하는 데 매우 중요하다.</p>
<pre><code class="language-Bash">$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: -1.57}" --feedback

...
Feedback:
remaining: -3.1268222332000732
Feedback:
remaining: -3.1108222007751465
...
Result:
delta: 3.1200008392333984
Goal finished with status: SUCCEEDED
</code></pre>
</li>
</ul>
<pre><code>
이처럼 ros2 action CLI는 액션 프로토콜의 복잡성을 추상화하지 않고 투명하게 보여줌으로써, 상태 머신이나 비동기 작업의 디버깅을 매우 용이하게 만든다.




## 7.  노드 설정 및 관리: 파라미터


파라미터(Parameter)는 코드를 변경하지 않고 노드의 동작을 시작 시점이나 실행 중에 설정하기 위한 메커니즘이다.7 각 노드는 자신만의 파라미터 집합을 가지며, 이를 통해 유연하고 재사용 가능한 노드를 만들 수 있다.

### 7.1 `ros2 param`


`ros2 param` 명령어는 실행 중인 노드의 파라미터를 동적으로 조회하고 수정하는 모든 기능을 제공한다.

#### 7.1.1 탐색 (Introspection)


- `ros2 param list &lt;노드_이름&gt;`: 특정 노드가 가진 모든 파라미터의 이름을 나열한다.17

- `ros2 param get &lt;노드_이름&gt; &lt;파라미터_이름&gt;`: 특정 파라미터의 현재 값을 조회한다.17

- `ros2 param describe &lt;노드_이름&gt; &lt;파라미터_이름&gt;`: 파라미터에 대한 설명, 타입, 제약 조건 등의 상세 정보를 보여준다.18


#### 7.1.2 조작 (Manipulation)


- `ros2 param set &lt;노드_이름&gt; &lt;파라미터_이름&gt; &lt;값&gt;`: 실행 중인 노드의 파라미터 값을 변경한다. 로봇의 동작을 실시간으로 튜닝할 때 매우 유용하다.17

  ```bash
    ros2 param set /turtlesim background_r 150
</code></pre>
<ul>
<li>
<p><code>ros2 param dump &lt;노드_이름&gt;</code>: 특정 노드의 모든 파라미터와 그 값을 YAML 형식으로 터미널에 출력한다. 이 출력을 파일로 리디렉션하여 현재 설정을 저장할 수 있다.17</p>
<pre><code class="language-bash">ros2 param dump /turtlesim &gt; turtlesim_params.yaml
</code></pre>
</li>
</ul>
<pre><code>
- `ros2 param load &lt;노드_이름&gt; &lt;파라미터_파일&gt;`: YAML 파일에 저장된 파라미터 값들을 실행 중인 노드에 로드한다.17

`dump`와 `load` 명령어는 단순한 설정 관리를 넘어, 시스템 상태를 캡처하고 재현하는 강력한 워크플로우를 형성한다. 예를 들어, 로봇 내비게이션 시스템의 복잡한 파라미터들을 `ros2 param set`으로 실시간 튜닝하여 최적의 성능을 찾은 뒤, `ros2 param dump`로 그 상태를 그대로 파일에 저장할 수 있다. 이 파일은 버전 관리 시스템에 포함시키고 런치 파일에서 로드하여, 언제나 최적화된 상태로 시스템을 시작할 수 있게 한다. 이 **실시간 튜닝 → 상태 캡처(`dump`) → 영구 설정(`load`)** 의 흐름은 ROS 2에서 매우 효과적인 핵심 엔지니어링 패턴이다.

## 8.  데이터 기록 및 재생: Bag


ROS Bag은 ROS 메시지 데이터를 파일에 저장하고 재생하기 위한 표준 메커니즘이다.19 이는 오프라인 데이터 분석, 알고리즘 테스트, 실제 하드웨어 없이 개발을 진행하는 등 로봇 공학 연구 및 개발의 모든 단계에서 필수적인 도구이다.20

### 8.1 `ros2 bag`


`ros2 bag` 명령어는 bag 파일을 생성, 재생, 검사하는 기능을 제공한다.

- `ros2 bag record &lt;토픽_목록&gt;`: 지정된 토픽들의 메시지를 bag 파일로 기록한다.

- **사용 예제**: `/turtle1/cmd_vel` 토픽을 기록한다.

    ```bash
    ros2 bag record /turtle1/cmd_vel
</code></pre>
<ul>
<li>
<p><strong>주요 옵션</strong>:</p>
</li>
<li>
<p><code>-a</code> 또는 <code>--all</code>: 모든 활성화된 토픽을 기록한다.</p>
</li>
<li>
<p><code>-o &lt;파일_이름&gt;</code>: bag 파일의 저장 경로와 이름을 지정한다.20</p>
</li>
<li>
<p><code>-b &lt;크기&gt;</code>: 파일이 지정된 크기(바이트 단위)에 도달하면 분할한다.19</p>
</li>
<li>
<p><code>-d &lt;시간&gt;</code>: 지정된 시간(초 단위)마다 파일을 분할한다.19</p>
</li>
<li>
<p><code>--compression-mode</code> 및 <code>--compression-format</code>: 데이터를 압축하여 저장한다.19</p>
</li>
<li>
<p><code>ros2 bag play &lt;bag_파일_이름&gt;</code>: bag 파일에 기록된 데이터를 원래의 타임스탬프에 맞춰 해당 토픽으로 다시 발행한다.21 이를 통해 과거의 특정 상황을 그대로 재현할 수 있다.</p>
</li>
<li>
<p><code>ros2 bag info &lt;bag_파일_이름&gt;</code>: bag 파일에 대한 메타데이터를 보여준다. 포함된 토픽 목록, 각 토픽의 메시지 수와 타입, 총 기록 시간, 파일 크기 등의 정보를 확인할 수 있다.20</p>
</li>
</ul>
<p>ROS Bag은 단순한 로그 파일이 아니다. 이는 실제 환경에서 발생한 상호작용의 고충실도(high-fidelity) 기록이며, 이를 재생함으로써 현실 세계 이벤트의 결정론적인 “디지털 트윈(digital twin)“을 생성할 수 있다. 개발자는 현장에서 로봇의 복잡한 센서 데이터 스트림을 한 번 기록한 후, 연구실로 돌아와 해당 bag 파일을 수백 번 재생하며 알고리즘을 수정하고 테스트할 수 있다. 이 기능은 알고리즘 개발을 물리적 하드웨어의 가용성으로부터 분리시켜 개발 주기를 획기적으로 단축시킨다.</p>
<h2>9.  인터페이스 정의 확인</h2>
<p>ROS 2의 모든 통신(토픽, 서비스, 액션)은 인터페이스(Interface) 정의 파일을 기반으로 한다. 이 파일들은 <code>.msg</code> (메시지), <code>.srv</code> (서비스), <code>.action</code> (액션) 확장자를 가지며, 통신에 사용될 데이터 구조를 ROS 2 IDL(Interface Definition Language)로 기술한다.23</p>
<h3>9.1 <code>ros2 interface</code></h3>
<p><code>ros2 interface</code> 명령어는 이러한 인터페이스의 정의를 탐색하고 확인하는 “메타 도구“이다. 이 명령어를 통해 토픽, 서비스, 액션이 별개의 기술이 아니라, 동일한 인터페이스 정의 시스템 위에 구축된 각기 다른 의미론적 패턴임을 이해할 수 있다.</p>
<h4>9.1.1 탐색 (Discovery)</h4>
<ul>
<li>
<p><code>ros2 interface list</code>: 사용 가능한 모든 인터페이스 타입의 목록을 보여준다.23</p>
</li>
<li>
<p><code>ros2 interface packages</code>: 인터페이스를 제공하는 모든 패키지의 목록을 보여준다.23</p>
</li>
<li>
<p><code>ros2 interface package &lt;패키지_이름&gt;</code>: 특정 패키지 내의 모든 인터페이스를 나열한다.23</p>
</li>
</ul>
<h4>9.1.2 정의 확인 (Inspection)</h4>
<ul>
<li>
<p><code>ros2 interface show &lt;인터페이스_타입&gt;</code>: 인터페이스의 소스 정의를 그대로 출력하는 핵심 명령어이다.</p>
</li>
<li>
<p><strong>메시지 (<code>.msg</code>)</strong>: 필드명과 데이터 타입의 목록을 보여준다.</p>
<pre><code>$ ros2 interface show geometry_msgs/msg/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
</code></pre>
</li>
</ul>
<pre><code>
- **서비스 (`.srv`)**: 요청(request) 부분의 필드, `---` 구분자, 그리고 응답(response) 부분의 필드를 보여준다.5

    ```Bash
    $ ros2 interface show turtlesim/srv/Spawn
    float32 x
    float32 y
    float32 theta
    string name # Optional. A unique name will be created and returned if this is empty
    ---
    string name
</code></pre>
<ul>
<li>
<p><strong>액션 (<code>.action</code>)</strong>: 목표(Goal), <code>---</code> 구분자, 결과(Result), <code>---</code> 구분자, 피드백(Feedback) 순으로 구조를 보여준다.23</p>
<pre><code class="language-Bash">$ ros2 interface show turtlesim/action/RotateAbsolute
# The desired heading in radians
float32 theta
---
# The angular displacement in radians to achieve the goal
float32 delta
---
# The remaining rotation in radians
float32 remaining
</code></pre>
</li>
</ul>
<pre><code>
이처럼 `ros2 interface show`는 하나의 명령어로 모든 종류의 통신 데이터 구조를 일관된 방식으로 확인할 수 있게 하여, ROS 2 시스템의 기반을 이해하는 데 필수적인 역할을 한다.

## 10. 부록: 주요 명령어 요약표


이 표는 숙련된 사용자가 특정 작업에 필요한 명령어 구문을 빠르게 참조할 수 있도록 주요 `ros2` 명령어와 일반적인 사용 예제를 요약한 것이다.

| **작업 목표**                   | **명령어**                 | **사용 예제**                                                                     |
| --------------------------- | ----------------------- | ----------------------------------------------------------------------------- |
| **실행 및 관리**                 |                         |                                                                               |
| 실행 가능한 노드 확인                | `ros2 pkg executables`  | `ros2 pkg executables turtlesim`                                              |
| 단일 노드 실행                    | `ros2 run`              | `ros2 run turtlesim turtlesim_node`                                           |
| 시스템 전체 실행                   | `ros2 launch`           | `ros2 launch my_pkg my_launch.py`                                             |
| **그래프 탐색**                  |                         |                                                                               |
| 실행 중인 노드 목록 확인              | `ros2 node list`        | `ros2 node list`                                                              |
| 특정 노드의 상세 정보 확인             | `ros2 node info`        | `ros2 node info /turtlesim`                                                   |
| 활성화된 토픽 목록 확인               | `ros2 topic list`       | `ros2 topic list -t`                                                          |
| 활성화된 서비스 목록 확인              | `ros2 service list`     | `ros2 service list -t`                                                        |
| 활성화된 액션 목록 확인               | `ros2 action list`      | `ros2 action list -t`                                                         |
| **데이터 상호작용**                |                         |                                                                               |
| 토픽 데이터 실시간 확인               | `ros2 topic echo`       | `ros2 topic echo /scan`                                                       |
| 토픽에 메시지 발행                  | `ros2 topic pub`        | `ros2 topic pub /cmd_vel geometry_msgs/Twist "{...}" --once`                  |
| 서비스 호출                      | `ros2 service call`     | `ros2 service call /clear std_srvs/srv/Empty`                                 |
| 액션 목표 전송                    | `ros2 action send_goal` | `ros2 action send_goal /navigate nav2_msgs/NavigateToPose "{...}" --feedback` |
| **파라미터 관리**                 |                         |                                                                               |
| 노드의 파라미터 목록 확인              | `ros2 param list`       | `ros2 param list /my_node`                                                    |
| 파라미터 값 변경                   | `ros2 param set`        | `ros2 param set /my_node use_sim_time true`                                   |
| 파라미터 설정을 파일로 저장             | `ros2 param dump`       | `ros2 param dump /my_node &gt; params.yaml`                                      |
| **데이터 기록**                  |                         |                                                                               |
| 모든 토픽을 bag 파일로 기록           | `ros2 bag record`       | `ros2 bag record -a -o my_data`                                               |
| bag 파일 재생                   | `ros2 bag play`         | `ros2 bag play my_data`                                                       |
| bag 파일 정보 확인                | `ros2 bag info`         | `ros2 bag info my_data`                                                       |
| **인터페이스 확인**                |                         |                                                                               |
| 인터페이스(msg/srv/action) 구조 확인 | `ros2 interface show`   | `ros2 interface show sensor_msgs/msg/LaserScan`                               |

## 11. 참고 자료


1. Introspection with command line tools — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Concepts/Basic/About-Command-Line-Tools.html
2. ROS2 Installation — ROS2 Tutorial July 26, 2025 documentation, https://ros2-tutorial.readthedocs.io/en/humble/installation.html
3. What are the differences between exec and name in ros2 launch file? - Stack Overflow, https://stackoverflow.com/questions/75451788/what-are-the-differences-between-exec-and-name-in-ros2-launch-file
4. ROS2 Tutorial July 26, 2025 documentation, https://ros2-tutorial.readthedocs.io/en/humble/
5. Beginner: CLI tools — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools.html
6. 2. Installing Humble in ROS2 - Yahboom, [https://www.yahboom.net/public/upload/upload-html/1757645654/2.ROS2%20install%20Humble.html](https://www.yahboom.net/public/upload/upload-html/1757645654/2.ROS2%20install%20Humble.html)
7. How to Use ROS 2 Parameters - Foxglove, https://foxglove.dev/blog/how-to-use-ros2-parameters
8. Launch — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Concepts/Basic/About-Launch.html
9. Creating a launch file — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Creating-Launch-Files.html
10. ROS 2 Launch System - ROS2 Design, https://design.ros2.org/articles/roslaunch.html
11. Tutorials — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials.html
12. [ROS2 How-to] #2 - Create a ROS2 action server - The Construct, https://www.theconstruct.ai/ros2-how-to-2-create-a-ros2-action-server/
13. ROS2 Part 10 - ROS2 Actions in Python and C++ - RoboticsUnveiled, https://www.roboticsunveiled.com/ros2-actions-in-python-and-cpp/
14. Actions - ROS2 Design, https://design.ros2.org/articles/actions.html
15. Understanding actions — ROS 2 Documentation: Humble ..., https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html
16. Parameters — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Concepts/Basic/About-Parameters.html
17. Understanding parameters — ROS 2 Documentation: Humble documentation, https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters.html
18. Using the ros2 param command-line tool - ROS documentation, https://docs.ros.org/en/humble/How-To-Guides/Using-ros2-param.html
19. ros2/rosbag2 - GitHub, https://github.com/ros2/rosbag2
20. ros2 bag - Save and Replay Topic Data - The Robotics Back-End, https://roboticsbackend.com/ros2-bag-save-and-replay-topic-data/
21. Recording and playing back data — ROS 2 Documentation, https://docs.ros.org/en/rolling/Tutorials/Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data.html
22. Create and Replay a ROS2 Bag - YouTube, https://www.youtube.com/watch?v=a-O1qM9_S7k
23. ROS2 Interfaces (ros2 interface) - (Murilo's) ROS2 Tutorial - Read the Docs, https://ros2-tutorial.readthedocs.io/en/latest/interfaces.html
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>