<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:ROS 2와 네이티브 DDS 상호운용성</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>ROS 2와 네이티브 DDS 상호운용성</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">ROS2 (Robot Operating System 2)</a> / <a href="index.html">ROS2 RMW</a> / <span>ROS 2와 네이티브 DDS 상호운용성</span></nav>
                </div>
            </header>
            <article>
                <h1>ROS 2와 네이티브 DDS 상호운용성</h1>
<h3>0.1 요약 (Executive Summary)</h3>
<p>본 안내서는 “ROS 2에서 네이티브 DDS(Data Distribution Service) 메시지를 직접 구독하거나 발행할 수 있는가?“라는 질문에 대한 심층적인 기술 분석을 제공합니다. 이 질문에 대한 명확한 답은 ’가능하다’입니다. 이러한 기능은 ROS 2의 부가적인 특징이 아니라, DDS 표준 위에 시스템을 구축한 ROS 2의 근본적인 아키텍처 설계에서 비롯된 필연적인 결과입니다.1</p>
<p>그러나 ROS 2와 순수(Native) DDS 애플리케이션 간의 상호운용성을 달성하는 과정은 간단하지 않으며, ROS 2가 DDS 위에 추가한 추상화 계층과 규약에 대한 정확한 이해를 요구합니다. 핵심적인 과제는 두 환경 간의 토픽 이름 지정 규칙, 데이터 타입 정의(IDL), 그리고 서비스 품질(QoS) 프로파일의 차이를 해소하는 것입니다.4</p>
<p>본 안내서의 주요 분석 결과는 다음과 같습니다.</p>
<ul>
<li><strong>ROS 미들웨어(RMW) 계층의 역할:</strong> RMW 계층은 다양한 DDS 벤더를 지원하는 유연성을 제공하는 핵심 요소인 동시에, 성능 오버헤드의 주된 원인이 되기도 합니다.3</li>
<li><strong>상호운용성의 핵심 요건:</strong> 성공적인 상호운용성은 토픽 이름 변환 규칙(<code>rt/</code>), 타입 이름 변환 규칙(<code>::msg::dds_::&lt;Type&gt;_</code>), 그리고 QoS 호환성을 보장하는 세심한 설정에 달려 있습니다.8</li>
<li><strong>고급 성능 최적화:</strong> Loaned Message API를 통한 제로카피(Zero-Copy) 통신이나 네이티브 DDS API 직접 접근과 같은 고급 기술은 표준 RMW의 오버헤드를 우회하여, 핵심적인 애플리케이션에서 상당한 성능 향상을 제공합니다.10</li>
<li><strong>대규모 시스템 확장성:</strong> 대규모 또는 무선 연결 시스템은 네트워크 트래픽을 관리하고 안정적인 노드 발견(Discovery)을 보장하기 위해 Discovery Server, DDS Router와 같은 특화된 DDS 기능이나 Zenoh와 같은 대체 미들웨어를 통해 큰 이점을 얻을 수 있습니다.12</li>
</ul>
<p>본 안내서는 시스템 아키텍트와 엔지니어가 이러한 복잡성을 해결할 수 있도록, 기초 이론, 실제 구현 가이드, 성능 최적화 전략, 그리고 배포 권장 사항을 포함하는 포괄적인 전문가 수준의 가이드를 제공하는 것을 목적으로 합니다.</p>
<hr />
<h2>1.  ROS 2와 DDS의 공생적 아키텍처</h2>
<p>이 섹션에서는 ROS 2가 단순히 DDS와 ’호환’되는 것이 아니라, 근본적으로 DDS 기반 시스템이라는 기초 이론을 확립합니다.</p>
<h3>1.1  ROS 1에서 DDS 기반으로의 전략적 전환</h3>
<p>ROS 1은 중앙 집중형 <code>roscore</code>(마스터 노드)를 사용하는 맞춤형 TCP 기반 프로토콜(TCPROS)을 활용했습니다. 이는 다중 로봇 시스템, 실시간 성능 보장, 그리고 불안정한 네트워크 환경에서의 배포에 있어 본질적인 한계를 드러냈습니다.15</p>
<p>ROS 2를 DDS 위에 구축하기로 한 결정은 산업적으로 검증된 DDS의 강력한 기능들을 상속받기 위한 의도적인 아키텍처 선택이었습니다. DDS는 분산형 P2P(Peer-to-Peer) 노드 발견 메커니즘, 실시간 및 신뢰성 있는 통신을 위한 풍부한 서비스 품질(QoS) 정책, 그리고 항공우주 및 금융과 같은 핵심 시스템에서 검증된 견고한 표준 기반을 제공합니다.2 이러한 특징들은 ROS 2를 상용 수준의 복잡한 시스템 배포에 본질적으로 더 적합하게 만듭니다.18</p>
<h3>1.2  ROS 2 통신 스택: 계층적 추상화</h3>
<p>ROS 2의 통신은 여러 추상화 계층으로 구성되어 있으며, 각 계층은 특정 역할을 수행합니다.</p>
<ul>
<li><strong>사용자 대면 API (<code>rclcpp</code>, <code>rclpy</code>):</strong> 최상위 계층으로, C++과 Python에서 노드, 퍼블리셔, 서브스크라이버와 같은 친숙한 ROS 개념을 제공합니다.19 사용자는</li>
</ul>
<p><code>create_publisher()</code>나 <code>create_subscription()</code>과 같은 메서드를 통해 통신 객체를 생성합니다.21</p>
<ul>
<li>
<p><strong>ROS 클라이언트 라이브러리 (RCL):</strong> C 언어 API로, ROS 개념(예: 노드 및 그래프 관리)의 공통 로직을 구현하며 미들웨어에 독립적인 형태로 설계되었습니다.20</p>
</li>
<li>
<p><strong>ROS 미들웨어 인터페이스 (RMW):</strong> 핵심적인 추상화 계층입니다. <code>rmw</code>는 <code>rmw_create_publisher</code>, <code>rmw_publish</code>와 같은 미들웨어 기본 기능에 대한 일반적인 C API를 정의합니다. 이 추상화를 통해 ROS 2는 벤더별 세부 사항을 상위 계층에 노출하지 않고도 다양한 DDS 구현을 지원할 수 있습니다.3</p>
</li>
<li>
<p><strong>RMW 구현체 (예: <code>rmw_fastrtps_cpp</code>, <code>rmw_cyclonedds_cpp</code>):</strong> 일반 RMW API 호출을 특정 DDS 벤더(예: eProsima Fast DDS, Eclipse Cyclone DDS)의 특정 API 호출로 변환하는 얇은 어댑터 또는 “심(shim)” 계층입니다.23 이 계층이 DDS 라이브러리와 직접 상호작용합니다.</p>
</li>
<li>
<p><strong>DDS/RTPS 계층:</strong> RTPS(Real-Time Publish-Subscribe) 프로토콜을 기반으로 직렬화, 노드 발견, 전송 등 실제 유선 상의 통신을 처리하는 기본 미들웨어입니다.1</p>
</li>
</ul>
<h3>1.3  개념 매핑: ROS 2 프리미티브에서 DDS 엔티티로</h3>
<p>ROS 2의 통신 개념은 DDS의 엔티티와 직접적으로 매핑됩니다.</p>
<ul>
<li><strong>ROS 노드 (Node):</strong> DDS의 <code>DomainParticipant</code>에 개념적으로 매핑됩니다. Participant는 DDS 통신 도메인으로의 진입점 역할을 합니다.27 기본적으로 각 ROS 2 프로세스는 단일 DDS Participant를 생성합니다.</li>
<li><strong>ROS 토픽/서비스/액션:</strong> 이들은 하나 이상의 기본 DDS <code>Topic</code>에 매핑됩니다. DDS 토픽은 이름, 데이터 타입, 그리고 연관된 QoS 정책의 고유한 조합입니다.1</li>
<li><strong>ROS 퍼블리셔/서브스크라이버:</strong> 각각 DDS의 <code>DataWriter</code>와 <code>DataReader</code> 엔티티에 매핑됩니다. <code>DataWriter</code>는 토픽에 데이터를 보내는 역할을, <code>DataReader</code>는 데이터를 수신하는 역할을 담당합니다.3</li>
</ul>
<p>이러한 아키텍처는 ROS 2 애플리케이션이 본질적으로 DDS 애플리케이션임을 의미하며, 이는 네이티브 DDS와의 상호운용성의 기반이 됩니다. 하지만 이 구조는 동시에 몇 가지 중요한 기술적 함의를 내포합니다.</p>
<p>첫째, RMW는 필연적으로 “새는 추상화(leaky abstraction)“가 됩니다. RMW의 공식적인 목표는 미들웨어에 독립적이고 DDS의 복잡성을 숨기는 것입니다.3 그러나 고급 QoS, 전송 계층 선택, 보안과 같은 강력한 DDS 기능들은 실제 애플리케이션에서 매우 중요하며, 이는 대부분 벤더에 특화되어 있습니다.4 이러한 기능들을 활용하기 위해, 개발자들은 종종 RMW 추상화를 우회하여 XML 파일이나 환경 변수를 통해 기본 DDS 벤더를 직접 설정해야 합니다.4 더욱이, 네이티브 DDS와의 상호운용성을 위해서는 이름 변환(name mangling)과 같은 ROS 2의 특정 DDS 구현 세부 사항을 알아야만 합니다.4 이는 근본적인 긴장 관계를 만듭니다. 즉, RMW는 기능 접근성을 희생하여 이식성을 제공하지만, 실제 배포 환경에서는 개발자가 추상화를 깨고 벤더별 세부 사항을 다루도록 강요받는 경우가 많습니다. 이러한 ’누수’는 결함이라기보다는 사용 편의성과 기본 미들웨어의 강력한 기능 사이의 균형을 맞추기 위한 필연적인 절충안입니다.34</p>
<p>둘째, ROS 2의 아키텍처는 기본적으로 “이중 직렬화(double serialization)” 오버헤드를 수반합니다. ROS 2 애플리케이션은 C++ 구조체나 Python 클래스와 같은 언어별 메시지 객체를 다룹니다.21</p>
<p><code>publish()</code>가 호출되면 데이터는 클라이언트 라이브러리(예: <code>rclcpp</code>)에서 RMW 계층으로 흐릅니다.3 RMW 구현체는 이 ROS 데이터 구조를 기본 DDS 벤더가 이해할 수 있는 형식으로 변환해야 하는데, 이 과정에서 종종 일반 바이트 버퍼로의 직렬화 단계가 포함됩니다.3 그 후 DDS 미들웨어는 이 버퍼를 받아 다시 유선 상의 RTPS 형식으로 자체 직렬화를 수행합니다.6 이러한 2단계 프로세스(ROS 객체 -&gt; 중간 버퍼 -&gt; RTPS 유선 형식)는 네이티브 DDS 애플리케이션이 데이터 객체에서 유선 형식으로 직접 직렬화하는 것에 비해 본질적으로 지연 시간과 CPU 오버헤드를 발생시킵니다. 이 아키텍처적 오버헤드는 첫 번째 복사를 제거하려는 Loaned Messages API와 같은 고급 기능의 주된 동기가 됩니다.7</p>
<hr />
<h2>2.  격차 해소: 네이티브 DDS와 ROS 2 상호운용성을 위한 실용 가이드</h2>
<p>이 섹션은 통신을 성공시키기 위한 실행 가능한 단계를 제공하는 핵심적인 “how-to” 매뉴얼입니다.</p>
<h3>2.1  핵심 과제: 임피던스 불일치 극복</h3>
<p>네이티브 DDS 애플리케이션과 ROS 2 애플리케이션은 동일한 DDS 벤더와 토픽 이름을 사용하더라도 기본적으로 통신하지 않습니다.4 이는 상호운용성이 자동으로 이루어지지 않음을 의미합니다.</p>
<p>RMW 계층은 DDS 전역 데이터 공간 내에 ROS 전용 네임스페이스를 생성하기 위해 의도적으로 토픽 이름과 타입 이름을 ’변환(mangle)’하거나 수정합니다. 이는 의도치 않은 교차 통신을 방지하지만, 의도적인 통신을 위해서는 명시적인 설정이 필요합니다.8 성공적인 상호운용을 위해서는 <strong>토픽 이름</strong>, <strong>데이터 타입</strong>, 그리고 <strong>QoS 프로파일</strong>이라는 세 가지 핵심 요소를 일치시켜야 합니다.</p>
<h3>2.2  1단계: 토픽 이름 일치화</h3>
<p>ROS 2는 사용자 대면 토픽 이름에 특정 접두사를 추가하여 최종 DDS 토픽 이름을 생성합니다. 이는 초보자들이 가장 흔하게 겪는 실패 지점입니다.4</p>
<ul>
<li><strong>표준 토픽 (Pub/Sub):</strong> <code>rt/</code> 접두사가 붙습니다. ROS 2 토픽 <code>/chatter</code>는 DDS 토픽 <code>rt/chatter</code>가 됩니다.4</li>
<li><strong>서비스 (Services):</strong> 서비스는 두 개의 DDS 토픽을 사용하여 구현됩니다. ROS 2 서비스 <code>/add_two_ints</code>는 요청을 위한 <code>rq/add_two_ints</code>와 응답을 위한 <code>rr/add_two_ints</code>라는 두 개의 DDS 토픽으로 변환됩니다.33</li>
<li><strong>액션 (Actions):</strong> 액션은 목표, 피드백, 결과, 상태 등을 위해 여러 토픽을 사용하며, 모두 특정 접두사를 가집니다.37</li>
</ul>
<p>실제 구현 시, 네이티브 DDS 애플리케이션은 ROS 2와 통신하기 위해 변환된 토픽 이름(예: <code>rt/chatter</code>)으로 <code>DataWriter</code> 또는 <code>DataReader</code>를 생성해야 합니다.</p>
<h3>2.3  2단계: 데이터 타입 호환성 보장</h3>
<ul>
<li><strong>IDL을 기준으로:</strong> ROS 2는 인터페이스 정의를 위해 <code>.msg</code>, <code>.srv</code>, <code>.action</code> 파일을 사용하지만, 이들은 빌드 과정에서 궁극적으로 OMG의 IDL(Interface Definition Language) 파일로 변환됩니다.25</li>
<li><strong>ROS 2 IDL 서브셋:</strong> ROS 2는 전체 IDL 사양의 일부만 지원합니다. 특히, <code>.msg</code> 정의에서 <code>enum</code>이나 <code>inheritance</code>와 같은 기능은 지원하지 않으므로, 이러한 기능을 사용하는 레거시 DDS 시스템과 연동할 때 문제가 될 수 있습니다.6 지원되는 서브셋은 관련 설계 문서에 명시되어 있습니다.41</li>
<li><strong>타입 이름 변환:</strong> 토픽 이름과 유사하게, ROS 2는 타입 이름도 변환합니다. ROS 2 메시지 <code>std_msgs/msg/String</code>은 DDS 타입 이름 <code>std_msgs::msg::dds_::String_</code>이 됩니다.9 이 특정 형식을 네이티브 DDS Participant에 등록해야 합니다.</li>
<li><strong>IDL 생성 방법:</strong></li>
</ul>
<ol>
<li>ROS 2는 모든 메시지 패키지에 대해 <code>.idl</code> 파일을 자동으로 생성합니다 (예: <code>/opt/ros/&lt;distro&gt;/share/&lt;pkg_name&gt;/msg/dds_connext/</code> 경로에서 찾을 수 있음).</li>
<li>사용자 정의 메시지의 경우, <code>rosidl_adapter</code> 패키지의 <code>msg2idl.py</code> 스크립트를 사용하여 <code>.msg</code> 파일을 <code>.idl</code>로 수동 변환할 수 있습니다.43</li>
<li>네이티브 DDS 애플리케이션은 이와 정확히 동일한 IDL 정의를 사용해야 합니다. 벤더별 코드 생성 도구(예: Connext의 <code>rtiddsgen</code>, Fast DDS의 <code>fastddsgen</code>)를 사용하여 이 IDL로부터 필요한 C++ 또는 다른 언어의 소스 파일을 생성합니다.9</li>
</ol>
<h3>2.4  3단계: 서비스 품질(QoS) 프로파일 일치</h3>
<ul>
<li><strong>통신의 계약:</strong> DDS의 QoS 정책은 <code>DataWriter</code>와 <code>DataReader</code> 간의 ’계약’을 형성합니다. 연결이 성립되려면 정책들이 호환되어야 합니다. 일반적으로 Writer가 제공하는 정책은 Reader가 요청하는 정책보다 크거나 같아야 합니다.15</li>
<li><strong>일반적인 불일치:</strong> <code>ros2 topic list</code>에서는 토픽이 보이지만 <code>ros2 topic echo</code>에서는 데이터가 보이지 않는 “조용한 실패“의 흔한 원인입니다. 주요 불일치 항목은 다음과 같습니다.</li>
<li><strong>신뢰성 (Reliability):</strong> <code>RELIABLE</code> 대 <code>BEST_EFFORT</code>. 신뢰성 있는 Writer는 최선형 Reader에게 데이터를 공급할 수 있지만, 그 반대는 불가능합니다.</li>
<li><strong>지속성 (Durability):</strong> <code>VOLATILE</code> 대 <code>TRANSIENT_LOCAL</code>. <code>TRANSIENT_LOCAL</code> Writer는 신뢰성 종류도 일치하지 않는 한 <code>VOLATILE</code> Reader와 연결되지 않을 수 있습니다. 이는 미묘하지만 중요한 지점입니다.</li>
<li><strong>데이터 표현 (Data Representation, X-Types):</strong> CycloneDDS 상호운용성에서 발견된 핵심 문제입니다. ROS 2 RMW는 더 단순한 CDR 인코딩을 사용할 수 있지만, 네이티브 애플리케이션은 기본적으로 더 복잡한 XCDR2 인코딩을 사용하여 불일치를 유발할 수 있습니다. 해결책은 네이티브 IDL이 더 단순한 인코딩을 강제하기 위해 <code>@appendable</code> 대신 <code>@final</code> 확장성을 사용하도록 하는 것입니다.5</li>
<li><strong>QoS 디버깅:</strong> <code>ros2 topic info -v</code>와 같은 도구는 일부 QoS 정보를 제공할 수 있지만, RTI Admin Console과 같은 벤더별 도구는 정확한 불일치를 진단하는 데 훨씬 더 강력합니다.46</li>
</ul>
<h3>2.5  완전한 네이티브 퍼블리셔 예제 [9]</h3>
<ol>
<li><strong>IDL 획득:</strong> 대상 ROS 2 메시지에 대한 <code>.idl</code> 파일을 찾거나 생성합니다 (예: <code>unique_identifier_msgs/msg/UUID.idl</code>).</li>
<li><strong>DDS 코드 생성:</strong> <code>fastddsgen</code>을 사용하여 IDL로부터 C++ 소스 파일을 생성합니다.</li>
<li><strong>생성된 코드 수정:</strong></li>
</ol>
<ul>
<li><code>UUIDPubSubTypes.cxx</code> 파일에서 <code>setName()</code> 호출을 찾아 타입 이름을 <code>unique_identifier_msgs::msg::dds_::UUID_</code>로 변경합니다.</li>
<li><code>UUIDPublisher.cxx</code> 파일에서 <code>create_topic()</code> 호출을 찾아 토픽 이름을 <code>rt/uuid_topic</code>으로 변경합니다.</li>
</ul>
<ol start="4">
<li><strong>메인 애플리케이션 작성:</strong> 생성된 헤더를 포함하고, <code>DomainParticipant</code>를 생성하며, 수정된 <code>UUIDPublisher</code>의 인스턴스를 만들어 루프 안에서 <code>publish()</code> 메서드를 호출하는 <code>main.cpp</code>를 작성합니다.</li>
<li><strong>컴파일 및 링크:</strong> CMake를 사용하여 Fast DDS 라이브러리에 대해 링크하며 애플리케이션을 컴파일합니다.</li>
<li><strong>실행:</strong> 네이티브 퍼블리셔를 실행합니다. 별도의 터미널에서 <code>ros2 topic echo /uuid_topic</code>을 실행하여 통신을 확인합니다.</li>
</ol>
<p>다음 표는 ROS 2와 DDS 간의 이름 변환 규칙을 요약한 것으로, 상호운용성 구현 시 중요한 참조 자료가 될 것입니다.</p>
<table><thead><tr><th>ROS 2 개념</th><th>사용자 대면 이름 (예시)</th><th>기본 DDS 엔티티</th><th>DDS 이름/타입 (결과)</th><th>비고</th></tr></thead><tbody>
<tr><td>토픽 (Pub/Sub)</td><td><code>/chatter</code></td><td>DDS Topic</td><td><code>rt/chatter</code></td><td>가장 일반적인 통신 패턴 8</td></tr>
<tr><td>서비스 (요청)</td><td><code>/add_two_ints</code></td><td>DDS Topic (Request)</td><td><code>rq/add_two_ints</code></td><td>요청/응답 패턴의 요청 부분 33</td></tr>
<tr><td>서비스 (응답)</td><td><code>/add_two_ints</code></td><td>DDS Topic (Reply)</td><td><code>rr/add_two_ints</code></td><td>요청/응답 패턴의 응답 부분 33</td></tr>
<tr><td>액션 (목표)</td><td><code>/_action/goal</code></td><td>DDS Topic (Goal)</td><td><code>ga/_action/goal</code></td><td>장기 실행 태스크의 목표 전송</td></tr>
<tr><td>액션 (결과)</td><td><code>/_action/result</code></td><td>DDS Topic (Result)</td><td><code>ar/_action/result</code></td><td>장기 실행 태스크의 최종 결과</td></tr>
<tr><td>액션 (피드백)</td><td><code>/_action/feedback</code></td><td>DDS Topic (Feedback)</td><td><code>af/_action/feedback</code></td><td>장기 실행 태스크의 중간 피드백</td></tr>
<tr><td>데이터 타입</td><td><code>std_msgs/msg/String</code></td><td>DDS Type</td><td><code>std_msgs::msg::dds_::String_</code></td><td>타입 호환성을 위해 필수적 9</td></tr>
<tr><td><strong>표 1: ROS 2에서 DDS로의 이름 변환 규칙</strong></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<h2>3.  벤더별 상호운용성 및 구성</h2>
<p>이 섹션에서는 가장 널리 사용되는 세 가지 RMW 구현체의 실제적인 세부 사항을 다루며, RMW의 ’추상화’가 실제 구현에 미치는 구체적인 영향을 분석합니다.</p>
<h3>3.1  eProsima Fast DDS (<code>rmw_fastrtps_cpp</code>)</h3>
<ul>
<li><strong>현황:</strong> Humble, Iron 등 대부분의 ROS 2 배포판에서 기본 RMW로 사용됩니다.49</li>
<li><strong>구성:</strong> 주로 XML 파일을 통해 구성됩니다. 이 파일의 경로는 <code>FASTRTPS_DEFAULT_PROFILES_FILE</code> 환경 변수로 지정됩니다.33</li>
<li><strong>상호운용성:</strong></li>
<li>표준 토픽(<code>rt/</code>) 및 타입(<code>...::dds_::..._</code>) 변환 규칙을 따릅니다.9</li>
<li>토픽 이름으로 프로파일 이름을 지정하여 ROS 2 노드의 QoS와 일치하는 XML 프로파일을 생성할 수 있습니다(예: <code>&lt;publisher profile_name="rt/chatter"&gt;</code> 프로파일은 해당 토픽의 퍼블리셔에 적용됨).33</li>
<li>Fast DDS는 Discovery Server, 대용량 데이터용 TCP 전송, 사용자 정의 메모리 관리 등 XML을 통해 구성할 수 있는 고급 기능을 제공하며, 이는 ROS 2 노드에서도 활용 가능합니다.28</li>
<li><strong>도구:</strong> <code>eProsima Fast DDS Monitor</code>는 DDS 네트워크 시각화, 엔티티 검사, 통계 데이터 분석을 위한 그래픽 도구로, ROS 2/DDS 상호작용 디버깅에 매우 유용합니다.55</li>
</ul>
<h3>3.2  RTI Connext DDS (<code>rmw_connextdds</code>)</h3>
<ul>
<li><strong>현황:</strong> 상용 등급의 RMW로, 특히 프로덕션 및 미션 크리티컬 시스템에서 널리 사용됩니다.4 평가/대학용 라이선스가 제공되지만, 기본적으로 라이선스가 필요합니다.50</li>
<li><strong>구성:</strong> XML 파일을 사용하며, <code>NDDS_QOS_PROFILES</code> 환경 변수나 작업 디렉토리의 <code>USER_QOS_PROFILES.xml</code> 파일을 통해 로드됩니다.4</li>
<li><strong>상호운용성:</strong></li>
<li>동일한 이름 변환 규칙을 따릅니다.4</li>
<li>과거의 주요 문제점은 RMW가 일반적인 “직렬화된 데이터” 타입 코드를 주입하여 특정 데이터 타입을 사용하는 네이티브 애플리케이션과 QoS 불일치를 일으키는 것이었습니다. 해결책은 타입 코드 공지를 억제하는 QoS 프로파일을 ROS 2 Participant에 추가하는 것입니다.4</li>
<li>RTI는 ROS 2 C++ 노드 내에서 네이티브 Connext <code>DomainParticipant</code>에 쉽게 접근할 수 있도록 전용 헬퍼 라이브러리(<code>rclcpp_dds</code>)를 제공하여 강력한 “하이브리드” 애플리케이션 모델을 지원합니다.57</li>
<li><strong>도구:</strong> <code>RTI Administration Console</code>은 시스템 발견, 토픽 시각화, 실시간 데이터 차트 작성, 그리고 가장 중요한 상세한 QoS 불일치 분석을 위한 매우 진보된 그래픽 도구입니다.47</li>
</ul>
<h3>3.3  Eclipse Cyclone DDS (<code>rmw_cyclonedds_cpp</code>)</h3>
<ul>
<li><strong>현황:</strong> 고성능 오픈소스 RMW로, ROS 2 Galactic의 기본 RMW였습니다.14 광범위한 튜닝 없이도 많은 수의 토픽/노드에서 우수한 성능을 보이는 것으로 알려져 있습니다.14</li>
<li><strong>구성:</strong> <code>CYCLONEDDS_URI</code> 환경 변수로 지정된 XML 파일을 통해 구성됩니다 (예: <code>export CYCLONEDDS_URI=file:///path/to/config.xml</code>).60</li>
<li><strong>상호운용성:</strong></li>
<li>과거에는 상호운용성이 더 어려웠으나, 커뮤니티 주도 솔션을 통해 문제들이 해결되었습니다.5</li>
<li>주요 문제는 <code>DataRepresentationQosPolicy</code> 불일치였습니다. 해결책은 네이티브 애플리케이션용 IDL을 <code>@appendable</code> 대신 <code>@final</code> 확장성으로 생성하여 호환되는 유선 표현을 강제하는 것입니다.5</li>
<li>동일한 <code>rt/</code> 토픽 이름 접두사 규칙을 따릅니다.43</li>
<li><strong>도구:</strong> 디버깅을 위해 DDSI-RTPS 디섹터가 포함된 Wireshark와 같은 범용 도구에 더 많이 의존합니다.14</li>
</ul>
<h3>3.4  RMW 구현체 전환 및 관리 가이드</h3>
<ul>
<li><code>RMW_IMPLEMENTATION</code> 환경 변수는 런타임에 사용할 설치된 RMW를 선택하는 주요 메커니즘입니다.53</li>
<li>예시: <code>RMW_IMPLEMENTATION=rmw_cyclonedds_cpp ros2 run demo_nodes_cpp talker</code>.62</li>
<li><strong>중요한 함정:</strong> 백그라운드에서 실행되는 ROS 2 데몬은 이전에 사용된 RMW를 유지할 수 있습니다. RMW를 전환할 때, 노드와 CLI 도구 간의 통신 문제를 피하기 위해 데몬을 명시적으로 종료(<code>ros2 daemon stop</code>)해야 하는 경우가 많습니다.62</li>
<li>통신 시스템의 모든 Participant는 호환되는 DDS 벤더 기반의 RMW를 사용해야 합니다. 다른 벤더들이 RTPS 표준을 통해 상호 운용될 수 있지만, 미묘한 차이로 인해 시스템 전체에서 동일한 벤더를 사용하는 것이 더 안정적입니다.53</li>
</ul>
<p>RMW의 선택은 단순한 기술적 결정이 아니라, 전체 개발 생태계를 선택하는 것과 같습니다. RMW는 환경 변수로 간단히 교체할 수 있는 것처럼 보이지만 62, 실제로는 각 벤더가 제공하는 고유한 도구들(Fast DDS Monitor, RTI Admin Console 등)이 심각한 디버깅과 성능 튜닝에 필수적입니다.56 구성 방식 또한 벤더별 XML 형식과 환경 변수(</p>
<p><code>FASTRTPS_DEFAULT_PROFILES_FILE</code> 대 <code>CYCLONEDDS_URI</code>)에 따라 달라집니다.53 또한, 알려진 상호운용성 문제와 해결책도 벤더에 따라 다릅니다(예: Cyclone의 X-Types 문제 대 Connext의 타입 코드 억제).4 따라서 RMW를 선택하는 것은 개발자를 특정 도구, 구성 패러다임, 그리고 커뮤니티 지식 기반에 종속시킵니다. 이는 단순히 전송 계층을 바꾸는 것이 아니라 전체 개발 및 디버깅 워크플로우에 영향을 미치는 결정입니다. 이는 프로덕션 프로젝트의 경우, RMW를 단순히 임의로 교체하는 것이 아니라, 도구, 지원, 성능 프로파일과 같은 요소를 기반으로 초기에 신중하게 선택해야 함을 시사합니다.</p>
<table><thead><tr><th>RMW 구현체</th><th>기본 배포판</th><th>라이선스</th><th>주요 구성 방법 (환경변수 + 파일)</th><th>주요 디버깅 도구</th></tr></thead><tbody>
<tr><td><code>rmw_fastrtps_cpp</code></td><td>Humble, Iron, Jazzy</td><td>Apache 2.0</td><td><code>FASTRTPS_DEFAULT_PROFILES_FILE</code> + XML</td><td>eProsima Fast DDS Monitor 55</td></tr>
<tr><td><code>rmw_connextdds</code></td><td>-</td><td>상용/평가용</td><td><code>NDDS_QOS_PROFILES</code> + XML</td><td>RTI Administration Console 58</td></tr>
<tr><td><code>rmw_cyclonedds_cpp</code></td><td>Galactic</td><td>EPL/EDL</td><td><code>CYCLONEDDS_URI</code> + XML</td><td>Wireshark 14</td></tr>
<tr><td><strong>표 2: RMW 구현 및 구성 요약</strong></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<h2>4.  고급 통신 패러다임 및 성능 최적화</h2>
<p>이 섹션은 “작동하게 만들기“에서 “빠르고 대규모로 작동하게 만들기“로 전환합니다.</p>
<h3>4.1  제로카피(Zero-Copy)를 향한 여정: RMW 오버헤드 우회</h3>
<p>앞서 분석했듯이, 기본 ROS 2 데이터 경로는 메모리 복사 및 직렬화 단계를 포함하여 오버헤드를 발생시키며, 이는 특히 이미지나 포인트 클라우드와 같은 대용량 데이터에서 문제가 됩니다.7</p>
<p>이 문제에 대한 해결책으로 ROS 2는 “Loaned Messages” API를 제공합니다. 사용자는 메시지를 생성하고 채워서 <code>publish()</code>에 전달하는 대신, <code>borrow_loaned_message()</code>를 통해 미들웨어로부터 직접 메모리 버퍼를 ’대여’합니다. 사용자는 이 미리 할당된 버퍼를 채우고 발행 시 미들웨어에 반환합니다. 이는 사용자 공간에서 미들웨어의 내부 버퍼로의 복사를 제거합니다.10</p>
<p>여러 DDS 구현체는 제로카피를 위한 자체적인 메커니즘을 제공합니다:</p>
<ul>
<li><strong>Eclipse iceoryx:</strong> CycloneDDS는 전용 공유 메모리 IPC 미들웨어인 Eclipse iceoryx와 통합될 수 있습니다. 활성화되면 동일한 호스트의 노드 간 통신은 포인터만 전달되므로 진정한 제로카피를 달성하여 상당한 성능 향상을 가져옵니다.64 주요 한계점은 전통적으로 컴파일 시간에 크기가 고정된 POD(Plain Old Data) 타입에만 작동하여, 가변 길이 배열(</li>
</ul>
<p><code>std::vector</code>)을 포함하는 메시지에는 사용하기 어렵다는 점입니다.63</p>
<ul>
<li>
<p><strong>RTI Connext Zero Copy:</strong> Connext는 유사한 공유 메모리 전송을 제공합니다. RMW를 우회하고 네이티브 Connext API를 사용하면 이 기능에 접근할 수 있으며, 대용량 데이터의 지연 시간을 극적으로 줄여 패킷 크기와 무관하게 만듭니다.11</p>
</li>
<li>
<p><strong>Agnocast:</strong> TIER IV에서 개발한 새로운 서드파티 솔루션으로, <code>LD_PRELOAD</code>를 통해 메모리 할당 함수(<code>malloc</code>/<code>free</code>)를 후킹하여 동적 크기 메시지에 대해서도 “진정한 제로카피“를 제공하는 것을 목표로 합니다.66</p>
</li>
</ul>
<h3>4.2  대규모 배포를 위한 네트워크 확장 전략</h3>
<p>기본 DDS 노드 발견 메커니즘(Simple Discovery Protocol)은 UDP 멀티캐스트에 의존합니다. 많은 노드가 있는 대규모 시스템에서는 모든 노드가 다른 모든 노드를 발견하려고 시도하면서 ’발견 폭풍(discovery storm)’이라 불리는 트래픽이 발생하여 완전히 연결된 그래프를 형성합니다. 이는 확장성이 떨어지며 기업이나 대학의 WiFi 네트워크에서는 종종 차단됩니다.12</p>
<ul>
<li><strong>해결책 1: Discovery Server:</strong> Fast DDS는 “Discovery Server” 모드를 제공합니다. 노드들은 중앙 서버(또는 서버들)에 연결하는 클라이언트로 구성됩니다. 클라이언트는 통신에 필요한 노드에 대한 발견 정보만 수신하므로 멀티캐스트 트래픽이 대폭 감소하고 멀티캐스트가 비활성화된 네트워크에서도 통신이 가능해집니다.13</li>
<li><strong>해결책 2: DDS Router:</strong> 서로 다른 DDS 네트워크를 연결할 수 있는 훨씬 더 강력한 도구입니다. DDS Router는 다른 <code>ROS_DOMAIN_ID</code>, 다른 물리적 LAN, 심지어 다른 전송 프로토콜을 연결할 수 있습니다. 이는 복잡한 다중 로봇 또는 다중 사이트 배포에서 제어된 통신 채널을 만드는 데 이상적입니다.12</li>
</ul>
<h3>4.3  성능 벤치마크 분석: DDS 대 Zenoh</h3>
<p><code>rmw_fastrtps_cpp</code>와 <code>rmw_cyclonedds_cpp</code>를 비교하는 여러 성능 벤치마크가 수행되었습니다.69</p>
<ul>
<li><strong>Fast DDS:</strong> 일반적으로 더 나은 처리량과 더 낮은 지연 시간을 보이며, 특히 대용량 데이터에서 뛰어납니다. 데이터 크기에 따른 확장성이 우수하지만, 메모리 사용량이 더 많은 경향이 있습니다.69</li>
<li><strong>Cyclone DDS:</strong> 구성 없이도 토픽 및 노드 수에 따라 매우 잘 확장되며 작은 메시지의 경우 지연 시간이 더 짧을 수 있습니다. 대용량 데이터에서는 성능이 더 크게 저하됩니다.14</li>
</ul>
<p>Zenoh(<code>rmw_zenoh</code>)는 DDS의 일부 단점, 특히 무선, WAN 및 리소스 제약 환경에서의 문제를 해결하기 위해 설계된 새로운 pub/sub/query 프로토콜입니다.71 ROS 2 TSC는</p>
<p><code>rmw_zenoh</code>를 평가했으며 14, 벤치마크에 따르면 Zenoh는 WiFi 및 4G에서 DDS보다 우수한 성능을 보이고, 안정적인 이더넷에서는 DDS(Cyclone)가 더 나은 성능을 보입니다.71 Zenoh의 발견 메커니즘은 기본 DDS 멀티캐스트보다 효율적이어서 발견 트래픽을 최대 97%까지 줄일 수 있습니다.15</p>
<h3>4.4  성능의 미래: 하드웨어 가속</h3>
<p>궁극적인 성능을 위해 ROS 2 계산 및 통신 로직을 하드웨어, 주로 FPGA로 오프로드할 수 있습니다.75 Acceleration Robotics의</p>
<p><code>RobotCore</code>와 같은 프로젝트는 ROS 2 네트워킹 스택(RCL, RMW, RTPS)을 하드웨어에서 직접 구현하는 FPGA IP 코어를 만들고 있습니다.77 이 접근 방식은 CPU 기반 소프트웨어 구현에 비해 지연 시간을 마이크로초 단위로 줄이고 전력 소비를 극적으로 낮추는 등 수십 배의 성능 향상을 약속하며 77, ROS 2 성능 최적화의 최전선을 대표합니다.</p>
<p>ROS 2의 성능 최적화 과정은 “추상화의 비용“에 대한 일련의 아키텍처적 절충안으로 볼 수 있습니다. 기준선은 사용하기 쉽지만 RMW 추상화로 인한 성능 오버헤드가 있는 표준 ROS 2 노드입니다. 첫 번째 최적화는 QoS 및 DDS XML 프로파일을 조정하는 것으로, 표준 아키텍처 내에 머무르지만 벤더별 기능에 접근하기 위해 RMW 추상화를 깨야 합니다. 다음 단계는 Loaned Messages API를 사용하는 것입니다. 이는 코드 변경이 필요하지만 메모리 복사를 줄여 상당한 성능 향상을 제공합니다. 이는 여전히 RMW를 통해 작동하지만 데이터 경로의 핵심 부분을 최적화합니다.10 최대 소프트웨어 성능을 위해서는 중요한 데이터 경로에 대해 ROS 2 클라이언트 라이브러리와 RMW를 완전히 우회하고 네이티브 DDS API(예: Connext Zero Copy)를 직접 사용해야 합니다. 이는 원시 속도를 위해 이식성과 ROS 통합(예: CLI 도구)을 희생합니다.11 마지막 단계는 전체 통신 스택을 실리콘으로 옮기는 하드웨어 가속입니다. 이는 가장 유연성이 낮지만 가장 높은 성능을 제공하는 옵션입니다.77 이는</p>
<p><strong>사용 편의성/이식성</strong>과 <strong>성능/복잡성</strong> 사이의 명확한 스펙트럼을 형성하며, 시스템 아키텍트는 시스템의 각 데이터 경로가 이 스펙트럼의 어느 지점에 위치해야 하는지 의식적으로 선택해야 합니다.</p>
<table><thead><tr><th>RMW/방법</th><th>메시지 크기(소형/대형)</th><th>지연 시간 (프로세스 간)</th><th>처리량 (프로세스 간)</th><th>핵심 요약</th></tr></thead><tbody>
<tr><td>Fast DDS (기본 비동기)</td><td>2MB</td><td>2.8 ms</td><td>1999 MBps</td><td>기본 설정에서 우수한 처리량 69</td></tr>
<tr><td>Fast DDS (동기)</td><td>2MB</td><td>2.6 ms</td><td>-</td><td>비동기 모드보다 지연 시간 개선 69</td></tr>
<tr><td>Fast DDS (데이터 공유)</td><td>2MB</td><td>~0.7 ms</td><td>&gt;2000 MBps</td><td>대용량 데이터에 가장 적합, 최저 지연 시간 69</td></tr>
<tr><td>Cyclone DDS</td><td>2MB</td><td>6.1 ms</td><td>822 MBps</td><td>소형 메시지에서 강점, 대형 데이터에서 성능 저하 69</td></tr>
<tr><td>Zenoh</td><td>-</td><td>DDS와 유사/더 우수</td><td>DDS보다 우수 (최대 3배)</td><td>무선/WAN 환경에서 강점, 프로토콜 효율성 높음 74</td></tr>
<tr><td><strong>표 3: 성능 벤치마크 종합 (지연 시간 및 처리량)</strong></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<h2>5.  데이터버스 보안: ROS 2에서 DDS-Security 구현</h2>
<p>이 섹션에서는 DDS에서 상속된 내장 보안 기능을 활용하는 방법을 자세히 설명합니다.</p>
<h3>5.1  DDS-Security: 보안 시스템의 기둥</h3>
<p>ROS 2 보안(<code>sros2</code>)은 별도의 ROS 기능이 아니라 OMG의 DDS-Security 사양을 직접 구현한 것입니다.31 이는 세 가지 핵심 서비스를 제공합니다.</p>
<ol>
<li><strong>인증 (Authentication):</strong> 인증서 및 인증 기관(CA)을 사용하는 공개 키 기반 구조(PKI)를 통해 Participant가 자신이 누구인지 확인합니다.31</li>
<li><strong>접근 제어 (Access Control):</strong> 인증된 특정 Participant가 어떤 토픽을 발행하거나 구독할 수 있는지 정의합니다. 이는 서명된 “거버넌스(Governance)” 및 “권한(Permissions)” XML 파일을 통해 관리됩니다.31</li>
<li><strong>암호화 (Cryptography):</strong> 기밀성과 무결성을 보장하기 위해 유선 상의 토픽 데이터를 암호화하며, 일반적으로 AES-GCM을 사용합니다.31</li>
</ol>
<h3>5.2  <code>sros2</code> 툴체인: 키에서 보안 그래프까지</h3>
<p><code>sros2</code> 명령줄 패키지는 보안 아티팩트를 생성하고 배포하는 복잡성을 관리하는 도구를 제공합니다.82</p>
<p><strong>워크플로우:</strong></p>
<ol>
<li><code>ros2 security create_keystore</code>: 시스템의 모든 보안 파일을 보관할 디렉토리를 생성합니다.82</li>
<li><code>ros2 security create_key</code>: CA 및 개별 노드(enclave)에 필요한 키와 인증서를 생성합니다.</li>
<li><code>ros2 security create_enclave</code>: 특정 노드 또는 논리적 노드 그룹에 대한 키, 인증서 및 정책 파일을 “보안 인클레이브(security enclave)“로 묶습니다.31</li>
</ol>
<h3>5.3  런타임에 보안 활성화</h3>
<p>보안은 환경 변수를 통해 제어됩니다.</p>
<ul>
<li><code>ROS_SECURITY_ENABLE=true</code>: 보안을 켜는 마스터 스위치입니다.81</li>
<li><code>ROS_SECURITY_KEYSTORE</code>: 이전 단계에서 생성된 키스토어 디렉토리의 경로입니다.31</li>
<li><code>ROS_SECURITY_STRATEGY=Enforce</code>: 파일이 없을 때 안전하지 않게 시작하는 허용 모드에서, 시작에 실패하는 엄격 모드로 동작을 변경합니다.31</li>
</ul>
<p>보안 노드를 시작할 때는 명령줄 인수를 통해 어떤 인클레이브의 자격 증명을 사용할지 지정해야 합니다: <code>ros2 run &lt;pkg&gt; &lt;node&gt; --ros-args --enclave /path/to/enclave</code>.31</p>
<p>ROS 2 보안은 전통적인 네트워크 보안과 근본적으로 다른 패러다임을 제시합니다. 전통적인 네트워크 보안은 방화벽, VPN, 네트워크 경계 보안에 중점을 두는 반면, DDS-Security와 이를 기반으로 한 SROS2는 “제로 트러스트(zero-trust)” 모델에서 작동합니다. 즉, 네트워크 자체를 신뢰하지 않습니다. 보안은 각 Participant(노드)의 암호화된 <em>신원</em>에 연결되며, 이 신원은 개인 키와 신뢰할 수 있는 CA가 서명한 인증서로 증명됩니다.31 접근 제어는 IP 주소나 서브넷이 아닌, 인증서에 명시된 신원이 서명된 권한 파일에서 특정 토픽에 대한 발행/구독 권한을 부여받았는지 여부에 따라 결정됩니다.31 이는 보안 정책이 네트워크 토폴로지와 무관하게 애플리케이션 계층에서 시행됨을 의미합니다. 두 노드가 올바른 자격 증명을 가지고 동일한 CA를 신뢰하는 한, 신뢰할 수 없는 공용 WiFi 네트워크에서도 사설 LAN에서와 마찬가지로 안전하게 통신할 수 있습니다. 이는 많은 엔지니어에게 익숙한 모델과는 매우 다른, 훨씬 더 견고한 보안 모델입니다.</p>
<hr />
<h2>6.  분석 및 전략적 권장 사항</h2>
<p>이 마지막 섹션에서는 안내서의 내용을 실행 가능한 의사 결정 프레임워크로 종합합니다.</p>
<h3>6.1  의사 결정 매트릭스: 네이티브 DDS 대 ROS 2 추상화 사용 시점</h3>
<ul>
<li><strong>시나리오 1: 레거시 또는 서드파티 DDS 컴포넌트 통합</strong></li>
<li><strong>권장 사항:</strong> 섹션 2에 자세히 설명된 네이티브 DDS 상호운용성 접근 방식을 사용해야 합니다. 대안이 없습니다. 성공은 토픽/타입 이름 변환 및 QoS 일치에 대한 세심한 준수에 달려 있습니다.</li>
<li><strong>시나리오 2: 고대역폭 프로세스 내 데이터 파이프라인 최적화 (예: 카메라 -&gt; 인식)</strong></li>
<li><strong>권장 사항:</strong> 제로카피 솔루션을 우선시합니다 (섹션 4.1). ROS 2의 프로세스 내 통신으로 시작하십시오. 노드가 동일한 호스트의 별도 프로세스에 있어야 하는 경우, POD 타입에 대해 CycloneDDS + iceoryx를 평가하거나 동적 타입에 대해 Agnocast를 조사하십시오. Loaned Messages API는 이 문제에 접근하는 표준 준수 방법입니다.</li>
<li><strong>시나리오 3: WiFi를 통한 대규모 다중 로봇 플릿 배포</strong></li>
<li><strong>권장 사항:</strong> 기본 DDS 멀티캐스트 발견은 적합하지 않습니다. 발견 트래픽을 관리하기 위해 Fast DDS Discovery Server(섹션 4.2)를 구현하십시오. 더 큰 제어가 필요하거나 네트워크 세그먼트를 연결하려면 DDS Router를 사용하십시오. 또한, 무선/손실 환경에서 우수한 성능과 발견 메커니즘을 위해 <code>rmw_zenoh</code>를 강력하게 평가하십시오 (섹션 4.3).</li>
<li><strong>시나리오 4: 새로운 성능 중심 애플리케이션 개발</strong></li>
<li><strong>권장 사항:</strong> 하이브리드 접근 방식을 고려하십시오. 비핵심 인터페이스(예: 구성, 상태)에는 표준 ROS 2 API를 사용하십시오. 핵심적인 고주파 데이터 경로의 경우, RMW를 우회하고 선택한 벤더의 네이티브 DDS API(예: RTI Connext)를 사용하여 최소한의 지연 시간과 제로카피와 같은 고급 기능에 접근하십시오.11</li>
</ul>
<h3>6.2  로보틱스 아키텍트를 위한 최종 권장 사항</h3>
<ul>
<li><strong>생태계를 수용하라:</strong> RMW의 선택은 도구, 문서, 커뮤니티 지원을 포함한 전체 생태계에 대한 투자입니다. 프로젝트 요구 사항에 따라 현명하게 선택하십시오.</li>
<li><strong>가정하지 말고 프로파일링하라:</strong> 성능 특성은 사용 사례(메시지 크기, 빈도, 네트워크 조건)에 따라 크게 달라집니다. 아키텍처를 확정하기 전에 <code>performance_test</code> 및 벤더별 모니터와 같은 도구를 사용하여 특정 시나리오를 벤치마킹하십시오.71</li>
<li><strong>도구를 마스터하라:</strong> Wireshark 및 RTI Admin Console 또는 Fast DDS Monitor와 같은 벤더별 도구에 대한 숙련도는 DDS를 포함하는 모든 진지한 개발에 있어 선택이 아닌 필수입니다. 이는 분산 시스템에서 흔히 발생하는 “조용한 실패“를 디버깅하는 데 필수적입니다.56</li>
<li><strong>설계에 의한 보안:</strong> 프로젝트 시작부터 보안 아키텍처(인클레이브, CA, 권한)를 계획하십시오. 보안을 나중에 추가하는 것은 훨씬 더 어렵고 오류가 발생하기 쉽습니다.31</li>
</ul>
<h3>6.3  향후 전망</h3>
<p>ROS 2와 DDS의 발전은 계속되고 있으며, 향상된 타입 지원(enum 등), 더 정교한 QoS 처리, 그리고 고급 기능의 RMW 계층으로의 긴밀한 통합과 같은 영역에서 지속적인 작업이 이루어지고 있습니다.84 Zenoh와 같은 대안의 부상과 하드웨어 가속으로의 추진은 차세대 로보틱스의 극한 성능 및 확장성 요구에 대한 솔루션을 제공하려는 명확한 추세를 나타냅니다.14 이러한 발전에 대한 최신 정보를 유지하는 것이 미래 지향적인 로봇 시스템을 구축하는 열쇠입니다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Introduction to Robot Operating System 2 (ROS 2) - MATLAB &amp; Simulink - MathWorks, accessed July 2, 2025, https://www.mathworks.com/help/ros/gs/robot-operating-system-ros2-basic-concepts.html</li>
<li>ROS 2: What is DDS | Data Distribution Service (DDS) Community RTI Connext Users, accessed July 2, 2025, https://community.rti.com/page/ros-2-what-dds</li>
<li>ROS 2 middleware interface - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/ros_middleware_interface.html</li>
<li>ROS2 + DDS: A Field Guide to Interoperability | RTI - Real-Time Innovations, accessed July 2, 2025, https://www.rti.com/blog/ros2-dds-a-field-guide-to-interoperability</li>
<li>ROS2 interoperability with native DDS - ROS Answers archive, accessed July 2, 2025, https://answers.ros.org/question/404995/</li>
<li>Ros2 and DDS messaging - ROS General - Open Robotics Discourse, accessed July 2, 2025, https://discourse.ros.org/t/ros2-and-dds-messaging/1556</li>
<li>Latency Analysis of ROS2 Multi-Node Systems - arXiv, accessed July 2, 2025, https://arxiv.org/pdf/2101.02074</li>
<li>Topic and Service name mapping to DDS - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/topic_and_service_names.html</li>
<li>osrf/ros2_raw_dds_example: A project showing how to … - GitHub, accessed July 2, 2025, https://github.com/osrf/ros2_raw_dds_example</li>
<li>Zero Copy via Loaned Messages - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/zero_copy.html</li>
<li>The Indy Autonomous Challenge: Achieving Extreme Performance with ROS 2, accessed July 2, 2025, https://www.rti.com/blog/the-indy-autonomous-challenge-achieving-extreme-performance-with-ros-2</li>
<li>1.2.2. How to Use DDS Router for Scalable ROS 2 Network Communication -, accessed July 2, 2025, https://docs.vulcanexus.org/en/jazzy/rst/tutorials/core/scalability/router_fully_connected/router_fully_connected.html</li>
<li>16.2. Use ROS 2 with Fast-DDS Discovery Server - 3.2.2, accessed July 2, 2025, https://fast-dds.docs.eprosima.com/en/latest/fastdds/ros2/discovery_server/ros2_discovery_server.html</li>
<li>2021 Eclipse Cyclone DDS ROS Middleware Evaluation Report with iceoryx and Zenoh, accessed July 2, 2025, https://osrf.github.io/TSC-RMW-Reports/humble/eclipse-cyclonedds-report.html</li>
<li>DDS Tuning for ROS 2 - breq.dev, accessed July 2, 2025, https://breq.dev/2024/05/17/dds</li>
<li>From ROS to ROS 2: A Comprehensive Guide to the Next Generation Robotics | by ScaleX Innovation, accessed July 2, 2025, https://scalexi.medium.com/from-ros-to-ros-2-a-comprehensive-guide-to-the-next-generation-robotics-f93a4e2e5793</li>
<li>Robot Operating System 2: Design, Architecture, and Uses In The Wild - ResearchGate, accessed July 2, 2025, https://www.researchgate.net/publication/365414963_Robot_Operating_System_2_Design_Architecture_and_Uses_In_The_Wild</li>
<li>Lessons Learned in Deploying ROS2 in Industrial Applications, accessed July 2, 2025, https://rosindustrial.squarespace.com/s/Lessons-Learned-in-Deploying-ROS2-in-Industrial-Apps-Robinson-March-25-no-animation.pdf</li>
<li>Introduction to ROS 2 (Robot Operating System 2) in Python - LearnOpenCV, accessed July 2, 2025, https://learnopencv.com/robot-operating-system-introduction/</li>
<li>Robot Operating System 2 (ROS 2) Architecture | by Huseyin Kutluca - Medium, accessed July 2, 2025, https://medium.com/software-architecture-foundations/robot-operating-system-2-ros-2-architecture-731ef1867776</li>
<li>Understanding the Publish-Subscribe (PubSub) Mechanism in ROS 2 Using rclpy, accessed July 2, 2025, https://www.roboticscontentlab.com/2024/09/29/publish-and-subscribe-mechanism-with-ros-2-rclpy/</li>
<li>ros2_i_training/workshop/source/_source/basics/ROS2-Simple-Publisher-Subscriber.md at main - GitHub, accessed July 2, 2025, https://github.com/ros-industrial/ros2_i_training/blob/main/workshop/source/_source/basics/ROS2-Simple-Publisher-Subscriber.md</li>
<li>About internal ROS 2 interfaces, accessed July 2, 2025, https://docs.ros.org/en/dashing/Concepts/About-Internal-Interfaces.html</li>
<li>rmw: ROS Middleware Abstraction Interface, accessed July 2, 2025, https://docs.ros2.org/foxy/api/rmw/</li>
<li>About ROS 2 middleware implementations, accessed July 2, 2025, https://docs.ros.org/en/foxy/Concepts/About-Middleware-Implementations.html</li>
<li>Eclipse Cyclone DDS - ROS 2 Documentation, accessed July 2, 2025, https://docs.ros.org/en/foxy/Installation/DDS-Implementations/Working-with-Eclipse-CycloneDDS.html</li>
<li>ROS 2 Communication - Clearpath Robotics Documentation, accessed July 2, 2025, https://docs.clearpathrobotics.com/docs/ros2humble/ros/networking/ros2_communication</li>
<li>Fast DDS - eProsima, accessed July 2, 2025, https://fast-dds.docs.eprosima.com/</li>
<li>Performance Evaluation of ROS2-DDS middleware implementations facilitating Cooperative Driving in Autonomous Vehicle. - arXiv, accessed July 2, 2025, https://arxiv.org/html/2412.07485v1</li>
<li>ROS QoS - Deadline, Liveliness, and Lifespan - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/qos_deadline_liveliness_lifespan.html</li>
<li>ROS 2 DDS-Security integration - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/ros2_dds_security.html</li>
<li>16.1. Configuring Fast DDS in ROS 2 - 3.2.2, accessed July 2, 2025, https://fast-dds.docs.eprosima.com/en/latest/fastdds/ros2/ros2_configure.html</li>
<li>Unlocking the potential of Fast DDS middleware [community-contributed] - ROS 2, accessed July 2, 2025, https://docs.ros.org/en/galactic/Tutorials/Advanced/FastDDS-Configuration.html</li>
<li>ROS 2 Over Email: rmw_email, an Actual Working RMW Implementation, accessed July 2, 2025, https://christophebedard.com/ros-2-over-email/</li>
<li>Latency Overhead of ROS2 for Modular Time-Critical Systems - arXiv, accessed July 2, 2025, http://www.arxiv.org/pdf/2101.02074v2</li>
<li>Subscribe to ROS2 topic from native ePromisa DDS program - Stack Overflow, accessed July 2, 2025, https://stackoverflow.com/questions/68272082/subscribe-to-ros2-topic-from-native-epromisa-dds-program</li>
<li>neil-rti/ros2-interop-demos: Demonstration apps to show ROS2 interoperability with native DDS apps - GitHub, accessed July 2, 2025, https://github.com/neil-rti/ros2-interop-demos</li>
<li>About ROS 2 interfaces - ROS 2 Documentation: Foxy documentation, accessed July 2, 2025, https://docs.ros.org/en/foxy/Concepts/About-ROS-Interfaces.html</li>
<li>Core Stack Developer Overview - ros_core bouncy documentation, accessed July 2, 2025, https://docs.ros2.org/bouncy/developer_overview.html</li>
<li>IDL - Interface Definition and Language Mapping - ROS2 Design, accessed July 2, 2025, https://design.ros2.org/articles/idl_interface_definition.html</li>
<li>design/articles/115_idl.md at gh-pages / ros2/design - GitHub, accessed July 2, 2025, https://github.com/ros2/design/blob/gh-pages/articles/115_idl.md</li>
<li>ROS 2 Getting Started - Safe DDS docs - eProsima, accessed July 2, 2025, https://safe-dds.docs.eprosima.com/intro/getting_started_ros2.html</li>
<li>DDS to ROS2 messages - ROS Answers archive, accessed July 2, 2025, https://answers.ros.org/question/406529/</li>
<li>My first application in FastDDS. I have some experience dealing with ROS… | by Hitoruna, accessed July 2, 2025, https://medium.com/@hitorunajp/438750d9527c</li>
<li>Communication between Cyclone and ROS2 / Issue #1412 / eclipse …, accessed July 2, 2025, https://github.com/eclipse-cyclonedds/cyclonedds/issues/1412</li>
<li>ROS 2 Quality of Service (QoS) - Isaac Sim Documentation, accessed July 2, 2025, https://docs.robotsfan.com/isaacsim/5.0.0/ros2_tutorials/tutorial_ros2_qos.html</li>
<li>Communication between RTI Connext DDS and ROS2 - Stack Overflow, accessed July 2, 2025, https://stackoverflow.com/questions/51523890/communication-between-rti-connext-dds-and-ros2</li>
<li>Setting up the RTI DDS configuration file in ROS2 - Stack Overflow, accessed July 2, 2025, https://stackoverflow.com/questions/52151179/setting-up-the-rti-dds-configuration-file-in-ros2</li>
<li>DDS implementations - ROS 2 Documentation: Foxy documentation, accessed July 2, 2025, https://docs.ros.org/en/foxy/Installation/DDS-Implementations.html</li>
<li>DDS implementations - ROS 2 Documentation: Iron documentation, accessed July 2, 2025, https://docs.ros.org/en/iron/Installation/DDS-Implementations.html</li>
<li>
<ol start="16">
<li>ROS 2 using Fast DDS middleware - 3.2.2, accessed July 2, 2025, https://fast-dds.docs.eprosima.com/en/stable/fastdds/ros2/ros2.html</li>
</ol>
</li>
<li>Running ROS 2 on Multiple Machines - Husarion, accessed July 2, 2025, https://husarion.com/tutorials/ros2-tutorials/6-robot-network/</li>
<li>ROS 2 Middleware (RMW) Configuration - GitHub Pages, accessed July 2, 2025, https://iroboteducation.github.io/create3_docs/setup/xml-config/</li>
<li>1.1.4. How to handle large data video streaming in ROS 2 - - Vulcanexus Docs, accessed July 2, 2025, https://docs.vulcanexus.org/en/jazzy/rst/tutorials/core/wifi/large_data/large_data.html</li>
<li>eProsima/Fast-DDS: The most complete DDS - Proven: Plenty of success cases. Looking for commercial support? Contact info@eprosima.com - GitHub, accessed July 2, 2025, https://github.com/eProsima/Fast-DDS</li>
<li>
<ol>
<li>Fast DDS Monitor with ROS 2 - 3.2.0, accessed July 2, 2025, https://fast-dds-monitor.readthedocs.io/en/latest/rst/ros/ros.html</li>
</ol>
</li>
<li>rticommunity/rticonnextdds-robot-helpers: Collection of code and cmake utilities to use RTI Connext DDS with ROS 2 - GitHub, accessed July 2, 2025, https://github.com/rticommunity/rticonnextdds-robot-helpers</li>
<li>ROS 2: RTI Tools Overview | Data Distribution Service (DDS …, accessed July 2, 2025, https://community.rti.com/page/ros-2-rti-tools-overview</li>
<li>Getting Started with Admin Console 1 of 4 - YouTube, accessed July 2, 2025, https://www.youtube.com/watch?v=akNAr-5JPlY</li>
<li>Connecting ROS 2 Nodes with the Custom CycloneDDS XML Config File | Husarnet, accessed July 2, 2025, https://husarnet.com/docs/ros2/custom-cyclonedds-xml/</li>
<li>Network Troubleshooting Tools - Clearpath Robotics Documentation, accessed July 2, 2025, https://docs.clearpathrobotics.com/docs/ros/networking/network_troubleshooting/network_troubleshooting_tools</li>
<li>Working with multiple ROS 2 middleware implementations, accessed July 2, 2025, https://docs.ros.org/en/humble/How-To-Guides/Working-with-multiple-RMW-implementations.html</li>
<li>[ROS2] Use loaned messages to optimize the performance for image transport / Issue #216 / ros-perception/image_common - GitHub, accessed July 2, 2025, https://github.com/ros-perception/image_common/issues/216</li>
<li>Zero-copy data transfer in ROS 2 - YouTube, accessed July 2, 2025, https://www.youtube.com/watch?v=gbSBRqLCVjE</li>
<li>Talk:Usingzero-copy data transfer in ROS 2 - General, accessed July 2, 2025, https://discourse.ros.org/t/talk-usingzero-copy-data-transfer-in-ros-2/21448</li>
<li>Introduce True Zero-Copy Publish/Subscribe IPC to Autoware!! (New Middleware Coexisting with ROS 2) / autowarefoundation / Discussion #5835 - GitHub, accessed July 2, 2025, https://github.com/orgs/autowarefoundation/discussions/5835</li>
<li>ROS 2 Discovery Configuration - Clearpath Robotics Documentation, accessed July 2, 2025, https://docs.clearpathrobotics.com/docs/ros/networking/ros2_discovery_config</li>
<li>1.3.1. Discovery Server Minimal Example - - Vulcanexus Docs, accessed July 2, 2025, https://docs.vulcanexus.org/en/jazzy/rst/tutorials/core/discoveryserver/discoveryserverminimalexample/discovery_server_minimal_example.html</li>
<li>Fast DDS TSC RMW report 2021 - GitHub Pages, accessed July 2, 2025, https://osrf.github.io/TSC-RMW-Reports/humble/eProsima-response.html</li>
<li>New Fast DDS Performance Testing - ROS General - Open Robotics Discourse, accessed July 2, 2025, https://discourse.ros.org/t/new-fast-dds-performance-testing/29539</li>
<li>Comparison of Middlewares in Edge-to-Edge and Edge-to-Cloud Communication for Distributed ROS 2 Systems - arXiv, accessed July 2, 2025, https://arxiv.org/html/2309.07496v4</li>
<li>Open Class - Zenoh ROS 2 RMW: A New Middleware Implementation, accessed July 2, 2025, https://app.theconstruct.ai/live_class/17306cc2-eaa8-4195-a115-f92dc2e6ef28/</li>
<li>Comparison of Middlewares in Edge-to-Edge and Edge-to-Cloud Communication for Distributed ROS 2 Systems - arXiv, accessed July 2, 2025, http://arxiv.org/pdf/2309.07496</li>
<li>Comparison of Middlewares in Edge-to-Edge and Edge-to-Cloud Communication for Distributed ROS2 Systems | Papers With Code, accessed July 2, 2025, https://paperswithcode.com/paper/comparison-of-dds-mqtt-and-zenoh-in-edge-to</li>
<li>ROS 2 Hardware Acceleration Working Group - GitHub, accessed July 2, 2025, https://github.com/ros-acceleration</li>
<li>An open architecture for Hardware Acceleration in ROS 2.pdf, accessed July 2, 2025, <a href="http://download.ros.org/downloads/roscon/2022/An%20open%20architecture%20for%20Hardware%20Acceleration%20in%20ROS%202.pdf">http://download.ros.org/downloads/roscon/2022/An%20open%20architecture%20for%20Hardware%20Acceleration%20in%20ROS%202.pdf</a></li>
<li>ROBOTCORE® for ROS 2 | Ultra-Fast FPGA-Powered Networking for ROS 2 Robots, accessed July 2, 2025, https://accelerationrobotics.com/robotcore-ros2.php</li>
<li>RobotCore: An Open Architecture for Hardware Acceleration in ROS 2 | Brian Plancher, accessed July 2, 2025, https://brianplancher.com/publication/robotcore/</li>
<li>ROS 2 on a Chip, Achieving Brain-Like Speeds and Efficiency in Robotic Networking - arXiv, accessed July 2, 2025, https://arxiv.org/html/2404.18208v1</li>
<li>Zenoh Performance - ROS General - Open Robotics Discourse, accessed July 2, 2025, https://discourse.ros.org/t/zenoh-performance/30494</li>
<li>ROS 2 Security - ROS 2 Documentation: Rolling documentation, accessed July 2, 2025, https://docs.ros.org/en/rolling/Concepts/Intermediate/About-Security.html</li>
<li>Setting up security - ROS 2 Documentation: Rolling documentation, accessed July 2, 2025, https://docs.ros.org/en/rolling/Tutorials/Advanced/Security/Introducing-ros2-security.html</li>
<li>11x Performance Gain: Latest Connext DDS, ROS 2 Performance Benchmarks, accessed July 2, 2025, https://www.rti.com/blog/latest-connext-dds-ros-2-performance-benchmarks</li>
<li>Feature Ideas - ROS 2 Documentation, accessed July 2, 2025, https://ros2-documentation-zh-cn.readthedocs.io/en/rolling/source/The-ROS2-Project/Feature-Ideas.html</li>
<li>ROS2 message format should support enums / Issue #260 / ros2/rosidl - GitHub, accessed July 2, 2025, https://github.com/ros2/rosidl/issues/260</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>