<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.1. 방법론 (Methodology)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.1. 방법론 (Methodology)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">기사 (Articles)</a> / <a href="index.html">실전 논문 작성 가이드</a> / <span>4.1. 방법론 (Methodology)</span></nav>
                </div>
            </header>
            <article>
                <h1>4.1. 방법론 (Methodology)</h1>
<p>학술 논문, 특히 컴퓨터 비전(CVPR, ICCV), 머신러닝(NeurIPS, ICML), 로보틱스(ICRA, IROS)와 같은 공학 및 응용 과학 분야의 최상위 컨퍼런스에서 ‘방법론(Methodology)’ 섹션은 연구의 심장이자 뼈대이다. 서론이 연구의 동기를 부여하고 관련 연구가 학문적 좌표를 설정한다면, 방법론은 저자의 주장이 단순한 직관이나 추측이 아닌, 엄밀한 설계와 과학적 절차에 기반한 ’공학적 사실’임을 입증하는 증거의 장이다.1</p>
<p>본 장에서는 방법론 섹션을 작성하는 데 필요한 철학적 접근부터 미세한 문장 기술 전략, 수식 표기법의 표준, 시각화 기법, 그리고 리뷰어의 심리적 방어 기제까지 포괄적으로 다룬다. 단순한 “무엇을 했는가“의 나열을 넘어, “왜 이 방법이 최선인가“를 설득하는 수사학적 전략을 마스터하는 것이 본 장의 목표다.</p>
<h2>1.  방법론의 본질: 재현성과 설득의 이중주</h2>
<p>방법론 섹션은 두 가지 상충될 수 있는 목표를 동시에 달성해야 한다. 첫째는 ’재현성(Reproducibility)’이라는 과학적 의무의 이행이며, 둘째는 ’타당성(Validity)’을 입증하는 수사적 설득이다.</p>
<h3>1.1  재현성 계약 (The Contract of Reproducibility)</h3>
<p>과학적 지식은 독립적인 검증을 통해 축적된다. 따라서 방법론 섹션의 일차적 독자는 해당 연구를 자신의 실험실에서 다시 구현해보고자 하는 동료 연구자다.3 이들에게 필요한 것은 모호한 형용사가 아니라, 정확한 수치, 명확한 알고리즘 순서, 그리고 구체적인 하드웨어 설정이다. NeurIPS와 CVPR은 최근 ’재현성 체크리스트(Reproducibility Checklist)’를 의무화하여, 코드 제공 여부, 하이퍼파라미터의 명시, 컴퓨팅 인프라 사양 등을 엄격히 심사하고 있다.1 만약 독자가 방법론을 읽고 “이 부분의 스트라이드(stride) 값은 얼마지?” 또는 “초기화는 어떻게 했지?“라는 의문을 갖게 된다면, 그 방법론은 실패한 것이다.</p>
<h3>1.2  설계의 정당화 (Justification of Design)</h3>
<p>단순히 실험 과정을 요리 레시피처럼 나열하는 것만으로는 부족하다. 독자와 리뷰어는 “왜 ResNet 대신 ViT(Vision Transformer)를 백본으로 썼는가?”, “왜 L2 Loss 대신 L1 Loss를 선택했는가?“와 같은 설계의 근거를 묻는다.5 방법론은 저자가 마주한 수많은 갈림길에서 왜 특정 경로를 선택했는지에 대한 논리적 방어 기제를 포함해야 한다. 이는 연구자가 문제를 깊이 이해하고 있으며, 무작위적인 시행착오(Trial and Error)가 아닌 합리적인 엔지니어링을 수행했음을 보여주는 지표가 된다.6</p>
<h2>2.  분야별 구조의 전형 (Structural Archetypes)</h2>
<p>모든 논문이 동일한 구조를 가질 수는 없다. 연구 주제와 커뮤니티의 관행(Convention)에 따라 방법론의 전개 방식은 크게 두 가지 유형으로 나뉜다. 자신이 투고하려는 학회의 성격을 파악하고 그에 맞는 ’템플릿’을 내재화하는 것이 중요하다.8</p>
<h3>2.1  딥러닝/알고리즘 중심 (CVPR, NeurIPS 스타일)</h3>
<p>이 유형의 논문은 주로 새로운 모델 아키텍처나 학습 프레임워크를 제안한다. 따라서 ’데이터의 흐름(Data Flow)’과 ’변환(Transformation)’이 서술의 중심이 된다.4</p>
<table><thead><tr><th><strong>섹션 순서</strong></th><th><strong>구성 요소</strong></th><th><strong>핵심 내용 및 역할</strong></th></tr></thead><tbody>
<tr><td><strong>1. Overview</strong></td><td><strong>전체 파이프라인</strong></td><td>입력에서 출력까지의 과정을 요약하는 메인 다이어그램(Figure 1/2)과 함께 전체적인 흐름을 개괄한다. 독자의 인지적 지도를 형성하는 단계다.</td></tr>
<tr><td><strong>2. Preliminaries</strong></td><td><strong>배경 및 정의</strong></td><td>문제 정의(Problem Formulation), 기호(Notation) 정의, 필요한 사전 지식(예: Diffusion Model의 수식적 기초)을 짧게 언급한다.</td></tr>
<tr><td><strong>3. Architecture</strong></td><td><strong>모델 구조 상세</strong></td><td>백본 네트워크, 인코더-디코더 구조, 각 모듈의 세부 사항을 텐서(Tensor) 차원과 함께 설명한다.</td></tr>
<tr><td><strong>4. Method/Module</strong></td><td><strong>핵심 기여</strong></td><td>논문이 제안하는 독창적인 모듈(예: New Attention Mechanism)을 집중적으로 다룬다. 가장 많은 지면을 할애해야 한다.</td></tr>
<tr><td><strong>5. Objective</strong></td><td><strong>학습 목표</strong></td><td>손실 함수(Loss Function)의 전체 수식을 제시하고, 각 항(Term)의 역할과 가중치(<span class="math math-inline">\lambda</span>)의 의미를 설명한다.</td></tr>
</tbody></table>
<h3>2.2  로보틱스/시스템 중심 (ICRA, IROS 스타일)</h3>
<p>로보틱스 논문은 물리적 실체와 소프트웨어의 통합을 다룬다. 따라서 ‘상태(State)’, ‘제어(Control)’, ’하드웨어 구성(Hardware Setup)’이 중요하다.9</p>
<table><thead><tr><th><strong>섹션 순서</strong></th><th><strong>구성 요소</strong></th><th><strong>핵심 내용 및 역할</strong></th></tr></thead><tbody>
<tr><td><strong>1. System Overview</strong></td><td><strong>시스템 아키텍처</strong></td><td>하드웨어 플랫폼, 센서 배치, 소프트웨어 스택(ROS 등)의 연결 구조를 설명한다.</td></tr>
<tr><td><strong>2. Formulation</strong></td><td><strong>문제 정식화</strong></td><td>로봇의 상태 공간(<span class="math math-inline">\mathcal{X}</span>), 제어 입력(<span class="math math-inline">\mathcal{U}</span>), 환경 지도(<span class="math math-inline">\mathcal{M}</span>) 등을 수학적으로 정의한다.</td></tr>
<tr><td><strong>3. Perception</strong></td><td><strong>인식 및 상태 추정</strong></td><td>센서 데이터 처리, SLAM, 객체 인식 알고리즘 등 입력 처리부를 기술한다.</td></tr>
<tr><td><strong>4. Planning/Control</strong></td><td><strong>계획 및 제어</strong></td><td>경로 계획(Path Planning), 궤적 생성, 모터 제어 법칙 등을 기술한다.</td></tr>
<tr><td><strong>5. Integration</strong></td><td><strong>통합 및 구현</strong></td><td>각 모듈 간의 통신, 지연 시간(Latency) 처리, 실시간성 보장 전략 등을 다룬다.</td></tr>
</tbody></table>
<h2>3.  시스템 개요(System Overview)와 시각화 전략</h2>
<p>“백문이 불여일견“이라는 말은 방법론 섹션에서 절대적인 진리다. 복잡한 신경망 구조나 로봇 시스템을 텍스트로만 설명하는 것은 독자에 대한 고문과 다름없다. 시스템 개요도(System Overview Diagram)는 독자가 논문의 내용을 멘탈 모델로 구축하는 데 결정적인 역할을 한다.12</p>
<h3>3.1  다이어그램 설계의 원칙</h3>
<p>성공적인 시스템 다이어그램은 정보의 위계가 명확해야 한다.</p>
<ol>
<li><strong>입력과 출력의 명시:</strong> 다이어그램의 왼쪽(또는 위)에는 원본 데이터(Raw Input)가, 오른쪽(또는 아래)에는 최종 결과물(Prediction, Control Command)이 위치하여 흐름이 자연스럽게 읽혀야 한다.</li>
<li><strong>모듈화와 추상화:</strong> 모든 연산을 다이어그램에 넣을 수는 없다. 기능 단위로 블록화(Module Block)하고, 세부 사항은 별도의 서브 다이어그램으로 분리하거나 텍스트로 설명한다.14</li>
<li><strong>표기법의 통일:</strong> 점선 화살표는 ’그라디언트 흐름(Backpropagation)’을, 실선 화살표는 ’데이터 흐름(Forward Pass)’을 나타내는 등 시각적 언어의 규칙을 정하고 범례(Legend)를 통해 명시해야 한다.16</li>
<li><strong>색상 코딩(Color Coding):</strong> 학습 가능한 파라미터(Trainable Parameters)는 파란색, 고정된(Frozen) 모듈은 회색, 손실 함수는 빨간색 등으로 색상을 통해 모듈의 성격을 구분하면 독자의 이해를 돕는다.</li>
</ol>
<h3>3.2  텍스트와 그림의 유기적 결합 (Weaving)</h3>
<p>그림은 본문과 독립적으로 존재해서는 안 된다. 본문 텍스트는 그림을 가이드해야 하며, 그림은 텍스트의 구체적 형상화여야 한다.17</p>
<ul>
<li><strong>나쁜 예:</strong> “Figure 1 shows the system architecture.” (너무 단순하고 수동적임)</li>
<li><strong>좋은 예:</strong> “As illustrated in Figure 1, the input image <span class="math math-inline">\mathbf{I}</span> is first processed by the backbone network to extract features <span class="math math-inline">\mathbf{F}</span>, which are then fed into…” (그림의 흐름을 따라가며 텍스트가 해설함).19</li>
</ul>
<h2>4.  수학적 형식화(Mathematical Formalization)와 표준 표기법</h2>
<p>공학 논문의 언어는 자연어와 수학의 결합이다. 특히 문제 정의(Problem Formulation) 단계에서 엄밀한 수학적 기호(Notation)를 정의하는 것은 이후의 모호함을 제거하는 필수 작업이다.21</p>
<h3>4.1  표기법의 표준 (Standard Notations)</h3>
<p>각 분야에는 암묵적으로 합의된 표준 표기법이 존재한다. 이를 무시하고 자신만의 기호를 사용하면 독자의 인지 부하를 가중시킨다.</p>
<ul>
<li><strong>집합(Sets):</strong> <span class="math math-inline">\mathcal{X}, \mathcal{Y}, \mathcal{D}</span> (캘리그라피체 대문자). 예: 학습 데이터셋 <span class="math math-inline">\mathcal{D} = \{(x_i, y_i)\}_{i=1}^N</span>.</li>
<li><strong>스칼라(Scalars):</strong> <span class="math math-inline">x, y, \lambda, \alpha</span> (이탤릭체 소문자/그리스어).</li>
<li><strong>벡터(Vectors):</strong> <span class="math math-inline">\mathbf{x}, \mathbf{y}, \boldsymbol{\theta}</span> (볼드체 소문자).</li>
<li><strong>행렬(Matrices):</strong> <span class="math math-inline">\mathbf{X}, \mathbf{W}, \mathbf{I}</span> (볼드체 대문자).</li>
<li><strong>텐서(Tensors):</strong> <span class="math math-inline">\mathsf{X}, \mathsf{Y}</span> (산세리프체 대문자 또는 일반 대문자 문맥에 따라).</li>
<li><strong>함수(Functions):</strong> <span class="math math-inline">f(\cdot), g(\cdot), \mathcal{L}(\cdot)</span> (이탤릭체 또는 캘리그라피체).</li>
</ul>
<table><thead><tr><th><strong>개념</strong></th><th><strong>표준 표기 (LaTeX)</strong></th><th><strong>예시</strong></th></tr></thead><tbody>
<tr><td><strong>데이터셋</strong></td><td><code>\mathcal{D}</code></td><td><span class="math math-inline">\mathcal{D} = \{(x_i, y_i)\}_{i=1}^N</span></td></tr>
<tr><td><strong>입력 벡터</strong></td><td><code>\mathbf{x}</code></td><td><span class="math math-inline">\mathbf{x} \in \mathbb{R}^d</span></td></tr>
<tr><td><strong>가중치 행렬</strong></td><td><code>\mathbf{W}</code></td><td><span class="math math-inline">\mathbf{W} \in \mathbb{R}^{d_{out} \times d_{in}}</span></td></tr>
<tr><td><strong>손실 함수</strong></td><td><code>\mathcal{L}</code></td><td><span class="math math-inline">\mathcal{L}(\theta) = \sum_{i} l(f_\theta(x_i), y_i)</span></td></tr>
<tr><td><strong>기댓값</strong></td><td><code>\mathbb{E}</code></td><td><span class="math math-inline">\mathbb{E}_{x \sim p(x)}[f(x)]</span></td></tr>
<tr><td><strong>실수 공간</strong></td><td><code>\mathbb{R}</code></td><td><span class="math math-inline">\mathbb{R}^{H \times W \times C}</span></td></tr>
</tbody></table>
<h3>4.2  변수의 정의와 일관성</h3>
<p>수식에 등장하는 모든 변수는 처음 등장할 때 반드시 정의되어야 한다.21</p>
<ul>
<li>“We define the objective function as in Eq. (1), where <span class="math math-inline">\lambda</span> is a balancing hyperparameter and <span class="math math-inline">\mathcal{R}</span> represents the regularization term.”</li>
<li>동일한 대상을 지칭할 때는 논문 전체에서 동일한 기호를 사용해야 한다. 서론에서는 <span class="math math-inline">I</span>라고 했다가 방법론에서는 <span class="math math-inline">x</span>라고 표기하는 것은 치명적인 실수다.</li>
</ul>
<h2>5.  알고리즘 기술 및 의사코드 (Pseudocode)</h2>
<p>복잡한 반복문이나 조건부 로직, 혹은 전체적인 학습 절차는 텍스트보다 의사코드(Pseudocode)로 표현하는 것이 훨씬 명확하다. 이는 재현성을 위한 핵심 도구이기도 하다.23</p>
<h3>5.1  의사코드 작성의 모범 사례</h3>
<ol>
<li><strong>입출력의 명시:</strong> 알고리즘의 인터페이스를 명확히 한다. <strong>Input:</strong>, <strong>Output:</strong>, <strong>Parameters:</strong> 섹션을 두어 함수가 무엇을 받아 무엇을 내뱉는지 정의한다.25</li>
<li><strong>수학적 추상화:</strong> 특정 프로그래밍 언어(Python, C++)의 문법(예: <code>list.append()</code>)보다는 수학적 표현(예: <span class="math math-inline">\mathcal{S} \leftarrow \mathcal{S} \cup \{x\}</span>)을 사용한다. 이는 언어 종속성을 없애고 알고리즘의 본질에 집중하게 한다.26</li>
<li><strong>주석 활용:</strong> 각 라인 번호 옆에 짧은 주석을 달아 해당 단계의 목적을 설명한다. (예: <code>▷ Update weights using SGD</code>).</li>
<li><strong>LaTeX 패키지:</strong> <code>algorithm2e</code> 또는 <code>algorithmicx</code> 패키지를 사용하여 전문적인 외관을 갖춘다. <code>algorithm2e</code>는 유연성이 좋고 <code>algorithmicx</code>는 구문이 직관적이다.24</li>
</ol>
<pre><code>\begin{algorithm}
\caption{Proposed Meta-Learning Training Procedure}
\SetAlgoLined
\textbf{Input:} Dataset $\mathcal{D}$, Learning rate $\alpha$, $\beta$ \\
\textbf{Output:} Optimized parameters $\theta^*$ \\
Initialize parameters $\theta$ randomly; \\
\While{not converged}{
    Sample batch of tasks $\mathcal{T}_i \sim p(\mathcal{T})$; \\
    \For{all $\mathcal{T}_i$}{
        Sample support set $\mathcal{D}_s$ and query set $\mathcal{D}_q$ from $\mathcal{T}_i$; \\
        Compute adapted parameters $\theta'_i = \theta - \alpha \nabla_\theta \mathcal{L}_{\mathcal{T}_i}(f_\theta(\mathcal{D}_s))$; \tcp*{Inner loop}
    }
    Update meta-parameters $\theta \leftarrow \theta - \beta \nabla_\theta \sum_{\mathcal{T}_i} \mathcal{L}_{\mathcal{T}_i}(f_{\theta'_i}(\mathcal{D}_q))$; \tcp*{Outer loop}
}
\Return $\theta$
\end{algorithm}
</code></pre>
<h2>6.  심층 분석: 아키텍처 및 모듈 상세 기술</h2>
<p>이 섹션은 제안하는 방법의 ’살’을 붙이는 과정이다. 모델의 각 구성 요소를 해부하고 그 작동 원리를 설명한다.</p>
<h3>6.1  백본 및 특징 추출기 (Backbone &amp; Feature Extractor)</h3>
<p>대부분의 CV/ML 연구는 기존의 검증된 모델(ResNet, Transformer 등)을 백본으로 사용한다. 이 경우, 해당 모델의 전체 구조를 다시 설명할 필요는 없다. 대신, <strong>어떤 변형(Modification)을 가했는지</strong>에 집중한다.4</p>
<ul>
<li>“We utilize ResNet-50 [He et al., 2016] as our backbone. However, we remove the final fully connected layer and modify the stride of the last convolutional block to 1 to preserve spatial resolution.”</li>
<li>이러한 서술은 독자가 기존 지식을 바탕으로 변경된 부분만 빠르게 파악하게 돕는다.</li>
</ul>
<h3>6.2  핵심 모듈의 상세화</h3>
<p>논문의 Novelty가 담긴 핵심 모듈(예: 새로운 Attention Block)은 가장 상세하게 기술해야 한다.</p>
<ul>
<li><strong>입력 텐서의 차원:</strong> 모듈로 들어오는 데이터의 형태(<span class="math math-inline">B \times C \times H \times W</span>)를 명시한다.29</li>
<li><strong>연산 과정:</strong> 1x1 Convolution, Softmax, Matrix Multiplication 등 내부 연산을 순차적으로 수식과 함께 설명한다.</li>
<li><strong>설계 의도:</strong> “We apply a <span class="math math-inline">1 \times 1</span> convolution to reduce the channel dimension by half, minimizing computational cost.“와 같이 각 연산의 목적을 덧붙인다.30</li>
</ul>
<h3>6.3  목적 함수 (Objective Function / Loss)</h3>
<p>학습의 방향을 결정하는 손실 함수는 반드시 별도의 소제목(Subsection)으로 분리하여 다룬다.</p>
<ul>
<li><strong>전체 손실 함수:</strong> <span class="math math-inline">\mathcal{L}_{total} = \lambda_{cls}\mathcal{L}_{cls} + \lambda_{reg}\mathcal{L}_{reg} + \lambda_{adv}\mathcal{L}_{adv}</span> 와 같이 구성 요소의 선형 결합으로 표현한다.</li>
<li><strong>항별 설명:</strong> 각 손실 항(<span class="math math-inline">\mathcal{L}_{cls}</span> 등)이 어떤 수식으로 정의되는지, 그리고 이 항이 모델 학습에 어떤 영향을 미치는지(예: “This term encourages spatial smoothness”) 설명한다.31</li>
</ul>
<h2>7.  구현 세부 사항 (Implementation Details)</h2>
<p>재현성을 보장하는 최후의 보루다. 많은 논문이 이 부분을 부록(Appendix)으로 넘기기도 하지만, 결과에 결정적인 영향을 미치는 핵심 파라미터는 본문에 남겨야 한다.33 이 섹션이 부실하면 “숨겨진 트릭(Hidden Tricks)으로 성능을 냈다“는 의심을 살 수 있다.</p>
<h3>7.1  학습 하이퍼파라미터</h3>
<p>다음 항목들을 필수적으로 포함해야 한다 10:</p>
<ul>
<li><strong>Optimizer:</strong> 종류(Adam, SGD 등), 모멘텀 값, 베타 값(<span class="math math-inline">\beta_1, \beta_2</span>), Weight Decay.</li>
<li><strong>Learning Rate:</strong> 초기 학습률, 웜업(Warm-up) 기간, 감쇠 스케줄(Cosine Annealing, Step Decay 등).</li>
<li><strong>Batch Size &amp; Epochs:</strong> 전체 학습 에폭 수와 배치 크기.</li>
<li><strong>Data Augmentation:</strong> 사용된 증강 기법(Random Crop, Flip, Color Jittering 등)과 그 파라미터.</li>
</ul>
<h3>7.2  환경 설정</h3>
<ul>
<li><strong>하드웨어:</strong> GPU 모델(NVIDIA A100 80GB x 8), CPU 사양. 이는 학습 시간(Training Time)을 비교할 때 중요한 기준이 된다.</li>
<li><strong>소프트웨어:</strong> 프레임워크(PyTorch 1.13, TensorFlow 2.x), CUDA 버전, 주요 라이브러리 버전.</li>
</ul>
<table><thead><tr><th><strong>파라미터</strong></th><th><strong>값/설정</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>Framework</strong></td><td>PyTorch 2.0.1</td><td>CUDA 11.7</td></tr>
<tr><td><strong>Hardware</strong></td><td>8 <span class="math math-inline">\times</span> NVIDIA A100 (80GB)</td><td>-</td></tr>
<tr><td><strong>Optimizer</strong></td><td>AdamW</td><td><span class="math math-inline">\beta_1=0.9, \beta_2=0.999</span></td></tr>
<tr><td><strong>Learning Rate</strong></td><td><span class="math math-inline">1 \times 10^{-4}</span></td><td>Cosine Decay with 5-epoch warmup</td></tr>
<tr><td><strong>Batch Size</strong></td><td>256</td><td>32 per GPU</td></tr>
<tr><td><strong>Weight Decay</strong></td><td>0.05</td><td>-</td></tr>
</tbody></table>
<h2>8.  로보틱스 연구를 위한 특수 고려사항</h2>
<p>로보틱스 논문(ICRA/IROS)은 시뮬레이션과 현실 세계(Real-world) 실험의 간극을 다루어야 하므로, 방법론 작성 시 추가적인 요소가 필요하다.35</p>
<h3>8.1  하드웨어 플랫폼 명세 (Checklist)</h3>
<p>실제 로봇을 사용했다면 다음 정보를 포함해야 한다 36:</p>
<ul>
<li><strong>로봇 본체:</strong> 모델명(예: Boston Dynamics Spot, TurtleBot3), 자유도(DOF), 기구학적 특성.</li>
<li><strong>센서:</strong> LiDAR(Velodyne VLP-16), 카메라(Intel RealSense D435), IMU 등의 모델명과 설치 위치, 데이터 전송 주파수(Hz).</li>
<li><strong>컴퓨팅:</strong> 온보드 컴퓨터(Jetson AGX Orin, Intel NUC) 사양. 실시간 처리가 가능한지 입증하는 근거가 된다.</li>
</ul>
<h3>8.2  시뮬레이션 환경</h3>
<ul>
<li><strong>시뮬레이터:</strong> Gazebo, MuJoCo, Isaac Gym 등 사용된 시뮬레이터와 버전.</li>
<li><strong>물리 엔진:</strong> 마찰 계수, 중력, 충돌 모델 등 물리 파라미터 설정.</li>
<li><strong>Sim-to-Real:</strong> 시뮬레이션에서 학습된 정책을 실제 로봇에 적용할 때 사용한 도메인 랜덤화(Domain Randomization) 등의 기법.35</li>
</ul>
<h2>9.  설계의 정당화 (Justification): ’왜’에 대답하기</h2>
<p>방법론 섹션의 수준을 가르는 것은 ’설명(Description)’과 ’정당화(Justification)’의 균형이다. 초보 연구자는 “무엇을 했다“만 나열하지만, 숙련된 연구자는 “왜 그것을 선택했는지“를 설득한다.5</p>
<h3>9.1  대안과의 비교 논리</h3>
<p>선택하지 않은 대안들에 대해 왜 배제했는지 설명함으로써 자신의 선택을 방어한다.</p>
<ul>
<li>“While RNNs are traditionally used for sequential data, we opted for a Transformer-based architecture to enable parallel processing and capture long-range dependencies more effectively.”</li>
<li>“We chose the L1 loss over the L2 loss to enhance robustness against outliers in the depth estimation task.” 31</li>
</ul>
<h3>9.2  가정과 한계의 명시 (Assumptions &amp; Limitations)</h3>
<p>모든 연구는 특정 가정 위에서 성립한다. 이를 숨기기보다 명확히 드러내는 것이 학문적 정직성을 높이고 리뷰어의 공격을 선제적으로 방어하는 길이다.39</p>
<ul>
<li>“We assume that the environment is static during the robot’s scanning phase.”</li>
<li>“Our method relies on the availability of high-quality ground truth depth maps, which limits its applicability to synthetic datasets.”</li>
<li>이러한 명시는 연구의 범위(Scope)를 한정지어, 범위를 벗어난 비판으로부터 논문을 보호한다.</li>
</ul>
<h2>10.  언어적 전략: 해라체와 문체 (Writing Mechanics)</h2>
<p>방법론 섹션의 문체는 건조하지만 힘이 있어야 한다. 감정적인 형용사(extremely, surprisingly)를 배제하고, 정확한 기술 용어와 능동태를 적절히 섞어 사용한다.40</p>
<h3>10.1  시제 (Tense)</h3>
<ul>
<li><strong>과거 시제(Past Tense):</strong> 수행한 실험 절차나 데이터 수집 과정을 묘사할 때 사용한다. (e.g., “We <em>collected</em> data using…”, “Participants <em>were asked</em> to…”)</li>
<li><strong>현재 시제(Present Tense):</strong> 제안하는 시스템의 영구적인 속성, 수식의 정의, 알고리즘의 동작 원리를 설명할 때 사용한다. (e.g., “The proposed module <em>takes</em> an image as input…”, “Eq. (1) <em>represents</em> the loss…”)</li>
<li>일반적으로 딥러닝/알고리즘 논문에서는 시스템 설명을 위해 <strong>현재 시제</strong>가 주를 이루고, 로보틱스나 사용자 스터디 논문에서는 실험 절차 설명에 <strong>과거 시제</strong>가 혼용된다.41</li>
</ul>
<h3>10.2  태 (Voice)</h3>
<p>전통적으로는 객관성을 위해 수동태(Passive Voice)가 선호되었으나, 최근에는 명확성과 가독성을 위해 **능동태(Active Voice)**의 사용이 권장되는 추세다.41</p>
<ul>
<li><em>Passive:</em> “The features are extracted by the backbone.” (다소 딱딱하고 행위의 주체가 불분명할 수 있음)</li>
<li><em>Active:</em> “The backbone extracts features from the input image.” (명확하고 힘참)</li>
<li>“We“라는 주어를 사용하여 저자의 설계 의도를 드러낼 때는 능동태가 필수적이다. (e.g., “We design a novel loss function…”)</li>
</ul>
<h3>10.3  학술적 표현 은행 (Phrasebank Integration)</h3>
<p>다음은 방법론 작성 시 유용하게 쓸 수 있는 검증된 표현들이다.38</p>
<ul>
<li><strong>채택의 정당화:</strong> “A [method] approach was chosen to allow…”, “Ideally, [method] should be used; however, due to [constraint], we adopted…”</li>
<li><strong>절차 설명:</strong> “The data processing pipeline consists of three stages:…”, “Specifically, we first…, followed by…”</li>
<li><strong>파라미터 설정:</strong> “Unless otherwise stated, all parameters were set to…”, “Based on preliminary experiments, we set <span class="math math-inline">\lambda = 0.5</span>.”</li>
</ul>
<h2>11.  리뷰어 관점에서의 점검 (Reviewer’s Perspective)</h2>
<p>논문을 제출하기 전, 리뷰어의 모자를 쓰고 자신의 방법론을 비판적으로 검토해야 한다. 리뷰어들은 다음과 같은 ’Red Flags’를 찾는다.34</p>
<ol>
<li><strong>재현 불가능성(Irreproducibility):</strong> “Details are missing.“은 가장 흔한 거절 사유 중 하나다. 데이터 전처리, 하이퍼파라미터, 모델의 세부 구조 중 하나라도 빠져 있다면 채워 넣어야 한다.</li>
<li><strong>과도한 복잡성(Unnecessary Complexity):</strong> “Rube Goldberg Machine“이라는 비판을 듣지 않으려면, 복잡한 설계가 성능 향상에 필수적이었음을 입증해야 한다. 불필요하게 복잡한 수식이나 모듈은 오히려 독이 된다.46</li>
<li><strong>참신함의 부재(Lack of Novelty):</strong> 기존 방법을 단순히 조합(Combination)한 것에 불과하다는 지적을 피하려면, 그 조합이 왜 비자명(Non-trivial)하며 시너지를 내는지 논리적으로 설명해야 한다.34</li>
<li><strong>불공정한 비교(Unfair Comparison):</strong> 제안하는 방법에는 최적의 설정을 적용하고, 비교군(Baseline)에는 대충 설정한 파라미터를 적용하는 것은 연구 윤리 위반이자 리뷰어에게 즉각 발각되는 실수다.47</li>
</ol>
<h2>12.  결론: 기술적 서사(Technical Narrative)의 완성</h2>
<p>방법론 섹션은 단순한 매뉴얼이 아니다. 그것은 하나의 문제 해결 과정을 보여주는 정교한 기술적 서사다. 서론에서 제기된 문제를 해결하기 위해, 저자가 어떤 철학을 가지고 시스템을 설계했으며, 그 설계가 수학적으로 타당하고 실험적으로 재현 가능함을 입증하는 과정이다.</p>
<p>훌륭한 방법론은 독자로 하여금 “나도 이대로 하면 똑같은 결과를 얻을 수 있겠다“는 확신을 줌과 동시에, “이 문제는 이렇게 푸는 것이 가장 합리적이구나“라는 깨달음을 준다. 엄밀한 수식, 직관적인 시각화, 구체적인 구현 디테일, 그리고 논리적인 정당화가 유기적으로 결합될 때, 비로소 그 논문은 학문적 기여로서의 생명력을 얻게 된다.</p>
<p><strong>[부록] 방법론 작성 자가 진단 체크리스트</strong></p>
<table><thead><tr><th><strong>점검 항목</strong></th><th><strong>세부 질문</strong></th><th><strong>필수 포함 요소</strong></th></tr></thead><tbody>
<tr><td><strong>시스템 개요</strong></td><td>전체 구조를 그림만 보고도 파악할 수 있는가?</td><td>System Architecture Diagram, 입출력 명시</td></tr>
<tr><td><strong>수식/표기법</strong></td><td>표준 표기법을 따르며, 모든 변수가 정의되었는가?</td><td>Notation Table, 변수 정의 문장</td></tr>
<tr><td><strong>알고리즘</strong></td><td>핵심 로직이 명확하며 재현 가능한가?</td><td>Pseudocode (Algorithm 박스), 복잡도 분석</td></tr>
<tr><td><strong>구현 상세</strong></td><td>제3자가 내일 당장 코드를 짤 수 있을 만큼 구체적인가?</td><td>Hyperparameters, Hardware Specs, Libraries</td></tr>
<tr><td><strong>정당화</strong></td><td>왜 이 방법을 선택했는지에 대한 ’Why’가 있는가?</td><td>설계 근거(Rationale), 대안 비교, 가정(Assumption)</td></tr>
<tr><td><strong>일관성</strong></td><td>서론의 주장(Claim)과 방법론의 내용이 일치하는가?</td><td>용어의 통일, 기여점과의 연결</td></tr>
</tbody></table>
<h2>13. 참고 자료</h2>
<ol>
<li>NeurIPS Paper Checklist Guidelines, https://neurips.cc/public/guides/PaperChecklist</li>
<li>Most Common Mistakes in Research Methodology - PaperEdit, https://paperedit.org/research-methodology-common-mistakes/</li>
<li>Common Pitfalls In The Research Process - StatPearls - NCBI Bookshelf - NIH, https://www.ncbi.nlm.nih.gov/books/NBK568780/</li>
<li>Ideographic Description Sequence-Following Font Generation - NIPS papers, https://papers.nips.cc/paper_files/paper/2024/file/19ded4cfc36a7feb7fce975393d378fd-Paper-Conference.pdf</li>
<li>Choosing and justifying your methods - The University of Melbourne, https://students.unimelb.edu.au/academic-skills/graduate-research-services/writing-thesis-sections-part-2/choosing-and-justifying-your-methods</li>
<li>Step 4: Selecting and Justifying Your Research Design - Amanda Rockinson, http://amandaszapkiw.com/artifacts/resources/tutorials/research-process/Step-4-Selecting-and-Justifying-Your-Research-Design.pdf</li>
<li>The Selection of a Research Design, https://us.sagepub.com/sites/default/files/upm-binaries/22780_Chapter_1.pdf</li>
<li>Vision Language Models: A Survey of 26K Papers (CVPR, ICLR, NeurIPS 2023–2025), https://arxiv.org/html/2510.09586v1</li>
<li>Thoughts on Writing a Good (Robotics) Paper - Pratap Tokekar, http://tokekar.com/docs/Tokekar-WritingPapers-Talk.pdf</li>
<li>Structuring Robotics Conference Papers | MichaelMilford.com, https://michaelmilford.com/structuring-robotics-conference-papers/</li>
<li>ROS-related Robotic Systems Development with V-model-based Application of MeROS Metamodel - arXiv, https://arxiv.org/html/2506.08706v2</li>
<li>A Systematic Approach for Robotic System Development - MDPI, https://www.mdpi.com/2227-7080/13/8/316</li>
<li>Architectural diagrams: What is, how to draw and templates - Miro, https://miro.com/diagramming/what-is-software-architecture-diagramming/</li>
<li>System Architecture Our text classification system (Figure 1) consists of five components - ResearchGate, https://www.researchgate.net/figure/System-Architecture-Our-text-classification-system-Figure-1-consists-of-five-components_fig1_2913075</li>
<li>From Expert to Novice: An Empirical Study on Software Architecture Explanations - arXiv, https://arxiv.org/html/2503.08628v1</li>
<li>System architecture diagram basics &amp; best practices - vFunction, https://vfunction.com/blog/architecture-diagram-guide/</li>
<li>Standard for figure description in main text and its placement in a report/paper, https://academia.stackexchange.com/questions/8638/standard-for-figure-description-in-main-text-and-its-placement-in-a-report-paper</li>
<li>Figures, Tables &amp; References, <a href="https://www.bristol.ac.uk/Depts/DeafStudiesTeaching/dissert/Figures,%20Tables%20&amp;%20References.htm">https://www.bristol.ac.uk/Depts/DeafStudiesTeaching/dissert/Figures,%20Tables%20&amp;%20References.htm</a></li>
<li>The Dos and Don’ts of Using Tables and Figures in Your Writing, https://writingcenter.uci.edu/2024/04/29/the-dos-and-donts-of-using-tables-and-figures-in-your-writing/</li>
<li>How to write a figure caption - International Science Editing, https://www.internationalscienceediting.com/how-to-write-a-figure-caption/</li>
<li>A Standard Rigid Transformation Notation Convention for Robotics Research - arXiv, https://arxiv.org/pdf/2405.07351</li>
<li>Notation — Dive into Deep Learning 1.0.3 documentation, https://d2l.ai/chapter_notation/index.html</li>
<li>Pseudocode Standard, https://users.csc.calpoly.edu/~jdalbey/SWE/pdl_std.html</li>
<li>Write Pseudo Code in LaTeX | Baeldung on Computer Science, https://www.baeldung.com/cs/latex-pseudocode-format-snippets</li>
<li>What is a good package for displaying algorithms? - TeX - LaTeX Stack Exchange, https://tex.stackexchange.com/questions/1375/what-is-a-good-package-for-displaying-algorithms</li>
<li>Is there a standard algorithm pseudocode syntax in papers? If so, any good guides to learn it? : r/computerscience - Reddit, https://www.reddit.com/r/computerscience/comments/1o9fwo1/is_there_a_standard_algorithm_pseudocode_syntax/</li>
<li>Is there a convention on how to write pseudocode in scientific papers?, https://academia.stackexchange.com/questions/115797/is-there-a-convention-on-how-to-write-pseudocode-in-scientific-papers</li>
<li>algorithm, algorithmic, algorithmicx, algorithm2e, algpseudocode = confused - TeX - LaTeX Stack Exchange, https://tex.stackexchange.com/questions/229355/algorithm-algorithmic-algorithmicx-algorithm2e-algpseudocode-confused</li>
<li>Math Notation, https://phillipi.github.io/6.s898/materials/notation.pdf</li>
<li>Method Sections for Empirical Research Papers, https://www.jmu.edu/uwc/files/link-library/empirical/method_section_overview.pdf</li>
<li>A Table of Notation, https://proceedings.neurips.cc/paper/2020/file/f754186469a933256d7d64095e963594-Supplemental.pdf</li>
<li>A Notations and mathematical proofs, https://proceedings.neurips.cc/paper_files/paper/2023/file/5965f3a748a8d41415db2bfa44635cc3-Supplemental-Conference.pdf</li>
<li>2025 Author Guidelines - CVPR 2026 - The Computer Vision Foundation, https://cvpr.thecvf.com/Conferences/2025/AuthorGuidelines</li>
<li>CVPR 2026 Reviewer Training Material - The Computer Vision Foundation, https://cvpr.thecvf.com/Conferences/2026/ReviewerTrainingMaterial</li>
<li>Open Robot Hardware: Progress, Benefits, Challenges, and Best Practices - Yale Engineering, https://www.eng.yale.edu/grablab/pubs/Patel_RAM2023.pdf</li>
<li>Overview of hardware description. | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/Overview-of-hardware-description_fig8_343661081</li>
<li>PaoPaoRobot/ICRA2020-paper-list - GitHub, https://github.com/PaoPaoRobot/ICRA2020-paper-list</li>
<li>Introducing work - Academic Phrasebank - The University of Manchester, https://www.phrasebank.manchester.ac.uk/introducing-work/</li>
<li>CVPR 2025 Suggested Practices for Authors - The Computer Vision Foundation, https://cvpr.thecvf.com/Conferences/2025/AuthorSuggestedPractices</li>
<li>Structuring Robotics Conference Papers - YouTube, https://www.youtube.com/watch?v=C8ZlyA-CMJI</li>
<li>Research Methodology - 5 Beginner Writing Mistakes to Avoid, https://www.ref-n-write.com/blog/research-methodology-5-beginner-writing-mistakes-to-avoid/</li>
<li>Describing methods: Academic Phrasebank, https://www.phrasebank.manchester.ac.uk/describing-methods/</li>
<li>Describing Methods, https://phrasebankresearch.net/wp-content/uploads/2019/10/Academic-Phrasebank-Sample-PDF-2018.pdf</li>
<li>What some of the common reasons research papers are rejected? : r/academia - Reddit, https://www.reddit.com/r/academia/comments/1dpip85/what_some_of_the_common_reasons_research_papers/</li>
<li>[D] Discussion on CVPR 2024 Reviewer Scores and Rebuttals : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/19e8xyw/d_discussion_on_cvpr_2024_reviewer_scores_and/</li>
<li>In a lot of papers there are these wild looking functions. How do I understand what all the symbols mean? : r/learnmachinelearning - Reddit, https://www.reddit.com/r/learnmachinelearning/comments/12miyw6/in_a_lot_of_papers_there_are_these_wild_looking/</li>
<li>Insights from the ICLR Peer Review and Rebuttal Process - arXiv, https://arxiv.org/pdf/2511.15462</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>