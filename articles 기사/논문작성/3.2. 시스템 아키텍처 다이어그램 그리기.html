<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:3.2. 시스템 아키텍처 다이어그램 그리기</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>3.2. 시스템 아키텍처 다이어그램 그리기</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">기사 (Articles)</a> / <a href="index.html">실전 논문 작성 가이드</a> / <span>3.2. 시스템 아키텍처 다이어그램 그리기</span></nav>
                </div>
            </header>
            <article>
                <h1>3.2. 시스템 아키텍처 다이어그램 그리기</h1>
<p>논문에서 시스템 아키텍처 다이어그램(System Architecture Diagram)은 단순한 그림이 아니다. 그것은 연구자가 제안하는 방법론의 논리적 구조를 시각적 언어로 번역한 ’설계도’이자, 복잡한 수식과 알고리즘의 숲을 헤매는 독자에게 제공하는 가장 강력한 ’지도’이다. 심사위원(Reviewer)은 텍스트를 정독하기 전에 그림을 먼저 훑어본다. 이때 아키텍처 다이어그램이 조잡하거나 논리적 흐름이 불분명하다면, 그 논문은 읽히기도 전에 부정적인 선입견을 줄 가능성이 크다.1 반면, 잘 설계된 다이어그램은 수천 줄의 코드와 수십 개의 수식보다 더 명확하게 저자의 기여점(Contribution)을 전달하며, 연구의 완성도를 대변한다.</p>
<p>이 장에서는 인공지능(AI)과 로보틱스 연구자가 자신의 시스템을 출판 가능한 수준(Camera-Ready)으로 시각화하기 위해 필요한 철학, 도구 선택, 디자인 원칙, 그리고 분야별 특화 전략을 철저하게 파헤친다. 우리는 단순히 ’그리는 법’을 넘어, ’이기는 그림’을 설계하는 법을 다룰 것이다.</p>
<h2>1.  다이어그램의 본질과 추상화의 미학</h2>
<p>많은 초보 연구자가 범하는 치명적인 실수는 아키텍처 다이어그램을 ’구현 명세서’로 착각하는 것이다. 논문의 다이어그램은 엔지니어가 시스템을 복제하기 위해 보는 회로도가 아니다. 그것은 연구의 **내러티브(Narrative)**를 시각화한 것이다. 따라서 다이어그램 작성의 첫 단계는 소프트웨어를 켜는 것이 아니라, 무엇을 보여주고 무엇을 감출지 결정하는 ’추상화(Abstraction)’의 과정이어야 한다.3</p>
<h3>1.1 논리적 뷰(Logical View) vs. 물리적 뷰(Physical View)</h3>
<p>연구 논문, 특히 AI와 로보틱스 분야에서는 논리적 아키텍처와 물리적 아키텍처를 명확히 구분하거나, 목적에 맞게 혼합해야 한다.</p>
<ul>
<li><strong>논리적 뷰:</strong> 데이터의 흐름, 알고리즘의 처리 단계, 모듈 간의 의존성을 표현한다. 딥러닝 모델의 레이어 구조나 제어 알고리즘의 블록 다이어그램이 이에 해당한다. 여기서 중요한 것은 “어떤 연산이 일어나는가“이다.4</li>
<li><strong>물리적 뷰:</strong> 실제 하드웨어 배치, 네트워크 연결, 로봇의 센서 위치 등을 표현한다. 로보틱스 시스템 논문이나 분산 처리 시스템 연구에서는 이 뷰가 필수적이다.5</li>
</ul>
<p>성공적인 논문은 이 두 가지를 혼동하지 않는다. 만약 당신의 연구가 새로운 딥러닝 모델을 제안하는 것이라면, 물리적 서버가 몇 대인지나 GPU가 무엇인지는 아키텍처 그림에 들어갈 필요가 없다. 반면, 멀티 로봇 협업 시스템을 제안한다면 로봇 간의 통신 토폴로지(Topology)가 핵심이 되므로 물리적 연결도가 중요해진다.</p>
<h3>1.2 블랙박스와 화이트박스의 전략적 배치</h3>
<p>모든 컴포넌트를 동일한 상세도로 그리는 것은 독자의 인지 부하(Cognitive Load)를 가중시킨다. 연구의 핵심 기여점(Contribution)은 ’화이트박스(White Box)’로 내부를 상세히 보여주고, 이미 널리 알려진 기술이나 중요도가 낮은 전처리/후처리 모듈은 ’블랙박스(Black Box)’로 처리해야 한다.6</p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>처리 전략</strong></th><th><strong>예시 (AI/Robotics)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 기여 (Contribution)</strong></td><td><strong>상세 시각화 (Detailed Visualization):</strong> 내부 구조, 데이터 차원 변화, 수식 기호와의 매핑을 명확히 표현. 시각적 강조(Highlight) 적용.</td><td>제안하는 Attention 모듈, 새로운 손실 함수 계산 경로, 독창적인 제어 루프.</td></tr>
<tr><td><strong>기반 기술 (Backbone)</strong></td><td><strong>추상화 (Abstraction):</strong> 하나의 블록으로 축약하고 표준 명칭 사용.</td><td>ResNet-50 Feature Extractor, 표준 PID 제어기, ROS Navigation Stack.</td></tr>
<tr><td><strong>인프라/환경</strong></td><td><strong>아이콘화 (Iconography):</strong> 텍스트보다는 직관적인 아이콘이나 간략한 그림으로 대체.</td><td>클라우드 서버, 카메라 센서, 시뮬레이션 환경(Unity/Gazebo).</td></tr>
</tbody></table>
<h3>1.3 입력과 출력의 명확성</h3>
<p>시스템 아키텍처는 반드시 ’입력(Input)’에서 시작해 ’출력(Output)’으로 끝나야 한다. 이는 시스템의 경계(Boundary)를 정의하는 행위다. AI 모델이라면 입력 텐서(<span class="math math-inline">H \times W \times C</span>)와 출력 예측값(Class Probability, Bounding Box 등)이 명시되어야 하고, 로봇 제어 시스템이라면 센서 데이터(Raw Data)와 액추에이터 명령(Torque/Velocity Command)이 양끝에 위치해야 한다. 시작과 끝이 불분명한 다이어그램은 독자를 미궁에 빠뜨린다.7</p>
<h2>2.  도구의 선정: 벡터 그래픽의 전장</h2>
<p>“도대체 이 그림은 무슨 툴로 그렸나요?” 연구자들이 가장 많이 하는 질문이다. 결론부터 말하자면, 논문용 다이어그램은 반드시 **벡터 그래픽(Vector Graphics)**이어야 한다. 래스터(Raster, 픽셀 기반) 이미지는 확대 시 깨짐 현상이 발생하여 논문의 전문성을 크게 훼손한다.9 도구 선택은 연구자의 숙련도, 시스템의 성격(AI vs Robotics), 그리고 자동화 필요 여부에 따라 달라진다.</p>
<h3>2.1 전문가용 GUI 벡터 도구</h3>
<p>미적인 완성도와 디자인의 자유도를 최우선으로 한다면 GUI 기반의 전문 벡터 툴이 정답이다.</p>
<ul>
<li><strong>Adobe Illustrator:</strong> 업계 표준이다. 가장 강력한 기능을 제공하며, PDF 및 EPS 내보내기 품질이 우수하다. CMYK 색상 모드를 지원하여 출판 시 색감 왜곡을 방지할 수 있다. 단점은 유료 구독 모델이며 학습 곡선이 높다는 점이다.11</li>
<li><strong>Inkscape:</strong> 오픈소스 진영의 강자다. 무료이며 Linux, Windows, Mac을 모두 지원한다. Illustrator의 대안으로 손색이 없으며, 특히 LaTeX 수식 입력 플러그인(TexText)을 통해 수식을 깔끔하게 넣을 수 있다는 점은 연구자에게 큰 매력이다. 다만 인터페이스가 다소 투박하고 Mac 환경에서의 안정성이 떨어질 수 있다.9</li>
<li><strong>PowerPoint:</strong> 가장 접근성이 높다. 많은 연구자가 초안을 PPT로 잡는다. 하지만 PPT는 근본적으로 프레젠테이션 툴이지 벡터 드로잉 툴이 아니다. PDF로 내보낼 때 여백 설정이 까다롭고, 복잡한 곡선이나 정밀한 정렬(Alignment) 기능이 부족하다. 급할 때는 쓸 수 있지만, 탑 티어 학회(CVPR, ICRA 등) 제출용으로는 권장하지 않는다. 만약 사용해야 한다면, 반드시 고해상도(300dpi 이상) 설정과 벡터 내보내기(EMF/PDF)를 활용해야 한다.14</li>
</ul>
<h3>2.2 코드 기반 도구 (Programmable Visualization)</h3>
<p>시스템의 구조가 자주 변경되거나, 정확한 수학적 비율이 중요한 경우 코드로 그림을 그리는 것이 유리하다. 이는 ‘재현 가능한 연구(Reproducible Research)’ 철학에도 부합한다.</p>
<ul>
<li><strong>LaTeX / TikZ:</strong> 논문 원고(tex 파일) 내에서 코드로 그림을 그린다. 본문의 폰트, 수식 스타일과 다이어그램 내부의 스타일이 100% 일치한다는, 타의 추종을 불허하는 장점이 있다. <code>PlotNeuralNet</code>과 같은 라이브러리를 사용하면 복잡한 3D CNN 구조를 몇 줄의 코드로 생성할 수 있다.16 단점은 극악의 학습 난이도다. 선 하나를 옮기기 위해 컴파일을 반복해야 한다. 그러나 한 번 익혀두면 평생의 자산이 된다.18</li>
<li><strong>Python 기반 도구 (NN-SVG, Netron):</strong> 딥러닝 모델 파일(Keras, PyTorch, ONNX)을 읽어 자동으로 시각화해준다. <code>NN-SVG</code>는 벡터(SVG) 출력을 지원하여 논문 삽입에 용이하다.20 하지만 자동 생성된 그림은 논문의 문맥을 완벽히 반영하지 못하므로, 이를 기본(Base)으로 삼아 Illustrator나 Inkscape에서 후가공(Post-processing)하는 워크플로우가 효율적이다.</li>
<li><strong>Graphviz / Mermaid:</strong> 알고리즘 흐름도(Flowchart)나 상태 머신(State Machine)을 그릴 때 유용하다. 레이아웃을 자동으로 잡아주므로 구조 파악에는 좋으나, 논문에 싣기에는 심미적으로 부족할 수 있다.21</li>
</ul>
<h3>2.3 도구 선택 가이드라인</h3>
<table><thead><tr><th><strong>연구자의 요구 사항</strong></th><th><strong>추천 도구</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>최고의 디자인 품질 &amp; 자유도</strong></td><td><strong>Adobe Illustrator</strong></td><td>유료, 학습 필요</td></tr>
<tr><td><strong>무료 &amp; 고품질 벡터</strong></td><td><strong>Inkscape</strong></td><td>오픈소스</td></tr>
<tr><td><strong>논문 폰트/수식과의 완벽한 일치</strong></td><td><strong>LaTeX (TikZ)</strong></td><td>코딩 필요, 높은 난이도</td></tr>
<tr><td><strong>딥러닝 모델 구조 자동 시각화</strong></td><td><strong>PlotNeuralNet / NN-SVG</strong></td><td>Python 기반, 후가공 권장</td></tr>
<tr><td><strong>빠른 초안 작성</strong></td><td><strong>PowerPoint / Draw.io</strong></td><td>최종본으로는 비추천</td></tr>
</tbody></table>
<h2>3.  인공지능(AI) 논문을 위한 아키텍처 전략</h2>
<p>딥러닝, 특히 컴퓨터 비전(Computer Vision)이나 자연어 처리(NLP) 논문의 아키텍처 다이어그램은 데이터(텐서)의 흐름과 연산(Operation)의 변화를 시각화하는 것이 핵심이다.</p>
<h3>3.1  텐서(Tensor)의 차원과 변환 과정 시각화</h3>
<p>독자는 모델이 입력을 어떻게 변형시키는지 알고 싶어 한다. 단순히 “Conv Layer“라고 쓰지 말고, 해당 레이어를 통과한 후의 데이터 형태(Shape)를 명시하라.</p>
<ul>
<li><strong>3D 직육면체 표현:</strong> CNN 계열의 경우, 특징 맵(Feature Map)을 직육면체(<span class="math math-inline">H \times W \times C</span>)로 표현하고, 풀링(Pooling)이나 업샘플링(Upsampling)에 따른 크기 변화를 시각적으로 보여주어야 한다.8</li>
<li><strong>차원 표기:</strong> 각 단계마다 텐서의 크기(예: <span class="math math-inline">64 \times 64 \times 256</span>)를 텍스트로 명기한다. 이는 독자가 모델의 파라미터 수와 연산량을 가늠하는 데 중요한 단서가 된다.</li>
</ul>
<h3>3.2  복잡한 모듈의 계층적 분해</h3>
<p>최신 모델(Transformer, Diffusion Model 등)은 매우 깊고 복잡하다. 이를 한 그림에 모두 담으려 하면 ’스파게티’가 된다.</p>
<ul>
<li><strong>매크로-마이크로 구조:</strong> 전체 아키텍처를 보여주는 ’매크로 뷰(Macro View)’와 핵심 모듈(예: Multi-Head Attention, Residual Block)의 내부를 보여주는 ’마이크로 뷰(Micro View)’를 분리하거나 중첩(Nested)하여 표현한다. 점선 박스(Zoom-in 효과)를 활용하여 독자의 시선을 유도하라.6</li>
</ul>
<h3>3.3  수식과의 일관성 (Symbol consistency)</h3>
<p>다이어그램에 사용된 기호(<span class="math math-inline">x_t, h_{t-1}, W_q</span>)는 본문 수식에 사용된 기호와 <strong>완벽하게 일치</strong>해야 한다. 그림에서는 <span class="math math-inline">I</span>라고 쓰고 수식에서는 <span class="math math-inline">x</span>라고 쓰면 독자는 혼란에 빠진다. 폰트 스타일(이탤릭체 등)까지 맞춰주는 디테일이 논문의 품격을 높인다.23</p>
<h2>4.  로보틱스(Robotics) 논문을 위한 아키텍처 전략</h2>
<p>로보틱스 논문은 소프트웨어 알고리즘뿐만 아니라 하드웨어, 물리적 환경, 그리고 제어 루프(Control Loop)가 포함되어야 한다는 점에서 AI 논문과 차별화된다.</p>
<h3>4.1  하드웨어-소프트웨어 인터페이스의 명시</h3>
<p>로봇 시스템은 센서 데이터가 하드웨어에서 소프트웨어로 넘어오고, 다시 제어 명령이 하드웨어로 나가는 순환 구조를 가진다.</p>
<ul>
<li><strong>전체 파이프라인(Pipeline):</strong> 센서(Camera, LiDAR, IMU) <span class="math math-inline">\rightarrow</span> 인식(Perception) <span class="math math-inline">\rightarrow</span> 계획(Planning) <span class="math math-inline">\rightarrow</span> 제어(Control) <span class="math math-inline">\rightarrow</span> 액추에이터(Motor Driver)로 이어지는 흐름을 명확히 한다.7</li>
<li><strong>ROS 그래프의 재구성:</strong> ROS(Robot Operating System)를 사용하는 경우, 노드(Node)와 토픽(Topic) 관계가 중요하다. 하지만 <code>rqt_graph</code>의 스크린샷을 그대로 논문에 싣는 것은 절대 금물이다. 이는 너무 복잡하고 가독성이 떨어진다. 핵심 노드와 메시지 흐름만을 추려내어 벡터 툴로 다시 깔끔하게 그려야 한다.25</li>
</ul>
<h3>4.2  제어 루프와 피드백 (Feedback Loop)</h3>
<p>제어 이론 기반의 논문에서는 피드백 경로가 가장 중요하다.</p>
<ul>
<li><strong>블록 다이어그램 표준:</strong> 제어 시스템은 표준 블록 다이어그램 표기법(Summing Junction, Transfer Function Block, Feedback Path)을 따르는 것이 좋다. 화살표의 방향이 명확해야 하며, 피드백 신호가 어디서 합류하는지(Summing Point)를 정확히 묘사해야 한다.27</li>
<li><strong>상태 추정(State Estimation):</strong> 실제 값(Ground Truth)과 추정 값(Estimated State)이 어디서 비교되고 오차(Error)가 계산되는지 보여준다.</li>
</ul>
<h3>4.3  환경(Environment)과의 상호작용</h3>
<p>로봇은 진공 속에서 작동하지 않는다. 로봇 아이콘이나 시뮬레이션/실제 환경의 이미지를 다이어그램의 배경이나 요소로 포함시켜, 이 시스템이 ’현실 세계’와 상호작용하고 있음을 시각적으로 강조한다. 예를 들어, 로봇 팔이 물체를 집는 그림을 입력 부분에 배치하면 독자의 이해도가 훨씬 높아진다.1</p>
<h2>5.  시각적 계층 구조와 디자인 원칙</h2>
<p>좋은 다이어그램은 예쁜 그림이 아니라 ‘잘 읽히는’ 그림이다. 이를 위해 시각적 계층 구조(Visual Hierarchy)를 설계해야 한다.</p>
<h3>5.1 레이아웃의 흐름 (Flow)</h3>
<ul>
<li><strong>좌에서 우 (Left-to-Right):</strong> 시간의 흐름, 데이터 처리 파이프라인, Feedforward 네트워크를 표현할 때 가장 자연스럽다. 서구권 언어의 읽기 방향과 일치하여 인지적 저항이 없다.27</li>
<li><strong>위에서 아래 (Top-Down):</strong> 시스템 스택(System Stack), 계층적 구조(Hierarchy), 클래스 다이어그램 등을 표현할 때 적합하다. 상위 레벨(Application Layer)에서 하위 레벨(Hardware Layer)로 내려가는 구조를 보여준다.30</li>
</ul>
<h3>5.2 정렬과 여백 (Alignment &amp; Whitespace)</h3>
<p>아마추어와 프로의 차이는 ’정렬’에서 드러난다.</p>
<ul>
<li><strong>그리드(Grid) 정렬:</strong> 모든 박스와 화살표는 보이지 않는 격자에 맞춰 정렬되어야 한다. 중심선 맞춤, 등간격 배치는 시각적 안정감을 준다.</li>
<li><strong>여백의 미:</strong> 정보를 꽉 채우려 하지 마라. 충분한 여백(Whitespace)은 정보를 그룹핑(Grouping)하고 독자가 숨 쉴 틈을 준다. 복잡한 그림일수록 여백이 더 필요하다.31</li>
</ul>
<h3>5.3 색상 전략: 정보로서의 색상</h3>
<p>색상은 장식이 아니다. 색상은 정보를 분류하는 코드다.</p>
<ul>
<li><strong>의미론적 색상 (Semantic Coloring):</strong> 같은 기능을 하는 모듈은 같은 색으로, 다른 기능은 다른 색으로 칠한다. 예를 들어, 모든 ’학습 가능한 파라미터’는 파란색, ’고정된 파라미터’는 회색으로 표시한다.</li>
<li><strong>색각 이상 고려 (Color Accessibility):</strong> 적록생맹 등 색각 이상을 가진 독자도 정보를 구분할 수 있어야 한다. 빨강(Red)과 초록(Green)을 대비시키는 것은 최악이다. 대신 <strong>파랑(Blue)과 주황(Orange)</strong>, 또는 <strong>Viridis, Magma</strong>와 같은 색각 이상 친화적 팔레트를 사용하라. 명도(Brightness) 차이를 함께 주거나, 패턴(빗금 등)을 활용하는 것도 좋은 방법이다.32</li>
</ul>
<h3>5.4 타이포그래피와 선(Line)의 규칙</h3>
<ul>
<li><strong>폰트:</strong> 다이어그램 내부 텍스트는 <strong>산세리프(Sans-Serif)</strong> 폰트를 사용하는 것이 불문율이다. 본문은 세리프(Times New Roman 등)를 쓰더라도, 그림 내부는 <strong>Helvetica, Arial, Roboto</strong> 등을 사용하여 가독성을 높인다. 폰트 크기는 그림을 축소했을 때 최소 8pt 이상이 되도록 하여 가독성을 확보한다.34</li>
<li><strong>선 두께:</strong> 주요 데이터 흐름(Main Path)은 굵게(1pt 이상), 보조 신호나 주석은 얇게(0.5pt) 처리하여 위계를 둔다. IEEE 등 주요 학회는 최소 선 두께(Hairline rule)를 규정하고 있으므로 이를 준수해야 한다.34</li>
</ul>
<h2>6.  실전 워크플로우: 스케치에서 벡터까지</h2>
<p>이제 이론을 바탕으로 실제 다이어그램을 완성하는 단계별 워크플로우를 따른다.</p>
<h3>6.1 Step 1. 펜과 종이로 구조 잡기 (Analog Sketch)</h3>
<p>컴퓨터를 켜기 전에 종이와 펜을 들어라. 전체적인 레이아웃, 핵심 컴포넌트, 데이터 흐름을 손으로 그려본다. 논리적 오류는 이 단계에서 잡는 것이 가장 빠르다. “이 화살표가 왜 여기로 가지?“라는 의문을 스스로 해결하라.3</p>
<h3>6.2 Step 2. 도구에서 뼈대 만들기 (Blocking)</h3>
<p>선택한 벡터 툴(Illustrator, Inkscape 등)을 열고, 스케치를 바탕으로 기본 도형(사각형, 원)들을 배치한다. 이때 색상이나 폰트는 신경 쓰지 말고, 전체적인 **비례(Proportion)**와 **배치(Layout)**에 집중한다. 그리드 기능을 켜고 정렬을 맞춘다.</p>
<h3>6.3 Step 3. 연결 및 상세화 (Connection &amp; Detailing)</h3>
<p>컴포넌트 사이를 화살표로 연결하고, 텍스트(변수명, 차원, 모듈명)를 입력한다. 제안하는 핵심 모듈(Novel Module)은 더 상세하게 그리고, 기존 모듈은 단순화한다. 필요한 경우 아이콘을 배치한다.</p>
<h3>6.4 Step 4. 스타일링 및 강조 (Styling)</h3>
<p>미리 정해둔 컬러 팔레트를 적용한다. 제안하는 기법(Ours)을 **강조색(Highlight Color)**으로 처리하여 독자의 시선을 끈다. 불필요한 그림자(Drop Shadow)나 3D 효과는 제거하고, 현대적인 **플랫 디자인(Flat Design)**을 지향한다.</p>
<h3>6.5 Step 5. 검증 (Review)</h3>
<p>연구 내용을 전혀 모르는 동료에게 그림만 보여주고 설명을 부탁해 본다. 동료가 엉뚱하게 해석한다면 그림 실패다. 피드백을 반영하여 수정한다.</p>
<h2>7.  피해야 할 안티 패턴 (Anti-Patterns)</h2>
<p>마지막으로, 논문의 품격을 떨어뜨리는 흔한 실수들을 점검한다.</p>
<ol>
<li><strong>스파게티 다이어그램:</strong> 선들이 무질서하게 꼬이고 교차하여 흐름을 알 수 없는 경우. 배치를 다시 하거나, 복잡한 부분을 별도의 서브 다이어그램으로 분리하라.38</li>
<li><strong>범례(Legend) 누락:</strong> 점선이 무엇을 의미하는지, 파란색 박스가 무엇인지 설명이 없다면 독자는 추측해야 한다. 모든 시각적 기호는 범례나 캡션에서 정의되어야 한다.39</li>
<li><strong>비일관성:</strong> 앞에서는 입력 <span class="math math-inline">x</span>를 원으로 그렸는데, 뒤에서는 사각형으로 그리는 경우. 논문 전체에서 기호와 도형의 의미는 일관되어야 한다.</li>
<li><strong>텍스트 과다:</strong> 다이어그램에 소설을 쓰지 마라. 텍스트는 키워드 위주로 간결하게, 자세한 설명은 본문으로 넘겨라.</li>
<li><strong>래스터 이미지 혼용:</strong> 벡터 그림 안에 해상도가 낮은 비트맵 이미지를 붙여 넣는 행위. 확대 시 흐릿해지며 매우 전문성이 떨어져 보인다.</li>
</ol>
<p>시스템 아키텍처 다이어그램은 연구자의 머릿속에 있는 아이디어를 세상 밖으로 꺼내는 첫 번째 관문이다. 이 그림이 명확하고 아름답다면, 독자는 기꺼이 당신의 복잡한 수식과 실험 결과 속으로 들어올 것이다. 다음 장에서는 이 지도를 바탕으로, 실험 결과를 가장 효과적으로 보여주는 ’그래프 작성의 도(道)’에 대해 다룬다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Diagram of the system architecture. The communication between all the components used is represented. - ResearchGate, https://www.researchgate.net/figure/Diagram-of-the-system-architecture-The-communication-between-all-the-components-used-is_fig3_338586840</li>
<li>A Systematic Mapping Study on Software Architecture for AI-based Mobility Systems - arXiv, https://arxiv.org/abs/2506.01595</li>
<li>Architectural diagrams: What is, how to draw and templates - Miro, https://miro.com/diagramming/what-is-software-architecture-diagramming/</li>
<li>System architecture diagram basics &amp; best practices - vFunction, https://vfunction.com/blog/architecture-diagram-guide/</li>
<li>Principles of Design Diagramming - Dell Learning, https://learning.dell.com/content/dam/dell-emc/documents/en-us/2015KS_Pantyukhin-Principles_of_Design_Diagramming.pdf</li>
<li>The Art and Science of Architecture Diagrams - Catio.tech, https://www.catio.tech/blog/the-art-and-science-of-architecture-diagrams</li>
<li>Vision-Based Pick and Place Control System for Industrial Robots Using an Eye-in-Hand Camera - IEEE Xplore, https://ieeexplore.ieee.org/iel8/6287639/10820123/10858145.pdf</li>
<li>Illustrating (Convolutional) Neural Networks in LaTeX with TikZ - David Stutz, https://davidstutz.de/illustrating-convolutional-neural-networks-in-latex-with-tikz/</li>
<li>Comparing Multimedia Software: Adobe Illustrator CC and Inkscape – News - UD Library, https://library.udel.edu/news/2025/05/12/illustrator-and-inkscape/</li>
<li>How do you make those nice figures in journal papers? : r/GradSchool - Reddit, https://www.reddit.com/r/GradSchool/comments/wif918/how_do_you_make_those_nice_figures_in_journal/</li>
<li>Scientific Illustration Software: A Comparison Guide, https://www.scidart.com/blog/scientific-illustration-software-a-comparison-guide/</li>
<li>How to Make Scientific Figures &amp; Illustrations with Adobe Illustrator, https://www.simplifiedsciencepublishing.com/resources/how-to-make-scientific-figures-and-illustrations-with-adobe-illustrator</li>
<li>Software to create scientific figures? : r/labrats - Reddit, https://www.reddit.com/r/labrats/comments/9zfwvx/software_to_create_scientific_figures/</li>
<li>What are some tools available for drawing good figures for computer science research papers and presentations - Academia Stack Exchange, https://academia.stackexchange.com/questions/141232/what-are-some-tools-available-for-drawing-good-figures-for-computer-science-rese</li>
<li>Any software better than PPT for organizing figures for publication? : r/labrats - Reddit, https://www.reddit.com/r/labrats/comments/194f6t6/any_software_better_than_ppt_for_organizing/</li>
<li>HarisIqbal88/PlotNeuralNet: Latex code for making neural networks diagrams - GitHub, https://github.com/HarisIqbal88/PlotNeuralNet</li>
<li>fraserlove/nntikz: A collection of TikZ diagrams of neural networks and deep learning concepts for academic use. - GitHub, https://github.com/fraserlove/nntikz</li>
<li>How to Make Scientific Figures: Comparisons Guide - Vexlio, https://vexlio.com/comparisons/how-to-make-scientific-figures/</li>
<li>Why do people insist on using Tikz when they can use simpler drawing tools? - TeX, https://tex.stackexchange.com/questions/661079/why-do-people-insist-on-using-tikz-when-they-can-use-simpler-drawing-tools</li>
<li>[D] Tools for drawing/visualising Neural Networks that are pretty? - Reddit, https://www.reddit.com/r/MachineLearning/comments/119w7c6/d_tools_for_drawingvisualising_neural_networks/</li>
<li>Bit of a long shot, but has anyone found a proper diagramming tool for AI architecture? : r/LangChain - Reddit, https://www.reddit.com/r/LangChain/comments/1gb0axf/bit_of_a_long_shot_but_has_anyone_found_a_proper/</li>
<li>NeurIPS 2024 Tutorials, https://neurips.cc/virtual/2024/events/tutorial</li>
<li>Building a diagram of a deep learning architecture with tikz - TeX - LaTeX Stack Exchange, https://tex.stackexchange.com/questions/740618/building-a-diagram-of-a-deep-learning-architecture-with-tikz</li>
<li>Software and Hardware Architecture for Autonomous Robots using Distributed Embedded system - ResearchGate, https://www.researchgate.net/publication/258652631_Software_and_Hardware_Architecture_for_Autonomous_Robots_using_Distributed_Embedded_system</li>
<li>A visualization of the ROS computation graph of the developed… | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/A-visualization-of-the-ROS-computation-graph-of-the-developed-inspection-framework-Oval_fig4_358036606</li>
<li>rqt graph - Visualize and Debug Your ROS Graph - The Robotics Back-End, https://roboticsbackend.com/rqt-graph-visualize-and-debug-your-ros-graph/</li>
<li>Block Diagrams of Control Systems 1.4 - CircuitBread, https://www.circuitbread.com/tutorials/block-diagrams-1-4</li>
<li>Feedback Control System Block Diagram | Bani Instind 23 - WordPress.com, https://baniinstind23.wordpress.com/process-controls/control-loops-diagram/feedback-control-system-block-diagram/</li>
<li>Advanced Design of Soft Robots with Artificial Intelligence - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC11176285/</li>
<li>What is Architecture Diagramming? - AWS, https://aws.amazon.com/what-is/architecture-diagramming/</li>
<li>Five Models for Making Sense of Complex Systems | by Christina Wodtke - Medium, https://cwodtke.medium.com/five-models-for-making-sense-of-complex-systems-134be897b6b3</li>
<li>Coloring for Colorblindness - David Nichols, https://davidmathlogic.com/colorblind/</li>
<li>Colorblind Safe Color Schemes, <a href="https://www.nceas.ucsb.edu/sites/default/files/2022-06/Colorblind%20Safe%20Color%20Schemes.pdf">https://www.nceas.ucsb.edu/sites/default/files/2022-06/Colorblind%20Safe%20Color%20Schemes.pdf</a></li>
<li>Style Guide for Figures in Science Writing | Writers Workshop - University of Illinois, https://writersworkshop.illinois.edu/resources-2/writer-resources/academic-writing/style-guide-for-science-writing/</li>
<li>A Classy Collection: The 11 Best Fonts for Exceptional Reporting - PresentationPoint, https://presentationpoint.com/11-best-fonts-for-exceptional-reporting/</li>
<li>Resolution and Size - IEEE Author Center Journals, https://journals.ieeeauthorcenter.ieee.org/create-your-ieee-journal-article/create-graphics-for-your-article/resolution-and-size/</li>
<li>Architecture Program Diagram in Adobe Illustrator - YouTube, https://www.youtube.com/watch?v=j2k3jnacd-k</li>
<li>The Art of Crafting Architectural Diagrams - InfoQ, https://www.infoq.com/articles/crafting-architectural-diagrams/</li>
<li>Top 6 mistakes in software architecture diagrams | by IcePanel - Medium, https://icepanel.medium.com/top-6-mistakes-in-software-architecture-diagrams-e972cfef66ba</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>