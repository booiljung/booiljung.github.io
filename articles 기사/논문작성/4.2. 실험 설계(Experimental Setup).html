<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.2. 실험 설계 (Experimental Setup)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.2. 실험 설계 (Experimental Setup)</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">기사 (Articles)</a> / <a href="index.html">실전 논문 작성 가이드</a> / <span>4.2. 실험 설계 (Experimental Setup)</span></nav>
                </div>
            </header>
            <article>
                <h1>4.2. 실험 설계 (Experimental Setup)</h1>
<h2>1.  서론: 과학적 주장의 검증대와 논문의 허리</h2>
<p>논문의 ‘방법론(Methodology)’ 섹션이 연구자가 제안하는 새로운 아이디어의 논리적 구조와 아키텍처를 설명하는 ’설계도’라면, ‘실험 설계(Experimental Setup)’ 섹션은 그 설계도가 현실 세계(또는 시뮬레이션 세계)에서 실제로 작동하며, 기존의 방법들보다 우월하거나 유의미한 특성을 가진다는 것을 증명하는 ’법정(法庭)’이자 ’전장(Battlefield)’과도 같다. 많은 초심 연구자들이 방법론 섹션에 온 힘을 쏟은 뒤, 정작 논문의 승패를 가르는 실험 설계 섹션을 단순히 “데이터셋 A를 사용했고, 하이퍼파라미터는 B로 설정했다“는 식의 건조한 나열로 채우는 우를 범한다. 그러나 리뷰어(Reviewer)들이 논문을 거절(Reject)할 때 가장 많이, 그리고 가장 치명적으로 공격하는 지점이 바로 이 실험 설계의 허점이다.1 실험 설계가 부실하면 아무리 혁신적인 알고리즘도 ‘운 좋게 얻어걸린 결과’ 또는 ’특정 상황에서만 작동하는 편향된 모델’로 치부되기 십상이다.</p>
<p>실험 설계 섹션은 독자와 리뷰어에게 다음 세 가지 핵심 질문에 대해 명확하고 방어 가능한 답을 제시해야 한다. 첫째, **재현 가능성(Reproducibility)**이다. 제3자가 이 논문만을 보고 동일한 환경을 구축하여 동일한 결과를 만들어낼 수 있는가? 이는 과학적 방법론의 대전제이다.3 둘째, **공정한 비교(Fair Comparison)**이다. 비교 대상(Baseline)들은 최신의 것이며, 제안하는 모델과 동등하고 공정한 조건(동일한 데이터, 동일한 연산 자원 등)에서 경쟁했는가? 셋째, **검증의 타당성(Validity)**이다. 설계된 실험 시나리오와 사용된 평가지표가 연구자가 주장하고자 하는 기여점(Contribution)을 실제로 뒷받침하는가?</p>
<p>특히 인공지능(AI)과 로보틱스 분야는 실험의 복잡도가 타 분야에 비해 월등히 높다. AI 분야(CVPR, NeurIPS 등)에서는 데이터셋의 편향, 학습 파라미터의 미세 조정, 랜덤 시드(Seed)에 따른 성능 변동성, 컴퓨팅 자원의 규모가 중요한 검증 요소가 된다.3 반면 로보틱스 분야(ICRA, IROS 등)에서는 시뮬레이션과 실제 하드웨어 간의 격차(Sim-to-Real Gap), 물리 엔진의 정합성, 센서 노이즈 모델링, 실제 환경의 불확실성 제어 등이 논문의 가치를 결정짓는 치명적인 변수로 작용한다.6 따라서 이 두 분야를 아우르는 실험 설계는 소프트웨어적 엄밀함과 하드웨어적 현실성을 동시에 만족시켜야 하는 고난도의 작업을 요한다.</p>
<p>본 장에서는 단순한 실험 정보의 나열을 넘어, 리뷰어를 설득하고 연구의 견고함을 증명하는 실험 설계의 전략적 접근법을 심도 있게 다룬다. 우리는 독자가 이 섹션을 읽는 것만으로도 머릿속에 실험실의 풍경을 생생하게 그릴 수 있도록, 그리고 당장이라도 코드를 실행하여 결과를 확인해보고 싶도록 만들어야 한다. 이것이 바로 논문을 ‘쓰기’ 전에 ‘이기고’ 들어가는 전략의 핵심이다.</p>
<h2>2.  실험 환경의 구축 (Experimental Environment): 물리적, 가상적 무대의 설정</h2>
<p>실험 환경에 대한 기술은 연구의 ’무대’를 설정하는 것이다. 독자가 연구자가 처한 제약 조건, 사용한 도구, 그리고 환경의 특성을 정확히 이해해야만 도출된 결과의 가치를 올바르게 판단할 수 있다. 환경 설정이 모호하면 결과의 신뢰도는 바닥으로 떨어진다.</p>
<h3>2.1  인공지능 연구를 위한 컴퓨팅 리소스 명세</h3>
<p>딥러닝 기반의 연구, 특히 대규모 언어 모델(LLM)이나 생성형 AI, 고해상도 컴퓨터 비전 연구에서는 사용된 컴퓨팅 리소스가 단순히 실험 도구를 넘어 결과 자체에 영향을 미치는 독립변수가 된다. 예를 들어, 특정 모델이 수백 개의 A100 GPU를 사용하여 학습되었다면, 이는 일반적인 대학 연구실에서 재현하기 어려운 결과임을 시사하며, 실용성 측면에서 공격받을 여지가 있다. 반대로, 제한된 자원(Edge Device 등)에서 고성능을 냈다면 이는 강력한 기여점이 된다. 따라서 하드웨어 스펙은 투명하고 상세하게 공개되어야 한다.4</p>
<p>먼저, **가속기(Accelerator)**의 사양을 명확히 한다. GPU의 모델명(예: NVIDIA A100, RTX 4090, TPU v4), 개수, 그리고 VRAM 용량을 명시해야 한다. VRAM 용량은 배치 크기(Batch Size)를 결정하는 핵심 요인이 되며, 배치 크기는 모델의 수렴 속도와 최종 성능(Generalization Gap)에 영향을 미친다. 또한, 분산 학습(Distributed Training)을 수행했다면 사용된 노드의 수와 통신 백엔드(예: NCCL, Gloo) 설정까지 언급하는 것이 재현성을 높이는 길이다.</p>
<p>둘째, <strong>CPU 및 메모리(RAM)</strong> 사양을 간과해서는 안 된다. 데이터 로딩(Data Loading)이나 전처리(Preprocessing)가 병목이 되는 비전 연구나, 시뮬레이션 환경을 병렬로 돌려야 하는 강화학습(RL) 연구에서는 CPU의 코어 수와 클럭 속도, 시스템 메모리 용량이 전체 실험 시간(Training Wall-clock Time)을 좌우한다.</p>
<p>셋째, <strong>소프트웨어 스택</strong>을 버전을 포함하여 명시한다. PyTorch, TensorFlow, JAX 등의 프레임워크 버전뿐만 아니라, CUDA, cuDNN 버전까지 기록하는 것이 좋다. 특정 버전의 라이브러리에서만 발생하는 버그나 성능 최적화 이슈가 존재하기 때문에, 이는 ‘디버깅 가능한’ 논문을 만드는 기초가 된다.</p>
<p><strong>[표 4.2.1] 컴퓨팅 환경 명세 예시 (나쁜 예 vs 좋은 예)</strong></p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>나쁜 예 (모호함, 정보 가치 없음)</strong></th><th><strong>좋은 예 (구체적, 재현 가능성 확보)</strong></th></tr></thead><tbody>
<tr><td><strong>GPU 기술</strong></td><td>“우리는 고성능 GPU를 사용하여 모델을 학습시켰다.”</td><td>“Experiments were conducted on a cluster with 8 NVIDIA A100 GPUs (80GB VRAM per GPU). Total compute budget was approx. 500 GPU-hours.”</td></tr>
<tr><td><strong>환경 설정</strong></td><td>“PyTorch를 사용했다.”</td><td>“Implemented in PyTorch 2.1.0 with CUDA 11.8 and cuDNN 8.7. We used automatic mixed precision (AMP) for efficiency.”</td></tr>
<tr><td><strong>학습 시간</strong></td><td>“학습에 며칠이 걸렸다.”</td><td>“Training took 48 hours for 100 epochs on a single node with 4 GPUs, using a global batch size of 256.”</td></tr>
</tbody></table>
<h3>2.2  로보틱스 하드웨어 셋업 (Robotic Hardware Setup): 현실 세계의 복잡성 기술</h3>
<p>로보틱스 논문(ICRA, IROS, RSS)에서 하드웨어 셋업 기술은 독자가 물리적 상호작용의 맥락을 이해하는 데 결정적이다. 로봇은 이상적인 강체(Rigid Body)가 아니며, 센서는 노이즈를 포함하고, 환경은 불확실하다. 이 섹션은 마치 ’실험 장비 매뉴얼’이나 ’조립 설명서’를 방불케 할 정도로 상세해야 한다.7</p>
<p>첫째, **로봇 플랫폼(Robot Platform)**을 구체화한다. 매니퓰레이터라면 모델명(예: Franka Emika Panda, UR5e, KUKA iiwa)과 자유도(DoF), 가반 하중(Payload), 반복 정밀도(Repeatability)를 명시한다. 모바일 로봇이라면 구동 방식(Differential Drive, Ackerman Steering, Omnidirectional), 바퀴의 재질, 로봇의 크기와 무게 등을 적어야 한다. 만약 상용 로봇을 개조(Customization)했다면, 개조된 부분의 설계 도면이나 CAD 모델을 부록(Appendix)으로 제공하는 것이 좋다.12</p>
<p>둘째, **센서 구성(Sensor Configuration)**은 실험의 눈과 귀가 된다. 카메라(RGB, Depth, Stereo, Event Camera), 라이다(LiDAR), IMU, 힘/토크 센서(F/T Sensor) 등의 모델명과 구체적인 스펙(해상도, FPS, 노이즈 레벨, 측정 범위)을 기술한다. 여기서 가장 중요한 것은 **센서의 설치 위치(Extrinsic Parameters)**이다. 카메라가 ‘Eye-in-hand’(로봇 팔 끝에 부착) 방식인지 ‘Eye-to-hand’(외부 고정) 방식인지에 따라 제어 전략과 좌표계 변환(Hand-Eye Calibration)의 난이도가 완전히 달라진다.13 예를 들어, Eye-in-hand 구성은 정밀한 조작에는 유리하지만 시야각(FOV)이 제한되는 단점이 있으므로, 이러한 선택의 이유를 실험 설계에서 정당화해야 한다.</p>
<p>셋째, **그리퍼 및 엔드 이펙터(End-effector)**에 대한 설명이다. 단순히 “그리퍼를 사용했다“가 아니라, 평행 그리퍼(Parallel Jaw)인지 다지(Multi-fingered) 핸드인지, 흡착형(Suction)인지 구분해야 한다. 특히 연성 로봇(Soft Robotics)이나 비정형 물체 조작 연구에서는 그리퍼의 마찰 계수, 손가락 끝의 재질(실리콘, 고무 등), 악력(Gripping Force)이 실험 성공의 핵심 변수이므로 상세히 기술해야 한다.10</p>
<p>넷째, **환경 제어 및 물체(Environment &amp; Objects)**이다. 실험이 수행된 공간의 조명 조건(제어된 조명 vs 자연광), 바닥의 재질(마찰력), 사용된 물체(YCB Object Set 등 표준 물체인지, 임의로 선정한 물체인지)를 설명한다. 물체의 무게, 크기, 강성(Stiffness) 분포는 로봇의 파지 성공률에 직접적인 영향을 미치므로, 이를 표로 정리하여 제시하는 것이 바람직하다.</p>
<p>[팁: 시각화의 절대적 필요성]</p>
<p>복잡한 하드웨어 셋업을 글로만 설명하는 것은 불가능에 가깝다. 반드시 ‘System Overview Figure’ 또는 **‘Experimental Setup Photo’**를 포함해야 한다.16 실제 실험실 사진에 각 센서의 위치, 좌표계(World Frame, Camera Frame, End-effector Frame), 데이터 및 제어 신호의 흐름(화살표로 표시)을 오버레이(Overlay)하여 시각적으로 명확하게 전달해야 한다. 이는 리뷰어가 “이 실험이 실제로 수행 가능한가?“라는 의구심을 품지 않도록 만드는 가장 강력한 증거가 된다.</p>
<h3>2.3  시뮬레이션 환경 (Simulation Environment): 가상 세계의 정합성</h3>
<p>현대 로보틱스 연구, 특히 강화학습(RL) 기반의 연구는 시뮬레이션 의존도가 높다. 시뮬레이터는 현실의 근사치(Approximation)일 뿐이므로, 시뮬레이터의 설정이 현실과 얼마나 유사한지, 또는 어떤 가정(Assumption)을 하고 있는지를 밝히는 것이 중요하다.18</p>
<ul>
<li><strong>물리 엔진의 선택과 정당성:</strong> 왜 특정 시뮬레이터를 선택했는지 논리적으로 설명한다.</li>
<li><em>MuJoCo:</em> 빠르고 안정적인 접촉 역학(Contact Dynamics)을 제공하여 강화학습 연구의 표준으로 자리 잡았다.21 연속적인 제어(Continuous Control) 문제에 적합하다.</li>
<li><em>PyBullet:</em> 오픈소스이며 URDF(Unified Robot Description Format) 지원이 강력하고, 다양한 로봇 모델을 쉽게 불러올 수 있어 조작(Manipulation) 연구에 널리 쓰인다.20</li>
<li><em>Isaac Gym / Isaac Sim:</em> GPU 병렬 처리를 통해 수천 개의 환경을 동시에 시뮬레이션할 수 있어, 대규모 학습이 필요한 연구에 필수적이다.</li>
<li><em>Gazebo:</em> ROS(Robot Operating System)와의 통합이 강력하여 시스템 레벨의 검증에 유리하다.22</li>
<li><strong>시뮬레이션 파라미터(Simulation Parameters):</strong> 타임 스텝(Time Step, 예: 0.01s), 중력 가속도, 솔버(Solver)의 반복 횟수(Iterations), 마찰 모델(Friction Model) 등을 명시한다. 타임 스텝이 너무 크면 시뮬레이션이 불안정해지고, 너무 작으면 학습 시간이 오래 걸린다.</li>
<li><strong>센서 및 액추에이터 모델링:</strong> 시뮬레이션 상의 카메라는 완벽한 이미지를 생성하고, 모터는 지령한 대로 정확히 움직인다. 그러나 이는 현실과 다르다. 따라서 현실성을 높이기 위해 렌더링 된 이미지에 가우시안 노이즈를 추가했는지, 모터의 토크 제한이나 관성을 모델링했는지, 통신 지연(Latency)을 모사했는지 등을 서술해야 한다. 이러한 ‘비이상적(Non-ideal)’ 요소의 추가는 Sim-to-Real 성공의 열쇠가 된다.8</li>
</ul>
<h2>3.  데이터셋과 벤치마크 (Datasets and Benchmarks): 공정한 경쟁의 운동장</h2>
<p>데이터는 학습 기반 모델의 연료이자 성능 측정의 기준점이다. 어떤 데이터를 사용했느냐가 실험의 공정성을 좌우하며, 데이터의 품질과 다양성은 모델의 일반화(Generalization) 능력을 담보한다.</p>
<h3>3.1  표준 벤치마크의 필수적 사용 (Standard Benchmarks)</h3>
<p>연구 커뮤니티에서 널리 인정받고 사용되는 표준 데이터셋을 사용하는 것은 선택이 아닌 필수다. 독자적인 데이터셋만을 사용하여 성능을 입증하는 것은 “나만의 리그에서 1등 했다“는 주장과 다를 바 없어 설득력이 떨어진다.</p>
<ul>
<li><strong>컴퓨터 비전:</strong> ImageNet, COCO, ADE20K, Pascal VOC 등.</li>
<li><strong>로보틱스:</strong> YCB Object Set(물체 조작), KITTI/NuScenes(자율주행), RLBench/Meta-World(로봇 학습).</li>
<li><strong>주의사항:</strong> 데이터셋의 **버전(Version)**과 **스플릿(Split)**을 정확히 명시해야 한다. 예를 들어, 자율주행 데이터셋인 KITTI는 공식적인 Train/Val 스플릿 외에도 연구자들이 관습적으로 사용하는 여러 스플릿이 존재하므로, “We followed the standard split used in [Author et al.]“과 같이 명확한 레퍼런스를 제시해야 한다.4</li>
</ul>
<h3>3.2  커스텀 데이터셋 구축 (Custom Datasets): 투명성과 다양성 확보</h3>
<p>새로운 문제를 풀거나 기존 데이터셋이 연구 목적에 부합하지 않을 경우, 직접 데이터를 수집해야 한다. 이때는 데이터셋 자체가 연구의 중요한 기여점(Contribution)이 될 수 있으므로, 수집 및 가공 과정을 매우 투명하게 기술해야 한다.</p>
<ol>
<li><strong>수집 프로토콜:</strong> 데이터를 어떻게 수집했는가? 로봇 팔을 직접 원격 조조(Teleoperation)하여 데이터를 모았는지, 사람의 데모 영상을 녹화했는지, 아니면 스크립트를 통해 자동 생성했는지 밝힌다.</li>
<li><strong>어노테이션(Annotation) 및 검수:</strong> 정답(Ground Truth) 레이블을 누가, 어떤 기준으로 달았는가? 크라우드 소싱을 이용했다면 작업자 교육 과정과 품질 관리(QA) 절차를 기술해야 데이터의 신뢰성을 얻을 수 있다.</li>
<li><strong>통계적 분포(Statistics):</strong> 데이터의 클래스 불균형(Class Imbalance), 객체 크기 분포, 조명 조건의 다양성, 배경의 복잡도 등을 히스토그램이나 파이 차트로 시각화하여 제시한다. 데이터가 특정 조건에 편향되지 않고 충분한 다양성(Diversity)을 가짐을 증명해야 한다.24</li>
<li><strong>윤리적 고려 및 공개 여부:</strong> 사람의 얼굴이나 개인정보가 포함된 경우 비식별화(Anonymization) 조치를 취했음을 명시하고, IRB(Institutional Review Board) 승인 여부를 언급한다. 또한, 데이터셋 공개 여부(Open Access)는 논문의 파급력을 높이는 중요한 요소이므로, 가능하면 공개 계획을 밝힌다.9</li>
</ol>
<h3>3.3  합성 데이터와 도메인 적응 (Synthetic Data &amp; Domain Adaptation)</h3>
<p>시뮬레이션에서 생성된 합성 데이터를 사용할 경우, ’Sim-to-Real Gap’을 줄이기 위한 전략을 상세히 기술해야 한다. 가장 대표적인 것이 **도메인 무작위화(Domain Randomization)**이다. 텍스처, 조명, 카메라 위치, 물체의 물성치 등을 무작위로 변동시키는 범위와 분포(Uniform, Gaussian 등)를 표로 정리하여 제시한다.27 예를 들어, “조명의 밝기를 [0.5, 1.5] 범위에서 무작위로 변경했고, 물체의 마찰 계수를 로그 정규 분포를 따르도록 설정했다“는 식으로 구체적이어야 한다. 이는 독자가 해당 데이터셋을 재생성하거나 실험 결과를 해석하는 데 필수적인 정보이다.</p>
<h2>4.  비교군 설정 (Baselines): 적수(敵手)의 선정과 예우</h2>
<p>“내 방법이 최고다“라고 주장하기 위해서는, 누구와 싸워 이겼는지가 중요하다. 비교군(Baseline) 선정은 실험 설계에서 가장 공격받기 쉬운 지점이다. 리뷰어들은 습관적으로 “왜 방법 X와는 비교하지 않았는가?“라고 묻는다.1</p>
<h3>4.1  비교군 선정의 3원칙</h3>
<ol>
<li><strong>최신 SOTA (State-of-the-Art):</strong> 해당 분야에서 가장 성능이 좋은 최신 논문(제출일 기준 1~2년 이내)을 반드시 포함해야 한다. 5년 전의 알고리즘과만 비교하여 성능 우위를 주장하는 것은 ’허수아비 때리기(Strawman Fallacy)’로 간주되어 즉각적인 거절 사유가 된다.</li>
<li><strong>표준적 고전 방법(Canonical Methods):</strong> 딥러닝 이전의 전통적인 방법이나, 해당 분야의 ’교과서’적인 방법(예: SLAM에서의 ORB-SLAM, Object Detection에서의 Faster R-CNN)을 포함한다. 이는 제안하는 방법이 딥러닝을 씀으로써 얻는 이득이 전통적인 엔지니어링 접근법을 압도함을 보여주기 위함이다.</li>
<li><strong>유사한 접근법(Direct Competitors):</strong> 제안하는 방법과 기술적 궤를 같이하는 연구들을 비교군으로 삼는다. 예를 들어, 트랜스포머(Transformer) 기반의 모델을 제안했다면, 다른 트랜스포머 기반 모델들과 비교해야지, 구조가 완전히 다른 CNN 모델과만 비교하는 것은 불충분하다.</li>
</ol>
<h3>4.2  공정한 비교를 위한 조건 (Fair Comparison)</h3>
<p>단순히 결과 표에 숫자를 적는 것만으로는 부족하다. 그 숫자가 ’기울어진 운동장’이 아닌 공정한 조건에서 나왔음을 증명해야 한다.29</p>
<ul>
<li><strong>동일한 백본(Backbone) 및 파라미터 수:</strong> 비교하는 모델들이 서로 다른 특징 추출기(예: ResNet-50 vs. ViT-B)를 사용한다면, 성능 차이가 모델 구조(Head)에서 온 것인지 백본의 차이에서 온 것인지 알 수 없다. 가능한 한 백본을 통일하거나, 전체 파라미터 수(Model Size)가 비슷한 수준에서 비교해야 한다.</li>
<li><strong>동일한 학습 데이터 및 전처리:</strong> 외부 데이터(Extra Data)를 사용하여 사전 학습(Pre-training)한 모델과 처음부터 학습(Scratch)한 모델을 직접 비교하는 것은 불공정하다. 이를 명확히 구분하여 표기하거나, 동일한 데이터셋으로 재학습시켜 비교해야 한다.</li>
<li><strong>구현(Implementation)의 출처 명시:</strong> 비교군의 성능 수치를 해당 논문에서 그대로 가져왔는지(Reported), 아니면 직접 동일한 환경에서 재구현(Re-implemented)했는지 명시해야 한다. 만약 재구현했다면, 공식 코드를 사용했는지 여부와 재구현된 성능이 원본 논문과 유사함을 언급하여 신뢰를 얻어야 한다.4</li>
</ul>
<p>[팁: 리뷰어 방어 논리]</p>
<p>만약 특정 SOTA 논문과 비교하지 못했다면, 그 이유를 미리 실험 설계 섹션에 적어두는 것이 좋다. (예: “방법 X는 코드가 공개되지 않았으며, 논문의 세부 사항 부족으로 재구현이 불가능하여 비교에서 제외하였다.” 또는 “방법 Y는 오프라인 처리를 가정하므로, 본 연구의 타겟 애플리케이션인 실시간 로봇 제어와는 비교 범주가 다르다.”) 이는 리뷰어의 공격을 사전에 차단하는 ‘선제적 방어(Pre-emptive Strike)’ 효과가 있다.6</p>
<h2>5.  평가 지표 (Evaluation Metrics): 성과 측정의 자(Ruler)</h2>
<p>결과를 어떤 자(Ruler)로 잴 것인가? 적절한 평가 지표의 선택은 연구의 성패를 가른다. 단순히 정확도(Accuracy) 하나만 제시하는 시대는 지났다. 다각적인 지표를 통해 제안하는 방법의 우수성을 입체적으로 증명해야 한다.32</p>
<h3>5.1  정량적 지표 (Quantitative Metrics): 숫자의 힘</h3>
<p>분야별로 표준화된 지표들을 빠짐없이 포함해야 한다. 임의로 만든 지표(Custom Metric)를 사용할 때는 그 타당성을 강력하게 입증해야 한다.</p>
<ul>
<li><strong>컴퓨터 비전:</strong></li>
<li><em>Classification:</em> Top-1 / Top-5 Accuracy.</li>
<li><em>Detection/Segmentation:</em> IoU (Intersection over Union), mAP (mean Average Precision). 특히 IoU 임계값(0.5, 0.75 등)에 따른 mAP 변화를 보여주거나, 객체의 크기(Small, Medium, Large)에 따른 성능을 분리하여 제시하면 모델의 특성을 더 깊이 있게 분석할 수 있다.23</li>
<li><strong>로보틱스 (Manipulation/Navigation):</strong></li>
<li><em>Success Rate (SR):</em> 작업 성공률. 성공의 기준을 명확히 정의해야 한다(예: “물체를 들어 올려 5초간 떨어뜨리지 않고 유지함”).</li>
<li><em>Completion Time:</em> 작업 완료 시간. 성공하더라도 너무 느리면 실용성이 없다.</li>
<li><em>Path Length &amp; Smoothness:</em> 이동 경로의 효율성과 부드러움. 로봇의 움직임이 덜덜 떨리거나(Jerk), 불필요한 경로로 우회한다면 성공했더라도 실제 현장 적용은 불가능하다.36</li>
<li><em>Safety Violations:</em> 충돌 횟수, 안전 거리 위반 횟수 등.</li>
<li><strong>시스템 효율성 지표:</strong></li>
<li><em>FLOPs (Floating Point Operations):</em> 이론적인 연산량.</li>
<li><em>Inference Latency (FPS):</em> 실제 하드웨어에서의 추론 속도.</li>
<li><em>Memory Footprint:</em> 모델이 차지하는 메모리 용량.</li>
<li><em>Sample Efficiency:</em> 강화학습에서 목표 성능에 도달하기까지 필요한 데이터(에피소드)의 양.</li>
</ul>
<h3>5.2  통계적 유의성 (Statistical Significance): 우연의 배제</h3>
<p>AI와 로보틱스, 특히 강화학습 실험에서는 초기화된 랜덤 시드(Random Seed)에 따라 성능이 크게 달라질 수 있다. 따라서 단 한 번의 실험 결과만 제시하는 것은 과학적으로 무의미하며, 리뷰어에게 공격받기 딱 좋은 빌미를 제공한다.</p>
<ul>
<li><strong>다중 시드 실험(Multi-seed Experiments):</strong> 최소 3번, 권장 5~10번 이상의 서로 다른 랜덤 시드로 실험을 반복하고, 평균(Mean)과 표준편차(Standard Deviation) 또는 표준오차(Standard Error)를 함께 보고해야 한다.4 결과 그래프에는 반드시 에러 바(Error Bar)나 신뢰 구간(Confidence Interval, 보통 95%)을 음영(Shaded Area)으로 표시한다.</li>
<li><strong>유의성 검정(Significance Test):</strong> 성능 차이가 통계적으로 유의미한지 t-test나 bootstrap test 등을 통해 검증하고, p-value를 언급하면 논문의 신뢰도가 급격히 상승한다. “Our method outperforms X with p &lt; 0.05“라는 문장은 단순한 “성능이 더 좋다“는 주장보다 훨씬 강력하다.1</li>
</ul>
<h3>5.3  정성적 평가 (Qualitative Evaluation) 및 사용자 연구</h3>
<p>수치로 표현할 수 없는 성능을 보여주기 위해 시각적 결과물이나 사용자 연구(User Study)가 필요하다.</p>
<ul>
<li><strong>시각적 예시:</strong> 성공 사례뿐만 아니라 **실패 사례(Failure Case)**도 포함하여 알고리즘의 한계를 솔직하게 보여주는 것이 오히려 신뢰를 높인다.6 모델이 어떤 상황에서 헷갈려하는지, 로봇이 왜 물체를 떨어뜨렸는지 분석하는 것은 후속 연구를 위한 중요한 단서가 된다.</li>
<li><strong>사용자 연구 (HRI 분야):</strong> 인간-로봇 상호작용 연구라면, 설문조사(Likert Scale), NASA-TLX(작업 부하 측정), Godspeed Questionnaire(로봇의 인상 평가) 등의 표준화된 도구를 사용하여 인간의 주관적 만족도를 객관화해야 한다.24 이때 참여자 수(N), 인구통계학적 정보, 실험 절차(Within-subjects vs Between-subjects)를 상세히 기술해야 윤리적, 통계적 타당성을 인정받는다.</li>
</ul>
<h2>6.  구현 세부 사항 (Implementation Details): 재현을 위한 레시피</h2>
<p>이 섹션은 “재현 가능성“을 위한 가장 실무적인 가이드북이다. 독자가 이 내용을 보고 코드를 짤 수 있어야 하며, 논문대로 구현했는데 결과가 다르다면 이 섹션의 정보가 부족한 것이다. 숨김없이 모든 ’비법’을 공개해야 한다.</p>
<h3>6.1  하이퍼파라미터 (Hyperparameters)</h3>
<p>모델 학습에 사용된 모든 주요 하이퍼파라미터를 본문 내 표(Table)로 정리하거나, 지면이 부족하면 부록(Appendix)에 반드시 수록한다.</p>
<ul>
<li><strong>학습 파라미터:</strong> Learning Rate, Batch Size, Optimizer 종류(Adam, SGD 등) 및 세부 파라미터(beta1, beta2, momentum), Weight Decay, Dropout Rate, Epoch 수.</li>
<li><strong>스케줄러:</strong> Learning Rate Decay 전략(Cosine Annealing, Step Decay 등)과 Warm-up 기간.</li>
<li><strong>강화학습 특화:</strong> Reward Function의 수식과 각 항의 가중치(Coefficient), Discount Factor (gamma), Buffer Size, Entropy Coefficient, GAE Parameter (lambda) 등. 보상 함수(Reward Function) 설계는 RL 논문에서 가장 중요한 부분 중 하나이므로, 수식과 함께 왜 그렇게 설계했는지에 대한 직관(Intuition)을 설명해야 한다.15</li>
<li><strong>초기화:</strong> 가중치 초기화 방법(Xavier, Kaiming 등)이나 사전 학습 모델 사용 여부.</li>
</ul>
<h3>6.2  데이터 전처리 및 증강 (Preprocessing &amp; Augmentation)</h3>
<p>입력 데이터가 모델에 들어가기 전에 거치는 모든 과정을 기술한다.</p>
<ul>
<li><strong>이미지:</strong> 리사이즈(Resize), 크롭(Crop) 방식, 정규화(Normalization) 방법(예: ImageNet mean/std 사용, 또는  스케일링), 색상 변환(Color Jittering) 등.</li>
<li><strong>로봇 센서:</strong> 센서 데이터의 노이즈 필터링(Low-pass filter, Kalman filter), 좌표계 변환, 다운샘플링(Downsampling), 포인트 클라우드 전처리(Voxelization) 등.</li>
</ul>
<h3>6.3  코드 공개 (Code Release)</h3>
<p>최근 Top-tier 학회(NeurIPS, CVPR, ICRA 등)는 코드 제출을 강력히 권장하거나 의무화하고 있다. 코드 공개는 재현성을 보장하는 가장 확실한 방법이다.</p>
<ul>
<li>“We will release the source code and checkpoints upon acceptance.” (게재 승인 시 공개하겠다)라는 문구보다는,</li>
<li>가능하다면 익명화된 저장소(Anonymous Repository, 예: GitHub Anonymous, OSF) 링크를 제출 시점에 포함하는 것이 리뷰어에게 훨씬 긍정적인 인상을 준다.4</li>
<li>코드는 단순히 파일만 올리는 것이 아니라, <code>README.md</code>에 실행 환경(Environment.yaml)과 실행 명령어, 데이터 다운로드 스크립트 등을 포함하여 ‘실행 가능한(Executable)’ 상태여야 한다.</li>
</ul>
<h2>7.  절개 연구(Ablation Study) 설계: 필연성의 증명</h2>
<p>본문의 실험 섹션에서 ’절개 연구(Ablation Study)’는 선택이 아니라 필수다. 제안하는 방법이 3가지 새로운 모듈(A, B, C)로 구성되어 있다면, 단순히 “A+B+C“의 최종 결과만 보여줘서는 안 된다. 독자와 리뷰어는 “정말 A가 필요한가? B만 있어도 되는 것 아닌가?“라는 의문을 갖는다. 이를 해소하기 위해 구성 요소를 하나씩 제거하거나 변경해가며 성능 변화를 추적해야 한다.</p>
<h3>7.1  단계적 성능 분석 (Component-wise Analysis)</h3>
<p>다음과 같은 구성을 표로 제시하여 각 모듈의 기여도를 정량적으로 보여준다.</p>
<ol>
<li><strong>Baseline:</strong> 기본 모델 (아무것도 적용하지 않음).</li>
<li><strong>Base + A:</strong> 모듈 A만 적용했을 때.</li>
<li><strong>Base + B:</strong> 모듈 B만 적용했을 때.</li>
<li><strong>Base + A + B:</strong> 모듈 A와 B를 결합했을 때.</li>
<li><strong>Proposed (Base + A + B + C):</strong> 제안하는 전체 모델.</li>
</ol>
<p>위 표를 통해 각 모듈이 추가될 때마다 성능이 어떻게 향상되는지 보여주어야 한다. 만약 모듈 C를 더했는데 성능 향상이 미미하거나 오히려 떨어진다면, 리뷰어는 “C는 왜 넣었는가?“라고 공격할 것이다. 이에 대해 “C는 성능(Accuracy) 향상은 적지만 학습 안정성(Stability)이나 수렴 속도를 높여준다“는 식의 별도 지표를 통해 방어하거나, 솔직하게 분석하여 불필요한 복잡성을 제거하는 것이 좋다.31</p>
<h3>7.2  하이퍼파라미터 민감도 분석 (Sensitivity Analysis)</h3>
<p>주요 하이퍼파라미터(예: 손실 함수의 가중치 <span class="math math-inline">\lambda</span>, 클러스터의 개수 <span class="math math-inline">K</span>)를 변화시켰을 때 성능이 얼마나 변하는지 그래프로 보여준다. 특정 값에서만 성능이 좋고 조금만 바뀌어도 성능이 급락한다면, 그 방법은 ‘강건하지 못한(Brittle)’ 방법으로 간주된다. 넓은 범위의 파라미터에서 안정적인 성능을 보임을 입증해야 한다.</p>
<h2>8.  로보틱스 특화: Sim-to-Real 검증 전략</h2>
<p>로봇 논문에서 실험 설계의 꽃은 **Sim-to-Real(시뮬레이션에서 현실로의 이식)**이다. 단순 시뮬레이션 결과만으로는 ICRA/IROS와 같은 로보틱스 학회에서 좋은 평가를 받기 어렵다. 현실 세계의 불확실성을 어떻게 극복했는지 보여주는 것이 핵심이다.</p>
<ol>
<li><strong>System Identification:</strong> 실제 로봇의 물리 파라미터(질량, 관성 모멘트, 마찰 계수 등)를 정밀하게 측정하여 시뮬레이터에 반영하는 과정을 기술한다.18 이를 통해 시뮬레이션과 현실의 격차(Reality Gap)를 1차적으로 줄인다.</li>
<li><strong>Domain Randomization (DR):</strong> 시뮬레이션의 파라미터를 무작위로 흔들어 학습된 정책(Policy)이 다양한 환경 변화에 강건(Robust)하도록 만드는 과정을 설명한다. 어떤 파라미터(마찰, 질량, 센서 노이즈, 외력 등)를 어느 범위로 무작위화했는지 표로 제시하라.8 “적절한 DR을 통해 정책이 현실 세계의 노이즈를 견딜 수 있게 되었다“는 논리를 전개한다.</li>
<li><strong>Real-world Evaluation Protocol:</strong> 실제 로봇 실험은 시뮬레이션처럼 무한히 반복할 수 없고 통제하기 어렵다. 따라서 실험 프로토콜을 매우 상세히 적어야 한다.</li>
</ol>
<ul>
<li>초기화: “매 에피소드마다 로봇을 홈 위치로 수동 복귀시켰다.”</li>
<li>물체 배치: “물체 위치를 3cm 이내 오차로 무작위 배치했다.”</li>
<li>사람의 개입: 실험 도중 로봇이 멈추거나 위험할 때 사람이 개입(Human Intervention)했는지 여부와 횟수를 솔직히 기록해야 한다.</li>
<li>실험 횟수: 실제 로봇 실험은 시간이 많이 걸리지만, 최소 10~20회 이상의 시도(Trial)를 통해 성공률을 산출해야 통계적 의미를 갖는다.</li>
</ul>
<h2>9.  실험 설계 작성 시 주의사항 및 팁: 리뷰어의 마음을 읽어라</h2>
<h3>9.1  시제와 문체: 과거의 사실을 객관적으로</h3>
<p>실험 설계는 이미 수행된 사실을 기술하는 것이므로 **과거 시제(Past Tense)**를 사용하는 것이 원칙이다 (예: “Models were trained…”, “We collected data…”). 그러나 일반적인 사실이나 데이터셋의 속성, 알고리즘의 불변하는 특성을 설명할 때는 현재 시제를 사용할 수 있다. 문체는 감정을 배제하고 건조하고 명료해야 한다. “매우 좋은 성능을 보였다“와 같은 주관적 형용사 대신 “기존 대비 5% 성능 향상을 보였다“와 같이 수치로 말해야 한다.</p>
<h3>9.2  “해라체” 논문 작성 가이드 (국문 논문/보고서의 경우)</h3>
<p>국문 논문이나 기술 보고서 작성 시에는 문장의 끝을 명확하고 간결하게 맺는 ’해라체(~한다, ~이다)’를 사용한다. 불필요한 수식어구(예: “정말”, “매우”, “다행히도”)를 배제하고 객관적인 톤을 유지한다.</p>
<ul>
<li><em>나쁜 예:</em> “우리는 학습이 잘 되도록 꽤 높은 러닝 레이트를 주었다.” (모호함, 비전문적)</li>
<li><em>좋은 예:</em> “초기 학습률(Learning rate)은 1e-3으로 설정하였으며, 10 에폭(Epoch)마다 0.1배씩 감소시키는 스텝 디케이(Step Decay) 방식을 적용하였다.” (구체적, 전문적)</li>
</ul>
<h3>9.3  체크리스트 활용</h3>
<p>NeurIPS, CVPR, ICLR 등 주요 학회는 논문 제출 시 ‘Reproducibility Checklist’ 작성을 의무화하고 있다.3 논문을 제출하기 전에, 아니 실험 설계 섹션을 쓰기 시작할 때부터 이 체크리스트를 옆에 두고 항목 하나하나를 본문에 녹여내야 한다.</p>
<ol>
<li>모든 하이퍼파라미터가 명시되었는가?</li>
<li>데이터셋의 출처, 라이선스, 스플릿이 명확한가?</li>
<li>비교군(Baseline) 선정 논리가 타당하며, 재구현 여부가 명시되었는가?</li>
<li>통계적 유의성(에러 바, p-value)을 검증했는가?</li>
<li>컴퓨팅 인프라와 실험 예산(Compute Budget)이 기술되었는가?</li>
<li>코드와 데이터를 공개할 준비가 되었는가?</li>
</ol>
<h2>10.  결론: 실험 설계는 독자와의 약속이다</h2>
<p>실험 설계 섹션은 화려한 미사여구나 복잡한 수식이 필요한 곳이 아니다. 건조하지만 정확하게, 그리고 치밀하게 연구의 과정을 복기(Replay)할 수 있도록 기록하는 곳이다. 훌륭한 실험 설계는 단순히 좋은 결과를 보여주는 것을 넘어, 연구자가 이 문제를 얼마나 깊이 이해하고 있으며, 결과의 신뢰성을 확보하기 위해 얼마나 치열하게 고민했는지를 보여주는 가장 강력한 증거가 된다. 이 섹션이 부실하면 앞선 방법론의 혁신성도, 뒤따를 결과의 탁월함도 모두 ’사상누각(沙上樓閣)’이 됨을 명심해야 한다. 따라서 본 장에서 제시한 항목들을 하나씩 점검하며, 빈틈없는 실험 설계를 구축하는 데 만전을 기해야 한다. 실험 설계는 당신의 연구를 과학으로 승격시키는 마지막 관문이다.</p>
<p><strong>[표 4.2.2] 실험 설계 섹션 필수 구성 요소 요약 및 학회별 강조점</strong></p>
<table><thead><tr><th><strong>구성 요소</strong></th><th><strong>핵심 내용</strong></th><th><strong>AI 학회 (NeurIPS/CVPR) 포인트</strong></th><th><strong>로보틱스 학회 (ICRA/IROS) 포인트</strong></th></tr></thead><tbody>
<tr><td><strong>환경 (Environment)</strong></td><td>하드웨어(GPU/CPU), 로봇 모델, 센서 스펙, 시뮬레이터 종류</td><td>Compute Budget, Carbon Footprint, Batch Size</td><td>Robot Hardware Spec, Sensor Noise, Physics Engine</td></tr>
<tr><td><strong>데이터 (Data)</strong></td><td>데이터셋 명, 출처, Train/Val/Test 스플릿, 전처리, 증강</td><td>Dataset Bias, License, Ethical Use, Augmentation</td><td>Real-world Data Collection, Teleoperation, Sim Data</td></tr>
<tr><td><strong>비교군 (Baselines)</strong></td><td>SOTA 모델, 고전 모델, 유사 방법론 (공정한 비교 조건 명시)</td><td>Backbone 통일, Pre-training 여부 구분</td><td>동일한 하드웨어/시뮬레이터 조건, Control Frequency</td></tr>
<tr><td><strong>지표 (Metrics)</strong></td><td>정확도, 효율성(FPS/FLOPs), 성공률, 통계적 유의성(p-value)</td><td>Error Bars, Confidence Intervals, Statistical Tests</td><td>Real-world Success Rate, Safety, Smoothness</td></tr>
<tr><td><strong>세부 사항 (Details)</strong></td><td>하이퍼파라미터(LR, Batch size), 랜덤 시드, 최적화 기법</td><td>Reproducibility Checklist 준수</td><td>Controller Gains (PID), Force Limits, Latency</td></tr>
<tr><td><strong>절개 연구 (Ablation)</strong></td><td>각 구성 요소의 기여도 분석 (Component-wise analysis)</td><td>논문의 깊이(Depth) 평가 요소, 모듈별 유효성</td><td>센서 조합별 성능(RGB vs RGB-D), Sim-to-Real 요소</td></tr>
</tbody></table>
<p>이 표를 나침반 삼아, 당신의 실험 설계가 거친 리뷰(Review)의 파도를 넘어 출판(Publication)이라는 항구에 안전하게 도달할 수 있도록 하라.</p>
<h2>11. 참고 자료</h2>
<ol>
<li>How to submit a manuscript Common Rejection Reasons | Publish your research, https://www.springernature.com/gp/authors/campaigns/how-to-submit-a-journal-article-manuscript/common-rejection-reasons</li>
<li>Rejection Blues: Why Do Research Papers Get Rejected? - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC6046667/</li>
<li>NeurIPS Paper Checklist Guidelines, https://neurips.cc/public/guides/PaperChecklist</li>
<li>NeurIPS 2021 Paper Checklist Guidelines, https://neurips.cc/Conferences/2021/PaperInformation/PaperChecklist</li>
<li>Improving Reproducibility in Machine Learning Research(A Report from the NeurIPS 2019 Reproducibility Program), https://www.jmlr.org/papers/volume22/20-303/20-303.pdf</li>
<li>Practical Tips for Writing Robotics Conference Papers that Get Accepted, https://michaelmilford.com/practical-tips-for-writing-robotics-conference-papers-that-get-accepted/</li>
<li>Hardware Design for Autonomous Robot Evolution - White Rose Research Online, https://eprints.whiterose.ac.uk/id/eprint/166131/1/ICES_Hardware_Design_for_Autonomous_Robot_Evolution.pdf</li>
<li>Crossing the Gap: A Deep Dive into Zero-Shot Sim-to-Real Transfer for Dynamics, https://www.robot-learning.uk/crossing-the-gap</li>
<li>NeurIPS Paper Checklist - arXiv, https://arxiv.org/html/2505.04037v1</li>
<li>Manufacturing Robotics Report: Hardware | Blog - Protolabs, https://www.protolabs.com/en-gb/resources/blog/manufacturing-robotics-report-hardware/</li>
<li>The Role of Experiments in Robotics Research, <a href="https://fileadmin.cs.lth.se/ai/Proceedings/ICRA2010/ICRA%202010%20WS/W1/ICRA2010BonsignorioPobilHallamMadhavanPdf.pdf">https://fileadmin.cs.lth.se/ai/Proceedings/ICRA2010/ICRA%202010%20WS/W1/ICRA2010BonsignorioPobilHallamMadhavanPdf.pdf</a></li>
<li>Open Robot Hardware: Progress, Benefits, Challenges, and Best Practices - Yale Engineering, https://www.eng.yale.edu/grablab/pubs/Patel_RAM2023.pdf</li>
<li>An Overview of Robot-Sensor Calibration Methods for Evaluation of Perception Systems, http://faculty.cooper.edu/mili/permis2012.pdf</li>
<li>A Noise-Tolerant Algorithm for Robot-Sensor Calibration Using a Planar Disk of Arbitrary 3-D Orientation | Request PDF - ResearchGate, https://www.researchgate.net/publication/309628765_A_Noise-Tolerant_Algorithm_for_Robot-Sensor_Calibration_Using_a_Planar_Disk_of_Arbitrary_3-D_Orientation</li>
<li>Review of Reinforcement Learning for Robotic Grasping: Analysis and Recommendations - Semantic Scholar, https://pdfs.semanticscholar.org/ed1c/6b6eb9b648cabd4f7ee3ecdaf4fc459e0483.pdf</li>
<li>Figure Design : AeroAstro Communication Lab, https://mitcommlab.mit.edu/aeroastro/commkit/figure-design/</li>
<li>Robotics-based experimental setup a, Experimental setup showing the… - ResearchGate, https://www.researchgate.net/figure/Robotics-based-experimental-setup-a-Experimental-setup-showing-the-main-tank-with-two_fig1_343559971</li>
<li>SoMo: Fast and Accurate Simulations of Continuum Robots, <a href="https://ntrs.nasa.gov/api/citations/20240008653/downloads/SoMo%20Fast%20and%20Accurate%20Simulations.pdf">https://ntrs.nasa.gov/api/citations/20240008653/downloads/SoMo%20Fast%20and%20Accurate%20Simulations.pdf</a></li>
<li>A Review of Physics Simulators for Robotic Applications, https://ora.ox.ac.uk/objects/uuid:e64b1797-917d-4b75-8eae-a5a60af74246/files/sx346d596k</li>
<li>ROS-PyBullet Interface: A Framework for Reliable Contact Simulation and Human-Robot Interaction - University of Edinburgh Research Explorer, https://www.research.ed.ac.uk/files/342776818/ROS_PyBullet_Interface_MOWER_DOA10092022_VOR_CC_BY.pdf</li>
<li>Benchmark of the Physics Engine MuJoCo and Learning-based Parameter Optimization for Contact-rich Assembly Tasks | Request PDF - ResearchGate, https://www.researchgate.net/publication/372227198_Benchmark_of_the_Physics_Engine_MuJoCo_and_Learning-based_Parameter_Optimization_for_Contact-rich_Assembly_Tasks</li>
<li>ROS: an open-source Robot Operating System - Stanford University, https://robotics.stanford.edu/~ang/papers/icraoss09-ROS.pdf</li>
<li>Investigating the Sim-to-Real Generalizability of Deep Learning Object Detection Models, https://www.mdpi.com/2313-433X/10/10/259</li>
<li>A Robotics Experimental Design Method Based on PDCA: A Case Study of Wall-Following Robots - MDPI, https://www.mdpi.com/1424-8220/24/6/1869</li>
<li>General principles for reducing bias - APA Style - American Psychological Association, https://apastyle.apa.org/style-grammar-guidelines/bias-free-language/general-principles</li>
<li>Even the “Devil” Has Rights! - arXiv, https://arxiv.org/html/2410.22963v2</li>
<li>Closing the Simulation-to-Reality Gap for Deep Robotic Learning - Google Research, https://research.google/blog/closing-the-simulation-to-reality-gap-for-deep-robotic-learning/</li>
<li>CVPR 2026 Reviewer Training Material - The Computer Vision Foundation, https://cvpr.thecvf.com/Conferences/2026/ReviewerTrainingMaterial</li>
<li>Sample Selection for Fair and Robust Training, https://par.nsf.gov/servlets/purl/10311450</li>
<li>How we write rebuttals - Devi Parikh, https://deviparikh.medium.com/how-we-write-rebuttals-dc84742fece1</li>
<li>Reflections on Reviewing Computer Vision Papers - M. Usman Rafique, https://urafique.com/posts/cv_review/</li>
<li>A Guide to Metrics for Evaluating Machine Vision - UnitX, https://www.unitxlabs.com/metrics-evaluating-machine-vision/</li>
<li>Writing (Computer Vision) Papers from the Reviewer’s Perspective - LatinX in CV Workshop @ ICCV 2021 - Matias Valdenegro-Toro, https://mvaldenegro.github.io/files/LXCV-ICCV-2021-tutorial-paper-writing.pdf</li>
<li>Deep Reinforcement Learning for Robotics: A Survey of Real-World Successes - arXiv, https://arxiv.org/html/2408.03539v3</li>
<li>Key Metrics for Autonomous System Performance Evaluation - Do that with AI! AI Coaching &amp; Mentorship to Help You Leverage AI - Jonathan Mast, https://jonathanmast.com/key-metrics-for-autonomous-system-performance-evaluation/</li>
<li>A Framework of Indicators for Assessing Team Performance of Human–Robot Collaboration in Construction Projects - MDPI, https://www.mdpi.com/2075-5309/15/15/2734</li>
<li>Understanding research metrics | Editor Resources - Taylor &amp; Francis, https://editorresources.taylorandfrancis.com/understanding-research-metrics/</li>
<li>How to Get Your CVPR Paper Rejected - Department of Computer Science, https://www.cs.ryerson.ca/~wangcs/resources/How-to-get-your-CVPR-paper-rejected.pdf</li>
<li>Introducing the NeurIPS 2021 Paper Checklist, https://blog.neurips.cc/2021/03/26/introducing-the-neurips-2021-paper-checklist/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>