# 컴퓨터 운영체제 (Operating System)


이 장에서는 운영체제의 근본적인 정의, 목적, 그리고 핵심 기능을 탐구한다. 또한, 컴퓨터 기술의 발전과 함께 운영체제가 어떻게 진화해왔는지 그 역사적 맥락을 심도 있게 분석하여, 현대 운영체제의 복잡한 개념들이 어떤 필요에 의해 탄생했는지 이해의 기반을 마련한다.



운영체제(Operating System, OS)는 사용자와 컴퓨터 하드웨어 사이의 중재자 역할을 수행하는 핵심적인 시스템 소프트웨어이다.1 이는 컴퓨터 시스템의 CPU, 메모리, 저장장치와 같은 하드웨어 자원과 소프트웨어 자원을 직접적이고 효율적으로 제어 및 관리하며, 응용 프로그램이 실행될 수 있는 기반 환경을 제공한다.3

운영체제는 자동차의 엔진에 비유할 수 있다. 엔진은 그 자체로도 작동하지만, 변속기, 차축, 바퀴와 같은 다른 부품들과 유기적으로 연결되어야 비로소 자동차를 움직일 수 있다.4 이와 마찬가지로, 운영체제는 응용 소프트웨어라는 '작업'과 하드웨어라는 '물리적 실체'를 연결하는 필수적인 다리 역할을 수행한다. 사용자는 운영체제가 제공하는 인터페이스를 통해 복잡한 하드웨어의 작동 원리를 알지 못해도 컴퓨터를 손쉽게 사용할 수 있다.3

이러한 운영체제의 본질은 이중적인 정체성에서 비롯된다. 첫째, 사용자 및 응용 프로그램의 관점에서 운영체제는 복잡한 하드웨어의 구체적인 작동 방식을 숨기고, 파일 열기, 데이터 저장과 같은 일관되고 편리한 인터페이스(API, 시스템 호출)를 제공하는 **추상화 계층(Abstraction Layer)**으로 기능한다. 둘째, 시스템 내부의 관점에서는 한정된 자원(CPU 시간, 메모리 공간 등)을 여러 프로세스들의 경쟁적인 요청으로부터 보호하고, 스케줄링과 같은 메커니즘을 통해 공정하고 효율적으로 자원을 분배하는 **자원 관리자(Resource Manager)**로서의 역할을 수행한다. 이 두 가지 역할은 상호 보완적이며 운영체제 설계의 모든 측면에 깊이 관여한다. 예를 들어, 가상 메모리 시스템은 사용자에게 실제 물리 메모리보다 훨씬 큰 연속적인 메모리 공간이 있는 것처럼 보이는 '추상화'를 제공하지만, 내부적으로는 물리 메모리와 디스크 간의 복잡한 데이터 이동을 관리하는 정교한 '자원 관리'를 통해 이를 구현한다.


운영체제의 핵심 목적은 크게 두 가지로 요약할 수 있다.5

1. **사용자 편의성 제공**: 가장 중요한 목적은 사용자가 컴퓨터 시스템을 편리하고 효율적으로 사용할 수 있는 환경을 제공하는 것이다.5 운영체제가 없다면, 사용자는 프로그램을 실행하기 위해 하드웨어를 직접 제어하는 기계어를 사용해야 할 것이다. 운영체제는 이러한 복잡성을 감추고 그래픽 인터페이스나 간단한 명령어를 통해 컴퓨터와 상호작용할 수 있게 한다.3
2. **자원의 효율적 관리**: 컴퓨터 시스템의 자원, 즉 중앙처리장치(CPU), 주기억장치(메모리), 입출력 장치, 파일, 데이터 등은 한정되어 있다.2 운영체제는 이러한 하드웨어 및 소프트웨어 자원을 여러 사용자나 응용 프로그램 간에 효율적으로 할당하고, 관리하며, 잘못된 사용으로부터 보호하는 역할을 수행한다.6 이를 통해 시스템의 전반적인 성능(처리 능력, 응답 시간 등)을 최적화한다.3


운영체제는 앞서 언급한 목적을 달성하기 위해 다음과 같은 구체적이고 핵심적인 기능들을 수행한다.

- **프로세스 관리 (Process Management)**: 실행 중인 프로그램인 프로세스를 관리한다. 여기에는 프로세스의 생성과 소멸, 실행 중지 및 재개, 프로세스 간 통신 및 동기화, 그리고 여러 프로세스가 자원을 놓고 경쟁하다 발생하는 교착 상태(Deadlock) 처리 등이 포함된다.1
- **메모리 관리 (Memory Management)**: 한정된 주기억장치(RAM)를 어떤 프로세스에 얼마만큼 할당할지 결정한다. 각 프로세스가 자신에게 할당된 메모리 영역에만 접근하도록 보호하고, 더 이상 사용되지 않는 공간은 회수하여 다른 프로세스가 사용할 수 있도록 관리한다.1
- **파일 시스템 관리 (File System Management)**: 보조기억장치(디스크)에 파일 형태로 저장된 데이터를 관리한다. 파일의 생성, 삭제, 읽기, 쓰기와 같은 기본적인 연산을 지원하며, 디렉터리 구조를 통해 파일들을 체계적으로 관리한다. 또한 디스크의 빈 공간 관리 및 스케줄링도 담당한다.1
- **입출력 장치 관리 (I/O Device Management)**: 키보드, 마우스, 모니터, 프린터 등 다양한 입출력 장치와의 상호작용을 제어한다. 장치 드라이버를 통해 하드웨어의 복잡성을 숨기고, 입출력 작업의 스케줄링과 데이터 전송을 관리한다.2
- **보호 및 보안 (Protection & Security)**: 다중 사용자 또는 다중 작업 환경에서 각 사용자 및 프로세스의 자원이 서로를 침범하지 않도록 보호한다.2 또한, 인증되지 않은 외부의 불법적인 접근이나 악성 코드로부터 시스템 전체를 안전하게 지키는 보안 기능을 수행한다.9
- **네트워킹 (Networking)**: 분산 시스템 환경에서 컴퓨터 간의 원활한 통신을 위한 프로토콜 스택을 관리하고, 네트워크 서비스를 제공한다.2
- **명령어 해석기 (Command Interpreter System)**: 사용자가 입력한 명령어를 해석하여 운영체제가 이해할 수 있는 형태로 변환하고, 해당 기능이 수행되도록 커널에 전달하는 역할을 한다. 그래픽 환경의 GUI 셸(Shell)이나 텍스트 기반의 CLI 셸이 대표적인 예이다.2


운영체제의 역사는 컴퓨터 하드웨어의 발전, 특히 비용 구조의 변화와 불가분의 관계를 맺고 있다. 초창기에는 극도로 비싼 하드웨어의 효율성을 단 1%라도 더 끌어올리는 것이 지상 과제였으나, 점차 하드웨어 가격이 하락하고 인건비가 상승하면서 사용자의 편의성과 생산성을 높이는 방향으로 발전의 무게 중심이 이동했다. 이러한 발전 과정을 세 가지 핵심 동력, 즉 **경제성(Economics)**, **상호작용성(Interactivity)**, **연결성(Connectivity)**의 관점에서 살펴보면 그 흐름을 명확히 이해할 수 있다.


최초의 컴퓨터 에니악(ENIAC)이 등장했던 1940년대에는 운영체제라는 개념 자체가 없었다.11 프로그래밍은 진공관을 전선으로 직접 연결하는 '하드와이어링' 방식으로 이루어졌으며, 다른 프로그램을 실행하려면 물리적으로 전선을 재배치해야 했다.11

1950년대에 들어서면서 천공카드 시스템이 도입되어 프로그램 교체가 용이해졌다.11 하지만 여전히 하나의 작업이 끝나면 운영자(사람)가 수동으로 다음 작업을 위한 카드 덱을 로드하고 기계를 재설정해야 했다.13 이 작업 전환(job-to-job transition) 시간 동안 수백만 달러에 달하는 고가의 컴퓨터 CPU는 아무 일도 하지 않고 멈춰 있어야 했다. 이는 엄청난 자원 낭비였으며, 바로 이 '경제성' 문제가 초기 운영체제 기술의 발전을 촉발했다.

이 문제를 해결하기 위해 등장한 것이 **일괄 처리 시스템(Batch Processing System)**이다.11 여러 개의 유사한 작업(job)을 하나의 묶음(batch)으로 만들어 자기 테이프에 기록한 뒤, 컴퓨터가 이를 자동으로 순차 처리하도록 한 것이다.13 이를 통해 작업과 작업 사이의 전환 시간을 기계의 속도로 단축시켜 CPU의 유휴 시간(idle time)을 크게 줄일 수 있었다.14 1956년에 등장하여 최초의 실질적인 운영체제로 평가받는 **GM-NAA I/O**는 바로 이 일괄 처리 기능을 자동화한 시스템이었다.16


일괄 처리 시스템은 CPU의 유휴 시간을 줄였지만, 여전히 한계가 있었다. 프로그램 실행 중에는 CPU 연산과 입출력(I/O) 연산이 번갈아 발생하는데, 카드 리더기나 프린터 같은 입출력 장치는 CPU에 비해 속도가 매우 느렸다. 따라서 입출력 작업이 진행되는 동안 CPU는 또다시 유휴 상태에 빠지게 되었다.13

이 문제를 해결하기 위해 **다중 프로그래밍(Multiprogramming)** 개념이 도입되었다.14 이는 여러 개의 프로그램을 동시에 메모리에 적재해두고, 한 프로그램이 입출력 작업을 위해 대기 상태에 들어가면, 즉시 CPU를 다른 프로그램으로 전환(Context Switching)하여 실행시키는 방식이다.14 이를 통해 CPU가 거의 쉬지 않고 일하게 만들어 시스템 전체의 처리량(Throughput)을 극대화할 수 있었다.

한편, 1960년대 후반으로 가면서 하드웨어 가격은 점차 하락하고 프로그래머의 인건비는 상승하기 시작했다. 이에 따라 기계의 효율성뿐만 아니라 '인간의 효율성', 즉 사용자의 생산성이 새로운 화두로 떠올랐다.13 여러 사용자가 값비싼 메인프레임 컴퓨터에 동시에 접속하여 대화하듯 작업을 처리할 수 있는 **시분할 시스템(Time-Sharing System)**이 등장한 배경이다.19

시분할 시스템은 다중 프로그래밍을 논리적으로 확장한 개념으로, CPU 시간을 매우 짧은 시간 단위인 '타임 슬라이스(Time Slice)' 또는 '타임 퀀텀(Time Quantum)'으로 잘게 쪼개어 여러 사용자에게 번갈아 할당했다.14 CPU의 처리 속도가 워낙 빠르기 때문에, 각 사용자는 마치 자신 혼자 컴퓨터를 독점하여 사용하는 듯한 착각을 느끼게 되었다.20 이 시스템의 목표는 CPU 사용률 극대화를 넘어, 사용자에 대한 **응답 시간(Response Time)**을 최소화하는 것이었다.23 이는 운영체제의 관심사가 기계 중심에서 인간 중심으로 이동하는 중요한 전환점이었다.

이 시기에는 또한 여러 개의 CPU를 장착하여 동시에 여러 작업을 병렬로 처리하는 **다중 처리 시스템(Multi-processing System)**도 등장했다. 이는 하나의 CPU가 고장 나더라도 다른 CPU가 작업을 계속할 수 있어 시스템의 신뢰성과 안정성을 크게 높였다.2


집적회로(IC) 기술의 혁신적인 발전은 컴퓨터의 소형화와 가격 하락을 이끌었고, 마침내 개인이 소유할 수 있는 **개인용 컴퓨터(PC)**의 시대를 열었다.21 이 변화는 운영체제 패러다임의 거대한 전환을 가져왔다.

1981년, 신생 기업이었던 Microsoft는 IBM PC에 탑재될 운영체제로 **MS-DOS**를 출시했다.16 MS-DOS는 키보드로 명령어를 직접 입력하는 명령줄 인터페이스(CLI) 방식이었지만, IBM PC 호환 기종 시장을 장악하며 Microsoft를 소프트웨어 제국으로 성장시키는 결정적인 발판이 되었다.24

컴퓨터와의 상호작용 방식을 근본적으로 바꾼 혁명은 제록스(Xerox)의 팔로알토 연구소(PARC)에서 시작되었다. 이곳에서 개발된 마우스, 아이콘, 윈도우와 같은 기술들은 **그래픽 사용자 인터페이스(GUI)**의 기반이 되었다.26 이 기술의 잠재력을 알아본 애플(Apple)은 1984년, 최초로 상업적 성공을 거둔 GUI 운영체제인 **매킨토시(Macintosh)**를 출시했다.21 사용자는 더 이상 복잡한 명령어를 외울 필요 없이, 마우스를 클릭하여 아이콘을 조작하는 직관적인 방식으로 컴퓨터를 사용할 수 있게 되었다. 이는 컴퓨터가 전문가의 도구에서 모든 사람을 위한 도구로 거듭나는 계기가 되었다.10

애플의 성공에 자극받은 Microsoft 역시 **Windows**를 출시하며 GUI 경쟁에 뛰어들었다. 초기 버전의 Windows는 MS-DOS 위에서 동작하는 반쪽짜리 운영체제였으나, 1995년 출시된 **Windows 95**는 MS-DOS와 완전히 결별하고 독자적인 32비트 운영체제로 거듭나며 PC 운영체제 시장의 절대 강자로 군림하게 되었다.24


1990년대 이후 인터넷이 전 세계적으로 보급되면서, 개별 컴퓨터의 성능을 넘어 컴퓨터들을 서로 '연결'하는 네트워킹 기능이 운영체제의 핵심으로 부상했다.13

**분산 운영체제(Distributed OS)**는 이러한 시대적 요구를 반영하는 개념이다. 이는 네트워크로 연결된 여러 독립적인 컴퓨터들을 마치 하나의 단일 시스템처럼 보이게 만드는 기술이다.20 사용자는 다른 컴퓨터에 있는 파일이나 프린터를 마치 자신의 컴퓨터에 있는 것처럼 투명하게 사용할 수 있으며, 여러 컴퓨터의 연산 능력을 모아 복잡한 계산을 처리함으로써 성능과 신뢰성을 높일 수 있다.15

한편, 오픈 소스 운동의 확산은 운영체제 역사에 또 다른 중요한 이정표를 세웠다. 1991년 리누스 토르발스가 개발한 **리눅스(Linux)** 커널은 전 세계 개발자들의 자발적인 참여로 발전하며, 서버, 슈퍼컴퓨터, 임베디드 시스템 시장에서 막강한 영향력을 확보했다.2 리눅스는 무료로 사용할 수 있는 강력한 성능과 안정성, 유연성을 바탕으로 독점 운영체제들의 강력한 대안으로 자리 잡았다.

21세기에 들어서는 스마트폰의 등장으로 **모바일 운영체제**(Google의 Android, Apple의 iOS)가 새로운 주역으로 떠올랐고, **클라우드 컴퓨팅**과 **사물 인터넷(IoT)**의 확산은 대규모 데이터를 처리하고 수많은 기기를 연결하기 위한 새로운 형태의 운영체제 기술을 요구하고 있다.2 이처럼 운영체제는 기술 환경의 변화에 맞춰 끊임없이 진화하고 있다.

**표 1: 운영체제 발전 과정 요약**

| 세대  | 연대          | 주요 하드웨어                   | 운영 기법                                      | 주요 목표                                     | 대표 OS/시스템                      |
| ----- | ------------- | ------------------------------- | ---------------------------------------------- | --------------------------------------------- | ----------------------------------- |
| 1세대 | 1950년대      | 메인프레임                      | **일괄 처리 (Batch Processing)**               | 처리량(Throughput) 극대화, CPU 유휴 시간 감소 | GM-NAA I/O                          |
| 2세대 | 1960년대      | 메인프레임                      | **다중 프로그래밍, 시분할, 다중 처리, 실시간** | CPU 사용률 향상, 사용자 응답 시간 단축        | CTSS, UNIX                          |
| 3세대 | 1970-80년대   | 개인용 컴퓨터(PC)               | **다중 모드 (GUI 기반)**                       | 사용자 편의성 증대, 개인화                    | MS-DOS, Apple Macintosh             |
| 4세대 | 1990년대-현재 | 워크스테이션, 서버, 모바일 기기 | **분산 처리, 네트워크, 가상화**                | 자원 공유, 신뢰성, 확장성, 이동성             | Windows, Linux, macOS, Android, iOS |


이 장에서는 운영체제의 내부 구조를 파헤친다. 시스템의 심장부인 커널의 역할과, 응용 프로그램이 커널의 서비스를 이용하는 통로인 시스템 호출에 대해 알아본다. 또한, 대표적인 운영체제인 Windows, macOS, Linux의 구조적 특징을 비교 분석하여 이론이 실제 시스템에서 어떻게 구현되는지 살펴본다.



커널은 운영체제의 가장 핵심적인 부분으로, 비유하자면 운영체제의 '뇌'와 '심장'에 해당한다.6 컴퓨터가 부팅될 때 가장 먼저 메모리에 적재되어 실행이 끝날 때까지 항상 메모리에 상주(resident)하며, 시스템의 모든 것을 통제하고 관리한다. 커널이 수행하는 주요 기능은 다음과 같다.4

- **자원 관리**: CPU, 메모리, 파일, 네트워크 장치 등 모든 하드웨어 및 소프트웨어 자원에 대한 접근을 관리하고 제어한다.
- **프로세스 관리**: 프로세스를 생성하고 스케줄링하며, 프로세스 간 통신을 중재한다.
- **메모리 관리**: 각 프로세스에 메모리를 할당하고, 사용되지 않는 메모리를 회수한다.
- **보안**: 시스템 자원에 대한 접근 권한을 관리하고, 악의적인 접근으로부터 시스템을 보호한다.

커널의 성능과 안정성이 곧 운영체제 전체의 성능과 안정성을 결정한다고 할 수 있다.9


응용 프로그램이 파일 읽기, 화면 출력, 네트워크 통신 등 운영체제의 보호된 기능을 사용해야 할 때, 커널에게 서비스를 요청하기 위한 공식적인 통로가 바로 시스템 호출이다.9

운영체제는 시스템 자원을 보호하기 위해 **커널 모드(Kernel Mode)**와 **사용자 모드(User Mode)**라는 이중 동작 모드를 사용한다. 중요한 시스템 자원에 접근하고 하드웨어를 제어하는 코드는 커널 모드에서만 실행될 수 있다. 반면, 일반 응용 프로그램은 제한된 권한을 가진 사용자 모드에서 실행된다.

응용 프로그램이 파일 생성(`create`), 메모리 할당(`malloc`), 프로세스 생성(`fork`)과 같이 커널의 도움이 필요한 작업을 수행하려면, 직접 하드웨어를 제어하는 대신 시스템 호출이라는 인터페이스를 통해 커널에 '요청'해야 한다. 이 요청이 발생하면, CPU는 사용자 모드에서 커널 모드로 전환되고, 커널은 요청받은 작업을 안전하게 수행한 뒤 그 결과를 응용 프로그램에 반환하고 다시 사용자 모드로 복귀한다. 이처럼 시스템 호출은 사용자 프로그램과 커널 사이의 다리 역할을 하며, 시스템의 안정성과 보안을 보장하는 핵심적인 메커니즘이다.


드라이버는 특정 하드웨어 장치(예: 그래픽 카드, 프린터, 네트워크 카드)를 제어하기 위해 작성된 소프트웨어 모듈이다.6 커널의 일부로 동작하며, 운영체제가 수많은 제조사의 각기 다른 하드웨어들을 일관된 방식으로 인식하고 사용할 수 있도록 해주는 '번역기'와 같은 역할을 한다.9 사용자가 프린터를 사용하고자 할 때, 운영체제는 프린터 드라이버를 통해 해당 프린터 모델에 맞는 명령을 전달하여 인쇄 작업을 수행한다.


운영체제의 내부 기능을 어떻게 구성하고 조직화하는지에 따라 여러 구조적 모델로 나눌 수 있다.

- **단일형 구조 (Monolithic Structure)**: 초기의 UNIX와 같이 운영체제의 모든 핵심 기능(프로세스 관리, 메모리 관리, 파일 시스템, 장치 드라이버 등)이 하나의 거대한 프로그램, 즉 단일 커널 내부에 모두 포함된 구조이다.
  - **장점**: 커널 내부의 모듈들이 별도의 통신 과정 없이 직접 함수를 호출하여 상호작용하므로 매우 효율적이고 빠르다.
  - **단점**: 모든 기능이 강하게 결합되어 있어, 하나의 모듈에 발생한 작은 결함이 시스템 전체의 안정성을 해칠 수 있다(시스템 다운). 또한, 기능 간의 상호 의존성이 높아 특정 기능을 수정하거나 새로운 기능을 추가하기가 매우 어렵고, 다른 종류의 하드웨어로 이식하는 것도 복잡하다.9
- **계층형 구조 (Layered Structure)**: 운영체제를 여러 개의 계층(Layer)으로 나누어 설계하는 방식이다. 각 계층은 자신보다 바로 아래에 있는 하위 계층의 기능과 서비스만을 이용하여 구현된다. 최하위 계층은 하드웨어를 직접 제어하고, 최상위 계층은 사용자 인터페이스를 담당한다.
  - **장점**: 계층 간의 인터페이스만 명확히 정의하면 되므로 설계와 구현이 단순해지고, 특정 계층의 오류를 쉽게 찾아 수정할 수 있다(디버깅 용이).
  - **단점**: 각 계층을 거쳐야 하므로 단일형 구조에 비해 성능 저하가 발생할 수 있다.
- **마이크로커널 구조 (Microkernel Structure)**: 단일형 구조의 단점을 극복하기 위해 등장했다. 이 구조는 커널의 크기를 극단적으로 줄여, 가장 필수적인 최소한의 기능(프로세스 간 통신(IPC), 기본적인 메모리 관리, CPU 스케줄링 등)만을 커널에 남긴다. 파일 시스템, 장치 드라이버, 네트워크 프로토콜과 같은 나머지 기능들은 커널 외부의 사용자 수준 프로세스(서버 형태)로 구현한다.
  - **장점**: 특정 기능(서버)에 문제가 발생하더라도 커널 자체는 영향을 받지 않으므로 시스템 전체의 안정성과 보안성이 향상된다. 새로운 기능을 추가하거나 기존 기능을 수정할 때, 해당 서버 프로세스만 교체하면 되므로 확장성과 유연성이 뛰어나다.
  - **단점**: 사용자 프로세스 형태로 구현된 서버들 간의 통신은 반드시 커널의 IPC 기능을 거쳐야 하므로, 단일형 구조에 비해 잦은 모드 전환과 메시지 전달로 인한 성능 저하가 발생할 수 있다.


이론적인 구조는 실제 운영체제에서 어떻게 구현되어 있을까? 각 운영체제는 저마다의 개발 철학과 목표 시장에 따라 고유한 아키텍처와 생태계를 구축했다. 이들의 차이는 단순히 기술적 우위를 넘어, '개방성'과 '통제'라는 전략적 선택의 결과로 이해할 수 있다.

- **Windows**: Microsoft가 개발한 Windows는 '하드웨어 개방성' 전략을 통해 전 세계의 다양한 PC 제조업체들이 자사의 하드웨어에 Windows를 탑재하도록 허용했다. 이 전략 덕분에 데스크톱 시장에서 압도적인 점유율을 확보하고 방대한 응용 프로그램 생태계를 구축할 수 있었다.2

  - **구조 및 특징**: 사용자 친화적인 GUI와 뛰어난 하드웨어 호환성이 최대 장점이다.3 파일 시스템으로는 접근 제어, 압축, 암호화 등 고급 기능을 지원하는 **NTFS(New Technology File System)**를 주로 사용한다.29 소프트웨어는 주로 제작사가 배포하는 

    `.exe` 또는 `.msi` 형태의 설치 파일을 통해 개별적으로 설치된다.29

  - **트레이드오프**: 하지만 이러한 개방성은 수많은 하드웨어 조합에 대한 드라이버 호환성 문제와, 넓은 공격 표면으로 인한 보안 취약점이라는 대가를 치르게 했다.3 상대적으로 많은 시스템 자원을 요구하는 경향도 있다.3

- **macOS**: Apple은 '수직적 통합' 전략을 채택했다. 즉, 하드웨어(Mac)와 소프트웨어(macOS)를 모두 직접 설계하고 통제한다. 이를 통해 완벽한 최적화와 높은 수준의 안정성, 그리고 일관된 사용자 경험을 제공한다.3

  - **구조 및 특징**: UNIX 기반으로 개발되어 안정성이 높고, 미려하고 직관적인 UI/UX로 전문가와 크리에이터들에게 높은 평가를 받는다.3 파일 시스템으로는 SSD에 최적화된 **APFS(Apple File System)**를 사용한다.29 소프트웨어는 Apple이 직접 관리하는 

    **App Store**를 통해 안전하게 배포되거나, `.dmg` 이미지 파일을 통해 손쉽게 설치된다.29

  - **트레이드오프**: 이러한 강력한 통제는 폐쇄적인 생태계와 제한된 하드웨어 확장성이라는 단점으로 이어진다. 사용자는 Apple이 정해준 하드웨어 외에는 선택의 여지가 없으며, 이로 인해 가격이 비싸고 특정 전문 작업(예: 딥러닝)에는 부적합할 수 있다.3

- **Linux**: Linux는 '소프트웨어 개방성', 즉 오픈 소스 철학을 기반으로 한다. 커널 소스 코드가 모두에게 공개되어 있어 누구나 자유롭게 수정하고 재배포할 수 있다.2

  - **구조 및 특징**: 이 개방성 덕분에 전 세계 개발자 커뮤니티의 참여를 통해 매우 빠르고 안정적으로 발전했다. 특히 서버, 클라우드, 임베디드 시스템과 같은 전문 영역에서 강력한 생태계를 구축했다. 보안성과 안정성이 매우 뛰어나며, 시스템 자원을 효율적으로 사용한다.31 파일 시스템으로는 안정적인 

    **ext4**나 대용량 파일 처리에 강한 **XFS** 등 다양한 선택지를 제공한다.29 소프트웨어는 주로 각 배포판(Ubuntu, CentOS 등)이 운영하는 중앙 저장소(Repository)에서 

    **패키지 관리자**(예: `apt`, `yum`)를 통해 일관되고 안전하게 설치 및 관리된다.30

  - **트레이드오프**: 소프트웨어의 개방성은 데스크톱 환경의 파편화(다양한 GUI 환경)와 일부 상용 소프트웨어(MS Office, Adobe 제품군 등)의 호환성 부족이라는 한계를 낳았다.3 초보 사용자에게는 CLI 기반의 설정이 다소 어렵게 느껴질 수 있다.

결론적으로, 사용자가 운영체제를 선택하는 것은 단순히 기술적 사양을 비교하는 것을 넘어, 자신이 속하고자 하는 기술 생태계의 철학, 즉 '광범위한 호환성(Windows)', '완벽한 통합과 안정성(macOS)', '자유와 통제권(Linux)' 중 무엇에 가치를 둘 것인지를 선택하는 과정이라 할 수 있다.


프로세스는 실행 중인 프로그램을 의미하며, 운영체제 관리의 가장 기본적인 단위이다. 이 장에서는 프로세스의 생명주기, 상태 변화, 그리고 운영체제가 각 프로세스를 관리하기 위해 사용하는 핵심 자료구조인 PCB에 대해 학습한다. 이후, 다중 프로그래밍 환경에서 한정된 CPU 자원을 어떤 프로세스에 할당할지 결정하는 CPU 스케줄링 기법과, 여러 프로세스가 동시에 실행될 때 발생하는 동기화 문제 및 교착 상태에 대해 심도 있게 다룬다.



프로세스(Process)란 가장 일반적으로 '실행 중인 프로그램(a program in execution)'으로 정의된다.36 하드 디스크와 같은 보조기억장치에 존재하는 실행 파일(프로그램)이 메모리에 적재되어 CPU에 의해 명령어들이 실행되기 시작하면, 비로소 생명을 가진 '프로세스'가 되는 것이다.38

프로세스는 단순히 프로그램 코드 덩어리가 아니라, 운영체제로부터 자원(CPU 시간, 메모리, 파일, 입출력 장치 등)을 할당받는 작업의 단위이다.37 또한 프로그램 카운터(PC), 레지스터 등 현재의 활동 상태를 나타내는 정보들을 포함한다. 동일한 프로그램이라도 여러 번 실행되면, 각각은 서로 다른 자원을 할당받은 별개의 프로세스가 된다.37


운영체제는 각 프로세스에게 독립된 가상 주소 공간을 할당한다. 이 공간은 일반적으로 다음과 같은 네 가지 주요 영역으로 구성된다.37

- **코드 (Code) 영역**: 텍스트(Text) 영역이라고도 하며, 실행할 프로그램의 기계어 코드가 저장되는 공간이다. 읽기 전용(Read-only)으로 설정되어 프로그램의 코드가 변경되지 않도록 보호된다.
- **데이터 (Data) 영역**: 프로그램이 시작될 때 할당되어 프로그램이 종료될 때까지 유지되는 전역 변수(global variables)와 정적 변수(static variables)가 저장된다.
- **힙 (Heap) 영역**: 프로그래머가 직접 관리하는 메모리 공간으로, 프로그램 실행 중에 동적으로 메모리를 할당(예: C 언어의 `malloc()`)하고 해제(예: `free()`)하는 데 사용된다. 힙은 메모리의 낮은 주소에서 높은 주소 방향으로 자라난다.
- **스택 (Stack) 영역**: 함수 호출과 관련된 정보가 저장되는 공간이다. 함수가 호출될 때마다 해당 함수의 매개변수, 지역 변수, 복귀 주소 등이 스택 프레임(Stack Frame)이라는 단위로 쌓인다. 스택은 메모리의 높은 주소에서 낮은 주소 방향으로 자라난다.


프로세스는 생성되어 실행되고 종료되기까지의 생명주기 동안 여러 상태를 거치게 되며, 이를 **프로세스 상태 전이(Process State Transition)**라고 한다. 운영체제는 프로세스의 상태를 추적하며 시스템을 관리한다. 주요 상태는 다음과 같다.40

- **생성 (New / Create)**: 프로세스가 막 생성되었으나 아직 메모리 할당 등 실행 준비가 완료되지 않은 초기 상태이다.38 운영체제는 이 단계에서 PCB를 생성하고 자원을 할당한다.
- **준비 (Ready)**: CPU를 제외한 모든 필요한 자원(메모리 등)을 할당받고, CPU의 할당을 기다리는 상태이다. 준비 상태의 프로세스들은 준비 큐(Ready Queue)라는 리스트에서 자신의 차례를 기다린다.40
- **실행 (Running)**: 프로세스가 CPU를 점유하여 자신의 명령어를 실행하고 있는 상태이다. 단일 프로세서(CPU) 시스템에서는 특정 순간에 오직 하나의 프로세스만이 실행 상태에 있을 수 있다.40
- **대기 (Waiting / Blocked)**: 프로세스가 입출력(I/O) 작업의 완료나 특정 이벤트(예: 시그널 수신)가 발생하기를 기다리는 상태이다. 이 상태의 프로세스는 CPU를 점유하지 않으며, 스스로 대기 상태로 진입한다.36
- **종료 (Terminated)**: 프로세스의 실행이 완료되고, 운영체제가 할당했던 모든 자원을 반납한 상태이다. 운영체제는 해당 프로세스의 PCB를 제거하여 정리 작업을 수행한다.41

이러한 상태들 사이의 전환은 특정 이벤트에 의해 발생한다.

- **승인 (Admitted)**: 생성 상태의 프로세스가 시스템 자원을 할당받아 준비 큐로 이동한다.
- **디스패치 (Dispatch)**: 준비 상태의 프로세스가 CPU 스케줄러에 의해 선택되어 CPU를 할당받고 실행 상태로 전환되는 과정이다.39
- **타임아웃 (Timeout)**: 실행 상태의 프로세스가 자신에게 할당된 CPU 시간(Time Quantum)을 모두 소진하면, 운영체제는 인터럽트를 통해 CPU 제어권을 회수하고 해당 프로세스를 다시 준비 상태로 되돌려 보낸다.36
- **블록 (Block)**: 실행 상태의 프로세스가 파일 읽기와 같은 입출력 작업을 요청하면, 해당 작업이 완료될 때까지 기다려야 하므로 스스로 CPU를 반납하고 대기 상태로 전환된다.36
- **웨이크업 (Wakeup)**: 대기 상태에 있던 프로세스가 기다리던 입출력 작업이나 이벤트가 완료되면, 운영체제는 이를 감지하고 해당 프로세스를 다시 준비 상태로 전환시켜 CPU 할당을 기다리게 한다.37


프로세스는 추상적인 개념이지만, 운영체제는 이를 구체적인 데이터 구조를 통해 관리한다. **프로세스 제어 블록(PCB)**은 운영체제가 특정 프로세스를 관리하기 위해 필요한 모든 정보를 담고 있는 핵심 자료구조이다.41 운영체제에게 프로세스는 곧 PCB이며, PCB가 없다면 프로세스는 존재하지 않는 것과 같다. PCB는 프로세스가 생성될 때 커널 메모리 영역에 함께 만들어지며, 프로세스가 종료되면 폐기된다.41

PCB에는 다음과 같은 중요한 정보들이 저장된다.41

- **프로세스 식별자 (Process ID, PID)**: 시스템 내의 모든 프로세스를 고유하게 식별하기 위한 번호.
- **프로세스 상태 (Process State)**: 현재 프로세스가 준비, 실행, 대기, 종료 등 어떤 상태에 있는지를 나타낸다.
- **프로그램 카운터 (Program Counter, PC)**: 이 프로세스가 다음으로 실행해야 할 명령어의 메모리 주소를 가리킨다.
- **CPU 레지스터**: 프로세스가 실행을 멈추었을 때, CPU의 각종 레지스터(누산기, 스택 포인터, 범용 레지스터 등)에 있던 값들을 저장해 두었다가 나중에 다시 실행을 이어갈 때 복원하기 위해 사용된다.
- **CPU 스케줄링 정보**: 프로세스의 우선순위, 스케줄링 큐에 대한 포인터 등 CPU 스케줄링에 필요한 정보.
- **메모리 관리 정보**: 해당 프로세스에 할당된 메모리 영역에 대한 정보(예: 페이지 테이블의 시작 주소, 경계 레지스터 값 등).
- **입출력 상태 정보**: 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등.

이처럼 PCB는 프로세스의 모든 상태 정보, 즉 **문맥(Context)**을 담고 있는 물리적인 데이터 구조체이다. 따라서 다중 프로그래밍의 핵심 동작인 **문맥 교환(Context Switching)**은 단순히 CPU 제어권을 넘기는 추상적인 행위가 아니다. 이는 현재 CPU의 레지스터 상태를 실행 중이던 프로세스의 PCB에 '저장(save)'하고, 새로 실행할 프로세스의 PCB로부터 이전 상태를 CPU 레지스터로 '복원(restore)'하는 구체적이고 비용이 드는 작업이다.41

문맥 교환이 일어나는 동안 CPU는 사용자 프로그램을 위한 어떠한 유용한 작업도 수행하지 못하므로, 이 시간은 순수한 **오버헤드(Overhead)**가 된다.48 문맥 교환이 너무 자주 발생하면 시스템의 전반적인 성능이 저하될 수 있다. 이 오버헤드는 PCB 저장 및 복원 시간, 스케줄링 알고리즘 실행 비용, 그리고 문맥 교환 시 발생하는 CPU 캐시 무효화(cache flush) 등으로 인해 발생한다.51 이처럼 PCB는 프로세스의 존재를 증명하는 실체인 동시에, 다중 프로그래밍의 효율성을 결정하는 비용의 근원이기도 하다.


다중 프로그래밍 시스템에서는 항상 여러 개의 프로세스가 CPU를 사용하기 위해 준비 큐에서 대기하고 있다. **CPU 스케줄링**은 이 준비 큐에 있는 프로세스들 중에서 어떤 프로세스에게 CPU를 할당할 것인지를 결정하는 운영체제의 핵심 정책이다.52


CPU 스케줄링의 목표는 시스템의 종류(일괄 처리, 대화형 등)에 따라 다르지만, 공통적으로 다음과 같은 목표를 추구한다.53

- **공평성 (Fairness)**: 모든 프로세스가 CPU를 공평하게 할당받아야 하며, 특정 프로세스가 무한히 기다리는 기아 상태(Starvation)가 발생하지 않아야 한다.
- **효율성 (Efficiency)**: CPU가 유휴 상태로 있는 시간을 최소화하여 CPU 이용률을 극대화해야 한다.
- **처리량 (Throughput)**: 단위 시간당 완료되는 프로세스의 수를 최대화해야 한다.
- **총처리 시간 (Turnaround Time)**: 프로세스가 시스템에 제출된 시점부터 완료될 때까지 걸리는 총 시간을 최소화해야 한다.
- **대기 시간 (Waiting Time)**: 프로세스가 준비 큐에서 CPU를 기다리며 보낸 시간의 총합을 최소화해야 한다.
- **응답 시간 (Response Time)**: 사용자가 요청을 보낸 후 첫 번째 응답을 받기까지 걸리는 시간을 최소화해야 한다 (대화형 시스템에서 특히 중요).


스케줄링 방식은 CPU를 강제로 빼앗을 수 있는지 여부에 따라 크게 두 가지로 나뉜다.55

- **비선점형 (Non-preemptive)**: 일단 한 프로세스가 CPU를 할당받으면, 그 프로세스가 스스로 CPU를 반납(종료 또는 I/O 대기)할 때까지 다른 프로세스가 CPU를 빼앗을 수 없다.57 일괄 처리 시스템에 적합하며, 문맥 교환 오버헤드가 적지만 응답 시간 예측이 어렵다.56
- **선점형 (Preemptive)**: 운영체제가 현재 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스에게 CPU를 할당할 수 있다.58 예를 들어, 더 높은 우선순위의 프로세스가 도착하거나, 할당된 시간이 만료되면 선점이 일어난다. 대화형 시분할 시스템에 필수적이며, 빠른 응답 시간을 보장하지만 잦은 문맥 교환으로 인한 오버헤드가 발생할 수 있다.56 현대의 대부분 운영체제는 선점형 방식을 사용한다.57


- **FCFS (First-Come, First-Served)**: '선입선출' 방식으로, 준비 큐에 먼저 도착한 프로세스 순서대로 CPU를 할당하는 가장 간단한 비선점형 알고리즘이다.60
  - **장점**: 구현이 매우 간단하고 공평하게 느껴질 수 있다.
  - **단점**: 실행 시간이 매우 긴 프로세스가 먼저 도착하면, 뒤따르는 짧은 프로세스들이 하염없이 기다려야 하는 **호위 효과(Convoy Effect)**가 발생하여 시스템 전체의 평균 대기 시간이 급격히 늘어날 수 있다.52
- **SJF (Shortest-Job-First)**: 준비 큐에 있는 프로세스들 중에서 예상 CPU 실행 시간(CPU Burst Time)이 가장 짧은 프로세스에게 CPU를 먼저 할당한다.57 이 방식은 평균 대기 시간을 최소화하는 최적의 알고리즘으로 증명되었다.61
  - **비선점형 SJF**: 일단 CPU를 점유하면, 더 짧은 작업이 도착하더라도 현재 작업을 끝까지 수행한다.
  - **선점형 SJF (SRTF: Shortest-Remaining-Time-First)**: 현재 실행 중인 프로세스의 남은 실행 시간보다 더 짧은 실행 시간을 가진 새로운 프로세스가 도착하면, 즉시 CPU를 빼앗아 새로운 프로세스에게 할당한다.61
  - **단점**: 가장 큰 문제는 프로세스의 미래 실행 시간을 정확히 예측하는 것이 불가능하다는 점이다.61 또한, 실행 시간이 긴 프로세스는 계속해서 도착하는 짧은 프로세스들에게 밀려 영원히 CPU를 할당받지 못하는 **기아 상태(Starvation)**에 빠질 수 있다.57
- **우선순위 스케줄링 (Priority Scheduling)**: 각 프로세스에 정적인 또는 동적인 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당하는 방식이다.57 SJF는 CPU 실행 시간을 우선순위로 간주하는 특별한 경우로 볼 수 있다.
  - **단점**: 우선순위가 낮은 프로세스는 기아 상태에 빠질 위험이 크다.
  - **해결책**: **노화(Aging)** 기법을 적용하여, 대기 시간이 길어지는 프로세스의 우선순위를 점진적으로 높여 언젠가는 실행될 기회를 보장한다.57
- **라운드 로빈 (Round Robin, RR)**: 현대적인 시분할 시스템을 위해 고안된 대표적인 선점형 알고리즘이다.57 FCFS와 유사하게 큐를 사용하지만, 각 프로세스는 **타임 퀀텀(Time Quantum)**이라는 정해진 최대 시간만큼만 CPU를 사용할 수 있다.54 만약 프로세스가 퀀텀 내에 작업을 마치지 못하면, CPU를 반납하고 준비 큐의 맨 뒤로 이동한다.57
  - **장점**: 모든 프로세스가 `$(n-1) \times q$` 시간 이내에 최소 한 번은 CPU를 할당받으므로 응답 시간이 빠르고 공평하며, 기아 상태가 발생하지 않는다.54
  - **단점**: 성능이 타임 퀀텀의 크기에 매우 민감하다. 퀀텀이 너무 크면 FCFS와 다를 바 없어지고, 반대로 너무 작으면 문맥 교환이 지나치게 빈번하게 발생하여 오버헤드로 인해 시스템 효율이 떨어진다.57

**표 2: 주요 CPU 스케줄링 알고리즘 비교**

| 알고리즘        | 방식        | 핵심 기준       | 장점                         | 단점                                         |
| --------------- | ----------- | --------------- | ---------------------------- | -------------------------------------------- |
| **FCFS**        | 비선점      | 도착 순서       | 간단하고 공평함              | 호위 효과, 긴 평균 대기 시간                 |
| **SJF/SRTF**    | 비선점/선점 | CPU 버스트 시간 | 평균 대기 시간 최소화 (최적) | 기아 상태 발생 가능, 버스트 시간 예측 어려움 |
| **우선순위**    | 선점/비선점 | 우선순위        | 중요도에 따른 처리 가능      | 기아 상태 발생 가능 (Aging으로 완화)         |
| **Round Robin** | 선점        | 타임 퀀텀       | 짧은 응답 시간, 기아 없음    | 잦은 문맥 교환 오버헤드 (퀀텀이 작을 시)     |


실제 시스템에서는 다양한 성격의 프로세스(예: 빠른 응답이 중요한 대화형 프로세스, 처리량이 중요한 일괄 처리 프로세스)가 혼재한다. 이들을 단일 큐로 관리하는 것은 비효율적이므로, 다단계 큐 기법이 사용된다.

- **다단계 큐 (Multilevel Queue)**: 준비 큐를 여러 개의 독립적인 큐로 분할하는 방식이다.54 예를 들어, 시스템 프로세스 큐, 대화형 프로세스 큐, 일괄 처리 프로세스 큐 등으로 나눌 수 있다. 각 큐는 자신만의 스케줄링 알고리즘(예: 대화형 큐는 RR, 일괄 처리 큐는 FCFS)을 가질 수 있으며, 큐들 사이에는 절대적인 우선순위가 부여된다.54 상위 우선순위 큐가 모두 비어있을 때만 하위 큐의 프로세스가 실행될 수 있다.
  - **단점**: 프로세스가 한번 특정 큐에 할당되면 다른 큐로 이동할 수 없기 때문에, 하위 큐에 있는 프로세스는 기아 상태에 빠지기 쉽다.60
- **다단계 피드백 큐 (Multilevel Feedback Queue)**: 다단계 큐의 단점을 보완하여 프로세스가 큐 사이를 이동할 수 있게 만든, 가장 일반적이면서도 정교한 스케줄링 기법이다.54
  - **동작 방식**: 프로세스의 행동 패턴에 따라 큐를 동적으로 이동시킨다. 예를 들어, CPU를 짧게 사용하고 I/O 대기로 넘어가는 프로세스(대화형 작업으로 간주)는 높은 우선순위 큐에 머무르게 한다. 반면, 할당된 타임 퀀텀을 모두 소진하는 CPU 위주 프로세스는 점차 낮은 우선순위 큐로 강등된다.68 또한, 낮은 우선순위 큐에서 너무 오래 대기한 프로세스는 높은 우선순위 큐로 승격시켜(Aging) 기아 상태를 방지한다.54



다중 프로그래밍 환경에서는 여러 프로세스가 공유 데이터나 자원에 동시에 접근하려 할 때 문제가 발생할 수 있다. 이를 **경쟁 상태(Race Condition)**라 하며, 실행 순서에 따라 결과가 달라져 데이터의 일관성이 깨질 수 있다.

- **임계 구역 (Critical Section)**: 공유 자원에 접근하는 코드 영역으로, 한 번에 하나의 프로세스만 진입하도록 보장해야 하는 구간이다.70
- **상호 배제 (Mutual Exclusion)**: 한 프로세스가 임계 구역을 실행 중일 때 다른 프로세스의 접근을 막는 것을 의미한다.71
- **해결책**:
  - **뮤텍스 (Mutex)**: 임계 구역을 보호하기 위한 가장 기본적인 '잠금(Lock)' 메커니즘이다.72 화장실이 하나뿐인 식당의 열쇠에 비유할 수 있다. 오직 하나의 프로세스만이 열쇠(lock)를 획득하여 임계 구역에 들어갈 수 있으며, 반드시 열쇠를 획득한 그 프로세스가 임계 구역을 나갈 때 열쇠를 반납(unlock)해야 한다.71
  - **세마포어 (Semaphore)**: 정수 값을 가지는 동기화 도구로, `wait()`(P 연산, 값 감소)와 `signal()`(V 연산, 값 증가)이라는 원자적 연산으로만 접근할 수 있다.74
    - **카운팅 세마포어**: 여러 개의 동일한 자원이 있을 때 사용된다. 세마포어의 값은 현재 사용 가능한 자원의 개수를 나타내며, 값이 0보다 클 때만 자원을 획득(wait)할 수 있다.72 화장실 칸이 여러 개인 식당의 빈 칸 개수 표시등과 같다.71
    - **이진 세마포어**: 값이 0과 1만 가질 수 있으며, 뮤텍스와 유사하게 상호 배제를 위해 사용될 수 있다.74
  - **뮤텍스와 세마포어의 근본적 차이**: 뮤텍스는 'Locking' 메커니즘으로, 락을 획득한 프로세스만이 해제할 수 있는 **소유권** 개념이 있다. 반면 세마포어는 'Signaling' 메커니즘으로, 특정 프로세스가 자원을 기다리도록 신호를 보내 멈추게 하고, 다른 프로세스가 작업 완료 후 신호를 보내 깨우는 용도로도 사용될 수 있다. 따라서 락을 획득하지 않은 프로세스도 락을 해제(signal)할 수 있다.70


**교착 상태(Deadlock)**란 둘 이상의 프로세스가 서로 상대방이 점유한 자원을 해제하기만을 기다리며, 결과적으로 아무것도 진행하지 못하고 무한정 대기하는 상태를 말한다.76

- **교착 상태의 4가지 발생 조건**: 다음 네 가지 조건이 **동시에** 충족될 때 교착 상태가 발생할 가능성이 생긴다.77
  1. **상호 배제 (Mutual Exclusion)**: 자원은 한 번에 하나의 프로세스만 사용할 수 있다.
  2. **점유와 대기 (Hold and Wait)**: 프로세스가 최소 하나의 자원을 보유한 상태에서, 다른 프로세스가 점유한 자원을 추가로 요청하며 대기한다.
  3. **비선점 (No Preemption)**: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.
  4. **순환 대기 (Circular Wait)**: 대기하고 있는 프로세스들이 원형의 사슬을 이루며 서로의 자원을 기다린다.
- **교착 상태 처리 기법**: 교착 상태를 다루는 방법은 이론적 완벽함과 현실적 타협 사이의 트레이드오프 관계를 보여준다.
  - **예방 (Prevention)**: 가장 강력한 접근법으로, 교착 상태의 4가지 발생 조건 중 하나 이상이 성립하지 않도록 시스템을 설계하는 방식이다.79 예를 들어, 순환 대기 조건을 막기 위해 모든 자원에 순서를 부여하고 오름차순으로만 자원을 요청하도록 강제할 수 있다. 하지만 대부분의 예방 기법은 자원 이용률을 심각하게 저하시키거나 시스템에 과도한 제약을 가하는 등 부작용이 크다.80
  - **회피 (Avoidance)**: 덜 제한적인 방식으로, 시스템이 자원 할당 요청을 받을 때마다, 해당 요청을 수락할 경우 시스템이 교착 상태에 빠질 가능성이 없는 **안전 상태(Safe State)**로 계속 유지될 수 있는지를 검사한다.82 안전 상태임이 확인될 때만 자원을 할당한다. 대표적인 알고리즘으로 **은행원 알고리즘(Banker's Algorithm)**이 있다.77 이 방법은 예방보다 자원 효율성은 높지만, 각 프로세스가 앞으로 사용할 자원의 최대량을 미리 알아야 한다는 비현실적인 가정을 전제로 한다.80
  - **탐지 및 회복 (Detection & Recovery)**: 교착 상태 발생을 허용하되, 운영체제가 주기적으로 자원 할당 그래프를 분석하여 사이클이 있는지 검사하는 등 교착 상태를 탐지한다.86 교착 상태가 탐지되면, 관련된 프로세스 중 일부를 강제 종료하거나 할당된 자원을 선점하여 교착 상태를 해소하는 방식으로 회복한다.77
  - **무시 (Ignorance)**: 가장 현실적이고 널리 사용되는 접근법이다. 이 방식은 교착 상태가 매우 드물게 발생한다고 가정하고, 이를 예방하거나 탐지하는 데 드는 지속적인 성능 오버헤드가 교착 상태 발생으로 인한 손실보다 크다고 판단한다. 따라서 별도의 조치를 취하지 않고, 문제가 발생하면 사용자가 시스템을 재부팅하는 등의 방법으로 해결하도록 내버려 둔다. 대부분의 범용 운영체제(Windows, UNIX, Linux 등)가 이 방식을 채택하고 있다.86

결국, 교착 상태 처리는 이론적 완벽함(예방)에서 실용적 타협(무시)으로 이어지는 스펙트럼을 형성한다. 이는 운영체제 설계가 항상 최적의 해를 추구하는 것이 아니라, 실제 사용 환경에서의 성능과 복잡도를 고려한 공학적 절충의 산물임을 보여주는 대표적인 사례이다.


메모리는 CPU가 직접 접근할 수 있는 유일한 대용량 저장 공간으로, 모든 실행 가능한 프로그램과 데이터는 반드시 메모리에 적재되어야 한다. 이 장에서는 한정된 메모리 자원을 효율적으로 관리하기 위한 운영체제의 다양한 전략을 탐구한다. 먼저 논리적 주소와 물리적 주소의 개념을 이해하고, 초기 메모리 할당 방식인 연속 할당과 그로 인해 발생하는 단편화 문제를 살펴본다. 이어서 현대 운영체제의 핵심인 페이징과 세그멘테이션 기법을 배우고, 물리 메모리의 한계를 극복하는 가상 메모리의 원리를 학습한다.


컴퓨터 시스템에서 메모리 주소는 두 가지 형태로 존재한다.

- **논리적 주소 (Logical Address)**: CPU가 생성하는 주소로, **가상 주소(Virtual Address)**라고도 불린다.89 각 프로세스는 자신만의 독립적인 0번지부터 시작하는 논리적 주소 공간을 가진다.91 이를 통해 프로그래머는 실제 물리 메모리의 복잡한 상태를 신경 쓸 필요 없이 프로그램을 작성할 수 있다.
- **물리적 주소 (Physical Address)**: 실제 메모리(RAM) 하드웨어상의 주소를 의미한다.89 CPU가 논리적 주소를 통해 데이터에 접근하려 하면, 이 주소는 최종적으로 실제 데이터가 저장된 물리적 주소로 변환되어야 한다.

이처럼 논리적 주소를 물리적 주소로 변환하는 작업을 **주소 바인딩(Address Binding)**이라고 한다.89 이 바인딩이 언제 이루어지느냐에 따라 세 가지 방식으로 나뉜다.

1. **컴파일 시간 바인딩 (Compile Time Binding)**: 프로그램을 컴파일할 때 물리적 주소가 결정된다. 만약 프로그램이 적재될 메모리 위치가 변경되면 코드를 다시 컴파일해야 한다. 멀티 프로그래밍 환경에는 적합하지 않은 구식 방법이다.92

2. **로드 시간 바인딩 (Load Time Binding)**: 프로그램이 메모리에 적재(loading)될 때 물리적 주소가 결정된다. 프로그램 시작 위치가 바뀌어도 재컴파일할 필요는 없지만, 일단 적재된 후에는 메모리 내에서 위치를 이동시킬 수 없다.89

3. **실행 시간 바인딩 (Execution Time Binding)**: 프로그램이 실행 중일 때, CPU가 특정 주소를 참조할 때마다 바인딩이 이루어진다. 이 방식은 프로세스를 메모리 내 다른 위치로 이동시킬 수 있어 가장 유연하며, 현대 운영체제에서 사용하는 방식이다.89 이를 위해서는 하드웨어의 지원이 필수적인데, **MMU(Memory Management Unit)**라는 하드웨어 장치가 이 역할을 수행한다.89 MMU는 CPU가 내보낸 논리적 주소를 실시간으로 물리적 주소로 변환해준다. 가장 간단한 형태의 MMU는 

   **재배치 레지스터(Relocation Register)**(또는 기준 레지스터, Base Register)를 사용하여, 논리적 주소에 재배치 레지스터의 값을 더함으로써 물리적 주소를 계산한다.93



초기 운영체제에서 사용된 가장 간단한 방식으로, 각 프로세스를 물리 메모리의 비어있는 공간에 연속적으로 할당하는 기법이다.96

- **고정 분할 방식 (Fixed Partitioning)**: 물리 메모리를 미리 여러 개의 고정된 크기의 분할(partition)로 나누어두고, 각 분할에 하나의 프로세스를 적재하는 방식이다.97
  - **문제점**: 분할의 크기보다 큰 프로세스는 적재될 수 없다. 또한, 분할의 크기보다 작은 프로세스가 적재되면 남는 공간이 발생하는데, 이 공간은 다른 프로세스가 사용할 수 없어 낭비된다. 이를 **내부 단편화(Internal Fragmentation)**라고 한다.99
- **가변 분할 방식 (Variable Partitioning)**: 미리 메모리를 나누지 않고, 프로세스가 요청하는 크기만큼 동적으로 메모리를 할당하는 방식이다.97
  - **문제점**: 프로세스들이 메모리에 적재되고 해제되는 과정이 반복되다 보면, 총 가용 메모리 공간은 충분하지만 연속적이지 않은 작은 빈 공간들로 쪼개지는 현상이 발생한다. 이로 인해 요청된 크기의 프로세스를 할당할 수 없게 되는 문제를 **외부 단편화(External Fragmentation)**라고 한다.96
  - **배치 전략**: 가변 분할 방식에서 새로운 프로세스를 어떤 빈 공간(hole)에 배치할지 결정하는 전략에는 다음과 같은 것들이 있다.96
    - **최초 적합 (First-fit)**: 요청된 크기를 수용할 수 있는 첫 번째 빈 공간에 할당한다. 속도가 빠르다.
    - **최적 적합 (Best-fit)**: 수용 가능한 빈 공간 중 가장 크기가 작은 곳에 할당한다. 작은 조각들이 많이 남을 수 있다.
    - **최악 적합 (Worst-fit)**: 수용 가능한 빈 공간 중 가장 크기가 큰 곳에 할당한다. 남는 공간이 커서 다른 프로세스가 사용할 가능성이 높다.


연속 할당 방식의 단편화 문제를 해결하기 위해, 하나의 프로세스가 물리 메모리의 여러 분산된 영역에 나뉘어 저장될 수 있도록 허용하는 기법이다. 현대 운영체제는 모두 이 방식을 기반으로 한다.

- **페이징 (Paging)**: 가장 널리 사용되는 메모리 관리 기법 중 하나이다.

  - **개념**: 프로세스의 논리적 주소 공간을 **페이지(Page)**라는 고정된 크기의 블록으로 나누고, 물리 메모리 역시 **프레임(Frame)**이라는 페이지와 동일한 크기의 블록으로 나눈다. 그리고 각 페이지를 비어있는 프레임에 불연속적으로 할당한다.91

  - **주소 변환**: 논리적 주소는 `<페이지 번호(p), 변위(d)>`로 구성된다. 운영체제는 각 프로세스마다 **페이지 테이블(Page Table)**을 유지하는데, 이 테이블은 각 페이지 번호가 어느 프레임 번호에 저장되어 있는지를 매핑하는 정보를 담고 있다.91 MMU는 CPU가 생성한 논리 주소의 페이지 번호(p)를 이용해 페이지 테이블에서 해당 프레임 번호(f)를 찾고, 이를 변위(d)와 결합하여 최종 물리 주소 

    `$f+d$`를 계산한다.105

  - **장단점**: 외부 단편화 문제를 완전히 해결할 수 있다는 큰 장점이 있다.91 하지만 프로세스의 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지에서는 필연적으로 사용되지 않는 공간이 발생하여 내부 단편화 문제가 생길 수 있다.96

- **세그멘테이션 (Segmentation)**: 페이징이 물리적인 고정 크기로 공간을 나누는 것과 달리, 세그멘테이션은 논리적인 내용 단위를 기준으로 공간을 나눈다.96

  - **개념**: 프로세스의 논리적 주소 공간을 코드, 데이터, 스택, 힙 등 의미 있는 단위인 **세그먼트(Segment)**로 분할한다. 각 세그먼트는 서로 다른 크기를 가질 수 있으며, 물리 메모리에 불연속적으로 할당된다.91
  - **주소 변환**: 논리적 주소는 `<세그먼트 번호(s), 변위(d)>`로 구성된다. **세그먼트 테이블**은 각 세그먼트의 물리 메모리 시작 주소(base)와 크기(limit) 정보를 담고 있다.108
  - **장단점**: 논리적 단위로 관리하므로 코드나 데이터를 공유하거나 보호하기에 용이하다.104 또한, 필요한 크기만큼만 할당하므로 내부 단편화가 발생하지 않는다.91 그러나 가변 크기의 세그먼트들이 할당되고 해제되면서 외부 단편화 문제가 발생할 수 있다.96


**가상 메모리**는 실제 물리 메모리의 크기보다 더 큰 프로그램을 실행할 수 있도록 하는 기술로, 현대 운영체제의 핵심 기능이다.110 이는 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하다는 아이디어에서 출발한다.103


가상 메모리는 주로 **요구 페이징** 기법을 통해 구현된다. 이는 프로그램을 실행할 때 모든 페이지를 메모리에 미리 올리는 것이 아니라, 실행에 당장 필요한 페이지만을 메모리에 적재하는 방식이다.111 이를 '게으른 스와퍼(Lazy Swapper)' 방식이라고도 한다.113

- **페이지 부재 (Page Fault)**: 프로세스가 실행 중에 참조하려는 페이지가 현재 물리 메모리에 없는 경우, 하드웨어(MMU)는 **페이지 부재 트랩(Page Fault Trap)**을 발생시켜 운영체제에 제어권을 넘긴다.112
- **페이지 부재 처리 과정**: 페이지 부재가 발생하면 운영체제는 다음과 같은 과정을 수행한다.111
  1. 요청된 페이지에 대한 접근이 유효한지(예: 주소 범위, 접근 권한) 확인한다.
  2. 보조기억장치(스왑 영역)에서 해당 페이지를 찾아 빈 프레임으로 가져온다 (Swap-in).
  3. 만약 빈 프레임이 없다면, **페이지 교체 알고리즘**을 사용하여 기존에 있던 페이지 중 하나를 희생양(victim)으로 선택하여 디스크로 내보낸다 (Swap-out).
  4. 페이지 테이블을 새로운 매핑 정보로 갱신하고, **유효-무효 비트(valid-invalid bit)**를 '유효(valid)'로 설정한다.
  5. 중단되었던 명령어를 다시 실행한다.
- **유효-무효 비트**: 페이지 테이블의 각 항목(PTE)에는 해당 페이지가 현재 물리 메모리에 있는지(valid), 아니면 디스크에 있는지(invalid)를 나타내는 비트가 있다. 이 비트를 통해 페이지 부재 발생 여부를 판단한다.103


물리 메모리가 가득 찼을 때 어떤 페이지를 디스크로 내보낼지(교체할지) 결정하는 정책이다. 목표는 페이지 부재 발생률을 최소화하는 것이다.

- **FIFO (First-In, First-Out)**: 가장 먼저 메모리에 들어온 페이지를 가장 먼저 교체하는 가장 간단한 알고리즘이다.114
  - **단점**: 초기에 들어왔지만 계속해서 사용되는 중요한 페이지를 교체할 수 있다. 또한, 프레임 수를 늘려주었음에도 불구하고 페이지 부재가 오히려 증가하는 **벨레이디의 모순(Belady's Anomaly)** 현상이 발생할 수 있다.110
- **최적 페이지 교체 (Optimal Page Replacement, OPT)**: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다.114 페이지 부재 횟수를 최소화할 수 있는 가장 이상적인 알고리즘이지만, 미래의 페이지 참조를 예측하는 것이 불가능하므로 실제 시스템에서는 구현할 수 없고, 다른 알고리즘의 성능 비교를 위한 기준으로만 사용된다.114
- **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘이다.114 이는 '최근에 사용된 페이지는 가까운 미래에도 다시 사용될 것이다'라는 **시간적 지역성(temporal locality)**에 기반한다.116
  - **장점**: 최적 알고리즘에 가까운 좋은 성능을 보여 많은 시스템에서 채택하고 있다.114
  - **단점**: 모든 페이지 접근마다 시간을 기록하거나 리스트를 유지해야 하므로 구현에 상당한 오버헤드가 발생한다.116


이 장에서는 데이터와 프로그램을 영구적으로 저장하는 보조기억장치, 특히 하드 디스크를 운영체제가 어떻게 관리하는지 다룬다. 파일과 디렉터리의 개념부터 시작하여, 이들을 디스크에 효율적으로 배치하는 파일 시스템의 구조와 할당 방식, 그리고 디스크 헤드의 이동을 최소화하여 성능을 향상시키는 디스크 스케줄링 기법까지 살펴본다.


**파일 시스템**은 컴퓨터에서 파일이나 자료를 쉽게 찾고 접근할 수 있도록 보관하고 조직하는 체계이다.118 운영체제는 파일 시스템을 통해 비휘발성 보조기억장치(하드 디스크, SSD 등)를 관리하며, 사용자에게 일관된 파일 관리 인터페이스를 제공한다.120


- **파일 (File)**: '관련된 정보의 집합'으로, 운영체제 관점에서는 보조기억장치에 저장된 논리적인 최소 단위이다.119 파일은 이름, 유형, 크기, 위치, 접근 권한, 생성 시간 등 다양한 속성(메타데이터)을 가진다.121
- **디렉터리 (Directory)**: 파일들을 체계적으로 분류하고 관리하기 위한 특별한 파일이다.122 GUI 환경에서는 **폴더(Folder)**라고도 불린다.124 디렉터리는 내부에 다른 파일이나 또 다른 디렉터리(하위 디렉터리)를 포함할 수 있으며, 이를 통해 대부분의 운영체제는 **계층적 디렉터리 구조(Hierarchical Directory Structure)**를 형성한다.124


파일 시스템은 여러 계층으로 구성되어 사용자 요청을 물리적 디스크 작업으로 변환한다.121

- **논리 파일 시스템 (Logical File System)**: 사용자와 가장 가까운 계층으로, 파일의 메타데이터(파일 이름, 구조 등)를 관리하고 디렉터리 구조를 유지한다.
- **파일 구성 모듈 (File-Organization Module)**: 파일의 논리적 블록 주소를 물리적 블록 주소로 변환하는 역할을 한다. 디스크의 빈 공간 관리도 담당한다.
- **기본 파일 시스템 (Basic File System)**: 파일 구성 모듈로부터 전달받은 물리적 블록 주소를 이용해 실제 장치 드라이버를 호출하는 명령을 생성한다.
- **I/O 제어 (I/O Control)**: 장치 드라이버와 인터럽트 핸들러로 구성되며, 메모리와 디스크 간의 실제 데이터 전송을 담당한다.


- **순차 접근 (Sequential Access)**: 파일의 내용을 처음부터 끝까지 순서대로 읽거나 쓰는 가장 간단한 방식이다. 테이프 매체처럼 동작하며, 특정 위치로 가려면 처음부터 순차적으로 탐색해야 한다.125
- **직접 접근 (Direct Access)**: 파일의 특정 블록이나 레코드를 순서에 상관없이 직접 읽고 쓸 수 있는 방식이다. 디스크와 같은 임의 접근 매체에서 가능하며, 데이터베이스 시스템에서 널리 사용된다.125
- **색인 접근 (Indexed Access)**: 파일의 내용에 대한 색인(index)을 별도로 유지하여, 색인을 통해 원하는 레코드의 위치를 빠르게 찾아 직접 접근하는 방식이다. 대용량 파일에서 효율적이다.121


파일을 디스크에 저장할 때, 파일의 데이터 블록들을 어떤 방식으로 배치할지 결정하는 기법이다.

- **연속 할당 (Contiguous Allocation)**: 각 파일을 디스크 상의 연속된 블록 공간에 할당하는 가장 간단한 방식이다.127
  - **장점**: 파일의 모든 블록이 물리적으로 인접해 있어 디스크 헤드의 이동이 최소화되므로 읽기 성능이 매우 빠르다. 직접 접근도 용이하다.129
  - **단점**: 메모리의 가변 분할 방식과 마찬가지로 **외부 단편화** 문제가 심각하게 발생한다. 또한, 파일 생성 시 크기를 미리 예측해야 하고, 파일 크기가 커지면 새로운 공간으로 전체를 이동시켜야 하는 비효율성이 있다.129
- **연결 할당 (Linked Allocation)**: 각 데이터 블록이 다음 블록을 가리키는 포인터를 포함하여, 연결 리스트(Linked List) 형태로 파일을 구성하는 방식이다. 디렉터리에는 파일의 첫 번째 블록 주소만 저장하면 된다.
  - **장점**: 외부 단편화가 발생하지 않으며, 파일 크기가 동적으로 변해도 쉽게 확장할 수 있다.127
  - **단점**: 포인터를 저장하기 위한 공간이 추가로 필요하다. 블록들이 디스크에 흩어져 있어 순차 접근 시 헤드 이동이 잦아 성능이 느리며, **직접 접근이 매우 비효율적**이다. 또한, 포인터 하나가 손상되면 그 이후의 모든 데이터를 잃을 수 있는 신뢰성 문제가 있다.127 (이 단점을 보완하기 위해 FAT 파일 시스템이 고안되었다.)
- **색인 할당 (Indexed Allocation)**: 파일의 모든 데이터 블록 주소들을 **색인 블록(Index Block)**이라는 특별한 블록에 모아서 저장하는 방식이다.132 디렉터리에는 이 색인 블록의 주소만 저장한다.
  - **장점**: 외부 단편화가 발생하지 않으면서도, 색인 블록을 통해 원하는 데이터 블록의 주소를 즉시 알 수 있어 **직접 접근을 효율적으로 지원**한다.129
  - **단점**: 파일이 작더라도 색인 블록을 위한 공간(최소 1블록)이 낭비될 수 있다. 파일이 매우 클 경우, 하나의 색인 블록에 모든 주소를 담지 못하는 문제가 발생할 수 있다. (이를 해결하기 위해 연결된 색인 블록, 다단계 색인, 혼합 색인(UNIX의 inode 방식) 등이 사용된다 127).


디스크는 기계적인 장치로, 데이터를 읽고 쓰기 위해 헤드를 특정 트랙으로 이동시키는 **탐색 시간(Seek Time)**이 전체 성능에 가장 큰 영향을 미친다. 디스크 스케줄링은 여러 입출력 요청이 있을 때, 디스크 헤드의 총 이동 거리를 최소화하여 평균 응답 시간을 줄이고 처리량을 높이는 것을 목표로 하는 알고리즘이다.

- **FCFS (First-Come, First-Served)**: 가장 간단한 방식으로, 디스크 큐에 들어온 요청 순서대로 처리한다. 공평하지만, 헤드가 디스크의 양 끝을 불필요하게 왕복하며 비효율적인 경로로 움직일 수 있다.133
- **SSTF (Shortest-Seek-Time-First)**: 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙의 요청을 먼저 처리한다. 평균 탐색 시간을 크게 줄일 수 있지만, 헤드 위치에서 멀리 떨어진 트랙의 요청들은 계속해서 새로운 요청에 밀려 서비스받지 못하는 **기아 상태**가 발생할 수 있다.133
- **SCAN (엘리베이터 알고리즘)**: 디스크 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하면서, 경로상에 있는 모든 요청을 처리한다. 끝에 도달하면 방향을 바꾸어 반대 방향으로 이동하며 다시 요청을 처리한다.133 SSTF의 기아 문제를 해결하지만, 양쪽 끝 트랙에 대한 불평등이 존재한다(막 도착한 쪽은 오래 기다려야 함).
- **C-SCAN (Circular SCAN)**: SCAN과 유사하게 한쪽 끝으로 이동하며 요청을 처리하지만, 끝에 도달하면 반대 방향으로 요청을 처리하며 돌아오는 대신, 요청 처리 없이 곧바로 출발점으로 이동한 후 다시 같은 방향으로 스캔을 시작한다.133 SCAN보다 더 균일한 대기 시간을 제공한다.
- **LOOK / C-LOOK**: SCAN / C-SCAN의 변형으로, 헤드가 더 이상 처리할 요청이 없으면 디스크의 끝까지 이동하지 않고 즉시 방향을 바꾸거나 출발점으로 돌아가 불필요한 이동을 줄인 더 효율적인 방식이다.133


이 장에서는 운영체제의 현대적인 개념과 기술들을 다룬다. 다중 프로세서 환경에서의 동시성 문제를 해결하는 기법, 하나의 물리적 컴퓨터에서 여러 운영체제를 실행하는 가상화 기술, 그리고 네트워크로 연결된 여러 컴퓨터를 하나의 시스템처럼 사용하는 분산 운영체제의 개념을 살펴본다.


다중 스레드 또는 다중 프로세스 환경에서 공유 자원에 대한 동시 접근은 데이터 불일치와 같은 심각한 문제를 야기할 수 있다. **동시성 제어**는 이러한 문제를 해결하고 데이터의 일관성을 보장하기 위한 기법이다. 대표적인 동기화 도구로 세마포어와 뮤텍스가 있다.

- **뮤텍스 (Mutex)**: '상호 배제(Mutual Exclusion)'의 줄임말로, 임계 구역(Critical Section)을 보호하기 위한 **Locking 메커니즘**이다.72
  - **개념**: 화장실이 하나뿐인 식당의 '열쇠'에 비유할 수 있다.71 오직 하나의 스레드만이 열쇠(lock)를 획득하여 임계 구역에 들어갈 수 있다. 다른 스레드들은 열쇠가 반납(unlock)될 때까지 기다려야 한다.
  - **특징**: 가장 중요한 특징은 **소유권(Ownership)**이다. 즉, 열쇠를 획득한(lock) 스레드만이 열쇠를 반납(unlock)할 수 있다.70 동기화 대상이 단 하나일 때 사용된다.75
- **세마포어 (Semaphore)**: 정수 값(카운터)을 가지는 동기화 도구로, **Signaling 메커니즘**으로 동작한다.71
  - **개념**: 화장실 칸이 여러 개인 식당 입구의 '빈 칸 개수 표시등'에 비유할 수 있다.71
  - **동작**: 스레드가 임계 구역에 진입하려 할 때 `wait()` 연산을 호출하여 카운터를 1 감소시킨다. 만약 카운터가 0 이하면, 빈자리가 생길 때까지 대기한다. 임계 구역을 빠져나올 때는 `signal()` 연산을 호출하여 카운터를 1 증가시켜 다른 스레드가 들어올 수 있음을 알린다.
  - **종류**:
    - **카운팅 세마포어 (Counting Semaphore)**: 카운터가 0 이상의 정수 값을 가질 수 있으며, 사용 가능한 자원의 개수를 나타낸다. 여러 스레드가 동시에 접근 가능한 자원에 사용된다.72
    - **이진 세마포어 (Binary Semaphore)**: 카운터가 0 또는 1의 값만 가지며, 뮤텍스와 유사하게 상호 배제를 구현하는 데 사용될 수 있다.72
  - **특징**: 뮤텍스와 달리 소유권 개념이 없다. 따라서 한 스레드가 `wait()`으로 자원을 점유했더라도, 다른 스레드가 `signal()`을 통해 자원을 해제해 줄 수 있다. 이는 복잡한 동기화 상황이나 생산자-소비자 문제 해결에 유용하다.


**가상화(Virtualization)**는 물리적인 컴퓨터 리소스(CPU, 메모리, 스토리지 등)의 특징을 다른 시스템이나 응용 프로그램, 최종 사용자로부터 감추는 기술이다. 가장 일반적인 형태는 하나의 물리적 서버에서 여러 개의 독립적인 가상 머신(Virtual Machine, VM)을 실행하는 것이다.

- **하이퍼바이저 (Hypervisor)**: 가상 머신 모니터(VMM)라고도 불리며, 가상 머신을 생성하고 실행하는 소프트웨어, 펌웨어 또는 하드웨어이다.137 하이퍼바이저는 물리적 하드웨어와 가상 머신 사이에서 중재자 역할을 하며, 각 VM에 필요한 리소스를 할당하고 관리한다. 하이퍼바이저는 구조에 따라 두 가지 유형으로 나뉜다.138
  - **Type 1 (네이티브 또는 베어메탈)**: 운영체제 없이 하드웨어 위에 직접 설치되어 실행된다. 물리적 리소스에 직접 접근하므로 성능이 뛰어나고 격리 수준이 높아 데이터 센터나 클라우드 환경에서 주로 사용된다. 예시로는 VMware ESXi, Microsoft Hyper-V, KVM 등이 있다.138
  - **Type 2 (호스트)**: 일반적인 운영체제(예: Windows, Linux) 위에 하나의 응용 프로그램처럼 설치되어 실행된다. 설치와 관리가 용이하여 개인용 컴퓨터나 개발 환경에서 주로 사용된다. 하지만 호스트 OS를 거쳐 하드웨어에 접근하므로 Type 1에 비해 성능 저하와 오버헤드가 발생한다. 예시로는 Oracle VirtualBox, VMware Workstation 등이 있다.138
- **전가상화와 반가상화**:
  - **전가상화 (Full-Virtualization)**: 하드웨어를 완전히 에뮬레이션하여, 게스트 운영체제를 수정하지 않고 그대로 실행할 수 있는 방식이다.141 게스트 OS는 자신이 가상 환경에서 실행 중이라는 사실을 인지하지 못한다. 하이퍼바이저가 모든 명령을 중재하고 번역해야 하므로 구현이 복잡하고 성능 저하가 발생할 수 있다.140
  - **반가상화 (Para-Virtualization)**: 게스트 OS가 자신이 가상화된 환경임을 인지하고, 하이퍼바이저와 직접 통신(하이퍼콜, Hypercall)하여 성능을 높이는 방식이다.140 이를 위해 게스트 OS의 커널을 일부 수정해야 하는 단점이 있지만, 불필요한 중재 과정을 생략하여 전가상화보다 높은 성능을 제공한다.141


**분산 시스템**은 네트워크를 통해 연결된 독립적인 컴퓨터들의 집합으로, 이들을 사용자에게 하나의 단일하고 일관된 시스템처럼 보이게 하는 것이 **분산 운영체제**의 역할이다.145

- **설계 목적**:
  - **자원 공유 (Resource Sharing)**: 네트워크 상의 다른 컴퓨터에 있는 파일, 프린터, CPU 등 다양한 자원을 공유하여 효율성을 높인다.146
  - **연산 속도 향상 (Computation Speedup)**: 하나의 거대한 작업을 여러 컴퓨터에 분산시켜 병렬로 처리함으로써 전체 작업 완료 시간을 단축시킨다.145
  - **신뢰성 향상 (Reliability)**: 시스템의 일부 컴퓨터에 장애가 발생하더라도, 다른 컴퓨터들이 작업을 계속 수행하여 전체 시스템의 가용성과 안정성을 높인다.145
- **핵심 특징: 투명성 (Transparency)**: 분산 시스템의 가장 중요한 목표는 사용자에게 시스템의 분산된 특성을 숨기는 것이다. 이를 투명성이라고 하며, 여러 종류가 있다.145
  - **위치 투명성 (Location Transparency)**: 자원의 물리적 위치를 알 필요 없이 이름만으로 접근할 수 있다.
  - **이주 투명성 (Migration Transparency)**: 자원이나 프로세스가 시스템 내의 다른 위치로 이동하더라도 사용자는 이를 인지하지 못한다.
  - **복제 투명성 (Replication Transparency)**: 신뢰성이나 성능 향상을 위해 자원이 여러 곳에 복제되어 있더라도, 사용자는 이를 하나의 자원으로 인식한다.
  - **병행 투명성 (Concurrency Transparency)**: 여러 사용자가 동시에 공유 자원에 접근하더라도 시스템이 이를 문제없이 처리한다.
- **장점과 단점**:
  - **장점**: 자원 공유, 높은 성능, 높은 신뢰성, 점진적인 시스템 확장이 용이하다는 점 등 많은 이점을 제공한다.145
  - **단점**: 시스템 설계 및 소프트웨어 개발이 복잡하고, 네트워크를 통해 통신하므로 보안에 취약할 수 있으며, 에러 발생 시 원인 파악이 어렵다.148


1. [Operating System] 운영체제란 / 운영체제 목적 / 운영체제 분류 / 운영체제 구조 - 채채씨의 학습 기록, 8월 15, 2025에 액세스, https://amber-chaeeunk.tistory.com/164
2. [OS] 운영체제란? (운영체제의 역할, 목적, 종류, 기능) - 코딩 공부 일지, 8월 15, 2025에 액세스, https://cocoon1787.tistory.com/685
3. 운영체제 그것이 알고싶다! | 블로그 - 모두의연구소, 8월 15, 2025에 액세스, https://modulabs.co.kr/blog/introducing-os
4. Linux(리눅스)란? 오픈소스 운영체제의 핵심 구성 요소와 장점 - Red Hat, 8월 15, 2025에 액세스, https://www.redhat.com/ko/topics/linux/what-is-linux
5. ko.wikipedia.org, 8월 15, 2025에 액세스, [https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C#:~:text=%EB%8A%94%20%EA%B7%B8%EB%A0%87%EC%A7%80%20%EC%95%8A%EB%8B%A4.-,%EB%AA%A9%EC%A0%81,%EC%9E%88%EB%8A%94%20%ED%99%98%EA%B2%BD%EC%9D%84%20%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4.&text=%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94%20%EC%A0%9C%EC%96%B4%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9C%BC%EB%A1%9C%EC%84%9C,%EA%B3%BC%20%EC%A0%9C%EC%96%B4%EB%A5%BC%20%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4.](https://ko.wikipedia.org/wiki/운영체제#:~:text=는 그렇지 않다.-,목적,있는 환경을 제공한다.&text=운영체제는 제어 프로그램으로서,과 제어를 관리한다.)
6. 운영체제 - 위키백과, 우리 모두의 백과사전, 8월 15, 2025에 액세스, [https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C](https://ko.wikipedia.org/wiki/운영체제)
7. [운영체제] 정의, 목적, 역할, 기능, 구조, 8월 15, 2025에 액세스, https://sxxb-in.tistory.com/8
8. jerryjerryjerry.tistory.com, 8월 15, 2025에 액세스, [https://jerryjerryjerry.tistory.com/171#:~:text=%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98,%EB%8F%99%EC%8B%9C%EC%97%90%20%EC%8B%A4%ED%96%89%EB%90%A0%20%EC%88%98%20%EC%9E%88%EB%8F%84%EB%A1%9D%20%ED%95%9C%EB%8B%A4.](https://jerryjerryjerry.tistory.com/171#:~:text=운영체제는 컴퓨터 시스템의,동시에 실행될 수 있도록 한다.)
9. [운영체제] 운영체제란? - 정의, 역할, 구조 - velog, 8월 15, 2025에 액세스, [https://velog.io/@dddooo9/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EC%A0%95%EC%9D%98-%EC%97%AD%ED%95%A0-%EA%B5%AC%EC%A1%B0](https://velog.io/@dddooo9/운영체제-운영체제란-정의-역할-구조)
10. 3. 운영체제의 역사 (1970~2000) - 성장通 - 티스토리, 8월 15, 2025에 액세스, https://kevin-rain.tistory.com/88
11. 운영체제의 역사, 8월 15, 2025에 액세스, https://rob-coding.tistory.com/23
12. 2. 운영체제의 역사(1950년 ~ 1960년대) - 개발자를 향하여 - 티스토리, 8월 15, 2025에 액세스, https://devraphy.tistory.com/141
13. [OS101] 운영체제 역사 및 기능 - 개발자의 이중생활 - 티스토리, 8월 15, 2025에 액세스, [https://kimdora.tistory.com/entry/%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C-%EC%86%8C%EA%B0%9C](https://kimdora.tistory.com/entry/운영-체제-소개)
14. 운영체제의 기술 발전 흐름 총정리 - 너는 어느 사막 위를 걷고 있는가 - 티스토리, 8월 15, 2025에 액세스, [https://chanelcocolover.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B8%B0%EC%88%A0-%EB%B0%9C%EC%A0%84-%ED%9D%90%EB%A6%84-%EC%B4%9D%EC%A0%95%EB%A6%AC](https://chanelcocolover.tistory.com/entry/운영체제의-기술-발전-흐름-총정리)
15. [OS] 운영체제 운용기법 (발전과정,시스템종류) - nemo's dev memos, 8월 15, 2025에 액세스, https://nemomemo.tistory.com/46
16. 프로그래밍 언어의 발전과 운영체제의 역사 / 운영체제의 발전 | by Seo Minsang | Medium, 8월 15, 2025에 액세스, [https://medium.com/@seominsang/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EC%9D%98-%EB%B0%9C%EC%A0%84%EA%B3%BC-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%EC%82%AC-1%EC%A3%BC%EC%B0%A8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%B0%9C%EC%A0%84-80df6f89192f](https://medium.com/@seominsang/프로그래밍-언어의-발전과-운영체제의-역사-1주차-운영체제의-발전-80df6f89192f)
17. 운영체제의 역사 - 위키백과, 우리 모두의 백과사전, 8월 15, 2025에 액세스, [https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98_%EC%97%AD%EC%82%AC](https://ko.wikipedia.org/wiki/운영체제의_역사)
18. chap1. 운영체제의 개념과 태동, 그리고 발전 - MyCodingStudyNote, 8월 15, 2025에 액세스, https://codejin.tistory.com/251
19. [운영체제] 1. 운영체제의 시작과 발전 - velog, 8월 15, 2025에 액세스, [https://velog.io/@passion_man/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-1.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%8B%9C%EC%9E%91%EA%B3%BC-%EB%B0%9C%EC%A0%84](https://velog.io/@passion_man/운영체제-1.-운영체제의-시작과-발전)
20. OS의 정의와 발전 과정 - 개 x발 - 티스토리, 8월 15, 2025에 액세스, https://programmingjun.tistory.com/76
21. [OS]운영체제(OS: Operating System)의 역사 - 베스핀글로벌 테크센터 블로그, 8월 15, 2025에 액세스, https://btcd.tistory.com/48
22. 운영체제의 역할과 발전과정 - IT 공부한거 올리는 블로그, 8월 15, 2025에 액세스, https://it-learn.tistory.com/85
23. 2. 운영체제 - 티스토리, 8월 15, 2025에 액세스, https://arainablog.tistory.com/275
24. [IT산업 20년 전] 윈도우의 흥망성쇠 - 컴퓨터월드, 8월 15, 2025에 액세스, https://www.comworld.co.kr/news/articleView.html?idxno=48816
25. MS-DOS - 나무위키, 8월 15, 2025에 액세스, https://namu.wiki/w/MS-DOS
26. 그래픽 사용자 인터페이스 - 나무위키, 8월 15, 2025에 액세스, [https://namu.wiki/w/%EA%B7%B8%EB%9E%98%ED%94%BD%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4](https://namu.wiki/w/그래픽 사용자 인터페이스)
27. [CrashCourse] 그래픽 유저 인터페이스 (컴퓨터 과학 수업 26/40), 8월 15, 2025에 액세스, https://deepaal.tistory.com/56
28. 거의 모든 IT의 역사 - 브런치, 8월 15, 2025에 액세스, https://brunch.co.kr/@medicibooks/28
29. [Linux] 리눅스와 다른 운영체제 비교(vs Windows, Mac os), 8월 15, 2025에 액세스, https://hi-ai0913.tistory.com/3
30. Windows랑 Mac, Linux는 실제로 무슨 차이가 있어? : r/AskProgramming - Reddit, 8월 15, 2025에 액세스, https://www.reddit.com/r/AskProgramming/comments/1c3lf8z/what_actual_difference_is_there_between_windows/?tl=ko
31. 프로그래밍을 위한 Mac 대 Windows 대 Linux: 어떤 OS가 가장 좋을까요? - ClickUp, 8월 15, 2025에 액세스, https://clickup.com/ko/blog/218063/mac-vs-linux-vs-windows-for-programming
32. 어린이용 설명 맥/리눅스 앱 설치 vs 윈도우 앱 설치 차이 : r/explainlikeimfive - Reddit, 8월 15, 2025에 액세스, https://www.reddit.com/r/explainlikeimfive/comments/pcip7b/eli5_maclinux_app_installation_vs_windows/?tl=ko
33. 운영체제의 종류와 비교: Windows, macOS, Linux, Android, iOS, 8월 15, 2025에 액세스, [https://oobwrite.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%B9%84%EA%B5%90-Windows-macOS-Linux-Android-iOS](https://oobwrite.com/entry/운영체제의-종류와-비교-Windows-macOS-Linux-Android-iOS)
34. EXT4가 진짜 NTFS보다 나은 거야? : r/linux4noobs - Reddit, 8월 15, 2025에 액세스, https://www.reddit.com/r/linux4noobs/comments/160kbio/is_ext4_really_better_than_ntfs/?tl=ko
35. macOS vs 리눅스: 개발자 워크스테이션 OS로서의 생산성 비교 🖥️ - 재능넷, 8월 15, 2025에 액세스, https://www.jaenung.net/tree/6207
36. [OS] 프로세스 개념과 상태 변화 및 관리 - About SY - 티스토리, 8월 15, 2025에 액세스, https://s-y-130.tistory.com/322
37. [운영체제] 6. 프로세스의 개념과 상태 변화 - Wonit - 티스토리, 8월 15, 2025에 액세스, https://wonit.tistory.com/81
38. 프로세스 상태 전이도 ( Process State Diagram ) - 개발라마 - 티스토리, 8월 15, 2025에 액세스, https://junsday.tistory.com/25
39. 운영체제 - 프로세스(Process)란? 프로세스상태,Context Switching - 코딩스타트 - 티스토리, 8월 15, 2025에 액세스, https://coding-start.tistory.com/198
40. 공룡책으로 정리하는 운영체제 - CHAPTER 3. 프로세스(Process), 8월 15, 2025에 액세스, https://will-behappy.tistory.com/19
41. [운영체제] 프로세스의 상태 변화, 프로세스 제어 블록 (PCB), 8월 15, 2025에 액세스, [https://laurent.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-PCB](https://laurent.tistory.com/entry/운영체제-프로세스의-상태-변화-프로세스-제어-블록-PCB)
42. 프로세스 상태 전이도(Process State Diagram) - Anything Is Possible - 티스토리, 8월 15, 2025에 액세스, https://hi5june.tistory.com/30
43. [Chapter 3. 프로세스] 프로세스의 상태 - 봉황대 in CS - 티스토리, 8월 15, 2025에 액세스, https://eunajung01.tistory.com/46
44. ground90.tistory.com, 8월 15, 2025에 액세스, [https://ground90.tistory.com/100#:~:text=PCB%EB%8A%94%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98%20%EC%A0%95%EB%B3%B4,%EC%83%81%ED%83%9C%20%EB%93%B1%EC%9D%84%20%ED%8F%AC%ED%95%A8%ED%95%A9%EB%8B%88%EB%8B%A4.](https://ground90.tistory.com/100#:~:text=PCB는 프로세스의 정보,상태 등을 포함합니다.)
45. 프로세스 제어 블록(PCB) - 티스토리, 8월 15, 2025에 액세스, [https://one-armed-boy.tistory.com/entry/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9DPCB](https://one-armed-boy.tistory.com/entry/프로세스-제어-블록PCB)
46. [OS] 프로세스 제어 블록(PCB), 문맥 교환 - 솜은 코튼 - 티스토리, 8월 15, 2025에 액세스, https://sommda.tistory.com/84
47. 프로세스 제어 블록(PCB, Process Control Block) - G-Stack - 티스토리, 8월 15, 2025에 액세스, https://ground90.tistory.com/100
48. 문맥교환(context switching)과 오버헤드(overhead) - 우당탕탕 개발 - 티스토리, 8월 15, 2025에 액세스, https://oizys.tistory.com/14
49. [운영체제] PCB와 컨텍스트 스위칭(Context Switching) - 신입개발자 쩨리 - 티스토리, 8월 15, 2025에 액세스, https://jerryjerryjerry.tistory.com/181
50. 컨텍스트 스위칭(Context Switching): 멀티태스킹의 핵심 원리 - 유니얼 게임 개발, 8월 15, 2025에 액세스, https://unialgames.tistory.com/entry/CSharpContextSwitching
51. Context Switch가 일어날 때는 왜 overhead가 클까? - Dev. Ella, 8월 15, 2025에 액세스, https://dev-ellachoi.tistory.com/106
52. [운영체제] 1. CPU 스케줄링(개념, 알고리즘) - 우당탕탕 규투리의 개발일지, 8월 15, 2025에 액세스, https://hi-claire.tistory.com/m/48
53. [운영체제] CPU 스케줄링 - 평범한 공대생의 개발 노트 - 티스토리, 8월 15, 2025에 액세스, https://rob-coding.tistory.com/31
54. [OS/운영체제] CPU 스케줄링과 알고리즘 - 햄버거의 개발 - 티스토리, 8월 15, 2025에 액세스, https://eunsun-zizone-zzang.tistory.com/38
55. [운영체제] 선점형/비선점형 스케쥴러 - Grace's Tech Blog - 티스토리, 8월 15, 2025에 액세스, [https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%A0%EC%A0%90%ED%98%95%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC](https://libertegrace.tistory.com/entry/운영체제-선점형비선점형-스케쥴러)
56. 선점형 스케쥴링&비선점형 스케쥴링, 8월 15, 2025에 액세스, [https://jcsoohwancho.github.io/2019-10-25-%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81&%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/](https://jcsoohwancho.github.io/2019-10-25-선점형-스케쥴링&비선점형-스케쥴링/)
57. [운영체제] CPU 스케줄링 2 (FCFS, SJF, SRTF, Round Robin ..., 8월 15, 2025에 액세스, [https://rannnneey.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-2-FCFS-SJF-SRTF-Round-Robin-Multilevel-Queue-Multilevel-Feedback](https://rannnneey.tistory.com/entry/운영체제-CPU-스케줄링-2-FCFS-SJF-SRTF-Round-Robin-Multilevel-Queue-Multilevel-Feedback)
58. 선점형(Pre-emption)OS와 비선점형(Nonpre-emption)OS 차이 - 개발자를 꿈꾸는 프로그래머, 8월 15, 2025에 액세스, https://jwprogramming.tistory.com/14
59. [개발자 면접] 선점형 스케줄링과 비선점 스케줄링의 차이 - zeroco - 티스토리, 8월 15, 2025에 액세스, https://zeroco.tistory.com/76
60. [운영체제] CPU 스케줄링 알고리즘 정리 및 요약, FCFS, SJF, Round Robin - 코드 연구소, 8월 15, 2025에 액세스, https://code-lab1.tistory.com/45
61. [OS] CPU 스케줄링, 스케줄링 알고리즘(FCFS, SJF, RR, RMS, EDF) - 주니모 오두막, 8월 15, 2025에 액세스, https://pom-pomm.tistory.com/20
62. CPU 스케줄러 전략 (FCFS, SJF, HRN, SRT, Round Robin, Multi-Level Queue) - ‍ 은진의 로그파일 ✍️ - 티스토리, 8월 15, 2025에 액세스, https://aeroej.tistory.com/143
63. 운영체제: 프로세스(Process)와 스케줄링 알고리즘 - WRITING BEYOND BOUNDARIES, 8월 15, 2025에 액세스, [https://oobwrite.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4Process%EC%99%80-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://oobwrite.com/entry/운영체제-프로세스Process와-스케줄링-알고리즘)
64. CPU 스케줄링, 8월 15, 2025에 액세스, https://sihyung92.oopy.io/os/5
65. 다단계 큐 스케줄링 - 위키백과, 우리 모두의 백과사전, 8월 15, 2025에 액세스, [https://ko.wikipedia.org/wiki/%EB%8B%A4%EB%8B%A8%EA%B3%84_%ED%81%90_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81](https://ko.wikipedia.org/wiki/다단계_큐_스케줄링)
66. Chapter5 프로세스 스케줄링(Multilevel Queue, Multilevel Feedback Queue ) - Hi, I'm JeongHun - 티스토리, 8월 15, 2025에 액세스, https://jeonghoonmoon.tistory.com/120
67. CPU Scheduling(스케줄링) - 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링, Fair-share 스케줄링, 실시간 스케줄링 - IT, FIRE, License and Daily life - 티스토리, 8월 15, 2025에 액세스, https://itdexter.tistory.com/394
68. [운영체제 9편] 스케줄링 종류 - 개발자 배씨 - 티스토리, 8월 15, 2025에 액세스, https://baebalja.tistory.com/360
69. 다단계 큐, 다단계 피드백 큐 스케줄링 알고리즘 | CPU 스케줄링 | 운영체제 - YouTube, 8월 15, 2025에 액세스, https://www.youtube.com/watch?v=7sJX0miYpHk
70. [OS] 뮤텍스와 세마포어 (Mutex and Semaphore) - Hoyeon, 8월 15, 2025에 액세스, https://hoyeonkim795.github.io/posts/mutex-semaphore/
71. 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이 - Worth spreading - 티스토리, 8월 15, 2025에 액세스, https://worthpreading.tistory.com/90
72. [OS] 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 - MangKyu's Diary, 8월 15, 2025에 액세스, https://mangkyu.tistory.com/104
73. [운영체제] Mutex 뮤텍스와 Semaphore 세마포어의 차이 - 우당탕탕 히온이네 - 티스토리, 8월 15, 2025에 액세스, https://heeonii.tistory.com/14
74. [10분 테코톡] 오션의 뮤텍스와 세마포어 - YouTube, 8월 15, 2025에 액세스, https://www.youtube.com/watch?v=NL9JQh5bbZ8
75. Mutex 와 Semaphore. Mutex(Mutual Exclusion)란? | by Chae - Medium, 8월 15, 2025에 액세스, [https://chaeoff.medium.com/mutex-%EC%99%80-semaphore-9c43a6f81d48](https://chaeoff.medium.com/mutex-와-semaphore-9c43a6f81d48)
76. 데드락(Deadlock) 의 발생조건과 이를 해결하기 위한 4가지 방안(예방, 회피, 검출, 회복), 8월 15, 2025에 액세스, https://haon.blog/cs/os/deadlock/
77. [운영체제] Deadlock(교착상태)의 정의와 필수조건, 예방, 회피, 회복 기법 - velog, 8월 15, 2025에 액세스, [https://velog.io/@smallcherry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Deadlock%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%ED%95%84%EC%88%98%EC%A1%B0%EA%B1%B4-%EC%98%88%EB%B0%A9-%ED%9A%8C%ED%94%BC-%ED%9A%8C%EB%B3%B5-%EA%B8%B0%EB%B2%95](https://velog.io/@smallcherry/운영체제-Deadlock교착상태의-정의와-필수조건-예방-회피-회복-기법)
78. 교착상태(Deadlock)에 대해서 설명해 주세요., 8월 15, 2025에 액세스, https://www.nossi.dev/d42a6f0e-492a-4a23-ab97-fb30e78f054c
79. [운영체제] 13. 교착상태의 해결 방법(예방, 회피, 회복) - Wonit - 티스토리, 8월 15, 2025에 액세스, https://wonit.tistory.com/96
80. \#5 - 1) 교착상태 (Deadlock) - 얍문's Coding World.. - 티스토리, 8월 15, 2025에 액세스, https://yabmoons.tistory.com/662
81. [OS] 교착상태 해결 방법 예방, 회피, 탐지 - Hoyeon, 8월 15, 2025에 액세스, [https://hoyeonkim795.github.io/posts/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/](https://hoyeonkim795.github.io/posts/교착상태해결방법/)
82. [OS] 교착상태(Deadlock, 데드락)의 정의, 발생 조건, 해결 방법 - 코딩 공부 일지, 8월 15, 2025에 액세스, https://cocoon1787.tistory.com/858
83. [OS] 교착 상태의 해결 방법 - About SY - 티스토리, 8월 15, 2025에 액세스, https://s-y-130.tistory.com/329
84. [OS] 은행원 알고리즘 (예시문제 까지) | Hoyeon, 8월 15, 2025에 액세스, https://hoyeonkim795.github.io/posts/bankers/
85. Banker's 알고리즘 - 지식덤프, 8월 15, 2025에 액세스, http://www.jidum.com/jidums/view.do?jidumId=451
86. 교착상태(Dead Lock) 해결 방법 - yoongrammer - 티스토리, 8월 15, 2025에 액세스, https://yoongrammer.tistory.com/67
87. [OS] 교착 상태 해결 방법 (교착 상태 탐지) - 솜은 코튼 - 티스토리, 8월 15, 2025에 액세스, https://sommda.tistory.com/81
88. 교착 상태 발생 조건과 해결 방안을 말해주세요. - velog, 8월 15, 2025에 액세스, https://velog.io/@tbh05158/Temp-Title
89. 8. 메모리 관리 - velog, 8월 15, 2025에 액세스, [https://velog.io/@sunaookamisiroko/8.-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC](https://velog.io/@sunaookamisiroko/8.-메모리-관리)
90. 메모리의 주소 공간: 물리/논리주소 가상메모리 & 주소 변환 - hmmumm - 티스토리, 8월 15, 2025에 액세스, [https://mmmhmm.tistory.com/m/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC%EB%85%BC%EB%A6%AC%EC%A3%BC%EC%86%8C-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC](https://mmmhmm.tistory.com/m/entry/메모리의-주소-공간-물리논리주소-가상메모리)
91. [운영체제] 메모리 관리 기법 - 페이징 & 세그멘테이션 - 데일리디벨롭, 8월 15, 2025에 액세스, https://hyuuny.tistory.com/155
92. [OS] 논리(Logical) 메모리와 물리(Physical) 메모리에 관하여 - middlefitting - 티스토리, 8월 15, 2025에 액세스, https://middlefitting.tistory.com/51
93. [ 운영체제 ] 주소 공간(Address Space), 물리적 주소(Physical ..., 8월 15, 2025에 액세스, https://charles098.tistory.com/103
94. 컴퓨터 구조 #13 - 메모리 주소 공간 - 물리 주소와 논리 주소 - 차곡차곡 성 쌓기, 8월 15, 2025에 액세스, https://uzinlab.tistory.com/109
95. [CS] 논리주소와 물리주소 - 김놀자, 8월 15, 2025에 액세스, https://cjbworld.tistory.com/34
96. [운영체제]메모리 관리 전략(Memory Management Strategy), 8월 15, 2025에 액세스, [https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy](https://dheldh77.tistory.com/entry/운영체제메모리-관리-전략Memory-Management-Strategy)
97. [Operating System] 메모리 할당 - Tech Log - 티스토리, 8월 15, 2025에 액세스, https://hapen385.tistory.com/49
98. [OS] 연속 메모리 할당 - About SY - 티스토리, 8월 15, 2025에 액세스, https://s-y-130.tistory.com/337
99. [OS] 메모리 할당 기법(연속 할당, 불연속 할당)에 대해 알아보자. - Study Repository, 8월 15, 2025에 액세스, https://rlaehddnd0422.tistory.com/246
100. [운영체제 11편] 메모리 할당 (연속할당 방식) - 개발자 배씨 - 티스토리, 8월 15, 2025에 액세스, https://baebalja.tistory.com/416
101. [운영체제 OS] 메모리 관리란? - 이유, 방법 - 내가보려고만든 메자노트 - 티스토리, 8월 15, 2025에 액세스, https://technote-mezza.tistory.com/92
102. [운영체제] 물리 메모리 관리 - 평범한 공대생의 개발 노트 - 티스토리, 8월 15, 2025에 액세스, https://rob-coding.tistory.com/32
103. 가상 메모리(Virtual Memory), 페이징(Paging) - 다락방 - 티스토리, 8월 15, 2025에 액세스, https://hojunking.tistory.com/110
104. [OS] 페이징과 세그멘테이션 - velog, 8월 15, 2025에 액세스, [https://velog.io/@jsi06138/OS-%ED%8E%98%EC%9D%B4%EC%A7%95%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98](https://velog.io/@jsi06138/OS-페이징과-세그멘테이션)
105. 세그멘테이션과 페이징 (+ 비교 ) - Scatch note, 8월 15, 2025에 액세스, [https://mglee.dev/blog/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98%EA%B3%BC-%ED%8E%98%EC%9D%B4%EC%A7%95-%EB%B9%84%EA%B5%90/](https://mglee.dev/blog/세그멘테이션과-페이징-비교/)
106. [OS] 페이징 & 세그멘테이션 - BUILD_SSO - 티스토리, 8월 15, 2025에 액세스, https://sohyeonnn.tistory.com/14
107. [운영체제] 페이징과 세그멘테이션 - 뜬 눈으로 꾸는 꿈 - 티스토리, 8월 15, 2025에 액세스, https://bellog.tistory.com/159
108. [운영체제] 단편화와 메모리 관리 기법(페이징, 세그멘테이션) - 뚜발자 - 티스토리, 8월 15, 2025에 액세스, https://s0ojin.tistory.com/43
109. [운영체제] 페이징과 세그멘테이션 - 느리더라도 꾸준하게 - 티스토리, 8월 15, 2025에 액세스, https://steady-coding.tistory.com/524
110. 운영체제. 가상 메모리, 페이징 - velog, 8월 15, 2025에 액세스, [https://velog.io/@leeesangheee/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%8E%98%EC%9D%B4%EC%A7%95](https://velog.io/@leeesangheee/운영체제.-가상-메모리-페이징)
111. [OS] 요구 페이징(가상메모리) - 장장스 - 티스토리, 8월 15, 2025에 액세스, https://zangzangs.tistory.com/142
112. [OS] 요구 페이징 - 인성의 개발 공부 노트 - 티스토리, 8월 15, 2025에 액세스, https://superohinsung.tistory.com/127
113. [운영체제] 가상 메모리 관리 - 평범한 공대생의 개발 노트, 8월 15, 2025에 액세스, https://rob-coding.tistory.com/36
114. [운영체제] 페이지 교체 알고리즘 (FIFO/OPT/LRU/LFU/MFU), 8월 15, 2025에 액세스, https://code-lab1.tistory.com/60
115. [OS] 3. 페이지 교체 알고리즘[OPT/FIFO/LRU/LFU/NUR/SCR 등] - 초보개발자의 개발이야기, 8월 15, 2025에 액세스, https://berkley.tistory.com/111
116. [OS] 페이지 교체 알고리즘 - FIFO/LRU/LFU/MFU/NUR - CORE DATA - 티스토리, 8월 15, 2025에 액세스, https://doh-an.tistory.com/28
117. [OS/운영체제] 페이지 교체 (Page Replacement) - (2) - 4Legs_Archives - 티스토리, 8월 15, 2025에 액세스, https://4legs-study.tistory.com/54
118. OS 파일시스템(File System) - 개발새발 개발개발, 8월 15, 2025에 액세스, https://daesiker.tistory.com/36
119. File System(1) - 운영체제(OS) - velog, 8월 15, 2025에 액세스, [https://velog.io/@thdalstn6352/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-File-System](https://velog.io/@thdalstn6352/운영체제OS-File-System)
120. [OS] File System 이란? - beatmejy - 티스토리, 8월 15, 2025에 액세스, https://beatmejy.tistory.com/30
121. OS - File System(파일시스템), 8월 15, 2025에 액세스, https://jackcokebb.tistory.com/15
122. ko.wikipedia.org, 8월 15, 2025에 액세스, [https://ko.wikipedia.org/wiki/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC#:~:text=%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC(%EC%98%81%EC%96%B4%3A%20directory%2C%20%EB%AC%B8%ED%99%94%EC%96%B4,%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8(catalog)%EB%9D%BC%EA%B3%A0%EB%8F%84%20%ED%95%9C%EB%8B%A4.](https://ko.wikipedia.org/wiki/디렉토리#:~:text=디렉토리(영어%3A directory%2C 문화어,카탈로그(catalog)라고도 한다.)
123. 3. 파일과 디렉토리 / UNIXBasic - Jihoo Yim, 8월 15, 2025에 액세스, https://jihooyim1.gitbooks.io/unixbasic/content/contents/03.html
124. 디렉터리 - 나무위키, 8월 15, 2025에 액세스, [https://namu.wiki/w/%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC](https://namu.wiki/w/디렉터리)
125. [운영체제] 파일 시스템 - velog, 8월 15, 2025에 액세스, [https://velog.io/@k4minseung/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C](https://velog.io/@k4minseung/운영체제-파일-시스템)
126. [운영체제 OS] 파일 시스템 File System - MYVELOP 마이벨롭 - 티스토리, 8월 15, 2025에 액세스, https://myvelop.tistory.com/203
127. [Chapter 11. 파일 시스템 구현] 파일 시스템, 디스크 공간 할당 방법과 ..., 8월 15, 2025에 액세스, https://eunajung01.tistory.com/92
128. [운영체제][저장장치관리] 저장장치와 입출력(Storage & Input/Output) #4 파일 시스템 구현, 8월 15, 2025에 액세스, https://yonghwankim-dev.tistory.com/497
129. [운영체제] 디스크 공간할당 - 이누의 개발성장기 - 티스토리, 8월 15, 2025에 액세스, https://inuplace.tistory.com/383
130. 파일 할당(File Allocation) - 호모 아키비스트 - 티스토리, 8월 15, 2025에 액세스, [https://yeongunheo.tistory.com/entry/%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9](https://yeongunheo.tistory.com/entry/파일-할당)
131. [운영체제 정리] 19: 파일 할당 (Allocation of file) - 완숙의 에그머니, 8월 15, 2025에 액세스, [https://wansook0316.github.io/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-19-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9.html](https://wansook0316.github.io/cs/os/2020/04/06/운영체제-정리-19-파일-할당.html)
132. 19. 파일 할당(File Allocation) - velog, 8월 15, 2025에 액세스, [https://velog.io/@shin_ms/19.-%ED%8C%8C%EC%9D%BC-%ED%95%A0%EB%8B%B9File-Allocation](https://velog.io/@shin_ms/19.-파일-할당File-Allocation)
133. [운영체제] 디스크 스케줄링이란?(Disk Scheduling) - Limky 삽질블로그, 8월 15, 2025에 액세스, https://limkydev.tistory.com/165
134. [운영체제 정리] 20: 디스크 스케쥴링 알고리즘 | 완숙의 에그머니, 8월 15, 2025에 액세스, [https://wansook0316.github.io/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-20-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html](https://wansook0316.github.io/cs/os/2020/04/06/운영체제-정리-20-디스크-스케줄링-알고리즘.html)
135. 디스크 관리와 스케줄링, 8월 15, 2025에 액세스, https://sihyung92.oopy.io/os/11
136. [정보처리특강] 디스크 스케줄링 - SCAN, C-SCAN - YouTube, 8월 15, 2025에 액세스, https://www.youtube.com/watch?v=drgRPjEVlP8
137. 가상화의 종류 - 전가상화와 반가상화 - A6K 개발노트, 8월 15, 2025에 액세스, https://hbase.tistory.com/472
138. 1형 및 2형 하이퍼바이저 비교 - 하이퍼바이저 유형 간의 차이점 - AWS, 8월 15, 2025에 액세스, https://aws.amazon.com/ko/compare/the-difference-between-type-1-and-type-2-hypervisors/
139. 하이퍼바이저(Hypervisor)란 무엇인가? with 가상화 (Virutalization) - Neu@security-blog, 8월 15, 2025에 액세스, https://neutrinox4b1.tistory.com/19
140. [클라우드] 가상화의 종류(호스트OS , 하이퍼바이저-가상화와 반 ..., 8월 15, 2025에 액세스, [https://lee-automation-lab.tistory.com/entry/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EA%B0%80%EC%83%81%ED%99%94%EC%9D%98-%EC%A2%85%EB%A5%98%ED%98%B8%EC%8A%A4%ED%8A%B8OS-%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80-%EA%B0%80%EC%83%81%ED%99%94%EC%99%80-%EB%B0%98%EA%B0%80%EC%83%81%ED%99%94-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88](https://lee-automation-lab.tistory.com/entry/클라우드-가상화의-종류호스트OS-하이퍼바이저-가상화와-반가상화-컨테이너)
141. 반가상화 전가상화 - 별 볼일있는 공간 - 티스토리, 8월 15, 2025에 액세스, https://wlstnans.tistory.com/17
142. [가상화] Full Virtualization & Para Virtualization (전가상화와 반가상화) - Suyeon's Blog, 8월 15, 2025에 액세스, https://suyeon96.tistory.com/53
143. 전가상화와 반가상화 (Full & Para Virtualization) - #devspace - 티스토리, 8월 15, 2025에 액세스, https://myminju.tistory.com/100
144. [Server] 하드웨어 가상화(Virtualization)의 종류 및 차이 (2/2) - 망나니개발자 - 티스토리, 8월 15, 2025에 액세스, https://mangkyu.tistory.com/87
145. [OS-19] 분산 운영체제 - DevGang - 티스토리, 8월 15, 2025에 액세스, https://kkyu-coder.tistory.com/63
146. 분산 운영체제 - 취미로 공부하기, 8월 15, 2025에 액세스, https://3catpapa.tistory.com/118
147. 컴퓨터 시스템 정리 (분산 시스템, 병렬 시스템, 클러스터 시스템, Real-Time 시스템, Handled 시스템) - Jay's Blog - 티스토리, 8월 15, 2025에 액세스, https://enlqn1010.tistory.com/31
148. PART 03. 운영체제 - 분산 운영체제 - 까망눈연구소 - 티스토리, 8월 15, 2025에 액세스, https://wogh8732.tistory.com/43

