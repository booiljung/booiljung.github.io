[리눅스](./index.md)
# 리눅스 자습서

리눅스는 오늘날 컴퓨팅 환경에서 빼놓을 수 없는 중요한 운영체제이다. 개인용 컴퓨터부터 슈퍼 컴퓨터, 휴대전화, 스마트 TV와 같은 임베디드 시스템에 이르기까지 광범위하게 사용된다.1 이 자습서는 리눅스의 근본적인 이해를 돕고, 시스템을 효율적으로 활용하기 위한 필수 지식을 제공할 것이다.


리눅스 운영체제에 대한 근본적인 이해를 돕기 위해, 그 정의와 탄생 배경, 핵심적인 특징 및 장점을 설명한다. 또한 유닉스와의 관계를 명확히 하고, 주요 배포판들을 소개하여 리눅스 생태계의 다양성을 이해하도록 돕는다.


리눅스는 유닉스와 마찬가지로 다중 동시 사용자 시스템이다.2 유닉스가 통신 네트워크를 지향해 설계된 것처럼, 리눅스 역시 서버로 작동하는 데 최적화되어 있다.2 이러한 설계 철학 덕분에 리눅스는 서버 및 임베디드 시스템 분야에서 큰 발전을 이루었다.2

리눅스는 독점되거나 배타되지 않는 프리 소프트웨어 중 하나로, 'GNU 프로젝트'에 따라 누구나 쉽게 이용할 수 있도록 배포된다.1 리눅스의 이러한 개방성은 단순한 소프트웨어 배포 방식을 넘어선다. 소스 코드가 공개되어 누구나 활용하고 수정하며 재배포할 수 있기 때문에, 전 세계 개발자들의 지속적인 참여로 끊임없는 업그레이드가 이루어진다.2 이러한 협력적인 개발 모델은 리눅스의 강력한 보안 기능과 PC용 OS보다 뛰어난 안정성을 담보하는 근본적인 원동력이 된다.1 또한, 무료로 사용할 수 있다는 점은 기업들이 리눅스를 광범위하게 채택하고 많은 사람들이 리눅스를 배우려는 중요한 이유가 된다.1


리눅스는 안정적이며 안전한 운영체제이다.2 오픈소스 특성 덕분에 지속적인 업그레이드가 이루어지며, 이는 시스템의 안정성과 보안을 더욱 강화한다.1 리눅스는 명령어 라인(Command Line Interface, CLI)을 통해 컴퓨터에 직접 접근하므로, 운영체제의 작동 방식을 학습하는 데 매우 효과적이다.2

리눅스의 주요 장점은 다음과 같다. 유닉스와 완벽하게 호환되며 3, 공개 운영체제로서 무료로 사용 가능하다.1 PC용 운영체제보다 안정적이며 강력한 보안 기능을 제공한다.1 또한, 인터넷의 모든 기능을 지원하고 개발 환경이 풍부하여 다양한 개발 작업을 수행하기에 적합하다.1 모든 소스가 오픈되어 있어 광범위하게 사용되며, 다중 사용자 및 다중 작업을 지원하므로 서버 운영에 특히 적합하다.1 이러한 특성들로 인해 리눅스는 기업에서 많이 사용되고 있으며, 많은 이들이 학습하려는 대상이 된다.1


리눅스는 유닉스와 완벽하게 호환되는 운영체제이다.3 이는 리눅스가 유닉스의 견고한 아키텍처와 철학을 계승했음을 의미하며, 서버 환경에서 리눅스가 강력한 입지를 구축하는 데 중요한 역할을 한다. 유닉스처럼 다중 사용자 및 다중 작업을 지원하며 서버 작동에 최적화된 설계는 리눅스가 엔터프라이즈 서버 시장에서 지배적인 위치를 차지하는 핵심적인 배경이다.1 데스크톱 시장에서의 위치와는 별개로, 이러한 본질적인 능력과 유닉스와의 호환성은 리눅스가 서버 운영에 필수적인 선택이 되게 한다.

리눅스를 기반으로 300가지가 넘는 배포판이 개발되었는데, 대표적으로 RedHat, Ubuntu, Debian, Fedora 등이 있다.2 각 배포판은 고유한 특징과 강점을 가지며, 사용자의 필요에 따라 선택이 달라진다.

- **CentOS:** Red Hat Enterprise Linux(RHEL)를 지연 반영하는 형태로, 매우 높은 안정성을 자랑한다.4 그러나 버그 패치 또한 지연 반영되는 단점이 있다.4 RPM(Redhat Package Manager)을 이용하여 패키지 설치 및 제거가 쉽지만, 때로는 의존성 패키지 문제를 유발하기도 한다.4 RHEL의 기조를 따라 밸런스 있는 발전 속도와 혁신을 추구하지만, 기술 지원을 받기 어렵다는 점이 있다.4
- **Ubuntu:** LTS(Long Term Support) 버전을 통해 장기 지원을 제공하며, 동시에 새로운 시도를 하는 일반 버전도 지원한다.4 다수의 사용자 커뮤니티를 확보하고 있으며, 데비안(Debian) 기반으로 높은 신뢰도를 가진다.4 빠른 버그 수정 및 대응이 강점이며, 캐노니컬(Canonical)의 영업력 덕분에 높은 하드웨어 호환율을 자랑한다.4 넓은 사용자층을 가지고 있어 초보 리눅스 사용자들이 접근하기 쉬운 운영체제이며, 데스크톱용 리눅스 배포판 중 가장 많이 사용된다.3 그러나 서버 시장 점유율은 CentOS에 비해 밀리는 경향이 있다.3

배포판 선택은 안정성과 빠른 변화 사이의 중요한 균형점을 찾는 과정이다. CentOS는 절대적인 안정성과 보수적인 업데이트 주기를 선호하는 사용자에게 적합하며, 이는 미션 크리티컬한 프로덕션 서버 환경에 유리하다. 반면, Ubuntu는 더 빠른 개발 주기, 활발한 커뮤니티 지원, 신속한 버그 수정을 선호하는 사용자에게 적합하며, 개발 환경이나 개인 데스크톱 사용에 더 유리하다. 이러한 차이점은 특정 사용 사례에 따라 최적의 배포판이 달라질 수 있음을 의미한다.

**표: 주요 리눅스 배포판 비교**

| 배포판 (Distribution) | 기반 (Base) | 특징 (Characteristics)                      | 장점 (Pros)                                         | 단점 (Cons)                      | 주요 용도 (Primary Use Case)   |
| --------------------- | ----------- | ------------------------------------------- | --------------------------------------------------- | -------------------------------- | ------------------------------ |
| CentOS                | RHEL        | 안정성 높음, RPM 사용                       | 높은 안정성, 쉬운 설치/제거                         | 버그 패치 지연, 기술 지원 어려움 | 서버, 기업 환경                |
| Ubuntu                | Debian      | LTS 및 일반 버전 동시 지원, 대규모 커뮤니티 | 빠른 버그 수정, 높은 하드웨어 호환율, 초보자 친화적 | 서버 시장 점유율 낮음            | 데스크톱, 개발 환경, 개인 서버 |


리눅스 운영체제의 핵심 구성 요소인 커널과 쉘의 역할과 기능을 심층적으로 탐구한다. 이들이 어떻게 하드웨어와 상호작용하고, 사용자 명령을 처리하는지 이해하는 것은 리눅스 시스템 작동 방식을 파악하는 데 필수적이다.


커널은 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 사이의 인터페이스 역할을 한다.3 하드웨어 리소스를 효율적으로 사용하고 소프트웨어 애플리케이션의 실행을 지원하는 중추적인 역할을 담당한다.5 커널은 필요에 따라 동적으로 로드하거나 언로드할 수 있는 다양한 모듈과 함께 작동하여 리눅스 시스템의 유연성을 높인다.5

커널은 시스템의 안정성과 보안을 위한 가장 근본적인 요소이다. 사용자 공간에서 실행되는 프로그램들은 하드웨어나 핵심 시스템 자원에 직접 접근이 제한된다.6 하드웨어와의 모든 상호작용은 커널을 통해 간접적으로 진행되며, 각 프로그램은 독립된 메모리 영역을 할당받아 메모리 보호가 이루어진다.6 이러한 중앙 집중적인 자원 관리 및 접근 제어 역할은 리눅스가 안정적이고 안전한 운영체제라는 평가를 받는 직접적인 이유이다.1 커널이 손상되거나 불안정하면 다른 어떤 계층의 보안이나 안정성도 의미가 없어진다.

커널의 주요 기능은 다음과 같다.

- **프로세스 관리:** 시스템에서 실행 중인 모든 프로세스를 관리한다.3 프로세스 스케줄링, 생성 및 종료, 프로세스 간 통신(IPC) 등의 기능이 포함된다.5 사용자가 동시에 두 개 이상의 프로그램을 실행하는 경우, 커널은 프로세스 스케줄러를 사용하여 각 프로그램에 적절한 CPU 시간을 할당하고 어떤 프로세스를 일시 중지할지 등을 결정한다.5
- **메모리 관리:** 실제 메모리 및 가상 메모리 관리, 스왑 공간 관리 등을 담당한다.3 프로그램 실행 시 필요한 메모리를 할당하고, RAM이 부족할 경우 스왑 공간(디스크의 일부)을 사용하여 메모리를 확장한다.5
- **장치 드라이버:** 하드웨어와 상호 작용하는 다양한 장치 드라이버를 포함한다.5 이 드라이버들은 특정 하드웨어 장치를 제어하고 운영체제와의 통신을 중개한다.5 예를 들어, USB 메모리 스틱을 컴퓨터에 연결하면 커널은 해당 장치와 통신이 가능하도록 적절한 드라이버를 로드한다.5
- **시스템 호출 인터페이스:** 사용자 공간에서 실행되는 프로그램이 커널의 기능을 요청하기 위해 사용하는 인터페이스이다.5 프로그램이 파일을 저장할 때 'write()' 시스템 호출을 통해 커널에 파일 쓰기 요청을 시도하는 것이 그 예이다.5
- **네트워크 관리:** 네트워크 패킷의 전송과 수신, 프로토콜 스택 처리, 네트워크 상태 모니터링 등을 담당한다.3 사용자가 웹 브라우저로 웹사이트를 방문할 때 커널은 TCP/IP 프로토콜 스택을 통해 패킷을 전송하고 수신한다.5
- **파일 시스템 관리:** 파일과 디렉터리를 관리하고 파일 저장, 검색, 수정, 삭제와 같은 파일 시스템 작업을 처리한다.3 사용자가 파일을 열 때, 커널은 파일 시스템을 검색하여 해당 파일의 데이터를 읽는다.5


쉘은 운영체제의 핵심인 커널과 사용자를 이어주는 명령어 해석기(시스템 프로그램)이다.3 커널은 사용자와의 상호작용을 직접 지원하지 않기 때문에, 사용자와 직접적인 상호작용을 위해 쉘과 같은 시스템 프로그램이 필요하다.7 쉘은 사용자가 컴퓨터에게 전달하는 명령을 해석하여 커널에 전달하고, 커널의 응답을 사용자에게 보여줌으로써 사용자와의 직접적인 상호작용을 가능하게 한다.3

쉘은 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리가 가능하다.3 쉘은 파이프라인 기능을 지원하고 입출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.3 또한, 사용자가 직접 만든 쉘을 사용할 수도 있어 시스템과의 상호작용에 있어 높은 유연성과 제어권을 제공한다.3 이러한 커널과 쉘의 명확한 분리 아키텍처는 유닉스 계열 시스템의 핵심 설계 철학 중 하나이며, 사용자가 다양한 쉘을 통해 시스템과 상호작용하고, 환경을 맞춤 설정하며, 명령어를 조합할 수 있도록 하여 리눅스 시스템의 강력한 특징 중 하나로 작용한다.

**표: 커널과 쉘의 주요 기능 비교**

| 구성 요소 (Component) | 역할 (Role)                                       | 주요 기능 (Key Functions)                                    | 상호작용 방식 (Interaction Method)                           |
| --------------------- | ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 커널 (Kernel)         | 운영체제의 핵심, 하드웨어와 소프트웨어 인터페이스 | 프로세스 관리, 메모리 관리, 장치 드라이버, 시스템 호출 인터페이스, 네트워크 관리, 파일 시스템 관리 | 사용자 직접 상호작용 없음, 프로그램의 요청을 간접적으로 처리 |
| 쉘 (Shell)            | 사용자와 커널 간의 명령어 해석기                  | 사용자 명령 해석 및 전달, 커널 응답 표시, 파이프라인, 입출력 재지정, 사용자 정의 쉘 지원 | 사용자와 직접 상호작용 (명령어 입력 및 결과 출력)            |


리눅스 시스템의 파일 및 디렉토리 구조를 이해하는 것은 시스템을 효율적으로 관리하고 사용하는 데 필수적이다. 파일 시스템 계층 구조 표준(FHS)을 중심으로 각 디렉토리의 용도와 저장 장치 마운트 개념을 설명한다.


FHS(Filesystem Hierarchy Standard)는 리눅스와 같은 UNIX 기반 운영체제에서 파일 시스템 구조를 표준화하기 위한 규약이다.6 이 표준의 주 목적은 다양한 소프트웨어, 패키지, 그리고 배포판 간의 호환성을 증진하고, 사용자와 개발자 모두에게 일관된 파일 시스템 경로를 제공하는 것이다.6 FHS는 단순한 파일 정리 이상의 의미를 가진다. 표준이 없다면 모든 애플리케이션은 경로를 하드코딩해야 하여 파편화와 비호환성을 초래할 것이다. FHS는 한 배포판에서 작성된 애플리케이션이 다른 배포판에서도 대부분 작동하도록 허용하여, 방대한 리눅스 소프트웨어 생태계의 핵심적인 활성화 요소이자 개발의 협력적이고 다양한 특성을 촉진하는 숨은 공신이다.

FHS는 BSD 파일 시스템과 비교하여 몇 가지 차이점을 보인다.6 예를 들어, FHS는 `/bin`, `/sbin`, `/lib`, `/usr`, `/var` 등의 디렉토리를 포함하여 시스템 기본 도구, 라이브러리, 사용자 프로그램, 가변 데이터 등을 저장하는 반면, BSD는 `/usr/local`, `/usr/share`, `/usr/src` 등의 구조를 채택하여 `/usr` 아래에 대부분의 시스템 관련 파일들이 저장된다.6 또한, 로컬 설치의 위치나 시스템 구성 파일 관리 방식에서도 차이가 있다.6


리눅스 시스템은 다양한 디렉토리들로 구성되어 있으며, 각각의 디렉토리는 특정한 목적을 위해 설계되었다.6 이러한 구조를 이해하면 리눅스 시스템의 작동 방식을 더 쉽게 파악할 수 있다.6

- `/` (루트): 모든 디렉토리의 '시작점'이자 리눅스 전체 파일 시스템의 최상위 디렉토리이다.6 모든 파일과 디렉토리는 루트에서 시작되므로, 파일이나 디렉토리의 위치를 정확하게 알려면 루트 디렉토리의 구조를 이해해야 한다.6

- `/bin` & `/sbin`: 리눅스 핵심 명령어의 실행 파일이 위치한다.8

  `/bin`에는 일반 사용자가 사용하는 기본적인 시스템 명령어(예: `cat`, `chmod`)가, `/sbin`에는 시스템 관리자(root)만 사용하는 명령어(예: `reboot`, `ifconfig`)가 들어있다.6 이 명령어들은 리눅스 사용의 기본이 된다.6

- `/boot`: 리눅스가 컴퓨터를 시작할 때 필요한 파일들(예: 부트로더 설정 파일, 커널 이미지)이 위치한다.6 컴퓨터를 안정적으로 시작하기 위해 이곳의 파일들이 잘 작동해야 한다.6

- `/dev`: 컴퓨터의 모든 하드웨어 장치가 파일 형태로 위치하는 디바이스 디렉토리이다.6 USB 메모리, 외부 하드 드라이브 같은 장치 연결 시 이곳에서 장치를 확인하고 관리가 가능하다.6 리눅스는 하드웨어를 파일과 유사한 엔티티로 추상화한다. 이는 개발자들이 복잡하고 장치별로 다른 하드웨어 호출 대신 표준 파일 I/O 작업(읽기, 쓰기)을 사용하여 장치와 상호작용할 수 있도록 단순화한다. 이러한 추상화 계층은 리눅스의 다양한 하드웨어 아키텍처에 대한 이식성에 크게 기여한다.

- `/etc`: 리눅스 시스템에서 가장 중요한 디렉토리 중 하나로, 시스템 중요 환경 설정 파일, 서버 프로그램 설정 파일, 시스템 초기화 스크립트 등이 저장된다.8

- `/home`: 각 사용자의 개인 파일과 설정이 저장되는 공간으로, 각 사용자마다 `/home/사용자 이름` 형식의 디렉토리가 제공된다.6 개인 데이터나 설정을 찾을 때 유용하다.6

- `/lib`: `/bin`, `/sbin`에 있는 프로그램들이 의존하는 라이브러리 파일들이 위치한다.8

- `/media`: USB 메모리나 CD/DVD-ROM 같은 탈부착이 가능한 저장 장치가 자동으로 마운트될 때 마운트 지점을 제공한다.8

- `/opt`: 추가적인 소프트웨어나 패키지가 설치되는 위치이다.6 새로운 프로그램을 설치했을 때, 파일 확인이 가능하다.6

- `/proc`: 커널이 사용하는 가상의 파일 시스템으로, 메모리, CPU 같은 시스템 자원 관련 정보, 실행 중인 프로세스 관련 정보, 커널 관련 정보 등이 저장된다.8

- `/root`: 루트 계정의 홈 디렉토리이다.8

- `/tmp`: 임시로 사용되는 파일들이 저장되는 곳으로, 컴퓨터 재시작 시 파일들이 삭제된다.6 일시적인 파일 저장이 필요할 때 활용되지만 중요한 파일은 저장되지 않아야 한다.6

- `/usr`: 시스템 전체에서 공유하는 소프트웨어와 관련 파일들이 저장되는 위치이다.6 설치된 프로그램 대부분이 이 디렉토리에 위치하며, 프로그램 관련 파일을 찾을 때 유용하다 (

  `/usr/bin`, `/usr/sbin`, `/usr/include`, `/usr/lib` 포함).8

- `/var`: 시스템 운영 중에 필요한 가변 자료들(로그, 스풀 디렉토리, 임시 파일 등)이 주로 저장된다.6 시스템에서 무슨 일이 발생했는지 로그를 통해 확인이 가능하여 문제 해결에 유용하다.6 메일 서버, 웹 서버, FTP 서버 운영 시 해당 하위 디렉토리에 사용자 메일박스, 웹 콘텐츠, 공유 파일을 기록하기 위해 사용된다.8

  `/var` 디렉토리는 단순히 데이터를 저장하는 공간을 넘어 시스템 관리 및 문제 해결과 직접적으로 연결되는 중요한 허브이다. 로그와 같은 동적이고 가변적인 데이터의 존재는 감사, 디버깅, 시스템 동작 이해에 필수적이며, 이는 `/var`를 모든 관리자에게 매우 중요한 디렉토리로 만든다.

**표: 리눅스 파일 시스템 계층 구조 (FHS)**

| 디렉토리 (Directory) | 용도 (Purpose)                                   | 주요 내용 (Key Contents)                         | 예시 (Example)                      |
| -------------------- | ------------------------------------------------ | ------------------------------------------------ | ----------------------------------- |
| `/` (루트)           | 모든 디렉토리의 시작점, 파일 시스템 최상위       | 모든 파일과 디렉토리의 시작점                    | `/home`, `/etc` 등 모든 경로의 시작 |
| `/bin`               | 기본적인 사용자 명령어 실행 파일                 | `cat`, `chmod`, `ls`                             | `/bin/ls`                           |
| `/sbin`              | 시스템 관리자(root) 전용 명령어 실행 파일        | `reboot`, `ifconfig`, `shutdown`                 | `/sbin/reboot`                      |
| `/boot`              | 리눅스 부팅에 필요한 파일                        | 부트로더 설정, 커널 이미지                       | `grub.conf`, `vmlinuz`              |
| `/dev`               | 하드웨어 장치 파일                               | USB, 하드 드라이브, 가상 콘솔                    | `/dev/sda1`, `/dev/tty1`            |
| `/etc`               | 시스템 환경 설정 파일                            | 시스템 설정, 서버 프로그램 설정, 초기화 스크립트 | `/etc/passwd`, `/etc/fstab`         |
| `/home`              | 각 사용자의 개인 파일 및 설정                    | 사용자별 홈 디렉토리                             | `/home/user1`, `/home/user2`        |
| `/lib`               | 핵심 프로그램이 의존하는 라이브러리 파일         | 공유 라이브러리                                  | `libc.so.6`                         |
| `/media`             | 탈부착 저장 장치 자동 마운트 지점                | USB, CD/DVD-ROM 마운트                           | `/media/usbdisk`                    |
| `/opt`               | 추가 소프트웨어 및 패키지 설치 위치              | 서드파티 애플리케이션                            | `/opt/google/chrome`                |
| `/proc`              | 커널이 사용하는 가상 파일 시스템                 | 시스템 자원, 프로세스, 커널 정보                 | `/proc/cpuinfo`, `/proc/meminfo`    |
| `/root`              | 루트(root) 계정의 홈 디렉토리                    | 루트 사용자의 개인 파일 및 설정                  | `/root/.bashrc`                     |
| `/tmp`               | 임시 파일 저장 공간                              | 임시 파일 (재시작 시 삭제)                       | `/tmp/tempfile.txt`                 |
| `/usr`               | 시스템 전체에서 공유하는 소프트웨어 및 관련 파일 | 설치된 프로그램, 매뉴얼 페이지                   | `/usr/bin`, `/usr/share/man`        |
| `/var`               | 시스템 운영 중 필요한 가변 자료                  | 시스템 로그, 스풀, 웹 서버 데이터                | `/var/log`, `/var/www`              |


**마운트(mount)**는 저장 장치를 사용하기 위해 해당 장비를 파일 시스템 트리에 부착하는 것을 의미한다.8 이를 통해 운영체제가 해당 장비를 인식하고 접근할 수 있게 된다.8 마운트 지점은 장비가 마운트되는 위치로, 트리 구조에서 하나의 디렉토리에 해당한다.8

리눅스에서 `/dev` 디렉토리 안에는 많은 장치 파일들이 존재하며, 각 장치에는 특정한 이름 패턴이 부여된다.8

- IDE 디스크: `/dev/hda` (첫 번째 디스크 마스터), `/dev/hdb` (첫 번째 디스크 슬레이브)와 같이 이름이 정해진다. 파티션은 `hda1`, `hda2`와 같이 숫자가 붙는다.8
- SCSI 디스크: `/dev/sd*` (예: `sda`, `sdb`)와 같이 이름이 정해진다. 파티션은 `sda1`, `sda2`와 같이 숫자가 붙는다.8
- 가상 콘솔: `/dev/tty1`, `/dev/tty2` 등으로 표시된다.8
- 가상 터미널 장치: `/dev/pts/0`, `/dev/pts/1` 등으로 표시된다.8
- 편의를 위해 `/dev/cdrom`, `/dev/dvd`와 같은 심볼릭 링크도 자주 사용된다.8

이러한 장치별 이름 패턴을 알면 `/dev` 디렉토리 하위의 장치 파일들이 대략 어떤 장치인지 구분할 수 있다.8


리눅스 운영체제와 상호작용하는 가장 기본적인 방법은 명령줄 인터페이스(CLI)를 사용하는 것이다.2 이 섹션에서는 파일 및 디렉토리 관리, 입출력 제어, 그리고 명령어 활용의 효율성을 높이는 핵심 명령어들을 학습한다. CLI는 그래픽 사용자 인터페이스(GUI)가 제공할 수 없는 정밀성, 스크립팅, 자동화 기능을 제공하며, 이는 서버 관리 및 복잡한 작업을 위해 필수적인 인터페이스이다.


- `cd` (change directory): 디렉토리 간 이동에 사용한다.9

  - `cd [이동할 디렉토리명]`: 특정 디렉토리로 이동한다.9
  - `cd..`: 상위 디렉토리로 이동한다.10
  - `cd -`: 바로 이전 디렉토리로 이동한다.10
  - `cd ~`: 홈 디렉토리로 이동한다.10

- `pwd` (print working directory): 현재 작업 중인 디렉토리의 절대 경로를 출력한다.9

- `ls` (list): 현재 디렉토리의 목록을 출력한다.9

  - `-a`, `--all`: 숨겨진 파일의 목록까지 출력한다.9
  - `-l`: 파일에 대한 정보를 자세히 출력한다 (권한, 소유자, 그룹, 크기, 수정 시간 등).9
  - `-R`: 하위 디렉토리의 내용까지 재귀적으로 출력한다.9
  - `-h`: 사람이 이해하기 쉽도록 파일의 크기를 출력한다 (예: 1K, 234M).9
  - `-k`: KB 단위로 파일의 크기를 출력한다.9
  - `-i`: 파일의 inode 번호(고유번호)를 같이 출력한다.9

- `mkdir` (make directory): 지정한 디렉토리를 생성한다.9

  `-p` 옵션을 사용하면 필요하다면 생성하고자 하는 상위 디렉토리까지 함께 생성한다.9

- `rmdir` (remove directory): 지정한 디렉토리를 삭제한다.9 디렉토리가 비워져 있는 경우에만 삭제 가능하다.9

- `rm` (remove): 지정한 파일을 삭제한다.9

- `cp` (copy): 파일을 복사한다.9

- `mv` (move): 파일을 이동하거나 이름을 변경한다.9

- `cat` (concatenate): 파일의 내용을 출력하거나, 여러 파일을 연결하여 출력한다.9 파일의 입출력을 제어하는 데도 사용한다.9

  - `-n`: 행 단위 번호를 붙여 출력한다.9
  - `-b`: 공백 라인을 제외하고 행 단위 번호를 붙여 출력한다.9
  - 기본 입력 파일은 키보드, 기본 출력 파일은 화면(CRT)이다.9

- `touch`: 파일이 존재하지 않으면 새로운 빈 파일을 생성하고, 이미 존재하는 파일이라면 타임스탬프(수정 시간)를 변경한다.10

- `echo`: 환경 변수나 입력 내용을 화면에 출력한다.9 리다이렉션을 이용하면 파일을 생성할 수도 있다.9


리다이렉션과 파이핑은 유닉스 철학의 핵심적인 부분이다. 이는 사용자가 간단한 명령어를 복잡한 워크플로우로 조합할 수 있게 하여, 한 명령어의 출력이 다른 명령어의 입력이 되도록 한다. 이러한 모듈성과 조합 가능성은 리눅스 CLI가 데이터 처리 및 자동화에 있어 강력하고 유연한 이유를 설명한다.

- `>`: 표준 출력 지시자로, 명령어의 결과를 파일로 저장한다.9 기존 파일이 있다면 내용을 덮어쓴다.9 (예:  `command > 파일`)

- `>>`: 추가 표준 출력 지시자로, 명령어의 결과를 기존 파일에 추가한다.9 (예:  `command >> 파일`)

- `<`: 표준 입력 지시자로, 파일의 내용을 명령어의 입력 값으로 사용한다.9 (예:  `command < 파일`)


- `history`: 이전에 실행한 모든 명령어를 보여준다.10

- 방향키(위/아래): 이전에 실행한 명령어를 다시 불러와 실행할 수 있다.10

- Tab 키: 명령어 또는 파일 이름 자동 완성 기능을 제공하여 입력 시간을 단축하고 오타를 줄인다.10

  `history`와 `tab` 자동 완성 기능은 CLI의 효율성을 더욱 높인다.


`sudo` (superuser do) 명령어는 일반 사용자가 관리자(root) 권한으로 명령을 실행할 수 있도록 한다.10 이는 `sudo`가 단순히 편의성을 넘어선 중요한 보안 기능임을 강조한다. 위험한 root 계정으로 직접 로그인하는 대신, `sudo`는 특정 사용자에게 특정 명령어를 root 권한으로 일시적으로 실행할 수 있도록 허용한다.12 이는 공격 표면을 최소화하고 최소 권한의 원칙을 강제하여, 안전한 시스템 관리의 초석이 된다.

**표: 리눅스 기본 명령어 요약**

| 명령어 (Command) | 기능 (Function)                   | 주요 옵션 (Key Options)                                      | 예시 (Example)                                     |
| ---------------- | --------------------------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| `cd`             | 디렉토리 이동                     | `..` (상위), `-` (이전), `~` (홈)                            | `cd /home/user`, `cd..`                            |
| `pwd`            | 현재 작업 디렉토리 출력           | 없음                                                         | `pwd`                                              |
| `ls`             | 디렉토리 내용 목록 출력           | `-a` (숨김 파일), `-l` (상세), `-R` (하위), `-h` (읽기 쉬운 크기) | `ls -al`, `ls -R /var/log`                         |
| `mkdir`          | 디렉토리 생성                     | `-p` (상위 디렉토리 함께 생성)                               | `mkdir mydir`, `mkdir -p /a/b/c`                   |
| `rmdir`          | 빈 디렉토리 삭제                  | 없음                                                         | `rmdir emptydir`                                   |
| `rm`             | 파일 또는 디렉토리 삭제           | `-r` (디렉토리 재귀 삭제), `-f` (강제 삭제)                  | `rm myfile.txt`, `rm -rf mydir`                    |
| `cp`             | 파일/디렉토리 복사                | `-r` (디렉토리 재귀 복사)                                    | `cp file1.txt file2.txt`, `cp -r dir1 dir2`        |
| `mv`             | 파일/디렉토리 이동 또는 이름 변경 | 없음                                                         | `mv oldname.txt newname.txt`, `mv file.txt /tmp`   |
| `cat`            | 파일 내용 출력/연결               | `-n` (행 번호), `-b` (공백 제외 행 번호)                     | `cat myfile.txt`, `cat file1 file2 > combined.txt` |
| `touch`          | 빈 파일 생성/타임스탬프 변경      | 없음                                                         | `touch newfile.txt`                                |
| `echo`           | 문자열/환경 변수 출력             | 없음                                                         | `echo "Hello, Linux!"`, `echo $HOME`               |
| `history`        | 명령어 이력 출력                  | 없음                                                         | `history`                                          |
| `sudo`           | 관리자 권한으로 명령어 실행       | 없음                                                         | `sudo apt update`                                  |


리눅스 시스템에서 파일과 디렉토리의 접근 권한을 이해하고 관리하는 것은 보안과 시스템 안정성을 위해 매우 중요하다. 이 섹션에서는 권한의 의미, 변경 방법, 그리고 소유권 관리 및 특수 권한에 대해 학습한다.


리눅스 파일 및 디렉토리 권한은 읽기(read, `r`), 쓰기(write, `w`), 실행(execute, `x`)으로 구성된다.13 각 권한은 숫자 값으로 표현될 수 있다: 

`r`은 4, `w`는 2, `x`는 1이다.13 이 값들을 합산하여 8진수 형태로 권한을 지정할 수 있다 (예: `rwx` = 4+2+1=7).13

- **파일 권한:**
  - 읽기(`r`): 파일을 열어볼 수 있고, 파일의 수정은 불가능하나 복사는 가능하다.14
  - 쓰기(`w`): 파일에 내용을 덧붙여 쓸 수 있으며, 읽기 권한과 함께 있다면 파일 편집이 가능하다.14 읽기 권한 없이 쓰기 권한만 있다면 기존 파일 뒤에 정보를 덧붙이는 것만 가능하다.14
  - 실행(`x`): 파일을 실행할 수 있다.14
- **디렉토리 권한:**
  - 읽기(`r`): 디렉토리에 저장된 항목(파일/하위 디렉토리 이름)을 조회할 수 있다.14
  - 쓰기(`w`): 디렉토리 내에서 파일을 수정, 생성, 삭제하는 것이 가능하다.14
  - 실행(`x`): 디렉토리로 접근(`cd`)하는 것이 가능하다.14 실행 권한이 없다면 디렉토리 내 파일 목록을 볼 수 없어도 정확한 경로와 이름을 알고 있다면 파일 조회는 가능하다.14 디렉토리에 쓰기 권한만 부여한 경우는 아무 권한도 부여하지 않은 상태와 동일하다.14

`ls -l` 명령어를 사용하면 9글자의 권한 정보(소유자, 그룹, 기타 사용자 순서)와 함께 링크 수, 사용자(소유자), 그룹, 파일 크기, 수정 시간, 파일 이름을 확인할 수 있다.14 새로 생성되는 파일과 디렉토리의 기본 권한은 각각 `644`와 `755`로 정해져 있으며, 이는 `umask` 값에 의해 설정된다. `umask`는 `/etc/login.defs`에서 확인 및 변경 가능하다.13


`chmod` 명령어는 파일/디렉토리의 권한을 변경하는 데 사용한다.13

- **심볼릭 모드:** `u` (소유자), `g` (그룹), `o` (기타 사용자), `a` (모두)를 사용하여 권한을 추가(`+`), 제거(`-`), 설정(`=`)할 수 있다.13
  - 예시:
    - `chmod g+x [파일명]`: 그룹에 실행 권한을 준다.14
    - `chmod o-w [파일명]`: 다른 사용자에게 쓰기 권한을 제거한다.14
    - `chmod a=rw [파일명]`: 모든 사용자에게 읽기, 쓰기 권한을 지정한다.14
    - `chmod u+x /babo/babo1/a.txt`: 소유주에게 실행 권한을 추가한다.13
    - `chmod a+x /babo/babo1/a.txt`: 모든 사용자에게 실행 권한을 추가한다.13
- **8진수(숫자) 모드:** 각 권한의 숫자 값을 합산하여 8진수 형태로 권한을 지정한다.13
  - 예시:
    - `chmod 755 [파일명]`: 소유자에게 읽기/쓰기/실행(7), 그룹과 기타 사용자에게 읽기/실행(5) 권한을 부여한다.
    - `chmod 644 [파일명]`: 소유자에게 읽기/쓰기(6), 그룹과 기타 사용자에게 읽기(4) 권한을 부여한다.
- `-R` 옵션: 하위 디렉토리와 그 안의 파일 권한까지 모두 변경할 때 사용한다.13


`chown`과 `chgrp` 명령어는 파일이나 디렉토리의 소유권(사용자 소유권 및 그룹 소유권)을 변경할 때 사용한다.14 일반적으로 `sudo` 명령과 함께 사용해야 한다.14

- `chown [사용자명][파일명/디렉토리명]`: 파일의 사용자 소유권을 변경한다.13
  - 예시: `sudo chown user1 [파일명]`: 파일 사용자를 `user1`으로 변경한다.14
- `chgrp [그룹명][파일명/디렉토리명]`: 파일의 그룹 소유권을 변경한다.14
  - 예시: `sudo chgrp user2 [파일명]`: 파일 그룹을 `user2`으로 변경한다.14
- `chown [사용자명].[그룹명][파일명/디렉토리명]`: `chown` 명령어를 통해 사용자와 그룹을 동시에 변경할 수 있다.13
  - 예시: `sudo chown user3.user3 [파일명]`: 파일의 사용자 및 그룹을 `user3`으로 변경한다.14
- `-R` 옵션: 하위 디렉토리와 그 안의 파일 소유권까지 재귀적으로 변경할 때 사용한다.14


리눅스에는 일반적인 `rwx` 권한 외에 특별한 동작을 수행하는 특수 권한이 있다.13

- **SetUID (SUID):** 8진수 4000으로 표현된다. 이 권한이 설정된 파일을 실행하는 동안은 해당 파일의 소유주 권한으로 실행된다.13 예를 들어, 일반 사용자가 

  `passwd` 명령어를 실행하여 자신의 비밀번호를 변경할 수 있는 것은 `passwd` 파일에 SetUID가 설정되어 있기 때문이다.

- **SetGID (SGID):** 8진수 2000으로 표현된다. 이 권한이 설정된 파일을 실행하는 동안은 해당 파일의 그룹 권한으로 실행된다.13 디렉토리에 SetGID가 설정되면, 해당 디렉토리 내에 새로 생성되는 파일이나 디렉토리는 부모 디렉토리의 그룹을 상속받는다.

- **Sticky Bit:** 8진수 1000으로 표현된다. 디렉토리에 이 권한이 설정되면, 해당 디렉토리 내의 파일은 소유자(또는 root)만 삭제하거나 이름을 변경할 수 있다.13 대표적인 예로는 

  `/tmp` 디렉토리가 있다.13

  `/tmp`는 모든 사용자가 파일을 생성할 수 있지만, 다른 사용자가 생성한 파일을 삭제할 수는 없도록 Sticky Bit이 설정되어 있다.

`ls -l` 출력에서 SetUID는 소유자의 실행 권한 자리에 `s`로, SetGID는 그룹의 실행 권한 자리에 `s`로 표시된다.13 Sticky Bit은 기타 사용자의 실행 권한 자리에 `t`로 표시된다.13


리눅스 시스템은 다중 사용자 시스템이므로, 사용자 계정과 그룹을 효율적으로 관리하는 것이 중요하다. 이 섹션에서는 사용자 및 그룹 생성, 속성 변경, 삭제 방법을 학습한다.


- **사용자 계정 생성:** `useradd` 명령어를 사용하여 새로운 사용자 계정을 생성한다.12
  - `sudo useradd [사용자명]`: 새로운 사용자 계정을 생성한다.12
  - `useradd` 명령어에는 다양한 옵션이 있다 16:
    - `-d [홈디렉토리]`: 홈 디렉토리의 경로를 지정한다. 홈 디렉토리를 생성하려면 `-m` 옵션을 함께 사용한다.16
    - `-u`: 사용자 고유 식별자(UID)를 지정한다.16
    - `-g`: 주 그룹(GID)을 지정한다.16
    - `-G [그룹1,그룹2,...]`: 보조 그룹을 지정한다.16
    - `-s [쉘]`: 로그인 쉘을 지정한다.16
    - `-c [주석]`: 계정에 설명을 추가한다.16
- **비밀번호 설정:** `passwd` 명령어를 사용하여 생성된 계정의 비밀번호를 설정하거나 기존 비밀번호를 변경한다.12
  - `sudo passwd [사용자명]`: 지정된 사용자 계정의 비밀번호를 설정하거나 변경한다.12

리눅스 시스템은 사용자 계정 정보를 `/etc/passwd` 파일에 저장한다.12 이 파일은 사용자 계정, 암호(암호화되어 'x'로 표시되며 실제 암호는 `/etc/shadow`에 저장), 사용자 식별자(UID), 그룹 식별자(GID), 주석, 홈 디렉토리, 로그인 쉘 등의 정보를 포함한다.12 UID는 사용자를 식별하는 고유 번호로, UID 0은 관리자 계정(root), 1~999(또는 65534~)는 시스템 사용자, 1000~65535는 일반 사용자를 나타낸다.12


`usermod` 명령어는 기존 사용자 계정의 속성을 수정하는 데 사용한다.12

`sudo` 액세스 권한이 있는 루트 또는 사용자만 `usermod`를 호출하여 사용자 계정을 수정할 수 있다.17

- `sudo usermod -a -G [그룹명][사용자명]`: 사용자를 보조 그룹에 추가한다.12 여러 그룹에 동시에 추가하려면 공백 없이 

  `-G` 옵션 뒤에 그룹들을 지정한다.17

  `-a`(추가) 옵션을 생략하면 사용자가 해당 명령에 나열되지 않은 다른 그룹에서 제거되므로 주의해야 한다.17

- `sudo usermod -d [새_홈디렉토리][사용자명]`: 사용자의 홈 디렉토리를 변경한다.12 기본적으로 이 명령은 홈 디렉토리의 내용을 새 디렉토리로 이동하지 않는다. 내용을 이동하려면 

  `-m` 옵션을 함께 사용한다.17

- `sudo usermod -s [새_쉘][사용자명]`: 사용자의 기본 쉘을 변경한다.12 시스템에서 사용 가능한 쉘은 

  `/etc/shells` 파일에서 확인할 수 있다.17

- `sudo usermod -u[사용자명]`: 사용자의 UID를 변경한다.17

- `sudo usermod -l [새_사용자명][기존_사용자명]`: 사용자 이름을 변경한다.17 사용자 이름을 변경할 때 새 사용자 이름을 반영하도록 사용자의 홈 디렉토리를 변경할 수도 있다.17

- `sudo usermod -e[사용자명]`: 사용자의 계정 만료 날짜를 설정한다.17 계정 만료를 사용하지 않으려면 빈 만료 날짜를 설정한다.17

- `sudo usermod -L [사용자명]`: 사용자 계정을 잠근다.12 이 명령은 암호화된 암호 앞에 느낌표(!)를 삽입하여 암호 인증을 통한 로그인을 비활성화한다.17 모든 로그인 방법을 비활성화하려면 만료 날짜도 1로 설정해야 한다.17


- `sudo userdel [사용자명]`: 지정된 사용자 계정을 삭제한다.12
- `sudo userdel -r [사용자명]`: 사용자 계정과 해당 홈 디렉토리를 함께 삭제한다.


리눅스는 그룹을 통해 여러 사용자에 대한 권한을 효율적으로 관리할 수 있다. 그룹 정보는 `/etc/group` 파일에 저장된다.12

- **그룹 생성:** `groupadd` 명령어를 사용하여 새로운 그룹을 생성한다.12
  - `sudo groupadd [그룹명]`: 새로운 그룹을 생성한다.12
- **그룹 삭제:** `groupdel` 명령어를 사용하여 그룹을 삭제한다.12
  - `sudo groupdel [그룹명]`: 지정된 그룹을 삭제한다.12
- **그룹에 사용자 추가:** `usermod` 명령어를 사용하여 그룹에 사용자를 추가할 수 있다.12
  - `sudo usermod -aG [그룹명][사용자명]`: 지정된 사용자를 지정된 그룹에 추가한다.12


패키지 관리자는 리눅스 시스템에 소프트웨어를 설치, 업데이트, 제거하는 작업을 효율적으로 수행하도록 돕는 도구이다. 리눅스 배포판마다 주로 사용하는 패키지 관리자가 다르다. 데비안/우분투 계열에서는 `apt`를, CentOS/RHEL 계열에서는 `yum` 또는 `dnf`를 주로 사용한다.2


패키지 관리자는 소프트웨어의 설치, 업데이트, 제거뿐만 아니라 의존성 관리, 버전 관리 등 복잡한 작업을 자동화하여 시스템 관리의 편의성을 크게 높여준다.


`apt`는 데비안 및 우분투 기반 시스템에서 사용되는 강력한 패키지 관리 도구이다.

- `sudo apt update`: 패키지 저장소에서 패키지 목록을 새로 다운로드하여 업데이트한다.18 이는 설치 가능한 최신 패키지 정보를 가져오는 과정이다.
- `sudo apt upgrade`: 설치된 모든 패키지를 상위 버전으로 업그레이드한다.18
- `sudo apt install [패키지명]`: 새로운 패키지를 설치한다.18
- `sudo apt remove [패키지명]`: 설치된 패키지를 제거한다. 이 경우 패키지 관련 데이터는 삭제되지 않는다.18
- `sudo apt purge [패키지명]`: 패키지와 관련 데이터를 모두 삭제한다.18
- `sudo apt autoremove`: 더 이상 필요 없거나 사용하지 않는 패키지를 자동으로 삭제한다.18
- `sudo apt clean`: 패키지 설치를 위해 다운로드한 데이터(캐시)를 삭제한다.18 주기적인 사용을 권장한다.18
- `apt-cache search [검색어]`: 패키지명을 검색한다.18
- `apt-cache show [패키지명]`: 패키지의 상세한 정보를 출력한다.18


`yum`과 `dnf`는 Red Hat, CentOS, Fedora 등 RPM(Red Hat Package Manager) 기반 시스템에서 사용되는 패키지 관리 도구이다. `dnf`는 `yum`의 차세대 버전으로, 더 나은 성능과 의존성 해결 기능을 제공한다.

- **yum 사용법:**

  - `sudo yum update`: 시스템의 모든 패키지를 업데이트한다.21 특정 패키지만 업데이트하려면 

    `sudo yum install [패키지명]`을 사용한다.21

  - `sudo yum install [패키지명]`: 저장소에서 패키지를 설치한다.19 특정 아키텍처를 지정하여 설치할 수도 있다 (예: 

    `yum install sqlite.i686`).19

  - `sudo yum remove [패키지명]`: 패키지를 삭제한다.22

  - `yum install /usr/sbin/named`: 특정 명령어를 제공하는 패키지를 알 수 없을 때, 명령어 경로를 통해 패키지를 설치할 수 있다.19

  - `yum install @[그룹명]`: 그룹 ID나 그룹 이름을 이용하여 패키지 그룹을 설치할 수 있다.19

- **dnf 사용법:**

  - `sudo dnf update`: 설치된 모든 소프트웨어(및 커널)를 현재 릴리스에 대한 최신 버전으로 업데이트한다.20 Fedora와 같은 배포판은 매일 업데이트가 가능한 패키지를 자주 가지고 있다.20
  - `sudo dnf upgrade`: 주로 시스템을 다음 릴리스로 업그레이드할 때 사용한다 (예: Fedora 40 -> Fedora 41).20 이 프로세스는 새 릴리스가 발표되고 사용 가능하게 될 때, 즉 약 6개월마다 이루어진다.20
  - `sudo dnf install [패키지명]`: 패키지를 설치한다.23
  - `sudo dnf --enablerepo=[저장소명] install [패키지명]`: 특정 저장소에서 패키지를 설치할 수 있다.23


리눅스 환경에서 파일을 생성하고 수정하는 데는 다양한 텍스트 편집기가 사용된다. 그중 터미널 기반의 `nano`와 `vi/vim`은 가장 널리 사용되는 편집기이다.


`nano`는 초보자도 쉽게 사용할 수 있는 간단한 터미널 기반 텍스트 편집기이다.24

- **파일 열기 및 만들기:** `nano [파일명]` 명령어를 통해 파일을 열거나, 파일이 없으면 새로 만들어 연다.11
- **커서 이동:** 상, 하, 좌, 우 화살표 키, Home 키, End 키, PageUp 키, PageDown 키, 마우스 스크롤을 사용하여 커서를 이동할 수 있다.24
- **저장:** `Ctrl + O` 단축키를 누른 뒤 파일 이름을 수정하고 엔터를 눌러 저장할 수 있다.11
- **종료:** `Ctrl + X` 단축키를 누르면 편집기를 닫으려고 한다.11 수정 내용이 있다면 저장할 것인지 묻는 메시지가 나타난다.11
- **단어 찾기:** `Ctrl + W` (Where Is)를 누른 후 검색할 단어를 입력한다.24
- **찾아서 바꾸기:** `Ctrl + \` 단축키를 사용한다.24 바꿀 단어를 입력하고 엔터를 누르면, 하나하나 확인할 것인지(y/n) 또는 모두 바꿀 것인지(a) 묻는다.24
- **텍스트 선택, 잘라내기, 복사, 붙여넣기:**
  - 선택 블록 시작점 지정: `Alt + A` (Windows) 또는 `Esc, A` (Mac)를 누른다.24
  - 복사: `Alt + ^` (Windows) 또는 `Esc, 6` (Mac)를 누르면 선택 영역이 클립보드에 복사된다.24
  - 잘라내기: `Ctrl + K`를 누르면 선택한 텍스트 블록이 삭제된다. 선택된 블록이 없으면 커서가 위치한 줄 전체가 삭제된다.24
  - 붙여넣기: `Ctrl + U`를 누르면 클립보드 내용이 붙여넣어진다.24
- **실행 취소(Undo) 및 재실행(Redo):** `nano` 2.3.5 버전부터 지원된다.24
  - 실행 취소: `Alt + U` (Windows) 또는 `Esc + U` (Mac).24
  - 재실행: `Alt + E` (Windows) 또는 `Esc + E` (Mac).24


`vi`는 유닉스 및 리눅스 시스템에서 가장 강력하고 널리 사용되는 텍스트 편집기 중 하나이며, `vim`은 `vi`의 개선된 버전이다. `vim`은 `sudo apt -y install vim` 명령으로 설치할 수 있다.25

`vim [파일명]` 명령으로 파일을 열거나 생성한다.25

`vi/vim`은 세 가지 주요 모드를 가진다 26:

1. **명령 모드 (Normal Mode):** `vi`를 실행하면 가장 먼저 접하는 기본 모드이다.26 커서 이동, 수정, 삭제, 복사, 붙여넣기, 탐색 등의 작업을 수행한다.26 입력 모드에서 

   `Esc` 키를 누르면 명령 모드로 돌아온다.26

2. **입력 모드 (Insert Mode):** 글자를 입력하고 문서를 작성하는 모드이다.26 명령 모드에서 

   `i`, `a`, `o`, `I`, `A`, `O` 등의 키를 눌러 입력 모드로 전환한다.25

   - `i`: 현재 커서 위치에서 입력 모드로 전환.25
   - `a`: 현재 커서 위치에서 한 칸 뒤로 이동한 뒤 입력 모드로 전환.25
   - `o`: 현재 행 아래에 새로운 행을 만들고 입력 모드로 전환.25

3. **마지막 행 모드 (Last-Line Mode 또는 Ex Mode):** 명령 모드에서 콜론(`:`)을 입력하여 진입한다.26 파일 저장, 종료, 검색 및 바꾸기 등 고급 작업을 수행한다.26

**주요 vi/vim 명령어:**

- **파일 열기:**

  - `vi [파일명]`: 파일 열기 또는 생성.26
  - `vi +[행번호][파일명]`: 파일을 열고 지정한 행으로 커서를 이동한다.26
  - `view [파일명]`: 파일을 읽기 전용으로 연다.26

- **커서 이동 (명령 모드):**

  - `h, j, k, l`: 각각 왼쪽, 아래, 위, 오른쪽으로 한 문자씩 이동한다.26
  - `w, e, b`: 각각 오른쪽 한 단어의 시작, 끝, 왼쪽 한 단어의 시작으로 이동한다.26
  - `0` 또는 `^`: 행의 맨 왼쪽으로 이동한다.26
  - `$`: 행의 맨 오른쪽으로 이동한다.26
  - `H, M, L`: 화면의 맨 위, 중간, 맨 아래로 이동한다.26
  - `Ctrl + u, Ctrl + d`: 화면을 절반만큼 위/아래로 이동한다.26
  - `Ctrl + b, Ctrl + f`: 화면을 한 페이지 위/아래로 이동한다.26
  - `[#]gg`: #행으로 이동한다. # 생략 시 1행으로 이동한다.25

- **삭제 (명령 모드):**

  - `x`: 커서에 위치한 문자를 삭제한다.25
  - `dd`: 현재 행을 삭제한다.25
  - `D`: 현재 커서 위치부터 행의 끝까지 삭제한다.25
  - `:[#]d`: #번 행을 삭제한다.25
  - `:[#],[#]d`: 지정한 행의 범위를 삭제한다.25

- **복사 및 붙여넣기 (명령 모드):**

  - `yy`: 커서가 위치한 줄을 복사한다.26
  - `p`: 복사/잘라내기한 내용을 커서 아래에 붙여넣는다.26
  - `P`: 복사/잘라내기한 내용을 커서 위에 붙여넣는다.26

- **실행 취소 및 재실행 (명령 모드):**

  - `u`: 직전 명령을 취소한다 (undo).25
  - `Ctrl + R`: 직전에 취소한 명령을 재실행한다 (redo).25
  - `.` (dot): 이전 명령을 반복한다.25

- **검색 (명령 모드):**

  - `/string`: `string`을 파일 정방향으로 검색한다.25
  - `?string`: `string`을 파일 역방향으로 검색한다.25
  - `n`: 검색된 다음 문자열을 찾는다.25
  - `N`: 검색된 이전 문자열을 찾는다.25

- **저장 및 종료 (마지막 행 모드):**

  - `:w`: 변경사항을 저장한다.26

  - `:w [파일명]`: 변경사항을 지정한 파일명으로 저장한다.26

  - `:q`: 작업한 내용이 없으면 종료한다.26

  - `:wq`: 변경사항을 저장하고 `vi`를 종료한다.25

    `ZZ` 명령과 동일하다.26

  - `:q!`: 변경 내용을 저장하지 않고 강제로 종료한다.25


리눅스 시스템에서 실행 중인 프로세스를 확인하고 제어하는 것은 시스템 성능 모니터링 및 문제 해결에 필수적이다.


- `ps`: 현재 실행 중인 프로세스에 대한 정보를 정적인 스냅샷 형태로 출력한다.27
  - `-e` 또는 `-A`: 시스템의 모든 프로세스를 출력한다.27
  - `-ef` 또는 `aux`: 모든 사용자의 모든 프로세스를 자세한 형식으로 출력한다.27 UID, PID, 부모 프로세스(PPID), CPU 사용량, 시작 시간 등이 포함된다.27
  - `--forest`: 프로세스 간의 계층 구조를 트리 형식으로 출력한다.27
  - `-p`: 특정 프로세스 ID(PID)에 대한 정보를 표시한다.27
  - `-u [사용자명]`: 특정 사용자의 프로세스만 표시한다.27
- `top`: 시스템 활동을 실시간으로 확인할 수 있는 명령어이다.28 CPU 사용량, 메모리 사용량 등을 나타내주며 실시간으로 정보가 업데이트된다.29 활동 순으로 나열된 프로세스들을 지속적으로 갱신하면서 보여주며, 위쪽에는 시스템에 대한 전반적인 요약이, 아래에는 CPU를 사용하는 순으로 프로세스들이 정렬되어 표시된다.28


- `kill`: 프로세스에 시그널을 보내어 동작한다.27 기본적으로 

  `SIGTERM` 시그널을 보내어 프로세스에 종료 요청을 보낸다.27

  - `kill -9`: `SIGKILL` 시그널을 사용하여 프로세스를 강제 종료시킨다.27 좀비 프로세스나 응답 없음, 비정상적으로 동작하는 프로세스들의 실행을 끝내게 할 때 사용한다.28
  - `kill -l`: 지원되는 시그널 목록을 확인한다.27
  - 올바른 프로세스 ID(PID)를 사용하는 것이 중요하다. 잘못된 PID를 입력하면 다른 프로세스가 종료될 수 있으므로 주의해야 한다.27

- `pkill [프로세스_이름]`: 프로세스 이름으로 여러 프로세스를 종료한다.27

- `pkill -u [사용자명]`: 특정 사용자의 모든 프로세스를 종료한다.27

- `jobs`: 백그라운드 프로세스 목록을 출력한다.28

- `[명령어] &`: 명령어를 백그라운드에서 실행한다.28

- `bg`: 일시 정지된 포어그라운드 프로세스를 백그라운드로 전환한다.28

- `fg`: 백그라운드 프로세스를 포어그라운드로 전환한다.28

- `Ctrl + Z`: 포어그라운드 프로세스를 일시 정지시킨다 (`SIGTSTP` 시그널을 보낸다).28

- `Ctrl + C`: 포어그라운드 프로세스를 종료한다 (`SIGINT` 시그널을 보낸다).28


리눅스 시스템의 네트워크 상태를 확인하고 기본적인 네트워크 연결을 테스트하는 것은 시스템 관리의 중요한 부분이다.


- `ifconfig`: 네트워크 인터페이스의 설정과 상태 정보를 출력하는 가장 기본적인 명령어이다.29 IP 주소, MAC 주소, 수신/전송 패킷 수, 오류 수 등 다양한 정보를 확인할 수 있다.30

  `eth0`과 같은 인터페이스 이름과 `inet` 부분에서 IP 주소를 찾을 수 있다.30

- `hostname -I`: 다른 부가 정보 없이 간단하게 자신의 IP 주소만 확인할 수 있는 가장 간단한 방법이다.29

- `ip addr`: IP 주소를 포함하여 더 자세한 네트워크 정보를 보여준다.29

  `grep` 명령어를 함께 사용하여 IP 주소만 필터링할 수도 있다.29

- `ping [IP_주소]`: 특정 IP 주소를 가진 호스트와의 네트워크 연결 상태를 테스트한다.30 패킷 전송 및 반환 여부를 통해 연결 가능성을 확인한다.30

- `sudo tcpdump -i [네트워크_인터페이스명]`: 실제로 일어나는 패킷의 이동을 실시간으로 모니터링하는 데 사용한다.30 이 명령어를 통해 패킷 흐름을 파악하고 네트워크 문제를 진단할 수 있다.30


리눅스 시스템을 더욱 효율적으로 사용하기 위한 몇 가지 유용한 명령어를 소개한다.


`less` 명령어는 한 번에 한 페이지씩 텍스트 파일을 보고 스크롤할 수 있게 해주는 뷰어이다.31 특히 편집기로 열기에는 너무 큰 텍스트 파일을 조회할 때 유용하다.31

- `less [파일명]`: 지정된 파일의 내용을 페이지 단위로 표시한다.31
- **탐색:**
  - `j`: 한 줄 아래로 이동.31
  - `k`: 한 줄 위로 이동.31
  - `f` 또는 `space bar`: 한 페이지 앞으로 이동.31
  - `b`: 한 페이지 뒤로 이동.31
  - `g`: 파일의 맨 처음으로 이동.32
  - `G`: 파일의 맨 끝으로 이동.32
  - 좌우 화살표: 긴 문장을 좌우로 움직여 확인할 수 있다.32
- **검색:**
  - `/ [문자열]`: 파일 정방향 순서대로 문자열을 찾아 하이라이트한다.32
  - `? [문자열]`: 파일 역방향 순서대로 문자열을 찾아 하이라이트한다.32
  - `n`: 검색된 다음 문자열로 이동한다.32
  - `N`: 검색된 이전 문자열로 이동한다.32
- **종료:** `q` 키를 누르면 `less`를 종료하고 명령 프롬프트로 돌아간다.31
- **옵션:**
  - `-N`: 왼쪽에 라인 번호를 함께 표시한다.32
  - `-M`: `less` 하단에 현재 페이지와 진행률 정보를 출력한다.32
  - `-s`: 연속된 빈 라인들을 하나의 빈 라인으로 간주한다.32


`man`은 'manual'을 의미하며, 리눅스 명령어에 대한 상세한 설명서 페이지를 볼 수 있는 명령어이다.34

`--help` 옵션보다 훨씬 더 자세한 정보를 제공한다.34

- `man [명령어_이름]`: 지정된 명령어의 도움말(매뉴얼)을 확인한다.33
- **탐색:**
  - `Enter` 또는 위/아래 방향키: 한 줄씩 이동한다.34
  - `Page Up/Down` 또는 `f/b`: 페이지 단위로 이동한다.33
- **검색:**
  - `/ [문자열]`: 설명서에서 문자열을 검색한다.34
  - `n`: 다음 검색 결과로 이동한다.34
  - `N`: 이전 검색 결과로 이동한다.34
- **종료:** `q` 키를 누르면 `man` 페이지를 종료한다.33


시스템 종료 및 재시작 명령어는 관리자 권한이 있는 계정만 실행할 수 있다.33

- `logout`: 로그인한 쉘에서만 유효하며, 현재 쉘을 종료한다.33

- `exit`: 로그인한 쉘이 아니어도 현재 쉘을 종료한다.33

- `sudo shutdown [옵션][매개변수]`: 시스템을 종료한다.33

- `sudo reboot`: 시스템을 재시작한다.33 이는 

  `shutdown -r now`와 동일하다.33

- `Ctrl + Alt + Del`: 콘솔 앞에서 이 키 조합을 누르면 시스템이 강제로 재시작된다.33


이 자습서를 통해 리눅스 운영체제의 근본적인 정의와 특징, 유닉스와의 관계, 그리고 다양한 배포판의 존재를 이해했을 것이다. 리눅스의 강력함은 오픈소스라는 본질적인 특성에서 비롯되며, 이는 지속적인 혁신, 강력한 보안, 그리고 광범위한 채택으로 이어진다.

리눅스 시스템의 핵심 구성 요소인 커널과 쉘의 역할을 파악하고, 이들이 어떻게 하드웨어와 상호작용하며 사용자 명령을 처리하는지 이해함으로써 시스템의 안정성과 유연성을 높이는 아키텍처적 장점을 알게 되었을 것이다. 또한, 파일 시스템 계층 구조 표준(FHS)을 통해 리눅스 파일 시스템의 논리적인 구조와 각 디렉토리의 용도를 명확히 이해하고, 이는 시스템 관리 및 문제 해결에 필수적인 지식이다.

마지막으로, `cd`, `ls`, `chmod`, `chown`, `useradd`, `apt`, `yum`, `dnf`, `nano`, `vi/vim`, `ps`, `top`, `ifconfig`, `man`, `less` 등 리눅스 시스템과 상호작용하는 데 필요한 핵심 명령어들을 학습했다. 이러한 명령어들은 CLI 환경에서 시스템을 효율적으로 제어하고, 자동화된 작업을 수행하며, 문제 발생 시 진단하고 해결하는 데 필수적인 도구이다.

리눅스는 서버, 임베디드 시스템, 개인용 데스크톱 등 다양한 환경에서 견고하고 유연하게 작동하는 운영체제이다. 이 자습서에서 다룬 지식과 명령어들을 꾸준히 연습하고 실제 환경에 적용함으로써, 리눅스 시스템의 잠재력을 최대한 활용하고 더욱 능숙한 사용자로 성장할 수 있을 것이다.