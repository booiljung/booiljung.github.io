<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:암호학 원론</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>암호학 원론</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">정보 보안 (Information Security)</a> / <a href="index.html">암호학</a> / <span>암호학 원론</span></nav>
                </div>
            </header>
            <article>
                <h1>암호학 원론</h1>
<h2>1. 서론: 암호학의 원칙과 목표</h2>
<h3>1.1 암호학의 정의 및 기본 용어</h3>
<p>암호학(Cryptography)은 비밀 정보를 안전하게 전송하고 보호하기 위한 언어학적 및 수학적 방법론을 다루는 학문이다.1 그리스어에서 ’비밀’을 의미하는 ’크립토스(Kryptos)’에서 유래한 이 용어는 2, 정보를 인가되지 않은 제3자로부터 보호하여 오직 허가된 당사자만이 그 내용을 이해할 수 있도록 하는 기술과 과학을 포괄한다.3 암호학의 연구는 크게 두 분야로 나뉜다. 하나는 안전한 암호 시스템을 설계하고 분석하는 암호학(Cryptography)이며, 다른 하나는 허가 없이 암호화된 정보로부터 비밀 정보를 해독하는 기술을 연구하는 암호해독(Cryptanalysis)이다.1</p>
<p>암호학의 기본 개념을 이해하기 위해서는 몇 가지 핵심 용어에 대한 명확한 정의가 필요하다.</p>
<ul>
<li>
<p><strong>평문 (Plaintext):</strong> 암호화를 통해 보호하고자 하는 원본 메시지. 일반적으로 <span class="math math-inline">P</span> 또는 <span class="math math-inline">M</span>으로 표기한다.3</p>
</li>
<li>
<p><strong>암호문 (Ciphertext):</strong> 평문을 암호학적 방법으로 변환하여 그 내용을 알아볼 수 없게 만든 메시지. 일반적으로 <span class="math math-inline">C</span>로 표기한다.3</p>
</li>
<li>
<p><strong>암호화 (Encryption):</strong> 평문을 암호문으로 변환하는 과정. 암호 알고리즘 <span class="math math-inline">E</span>를 사용하여 수행된다.1</p>
</li>
<li>
<p><strong>복호화 (Decryption):</strong> 암호문을 다시 평문으로 변환하는 과정. 복호화 알고리즘 <span class="math math-inline">D</span>를 사용하여 수행된다.1</p>
</li>
<li>
<p><strong>키 (Key):</strong> 암호화 및 복호화 과정을 제어하는 비밀 정보. 일반적으로 <span class="math math-inline">K</span>로 표기한다.3</p>
</li>
</ul>
<p>이러한 용어들을 사용하여 암호화와 복호화 과정을 수식으로 표현하면 다음과 같다. 평문 <span class="math math-inline">P</span>를 키 <span class="math math-inline">K</span>를 사용하여 암호화하여 암호문 <span class="math math-inline">C</span>를 얻는 과정은 <span class="math math-inline">C = E_K(P)</span>로 나타낼 수 있다. 반대로, 암호문 <span class="math math-inline">C</span>를 키 <span class="math math-inline">K</span>로 복호화하여 평문 <span class="math math-inline">P</span>를 복원하는 과정은 <span class="math math-inline">P = D_K(C)</span>로 표현된다.3 현대 암호학의 중요한 원칙 중 하나는 케르크호프스의 원리(Kerckhoffs’s Principle)로, 암호 시스템의 안전성은 알고리즘의 비밀성에 의존해서는 안 되며, 오직 키의 비밀성에만 의존해야 한다는 것이다.6 즉, 암호화 및 복호화 알고리즘</p>
<p><span class="math math-inline">E</span>와 <span class="math math-inline">D</span>는 공개되어도, 키 <span class="math math-inline">K</span>를 모르면 암호문을 해독할 수 없어야 한다.</p>
<h3>1.2 정보 보안의 핵심 목표</h3>
<p>암호 기술은 단순히 정보를 숨기는 것을 넘어, 디지털 환경에서 신뢰를 구축하기 위한 여러 가지 핵심적인 보안 목표를 달성하고자 한다. 이러한 목표들은 정보 보안의 기둥 역할을 하며, 현대 암호 시스템은 이들을 종합적으로 제공하도록 설계된다.</p>
<ul>
<li>
<p><strong>기밀성 (Confidentiality):</strong> 정보 보안의 가장 기본적인 목표로, 오직 인가된 사용자만이 정보의 내용에 접근할 수 있도록 보장하는 원칙이다.1 암호화는 기밀성을 달성하는 가장 직접적이고 강력한 수단이며, 데이터가 저장되어 있거나(at rest) 전송 중일 때(in transit) 모두 적용된다.8</p>
</li>
<li>
<p><strong>무결성 (Integrity):</strong> 정보가 생성, 전송, 저장되는 과정에서 허가되지 않은 방식으로 변경, 삭제, 또는 생성되지 않았음을 보장하는 원칙이다.7 데이터가 원본 그대로 유지되었음을 확인하는 것은 금융 거래나 중요한 계약 문서 등에서 필수적이다. 암호학적 해시 함수와 메시지 인증 코드(MAC)가 무결성을 보장하는 데 핵심적인 역할을 한다.7</p>
</li>
<li>
<p><strong>인증 (Authentication):</strong> 통신에 참여하는 주체(사용자, 시스템 등)의 신원을 확인하거나, 수신된 메시지의 출처가 주장된 것과 일치하는지를 검증하는 과정이다.7 로그인 정보, 생체 데이터, 디지털 서명 등이 인증 수단으로 사용되며, 이를 통해 통신 상대방이 위장된 공격자가 아님을 확신할 수 있다.13</p>
</li>
<li>
<p><strong>부인 방지 (Non-repudiation):</strong> 특정 행위나 이벤트의 발생 및 그 행위의 주체를 증명하여, 해당 주체가 사후에 그 사실을 부인할 수 없도록 하는 강력한 보안 속성이다.1 이는 단순한 기술적 개념을 넘어 법적 증거력을 갖추기 위한 필수 요소로, 공개키 기반의 디지털 서명을 통해 강력하게 보장된다. 예를 들어, 디지털 서명이 된 전자 계약서는 서명자가 계약 내용에 동의했다는 사실을 부인할 수 없게 만든다.13</p>
</li>
<li>
<p><strong>가용성 (Availability):</strong> 인가된 사용자가 필요할 때 정보 자산 및 관련 서비스에 접근하고 사용할 수 있도록 보장하는 원칙이다.1 암호 기술이 직접적으로 가용성을 제공하지는 않지만, 서비스 거부(DoS) 공격과 같은 가용성을 저해하는 공격으로부터 시스템을 보호하고 데이터의 신뢰성을 유지함으로써 간접적으로 기여한다.</p>
</li>
</ul>
<p>이러한 보안 목표들의 발전 과정은 디지털 사회의 진화와 그 궤를 같이한다. 초기 암호학의 주된 관심사는 군사 및 정치적 맥락에서의 <strong>기밀성</strong>에 국한되었다. 적에게 메시지의 내용을 숨기는 것이 거의 유일한 목표였다.8 그러나 디지털 통신과 전자상거래가 보편화되면서, 데이터가 중간에 변조되지 않았다는 확신, 즉</p>
<p><strong>무결성</strong>의 중요성이 대두되었고, 통신 상대가 정말 그 사람이 맞는지 확인하는 <strong>인증</strong>이 필수적이 되었다.7 이 세 가지 목표(기밀성, 무결성, 가용성)를 묶어 전통적으로 “CIA Triad“라 부르며 정보 보안의 기본 모델로 삼았다.10</p>
<p>더 나아가, 전자 계약, 온라인 금융 거래 등 법적 책임이 수반되는 행위가 디지털 공간으로 이전되면서, “나는 그런 메시지를 보낸 적이 없다“고 발뺌하는 것을 방지할 필요성이 생겨났다. 이는 <strong>부인 방지</strong>라는, 단순한 기술적 보호를 넘어 법적 증거력을 확보하는 차원의 목표로 이어졌다.7 따라서 암호학 목표의 진화는 기술적 요구사항의 증가일 뿐만 아니라, 디지털 상호작용이 현실 세계의 사회적, 법적 관계를 완전히 대체해 나가는 과정을 보여주는 명백한 증거라 할 수 있다.</p>
<h2>2.  암호학의 역사적 여정</h2>
<p>암호학의 역사는 수천 년에 걸쳐 있으며, 각 시대의 기술적, 사회적 요구에 따라 끊임없이 진화해왔다. 이는 정보를 숨기려는 자와 그것을 밝혀내려는 자 사이의 끊임없는 지적 군비 경쟁의 역사이기도 하다.</p>
<h3>2.1  고전 암호의 시대: 치환과 전치</h3>
<p>고대 암호 기술은 주로 두 가지 기본 원리, 즉 치환(Substitution)과 전치(Transposition)에 기반을 두었다.1 이 시기의 암호는 수작업으로 계산 가능해야 했으며, 그 안전성은 알고리즘의 비밀성에 크게 의존했다.</p>
<h4>2.1.1 스테가노그래피 vs. 암호학</h4>
<p>암호 기술을 논하기에 앞서, 메시지를 숨기는 또 다른 방식인 스테가노그래피(Steganography)와 암호학을 구분할 필요가 있다. 스테가노그래피는 메시지의 존재 자체를 은폐하는 기술이다. 예를 들어, 특수 화학 처리를 해야만 보이는 잉크로 글씨를 쓰거나, 특정 문자에 미세한 핀 구멍을 뚫어 정보를 숨기는 방식이 이에 해당한다.3 반면, 암호학은 메시지의 존재는 드러나지만, 그 의미를 인가되지 않은 자가 이해할 수 없도록 내용을 변형하는 데 초점을 맞춘다.3</p>
<h4>2.1.2 전치 암호 (Transposition Cipher)</h4>
<p>전치 암호는 평문의 글자 순서를 재배열하여 암호문을 만드는 방식이다.4 가장 오래된 예시 중 하나는 고대 스파르타에서 사용된</p>
<p><strong>스키테일(Scytale)</strong> 암호이다.16 이는 특정 지름을 가진 원통형 막대(스키테일)에 가늘고 긴 양피지를 나선형으로 감은 뒤, 가로 방향으로 메시지를 작성하는 방식이다. 양피지를 풀어내면 글자들이 의미 없는 순서로 섞여 암호문이 된다.19 이 암호문을 해독하기 위해서는 송신자가 사용한 것과 동일한 지름의 스키테일이 필요하며, 이 막대의 지름이 바로 암호의 ‘키’ 역할을 한다.18 스키테일 암호는 평문의 문자는 그대로 사용하고 위치만 바꾸는 전형적인 전치 암호의 모습을 보인다.20</p>
<h4>2.1.3 치환 암호 (Substitution Cipher)</h4>
<p>치환 암호는 평문의 각 글자를 미리 정해진 규칙에 따라 다른 글자나 기호로 대체하는 방식이다.1 가장 널리 알려진 예는 로마의 율리우스 카이사르가 군사적 목적으로 사용했다고 전해지는 **카이사르 암호(Caesar Cipher)**이다.16 이는 각 알파벳을 알파벳 순서상 일정한 거리만큼 뒤로 밀어서 다른 글자로 바꾸는 단순 치환 방식이다. 예를 들어, 키가 3이라면 ’A’는 ’D’로, ’B’는 ’E’로 변환된다.22</p>
<p>수학적으로 카이사르 암호는 합동식(Modular Arithmetic)을 이용하여 표현할 수 있다. 알파벳 A부터 Z까지를 0부터 25까지의 숫자에 대응시킨다고 할 때, 평문 글자 <span class="math math-inline">P</span>를 키 <span class="math math-inline">k</span>를 사용하여 암호문 글자 <span class="math math-inline">C</span>로 변환하는 암호화 과정은 다음과 같다.24</p>
<p>C≡(P+k)(mod26)</p>
<p>복호화는 그 역과정으로, 암호문 글자 <span class="math math-inline">C</span>에서 키 <span class="math math-inline">k</span>를 빼서 평문 글자 <span class="math math-inline">P</span>를 얻는다.</p>
<p>P≡(C−k)(mod26)</p>
<p>이러한 단순 치환 암호는 구현이 간단하지만, 언어의 통계적 특성을 이용한 **빈도 분석(Frequency Analysis)**에 매우 취약하다는 단점이 있다.26</p>
<h3>2.2  기계식 암호와 암호 해독의 발전</h3>
<p>단순 치환 암호의 취약점이 드러나면서, 암호학은 더욱 복잡한 형태로 발전했다. 특히 두 차례의 세계 대전은 암호 기술의 기계화를 촉발했고, 이는 암호 해독 기술의 비약적인 발전으로 이어졌다.</p>
<p>9세기경 아랍의 학자 알-킨디(Al-Kindi)가 빈도 분석법을 체계화하면서, 평문의 글자마다 고정된 치환을 사용하는 단일치환 암호는 더 이상 안전하지 않게 되었다.27 이를 극복하기 위해 평문의 위치에 따라 다른 치환 규칙을 적용하는 **다중치환 암호(Polyalphabetic Cipher)**가 등장했다. 대표적인 예로 16세기에 고안된 비즈네르 암호(Vigenère Cipher)가 있으며, 이는 카이사르 암호를 여러 키를 이용해 반복 적용하는 방식으로 볼 수 있다.28</p>
<p>20세기 초, 전기기계 기술의 발전은 암호학에 혁명을 가져왔다. 제2차 세계대전 당시 독일군이 사용한 **에니그마(Enigma)**는 기계식 암호 장치의 정점이었다.2 에니그마는 여러 개의 회전자(rotor)를 내장하여, 키보드로 평문을 한 글자씩 입력할 때마다 회전자의 위치가 바뀌면서 암호화 규칙이 매번 달라지는 매우 복잡한 다중치환 암호를 생성했다.2 이로 인해 기존의 수작업 기반 빈도 분석은 사실상 불가능해졌다.</p>
<p>그러나 이러한 강력한 기계식 암호에 맞서, 암호 해독 역시 기계의 힘을 빌리기 시작했다. 영국 블레츨리 파크(Bletchley Park)의 앨런 튜링(Alan Turing)을 비롯한 연합군 암호 해독팀은 에니그마의 암호를 해독하기 위해 **콜로서스(Colossus)**와 같은 초기 형태의 전자 컴퓨터를 개발했다.2 이는 에니그마 메시지에 나타나는 통계적 약점을 찾아내고 방대한 양의 계산을 자동화함으로써 암호를 해독하는 데 결정적인 역할을 했다. 에니그마의 해독은 연합군의 승리에 크게 기여했으며, 이 과정은 암호 해독이 단순한 언어학적 분석을 넘어 계산 과학의 영역으로 진입하는 중요한 전환점이 되었다.</p>
<h3>2.3  현대 암호의 서막</h3>
<p>제2차 세계대전 이후, 컴퓨터 기술의 급속한 발전은 암호학을 현대적인 학문으로 탈바꿈시켰다. 1970년대까지의 복잡한 기계 장치를 이용한 암호 기술을 근대 암호라 한다면, 컴퓨터 개발 이후의 기술은 현대 암호로 분류된다.17</p>
<p>현대 암호학의 이론적 기틀은 1940년대 후반 벨 연구소의 수학자 **클로드 섀넌(Claude Shannon)**에 의해 마련되었다. 그는 그의 기념비적인 논문 “A Mathematical Theory of Communication“과 “Communication Theory of Secrecy Systems“를 통해 정보 이론을 정립하고, 암호 시스템의 안전성을 수학적으로 정의하고 분석할 수 있는 토대를 제공했다.29 특히 그는 안전한 암호가 갖추어야 할 두 가지 중요한 속성으로 **혼돈(Confusion)**과 **확산(Diffusion)**을 제시했다. 혼돈은 키와 암호문 사이의 관계를 복잡하게 만드는 것이고, 확산은 평문의 통계적 특성이 암호문 전반에 퍼지도록 하는 것이다.31 이 두 원리는 오늘날 사용되는 대부분의 블록 암호 설계의 핵심 철학이 되었다.</p>
<p>1970년대에 들어서면서 컴퓨터 기술의 발전은 섀넌의 이론을 실제 알고리즘으로 구현하는 것을 가능하게 했다. 1977년, IBM이 개발하고 미국 국립표준기술연구소(NIST)가 연방 정보 처리 표준(FIPS)으로 채택한 **DES(Data Encryption Standard)**는 최초의 현대적 블록 암호로 자리매김했다.6 DES는 전 세계 상업 및 금융 분야에서 수십 년간 표준으로 사용되며 디지털 암호 시대의 개막을 알렸다.</p>
<p>그러나 현대 암호학 역사상 가장 극적인 변화는 1976년에 일어났다. 휫필드 디피(Whitfield Diffie)와 마틴 헬만(Martin Hellman)이 “New Directions in Cryptography“라는 논문을 통해 **공개키 암호(Public-key Cryptography)**라는 혁명적인 개념을 제시한 것이다.29 이듬해인 1977년, MIT의 로널드 리베스트(Ronald Rivest), 아디 샤미르(Adi Shamir), 레오나르드 에이들먼(Leonard Adleman)은 이 개념을 구현한 최초의 실용적인 알고리즘인</p>
<p><strong>RSA</strong>를 발명했다.32 사전에 비밀키를 공유할 필요가 없는 공개키 암호의 등장은 암호학의 패러다임을 완전히 바꾸어 놓았다. 이로써 암호 기술은 더 이상 정부나 군대의 전유물이 아닌, 일반 대중과 상업계가 널리 사용할 수 있는 기술로 발전하는 계기를 맞이하게 되었다.16</p>
<p>이처럼 암호학의 역사는 각 시대의 기술적 한계와 사회적 요구가 맞물려 형성된 ’공격과 방어의 끊임없는 군비 경쟁’으로 요약될 수 있다. 고대 시대의 수작업 기반 암호와 통계적 분석의 대결에서부터, 세계 대전 시기 기계식 암호와 초기 컴퓨터의 싸움, 그리고 인터넷 시대의 키 분배 문제를 해결한 공개키 혁명에 이르기까지, 암호 기술은 외부의 도전에 응전하며 끊임없이 진화해 온 역사적 산물이다.</p>
<h2>3.  대칭키 암호 시스템</h2>
<p>대칭키 암호 시스템(Symmetric-key Cryptosystem)은 현대 암호학의 가장 기본적인 구성 요소 중 하나이다. 비밀키 암호(Secret-key Cryptography) 또는 관용 암호(Conventional Cryptography)라고도 불리며, 그 핵심 원리는 단순성과 효율성에 있다.4</p>
<h3>3.1  핵심 원리 및 분류</h3>
<p>대칭키 암호 방식의 근본적인 특징은 암호화 과정과 복호화 과정에서 <strong>동일한 키</strong>를 사용한다는 점이다.4 따라서 통신을 원하는 송신자와 수신자는 사전에 이 공통의 비밀키를 안전한 방법으로 공유하고 있어야만 한다.9 이 비밀키는 제3자에게 절대 노출되어서는 안 되며, 시스템의 모든 보안은 이 키의 비밀성에 의존한다.</p>
<p>대칭키 암호 알고리즘은 평문을 처리하는 방식에 따라 크게 두 가지 유형으로 분류된다.</p>
<ul>
<li><strong>블록 암호 (Block Cipher):</strong> 이 방식은 평문을 고정된 크기의 블록(block) 단위로 나누어 각 블록을 개별적으로 암호화한다.5 예를 들어, 128비트 블록 암호는 전체 평문을 128비트 단위로 잘라서 처리한다. 만약 마지막 평문 조각이 블록 크기보다 작을 경우, 정해진 규칙에 따라 부족한 부분을 채워 길이를 맞추는</li>
</ul>
<p><strong>패딩(Padding)</strong> 과정이 필요하다.35 DES, 3DES, AES, SEED, ARIA 등이 대표적인 블록 암호 알고리즘이다.15</p>
<ul>
<li><strong>스트림 암호 (Stream Cipher):</strong> 이 방식은 데이터를 비트(bit) 또는 바이트(byte) 단위의 연속적인 흐름(stream)으로 간주하고, 키 스트림(keystream)이라 불리는 의사 난수 비트열을 생성하여 평문 스트림과 XOR 연산 등을 통해 암호문을 생성한다.4 실시간 음성 통화나 비디오 스트리밍과 같이 지연에 민감하고 데이터가 연속적으로 발생하는 환경에 적합하다. RC4가 널리 알려진 스트림 암호 알고리즘의 예이다.38</li>
</ul>
<h3>3.2  장점과 근본적 한계</h3>
<p>대칭키 암호 방식은 여러 장점을 가지고 있지만, 동시에 극복하기 어려운 근본적인 한계를 내포하고 있다.</p>
<h4>3.2.1 장점</h4>
<p>대칭키 암호의 가장 큰 장점은 <strong>속도</strong>이다. 알고리즘의 내부 구조가 주로 비트 단위의 치환, 전치, XOR 등 상대적으로 단순한 연산들의 조합으로 이루어져 있어, 비대칭키 암호에 비해 암호화 및 복호화 연산 속도가 월등히 빠르다.4 이러한 효율성 덕분에 대용량의 데이터를 암호화해야 하는 경우, 예를 들어 데이터베이스 전체를 암호화하거나 대용량 파일을 전송할 때 매우 유용하다.38</p>
<h4>3.2.2 단점 (키 관리 문제)</h4>
<p>대칭키 암호의 아킬레스건은 **키 관리(Key Management)**의 어려움에 있다. 이 문제는 크게 두 가지 측면에서 발생한다.</p>
<ul>
<li>
<p><strong>키 분배 문제 (Key Distribution Problem):</strong> 대칭키 암호 시스템이 작동하기 위한 전제 조건은 통신 당사자들이 사전에 동일한 비밀키를 안전하게 공유해야 한다는 것이다. 만약 보안되지 않은 네트워크 채널을 통해 이 비밀키를 전송한다면, 공격자가 중간에서 키를 가로챌 수 있으며, 그 순간 해당 암호 시스템 전체가 무력화된다.4 따라서 ’닭이 먼저냐, 달걀이 먼저냐’와 같은 딜레마, 즉 안전한 통신을 위해 비밀키가 필요한데, 그 비밀키를 안전하게 전달할 방법이 마땅치 않다는 문제가 발생한다.</p>
</li>
<li>
<p><strong>키 개수 문제 (Key Scalability Problem):</strong> 통신 네트워크에 참여하는 사용자의 수가 증가할수록 관리해야 할 키의 개수가 기하급수적으로 늘어나는 문제이다. <code>n</code>명의 참여자가 서로 개별적인 비밀 통신을 하고자 할 경우, 모든 두 사용자 쌍마다 고유한 비밀키가 하나씩 필요하다. 따라서 필요한 총 키의 개수는 <span class="math math-inline">n(n-1)/2</span>개가 된다. 각 사용자는 자신을 제외한 모든 다른 사용자와의 통신을 위해 <span class="math math-inline">n-1</span>개의 키를 안전하게 보관하고 관리해야 하는 부담을 안게 된다.15 예를 들어, 100명의 사용자가 있다면 총 4,950개의 키가 필요하다. 이는 시스템의 확장성을 심각하게 저해하는 요인으로 작용한다.15</p>
</li>
</ul>
<p>이러한 키 관리의 어려움은 대칭키 암호 방식이 가진 본질적인 한계이다. 속도와 효율성이라는 명백한 장점에도 불구하고, 이 한계 때문에 결국 비대칭키 암호라는 새로운 패러다임이 등장하게 되었다. 현대 암호 시스템은 이 두 가지 방식의 장점을 결합한 하이브리드 형태를 취하는 경우가 많다. 즉, 비대칭키 암호를 사용하여 대칭키(세션키)를 안전하게 교환하고, 실제 대용량 데이터 통신은 교환된 대칭키를 이용해 빠르고 효율적으로 수행하는 것이다.40</p>
<h3>3.3  주요 알고리즘 심층 분석: DES와 AES</h3>
<h4>3.3.1 DES (Data Encryption Standard)</h4>
<p>DES는 1970년대 IBM에서 개발되어 1977년 미국 연방 표준으로 지정된, 현대 블록 암호의 효시와 같은 알고리즘이다.41</p>
<ul>
<li><strong>구조:</strong> DES는 64비트 크기의 평문 블록을 입력받아 64비트의 암호문 블록을 출력한다. 이때 사용되는 키의 길이는 64비트이지만, 이 중 8비트는 패리티(parity) 검사용으로 사용되므로 실제 유효 키 길이는 56비트이다.41 DES의 핵심 구조는 **페이스텔 구조(Feistel Structure)**이다.41 이 구조는 입력 블록을 왼쪽(L)과 오른쪽(R)의 두 부분으로 나눈 뒤, 16라운드에 걸쳐 암호화 변환을 반복한다. 각 라운드에서, 오른쪽 부분</li>
</ul>
<p><span class="math math-inline">R_i</span>는 라운드 키 <span class="math math-inline">K_{i+1}</span>과 함께 라운드 함수 <span class="math math-inline">F</span>에 입력되고, 그 결과는 왼쪽 부분 <span class="math math-inline">L_i</span>와 XOR 연산되어 다음 라운드의 오른쪽 부분 <span class="math math-inline">R_{i+1}</span>이 된다. 현재 라운드의 오른쪽 부분 <span class="math math-inline">R_i</span>는 그대로 다음 라운드의 왼쪽 부분 <span class="math math-inline">L_{i+1}</span>이 된다.31</p>
<p>Li+1​=Ri​Ri+1​=Li​⊕F(Ri​,Ki+1​)</p>
<p>페이스텔 구조의 가장 큰 장점은 암호화 과정과 복호화 과정의 알고리즘이 거의 동일하다는 점이다. 복호화는 단순히 암호화 과정에서 사용된 라운드 키들을 역순으로 적용하기만 하면 되므로, 하드웨어 구현이 매우 효율적이다.42</p>
<ul>
<li><strong>취약점:</strong> DES의 가장 치명적인 약점은 56비트라는 짧은 키 길이에 있다. 컴퓨터 기술이 발전함에 따라, 가능한 모든 키를 하나씩 시도해보는 **전사 공격(Brute-force attack)**에 취약해졌다.39 1998년, 전자 프론티어 재단(EFF)은 DES 전용 해독기인 ’딥 크랙(Deep Crack)’을 제작하여 약 56시간 만에 DES 암호를 해독하는 데 성공했으며, 이듬해에는 22시간 15분으로 시간을 단축했다.41 이러한 취약점을 보완하기 위해, DES를 세 번 연속으로 적용하는 **3DES(Triple DES)**가 대안으로 사용되었다. 3DES는</li>
</ul>
<p><code>암호화(K1) -&gt; 복호화(K2) -&gt; 암호화(K3)</code>의 과정을 거치며, 키 길이를 112비트 또는 168비트로 늘려 전사 공격에 대한 안전성을 높였다.31 그러나 3DES는 원래 DES보다 속도가 3배 느리고, 알고리즘 자체의 노후화 문제로 인해 근본적인 해결책이 되지는 못했다.</p>
<h4>3.3.2 AES (Advanced Encryption Standard)</h4>
<p>AES는 취약해진 DES를 대체하기 위해 미국 국립표준기술연구소(NIST)가 주관한 공개 공모전을 통해 2001년에 새로운 표준으로 채택된 블록 암호 알고리즘이다.17 벨기에의 암호학자 요안 대믄(Joan Daemen)과 빈센트 라이먼(Vincent Rijmen)이 개발한</p>
<p><strong>라인달(Rijndael) 알고리즘</strong>이 최종적으로 선정되었다.30</p>
<ul>
<li><strong>구조:</strong> AES는 128비트의 고정된 블록 크기를 가지며, 키 길이는 128비트, 192비트, 256비트 중에서 선택할 수 있다.46 키 길이에 따라 AES-128, AES-192, AES-256으로 불리며, 각각 10, 12, 14번의 라운드를 수행한다.46 DES의 페이스텔 구조와 달리, AES는</li>
</ul>
<p><strong>SPN(Substitution-Permutation Network)</strong> 구조를 채택했다.46 SPN 구조는 각 라운드에서 전체 데이터 블록을 대상으로 치환(Substitution)과 순열(Permutation) 연산을 반복적으로 적용하여 암호화를 수행한다.</p>
<ul>
<li><strong>라운드 함수:</strong> AES의 암호화 과정은 내부적으로 **상태(State)**라고 불리는 4x4 바이트 행렬을 기반으로 이루어진다.46 각 라운드는 다음 네 가지의 변환 계층으로 구성된다 (단, 마지막 라운드에서는 MixColumns 과정이 생략된다).46</li>
</ul>
<ol>
<li>
<p><strong>SubBytes (바이트 치환):</strong> 상태 행렬의 각 바이트를 S-Box(Substitution Box)라는 미리 정의된 테이블을 참조하여 새로운 바이트로 대체하는 비선형 변환 과정이다.46 이 과정은 섀넌의 ‘혼돈(Confusion)’ 속성을 제공하여, 암호문과 키 사이의 관계를 복잡하게 만든다.46</p>
</li>
<li>
<p><strong>ShiftRows (행 이동):</strong> 상태 행렬의 각 행을 정해진 규칙에 따라 왼쪽으로 순환 이동(cyclic shift)시키는 과정이다. 1행은 이동하지 않고, 2행은 1바이트, 3행은 2바이트, 4행은 3바이트씩 이동한다.46 이 순열 과정은 섀넌의 ‘확산(Diffusion)’ 속성을 강화하여, 평문의 한 비트 변화가 암호문 전체에 영향을 미치도록 한다.46</p>
</li>
<li>
<p><strong>MixColumns (열 섞기):</strong> 상태 행렬의 각 열을 하나의 다항식으로 간주하고, 유한체 <span class="math math-inline">GF(2^8)</span> 상에서 미리 정의된 상수 다항식과 곱셈 연산을 수행하는 과정이다.46 이 과정은 4개의 바이트를 서로 섞어주어 확산 효과를 극대화하는 핵심적인 역할을 한다.46</p>
</li>
<li>
<p><strong>AddRoundKey (라운드 키 더하기):</strong> 현재 상태 행렬에 해당 라운드의 라운드 키를 바이트 단위로 XOR 연산하는 과정이다.46 이는 암호화 과정에 키를 주입하는 유일한 단계이다.46</p>
</li>
</ol>
<ul>
<li><strong>운용 모드 (Cipher Mode):</strong> AES 역시 128비트보다 큰 데이터를 암호화하기 위해 운용 모드를 사용한다. <strong>ECB(Electronic Codebook)</strong> 모드는 가장 단순하지만, 동일한 평문 블록이 항상 동일한 암호문 블록으로 변환되기 때문에 데이터의 패턴이 노출될 수 있는 심각한 보안 약점이 있다. 이를 해결하기 위해, 이전 블록의 암호문 결과를 다음 블록의 평문과 XOR한 후 암호화하는 <strong>CBC(Cipher Block Chaining)</strong> 모드가 널리 사용된다. CBC 모드는 초기화 벡터(IV)를 사용하여 첫 블록의 암호화를 시작하며, 동일한 평문이라도 매번 다른 암호문을 생성하게 하여 보안성을 크게 향상시킨다.36</li>
</ul>
<p>현재까지 AES에 대한 심각한 이론적 공격은 발견되지 않았으며, 그 안전성과 효율성 덕분에 전 세계적으로 가장 널리 사용되는 대칭키 암호 표준으로 자리 잡고 있다.46</p>
<h2>4.  공개키 암호 시스템</h2>
<p>1970년대 중반에 등장한 공개키 암호 시스템(Public-key Cryptosystem)은 암호학의 역사에서 가장 중요한 패러다임 전환을 가져왔다. 비대칭키 암호(Asymmetric-key Cryptography)라고도 불리는 이 방식은 대칭키 암호가 가진 고질적인 키 분배 문제를 근본적으로 해결하며 디지털 통신과 상거래의 안전한 기반을 마련했다.</p>
<h3>4.1  패러다임의 전환: 비대칭키</h3>
<p>공개키 암호의 핵심 아이디어는 암호화에 사용하는 키와 복호화에 사용하는 키를 <strong>분리</strong>하는 것이다.8 각 사용자는 수학적으로 긴밀하게 연결된 한 쌍의 키, 즉 **공개키(Public Key)**와 **개인키(Private Key)**를 생성한다.9</p>
<ul>
<li>
<p><strong>공개키(Public Key):</strong> 이름 그대로 모든 사람에게 공개될 수 있는 키이다. 이 키는 전화번호부처럼 누구나 자유롭게 접근하고 사용할 수 있다.4</p>
</li>
<li>
<p><strong>개인키(Private Key):</strong> 키 소유자만이 안전하게 보관해야 하는 비밀 키이다. 이 키는 어떤 경우에도 외부에 노출되어서는 안 된다.4</p>
</li>
</ul>
<p>이 두 개의 키는 서로 다른 역할을 수행하며, 공개키 암호 시스템의 두 가지 주요 기능을 가능하게 한다.</p>
<ol>
<li>
<p><strong>기밀성 보장 (암호화):</strong> 송신자가 수신자에게 비밀 메시지를 보내고 싶을 때, 송신자는 수신자의 <strong>공개키</strong>를 사용하여 메시지를 암호화한다. 이렇게 암호화된 메시지는 오직 해당 공개키와 쌍을 이루는 수신자의 <strong>개인키</strong>로만 복호화할 수 있다.15 중간에 공격자가 암호문을 가로채더라도, 수신자의 개인키를 가지고 있지 않기 때문에 내용을 해독하는 것이 불가능하다. 이로써 사전에 비밀 정보를 공유하지 않고도 안전한 통신 채널을 구축할 수 있다.51</p>
</li>
<li>
<p><strong>인증 및 부인 방지 (디지털 서명):</strong> 송신자가 메시지의 출처를 증명하고 싶을 때, 송신자는 자신의 <strong>개인키</strong>를 사용하여 메시지(또는 메시지의 해시값)를 암호화한다. 이 과정을 ’서명’이라고 한다. 수신자를 포함한 누구나 송신자의 <strong>공개키</strong>를 사용하여 이 서명을 복호화(이를 ’검증’이라 함)할 수 있다.38 서명이 성공적으로 검증된다면, 이는 해당 메시지가 오직 그 개인키의 소유자만이 생성할 수 있음을 증명하는 것이다. 이를 통해 메시지 발신자의 신원을</p>
</li>
</ol>
<p><strong>인증</strong>하고, 발신자가 나중에 메시지를 보낸 사실을 <strong>부인하는 것을 방지</strong>할 수 있다.53</p>
<h3>4.2  수학적 기반: 일방향 트랩도어 함수</h3>
<p>공개키 암호 시스템의 안전성은 **일방향 트랩도어 함수(Trapdoor One-way Function)**라는 특수한 수학적 함수에 기반한다.53</p>
<ul>
<li>
<p><strong>일방향 함수(One-way Function):</strong> 한쪽 방향으로의 계산은 매우 쉽고 빠르지만, 그 계산 결과를 가지고 원래 입력값을 알아내는 역방향 계산은 계산적으로 거의 불가능한(computationally infeasible) 함수를 말한다.</p>
</li>
<li>
<p><strong>트랩도어(Trapdoor):</strong> 여기에 ’비밀의 문’이라는 의미의 트랩도어 정보가 추가된다. 이 비밀 정보(즉, 개인키)를 알고 있는 사람에게는 역방향 계산이 쉬워지는 특성을 가진 함수가 바로 일방향 트랩도어 함수이다.53</p>
</li>
</ul>
<p>공개키는 일방향 함수를 계산하는 데 사용되고, 개인키는 트랩도어 역할을 하여 역계산을 가능하게 한다. 현대 공개키 암호 시스템은 다음과 같은 수학적 난제들을 일방향 트랩도어 함수로 활용한다.</p>
<ul>
<li>
<p><strong>소인수분해 문제 (Integer Factorization Problem):</strong> 두 개의 매우 큰 소수 <span class="math math-inline">p</span>와 <span class="math math-inline">q</span>를 곱하여 하나의 큰 합성수 <span class="math math-inline">n = pq</span>를 계산하는 것은 간단하다. 그러나 역으로, 거대한 합성수 <span class="math math-inline">n</span>을 주고 두 소인수 <span class="math math-inline">p</span>와 <span class="math math-inline">q</span>를 찾아내는 것은 현재 알려진 가장 빠른 고전 컴퓨터 알고리즘으로도 사실상 불가능에 가까울 정도로 오랜 시간이 걸린다. 이 문제의 어려움이 <strong>RSA</strong> 암호 시스템의 보안을 뒷받침하는 근간이다.16</p>
</li>
<li>
<p><strong>이산 로그 문제 (Discrete Logarithm Problem):</strong> 유한군(finite group), 특히 소수 <span class="math math-inline">p</span>를 법으로 하는 정수 집합에서, 밑 <span class="math math-inline">g</span>와 지수 <span class="math math-inline">x</span>가 주어졌을 때 <span class="math math-inline">y = g^x \pmod{p}</span>를 계산하는 것은 효율적으로 수행할 수 있다. 하지만 역으로, <span class="math math-inline">y, g, p</span>를 알고 있을 때 지수 <span class="math math-inline">x</span>를 찾는 것은 매우 어려운 문제로 알려져 있다. 이 이산 로그 문제의 어려움은 <strong>디피-헬만 키 교환(Diffie-Hellman Key Exchange)</strong>, <strong>ElGamal</strong>, <strong>DSA(Digital Signature Algorithm)</strong> 등의 보안 근간을 이룬다.52</p>
</li>
</ul>
<h3>4.3  주요 알고리즘 심층 분석</h3>
<h4>4.3.1 RSA (Rivest-Shamir-Adleman)</h4>
<p>RSA는 소인수분해 문제의 어려움에 기반한 최초의 실용적인 공개키 암호 알고리즘으로, 현재까지도 가장 널리 사용되는 방식 중 하나이다.33</p>
<ul>
<li><strong>키 생성 과정:</strong></li>
</ul>
<ol>
<li>
<p>비밀로 유지될 두 개의 매우 큰 소수 <span class="math math-inline">p</span>와 <span class="math math-inline">q</span>를 무작위로 선택한다.</p>
</li>
<li>
<p>모듈러스(modulus) <span class="math math-inline">n = pq</span>를 계산한다. 이 <span class="math math-inline">n</span> 값은 공개된다.</p>
</li>
<li>
<p>오일러 피 함수(Euler’s totient function) 값인 <span class="math math-inline">\phi(n) = (p-1)(q-1)</span>을 계산한다. 이 값은 비밀로 유지되어야 한다.</p>
</li>
<li>
<p><span class="math math-inline">1 &lt; e &lt; \phi(n)</span>을 만족하면서 <span class="math math-inline">\phi(n)</span>과 서로소(coprime)인 정수 <span class="math math-inline">e</span>를 공개키 지수(public exponent)로 선택한다. 즉, <span class="math math-inline">gcd(e, \phi(n)) = 1</span>이어야 한다. 일반적으로 <span class="math math-inline">e=65537 (2^{16}+1)</span>이 효율성 때문에 널리 사용된다.</p>
</li>
<li>
<p>확장 유클리드 알고리즘(Extended Euclidean algorithm)을 사용하여 <span class="math math-inline">ed \equiv 1 \pmod{\phi(n)}</span>을 만족하는 <span class="math math-inline">d</span>를 계산한다. 이 <span class="math math-inline">d</span>가 개인키 지수(private exponent)가 된다.</p>
</li>
<li>
<p>최종적으로, <strong>공개키</strong>는 $(e, n)`이 되고, <strong>개인키</strong>는 $(d, n)``이 된다.54</p>
</li>
</ol>
<ul>
<li>암호화 및 복호화:</li>
</ul>
<p>평문 메시지를 정수 <span class="math math-inline">M</span> (<span class="math math-inline">0 \le M &lt; n</span>)으로 표현했을 때, 암호화와 복호화는 다음과 같은 모듈러 지수 연산(modular exponentiation)으로 수행된다.</p>
<ul>
<li>
<p><strong>암호화 (공개키 <span class="math math-inline">(e, n)</span> 사용):</strong> <span class="math math-inline">C = M^e \pmod{n}</span></p>
</li>
<li>
<p><strong>복호화 (개인키 <span class="math math-inline">(d, n)</span> 사용):</strong> <span class="math math-inline">M = C^d \pmod{n}</span></p>
</li>
</ul>
<p>이 암호화-복호화 과정이 정확하게 원본 메시지를 복원하는 이유는 **오일러의 정리(Euler’s theorem)**에 의해 수학적으로 증명된다. 오일러의 정리에 따르면, <span class="math math-inline">M</span>과 <span class="math math-inline">n</span>이 서로소일 때 <span class="math math-inline">M^{\phi(n)} \equiv 1 \pmod{n}</span>이 성립한다. 키 생성 과정에서 <span class="math math-inline">ed \equiv 1 \pmod{\phi(n)}</span>이므로, 적당한 정수 <span class="math math-inline">k</span>에 대해 <span class="math math-inline">ed = k\phi(n) + 1</span>로 쓸 수 있다. 따라서 복호화 과정은 다음과 같이 전개된다.60</p>
<p>Cd≡(Me)d≡Med≡Mkϕ(n)+1≡(Mϕ(n))k⋅M1≡1k⋅M≡M(modn)</p>
<p>아래 표는 RSA 알고리즘의 작동 원리를 구체적인 숫자를 통해 단계별로 보여준다.</p>
<table><thead><tr><th>단계</th><th>연산</th><th>예시 (<span class="math math-inline">p=61, q=53</span>)</th><th>수식</th></tr></thead><tbody>
<tr><td><strong>키 생성</strong></td><td>1. <span class="math math-inline">n</span> 계산</td><td><span class="math math-inline">n = 61 \times 53 = 3233</span></td><td><span class="math math-inline">n = pq</span></td></tr>
<tr><td></td><td>2. <span class="math math-inline">\phi(n)</span> 계산</td><td><span class="math math-inline">\phi(n) = (60) \times (52) = 3120</span></td><td><span class="math math-inline">\phi(n) = (p-1)(q-1)</span></td></tr>
<tr><td></td><td>3. <span class="math math-inline">e</span> 선택</td><td><span class="math math-inline">e = 17</span> (<span class="math math-inline">gcd(17, 3120) = 1</span>)</td><td><span class="math math-inline">1 &lt; e &lt; \phi(n), gcd(e, \phi(n)) = 1</span></td></tr>
<tr><td></td><td>4. <span class="math math-inline">d</span> 계산</td><td><span class="math math-inline">d = 2753</span> (<span class="math math-inline">17 \times 2753 \equiv 1 \pmod{3120}</span>)</td><td><span class="math math-inline">ed \equiv 1 \pmod{\phi(n)}</span></td></tr>
<tr><td><strong>공개키/개인키</strong></td><td></td><td>공개키: <span class="math math-inline">(e=17, n=3233)</span> <br>개인키: <span class="math math-inline">(d=2753, n=3233)</span></td><td></td></tr>
<tr><td><strong>암호화</strong></td><td>평문 <span class="math math-inline">M=65</span> 암호화</td><td><span class="math math-inline">C = 65^{17} \pmod{3233} = 2790</span></td><td><span class="math math-inline">C = M^e \pmod{n}</span></td></tr>
<tr><td><strong>복호화</strong></td><td>암호문 <span class="math math-inline">C=2790</span> 복호화</td><td><span class="math math-inline">M = 2790^{2753} \pmod{3233} = 65</span></td><td><span class="math math-inline">M = C^d \pmod{n}</span></td></tr>
</tbody></table>
<h4>4.3.2 Diffie-Hellman 키 교환</h4>
<p>디피-헬만 키 교환은 암호화 알고리즘이 아니라, 안전하지 않은 공개 채널을 통해 두 통신 당사자가 비밀 정보를 안전하게 공유할 수 있도록 하는 **키 합의 프로토콜(Key Agreement Protocol)**이다.7</p>
<ul>
<li><strong>과정:</strong></li>
</ul>
<ol>
<li>
<p>앨리스와 밥은 사전에 크고 안전한 소수 <span class="math math-inline">p</span>와 그에 대한 원시근(primitive root)인 생성자 <span class="math math-inline">g</span>를 합의하여 공개적으로 공유한다.</p>
</li>
<li>
<p>앨리스는 자신만의 비밀 정수 <span class="math math-inline">a</span>를 선택하고, <span class="math math-inline">A = g^a \pmod{p}</span>를 계산하여 밥에게 전송한다.</p>
</li>
<li>
<p>밥 역시 자신만의 비밀 정수 <span class="math math-inline">b</span>를 선택하고, <span class="math math-inline">B = g^b \pmod{p}</span>를 계산하여 앨리스에게 전송한다.</p>
</li>
<li>
<p>앨리스는 밥에게서 받은 <span class="math math-inline">B</span>와 자신의 비밀 정수 <span class="math math-inline">a</span>를 이용해 공유 비밀키 <span class="math math-inline">S = B^a \pmod{p}</span>를 계산한다.</p>
</li>
<li>
<p>밥은 앨리스에게서 받은 <span class="math math-inline">A</span>와 자신의 비밀 정수 <span class="math math-inline">b</span>를 이용해 공유 비밀키 <span class="math math-inline">S = A^b \pmod{p}</span>를 계산한다.</p>
</li>
</ol>
<p>수학적으로 <span class="math math-inline">(g^b)^a \equiv g^{ba} \equiv g^{ab} \equiv (g^a)^b \pmod{p}</span>이므로, 앨리스와 밥은 중간에 도청자가 <span class="math math-inline">A</span>와 <span class="math math-inline">B</span>를 가로채더라도 이산 로그 문제의 어려움 때문에 <span class="math math-inline">a</span>나 <span class="math math-inline">b</span>를 알아낼 수 없어, 결과적으로 동일한 공유 비밀키 <span class="math math-inline">S</span>를 안전하게 생성할 수 있다.52 다만, 이 기본 프로토콜은 통신 상대방을 인증하는 기능이 없어 **중간자 공격(Man-in-the-Middle Attack)**에 취약할 수 있다.52</p>
<h4>4.3.3 타원곡선 암호 (ECC, Elliptic Curve Cryptography)</h4>
<p>타원곡선 암호는 이산 로그 문제를 유한체 위의 타원곡선(elliptic curve)이라는 특수한 대수 구조로 옮겨온 공개키 암호 방식이다.61</p>
<ul>
<li>
<p><strong>원리:</strong> 유한 소수체 <span class="math math-inline">\mathbb{F}_p</span> 상에서 정의된 타원곡선 방정식 <span class="math math-inline">y^2 \equiv x^3 + ax + b \pmod{p}</span>를 만족하는 점들의 집합은 특수한 ‘덧셈’ 연산을 정의할 수 있다. 이 덧셈 연산에 기반한 이산 로그 문제, 즉 **타원곡선 이산 로그 문제(ECDLP)**는 일반적인 유한체에서의 이산 로그 문제보다 훨씬 더 어렵다고 알려져 있다.62</p>
</li>
<li>
<p><strong>키 생성:</strong> 타원곡선 위의 모든 참여자가 공유하는 기준점(base point) <span class="math math-inline">G</span>가 주어졌을 때, 사용자는 비밀 정수인 <strong>개인키</strong> <span class="math math-inline">d</span>를 선택한다. 그리고 <span class="math math-inline">G</span>를 <span class="math math-inline">d</span>번 덧셈하는 스칼라 곱셈(scalar multiplication) 연산을 통해 <strong>공개키</strong> <span class="math math-inline">Q = dG</span>를 계산한다.62</p>
</li>
</ul>
<p><span class="math math-inline">d</span>와 <span class="math math-inline">G</span>로부터 <span class="math math-inline">Q</span>를 계산하는 것은 쉽지만, <span class="math math-inline">Q</span>와 <span class="math math-inline">G</span>를 알고 있을 때 <span class="math math-inline">d</span>를 찾는 것은 계산적으로 매우 어렵다.63</p>
<ul>
<li><strong>장점:</strong> ECC의 가장 큰 장점은 <strong>효율성</strong>이다. RSA와 동일한 수준의 보안 강도를 훨씬 짧은 키 길이로 달성할 수 있다.65 예를 들어, 128비트 대칭키와 동등한 보안 수준을 제공하기 위해 RSA는 3072비트 키가 필요한 반면, ECC는 256비트 키만으로 충분하다.67 키 길이가 짧아지면 저장 공간이 절약될 뿐만 아니라, 암호화 및 복호화에 필요한 계산량도 크게 줄어든다. 이로 인해 ECC는 연산 능력, 메모리, 배터리 등 리소스가 제한적인 스마트폰, IoT 기기, 스마트카드 등의 환경에서 특히 유리하다.66</li>
</ul>
<p>아래 표는 대칭키 암호와 공개키 암호의 핵심적인 차이점을 비교한 것이다.</p>
<table><thead><tr><th>특징</th><th>대칭키 암호 (Symmetric-Key Cryptography)</th><th>공개키 암호 (Asymmetric-Key Cryptography)</th></tr></thead><tbody>
<tr><td><strong>키</strong></td><td>암호화/복호화에 동일한 키 사용 (비밀키)</td><td>암호화/복호화에 서로 다른 키 사용 (공개키, 개인키)</td></tr>
<tr><td><strong>키 개수 (<span class="math math-inline">n</span>명)</strong></td><td><span class="math math-inline">n(n-1)/2</span></td><td><span class="math math-inline">2n</span></td></tr>
<tr><td><strong>속도</strong></td><td>매우 빠름</td><td>상대적으로 매우 느림</td></tr>
<tr><td><strong>주요 기능</strong></td><td>기밀성 (Confidentiality)</td><td>기밀성, 인증, 부인 방지, 키 교환</td></tr>
<tr><td><strong>핵심 과제</strong></td><td>키 분배 문제 (Key Distribution Problem)</td><td>공개키의 신뢰성 문제 (PKI 필요)</td></tr>
<tr><td><strong>대표 알고리즘</strong></td><td>DES, AES, SEED, ARIA</td><td>RSA, Diffie-Hellman, ECC, DSA</td></tr>
</tbody></table>
<p>아래 표는 RSA와 ECC의 보안 강도에 따른 키 길이를 비교하여 ECC의 효율성을 보여준다.</p>
<table><thead><tr><th>대칭키 보안 수준 (비트)</th><th>RSA 키 길이 (비트)</th><th>ECC 키 길이 (비트)</th></tr></thead><tbody>
<tr><td>80</td><td>1024</td><td>160</td></tr>
<tr><td>112</td><td>2048</td><td>224</td></tr>
<tr><td>128</td><td>3072</td><td>256</td></tr>
<tr><td>192</td><td>7680</td><td>384</td></tr>
<tr><td>256</td><td>15360</td><td>512</td></tr>
</tbody></table>
<p>공개키 암호의 등장은 단순히 ’키 분배 문제’를 해결한 기술적 진보를 넘어서, ’신뢰’의 기반을 중앙 집중적 기관이나 물리적 접촉에서 탈중앙화된 ’수학적 증명’으로 전환시킨 철학적 혁명이었다. 대칭키 시스템에서 신뢰는 ’키를 공유한 우리’라는 폐쇄적 관계에 기반하지만 15, 공개키 시스템은 한 번도 만난 적 없는 사람의 ’공개키’를 신뢰하고 통신할 수 있게 한다.34 이 신뢰의 근원은 ‘소인수분해는 어렵다’ 또는 ’이산 로그 문제는 어렵다’는 수학적 사실에 대한 믿음이다.53 즉, 신뢰의 대상이 ’사람’이나 ’기관’에서 ’수학적 난제’라는 보편적이고 검증 가능한 원리로 이동한 것이다. 이러한 ’수학 기반 신뢰’는 전자상거래, 디지털 서명, 그리고 궁극적으로 중앙 기관 없이 P2P 신뢰를 구축하는 블록체인 기술의 탄생을 가능하게 한 근본적인 철학적 토대가 되었다.7</p>
<h2>5.  암호학적 해시 함수와 데이터 무결성</h2>
<p>암호학적 해시 함수(Cryptographic Hash Function)는 현대 암호 시스템에서 데이터의 무결성을 보장하고, 패스워드를 안전하게 저장하며, 디지털 서명을 생성하는 등 다방면에 걸쳐 핵심적인 역할을 수행하는 기본적인 암호학적 도구이다.</p>
<h3>5.1  해시 함수의 정의와 핵심 속성</h3>
<p>해시 함수는 임의의 길이의 입력 데이터(메시지)를 받아, 고정된 길이의 짧은 출력값으로 변환하는 수학적 함수이다.70 이 출력값을</p>
<p><strong>해시 값(Hash Value)</strong> 또는 **메시지 다이제스트(Message Digest)**라고 부른다.73 이는 마치 원본 데이터의 고유한 ’디지털 지문(fingerprint)’과 같은 역할을 한다.71 예를 들어, SHA-256 해시 함수는 입력 데이터의 길이가 한 글자이든 기가바이트 단위의 파일이든 상관없이 항상 256비트(32바이트) 길이의 해시 값을 출력한다.70</p>
<p>일반적인 해시 함수와 구별되는 암호학적 해시 함수는 보안 목적으로 사용되기 위해 다음과 같은 세 가지 강력한 보안 속성을 반드시 만족해야 한다.</p>
<ol>
<li>
<p><strong>역상 저항성 (Preimage Resistance):</strong> 이 속성은 해시 함수의 **일방향성(One-wayness)**을 의미한다. 주어진 해시 값 <span class="math math-inline">h</span>에 대해, <span class="math math-inline">H(x) = h</span>를 만족하는 원래의 입력값 <span class="math math-inline">x</span>를 찾는 것이 계산적으로 불가능해야 한다.35 즉, 해시 값으로부터 원본 메시지를 역추적할 수 없어야 한다. 이 성질은 패스워드를 저장할 때 원본 패스워드를 노출시키지 않기 위해 필수적이다.70</p>
</li>
<li>
<p><strong>제2 역상 저항성 (Second Preimage Resistance):</strong> **약한 충돌 저항성(Weak Collision Resistance)**이라고도 불리는 이 속성은, 주어진 특정 입력값 <span class="math math-inline">x</span>에 대해, 그와 동일한 해시 값을 갖는 또 다른 입력값 <span class="math math-inline">x&#39;` (</span>x \neq x’$)을 찾는 것이 계산적으로 불가능해야 함을 의미한다.[35, 70, 75] 즉,<code> H(x)=H(x′)</code>을 만족하는<code> x′</code>을 찾기 어려워야 한다. 이 속성은 디지털 서명된 문서가 위조되는 것을 방지하는 데 중요하다. 공격자가 원본 문서와 동일한 해시 값을 갖는 위조 문서를 만들 수 있다면, 원본 문서의 서명을 위조 문서에 그대로 사용할 수 있기 때문이다.</p>
</li>
<li>
<p><strong>충돌 저항성 (Collision Resistance):</strong> **강한 충돌 저항성(Strong Collision Resistance)**이라고도 하며, 해시 값이 같아지는 <strong>임의의</strong> 두 개의 서로 다른 입력값 <span class="math math-inline">x</span>와 <span class="math math-inline">x&#39;</span> (<span class="math math-inline">x \neq x&#39;</span>) 쌍을 찾는 것 자체가 계산적으로 불가능해야 한다는 가장 강력한 조건이다.[74, 75, 76] 즉,<code> H(x)=H(x′)</code>을 만족하는 어떠한<code> (x,x′)</code> 쌍도 찾아낼 수 없어야 한다. 해시 함수는 입력 공간이 출력 공간보다 훨씬 크기 때문에 비둘기집 원리에 따라 충돌은 반드시 존재하지만, 암호학적으로 안전한 해시 함수는 이러한 충돌 쌍을 의도적으로 찾아내는 것이 현실적으로 불가능하도록 설계된다.</p>
</li>
</ol>
<p>이 세 가지 저항성은 서로 미묘하게 다른 보안 보장을 제공하며, 이들의 관계는 단순한 계층 구조가 아니다. 예를 들어, 충돌 저항성을 만족하는 함수는 제2 역상 저항성도 만족하지만, 그 역은 성립하지 않는다. 또한 충돌 저항성과 역상 저항성 사이에는 직접적인 함의 관계가 없다.71 따라서 해시 함수를 선택하고 평가할 때는 어떤 응용 분야에 사용할 것인지, 그리고 해당 분야가 어떤 종류의 공격(역상 공격, 위조 공격, 충돌 공격)에 가장 민감한지를 분석하여 그에 맞는 저항성을 갖춘 함수를 선택하는 정교한 판단이 요구된다.</p>
<h3>5.2  데이터 무결성 검증</h3>
<p>해시 함수의 가장 기본적인 응용 분야는 데이터의 **무결성(Integrity)**을 검증하는 것이다. 원본 데이터가 전송되거나 저장되는 과정에서 의도적이든 비의도적이든 어떠한 변경도 발생하지 않았음을 확인하는 데 사용된다.77</p>
<p>무결성 검증의 원리는 간단하다. 송신자는 원본 데이터를 전송할 때, 해당 데이터에 해시 함수를 적용하여 생성된 해시 값을 함께 보낸다. 데이터를 수신한 수신자는, 받은 데이터에 대해 송신자와 동일한 해시 함수를 적용하여 새로운 해시 값을 직접 계산한다. 그 후, 자신이 계산한 해시 값과 송신자로부터 받은 해시 값을 비교한다.77 만약 두 해시 값이 정확히 일치한다면, 데이터는 전송 과정에서 변조되지 않았다고 높은 신뢰도로 판단할 수 있다. 만약 데이터의 단 1비트라도 변경되었다면, ’눈사태 효과(Avalanche Effect)’로 인해 해시 값은 완전히 다른 값으로 출력되므로, 두 해시 값은 일치하지 않게 된다.73 이 방법은 인터넷에서 소프트웨어나 대용량 파일을 다운로드할 때, 배포자가 제공한 해시 값(주로 MD5 또는 SHA-256)과 다운로드한 파일의 해시 값을 비교하여 파일의 변조 여부를 확인하는 데 널리 사용된다.78</p>
<h3>5.3  패스워드 저장 보안</h3>
<p>사용자의 패스워드를 데이터베이스에 안전하게 저장하는 것은 시스템 보안의 매우 중요한 부분이다. 패스워드를 평문 그대로 저장하는 것은 데이터베이스가 유출될 경우 모든 사용자의 계정이 즉시 탈취될 수 있는 최악의 방법이다. 따라서 현대 시스템은 해시 함수를 이용한 단방향 암호화를 통해 패스워드를 저장한다.73</p>
<h4>5.3.1 단순 해싱의 문제점</h4>
<p>가장 기본적인 방법은 사용자의 패스워드를 해시 함수에 통과시켜 그 결과 해시 값만을 데이터베이스에 저장하는 것이다.81 사용자가 로그인할 때는 입력한 패스워드를 동일한 해시 함수로 변환한 뒤, 데이터베이스에 저장된 해시 값과 비교하여 인증을 수행한다. 이 방법은 데이터베이스 관리자조차 원본 패스워드를 알 수 없게 하여 보안 수준을 높인다.73</p>
<p>하지만 이 방법에도 심각한 취약점이 존재한다. 해시 함수는 결정론적(deterministic)이므로, 동일한 입력에 대해서는 항상 동일한 출력을 반환한다. 따라서 ’123456’이나 ’password’와 같이 자주 사용되는 패스워드는 항상 동일한 해시 값을 갖게 된다.83 공격자들은 이러한 점을 이용하여, 사전에 수백만, 수십억 개의 흔한 패스워드와 그에 해당하는 해시 값을 미리 계산하여 거대한 테이블로 만들어 둘 수 있다. 이 테이블을 **레인보우 테이블(Rainbow Table)**이라고 부른다. 만약 데이터베이스가 유출되어 패스워드 해시 값들이 노출되면, 공격자는 이 레인보우 테이블을 조회하여 매우 빠르게 원본 패스워드를 찾아낼 수 있다.76</p>
<h4>5.3.2 솔트 (Salt)</h4>
<p>레인보우 테이블 공격을 무력화하기 위해 고안된 기법이 **솔트(Salt)**이다. 솔트는 패스워드를 해싱하기 전에 각 사용자별로 고유하게 생성되는 임의의 문자열이다.48 패스워드를 저장할 때, 시스템은</p>
<p><code>hash(password + salt)</code>와 같이 사용자의 패스워드와 솔트를 결합한 문자열을 해싱한다.83</p>
<p>이 방법을 사용하면, 설령 여러 사용자가 동일한 패스워드를 사용하더라도 각기 다른 솔트 값이 적용되기 때문에 데이터베이스에 저장되는 최종 해시 값은 모두 달라지게 된다.84 공격자는 더 이상 미리 계산된 레인보우 테이블을 사용할 수 없게 되며, 각 사용자의 해시 값을 개별적으로 공격해야 하므로 공격의 효율성이 크게 떨어진다. 생성된 솔트는 보안상 비밀로 유지할 필요는 없으며, 보통 해당 사용자의 패스워드 해시 값과 함께 데이터베이스에 저장된다.83 사용자가 로그인할 때는 데이터베이스에서 해당 사용자의 솔트 값을 먼저 가져온 뒤, 입력된 패스워드와 결합하여 해싱한 결과를 저장된 해시 값과 비교한다.81</p>
<h4>5.3.3 키 스트레칭 (Key Stretching)</h4>
<p>솔팅이 레인보우 테이블 공격을 막는다면, <strong>키 스트레칭</strong>은 **무차별 대입 공격(Brute-force Attack)**의 속도를 늦추기 위한 기법이다. 무차별 대입 공격은 특정 사용자의 해시 값 하나를 표적으로 삼아 가능한 모든 패스워드 조합을 시도해보는 방식이다. 현대의 빠른 하드웨어를 이용하면 초당 수십억 번의 해시 연산이 가능하므로, 비교적 단순한 패스워드는 금방 찾아낼 수 있다.</p>
<p>키 스트레칭은 이 공격을 비효율적으로 만들기 위해 의도적으로 해시 연산 과정을 느리게 만드는 방법이다. 이는 해시 함수를 한 번이 아니라 수천에서 수만 번 이상 반복적으로 적용하는 방식으로 이루어진다.81 예를 들어, <code>H_final = H(H(...H(password + salt)...))</code>와 같이 해싱을 10,000번 반복하도록 설정할 수 있다.</p>
<p>이 기법은 정상적인 사용자가 로그인할 때는 수백 밀리초 정도의 약간의 지연만을 유발하여 거의 체감되지 않지만, 공격자가 하나의 패스워드를 추측하는 데 드는 시간을 10,000배로 늘리는 효과를 가져온다. 이로 인해 무차별 대입 공격에 필요한 총 시간이 비현실적으로 길어져 사실상 공격을 불가능하게 만든다.76</p>
<p><strong>PBKDF2(Password-Based Key Derivation Function 2)</strong>, <strong>bcrypt</strong>, <strong>scrypt</strong>, <strong>Argon2</strong> 등이 키 스트레칭을 구현한 대표적인 알고리즘들이다.82</p>
<h2>6.  현대 암호 기술의 응용</h2>
<p>현대 암호학은 개별 알고리즘의 발전을 넘어, 다양한 암호학적 요소(primitive)들을 유기적으로 결합하여 복잡한 보안 목표를 달성하는 ’프로토콜 공학(Protocol Engineering)’의 단계로 진입했다. 전자 서명, 보안 통신, 블록체인, 종단간 암호화 등은 이러한 응용의 대표적인 사례이며, 현대 디지털 사회의 신뢰 인프라를 구성하는 핵심 기술들이다.</p>
<h3>6.1  전자 서명 (Digital Signature)</h3>
<p>전자 서명은 현실 세계의 수기 서명이나 인감을 디지털 환경으로 옮겨온 것으로, <strong>해시 함수</strong>와 <strong>공개키 암호</strong> 기술을 결합하여 데이터의 <strong>무결성, 인증, 부인 방지</strong>라는 세 가지 핵심 보안 목표를 동시에 달성한다.8</p>
<ul>
<li><strong>생성 과정:</strong></li>
</ul>
<ol>
<li>
<p><strong>해싱(Hashing):</strong> 송신자(서명자)는 서명하고자 하는 원본 전자문서(메시지)를 암호학적 해시 함수에 입력하여 고정된 길이의 메시지 다이제스트(해시 값)를 생성한다. 이는 문서의 고유한 ‘지문’ 역할을 한다.86</p>
</li>
<li>
<p><strong>서명(Signing):</strong> 송신자는 생성된 메시지 다이제스트를 자신의 <strong>개인키</strong>를 사용하여 암호화한다. 이 암호화된 해시 값이 바로 ’전자 서명’이다.52</p>
</li>
<li>
<p><strong>전송:</strong> 송신자는 원본 문서와 생성된 전자 서명을 함께 수신자에게 전송한다.90</p>
</li>
</ol>
<ul>
<li><strong>검증 과정:</strong></li>
</ul>
<ol>
<li>
<p><strong>해시값 계산:</strong> 수신자는 전달받은 원본 문서를 송신자가 사용한 것과 동일한 해시 함수에 입력하여 새로운 메시지 다이제스트(다이제스트 1)를 직접 계산한다.86</p>
</li>
<li>
<p><strong>서명 복호화:</strong> 수신자는 함께 전달받은 전자 서명을 송신자의 <strong>공개키</strong>를 사용하여 복호화한다. 성공적으로 복호화되면 원본 메시지 다이제스트(다이제스트 2)가 복원된다.90</p>
</li>
<li>
<p><strong>비교 및 검증:</strong> 수신자는 자신이 직접 계산한 ’다이제스트 1’과 서명을 복호화하여 얻은 ’다이제스트 2’를 비교한다.90</p>
</li>
</ol>
<ul>
<li>
<p>두 값이 <strong>일치</strong>하면, 수신자는 다음 세 가지 사실을 확신할 수 있다.</p>
</li>
<li>
<p><strong>무결성:</strong> 문서는 전송 중에 변경되지 않았다. (만약 변경되었다면 해시 값이 달라졌을 것이다.) 69</p>
</li>
<li>
<p><strong>인증:</strong> 이 서명은 오직 해당 공개키와 쌍을 이루는 개인키의 소유자만이 생성할 수 있으므로, 문서가 송신자로부터 온 것이 맞다.</p>
</li>
<li>
<p><strong>부인 방지:</strong> 송신자는 자신의 개인키로 서명한 사실을 나중에 부인할 수 없다.86</p>
</li>
</ul>
<h3>6.2  보안 통신 프로토콜: SSL/TLS</h3>
<p>SSL(Secure Sockets Layer)과 그 후속 표준인 TLS(Transport Layer Security)는 인터넷 상에서 웹 브라우저와 서버 간의 통신을 암호화하고 인증하기 위한 표준 보안 프로토콜이다. 우리가 흔히 보는 HTTPS(HTTP Secure)는 HTTP 프로토콜이 SSL/TLS 위에서 동작하는 것을 의미한다.94 SSL/TLS는 대칭키 암호의 빠른 속도와 비대칭키 암호의 안전한 키 교환 능력을 결합한 **하이브리드 암호 시스템(Hybrid Cryptosystem)**의 대표적인 예이다.9</p>
<ul>
<li>TLS 핸드셰이크 과정 (TLS 1.2, RSA 키 교환 기준):</li>
</ul>
<p>실제 데이터 통신이 시작되기 전에, 클라이언트와 서버는 ’핸드셰이크(handshake)’라는 협상 과정을 통해 안전한 통신 채널을 수립한다.</p>
<ol>
<li>
<p><strong>Client Hello:</strong> 클라이언트(웹 브라우저)가 서버에 접속하며, 자신이 지원하는 TLS 버전, 사용 가능한 암호 스위트(Cipher Suite: 암호화 알고리즘, 키 교환 알고리즘, 해시 함수의 조합) 목록, 그리고 <code>client_random</code>이라는 무작위 바이트 문자열을 서버로 전송한다.95</p>
</li>
<li>
<p><strong>Server Hello, Certificate, Server Hello Done:</strong> 서버는 클라이언트가 제시한 암호 스위트 중 하나를 선택하고, <code>server_random</code>이라는 또 다른 무작위 문자열과 함께 자신의 <strong>SSL/TLS 인증서</strong>를 클라이언트에게 보낸다. 이 인증서에는 서버의 도메인 이름, 서버의 <strong>공개키</strong>, 그리고 이 인증서가 신뢰할 수 있음을 보증하는 인증 기관(CA, Certificate Authority)의 전자 서명이 포함되어 있다.95</p>
</li>
<li>
<p><strong>인증서 검증 및 키 교환:</strong></p>
</li>
</ol>
<ul>
<li>
<p>클라이언트는 자신의 운영체제나 브라우저에 미리 내장된 신뢰할 수 있는 최상위 CA(Root CA)들의 공개키 목록을 참조하여 서버가 보낸 인증서의 서명을 검증한다. 이를 통해 접속하려는 서버가 위장된 서버가 아님을 확인한다(서버 인증).96</p>
</li>
<li>
<p>인증서가 유효하다고 판단되면, 클라이언트는 <code>pre-master secret</code>이라는 세 번째 무작위 데이터를 생성한다. 그리고 인증서에서 추출한 서버의 <strong>공개키</strong>로 이 <code>pre-master secret</code>을 암호화하여 서버로 전송한다.95</p>
</li>
</ul>
<ol start="4">
<li>
<p><strong>세션키 생성:</strong> 서버는 자신의 <strong>개인키</strong>를 사용하여 클라이언트가 보낸 암호화된 <code>pre-master secret</code>을 복호화한다. 이제 클라이언트와 서버 양측은 <code>client_random</code>, <code>server_random</code>, <code>pre-master secret</code>이라는 세 가지 무작위 데이터를 모두 공유하게 된다. 양측은 이 세 데이터를 동일한 알고리즘으로 조합하여 이후의 모든 통신에 사용할 **세션키(Session Key)**를 생성한다. 이 세션키는 대칭키이다.94</p>
</li>
<li>
<p><strong>핸드셰이크 완료:</strong> 클라이언트와 서버는 각자 생성한 세션키로 “Finished“라는 메시지를 암호화하여 서로에게 보내고, 성공적으로 복호화되면 핸드셰이크 과정이 완료된다. 이후 모든 애플리케이션 데이터(HTTP 요청 및 응답)는 이 세션키를 이용한 빠르고 효율적인 <strong>대칭키 암호 방식</strong>으로 암호화되어 전송된다.95</p>
</li>
</ol>
<h3>6.3  블록체인과 암호화폐</h3>
<p>블록체인 기술은 중앙 관리 기관 없이 P2P(Peer-to-Peer) 네트워크 참여자들이 데이터를 공동으로 기록하고 관리하는 분산 원장 기술이다. 이 기술의 핵심적인 신뢰와 보안은 암호학, 특히 해시 함수와 전자 서명에 깊이 의존한다.</p>
<ul>
<li>
<p><strong>해시 함수의 역할:</strong></p>
</li>
<li>
<p><strong>블록 연결 및 불변성(Immutability):</strong> 블록체인은 이름 그대로 데이터의 묶음인 ’블록(Block)’들이 ’체인(Chain)’처럼 연결된 구조이다. 각 블록은 자신의 데이터뿐만 아니라 <strong>이전 블록의 해시 값</strong>을 헤더에 포함한다.70 만약 누군가 과거의 특정 블록에 있는 거래 내역을 단 하나라도 수정하면, 그 블록의 해시 값이 변경된다. 이는 곧바로 다음 블록이 가리키는 ’이전 블록 해시 값’과 불일치를 일으키고, 그 결과 그 이후의 모든 블록들의 해시 값이 연쇄적으로 무효화된다. 이러한 연쇄 효과 때문에 블록체인에 한 번 기록된 데이터는 사실상 위변조가 불가능한</p>
</li>
</ul>
<p><strong>불변성</strong>을 갖게 된다.99</p>
<ul>
<li>
<p><strong>데이터 무결성 (머클 트리):</strong> 하나의 블록에는 수백, 수천 개의 거래(Transaction) 데이터가 포함될 수 있다. 이 모든 거래 데이터의 무결성을 효율적으로 검증하기 위해 **머클 트리(Merkle Tree)**라는 자료 구조가 사용된다. 각 거래 데이터를 해싱하고, 인접한 두 해시 값을 묶어 다시 해싱하는 과정을 반복하여 최종적으로 단 하나의 루트 해시(Merkle Root) 값을 얻는다. 이 루트 해시 값만 블록 헤더에 저장하면, 나중에 특정 거래가 블록에 포함되었는지 여부를 매우 효율적으로 검증할 수 있다.99</p>
</li>
<li>
<p><strong>전자 서명 (ECDSA):</strong></p>
</li>
<li>
<p><strong>소유권 증명 및 거래 승인:</strong> 비트코인, 이더리움 등 대부분의 주요 암호화폐는 **타원곡선 디지털 서명 알고리즘(ECDSA, Elliptic Curve Digital Signature Algorithm)**을 사용하여 자산의 소유권을 증명하고 거래를 승인한다.101</p>
</li>
<li>
<p><strong>키와 주소:</strong> 사용자는 먼저 256비트의 무작위 숫자인 <strong>개인키</strong>를 생성한다. 이 개인키는 절대 외부에 노출되어서는 안 된다. 타원곡선 수학(구체적으로 secp256k1 곡선)을 이용한 스칼라 곱셈 연산(<code>Q = dG</code>)을 통해 개인키(<code>d</code>)로부터 <strong>공개키</strong>(<code>Q</code>)가 파생된다.101 그리고 이 공개키에 다시 해시 함수를 적용하여 우리가 흔히 사용하는 암호화폐 ’주소’가 만들어진다.99</p>
</li>
<li>
<p><strong>거래 과정:</strong> 사용자가 자신의 암호화폐를 다른 주소로 보내려면, 거래 내역(보내는 사람, 받는 사람, 금액 등)을 담은 트랜잭션 데이터를 생성하고, 이를 자신의 <strong>개인키</strong>로 서명한다. 이 서명된 트랜잭션이 블록체인 네트워크에 전파되면, 다른 노드(참여자)들은 서명자의 <strong>공개키</strong>를 사용하여 서명을 검증한다. 검증이 성공하면, 해당 거래가 자산의 정당한 소유자에 의해 승인되었음을 확인하고 블록에 포함시킨다.104</p>
</li>
</ul>
<h3>6.4  종단간 암호화 (E2EE, End-to-End Encryption)</h3>
<p>종단간 암호화는 메시지를 보내는 송신자부터 최종 수신자까지, 전송 경로에 있는 그 어떤 중간자(서비스 제공업체 서버 포함)도 메시지의 내용을 들여다볼 수 없도록 보장하는 가장 강력한 형태의 통신 프라이버시 보호 기술이다.107 카카오톡의 비밀채팅, 왓츠앱, 시그널 메신저 등이 이 기술을 사용한다.108</p>
<ul>
<li>시그널 프로토콜 (Signal Protocol):</li>
</ul>
<p>시그널 프로토콜은 E2EE를 구현하는 가장 진보되고 널리 인정받는 기술 중 하나로, 그 핵심에는 **더블 래칫 알고리즘(Double Ratchet Algorithm)**이 있다.110 ’래칫(Ratchet)’은 한 방향으로만 돌아가는 톱니바퀴처럼, 암호키가 한 방향으로만 계속 갱신되어 과거의 키를 유추할 수 없게 만드는 메커니즘을 의미한다. 더블 래칫은 두 종류의 래칫을 결합하여 매우 강력한 보안 속성을 제공한다.112</p>
<ol>
<li>
<p><strong>대칭키 래칫 (Symmetric-key Ratchet):</strong> 이 래칫은 메시지를 하나 주고받을 때마다 작동한다. <strong>KDF(Key Derivation Function)</strong> 체인을 사용하여 현재의 체인 키(Chain Key)로부터 다음 체인 키와 현재 메시지를 암호화할 메시지 키(Message Key)를 파생시킨다. 메시지를 보낼 때마다 체인 키가 갱신되므로, 각 메시지는 서로 다른 키로 암호화된다. 이 메커니즘은 **전방향 안전성(Forward Secrecy)**을 제공한다. 즉, 만약 공격자가 특정 시점의 메시지 키 하나를 탈취하더라도, 그 키로는 오직 해당 메시지만 복호화할 수 있을 뿐, 그 이전에 주고받았던 메시지들은 안전하게 보호된다.110</p>
</li>
<li>
<p><strong>DH 래칫 (Diffie-Hellman Ratchet):</strong> 이 래칫은 대화가 진행되는 동안 주기적으로 작동한다. 메시지를 보내는 쪽은 새로운 디피-헬만(DH) 키 쌍을 생성하고, 그 공개키를 메시지에 첨부하여 상대방에게 보낸다. 상대방이 이 메시지를 받으면, 자신의 DH 키 쌍과 수신한 공개키를 이용해 DH 연산을 수행하여 새로운 루트 키(Root Key)를 계산한다. 이 새로운 루트 키는 대칭키 래칫의 KDF 체인을 초기화하는 데 사용된다. 이 과정은 <strong>침입 후 복구(Post-Compromise Security)</strong> 또는 **후방향 안전성(Backward Secrecy)**을 제공한다. 즉, 만약 공격자가 일시적으로 사용자의 장치를 해킹하여 현재의 모든 키를 탈취하더라도, 대화가 계속되어 새로운 DH 키 교환이 한 번이라도 이루어지면, 공격자는 그 이후의 메시지들은 더 이상 해독할 수 없게 된다. 시스템이 스스로 ’치유’되는 것이다.111</p>
</li>
</ol>
<p>이처럼 현대 암호 기술의 응용은 개별 알고리즘의 강력함을 넘어, 여러 암호학적 요소들을 유기적으로 ’조립’하여 특정 보안 목표를 달성하는 정교한 프로토콜 설계의 정수를 보여준다. SSL/TLS는 안전하면서도 효율적인 통신을, 블록체인은 탈중앙화된 신뢰를, 그리고 시그널 프로토콜은 지속적이고 자기 치유적인 프라이버시라는 매우 높은 수준의 보안 목표를 달성하기 위해 각기 다른 방식으로 암호학적 도구들을 조합하고 있다. 이는 암호학이 순수 수학을 넘어 시스템 공학의 영역과 깊이 결합하고 있음을 시사한다.</p>
<h2>7.  미래의 암호학: 양자 시대의 도전과 대응</h2>
<p>21세기 암호학은 역사상 가장 근본적인 도전에 직면해 있다. 바로 **양자 컴퓨팅(Quantum Computing)**의 등장이다. 양자역학의 원리를 이용하는 양자 컴퓨터는 특정 유형의 문제에 대해 기존의 고전 컴퓨터가 수백만 년이 걸려도 풀 수 없는 계산을 단 몇 시간, 몇 분 만에 해결할 수 있는 잠재력을 가지고 있다. 이는 현재 우리가 사용하는 대부분의 공개키 암호 시스템의 기반을 송두리째 무너뜨릴 수 있는 심각한 위협이다.</p>
<h3>7.1  양자 컴퓨팅의 위협</h3>
<p>양자 컴퓨터는 큐비트(qubit)라는 정보 단위를 사용한다. 0 또는 1의 상태만을 가질 수 있는 고전 비트와 달리, 큐비트는 0과 1의 상태를 동시에 가질 수 있는 **양자 중첩(Superposition)**과, 여러 큐비트가 서로 불가분하게 연결되어 하나의 상태 변화가 다른 큐비트에 즉시 영향을 미치는 **양자 얽힘(Entanglement)**이라는 독특한 특성을 활용한다. 이러한 특성 덕분에 양자 컴퓨터는 방대한 양의 계산을 병렬적으로 처리할 수 있다.114</p>
<p>이러한 양자 컴퓨터의 능력에 의해 직접적인 위협을 받는 암호 알고리즘은 다음과 같다.</p>
<ul>
<li>
<p><strong>쇼어 알고리즘 (Shor’s Algorithm):</strong> 1994년 수학자 피터 쇼어(Peter Shor)가 제안한 이 양자 알고리즘은, 충분한 수의 큐비트를 가진 양자 컴퓨터가 있다면 <strong>소인수분해 문제</strong>와 <strong>이산 로그 문제</strong>를 다항 시간(polynomial time) 내에 효율적으로 풀 수 있음을 증명했다.32 이는 현재 인터넷 보안의 근간을 이루는 RSA, 디피-헬만, 타원곡선 암호(ECC) 등 대부분의 공개키 암호 시스템이 가까운 미래에 완전히 무력화될 수 있음을 의미한다. 예를 들어, 현재 표준으로 사용되는 RSA-2048 암호는 고전 컴퓨터로는 해독에 수조 년이 걸릴 것으로 예상되지만, 이론적으로 양자 컴퓨터는 이를 단 몇 시간 만에 해독할 수 있다.114</p>
</li>
<li>
<p><strong>그로버 알고리즘 (Grover’s Algorithm):</strong> 1996년 로브 그로버(Lov Grover)가 제안한 이 양자 검색 알고리즘은 정렬되지 않은 <span class="math math-inline">N</span>개의 데이터베이스에서 특정 항목을 찾는 데 필요한 시간을 고전적인 <span class="math math-inline">O(N)</span>에서 <span class="math math-inline">O(\sqrt{N})</span>으로 단축시킨다.114 이는 대칭키 암호에 대한 전사 공격(brute-force attack)의 효율성을 크게 높이는 효과를 가져온다. 예를 들어, 128비트 키를 가진 AES-128의 경우, 고전적인 전사 공격에는</p>
</li>
</ul>
<p><span class="math math-inline">2^{128}</span>번의 시도가 필요하지만, 그로버 알고리즘을 사용하면 약 <span class="math math-inline">2^{64}</span>번의 시도만으로 키를 찾을 수 있게 된다. 따라서 양자 컴퓨팅 시대에 현재와 동등한 수준의 보안을 유지하기 위해서는 대칭키의 길이를 현재의 두 배로 늘려야 한다 (예: AES-128은 AES-256으로 대체).114</p>
<p>이러한 위협은 ‘지금 수확하고, 나중에 해독하는(Harvest now, decrypt later)’ 공격 시나리오 때문에 더욱 심각하다. 공격자들은 지금 당장 해독할 수 없더라도 현재의 암호화된 통신 데이터를 대량으로 수집하고 저장해 두었다가, 미래에 강력한 양자 컴퓨터가 개발되면 그때 저장해 둔 데이터를 해독하여 과거의 비밀 정보를 빼낼 수 있다.119</p>
<h3>7.2  양자내성암호 (PQC, Post-Quantum Cryptography)</h3>
<p>양자 컴퓨터의 위협에 대응하기 위한 첫 번째 접근법은 **양자내성암호(PQC)**이다. 이는 ’양자 컴퓨터 이후의 암호’라는 의미로, 양자 컴퓨터로도 효율적으로 풀기 어렵다고 여겨지는 새로운 종류의 수학적 난제에 기반한 차세대 암호 알고리즘들을 총칭한다.114 PQC의 가장 큰 장점은 기존의 컴퓨터와 네트워크 인프라를 그대로 사용하면서, 소프트웨어 업데이트만으로 양자 위협에 대응할 수 있다는 점이다.119</p>
<p>미국 국립표준기술연구소(NIST)는 2016년부터 PQC 표준화 프로젝트를 진행해 왔으며, 전 세계 암호학자들의 연구와 검증을 거쳐 몇 가지 유망한 알고리즘들을 표준으로 선정했다. PQC 알고리즘은 기반이 되는 수학적 난제에 따라 다음과 같이 분류된다.</p>
<ul>
<li><strong>격자 기반 암호 (Lattice-based Cryptography):</strong> 다차원 벡터 공간의 격자(lattice) 구조에서 ’가장 짧은 벡터 찾기(SVP)’나 ’가장 가까운 벡터 찾기(CVP)’와 같은 문제들의 어려움에 기반한다.120 성능과 키 크기, 보안성 사이의 균형이 뛰어나 현재 가장 유력한 PQC 후보로 평가받고 있으며, 동형암호와 같은 차세대 암호 기술의 기반이 되기도 한다. NIST는 키 교환 메커니즘으로</li>
</ul>
<p><strong>Kyber</strong>, 디지털 서명으로 <strong>Dilithium</strong>을 표준으로 채택했다.121</p>
<ul>
<li>
<p><strong>코드 기반 암호 (Code-based Cryptography):</strong> 통신에서 오류를 수정하기 위해 사용되는 선형 오류 수정 부호(linear error-correcting code)를 일반적인 경우에 디코딩하는 것이 어렵다는 문제에 기반한다.124 1978년에 제안된 McEliece 암호가 시초로, 역사가 길고 안전성에 대한 신뢰가 높지만, 공개키의 크기가 수 메가바이트에 달할 정도로 매우 크다는 실용적인 단점이 있다.121</p>
</li>
<li>
<p><strong>다변수 기반 암호 (Multivariate Cryptography):</strong> 유한체 위에서 정의된 여러 개의 변수를 갖는 다변수 이차방정식 시스템의 해를 구하는 것이 어렵다는 점에 기반한다.124 주로 디지털 서명에 사용되며, 서명 크기가 작고 서명 생성 속도가 빠르다는 장점이 있다.121</p>
</li>
<li>
<p><strong>해시 기반 암호 (Hash-based Cryptography):</strong> 다른 PQC 방식들과 달리, 새로운 수학적 난제가 아닌 기존의 검증된 암호학적 해시 함수의 안전성에만 기반을 둔다. 이는 양자 컴퓨터의 공격에 대해 매우 강력한 보안성을 제공한다는 큰 장점이 있다.124 하지만 서명 생성 시 상태(state)를 관리해야 하거나, 서명 횟수가 제한되는 등(one-time signature)의 단점이 있다. NIST는 **SPHINCS+**를 해시 기반 서명 표준으로 채택했다.121</p>
</li>
<li>
<p><strong>아이소제니 기반 암호 (Isogeny-based Cryptography):</strong> 두 타원곡선 사이에 존재하는 특별한 함수 관계인 아이소제니(isogeny)의 경로를 찾는 문제의 어려움에 기반한다.120 PQC 후보군 중에서 키 크기가 가장 작다는 매력적인 장점이 있었으나, 연산 속도가 매우 느리고 2022년에 핵심 알고리즘(SIKE)에 대한 심각한 공격 방법이 발견되어 현재는 표준 후보에서 제외되었다.126</p>
</li>
</ul>
<p>아래 표는 주요 PQC 유형별 특징을 요약한 것이다.</p>
<table><thead><tr><th>유형</th><th>기반 수학 난제</th><th>주요 특징 및 장단점</th><th>대표 알고리즘 (NIST 표준)</th></tr></thead><tbody>
<tr><td><strong>격자 기반</strong></td><td>최단 벡터 문제 (SVP), LWE 등</td><td><strong>장점:</strong> 성능과 키 크기 균형 우수, 다용도(동형암호 등) <br><strong>단점:</strong> 비교적 새로운 분야</td><td><strong>KEM:</strong> Kyber <br><strong>Signature:</strong> Dilithium</td></tr>
<tr><td><strong>코드 기반</strong></td><td>일반 선형 코드의 디코딩 문제</td><td><strong>장점:</strong> 긴 역사, 높은 신뢰도 <br><strong>단점:</strong> 매우 큰 공개키 크기</td><td><strong>KEM:</strong> Classic McEliece</td></tr>
<tr><td><strong>다변수 기반</strong></td><td>다변수 이차방정식 시스템 해 구하기</td><td><strong>장점:</strong> 작은 서명 크기, 빠른 서명 속도 <br><strong>단점:</strong> 일부 스킴은 공격에 취약했음</td><td><strong>Signature:</strong> (후보군)</td></tr>
<tr><td><strong>해시 기반</strong></td><td>암호학적 해시 함수의 안전성</td><td><strong>장점:</strong> 최소한의 보안 가정, 양자 공격에 매우 강함 <br><strong>단점:</strong> 상태 저장 필요, 서명 횟수 제한 또는 큰 서명</td><td><strong>Signature:</strong> SPHINCS+</td></tr>
<tr><td><strong>아이소제니 기반</strong></td><td>타원곡선 간 아이소제니 경로 찾기</td><td><strong>장점:</strong> 가장 작은 키 크기 <br><strong>단점:</strong> 매우 느린 연산 속도, 최근 취약점 발견</td><td>(SIKE, 제외됨)</td></tr>
</tbody></table>
<h3>7.3  양자암호통신 (QKD, Quantum Key Distribution)</h3>
<p>양자 위협에 대응하는 두 번째 접근법은 **양자 키 분배(QKD)**로, 이는 양자암호통신이라고도 불린다. PQC가 수학적 난제에 기반하는 것과 달리, QKD는 양자역학의 물리 법칙 그 자체를 이용하여 안전하게 암호키를 분배하는 기술이다.16</p>
<ul>
<li>
<p><strong>원리:</strong> QKD의 핵심 원리는 ’관측 행위가 양자 상태를 교란시킨다’는 양자역학의 기본 원리(불확정성 원리)에 있다. 송신자와 수신자는 단일 광자(photon)와 같은 양자 입자의 상태(예: 편광)를 이용하여 비밀키 정보를 인코딩하고 전송한다. 만약 공격자가 중간에서 이 광자를 가로채 측정을 시도하면, 광자의 양자 상태가 필연적으로 변하게 된다. 송수신자는 통신 후 자신들의 측정 결과 일부를 공개적으로 비교함으로써, 이러한 교란(오류율 증가)을 감지하고 도청 시도가 있었음을 알아챌 수 있다.123</p>
</li>
<li>
<p><strong>BB84 프로토콜:</strong> 1984년 찰스 베넷(Charles Bennett)과 질 브라사드(Gilles Brassard)가 제안한 최초이자 가장 대표적인 QKD 프로토콜이다.32</p>
</li>
</ul>
<ol>
<li>
<p>송신자 앨리스는 0과 1의 무작위 비트열을 생성한다. 각 비트에 대해, 두 개의 편광 기저(basis) 중 하나(예: 수직/수평 기저 <code>+</code> 또는 대각선 기저 <code>×</code>)를 무작위로 선택한다.</p>
</li>
<li>
<p>선택한 기저와 비트 값에 따라 광자의 편광 상태를 결정하여(예: 0은 수직 <code>|</code> 또는 45도 <code>/</code>, 1은 수평 <code>—</code> 또는 135도 <code>\</code>) 하나씩 수신자 밥에게 전송한다.</p>
</li>
<li>
<p>밥은 각 광자를 수신할 때마다, 앨리스와는 독립적으로 두 기저(<code>+</code> 또는 <code>×</code>) 중 하나를 무작위로 선택하여 광자의 편광을 측정하고 그 결과를 기록한다.</p>
</li>
<li>
<p>모든 전송이 끝난 후, 앨리스와 밥은 (도청 가능성이 있는) 공개 채널을 통해 각 광자를 측정할 때 사용했던 <strong>기저의 순서</strong>만을 서로 비교한다.</p>
</li>
<li>
<p>두 사람이 <strong>우연히 동일한 기저를 사용한 경우</strong>의 비트들만 남기고, 서로 다른 기저를 사용한 경우의 비트들은 모두 버린다. 이론적으로 약 50%의 비트가 남게 된다.</p>
</li>
<li>
<p>이렇게 남은 비트열이 바로 앨리스와 밥만이 공유하는 비밀키가 된다. 만약 도청자가 중간에 개입했다면, 남은 비트열에 높은 오류율이 나타나므로 도청 사실을 탐지할 수 있다.128</p>
</li>
</ol>
<ul>
<li><strong>보안성:</strong> QKD의 보안성은 **복제 불가능 정리(No-cloning theorem)**에 의해 더욱 강화된다. 이 정리에 따르면, 미지의 양자 상태를 완벽하게 복제하는 것은 물리적으로 불가능하다. 따라서 공격자는 전송 중인 광자를 몰래 복사하여 측정하고 원본을 그대로 다시 보내는 방식의 공격을 수행할 수 없다.130</li>
</ul>
<h3>7.4  PQC 대 QKD: 두 접근법 비교</h3>
<p>양자 시대의 암호학은 ’수학적 안전성’에 기반한 PQC와 ’물리적 안전성’에 기반한 QKD라는 두 가지 경로로 나아가고 있다. 두 기술은 양자 위협에 대응한다는 공통의 목표를 가지지만, 그 철학과 실용성 면에서 큰 차이를 보인다.</p>
<p>PQC는 양자 컴퓨터가 풀기 어려운 새로운 수학 문제를 찾아내어 기존의 공개키 암호 알고리즘을 대체하는, 본질적으로 <strong>소프트웨어적인 접근법</strong>이다. 이는 기존의 인터넷 인프라와의 호환성을 중시하는 <strong>‘진화적’</strong> 접근 방식으로, 저렴한 비용으로 넓은 범위에 걸쳐 즉시 배포할 수 있다는 강력한 장점을 가진다.119</p>
<p>반면, QKD는 도청 행위 자체가 물리 법칙에 의해 탐지되도록 하여 키 분배의 안전성을 보장하는 <strong>물리적인 접근법</strong>이다. 이는 새로운 물리적 인프라(전용 광섬유, 위성 등)를 요구하는 <strong>‘혁명적’</strong> 접근 방식이다.119 QKD는 이론적으로 정보이론적 안전성(information-theoretic security)을 제공하여 미래의 어떠한 계산 능력 발전과도 무관하게 안전하다는 장점이 있다. 하지만 전용 하드웨어가 필요하여 비용이 매우 높고, 광자 손실로 인한 거리 제한(현재 약 100~200km)이 있으며, 서비스 거부(DoS) 공격에 취약하다는 단점이 있다.129 또한, QKD는 이름 그대로 키 ‘분배’ 문제만을 해결할 뿐, 통신 상대방을 인증하거나 디지털 서명을 생성하는 기능은 제공하지 않으므로, 이러한 기능들을 위해서는 여전히 PQC와 같은 고전적 암호 기술에 의존해야 하는 한계가 있다.129</p>
<p>이러한 실용성과 확장성의 차이로 인해, 미국 NSA를 포함한 주요 보안 기관들은 현재 단기적이고 범용적인 해결책으로 PQC의 표준화와 도입에 집중하고 있다.123 QKD는 국방, 금융 등 극도로 높은 보안이 요구되는 특정 지점 간(point-to-point) 통신에 제한적으로 사용될 가능성이 높다.</p>
<table><thead><tr><th>구분</th><th>양자내성암호 (PQC)</th><th>양자 키 분배 (QKD)</th></tr></thead><tbody>
<tr><td><strong>기본 원리</strong></td><td><strong>수학적 복잡성:</strong> 양자컴퓨터로도 풀기 어려운 수학 문제에 기반</td><td><strong>물리적 법칙:</strong> 양자역학 원리(불확정성, 복제불가)에 기반</td></tr>
<tr><td><strong>구현 방식</strong></td><td>소프트웨어 기반 알고리즘</td><td>하드웨어 기반 시스템 (광자 송수신기, 전용 광섬유 등)</td></tr>
<tr><td><strong>인프라 호환성</strong></td><td>기존 인터넷 및 통신 인프라와 호환 가능 (소프트웨어 업그레이드)</td><td>전용 물리적 채널 필요 (호환성 낮음)</td></tr>
<tr><td><strong>주요 기능</strong></td><td>공개키 암호, 키 교환, 전자 서명 등 포괄적 기능 제공</td><td>암호키 ‘분배’ 기능에 특화됨 (인증 등은 별도 해결 필요)</td></tr>
<tr><td><strong>보안 보증</strong></td><td><strong>계산적 안전성:</strong> 현재 알려진 모든 공격에 대해 안전함 (미래에 새로운 알고리즘 발견 시 깨질 수 있음)</td><td><strong>정보이론적 안전성 (이론상):</strong> 물리 법칙에 의해 도청이 원천적으로 탐지됨 (구현상의 취약점 존재 가능)</td></tr>
<tr><td><strong>장점</strong></td><td>저비용, 높은 확장성, 즉시 배포 가능, 다양한 기능</td><td>이론적으로 완벽한 기밀성, 미래의 계산 능력 발전과 무관</td></tr>
<tr><td><strong>단점</strong></td><td>새로운 수학적 난제에 대한 신뢰도 검증 필요, 키/서명 크기 증가</td><td>고비용, 거리 제한, 특수 장비 필요, 서비스 거부(DoS) 공격에 취약</td></tr>
<tr><td><strong>현재 상태</strong></td><td>NIST 주도 표준화 완료 및 상용화 시작</td><td>연구 및 일부 특수 목적(국방, 금융) 네트워크에 시범 적용</td></tr>
</tbody></table>
<h2>8. 결론: 끊임없이 진화하는 암호학의 미래</h2>
<p>암호학은 고대 스파르타의 스키테일에서부터 현대의 양자내성암호에 이르기까지 수천 년에 걸쳐 인류의 역사와 함께 발전해왔다. 초기에는 군사적, 정치적 목적의 비밀 통신을 위한 기술에 머물렀으나, 컴퓨터와 인터넷의 등장은 암호학을 현대 디지털 사회의 신뢰를 구축하고 유지하는 핵심 기반 기술로 탈바꿈시켰다. 오늘날 암호 기술 없이는 안전한 전자상거래, 금융 거래, 개인 프라이버시 보호, 나아가 탈중앙화된 블록체인 시스템의 운영조차 상상할 수 없다.</p>
<p>본 보고서는 암호학의 기본 원칙인 기밀성, 무결성, 인증, 부인 방지에서 출발하여, 고전 암호의 역사적 교훈을 되짚어 보았다. 이어 현대 암호학의 양대 산맥인 대칭키 암호와 공개키 암호의 작동 원리, 대표적인 알고리즘인 AES와 RSA, ECC의 구조와 특징을 심층적으로 분석했다. 또한, 데이터 무결성의 초석인 암호학적 해시 함수의 원리를 탐구하고, 이러한 기본 요소들이 결합하여 전자 서명, SSL/TLS, 블록체인, 종단간 암호화와 같은 복잡하고 정교한 응용 시스템을 어떻게 구현하는지 살펴보았다.</p>
<p>이제 암호학은 양자 컴퓨터라는 역사상 가장 큰 패러다임 전환의 문턱에 서 있다. 쇼어의 알고리즘은 현재 우리가 의존하는 대부분의 공개키 암호 체계를 무력화할 잠재력을 지니고 있으며, 이는 디지털 사회의 신뢰 기반 전체를 위협하는 실존적 도전이다. 이에 대응하기 위한 양자내성암호(PQC)와 양자 키 분배(QKD)에 대한 전 세계적인 연구 경쟁은 암호학의 지평을 수학과 컴퓨터 과학을 넘어 물리학의 영역까지 확장시키고 있다. PQC가 기존 인프라와의 호환성을 바탕으로 실용적인 해결책으로 부상하고 있는 반면, QKD는 물리 법칙에 기반한 궁극적인 보안을 향한 장기적인 비전을 제시한다.</p>
<p>미래의 암호학은 이처럼 수학, 컴퓨터 과학, 물리학이 긴밀하게 융합되는 고도의 학제적 연구를 통해 더욱 발전할 것이다. 끊임없이 등장하는 새로운 공격 기법과 계산 패러다임에 맞서, 안전하고 신뢰할 수 있는 디지털 미래를 보장하기 위한 암호학자들의 노력은 계속될 것이다. 이를 위해 강력한 암호 알고리즘의 개발뿐만 아니라, 이를 안전하게 구현하고 검증하며, 국제적인 표준화를 통해 상호 운용성을 확보하려는 지속적인 노력이 그 어느 때보다 중요해질 것이다. 암호학은 과거에도 그랬듯, 앞으로도 보이지 않는 곳에서 우리 디지털 문명의 근간을 지키는 수호자로서 그 역할을 다할 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>기초암호학 - 교수님 이건 아니잖아요 - 티스토리, https://no-more-assignment.tistory.com/154</li>
<li>암호 이야기 I – 과거의 암호(고대~근대) - STAR Library, https://starlibrary.org/ecollection/infogudIemList.do?id=GUD00000000000001082</li>
<li>chap2. 암호학 - DevSecOps - 티스토리, https://bziwnsizd.tistory.com/49</li>
<li>암호학 1 - 암호의 개념 및 원리 + Steganograhpy - 공부 기록 - 티스토리, https://lemonandgrapefruit.tistory.com/139</li>
<li>암호 (암호학) - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8_(%EC%95%94%ED%98%B8%ED%95%99)">https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8_(%EC%95%94%ED%98%B8%ED%95%99)</a></li>
<li>암호화의 중요성과 그 역사적 배경에 대한 개요, https://www.redhat.com/ko/blog/brief-history-cryptography</li>
<li>암호화란 무엇인가요? - AWS, https://aws.amazon.com/ko/what-is/cryptography/</li>
<li>What is Cryptography? - AWS, https://aws.amazon.com/what-is/cryptography/</li>
<li>Cryptography 101: Key Principles, Major Types, Use Cases &amp; Algorithms | Splunk, https://www.splunk.com/en_us/blog/learn/cryptography.html</li>
<li>What is the CIA Triad and Why is it important? - Fortinet, https://www.fortinet.com/resources/cyberglossary/cia-triad</li>
<li>The Five Pillars of Information Security: CIA Triad and More - Destination Certification, https://destcert.com/resources/five-pillars-information-security/</li>
<li>5 Principles of Information Assurance - Sentient Digital, Inc., https://sdi.ai/blog/5-principles-of-information-assurance/</li>
<li>Authenticity vs. Non-Repudiation - UpGuard, https://www.upguard.com/blog/authenticity-vs-non-repudiation</li>
<li>비트코인 시스템의 이해 - 암호학 용어 설명(공개키, 해시, 전자서명) - CryptoCurrencyAnalysis, https://choikhyang.tistory.com/9</li>
<li>암호학 기초 개념, <a href="https://kali-km.tistory.com/entry/%EC%95%94%ED%98%B8%ED%95%99-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90">https://kali-km.tistory.com/entry/%EC%95%94%ED%98%B8%ED%95%99-%EA%B8%B0%EC%B4%88-%EA%B0%9C%EB%85%90</a></li>
<li>암호학 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99">https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%95%99</a></li>
<li>[암호화] 암호 &amp; 암호화 역사 - PSTOR BLOG, http://pstor.dev/csc/cryptographic-history/</li>
<li>RSA 암호의 수학적 원리 - 암호의 역사를 바탕으로 - 뉴스룸 - 자연과학대학 - 서울대학교, https://science.snu.ac.kr/newsroom/view/2/11/992</li>
<li>스키테일 암호 만들기 - 2016 수학체험프로그램개발 학습지 예시 자료, <a href="https://www.scienceall.com/jnrepo/uploads/2022/03/%EC%8A%A4%ED%82%A4%ED%85%8C%EC%9D%BC-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0.pdf">https://www.scienceall.com/jnrepo/uploads/2022/03/%EC%8A%A4%ED%82%A4%ED%85%8C%EC%9D%BC-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0.pdf</a></li>
<li>(암호학) 004. 스키테일 암호 - Scytale Cipher, https://namhoon.kim/2022/09/14/crypto-theory/004/index.html</li>
<li>가장 안전한 암호 기술을 찾아서 - ETRI WEBZINE Vol.234, https://www.etri.re.kr/webzine/20231013/sub01.html</li>
<li>seed.kisa.or.kr, <a href="https://seed.kisa.or.kr/kisa/intro/EgovHistory.do#:~:text=%EC%8B%9C%EC%A0%80(Caesar)%20%EC%95%94%ED%98%B8&amp;text=%EC%8B%9C%EC%A0%80%EB%8A%94%20%EA%B0%80%EC%A1%B1%EA%B3%BC%20%EB%B9%84%EB%B0%80,%ED%8F%89%EB%AC%B8%EC%9D%84%20%EC%96%BB%EC%9D%84%20%EC%88%98%20%EC%9E%88%EB%8B%A4.">https://seed.kisa.or.kr/kisa/intro/EgovHistory.do#:~:text=%EC%8B%9C%EC%A0%80(Caesar)%20%EC%95%94%ED%98%B8&amp;text=%EC%8B%9C%EC%A0%80%EB%8A%94%20%EA%B0%80%EC%A1%B1%EA%B3%BC%20%EB%B9%84%EB%B0%80,%ED%8F%89%EB%AC%B8%EC%9D%84%20%EC%96%BB%EC%9D%84%20%EC%88%98%20%EC%9E%88%EB%8B%A4.</a></li>
<li>카이사르가 사용한 간단한 암호 체계 - 아틀라스뉴스, http://www.atlasnews.co.kr/news/curationView.html?idxno=8119</li>
<li>카이사르 암호분석 - 기억정리 - 티스토리, https://revivekirin-studying.tistory.com/3</li>
<li>카이사르 암호(Caesar cipher) - 기계인간 John Grib, https://johngrib.github.io/wiki/crypto/caesar/</li>
<li>카이사르 암호 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%B9%B4%EC%9D%B4%EC%82%AC%EB%A5%B4_%EC%95%94%ED%98%B8">https://ko.wikipedia.org/wiki/%EC%B9%B4%EC%9D%B4%EC%82%AC%EB%A5%B4_%EC%95%94%ED%98%B8</a></li>
<li>History of cryptography - Wikipedia, https://en.wikipedia.org/wiki/History_of_cryptography</li>
<li>암호학 - 나무위키, <a href="https://namu.wiki/w/%EC%95%94%ED%98%B8%ED%95%99">https://namu.wiki/w/%EC%95%94%ED%98%B8%ED%95%99</a></li>
<li>A brief history of encryption (and cryptography) - Thales, https://www.thalesgroup.com/en/markets/digital-identity-and-security/magazine/brief-history-encryption</li>
<li>A Brief History of Cryptography - Red Hat, https://www.redhat.com/en/blog/brief-history-cryptography</li>
<li>[정보보안] 7. 블록 암호 - DES - Progrow - 티스토리, https://somuchthings.tistory.com/122</li>
<li>Timeline of cryptography - Wikipedia, https://en.wikipedia.org/wiki/Timeline_of_cryptography</li>
<li>암호학의 역사와 블록체인 — 탈중앙화 혁신. - Medium, <a href="https://medium.com/gopax/%EC%95%94%ED%98%B8%ED%95%99%EC%9D%98-%EC%97%AD%EC%82%AC%EC%99%80-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%83%88%EC%A4%91%EC%95%99%ED%99%94-%ED%98%81%EC%8B%A0-80ab900c0b6a">https://medium.com/gopax/%EC%95%94%ED%98%B8%ED%95%99%EC%9D%98-%EC%97%AD%EC%82%AC%EC%99%80-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%83%88%EC%A4%91%EC%95%99%ED%99%94-%ED%98%81%EC%8B%A0-80ab900c0b6a</a></li>
<li>공개키 암호 (Public key Cryptography) - Shine’s dev log - 티스토리, https://ddongwon.tistory.com/41</li>
<li>소개 - 암호기술의 정의 - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/intro/EgovDefinition.do</li>
<li>AES 알고리즘의 특징 및 Cipher Mode, https://sym312.tistory.com/16</li>
<li>[컴퓨터개론] 암호화(대칭키 vs 공개키(비대칭키)) - 소프트웨어전공생 끄적끄적, <a href="https://seung-nari.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%9D%B4%EB%A1%A0-%EC%95%94%ED%98%B8%ED%99%94%EB%8C%80%EC%B9%AD%ED%82%A4-vs-%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4">https://seung-nari.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%9D%B4%EB%A1%A0-%EC%95%94%ED%98%B8%ED%99%94%EB%8C%80%EC%B9%AD%ED%82%A4-vs-%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4</a></li>
<li>대칭키와 비대칭키/공개키 - velog, <a href="https://velog.io/@octo__/%EB%8C%80%EC%B9%AD%ED%82%A4%EC%99%80-%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4">https://velog.io/@octo__/%EB%8C%80%EC%B9%AD%ED%82%A4%EC%99%80-%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4</a></li>
<li>대칭키 암호화 방식 - PSD( Private-Self-Development ) - 티스토리, https://chjysm.tistory.com/10</li>
<li>대칭키와 공개키 이해하기 - HyunGyu, https://gusrb3164.github.io/computer-science/2021/02/03/symmetric,-public-key/</li>
<li>DES - IT 위키, https://itwiki.kr/w/DES</li>
<li>[보안 프로토콜] Triple-DES, AES 소개 - Part 1, https://singularis7.tistory.com/44</li>
<li>[보.알.남] 30년간 국가표준 암호기술로 자리매김한 ’DES’의 역사 - 보안뉴스, https://m.boannews.com/html/detail.html?idx=112953</li>
<li>DES 강의 by guardian, https://mytears.org/resources/doc/Encode/des.html</li>
<li>블록 암호 방식 - DES, https://continuetochallenge.tistory.com/81</li>
<li>기초 암호학(2) - AES - 나를위한노트 - 티스토리, https://developer-mac.tistory.com/59</li>
<li>sym312.tistory.com, <a href="https://sym312.tistory.com/16#:~:text=%EC%95%94%ED%98%B8%ED%99%94%20%ED%82%A4%EC%9D%98%20%EA%B8%B8%EC%9D%B4%EA%B0%80,%EB%B8%94%EB%9F%AD%20%EC%95%94%ED%98%B8%ED%99%94%2C%20%EC%96%91%EB%B0%A9%ED%96%A5%20%EC%95%94%ED%98%B8%ED%99%94%EC%9D%B4%EB%8B%A4.&amp;text=%EC%95%94%ED%98%B8%ED%99%94%EC%99%80%20%EB%B3%B5%ED%98%B8%ED%99%94%EB%A5%BC%20%EB%AA%A8%EB%91%90,%EC%A0%88%EB%8C%80%20%EB%85%B8%EC%B6%9C%EB%90%98%EC%84%9C%EB%8A%94%20%EC%95%88%EB%90%9C%EB%8B%A4.">https://sym312.tistory.com/16#:~:text=%EC%95%94%ED%98%B8%ED%99%94%20%ED%82%A4%EC%9D%98%20%EA%B8%B8%EC%9D%B4%EA%B0%80,%EB%B8%94%EB%9F%AD%20%EC%95%94%ED%98%B8%ED%99%94%2C%20%EC%96%91%EB%B0%A9%ED%96%A5%20%EC%95%94%ED%98%B8%ED%99%94%EC%9D%B4%EB%8B%A4.&amp;text=%EC%95%94%ED%98%B8%ED%99%94%EC%99%80%20%EB%B3%B5%ED%98%B8%ED%99%94%EB%A5%BC%20%EB%AA%A8%EB%91%90,%EC%A0%88%EB%8C%80%20%EB%85%B8%EC%B6%9C%EB%90%98%EC%84%9C%EB%8A%94%20%EC%95%88%EB%90%9C%EB%8B%A4.</a></li>
<li>안전한 암호화를 위한 AES 알고리즘에 대한 이해와 구현코드(Java, C#) - 개발한입, https://brewagebear.github.io/aes-algorithm-and-chiper-mode/</li>
<li>AES(Advanced Encryption Standard) 구조 - 0110 - 티스토리, <a href="https://tkdguq0110.tistory.com/entry/AESAdvanced-Encryption-Standard-%EA%B5%AC%EC%A1%B0">https://tkdguq0110.tistory.com/entry/AESAdvanced-Encryption-Standard-%EA%B5%AC%EC%A1%B0</a></li>
<li>AES 암호화 알고리즘 - jjuya - 티스토리, https://jjuya.tistory.com/m/199</li>
<li>대칭키, 공개키 암호화 방식 - 하루한방울 - 티스토리, https://gunjoon.tistory.com/149</li>
<li>공개키 암호와 해시를 이용한 인증 원리 - tae3log - 티스토리, https://taesam.tistory.com/24</li>
<li>기초 암호학(3) - 공개키 암호 (RSA, Diffie-Helmman) - 나를위한노트, https://developer-mac.tistory.com/76</li>
<li>A Study of Field Application Process of Public Key Algorithm RSA …, https://koreascience.kr/article/JAKO201534853187738.pdf</li>
<li>[논문]수학원리와 특성 진단을 기반으로 한 공개키 RSA 알고리즘의 현장 적용 프로세스 - 사이언스온, https://scienceon.kisti.re.kr/srch/selectPORSrchArticle.do?cn=JAKO201534853187738</li>
<li>공개 키 암호 방식 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D">https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D</a></li>
<li>RSA 암호화 수학적 원리 이해하기 :: 코딩수집, https://westlife0615.tistory.com/296</li>
<li>RSA (explained step by step) - CrypTool, https://www.cryptool.org/en/cto/rsa-step-by-step/</li>
<li>RSA cryptosystem - Wikipedia, https://en.wikipedia.org/wiki/RSA_cryptosystem</li>
<li>RSA 암호화 - RSA의 작동 원리 — 예지, https://miho273.tistory.com/40</li>
<li>타원곡선 암호 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0_%EC%95%94%ED%98%B8">https://ko.wikipedia.org/wiki/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0_%EC%95%94%ED%98%B8</a></li>
<li>– ECC 알고리즘 - 아이리포, https://www.ilifo.co.kr/files/board/167/1/download/20180628094950509.pdf</li>
<li>타원곡선암호 (Elliptic Curve Cryptography) 정리 :: 잉여의 생각저장소, https://chocolate-life.tistory.com/6</li>
<li>타원 곡선 암호(Elliptic Curve Cryptography) - Shine’s dev log - 티스토리, https://ddongwon.tistory.com/54</li>
<li>[논문]RSA와 ECC암호화 방법의 비교분석 - 한국과학기술정보연구원, https://scienceon.kisti.re.kr/srch/selectPORSrchArticle.do?cn=DIKO0011787764</li>
<li>RSA와 ECC 소개 및 비교 - 두아앙의 기록보관소 - 티스토리, <a href="https://sdk-archives.tistory.com/entry/RSA%EC%99%80-ECC">https://sdk-archives.tistory.com/entry/RSA%EC%99%80-ECC</a></li>
<li>ECC vs RSA Comparison: What’s the Technical Difference? - SSLInsights, https://sslinsights.com/ecc-vs-rsa/</li>
<li>ECC vs RSA vs DSA - Encryption Differences | Sectigo® Official, https://www.sectigo.com/resource-library/rsa-vs-dsa-vs-ecc-encryption</li>
<li>블록체인을 위한 암호학4. 공개키 암호와 hash를 이용한 전자서명 | by Jang Jiho | De-Butler, <a href="https://medium.com/de-butler/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%95%94%ED%98%B8%ED%95%993-a5239c36d93b">https://medium.com/de-butler/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%95%94%ED%98%B8%ED%95%993-a5239c36d93b</a></li>
<li>블록체인 해시함수 | 정의, 특징, 블록체인 활용 예시 - 코드스테이츠 공식 블로그, <a href="https://www.codestates.com/blog/content/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98">https://www.codestates.com/blog/content/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98</a></li>
<li>해시 함수_Hash Function(정보보안기사) - Connecting the Dots. - 티스토리, <a href="https://louis-j.tistory.com/entry/%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98Hash-Function%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EA%B8%B0%EC%82%AC">https://louis-j.tistory.com/entry/%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98Hash-Function%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EA%B8%B0%EC%82%AC</a></li>
<li>해시 알고리즘, 해시 함수, SHA(Secure Hash Algorithm), DES, AES, 블록체인, 위장 공격, 인증, https://swingswing.tistory.com/169</li>
<li>암호학) 단방향 해시함수 원리와 발생가능한 7개의 공격 - Medium, <a href="https://medium.com/curg/%EC%95%94%ED%98%B8%ED%95%99-chf-cryptographic-hash-function-%EC%95%94%ED%98%B8%ED%99%94-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-8e157ff89296">https://medium.com/curg/%EC%95%94%ED%98%B8%ED%95%99-chf-cryptographic-hash-function-%EC%95%94%ED%98%B8%ED%99%94-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-8e157ff89296</a></li>
<li>해시함수 - 정보보안 - Bluesplatter, https://www.bluesplatter.com/is_certification/IS-Management-HashAlgorithm/</li>
<li>암호화 해시 함수 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98">https://ko.wikipedia.org/wiki/%EC%95%94%ED%98%B8%ED%99%94_%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98</a></li>
<li>비밀번호 단방향 암호화: 가변솔트와 반복해싱(Dynamic Salting and Iterative Hashing), https://blog.letsdev.me/password-encryption-concept-kor</li>
<li>[Security] 암호화/복호화 이해하기 -1 : 기초, 암호화 종류(단방향, 양방향) - Contributor9, https://adjh54.tistory.com/527</li>
<li>정보보안기사 개인 정리 05 - 해시함수와 응용 - 루베리, https://luvery93.github.io/articles/2017-08/information-security-cert-05</li>
<li>해시 함수 (HASH)로 데이터 무결성 검증하기 - Db2 스토리, https://db2story.tistory.com/16</li>
<li>2 - 해시함수란 무엇인가? - Steemit, https://steemit.com/kr/@yahweh87/2</li>
<li>패스워드의 암호화와 저장 - Hash(해시)와 Salt(솔트) - Stranger’s LAB - 티스토리, https://st-lab.tistory.com/100</li>
<li>Salt(솔트)란? - @soheeeeP: Log - 티스토리, https://soheeeep.tistory.com/47</li>
<li>패스워드 암호화(해시, 솔트, 키스트레칭) - Tools in hand, brain in gear. - 티스토리, https://shurimp.tistory.com/45</li>
<li>비밀번호 암호화 - bcrypt - JIN_CODER - 티스토리, <a href="https://jin-coder.tistory.com/entry/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%95%94%ED%98%B8%ED%99%94-bcrypt">https://jin-coder.tistory.com/entry/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%95%94%ED%98%B8%ED%99%94-bcrypt</a></li>
<li>안전한 패스워드 저장 - NAVER, https://d2.naver.com/helloworld/318732</li>
<li>디지털 서명 &amp; PKI - Shine’s dev log - 티스토리, https://ddongwon.tistory.com/57</li>
<li>[HTTP완벽가이드] 전자서명 - 내가 하고 싶은 건, - 티스토리, https://plus-op.tistory.com/10</li>
<li>[Security] 전자서명 완벽 가이드: 개념부터 활용까지 한번에 이해하기 - 어제, 오늘 그리고 내일, https://eunplay.tistory.com/122</li>
<li>공개키 암호와 디지털 서명 - hmm. 하나고등학교 학생 매거진., https://hashmm.com/post/pkcrypto-and-digitalsigning/index.html</li>
<li>암호학 7 - 공개키와 비밀키를 이용한 전자서명 및 인증서 - 공부 기록 - 티스토리, https://lemonandgrapefruit.tistory.com/163</li>
<li>전자서명 - 자바시작 워니, https://oneny.tistory.com/m/69</li>
<li>SLH-DSA 기반 디지털 서명 및 검증 FPGA 시스템 구현 - Korea Science, https://koreascience.kr/article/JAKO202401650401760.pdf</li>
<li>전자서명에 대한 전반적인 이해 - Sunghwan’s blog, https://sunghwan7330.github.io/infomation/info_digital_signature/</li>
<li>TLS 핸드셰이크란? | 세션키 교환 - Cloudflare, https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/</li>
<li>TLS Handshake - velog, https://velog.io/@emotional_dev/TLS-Handshake</li>
<li>TLS/SSL Handshake (SSL인증서) - 하루에 하나씩 - 티스토리, https://1stepby1step.tistory.com/153</li>
<li>TLS Handshake / SSL Process - Nightcrawler - 티스토리, https://net-gate.tistory.com/35</li>
<li>SSL/TLS 인증서 동작 이해하기 1 - flavono123, https://flavono123.github.io/posts/understand-tls-certificate-with-hand-on-practice-1/</li>
<li>Ⅱ. 블록체인의 이해, <a href="https://www.kiri.or.kr/pdf/%EC%97%B0%EA%B5%AC%EC%9E%90%EB%A3%8C/%EC%97%B0%EA%B5%AC%EB%B3%B4%EA%B3%A0%EC%84%9C/nre2018-24_02.pdf">https://www.kiri.or.kr/pdf/%EC%97%B0%EA%B5%AC%EC%9E%90%EB%A3%8C/%EC%97%B0%EA%B5%AC%EB%B3%B4%EA%B3%A0%EC%84%9C/nre2018-24_02.pdf</a></li>
<li>블록체인 해시 및 해시 함수: 알아야 할 사항 - Plisio, https://plisio.net/ko/blog/how-does-hashing-in-blockchain-work</li>
<li>ECDSA (타원곡선 암호) - 니엘의 개발일지 - 티스토리, <a href="https://wisysta.tistory.com/entry/ECDSA-%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0-%EC%95%94%ED%98%B8">https://wisysta.tistory.com/entry/ECDSA-%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0-%EC%95%94%ED%98%B8</a></li>
<li>타원곡선암호 - 위키원, http://wiki.hash.kr/index.php/ECC</li>
<li>
<ol>
<li>타원곡선 디지털 서명 알고리즘(ECDSA) - IT 공부 - 티스토리, https://ljy98.tistory.com/134</li>
</ol>
</li>
<li>타원곡선 키 톺아보기 - Medium, <a href="https://medium.com/decipher-media/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0-%ED%82%A4-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0-1d84cbb0eb8a">https://medium.com/decipher-media/%ED%83%80%EC%9B%90%EA%B3%A1%EC%84%A0-%ED%82%A4-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0-1d84cbb0eb8a</a></li>
<li>비트코인 속으로 들어간 타원곡선 [2]: 디지털서명 알고리듬 - 고등과학원 HORIZON, https://horizon.kias.re.kr/23225/</li>
<li>밑바닥부터 시작하는 비트코인 - 3장 타원곡선 암호 - 개발 코어 강화 일지, https://piatoss3612.tistory.com/17</li>
<li>엔드투엔드 암호화(E2EE)란 무엇인가요? - IBM, https://www.ibm.com/kr-ko/topics/end-to-end-encryption</li>
<li>종단간 암호화(E2EE) - 토스페이먼츠 개발자센터, https://docs.tosspayments.com/resources/glossary/e2ee</li>
<li>종단간 암호화 - 나무위키, <a href="https://namu.wiki/w/%EC%A2%85%EB%8B%A8%EA%B0%84%20%EC%95%94%ED%98%B8%ED%99%94">https://namu.wiki/w/%EC%A2%85%EB%8B%A8%EA%B0%84%20%EC%95%94%ED%98%B8%ED%99%94</a></li>
<li>The Double Ratchet Algorithm - Signal, https://signal.org/docs/specifications/doubleratchet/doubleratchet.pdf</li>
<li>Double Ratchet Algorithm - Wikipedia, https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm</li>
<li>Specifications &gt;&gt; The Double Ratchet Algorithm - Signal, https://signal.org/docs/specifications/doubleratchet/</li>
<li>Trying to understand Signal’s double ratchet protocol : r/cryptography - Reddit, https://www.reddit.com/r/cryptography/comments/1ms1rr6/trying_to_understand_signals_double_ratchet/</li>
<li>양자 암호 - 쇼어 (Shor) 알고리즘, 그로버(Grover) 알고리즘 - Char - 티스토리, https://charstring.tistory.com/11</li>
<li>쇼어 알고리즘 - 나무위키, <a href="https://namu.wiki/w/%EC%87%BC%EC%96%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/%EC%87%BC%EC%96%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a></li>
<li>[기획] 현대 암호 체계를 무력화하는 양자 알고리즘 | 과학기술커리어트렌드 - W브릿지, https://www.wbridge.or.kr/platform/careersport/info/selectTrendDetail.do?ntt_sn=652</li>
<li>4화. 양자 컴퓨터의 활용 가능성과 보안 암호에 대한 위협, https://kbthink.com/main/economy/economic-in-depth-analysis/economic-research-report/series5-230207-1.html</li>
<li>양자 알고리즘 : Grover 알고리즘, Shor 알고리즘의 이론 및 구현 - To the moon - 티스토리, <a href="https://artemis69.tistory.com/entry/%EC%96%91%EC%9E%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Grover-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Shor-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%9D%B4%EB%A1%A0-%EB%B0%8F-%EA%B5%AC%ED%98%84">https://artemis69.tistory.com/entry/%EC%96%91%EC%9E%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Grover-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Shor-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%9D%B4%EB%A1%A0-%EB%B0%8F-%EA%B5%AC%ED%98%84</a></li>
<li>Quantum Cryptography vs. Post-Quantum Cryptography: What’s the Difference? - Synopsys, https://www.synopsys.com/blogs/chip-design/quantum-cryptography-vs-post-quantum-cryptography.html</li>
<li>양자내성암호 - 위키원 - 해시넷, <a href="http://wiki.hash.kr/index.php/%EC%96%91%EC%9E%90%EB%82%B4%EC%84%B1%EC%95%94%ED%98%B8">http://wiki.hash.kr/index.php/%EC%96%91%EC%9E%90%EB%82%B4%EC%84%B1%EC%95%94%ED%98%B8</a></li>
<li>PQC, 양자 컴퓨팅 시대의 암호화 기술 - NordVPN, https://nordvpn.com/ko/blog/what-is-post-quantum-cryptography/</li>
<li>Difference Between Post-Quantum Crypto &amp; Quantum Crypto - Fortanix, https://www.fortanix.com/blog/difference-between-post-quantum-crypto-and-quantum-crypto</li>
<li>High Level Differences Between PQC and QKD - SylLab Systems, https://www.syllab.io/wp/pqc-vs-qkd/</li>
<li>양자 내성 암호 알고리즘 (PQC) - Char - 티스토리, https://charstring.tistory.com/638</li>
<li>양자내성암호화(PQC), [한영식 사견임], https://hanys002.tistory.com/20</li>
<li>차세대 암호 - 양자내성암호 - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/ngc/pqc.do</li>
<li>양자 내성 암호화 및 암호화 기법 종합 가이드 - Entrust, https://www.entrust.com/ko/resources/learn/post-quantum-cryptography-and-encryption</li>
<li>양자키분배와 IPSec을 결합한 네트워크 보안 장치 연구 - Korea Science, https://koreascience.kr/article/JAKO202129857870067.pdf</li>
<li>Quantum Key Distribution (QKD) and Quantum Cryptography QC - National Security Agency, https://www.nsa.gov/Cybersecurity/Quantum-Key-Distribution-QKD-and-Quantum-Cryptography-QC/</li>
<li>양자 키 분배 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%96%91%EC%9E%90_%ED%82%A4_%EB%B6%84%EB%B0%B0">https://ko.wikipedia.org/wiki/%EC%96%91%EC%9E%90_%ED%82%A4_%EB%B6%84%EB%B0%B0</a></li>
<li>양자 통신 및 양자 암호의 개요, <a href="https://scienceon.kisti.re.kr/commons/util/originalView.do?cn=JAKO201511059258741&amp;dbt=JAKO&amp;koi=KISTI1.1003/JNL.JAKO201511059258741">https://scienceon.kisti.re.kr/commons/util/originalView.do?cn=JAKO201511059258741&amp;dbt=JAKO&amp;koi=KISTI1.1003%2FJNL.JAKO201511059258741</a></li>
<li>TrUE vs. QKD vs. PQC | Enterprise - Quantropi, https://www.quantropi.com/true-vs-qkd-vs-pqc-know-the-difference/</li>
<li>What is Post-Quantum Cryptography (PQC)? - Palo Alto Networks, https://www.paloaltonetworks.com/cyberpedia/what-is-post-quantum-cryptography-pqc</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>