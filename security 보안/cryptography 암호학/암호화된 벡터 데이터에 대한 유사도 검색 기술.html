<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:암호화된 벡터 데이터에 대한 유사도 검색 기술 고찰</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>암호화된 벡터 데이터에 대한 유사도 검색 기술 고찰</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">정보 보안 (Information Security)</a> / <a href="index.html">암호학</a> / <span>암호화된 벡터 데이터에 대한 유사도 검색 기술 고찰</span></nav>
                </div>
            </header>
            <article>
                <h1>암호화된 벡터 데이터에 대한 유사도 검색 기술 고찰</h1>
<h2>1. 서론: 벡터 데이터 시대의 프라이버시 역설</h2>
<p>생성형 인공지능(AI) 시대가 도래하며 벡터 데이터베이스는 현대 기술 스택의 핵심 인프라로 급부상하였다. 검색 증강 생성(RAG), 추천 시스템, 이미지 및 음성 검색 등 다양한 응용 분야에서 비정형 데이터를 의미적 관계를 포착하는 고차원 벡터로 변환하여 저장하고, 이를 유사도 기반으로 신속하게 검색하는 패러다임이 보편화된 것이다.1 이러한 벡터 데이터는 단순한 정보를 넘어, 개인 식별 정보(PII), 의료 기록, 금융 정보, 기업의 핵심 지적 재산(IP)과 같이 지극히 민감한 내용을 내포하는 경우가 많다.1</p>
<p>데이터의 가치가 높아짐에 따라, 벡터 데이터베이스는 사이버 공격, 내부자 위협, 무단 접근 등 악의적 행위자들의 매력적인 표적이 되고 있다. 만약 이러한 민감 데이터가 유출될 경우, 그 파급력은 막대한 금전적 손실과 규제 당국의 처벌을 넘어, 개인의 삶과 기업의 존속에 심각한 위협을 초래할 수 있다.1 특히 벡터 임베딩은 원본 데이터의 의미론적 정보를 고도로 압축하여 담고 있기 때문에 8, 단순히 암호화되지 않은 벡터가 유출되는 것만으로도 심각한 프라이버시 침해로 이어질 수 있다. 최근 연구들은 특정 임베딩 벡터로부터 원본 텍스트나 이미지를 상당 부분 복원해내는 ‘임베딩 역변환(Embedding Inversion)’ 공격의 가능성을 입증하였는데 9, 이는 벡터 데이터의 유출이 곧 사용자의 생각, 의도, 민감한 속성까지 추론되거나 복원될 수 있음을 시사한다. 이는 단순한 데이터 유출 리스크를 넘어, AI 서비스 자체에 대한 사용자의 신뢰를 근본적으로 훼손하는 ’신뢰의 위기’를 야기할 수 있다.</p>
<p>기존의 암호화 기술은 저장된 데이터(Data-at-rest)나 전송 중인 데이터(Data-in-transit)를 보호하는 데에는 효과적이지만, 데이터를 ‘사용’ 즉, 연산하기 위해서는 반드시 복호화해야 한다는 근본적인 한계를 지닌다.11 벡터 유사도 검색과 같은 연산을 수행하는 서버가 평문 데이터에 접근해야만 하는 현재의 구조에서는, 서버가 해킹되거나 악의적인 내부 관리자가 존재할 경우 데이터 프라이버시는 무력화될 수밖에 없다.</p>
<p>따라서, 데이터 활용과 프라이버시 보호라는 상충된 가치를 양립시키기 위해서는 새로운 패러다임이 요구된다. 데이터를 암호화된 상태 그대로 외부에 위탁하고, 복호화 과정 없이 그 위에서 직접 연산을 수행하는 ‘처리 중인 데이터(Data-in-use)’ 보호 기술이 바로 그것이다. 본 안내서는 이러한 ‘벡터 암호화’ 기술의 핵심 원리를 이론적, 수학적, 그리고 실용적 관점에서 심층적으로 고찰하고자 한다. 먼저 벡터 유사도 검색의 수학적 기초를 살펴보고, 이를 암호화된 상태에서 계산하기 위한 핵심 기술인 동형암호(Homomorphic Encryption)의 원리와 종류를 분석한다. 특히 실수 벡터 연산에 최적화된 CKKS 동형암호 스킴을 집중적으로 해부하고, 이를 이용해 코사인 유사도와 유클리드 거리를 계산하는 구체적인 방법을 제시한다. 나아가 실용적 구현의 난제와 최신 연구 동향, 그리고 타 프라이버시 보존 기술과의 비교를 통해 벡터 암호화 기술의 현재와 미래를 종합적으로 조망할 것이다.</p>
<h2>2.  벡터 유사도 검색의 수학적 원리</h2>
<p>벡터 데이터베이스의 핵심 기능은 주어진 질의 벡터와 가장 ‘유사한’ 벡터들을 데이터셋에서 찾아내는 것이다. 이때 ’유사도’를 어떻게 정의하고 측정하는지에 따라 검색의 결과와 성능이 결정된다. 다양한 유사도 측정 기법이 존재하지만, 가장 널리 사용되는 두 가지 방식은 유클리드 거리와 코사인 유사도이다.13</p>
<h3>2.1  유클리드 거리 (Euclidean Distance): 거리 기반 유사도</h3>
<p>유클리드 거리는 다차원 공간에 표현된 두 벡터, 즉 두 점 사이의 직선 거리를 측정하는 가장 직관적인 방법이다.14 두 벡터의 좌표 값 차이를 기반으로 계산되며, 이 거리가 짧을수록 두 벡터는 서로 가깝고, 따라서 유사도가 높다고 판단한다.15</p>
<p>n차원 공간상의 두 벡터 <span class="math math-inline">\mathbf{p} = (p_1, p_2, \dots, p_n)</span>와 <span class="math math-inline">\mathbf{q} = (q_1, q_2, \dots, q_n)</span>가 주어졌을 때, 두 벡터 사이의 유클리드 거리는 피타고라스 정리를 일반화하여 다음과 같이 정의된다.15</p>
<p><span class="math math-display">
d(\mathbf{p}, \mathbf{q}) = \sqrt{\sum_{i=1}^{n} (p_i - q_i)^2}
</span><br />
이 방식은 각 차원의 값, 즉 벡터의 크기(magnitude) 자체가 중요한 의미를 가지는 경우에 유용하다. 예를 들어, 이미지의 색상 분포나 센서 데이터 분석과 같이 각 차원의 절대적인 값이 객체의 특성을 직접적으로 나타낼 때 적합하다. 그러나 문서 데이터와 같이 벡터의 크기(예: 문서의 길이)보다 내용의 패턴이 더 중요한 경우에는 적합하지 않을 수 있다.</p>
<h3>2.2  코사인 유사도 (Cosine Similarity): 방향성 기반 유사도</h3>
<p>코사인 유사도는 두 벡터가 이루는 각도의 코사인 값을 이용하여 두 벡터의 ’방향’이 얼마나 유사한지를 측정하는 방법이다.16 벡터의 크기는 계산 과정에서 정규화되어 고려되지 않으며, 오직 두 벡터가 가리키는 방향의 일치도만을 평가한다.16 이는 벡터의 크기가 중요하지 않은 고차원 데이터, 특히 텍스트나 문서 데이터의 유사도를 측정하는 데 널리 사용된다.16</p>
<p>n차원 공간상의 두 벡터 <span class="math math-inline">\mathbf{A}</span>와 <span class="math math-inline">\mathbf{B}</span>가 주어졌을 때, 코사인 유사도는 두 벡터의 내적(dot product)을 각 벡터의 크기(L2-norm)의 곱으로 나누어 계산한다. 이는 벡터 내적의 기하학적 정의 <span class="math math-inline">\mathbf{A} \cdot \mathbf{B} = \|\mathbf{A}\| \|\mathbf{B}\| \cos(\theta)</span>로부터 유도된다.18</p>
<p><span class="math math-display">
\text{Cosine Similarity} = \cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{\|\mathbf{A}\| \|\mathbf{B}\|} = \frac{\sum_{i=1}^{n} A_i B_i}{\sqrt{\sum_{i=1}^{n} A_i^2} \sqrt{\sum_{i=1}^{n} B_i^2}}
</span><br />
코사인 유사도의 값은 <span class="math math-inline">-1</span>에서 <span class="math math-inline">1</span> 사이의 범위를 가진다. 값이 <span class="math math-inline">1</span>이면 두 벡터의 방향이 완전히 일치함을, <span class="math math-inline">0</span>이면 두 벡터가 직교(90도) 관계에 있음을, <span class="math math-inline">-1</span>이면 두 벡터가 정반대 방향을 가리킴을 의미한다. 따라서 값이 <span class="math math-inline">1</span>에 가까울수록 두 벡터의 유사도가 높다고 판단한다.18</p>
<h3>2.3  두 측정 방식의 비교 분석</h3>
<p>동일한 벡터 데이터셋에 대해서도 유클리드 거리와 코사인 유사도는 서로 다른 유사도 순위를 도출할 수 있다.14 이는 두 방식이 ’유사함’을 바라보는 근본적인 관점이 다르기 때문이다. 유클리드 거리는 좌표 공간상의 ’위치적 근접성’을, 코사인 유사도는 벡터 공간상의 ’방향적 일치성’을 측정한다.16</p>
<p>예를 들어, 문서 A가 “AI는 중요하다“이고, 문서 B가 “AI는 중요하다 AI는 중요하다“라고 가정하자. 단어 빈도를 기반으로 벡터화하면, 벡터 B는 벡터 A의 각 원소에 2를 곱한 형태가 된다. 이 경우, 두 벡터의 방향은 완전히 동일하므로 코사인 유사도는 1이 되어 매우 유사하다고 판단한다. 이는 문서의 길이가 길어졌을 뿐 주제는 동일하다는 직관과 일치한다. 반면, 유클리드 거리는 두 벡터의 크기 차이로 인해 상대적으로 큰 값을 가지게 되어, 다른 짧은 문서보다 덜 유사하다고 판단할 수 있다.18 이처럼 코사인 유사도는 벡터의 크기 변화에 불변(invariant)하므로, 문서의 길이나 단어의 절대적인 빈도수보다는 단어 분포의 패턴이 중요한 텍스트 분석에 특히 강점을 보인다.</p>
<p>이러한 차이점은 암호화된 상태에서 유사도를 계산하는 기술을 설계할 때 중요한 고려사항이 된다. 어떤 유사도 척도를 선택하느냐에 따라 구현해야 할 암호화 연산의 종류와 복잡도가 달라지기 때문이다. 다음 표는 두 방식의 핵심적인 차이를 요약한 것이다.</p>
<table><thead><tr><th>특징</th><th>유클리드 거리 (Euclidean Distance)</th><th>코사인 유사도 (Cosine Similarity)</th></tr></thead><tbody>
<tr><td><strong>측정 대상</strong></td><td>공간상의 절대적 거리 (Magnitude)</td><td>벡터 간의 방향성 (Direction)</td></tr>
<tr><td><strong>수식</strong></td><td><span class="math math-inline">\sqrt{\sum_{i=1}^{n} (p_i - q_i)^2}</span></td><td><span class="math math-inline">\frac{\mathbf{A} \cdot \mathbf{B}}{\Vert\mathbf{A}\Vert \Vert\mathbf{B}\Vert}</span></td></tr>
<tr><td><strong>값의 범위</strong></td><td><span class="math math-inline">[0, \infty)</span> (0에 가까울수록 유사)</td><td><span class="math math-inline">[-1, 1]</span> (1에 가까울수록 유사)</td></tr>
<tr><td><strong>벡터 크기 의존성</strong></td><td>크기에 민감함</td><td>크기에 불변함 (정규화)</td></tr>
<tr><td><strong>주요 활용 분야</strong></td><td>저차원 데이터 클러스터링, 이미지 색상 분석</td><td>문서 유사도, 텍스트 분류, 추천 시스템</td></tr>
<tr><td><strong>참고 자료</strong></td><td>13</td><td>16</td></tr>
</tbody></table>
<h2>3.  암호화된 데이터 연산의 돌파구, 동형암호</h2>
<p>벡터 유사도를 암호화된 상태에서 계산하기 위해서는, 암호문 위에서 덧셈, 곱셈, 내적과 같은 연산을 직접 수행할 수 있는 특별한 암호 기술이 필요하다. 이 요구사항을 만족시키는 가장 유망한 기술이 바로 동형암호(Homomorphic Encryption)이다.</p>
<h3>3.1  동형암호(Homomorphic Encryption)의 정의와 원리</h3>
<p>동형암호는 데이터를 복호화하지 않고 암호화된 상태(Ciphertext)에서 직접 연산을 수행할 수 있게 하는 차세대 암호 기술이다.11 서버나 제3자는 데이터의 원본 내용을 전혀 알 수 없는 상태에서 요청된 계산을 수행하고, 그 결과 역시 암호화된 상태로 반환한다. 데이터 소유자만이 자신의 비밀키로 이 암호화된 결과를 복호화하여 평문(Plaintext) 연산과 동일한 결과를 얻을 수 있다.22</p>
<p>이러한 특성은 대수학의 ‘동형사상(Homomorphism)’ 개념에서 유래하였다.19 암호화 함수 <code>Enc</code>와 복호화 함수 <code>Dec</code>가 평문 공간에서의 연산 <span class="math math-inline">\otimes</span>와 암호문 공간에서의 연산 <span class="math math-inline">\oplus</span>에 대해 다음과 같은 구조적 관계를 만족시키는 것을 의미한다.12</p>
<p><span class="math math-display">
\text{Dec}(\text{Enc}(m_1) \oplus \text{Enc}(m_2)) = m_1 \otimes m_2
</span><br />
여기서 <span class="math math-inline">m_1, m_2</span>는 평문 데이터이다. 이 성질 덕분에 데이터의 기밀성을全程 보장하면서도 클라우드 컴퓨팅, 빅데이터 분석, AI 모델 학습 등 다양한 데이터 활용이 가능해진다.12</p>
<h3>3.2  동형암호의 분류와 발전사</h3>
<p>동형암호는 지원하는 연산의 종류와 횟수에 따라 여러 세대로 구분된다. 이는 기술 발전의 역사가 암호문에 필연적으로 발생하는 ’노이즈(noise)’를 어떻게 관리하고 극복해왔는지와 밀접한 관련이 있다.</p>
<ul>
<li>
<p><strong>부분 동형암호 (Partially Homomorphic Encryption, PHE):</strong> 덧셈 또는 곱셈 중 한 가지 종류의 연산만을 무제한으로 지원하는 암호 방식이다.12 대표적으로 곱셈 동형을 지원하는 RSA, 덧셈 동형을 지원하는 Paillier 암호 등이 있다.12 이들은 특정 연산에 대해 노이즈 문제가 발생하지 않거나 예측 가능하게 증가하여 관리가 용이하다. 따라서 연산 속도가 빠르고 구현이 비교적 단순하지만, 수행할 수 있는 연산이 매우 제한적이어서 복잡한 계산에는 부적합하다.</p>
</li>
<li>
<p><strong>준동형암호 (Somewhat Homomorphic Encryption, SHE):</strong> 덧셈과 곱셈을 모두 지원하지만, 수행할 수 있는 연산의 횟수(특히 곱셈의 횟수)에 제한이 있는 암호 방식이다.12 이는 연산을 거듭할수록, 특히 곱셈 연산 시 암호문에 포함된 노이즈가 급격히 증가하기 때문이다. 노이즈가 특정 임계치를 초과하면 암호문이 손상되어 올바른 복호화가 불가능해진다.12 따라서 미리 정해진 깊이의 연산 회로(circuit)만 계산할 수 있다.</p>
</li>
<li>
<p><strong>완전 동형암호 (Fully Homomorphic Encryption, FHE):</strong> 덧셈과 곱셈 연산을 이론상 무제한으로 수행할 수 있는 궁극적인 형태의 동형암호이다.12 2009년 Craig Gentry가 격자(lattice) 기반 암호를 이용하여 최초로 FHE 스킴을 제안하며 이론적 가능성을 열었다. 그 핵심 아이디어는 ’부트스트래핑(Bootstrapping)’이라는 기법이다.23 부트스트래핑은 노이즈가 임계치에 가까워진 암호문을 입력으로 받아, 암호화된 상태에서 복호화 회로를 실행하여 노이즈를 ’리셋’하는 과정이다. 즉, 노이즈가 많이 쌓인 암호문을 복호화하지 않고도 노이즈가 적은 새로운 암호문으로 ’재생산’함으로써 계속해서 연산을 이어나갈 수 있게 한다.23</p>
</li>
</ul>
<p>동형암호의 발전사는 ’노이즈 관리’와의 투쟁의 역사라고 할 수 있다. 이는 연산의 기능성(functionality), 성능(performance), 보안성(security) 간의 근본적인 상충 관계(trade-off)를 드러낸다. PHE는 기능성을 제한하여 성능과 안정성을 확보했고, SHE는 제한된 기능성을 감수하고 어느 정도의 성능을 얻는 타협점을 찾았다. FHE는 부트스트래핑이라는 혁신을 통해 무한한 기능성을 달성했지만, 부트스트래핑 자체가 매우 복잡하고 비용이 큰 연산이어서 초기에는 성능을 크게 희생해야만 했다.23 따라서 동형암호 스킴을 선택하거나 설계하는 것은 단순히 어떤 연산을 할 수 있는가의 문제를 넘어, 주어진 연산 복잡도 내에서 허용 가능한 성능 저하와 보안 수준을 유지하며 노이즈를 어떻게 제어할 것인가라는 다차원적 최적화 문제를 푸는 과정과 같다.</p>
<h3>3.3  기술적 한계와 과제</h3>
<p>FHE는 이론적으로 모든 연산이 가능하지만, 실용화를 위해서는 여전히 극복해야 할 여러 난제가 존재한다. 가장 큰 장벽은 막대한 계산 비용으로 인한 느린 속도이다. 평문 연산에 비해 수십 배에서 수천 배 이상 느릴 수 있으며 25, 이는 실시간 처리가 요구되는 서비스에 적용하기 어렵게 만든다. 또한, 암호문의 크기가 평문보다 훨씬 커지는 문제(Ciphertext expansion)와, 보안 수준, 연산 깊이, 정밀도 등을 고려하여 복잡한 파라미터를 설정해야 하는 어려움도 주요 과제로 남아있다.25</p>
<p>다음 표는 동형암호의 종류별 특징을 비교하여 발전 과정을 요약한 것이다.</p>
<table><thead><tr><th>구분</th><th>부분 동형암호 (PHE)</th><th>준동형암호 (SHE)</th><th>완전 동형암호 (FHE)</th></tr></thead><tbody>
<tr><td><strong>지원 연산</strong></td><td>덧셈 <strong>또는</strong> 곱셈 중 하나만 무제한</td><td>덧셈 <strong>과</strong> 곱셈 모두 지원</td><td>덧셈 <strong>과</strong> 곱셈 모두 무제한</td></tr>
<tr><td><strong>연산 횟수</strong></td><td>무제한 (단일 연산)</td><td>제한적</td><td>무제한</td></tr>
<tr><td><strong>핵심 특징</strong></td><td>빠르고 단순함</td><td>제한된 깊이의 회로 계산 가능</td><td>임의의 연산 가능 (Turing Complete)</td></tr>
<tr><td><strong>주요 난제</strong></td><td>제한된 기능성</td><td>노이즈 축적으로 인한 연산 깊이 제한</td><td>막대한 연산 오버헤드 (특히 부트스트래핑)</td></tr>
<tr><td><strong>대표 알고리즘</strong></td><td>RSA, Paillier, ElGamal</td><td>초기 격자 기반 암호</td><td>Gentry 스킴, BGV, BFV, TFHE, CKKS</td></tr>
<tr><td><strong>참고 자료</strong></td><td>12</td><td>19</td><td>12</td></tr>
</tbody></table>
<h2>4.  실수 및 벡터 연산을 위한 CKKS 동형암호 스킴 심층 분석</h2>
<p>벡터 유사도 계산은 실수를 포함하는 벡터에 대한 내적, 놈(norm) 계산 등 복잡한 연산을 요구한다. 기존의 FHE 스킴들이 주로 정수 연산에 초점을 맞춘 반면, 이러한 실수 연산의 필요성에 부응하여 등장한 것이 바로 CKKS 동형암호 스킴이다.</p>
<h3>4.1  CKKS의 등장 배경: 근사 계산의 필요성</h3>
<p>BGV, BFV와 같은 이전 세대의 FHE 스킴들은 주로 정수(Integer)나 유한체(Finite Field) 위에서의 ‘정확한’ 연산을 지원하도록 설계되었다.31 이러한 스킴에서 노이즈는 반드시 제거해야 할 ’적’과 같은 존재였다. 노이즈가 특정 임계값을 넘으면 복호화가 실패하기 때문에, 모든 연산은 노이즈 증가를 최소화하도록 매우 신중하게 설계되어야 했다.</p>
<p>하지만 머신러닝, 통계 분석, 신호 처리 등 수많은 실제 응용 분야에서 다루는 데이터는 대부분 실수(Real Number)이며, 연산 과정에서 부동소수점 오차와 같이 어느 정도의 오차를 자연스럽게 허용하는 ’근사 계산’이 일반적이다. 이러한 응용에 정수 기반 FHE를 적용하려면 실수를 고정소수점(fixed-point) 방식으로 변환해야 하는데, 이는 효율성과 정밀도 측면에서 한계가 있었다.</p>
<p>2016년, 천정희, 김안드레, 김미란, 송용수 연구팀은 이러한 문제점을 해결하기 위해 실수 및 복소수 연산에 최적화된 새로운 동형암호 스킴인 CKKS(Cheon-Kim-Kim-Song)를 제안했다.28 CKKS의 가장 혁신적인 아이디어는 암호의 보안성을 보장하는 LWE(Learning With Errors) 문제의 ’에러(error)’를 암호 시스템의 노이즈가 아닌, 근사 계산에서 발생하는 ’오차(error)’의 일부로 취급하는 것이었다.33 이는 동형암호의 고질적인 ’노이즈 문제’를 ’정밀도 문제’로 치환함으로써 실용성을 획기적으로 높인 패러다임의 전환이었다. 이제 문제는 ’복호화 실패’가 아니라 ’결과의 정밀도 하락’이 되며, 사용자는 자신이 원하는 최종 정밀도를 얻기 위해 초기 파라미터를 조절할 수 있게 되었다. 이러한 접근 방식 덕분에 CKKS는 복잡한 머신러닝 연산을 동형암호의 영역으로 성공적으로 끌어들일 수 있었다.</p>
<h3>4.2  CKKS의 핵심 메커니즘</h3>
<p>CKKS 스킴은 여러 개의 실수(또는 복소수)를 하나의 암호문으로 묶어 병렬적으로 처리하는 SIMD(Single Instruction, Multiple Data) 연산을 효율적으로 지원한다. 그 핵심 메커니즘은 다음과 같다.</p>
<ul>
<li>
<p><strong>인코딩/디코딩 (Encoding/Decoding):</strong></p>
</li>
<li>
<p>CKKS는 <code>N/2</code>개의 복소수(또는 <code>N</code>개의 실수)로 구성된 벡터 <span class="math math-inline">\mathbf{z}</span>를 <code>N</code>차 환 다항식(Ring Polynomial) <span class="math math-inline">m(X)</span>으로 변환하는 인코딩 과정을 거친다. 이 과정에는 ’Canonical Embedding’이라는 수학적 매핑이 사용되어 벡터의 각 원소를 다항식의 특정 위치에 효과적으로 삽입한다.33</p>
</li>
<li>
<p>실수 값을 정수 계수를 가진 다항식으로 표현하기 위해, 먼저 스케일링 팩터(Scaling Factor) <span class="math math-inline">\Delta</span>를 곱한 후 가장 가까운 정수로 반올림한다. 이 <span class="math math-inline">\Delta</span> 값이 클수록 더 높은 정밀도를 표현할 수 있다.33</p>
<ul>
<li>
<p><span class="math math-display">m(X) = \text{round}(\Delta \cdot \mathcal{I}(\mathbf{z})) \in \mathbb{Z}[X] / (X^N+1)</span></p>
</li>
<li>
<p>디코딩은 이 과정의 역순으로, 복호화된 다항식을 다시 복소수 벡터로 변환하고 <span class="math math-inline">\Delta</span>로 나누어 원래의 근사치를 복원한다.</p>
</li>
</ul>
</li>
<li>
<p><strong>암호화/복호화 (Encryption/Decryption):</strong></p>
<ul>
<li>인코딩된 평문 다항식 <span class="math math-inline">m(X)</span>은 공개키 <code>pk</code>와 비밀키 <code>sk</code>를 이용해 암호화된다. CKKS의 보안성은 R-LWE(Ring-Learning With Errors) 문제의 어려움에 기반하며, 암호화 과정에서 작은 크기의 에러 다항식 <span class="math math-inline">e_0, e_1</span>이 추가된다.35</li>
</ul>
</li>
<li>
<p>암호문 <code>ct</code>는 <span class="math math-inline">(c_0, c_1)</span> 형태의 다항식 쌍으로 구성된다: <span class="math math-display">c_0 = -a \cdot s + e_0 + m \pmod{q}, \quad c_1 = a \pmod{q}</span> (여기서 <span class="math math-inline">a</span>는 랜덤 다항식, <span class="math math-inline">s</span>는 비밀키).</p>
<ul>
<li>복호화는 비밀키 <span class="math math-inline">s</span>를 이용해 <span class="math math-display">c_0 + c_1 \cdot s = m + e_0 \pmod{q}</span>를 계산하여 <span class="math math-inline">m</span>을 근사적으로 복원한다. 이 과정에서 발생하는 <span class="math math-inline">e_0</span>와 인코딩/연산 과정에서 누적된 오차들이 최종 결과의 정밀도에 영향을 미친다.</li>
</ul>
</li>
<li>
<p><strong>암호문 연산 (Homomorphic Operations):</strong></p>
</li>
<li>
<p><strong>덧셈:</strong> 두 암호문 <code>ct_1</code>, <code>ct_2</code>의 덧셈은 각 요소를 더하는 것으로 간단히 수행된다: <span class="math math-display">\text{ct}_{add} = (c_{1,0} + c_{2,0}, c_{1,1} + c_{2,1})</span>. 이는 평문 <span class="math math-inline">m_1+m_2</span>를 암호화한 것과 같다.</p>
</li>
<li>
<p><strong>곱셈:</strong> 곱셈은 더 복잡한 과정을 거친다. 두 암호문 <code>ct_1 = (c_{1,0}, c_{1,1})</code>과 <code>ct_2 = (c_{2,0}, c_{2,1})</code>를 곱하면 <span class="math math-inline">(c_{1,0}c_{2,0}, c_{1,0}c_{2,1} + c_{1,1}c_{2,0}, c_{1,1}c_{2,1})</span> 형태의 3개 항을 가진 다항식이 된다. 이는 비밀키 <span class="math math-inline">s^2</span>에 의존하므로, 원래의 비밀키 <span class="math math-inline">s</span>로 복호화할 수 있도록 ’Relinearization’이라는 키 변환 과정을 거쳐 다시 <span class="math math-inline">(c&#39;_0, c&#39;_1)</span> 형태의 암호문으로 만들어야 한다.33</p>
</li>
<li>
<p><strong>리스케일링 (Rescaling):</strong></p>
</li>
<li>
<p>동형 곱셈을 수행하면 평문의 스케일은 <span class="math math-inline">\Delta</span>에서 <span class="math math-inline">\Delta^2</span>으로 증가한다. 이 상태에서 계속 곱셈을 하면 스케일이 기하급수적으로 커져 암호문의 모듈러스 <span class="math math-inline">q</span>를 초과하는 오버플로우가 발생할 수 있다.</p>
</li>
<li>
<p>리스케일링은 이러한 문제를 해결하기 위한 핵심적인 절차이다. 곱셈 후 암호문의 모듈러스를 <span class="math math-inline">q</span>에서 <span class="math math-inline">q/p</span>로 줄이는 동시에, 암호문이 나타내는 평문 값을 <span class="math math-inline">p</span>로 나누어주는 연산이다 (여기서 <span class="math math-inline">p</span>는 리스케일링 인자이며, 보통 <span class="math math-inline">\Delta</span>와 비슷한 값으로 설정된다). 이는 암호화된 상태에서 ’나눗셈 후 반올림’을 수행하는 것과 유사하며, 평문의 스케일을 다시 <span class="math math-inline">\Delta</span>로 되돌리는 효과를 가져온다.33</p>
</li>
<li>
<p>이 과정을 통해 곱셈 연산을 계속 이어나갈 수 있는 ’레벨(level)’을 확보하게 된다. 하지만 리스케일링 과정에서 하위 비트 정보가 손실되므로, 이는 결과의 정밀도 하락으로 이어진다. 따라서 CKKS 기반의 암호 회로를 설계하는 것은 허용 가능한 정밀도 손실 범위 내에서 필요한 곱셈 깊이를 확보하도록 파라미터를 설정하는 정교한 엔지니어링 작업이다.</p>
</li>
</ul>
<h2>5.  동형암호를 이용한 벡터 유사도 계산 구현</h2>
<p>CKKS 동형암호의 연산 원리를 바탕으로, 암호화된 두 벡터에 대한 코사인 유사도와 유클리드 거리를 계산하는 구체적인 방법을 설계할 수 있다. 이 과정은 평문 환경에서의 수학 공식을 암호화 환경의 제약 조건에 맞게 ‘암호 친화적(Crypto-friendly)’ 형태로 재설계하는 과정이며, 정확도, 성능, 연산 가능성 간의 새로운 트레이드오프를 고려해야 한다.</p>
<h3>5.1  암호화된 코사인 유사도 계산 회로</h3>
<p>코사인 유사도 수식 <span class="math math-inline">\cos(\theta) = (\mathbf{A} \cdot \mathbf{B}) / (\|\mathbf{A}\| \|\mathbf{B}\|)</span>을 동형암호 연산으로 구현하기 위해서는 분자(내적), 분모(놈), 그리고 나눗셈을 각각 처리해야 한다.</p>
<ul>
<li>
<p><strong>분자 (내적 <span class="math math-inline">\mathbf{A} \cdot \mathbf{B}</span>):</strong></p>
</li>
<li>
<p>두 개의 암호화된 벡터 <code>Enc(A)</code>와 <code>Enc(B)</code>가 주어졌을 때, 내적 <span class="math math-inline">\sum A_i B_i</span>는 동형암호의 기본 연산으로 비교적 간단하게 구현할 수 있다.</p>
</li>
<li>
<ol>
<li><strong>요소별 곱셈:</strong> <code>Enc(A)</code>와 <code>Enc(B)</code>에 대해 동형 곱셈을 수행하여 각 요소가 곱해진 새로운 암호화된 벡터 <code>Enc(A_i \cdot B_i)</code>를 얻는다. 이 과정에서 곱셈 깊이 1이 소모된다.</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>전체 합:</strong> 결과 벡터의 모든 원소를 더하여 최종 내적 값을 구해야 한다. 이를 위해 CKKS가 지원하는 ‘Rotation’ 연산을 활용한다.28 예를 들어, 벡터를 왼쪽으로 1칸, 2칸, 4칸,… ,</li>
</ol>
</li>
</ul>
<p><code>N/2</code>칸 회전시킨 암호문들을 모두 생성한 후, 이들을 전부 더하는 방식으로 모든 요소의 합을 효율적으로 계산할 수 있다. 이 과정은 여러 번의 덧셈과 Rotation 연산을 필요로 한다.</p>
<ul>
<li>
<p><strong>분모 (놈 <span class="math math-inline">\|\mathbf{A}\|, \|\mathbf{B}\|</span>):</strong></p>
</li>
<li>
<p>놈 <span class="math math-inline">\|\mathbf{A}\| = \sqrt{\sum A_i^2}</span>의 계산은 동형암호 환경에서 가장 어려운 부분이다. <span class="math math-inline">\sum A_i^2</span>는 내적과 유사한 방식으로 <code>Enc(A)</code>와 <code>Enc(A)</code>를 곱하여 계산할 수 있지만, 제곱근(<code>sqrt</code>) 함수는 덧셈과 곱셈만으로 표현되지 않는 비선형 함수이기 때문이다.</p>
</li>
<li>
<p><strong>해결책: 다항식 근사 (Polynomial Approximation):</strong> 이 문제를 해결하기 위해, 제곱근 함수나 나눗셈을 포함한 그 역수(<span class="math math-inline">1/\sqrt{x}</span>)를 직접 계산하는 대신, 이 함수를 낮은 차수의 다항식으로 근사하는 방법을 사용한다.28 예를 들어, Taylor 급수 전개나 Chebyshev 근사, Remez 알고리즘 등을 사용하여 특정 구간에서</p>
<p><span class="math math-display">f(x) \approx c_0 + c_1 x + c_2 x^2 + \dots + c_d x^d</span> 와 같은 근사 다항식을 찾는다.</p>
<ul>
<li>이 근사 다항식을 동형암호 회로로 구현한다. 이는 여러 번의 동형 곱셈(예: <span class="math math-inline">x^d</span>를 계산하기 위해 <span class="math math-inline">\log_2 d</span> 깊이의 곱셈 필요)을 요구하므로, 전체 회로의 곱셈 깊이를 크게 증가시키는 주된 요인이 된다. 근사 다항식의 차수가 높을수록 정확도는 올라가지만, 계산 비용과 곱셈 깊이가 급격히 증가하는 상충 관계가 존재한다.</li>
</ul>
</li>
<li>
<p><strong>최종 계산 (나눗셈):</strong></p>
<ul>
<li>
<p>나눗셈 역시 직접적인 동형 연산이 없으므로, 곱셈으로 변환해야 한다. 즉, <span class="math math-inline">X/Y</span>를 <span class="math math-inline">X \cdot (1/Y)</span>로 계산한다. 따라서 분모의 <span class="math math-inline">\|\mathbf{A}\| \|\mathbf{B}\|</span>에 대해 역수를 취하는 함수 <span class="math math-inline">g(y) = 1/y</span>를 다항식으로 근사하여 <code>Enc(1/(\|\mathbf{A}\| \|\mathbf{B}\|))$를 계산한 후, 이를 분자 </code>Enc(\mathbf{A} \cdot \mathbf{B})`와 곱한다.</p>
</li>
<li>
<p>결론적으로, 암호화된 코사인 유사도는 암호화된 내적, 암호화된 제곱합, 그리고 비선형 함수(역수, 제곱근)에 대한 다항식 근사 회로를 조합하여 계산된다.</p>
</li>
</ul>
</li>
</ul>
<h3>4.2. 암호화된 유클리드 거리 계산 회로</h3>
<p>유클리드 거리 <span class="math math-inline">\sqrt{\sum (A_i - B_i)^2}</span> 역시 제곱근 함수 때문에 동형암호로 직접 계산하기 어렵다. 이 경우, 문제 자체를 ’변형’하여 암호 친화적인 형태로 만드는 전략을 사용할 수 있다.</p>
<ul>
<li>
<p><strong>대안: 제곱 유클리드 거리 (Squared Euclidean Distance):</strong></p>
<ul>
<li>
<p>많은 검색 및 클러스터링 응용에서는 실제 거리 값보다 벡터 간의 상대적인 거리 순위가 더 중요하다. 제곱근 함수는 단조 증가 함수이므로, 거리의 순위는 제곱 거리의 순위와 동일하다 (<span class="math math-inline">d_1 &lt; d_2 \iff d_1^2 &lt; d_2^2</span>). 따라서 계산이 훨씬 용이한 제곱 유클리드 거리 <span class="math math-inline">d^2 = \sum (A_i - B_i)^2</span>를 대신 사용하는 것이 매우 효율적인 대안이 된다.</p>
</li>
<li>
<p>제곱 유클리드 거리는 다음과 같이 전개할 수 있다.</p>
</li>
</ul>
</li>
</ul>
<p><span class="math math-display"> d^2 = \sum (A_i^2 - 2A_i B_i + B_i^2) = \sum A_i^2 - 2\sum A_i B_i + \sum B_i^2 = \|\mathbf{A}\|^2 - 2(\mathbf{A} \cdot \mathbf{B}) + \|\mathbf{B}\|^2 </span></p>
<ul>
<li>이 식은 각 벡터의 제곱합(<span class="math math-inline">\|\mathbf{A}\|^2, \|\mathbf{B}\|^2</span>)과 두 벡터의 내적(<span class="math math-inline">\mathbf{A} \cdot \mathbf{B}</span>)만으로 구성된다. 이 모든 항은 4.1절에서 설명한 바와 같이 동형암호의 덧셈과 곱셈만으로 효율적으로 계산 가능하다. 특히, 비선형 함수에 대한 다항식 근사가 필요 없어 계산 오차가 적고, 전체 회로의 곱셈 깊이도 1로 매우 낮게 유지할 수 있어 성능 면에서 큰 이점을 가진다.</li>
</ul>
<p>이처럼 동형암호 환경에서 벡터 유사도를 계산하는 것은 단순히 기존 공식을 그대로 옮기는 것이 아니다. 코사인 유사도의 경우처럼 비선형 함수를 다항식으로 ’근사’하여 원래의 의미를 유지하려 하되, 근사 오차와 성능 저하를 감수하는 전략을 취하거나, 유클리드 거리의 경우처럼 문제 자체를 ’변형’하여 비선형 연산을 원천적으로 제거함으로써 성능과 계산 정확성을 확보하는 전략을 선택해야 한다. 이는 순수 알고리즘 설계와 암호학적 제약 조건이 만나는 지점에서 이루어지는 중요한 아키텍처 설계 결정이다.</p>
<h2>6.  실용적 구현의 난제와 최신 연구 동향</h2>
<p>동형암호를 이용한 벡터 유사도 계산은 이론적으로 가능하지만, 이를 실제 대규모 시스템에 적용하기까지는 여러 기술적 난제를 해결해야 한다. 성능, 사용성, 표준화 등 다양한 측면에서 활발한 연구가 진행되고 있다.</p>
<h3>6.1  성능 및 파라미터 설정의 복잡성</h3>
<ul>
<li>
<p><strong>성능 병목:</strong> 동형암호 연산, 특히 곱셈과 Rotation은 평문 연산에 비해 수백에서 수천 배 이상 느리다.28 이는 대규모 벡터 데이터베이스에 저장된 수백만, 수십억 개의 벡터와 실시간으로 유사도를 비교해야 하는 응용에 심각한 제약으로 작용한다. 현재 기술 수준으로는 오프라인 배치(batch) 처리나 소규모 데이터셋에 대한 검색은 가능하지만, 실시간 온라인 서비스에 전면적으로 적용하기에는 성능이 부족하다.</p>
</li>
<li>
<p><strong>파라미터 상충 관계:</strong> 동형암호 시스템을 사용하기 위해서는 보안 수준(λ, 예: 128-bit security), 다항식 차수(<span class="math math-inline">N</span>), 암호문 모듈러스(<span class="math math-inline">Q</span>), 스케일링 팩터(<span class="math math-inline">\Delta</span>) 등 매우 복잡하고 민감한 파라미터들을 설정해야 한다. 이 파라미터들은 서로 복잡하게 얽혀 있어 최적의 균형점을 찾는 것이 매우 어렵다.</p>
</li>
<li>
<p><strong>보안 수준과 성능:</strong> 더 높은 보안 수준을 요구할수록, 이를 만족시키기 위해 다항식 차수 <span class="math math-inline">N</span>과 모듈러스 <span class="math math-inline">Q</span>가 커져야 한다. 이는 직접적으로 연산 속도를 저하시키고 메모리 사용량을 증가시킨다.</p>
</li>
<li>
<p><strong>연산 깊이와 정밀도:</strong> 계산해야 할 회로의 곱셈 깊이(<span class="math math-inline">L</span>)가 깊어질수록, 모든 연산을 감당할 수 있도록 초기 모듈러스 <span class="math math-inline">Q</span>가 커져야 한다. 또한, 높은 정밀도의 결과가 필요할수록 스케일링 팩터 <span class="math math-inline">\Delta</span>와 모듈러스 <span class="math math-inline">Q</span>가 함께 커져야 한다.</p>
</li>
<li>
<p>결론적으로, 보안성, 연산 기능성, 정밀도, 성능은 서로 상충 관계에 있으며, 특정 응용에 맞는 최적의 파라미터 조합을 찾는 것은 전문가에게도 상당한 노하우를 요구하는 작업이다.</p>
</li>
</ul>
<h3>6.2  최신 연구 동향</h3>
<p>이러한 난제들을 극복하기 위해 전 세계 연구자들이 다양한 방향에서 연구를 진행하고 있다.</p>
<ul>
<li>
<p><strong>RNS (Reside Number System) 최적화:</strong> CKKS와 같은 격자 기반 암호는 매우 큰 정수(BigInt)에 대한 다항식 연산을 필요로 한다. RNS는 중국인의 나머지 정리를 이용하여 이러한 큰 정수 연산을 컴퓨터의 기본 워드 크기(예: 64-bit) 정수 연산들의 병렬 처리로 변환하는 기술이다. 이를 CKKS 스킴에 완벽하게 적용한 ’Full RNS Variant’는 기존의 비효율적인 멀티-프리시전(multi-precision) 산술 연산을 제거함으로써, 복호화, 상수 곱셈, 동형 곱셈 등 핵심 연산에서 수 배에서 수십 배에 달하는 극적인 성능 향상을 이끌어냈다.38 현재 대부분의 고성능 동형암호 라이브러리는 RNS 최적화를 기본으로 채택하고 있다.</p>
</li>
<li>
<p><strong>부트스트래핑(Bootstrapping) 효율화:</strong> FHE가 무한한 깊이의 연산을 수행할 수 있게 해주는 핵심 기술이지만, 동시에 가장 느리고 복잡한 연산이기도 하다. 최근 연구들은 부트스트래핑 과정의 알고리즘을 개선하여 CPU 비용을 줄이고, 소모되는 곱셈 레벨의 수를 최소화하며, 더 높은 정밀도를 유지하는 데 초점을 맞추고 있다.41 효율적인 부트스트래핑은 암호화된 상태에서 깊은 신경망 모델을 실행하는 등, 더 복잡한 응용을 실현하기 위한 필수적인 연구 분야이다.</p>
</li>
<li>
<p><strong>하드웨어 가속:</strong> 소프트웨어 최적화만으로는 넘을 수 없는 성능의 벽을 극복하기 위해, 동형암호의 핵심 연산(NTT, 다항식 곱셈 등)을 가속하는 전용 하드웨어(FPGA, ASIC)를 설계하려는 연구가 활발히 진행되고 있다.38 이러한 하드웨어 가속기는 향후 동형암호가 클라우드 데이터센터의 표준 서비스로 자리 잡는 데 중요한 역할을 할 것으로 기대된다.</p>
</li>
<li>
<p><strong>사용성 개선 프레임워크:</strong> 복잡한 파라미터 설정과 암호 회로 설계를 자동화하여, 머신러닝 개발자들이 암호학적 지식 없이도 쉽게 동형암호를 사용할 수 있도록 돕는 고수준 컴파일러 및 프레임워크에 대한 연구도 진행되고 있다. 예를 들어, PyTorch와 같은 딥러닝 프레임워크로 작성된 모델을 자동으로 동형암호 프로그램으로 변환해주는 Orion과 같은 프로젝트가 대표적이다.42</p>
</li>
</ul>
<h3>6.3  주요 구현 라이브러리</h3>
<p>이러한 연구 성과들은 여러 오픈소스 라이브러리를 통해 실제 개발자들이 사용할 수 있도록 제공되고 있다.</p>
<ul>
<li>
<p><strong>Microsoft SEAL:</strong> Microsoft Research에서 개발한 대표적인 오픈소스 동형암호 라이브러리로, 정수 연산을 위한 BFV 스킴과 실수 연산을 위한 CKKS 스킴을 지원한다. C++17 표준으로 작성되었으며, C#, Python, Java 등 다양한 언어에 대한 래퍼(wrapper)를 제공하여 접근성이 매우 높다.31</p>
</li>
<li>
<p><strong>HEAAN:</strong> CKKS 스킴을 최초로 제안한 서울대학교 연구팀이 개발하고 유지보수하는 라이브러리이다. Full RNS variant와 같은 최신 연구 결과가 가장 빠르게 반영되는 특징이 있으며, 고성능이 요구되는 연구 및 개발에 널리 사용된다.34</p>
</li>
<li>
<p><strong>기타 라이브러리:</strong> IBM에서 개발한 HElib, Duality Technologies가 주도하는 PALISADE 등도 활발히 개발되고 있는 주요 동형암호 라이브러리이다.48</p>
</li>
</ul>
<h2>7.  타 프라이버시 보존 기술과의 비교 고찰</h2>
<p>동형암호는 ’처리 중인 데이터’를 보호하는 강력한 도구이지만, 유일한 해결책은 아니다. 특정 시나리오와 위협 모델에 따라 다른 프라이버시 보존 기술(Privacy-Enhancing Technologies, PETs)이 더 적합할 수 있으며, 이들을 결합한 하이브리드 방식이 가장 강력한 보호를 제공하기도 한다.</p>
<h3>7.1  안전한 다자간 계산 (Secure Multi-Party Computation, SMPC)</h3>
<ul>
<li>
<p><strong>개념:</strong> SMPC는 신뢰할 수 있는 제3자 없이, 둘 이상의 참여자가 각자 보유한 비밀 입력을 서로에게 공개하지 않으면서 그 입력들에 대한 특정 함수를 함께 계산하고 결과만을 공유하는 암호학적 프로토콜이다.49</p>
</li>
<li>
<p><strong>동형암호와의 비교:</strong></p>
</li>
<li>
<p><strong>계산 모델의 차이:</strong> 동형암호는 주로 클라이언트-서버 모델에 적합하다. 즉, 데이터 소유자(클라이언트)가 자신의 데이터를 암호화하여 계산 능력이 뛰어난 서버에 위탁하고, 서버가 단독으로 계산을 수행하는 시나리오에 사용된다.50 반면, SMPC는 참여자들이 서로를 신뢰하지 않는 분산 환경에서 협력적으로 계산을 수행하는 모델에 적합하다. 예를 들어, 여러 금융 기관이 각자의 거래 데이터를 공개하지 않고 공동으로 사기 거래 탐지 모델을 학습시키는 경우이다.48</p>
</li>
<li>
<p><strong>성능 특성의 차이:</strong> 동형암호는 암호문 자체의 크기가 크고 연산이 복잡하여 계산 비용(computation cost)이 매우 높지만, 일단 서버에 데이터가 전송된 후에는 추가적인 통신이 거의 필요 없다. 반면, SMPC는 프로토콜에 따라 계산 비용은 동형암호보다 낮을 수 있으나, 계산 과정에서 참여자들 간에 여러 라운드에 걸쳐 지속적인 상호작용과 데이터 교환을 요구하므로 통신 오버헤드(communication overhead)가 매우 크다.48</p>
</li>
</ul>
<h3>7.2  차분 프라이버시 (Differential Privacy, DP)</h3>
<ul>
<li>
<p><strong>개념:</strong> 차분 프라이버시는 데이터셋에 대한 통계적 쿼리나 머신러닝 모델 학습 결과로부터 특정 개인의 정보가 드러나는 것을 방지하기 위한 통계적 프라이버시 모델이다.52 이는 데이터셋에 특정 개인의 데이터가 포함되거나 제외되더라도 분석 결과가 거의 달라지지 않도록, 결과값에 수학적으로 제어된 ’노이즈’를 의도적으로 추가하는 방식으로 달성된다.</p>
</li>
<li>
<p><strong>동형암호와의 비교:</strong></p>
</li>
<li>
<p><strong>보호 대상의 차이:</strong> 동형암호는 데이터 자체를 암호학적으로 보호하여 원본 데이터의 유출을 원천적으로 차단하는 ‘입력 데이터 보호’ 기술이다. 반면, 차분 프라이버시는 데이터 분석 ’출력 결과’로부터 개인 정보가 추론되는 것을 방지하는 ‘출력 결과 보호’ 기술이다. 이 둘은 근본적으로 다른 위협 모델을 다룬다.</p>
</li>
<li>
<p><strong>정확성의 차이:</strong> 동형암호는 (CKKS의 근사 계산을 포함하더라도) 원칙적으로 주어진 입력에 대해 결정론적인 결과를 제공한다. 반면, 차분 프라이버시는 프라이버시 보장을 위해 의도적으로 통계적 노이즈를 추가하므로, 결과의 정확성(utility)이 필연적으로 저하된다. 프라이버시 수준을 높일수록 정확성은 낮아지는 상충 관계(privacy-utility trade-off)가 존재한다.9</p>
</li>
</ul>
<p>이러한 기술들은 상호 배타적인 관계가 아니라, 서로 다른 프라이버시 시나리오와 위협 모델을 다루는 상호 보완적인 도구이다. 예를 들어, 여러 병원이 공동으로 의료 AI 모델을 개발하는 시나리오를 생각해보자. 각 병원은 자신의 환자 데이터를 외부에 공개하지 않기 위해 연합 학습(Federated Learning)을 사용할 수 있다.53 이때, 각 병원이 중앙 서버로 보내는 모델 업데이트(gradient)가 다른 참여자에게 노출되지 않도록 동형암호나 SMPC를 적용할 수 있다. 또한, 최종적으로 학습된 모델 자체가 특정 환자의 정보를 과도하게 ’기억’하여 발생하는 프라이버시 유출(예: Membership Inference Attack)을 막기 위해, 학습 과정에 차분 프라이버시를 적용하여 노이즈를 추가할 수 있다.53 이처럼 HE, SMPC, DP, 연합 학습 등을 결합한 하이브리드 아키텍처가 단일 기술로는 해결할 수 없는 복잡한 실제 문제를 해결하고, 가장 강력하고 포괄적인 프라이버시를 제공하는 미래 기술의 방향이 될 것이다.</p>
<table><thead><tr><th>특징</th><th>동형암호 (HE)</th><th>안전한 다자간 계산 (SMPC)</th><th>차분 프라이버시 (DP)</th></tr></thead><tbody>
<tr><td><strong>핵심 원리</strong></td><td>암호학적 데이터 은닉</td><td>암호학적 프로토콜 기반 분산 계산</td><td>통계적 데이터 익명화</td></tr>
<tr><td><strong>주요 목적</strong></td><td>위탁 계산(Outsourced Computation) 시 데이터 보호</td><td>다자간 협력 계산(Collaborative Computation) 시 입력값 보호</td><td>데이터 분석 결과(Output)로부터 개인정보 추론 방지</td></tr>
<tr><td><strong>가정/모델</strong></td><td>서버는 정직하지만 호기심이 많음(Honest-but-curious)</td><td>참여자 간 상호 불신(Mutual Distrust)</td><td>강력한 공격자가 결과 분석</td></tr>
<tr><td><strong>성능 오버헤드</strong></td><td>계산(Computation) 비용이 매우 높음</td><td>통신(Communication) 비용이 매우 높음</td><td>정확도(Utility) 저하 발생</td></tr>
<tr><td><strong>적합한 응용</strong></td><td>클라우드 기반 암호화 DB 쿼리, Private AI 추론</td><td>프라이버시 보존 공동 학습, 전자 투표, 경매</td><td>대규모 데이터셋 통계 분석, 익명화된 데이터 공개</td></tr>
<tr><td><strong>참고 자료</strong></td><td>30</td><td>48</td><td>9</td></tr>
</tbody></table>
<h2>8. 결론: 벡터 암호화 기술의 미래 전망과 과제</h2>
<p>본 안내서는 암호화된 상태에서 벡터 유사도 검색을 수행하는 기술, 특히 동형암호를 중심으로 그 원리, 구현 방법, 기술적 난제 및 미래 전망을 심층적으로 고찰하였다. 생성형 AI의 확산으로 벡터 데이터의 중요성이 날로 커지는 가운데, 이에 내재된 심각한 프라이버시 위협은 데이터 활용과 보호라는 두 가치를 양립시킬 수 있는 새로운 기술 패러다임을 요구하고 있다.</p>
<p>동형암호, 그중에서도 실수 연산에 최적화된 CKKS 스킴은 암호화된 벡터에 대해 복호화 과정 없이 내적, 제곱합 등의 연산을 수행함으로써 코사인 유사도와 유클리드 거리를 계산할 수 있는 이론적, 실용적 토대를 마련했다. 이는 민감한 데이터를 외부 클라우드에 안전하게 위탁하여 분석하고 활용할 수 있는 가능성을 열어주었다는 점에서 큰 의의를 가진다. 그러나 이러한 잠재력을 현실 세계의 대규모 서비스에 온전히 적용하기까지는 여전히 해결해야 할 과제들이 남아있다.</p>
<p>첫째, <strong>성능 향상</strong>이 가장 시급하고 중요한 과제이다. 현재의 동형암호 연산 속도는 평문 연산에 비해 수백, 수천 배 느려 실시간 대규모 검색에는 한계가 명확하다. RNS 기반 알고리즘 최적화, 전용 하드웨어 가속기 개발, 효율적인 부트스트래핑 기법 연구 등을 통해 수십 배 이상의 성능 개선을 이루어내야만 실용성의 문턱을 넘을 수 있을 것이다.</p>
<p>둘째, <strong>사용성 개선</strong>이 기술의 대중화를 위해 필수적이다. 보안, 성능, 정밀도 간의 복잡한 상충 관계를 고려하여 최적의 파라미터를 설정하는 작업은 비전문가에게는 거의 불가능에 가깝다. 이러한 파라미터 설정을 자동화하고, 머신러닝 개발자들이 기존 개발 환경에서 손쉽게 동형암호를 적용할 수 있도록 하는 고수준의 컴파일러와 프레임워크 개발이 필요하다.42</p>
<p>셋째, 신뢰성 있는 기술 생태계 조성을 위한 <strong>표준화</strong> 노력이 요구된다. 다양한 동형암호 스킴과 라이브러리 간의 상호운용성을 확보하고, 보안 수준, 정확도, 성능을 객관적으로 평가하고 비교할 수 있는 표준화된 파라미터 셋과 벤치마크가 마련되어야 한다.</p>
<p>이러한 과제들이 해결된다면, 벡터 암호화 기술은 규제가 엄격하여 AI 도입에 어려움을 겪었던 의료, 금융, 공공 부문에서 데이터 기반 혁신을 가속화하는 핵심 기폭제가 될 것이다.1 미래에는 동형암호뿐만 아니라 안전한 다자간 계산, 차분 프라이버시, 연합 학습 등 다양한 프라이버시 보존 기술들이 각자의 장점을 살려 유기적으로 융합된 하이브리드 솔루션이 데이터 처리 파이프라인의 표준으로 자리 잡을 것이다.53</p>
<p>궁극적으로, 벡터 암호화 기술은 단순히 데이터를 보호하는 수동적 방어막을 넘어, 사용자가 자신의 데이터를 안심하고 제공하며 AI가 제공하는 무한한 혜택을 온전히 누릴 수 있도록 하는 ‘신뢰 기반 AI(Trustworthy AI)’ 생태계를 구축하는 데 가장 핵심적인 역할을 수행할 것으로 전망된다. 기술의 발전이 인류에게 이로운 방향으로 나아가기 위해서는, 그 기반에 신뢰가 있어야 하며, 벡터 암호화는 그 신뢰를 기술적으로 담보하는 약속이 될 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Cyborg 및 RAPIDS cuVS로 벡터 검색에 기밀성 제공 - NVIDIA …, https://developer.nvidia.com/ko-kr/blog/bringing-confidentiality-to-vector-search-with-cyborg-and-rapids-cuvs/</li>
<li>프롬프트 엔지니어링(3) - 검색엔진의 진화 Vector Search - 부딪히고 깨져야 원석이 된다., https://hwo7513565.tistory.com/117</li>
<li>벡터 검색 | Vertex AI - Google Cloud, https://cloud.google.com/vertex-ai/docs/vector-search/overview?hl=ko</li>
<li>벡터 검색이란 무엇인가요? - IBM, https://www.ibm.com/kr-ko/think/topics/vector-search</li>
<li>벡터 검색(Vector Search) 공개 미리보기 발표 - Databricks, https://www.databricks.com/kr/blog/introducing-databricks-vector-search-public-preview</li>
<li>데이터 암호화가 필수적인 이유 - Couchbase, https://www.couchbase.com/blog/ko/why-data-encryption-is-essential-2/</li>
<li>[전문가 강좌] 생성형 AI, 벡터 데이터베이스로 데이터 패러다임을 혁신하다 - 컴퓨터월드, https://www.comworld.co.kr/news/articleView.html?idxno=51238</li>
<li>ICD-10 Code Representation in Embedding Vector Spaces | IntuitionLabs, https://intuitionlabs.ai/articles/icd-10-code-embedding-vector-spaces</li>
<li>Private Release of Text Embedding Vectors - ACL Anthology, https://aclanthology.org/2021.trustnlp-1.3.pdf</li>
<li>Synopsis: Secure and private trend inference from encrypted semantic embeddings - arXiv, https://arxiv.org/pdf/2505.23880</li>
<li>네이버클라우드 “AI시대 최강보안 ‘동형암호’, 기술력으로 한계 극복” - 디지털데일리, https://m.ddaily.co.kr/page/view/2025012209401203167</li>
<li>동형암호(Homomorphic Encryption) - C’s Shelter - 티스토리, https://gnuhcjh.tistory.com/25</li>
<li>모두의 인공지능 기초 수학: 3 직교 벡터 - 9 - 더북(TheBook), https://thebook.io/080246/0294/</li>
<li>
<ol>
<li>군집화 (Clustering) - 유사도 측정 기법 - devvon - 티스토리, https://pickwon.tistory.com/160</li>
</ol>
</li>
<li>[딥러닝을 이용한 자연어 처리 입문] 5. 벡터의 유사도(Vector Similarity) - Tech for good, https://dianakang.tistory.com/54</li>
<li>[python] 데이터 유사성 측정방법, https://anweh.tistory.com/54</li>
<li>[NLP] Similarity Measures (유사도 측정) - AI Archive, https://doheejin.github.io/ai_concepts/2022/09/04/similarities.html</li>
<li>[자연어처리 입문] 4. 벡터의 유사도(Vector Similarity), https://codong.tistory.com/35</li>
<li>동형(Homomorphic)암호 표준동향, https://www.koreascience.kr/article/JAKO202125761253598.pdf</li>
<li>동형(Homomorphic)암호 표준동향 -Review of KIISC - Korea Science, https://koreascience.kr/article/JAKO202125761253598.view?orgId=anpor</li>
<li>동형암호 기반 딥러닝 기법 연구 동향 - Korea Science, https://koreascience.kr/article/CFKO202220859215200.pdf</li>
<li>동형암호(Homomorphic Encryption): 암호화된 상태에서의 데이터 연산 기술, https://j2doll.tistory.com/1041</li>
<li>동형암호(Homomorphic Encryption), https://soncs.tistory.com/155</li>
<li>동형암호기반 데이터 유출 방지 표준 동향, https://www.tta.or.kr/data/androReport/ttaJnal/193-1-3-6.pdf</li>
<li>8 OECD, 암호화(Encryption)의 주요 개념 및 기술 동향 소개, https://www.kistep.re.kr/gpsBoardDownload.es?board_se=trend&amp;list_no=3330&amp;seq=1</li>
<li>동형암호 - 1. Introduction, https://velog.io/@wonderit/HE-Introduction</li>
<li>클라우드 환경에서 데이터와 AI를 지켜줄 동형암호 – 잠재력, 연구 동향 - AHHA Labs, https://ahha.ai/2023/11/02/homomorphic/</li>
<li>동형암호 기반 프라이버시 보존 CNN 알고리즘 개발 꿀팁 대방출, [https://deview.kr/data/deview/session/attach/<a href="https://deview.kr/data/deview/session/attach/%5B243%5D%EB%8F%99%ED%98%95%EC%95%94%ED%98%B8%20%EA%B8%B0%EB%B0%98%20%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C%20%EB%B3%B4%EC%A1%B4%20CNN%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EA%B0%9C%EB%B0%9C%20%EA%BF%80%ED%8C%81%20%EB%8C%80%EB%B0%A9%EC%B6%9C.pdf">243]%EB%8F%99%ED%98%95%EC%95%94%ED%98%B8%20%EA%B8%B0%EB%B0%98%20%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B2%84%EC%8B%9C%20%EB%B3%B4%EC%A1%B4%20CNN%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EA%B0%9C%EB%B0%9C%20%EA%BF%80%ED%8C%81%20%EB%8C%80%EB%B0%A9%EC%B6%9C.pdf</a></li>
<li>[시장동향] 현실화되는 동형암호, 관건은 ‘성능’ - 컴퓨터월드, https://www.comworld.co.kr/news/articleView.html?idxno=50372</li>
<li>Applications of Homomorphic Encryption and Secure Multi-Party …, https://www.cyberark.com/resources/blog/applications-of-homomorphic-encryption-and-secure-multi-party-computation</li>
<li>Introduction To Homomorphic Encryption With Microsoft SEAL - C# Corner, https://www.c-sharpcorner.com/article/introduction-to-homomorphic-encryption-with-microsoft-seal/</li>
<li>CKKS 동형암호에서의 비산술 연산을 위한 안정적인 최적 다항식 근사 방법 - AWS, https://manuscriptlink-society-file.s3-ap-northeast-1.amazonaws.com/kics/conference/jcci2022/presentation/1570797382.pdf</li>
<li>Introduction To HEAAN (Aka CKKS) : Yongsoo Song, Microsoft …, https://www.scribd.com/document/579565232/2004simonsheaan</li>
<li>HEAAN Demystified: Accelerating Fully Homomorphic Encryption …, https://arxiv.org/pdf/2003.04510</li>
<li>완전동형암호 연산 가속 하드웨어 기술 동향, <a href="https://ettrends.etri.re.kr/ettrends/193/0905193001/001-012_%EB%B0%95%EC%84%B1%EC%B2%9C_193%ED%98%B8.pdf">https://ettrends.etri.re.kr/ettrends/193/0905193001/001-012_%EB%B0%95%EC%84%B1%EC%B2%9C_193%ED%98%B8.pdf</a></li>
<li>Introduction to Microsoft SEAL: Exploring Homomorphic Encryption | by Anderson Godoy, https://medium.com/@anderson.buenogod/introduction-to-microsoft-seal-exploring-homomorphic-encryption-910f1af0cb56</li>
<li>(PDF) Secure Logistic Regression Based on Homomorphic …, https://www.researchgate.net/publication/324583361_Secure_Logistic_Regression_Based_on_Homomorphic_Encryption_Design_and_Evaluation</li>
<li>Approximate Homomorphic Encryption with Reduced Approximation Error | Request PDF, https://www.researchgate.net/publication/358215705_Approximate_Homomorphic_Encryption_with_Reduced_Approximation_Error</li>
<li>‪Yongsoo Song‬ - ‪Google Scholar‬, https://scholar.google.co.il/citations?user=KUHhL3QAAAAJ&amp;hl=th</li>
<li>A Full RNS Variant of Approximate Homomorphic Encryption | springerprofessional.de, https://www.springerprofessional.de/en/a-full-rns-variant-of-approximate-homomorphic-encryption/16394428</li>
<li>Efficient Bootstrapping for Approximate Homomorphic Encryption with Non-sparse Keys | Request PDF - ResearchGate, https://www.researchgate.net/publication/352417073_Efficient_Bootstrapping_for_Approximate_Homomorphic_Encryption_with_Non-sparse_Keys</li>
<li>Orion: A Fully Homomorphic Encryption Framework for Deep Learning - arXiv, https://arxiv.org/html/2311.03470v3</li>
<li>Introduction to Microsoft SEAL Homomorphic Encryption Library - IAIK, https://www.isec.tugraz.at/wp-content/uploads/2021/08/seal.pdf</li>
<li>Private AI Bootcamp: Microsoft researchers share knowledge on cryptography, security, and privacy with PhD students, https://www.microsoft.com/en-us/research/blog/private-ai-bootcamp-microsoft-researchers-share-knowledge-on-cryptography-security-and-privacy-with-phd-students/</li>
<li>microsoft/SEAL: Microsoft SEAL is an easy-to-use and … - GitHub, https://github.com/microsoft/SEAL</li>
<li>Privacy-Preserving Machine Learning with Homomorphic Encryption among Multi-Parties: Master’s Thesis Degree Project - DiVA portal, https://www.diva-portal.org/smash/get/diva2:1947274/FULLTEXT01.pdf</li>
<li>Multi-key Homomorphic Encryption - Yongsoo Song, https://yongsoosong.github.io/files/slides/Simons_HEAAN.pdf</li>
<li>Homomorphic Encryption and Secure Multi-Party Computation - IJRASET, https://www.ijraset.com/research-paper/homomorphic-encryption-and-secure-multi-party-computation</li>
<li>Secure multi-party computation - Wikipedia, https://en.wikipedia.org/wiki/Secure_multi-party_computation</li>
<li>How does homomorphic encryption compare to secure multi-party computation in terms of security and performance?, <a href="https://massedcompute.com/faq-answers/?question=How+does+homomorphic+encryption+compare+to+secure+multi-party+computation+in+terms+of+security+and+performance?">https://massedcompute.com/faq-answers/?question=How%20does%20homomorphic%20encryption%20compare%20to%20secure%20multi-party%20computation%20in%20terms%20of%20security%20and%20performance?</a></li>
<li>Homomorphic Encryption and Secure Multi-Party Computation …, https://library.fiveable.me/edge-ai-and-computing/unit-11/homomorphic-encryption-secure-multi-party-computation/study-guide/zgVvHydApcBVPctz</li>
<li>Securing Large Language Models Against Membership Inference Attacks - Uppsala University, https://uu.diva-portal.org/smash/get/diva2:1895805/FULLTEXT01.pdf</li>
<li>Privacy-preserving machine learning: a review of federated learning techniques and ‎applications - ResearchGate, https://www.researchgate.net/publication/388822437_Privacy-preserving_machine_learning_a_review_of_federated_learning_techniques_and_applications</li>
<li>Privacy-Preserving Machine Learning Techniques for Healthcare Data Analysis, https://journals.mriindia.com/index.php/ijraet/article/view/114</li>
<li>A Pragmatic Introduction to Secure Multi-Party Computation - ResearchGate, https://www.researchgate.net/publication/339504451_A_Pragmatic_Introduction_to_Secure_Multi-Party_Computation</li>
<li>Best Practices for Privacy in RAG Chatbots - Artech Digital, https://www.artech-digital.com/blog/best-practices-for-privacy-in-rag-chatbots</li>
<li>BLAZE: Blazing Fast Privacy-Preserving Machine Learning - NDSS Symposium, https://www.ndss-symposium.org/ndss-paper/blaze-blazing-fast-privacy-preserving-machine-learning/</li>
<li>Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning, https://www.ndss-symposium.org/ndss-paper/trident-efficient-4pc-framework-for-privacy-preserving-machine-learning/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>