<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:대한민국 국가 표준 암호 알고리즘의 구조 및 보안성</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>대한민국 국가 표준 암호 알고리즘의 구조 및 보안성</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">정보 보안 (Information Security)</a> / <a href="index.html">암호학</a> / <span>대한민국 국가 표준 암호 알고리즘의 구조 및 보안성</span></nav>
                </div>
            </header>
            <article>
                <h1>대한민국 국가 표준 암호 알고리즘의 구조 및 보안성</h1>
<h2>1. 서론: 국가 정보보호의 초석, 대한민국 표준 암호</h2>
<p>국가 주도의 암호 기술 개발은 단순한 기술적 성취를 넘어, 디지털 시대의 주권을 확보하고 국가 핵심 정보통신 기반 시설을 보호하기 위한 전략적 행위이다. 대한민국은 1999년 민간 주도로 개발된 SEED 알고리즘을 시작으로 , 국가적 차원에서 정보보호 기술의 자립을 추구해왔다. 이러한 노력은 외부 기술에 대한 의존도를 낮추고, 잠재적으로 발생할 수 있는 기술적 종속이나 비관세 무역 장벽에 대응하는 다층적 목표를 내포한다.</p>
<p>이러한 국가 암호 생태계의 중심에는 **암호모듈검증제도(Korea Cryptographic Module Validation Program, KCMVP)**가 자리 잡고 있다. <code>전자정부법</code> 및 <code>사이버안보 업무규정</code>에 법적 근거를 둔 이 제도는 국가 및 공공기관의 정보통신망에서 사용되는 암호모듈의 안전성과 구현 적합성을 검증하는 핵심적인 역할을 수행한다.3 KCMVP는 비밀이 아닌 중요 업무자료를 보호하기 위해 도입되는 정보보호제품에 대해 검증필 암호모듈 탑재를 사실상 의무화함으로써, 국내에서 개발된 표준 암호 알고리즘의 채택을 유도하고 관련 산업 생태계를 형성하는 데 결정적인 영향을 미쳤다.5</p>
<p>본 보고서는 KCMVP의 검증 대상 알고리즘이자 대한민국 국가 표준으로 지정된 4대 핵심 암호 기술—<strong>ARIA, LEA, HIGHT, LSH</strong>—에 대한 심층 분석을 목적으로 한다. 각 알고리즘의 개발 배경, 구조적 특징, 핵심 연산 과정, 그리고 보안성을 기술적 관점에서 면밀히 분석할 것이다. 이들 알고리즘의 개발 연혁과 기술적 목표를 살펴보면, 이는 단순한 개별 기술의 집합이 아닌, 변화하는 IT 환경에 대응하며 완전한 암호 기술 주권을 확보하려는 국가의 체계적인 진화 경로를 보여준다. 2004년 국제 표준 AES에 대응하는 범용 블록 암호 ARIA를 통해 표준의 기틀을 마련한 것을 시작으로 8, 2006년에는 RFID/USN 등 저자원 환경을 겨냥한 경량 블록 암호 HIGHT를 개발하여 기술 적용 범위를 특화했다.10 이후 2013년에는 빅데이터 및 클라우드 환경에서 소프트웨어 성능을 극대화한 LEA를 선보였고 11, 2014년에는 기존 해시 함수의 취약성에 대응하기 위한 고속 해시 함수 LSH를 개발하며 암호 시스템의 근간을 현대화했다.13 이처럼 각 알고리즘은 시대적 요구에 부응하며 국가 암호 기술의 포트폴리오를 전략적으로 확장해왔다.</p>
<p>나아가, 양자컴퓨터의 등장이 기존 공개키 암호 체계에 제기하는 심각한 위협에 대응하기 위해 국가보안기술연구소는 ’양자내성암호(Post-Quantum Cryptography, PQC) 연구단’을 발족하고 차세대 암호 표준화 공모를 진행하는 등 미래 암호 환경에 선제적으로 대비하고 있다.15 이는 대한민국의 암호 기술 개발이 현재의 안정성에 머무르지 않고, 다가올 패러다임 변화에 능동적으로 대처하고 있음을 시사한다.</p>
<h2>2.  대칭키 블록 암호 ARIA: 표준성과 범용성의 조화</h2>
<h3>2.1  개발 배경 및 설계 철학</h3>
<p>ARIA는 2003년 학계(Academy), 연구소(Research Institute), 정부 기관(Agency)의 암호 기술 전문가들이 공동으로 개발한 128비트 블록 암호 알고리즘이다.8 2004년 12월, 산업자원부(현 산업통상자원부)에 의해 대한민국 국가 표준(KS X 1213)으로 제정되었으며, 이는 국가 정보보호 시스템의 표준화를 위한 중요한 이정표가 되었다.9 ARIA 개발의 핵심 목표는 당시 미국 국립표준기술연구소(NIST)에 의해 새로운 표준으로 채택된 AES(Advanced Encryption Standard)와 동등한 수준의 보안성과 호환성을 갖춘 국가 고유의 표준 암호를 확보하는 것이었다. 이를 위해 ARIA는 AES와 동일한 128비트 블록 크기와 128, 192, 256비트의 가변 키 길이를 채택하여 국제 표준과의 상호 운용성을 전략적으로 고려하였다.8</p>
<p>ARIA의 가장 핵심적인 설계 철학은 <strong>Involutional Substitution-Permutation Network (SPN)</strong> 구조에 있다.8 ’Involution’이란 자기 자신을 역함수로 갖는 변환, 즉 두 번 적용하면 원래 상태로 돌아오는(<span class="math math-inline">f(f(x)) = x</span>) 성질을 의미한다. ARIA는 암호화 과정과 복호화 과정의 전체 구조를 동일하게 설계함으로써, 복호기를 별도로 구현할 필요 없이 암호화 회로를 재사용할 수 있도록 하였다. 이러한 대칭적 구조는 하드웨어 구현 시 회로의 면적을 줄이고, 소프트웨어 구현 시 코드 크기를 감소시켜 경량 환경에서의 효율성을 높이는 데 크게 기여한다.19</p>
<h3>2.2  기술 명세 및 전체 구조</h3>
<p>ARIA의 주요 기술적 제원은 아래 표와 같이 요약할 수 있다. 키 길이에 따라 라운드 수가 결정되며, 이는 AES와 동일한 규격이다.8</p>
<p><strong>표 1-1: ARIA 기술 명세</strong></p>
<table><thead><tr><th>항목</th><th>명세</th></tr></thead><tbody>
<tr><td>블록 크기</td><td>128비트</td></tr>
<tr><td>키 크기</td><td>128 / 192 / 256비트</td></tr>
<tr><td>구조</td><td>Involutional SPN (Substitution-Permutation Network)</td></tr>
<tr><td>라운드 수</td><td>12 (128비트 키) / 14 (192비트 키) / 16 (256비트 키)</td></tr>
</tbody></table>
<p>ARIA의 암호화 및 복호화 과정은 SPN 구조를 기반으로 한다. 전체 과정은 다음과 같이 구성된다.21</p>
<ol>
<li>
<p><strong>초기 라운드 키 덧셈:</strong> 128비트 평문 블록에 첫 번째 라운드 키(<code>ek₁</code>)를 XOR 연산한다.</p>
</li>
<li>
<p><strong>라운드 반복:</strong> 키 길이에 따라 정해진 <code>N</code> 라운드 중, <code>N-1</code> 번의 라운드 함수를 반복 적용한다. 각 라운드는 <code>치환 계층(Substitution Layer)</code>과 <code>확산 계층(Diffusion Layer)</code>, 그리고 <code>라운드 키 덧셈(Round Key Addition)</code>으로 구성된다.</p>
</li>
<li>
<p><strong>최종 라운드:</strong> 마지막 <code>N</code>번째 라운드에서는 <code>확산 계층</code>을 생략하고 <code>치환 계층</code>과 <code>라운드 키 덧셈</code>만 수행한다. 이는 암호화와 복호화 과정의 대칭성을 유지하기 위한 구조적 장치이다.21</p>
</li>
</ol>
<p>복호화 과정은 암호화 과정의 역순으로 진행되지만, Involution 구조 덕분에 각 계층(치환, 확산)과 키 스케줄이 모두 대칭적으로 설계되어 있어 암호화와 동일한 구조를 사용한다. 단지 라운드 키를 역순으로 적용할 뿐이다.</p>
<h3>2.3  핵심 연산 분석: 라운드 함수</h3>
<p>ARIA의 라운드 함수는 <code>라운드 키 덧셈</code>, <code>치환 계층</code>, <code>확산 계층</code>의 세 가지 핵심적인 변환으로 구성된다.22</p>
<h4>2.3.1  치환 계층(Substitution Layer)</h4>
<p>치환 계층은 데이터에 비선형성(non-linearity)을 부여하는 핵심적인 부분으로, 바이트 단위의 치환을 수행한다. ARIA는 두 종류의 8x8 S-box, <code>S₁</code>과 <code>S₂</code>, 그리고 각각의 역함수인 <code>S₁⁻¹</code>과 <code>S₂⁻¹</code>을 사용한다. 흥미롭게도 이 S-box들은 AES(Rijndael)에서 사용하는 S-box 및 그 역함수와 동일하다.22</p>
<p>전체 구조의 Involution 성질을 만족시키기 위해, ARIA는 홀수 라운드와 짝수 라운드에서 서로 다른 형태의 치환 계층을 교대로 사용한다.21 128비트(16바이트) 상태(State)를 4개의 32비트 워드로 나누어 각 워드에 서로 다른 S-box 조합을 적용하는 방식이다.</p>
<ul>
<li>
<p><strong>Type 1 (홀수 라운드):</strong> 16개의 바이트에 <code>(S₁, S₂, S₁⁻¹, S₂⁻¹)</code>의 S-box 조합을 순서대로 적용한다.</p>
</li>
<li>
<p><strong>Type 2 (짝수 라운드):</strong> 16개의 바이트에 <code>(S₁⁻¹, S₂⁻¹, S₁, S₂)</code>의 S-box 조합을 순서대로 적용한다.</p>
</li>
</ul>
<p>이처럼 한 라운드에서는 <code>S₁</code>을, 다음 라운드에서는 그 역함수인 <code>S₁⁻¹</code>을 사용하는 구조를 짝수 번 반복함으로써, 전체 치환 과정이 자기 자신을 역함수로 갖게 되어 Involution 성질을 만족시킨다.</p>
<h4>2.3.2  확산 계층(Diffusion Layer)</h4>
<p>확산 계층은 치환 계층을 거친 데이터의 각 비트가 다른 모든 비트에 영향을 미치도록 섞어주는 선형 변환(linear transformation) 과정이다. 이는 소수의 비트 변경이 전체 블록에 걸쳐 눈사태 효과(avalanche effect)를 일으키도록 보장한다. ARIA는 16x16 이진 행렬 <code>A</code>를 이용한 단순 행렬 곱셈으로 확산을 수행한다.21 이 행렬 <code>A</code> 역시 <code>A² = I</code> (I는 단위행렬)를 만족하는 Involution 행렬로 설계되었다.</p>
<p>128비트(16바이트) 입력 벡터를 <span class="math math-inline">x = (x_0, x_1,..., x_{15})^T</span>라 하고, 출력 벡터를 <span class="math math-inline">y = (y_0, y_1,..., y_{15})^T</span>라 할 때, 확산 연산은 유한체 <code>GF(2)</code> 상에서의 행렬 곱으로 다음과 같이 표현된다.</p>
<p><span class="math math-display">
y = A \cdot x
</span><br />
행렬 <code>A</code>의 각 원소는 0 또는 1이며, 행렬 곱셈은 비트 XOR 연산으로 구현된다. 예를 들어, 출력 바이트 <span class="math math-inline">y_0</span>와 <span class="math math-inline">y_8</span>은 다음과 같이 계산된다.22</p>
<p><span class="math math-display">
\begin{aligned}
y_0 &amp;= x_3 \oplus x_4 \oplus x_6 \oplus x_8 \oplus x_9 \oplus x_{13} \oplus x_{14} \\
y_8 &amp;= x_0 \oplus x_1 \oplus x_4 \oplus x_7 \oplus x_{10} \oplus x_{13} \oplus x_{15}
\end{aligned}
</span><br />
이러한 확산 방식은 128비트 상태 전체를 한 번에 혼합하여, AES의 MixColumns 연산이 32비트 단위로 확산을 수행하는 것에 비해 더 넓은 범위의 확산을 제공한다.</p>
<h3>2.4  핵심 연산 분석: 키 스케줄 알고리즘</h3>
<p>ARIA의 키 스케줄은 사용자가 제공한 마스터 키 <code>MK</code>로부터 각 라운드에서 사용될 <code>N+1</code>개의 128비트 라운드 키(<code>ek₁</code>,…, <code>ek_(N+1)</code>)를 생성하는 과정이다. 이 과정은 RFC 5794에 상세히 기술되어 있으며, 키 길이에 따라 다른 초기화 상수와 반복 횟수를 사용한다.24</p>
<p>키 스케줄은 크게 두 단계로 나뉜다.</p>
<ol>
<li>
<p><strong>초기화 단계:</strong> 마스터 키 <code>MK</code>를 4개의 128비트 임시 변수 <code>W₀, W₁, W₂, W₃</code>로 확장하는 과정이다. 이 과정은 256비트 Feistel 구조를 3라운드 적용하여 수행된다. 마스터 키와 라운드 상수 <code>C₁, C₂, C₃</code>를 입력으로 받아 복잡한 치환, 순환 이동, XOR 연산을 거쳐 <code>W₀, W₁, W₂, W₃</code>를 생성한다.</p>
</li>
<li>
<p><strong>라운드 키 생성 단계:</strong> 초기화 단계에서 생성된 <code>W₀, W₁, W₂, W₃</code>를 이용하여 각 라운드 키를 순차적으로 생성한다. <code>i</code>번째 라운드 키 <code>ekᵢ</code>는 <code>W</code> 값들의 조합과 XOR 연산을 통해 계산된다. 예를 들어, <code>ekᵢ</code>는 <code>W₀</code>를 특정 비트만큼 순환 이동시킨 값과 <code>W₁</code>, <code>W₂</code>, <code>W₃</code>의 조합으로 생성되며, 다음 라운드 키 생성을 위해 <code>W</code> 값들이 업데이트된다. 이 과정 역시 Involution 성질을 가지도록 설계되어, 복호화 시에는 암호화 라운드 키를 간단한 변환을 통해 복호화 라운드 키로 만들 수 있다.</p>
</li>
</ol>
<h3>2.5  표준화 및 보안성 평가</h3>
<p>ARIA는 2004년 대한민국 국가 표준(KS X 1213)으로 제정된 이후 9, 국제 인터넷 표준화 기구(IETF)에 의해 RFC 5794(알고리즘 명세)와 RFC 6209(TLS/SSL 적용)로 등록되어 국제적 인지도를 확보했다.18 이는 ARIA가 단순히 국내용 표준을 넘어 국제 인터넷 환경에서도 사용될 수 있는 기술적 기반을 갖추었음을 의미한다.</p>
<p>보안성 측면에서 ARIA는 현재까지 알려진 주요 암호 분석 기법에 대해 안전한 것으로 평가된다. 개발 초기부터 차분 공격(Differential Cryptanalysis), 선형 공격(Linear Cryptanalysis) 등에 대한 안전성이 분석되었다. 일부 축소 라운드에 대한 공격이 발표된 바 있으나, 전체 라운드에 대한 실질적인 위협은 보고되지 않았다. 예를 들어, 8라운드 ARIA에 대한 중간자 공격(Meet-in-the-middle attack)이 알려져 있지만, 이는 키 길이에 따라 12, 14, 16라운드로 구성된 전체 ARIA의 안전성을 위협하지는 않는다.18</p>
<h2>3.  경량 고속 블록 암호 LEA: 소프트웨어 환경의 지배자</h2>
<h3>3.1  개발 배경 및 설계 철학</h3>
<p>LEA(Lightweight Encryption Algorithm)는 2013년 국가보안기술연구소(NSRI)에 의해 개발된 128비트 블록 암호 알고리즘이다.11 LEA의 등장은 빅데이터, 클라우드 컴퓨팅, 모바일 기기의 확산이라는 시대적 변화와 밀접한 관련이 있다. 이러한 환경에서는 대용량 데이터를 신속하게 처리하는 소프트웨어의 성능이 매우 중요해졌고, 기존의 암호 알고리즘, 특히 하드웨어에 최적화된 AES보다 소프트웨어 환경에서 더 빠른 성능을 제공하는 새로운 암호 기술이 요구되었다.12</p>
<p>LEA의 핵심 설계 철학은 <strong>ARX(Addition, Rotation, XOR)</strong> 연산만을 사용하는 것이다.11 ARX는 현대의 범용 CPU가 매우 효율적으로 처리할 수 있는 기본 명령어들이다. LEA는 암호 알고리즘의 비선형성을 제공하기 위해 전통적으로 사용되던 S-box(치환 테이블)를 완전히 배제했다.27 S-box는 메모리 참조를 필요로 하여 소프트웨어에서 성능 저하의 원인이 될 수 있으며, 캐시 메모리의 접근 패턴을 분석하는 부채널 공격(Side-channel attack)에 취약할 수 있다.28 LEA는 S-box 대신 32비트 워드 단위의 모듈러 덧셈(</p>
<p><span class="math math-inline">A</span>), 비트 순환 이동(<span class="math math-inline">R</span>), 그리고 배타적 논리합(<span class="math math-inline">X</span>) 연산을 조합하여 비선형성과 확산을 구현함으로써, 소프트웨어에서의 고속 암호화와 부채널 공격에 대한 저항성을 동시에 달성하고자 했다.</p>
<h3>3.2  기술 명세 및 GFN(Generalized Feistel Network) 구조</h3>
<p>LEA의 주요 기술적 제원은 아래 표와 같다. ARIA와 마찬가지로 128비트 블록과 가변 키 길이를 지원하지만, 구조와 라운드 수에서 차이를 보인다.11</p>
<p><strong>표 2-1: LEA 기술 명세</strong></p>
<table><thead><tr><th>항목</th><th>명세</th></tr></thead><tbody>
<tr><td>블록 크기</td><td>128비트</td></tr>
<tr><td>키 크기</td><td>128 / 192 / 256비트</td></tr>
<tr><td>구조</td><td>ARX 기반 GFN (Generalized Feistel Network)</td></tr>
<tr><td>라운드 수</td><td>24 (128비트 키) / 28 (192비트 키) / 32 (256비트 키)</td></tr>
</tbody></table>
<p>LEA는 128비트 데이터 블록을 4개의 32비트 워드(<span class="math math-inline">X, X, X, X</span>)로 나누어 처리하는 **일반화된 파이스텔 구조(Generalized Feistel Network, GFN)**를 채택했다.11 전통적인 파이스텔 구조가 블록을 두 부분으로 나누는 것과 달리, GFN은 여러 개의 서브 블록으로 나누어 더 복잡한 데이터 흐름을 만들어낸다. LEA의 GFN 구조는 각 라운드에서 3개의 워드는 라운드 함수를 통해 변환되고, 나머지 1개의 워드는 그대로 다음 라운드로 전달되는 형태를 취하여 효율적인 확산을 달성한다.30</p>
<h3>3.3  핵심 연산 분석: 라운드 함수</h3>
<p>LEA의 라운드 함수는 ARX 연산의 조합으로 매우 간결하게 구성된다. <span class="math math-inline">i</span>번째 라운드에서 입력 128비트 상태를 <span class="math math-inline">X^{(i)} = (X^{(i)}, X^{(i)}, X^{(i)}, X^{(i)})</span>라 하고, 해당 라운드에서 사용되는 192비트(6개의 32비트 워드) 라운드 키를 <span class="math math-inline">RK^{(i)} = (RK^{(i)},..., RK^{(i)})</span>라 할 때, 다음 라운드의 상태 <span class="math math-inline">X^{(i+1)}</span>은 다음과 같은 연산을 통해 계산된다.29</p>
<p><span class="math math-display">
\begin{aligned}
X^{(i+1)} &amp;= ((X^{(i)} \oplus RK^{(i)}) \boxplus (X^{(i)} \oplus RK^{(i)})) \lll 9 \\
X^{(i+1)} &amp;= ((X^{(i)} \oplus RK^{(i)}) \boxplus (X^{(i)} \oplus RK^{(i)})) \ggg 5 \\
X^{(i+1)} &amp;= ((X^{(i)} \oplus RK^{(i)}) \boxplus (X^{(i)} \oplus RK^{(i)})) \ggg 3 \\
X^{(i+1)} &amp;= X^{(i)}
\end{aligned}
</span><br />
여기서 <span class="math math-inline">\boxplus</span>는 모듈러 <span class="math math-inline">2^{32}</span> 덧셈, <span class="math math-inline">\oplus</span>는 비트 단위 XOR, <span class="math math-inline">\lll s</span>는 <span class="math math-inline">s</span>비트 좌측 순환 이동(Left Rotation), <span class="math math-inline">\ggg s</span>는 <span class="math math-inline">s</span>비트 우측 순환 이동(Right Rotation)을 의미한다. 이 구조에서 <span class="math math-inline">X^{(i)}</span>이 변환되지 않고 <span class="math math-inline">X^{(i+1)}</span>으로 이동하는 것은 GFN 구조의 특징을 잘 보여준다. 복호화 과정은 암호화의 역연산으로 구성되며, 모듈러 덧셈(<span class="math math-inline">\boxplus</span>)은 모듈러 뺄셈으로, 좌측 순환 이동(<span class="math math-inline">\lll</span>)은 우측 순환 이동(<span class="math math-inline">\ggg</span>)으로 대체된다.30</p>
<h3>3.4  핵심 연산 분석: 키 스케줄 알고리즘</h3>
<p>LEA의 키 스케줄은 마스터 키 <code>K</code>로부터 각 라운드에서 사용될 라운드 키 <code>RK</code>를 생성하는 과정이다. 이 과정 역시 ARX 연산만을 사용하여 효율적으로 설계되었다. 키 길이에 따라 128, 192, 256비트의 마스터 키를 입력받아, 각각 24, 28, 32개의 192비트 라운드 키를 생성한다.29</p>
<p>키 스케줄은 사전에 정의된 32비트 상수 <span class="math math-inline">\delta[0..7]</span> 배열을 사용한다. 이 상수들은 원주율 <span class="math math-inline">\pi</span>의 소수점 이하 값들로부터 파생된 값으로, 특정 패턴이 없는 난수처럼 보이도록 설계되었다. <span class="math math-inline">i</span>번째 라운드 키 생성 시, 이전 단계에서 계산된 임시 키 값과 <span class="math math-inline">i</span>에 따라 순환적으로 선택되는 상수 <span class="math math-inline">\delta</span>를 사용하여 다음 라운드 키를 계산한다.</p>
<p>예를 들어, 128비트 마스터 키 <span class="math math-inline">K=(K, K, K, K)</span>의 경우, 임시 변수 <span class="math math-inline">T = (K, K, K, K)</span>를 초기화한 후, <span class="math math-inline">i=0</span>부터 23까지 다음의 과정을 반복하여 라운드 키 <span class="math math-inline">RK^{(i)}</span>를 생성한다.29</p>
<p><span class="math math-display">
\begin{aligned}
\delta[i] &amp;= \text{ROL}^{i}(0xc3efe9db) \\
T &amp;= (T \boxplus \text{ROL}^{1}(\delta[i \pmod 4])) \\
T &amp;= (T \boxplus \text{ROL}^{2}(\delta[i \pmod 4])) \\
T &amp;= (T \boxplus \text{ROL}^{3}(\delta[i \pmod 4])) \\
T &amp;= (T \boxplus \text{ROL}^{4}(\delta[i \pmod 4])) \\
RK^{(i)} &amp;= (T, T, T, T, T, T)
\end{aligned}
</span><br />
이처럼 LEA의 키 스케줄은 단순한 ARX 연산의 반복으로 구성되어 있어 매우 빠르게 실행될 수 있으며, 이는 전체 암호화 성능 향상에 기여한다.</p>
<h3>3.5  표준화 및 성능 평가</h3>
<p>LEA는 2013년 한국정보통신기술협회(TTA) 표준(TTAK.KO-12.0223)으로 제정되었고 31, 이후 2016년 국가 표준(KS X 3246)으로 지정되었다.32 더 나아가, 2019년에는 국제표준화기구(ISO/IEC)의 경량 블록 암호 분야 국제 표준(ISO/IEC 29192-2)으로 제정되어 국제적인 공신력을 확보했다.29 이는 미국 국가안보국(NSA)이 추진하던 SIMON/SPECK이 안전성 논란으로 표준화가 중단된 것과 대조적으로, LEA의 기술적 우수성과 안전성을 국제적으로 인정받은 성과이다.27</p>
<p>성능 면에서 LEA는 다양한 소프트웨어 환경에서 국제 표준인 AES 대비 평균 1.5배에서 2배 빠른 암호화 속도를 보인다.11 AES 개발 기관인 벨기에 COSIC 연구소로부터 안전성을 검증받았으며, 국제 경량암호 성능평가(FELICS)에서 128비트 블록 암호 중 1위를 차지하는 등 객관적인 성능 우위를 입증했다.32 또한, AES와 달리 키 스케줄의 구조적 특성에 기인한 이론적 취약점이 존재하지 않으며, 현재까지 알려진 모든 블록 암호 공격 기법에 대해 안전한 것으로 평가받고 있다.12 이러한 특성 덕분에 LEA는 스마트그리드, 압축 암호화, 인증 시스템 등 국가·공공 분야는 물론, IoT 환경과 같이 높은 처리량과 낮은 전력 소비가 요구되는 다양한 분야에서 널리 활용되고 있다.32</p>
<h2>4.  초경량 블록 암호 HIGHT: 저자원 환경의 수호자</h2>
<h3>4.1  개발 배경 및 설계 철학</h3>
<p>HIGHT(HIGh security and light weigHT)는 2005년 한국인터넷진흥원(KISA), 국가보안기술연구소(당시 ETRI 부설 연구소), 고려대학교가 공동으로 개발한 64비트 블록 암호 알고리즘이다.10 HIGHT의 개발 목표는 명확했다. 바로 RFID 태그, 무선 센서 네트워크(USN), 그리고 사물인터넷(IoT) 디바이스와 같이 계산 능력, 메모리, 전력 공급이 극도로 제한된 저자원 환경에서 효율적인 기밀성을 제공하는 것이다.10</p>
<p>당시 표준이었던 AES나 ARIA는 128비트 블록 크기를 기반으로 하여 이러한 초경량 환경에 적용하기에는 부담이 컸다. HIGHT는 블록 크기를 64비트로 줄이고, 하드웨어 구현 시 논리 게이트의 수를 최소화하는 데 설계의 초점을 맞췄다. 이를 위해 알고리즘의 모든 연산을 8비트 단위의 단순한 연산, 즉 모듈러 덧셈, 비트 단위 XOR, 그리고 비트 순환 이동만으로 구성하였다.34 이러한 설계 철학은 HIGHT가 최소한의 자원으로 최대한의 보안성과 효율성을 달성하도록 만들었다.</p>
<h3>4.2  기술 명세 및 Feistel 변형 구조</h3>
<p>HIGHT의 주요 기술적 제원은 아래 표와 같다. 64비트 블록 크기와 128비트 고정 키 길이는 이 알고리즘의 경량화 특성을 명확히 보여준다.33</p>
<p><strong>표 3-1: HIGHT 기술 명세</strong></p>
<table><thead><tr><th>항목</th><th>명세</th></tr></thead><tbody>
<tr><td>블록 크기</td><td>64비트</td></tr>
<tr><td>키 크기</td><td>128비트</td></tr>
<tr><td>구조</td><td>일반화된 Feistel 변형 구조 (Generalized Feistel Network variant)</td></tr>
<tr><td>라운드 수</td><td>32</td></tr>
</tbody></table>
<p>HIGHT는 64비트 평문을 8개의 8비트 바이트(<span class="math math-inline">X_0,..., X_7</span>)로 나누어 처리하는 일반화된 파이스텔 구조의 변형된 형태를 채택했다.35 각 라운드에서 일부 바이트는 위치를 바꾸고, 나머지 바이트는 라운드 함수와 서브키를 통해 복잡하게 변환된다. 이 구조는 암호화와 복호화 과정에서 라운드 함수의 역함수가 필요 없도록 설계되어 구현을 단순화하는 데 기여한다.</p>
<h3>4.3  핵심 연산 분석: 라운드 함수</h3>
<p>HIGHT의 라운드 함수는 32라운드에 걸쳐 반복되며, 각 라운드는 4개의 8비트 서브키를 사용한다. 라운드 함수의 핵심은 두 개의 보조 함수 <span class="math math-inline">F_0</span>와 <span class="math math-inline">F_1</span>이다. 이 함수들은 8비트 입력에 대해 비트 단위 확산을 수행하는 선형 변환으로, 비트 회전과 XOR 연산으로 구성된다.36</p>
<p><span class="math math-display">
\begin{aligned}
F_0(x) &amp;= (x \lll 1) \oplus (x \lll 2) \oplus (x \lll 7) \\
F_1(x) &amp;= (x \lll 3) \oplus (x \lll 4) \oplus (x \lll 6)
\end{aligned}
</span><br />
<span class="math math-inline">i</span>번째 라운드에서 입력 상태를 <span class="math math-inline">X_i = (X_{i,7} || \dots || X_{i,0})</span>라 하고, 4개의 서브키를 <span class="math math-inline">SK_{4i+3}</span>, <span class="math math-inline">SK_{4i+2}</span>, <span class="math math-inline">SK_{4i+1}</span>, <span class="math math-inline">SK_{4i}</span>라 할 때, 다음 라운드 상태 Xi+1`은 다음과 같이 계산된다.33</p>
<p><span class="math math-display">
\begin{aligned}
X_{i+1,0} &amp;= X_{i,7} \oplus (F_0(X_{i,6}) \boxplus SK_{4i+3}) \\
X_{i+1,1} &amp;= X_{i,0} \\
X_{i+1,2} &amp;= X_{i,1} \boxplus (F_1(X_{i,0}) \oplus SK_{4i+2}) \\
X_{i+1,3} &amp;= X_{i,2} \\
X_{i+1,4} &amp;= X_{i,3} \oplus (F_0(X_{i,2}) \boxplus SK_{4i+1}) \\
X_{i+1,5} &amp;= X_{i,4} \\
X_{i+1,6} &amp;= X_{i,5} \boxplus (F_1(X_{i,4}) \oplus SK_{4i}) \\
X_{i+1,7} &amp;= X_{i,6}
\end{aligned}
</span><br />
여기서 <span class="math math-inline">\boxplus</span>는 모듈러 <span class="math math-inline">2^8</span> 덧셈, <span class="math math-inline">\oplus</span>는 XOR, <span class="math math-inline">\lll s</span>는 <span class="math math-inline">s</span>비트 좌측 순환 이동을 의미한다. 이 구조에서 짝수 인덱스의 바이트는 변환되고, 홀수 인덱스의 바이트는 이전 라운드의 짝수 인덱스 바이트 값으로 대체되는 것을 볼 수 있다.</p>
<h3>4.4  핵심 연산 분석: 키 스케줄 알고리즘</h3>
<p>HIGHT의 키 스케줄은 다른 블록 암호와 구별되는 독특한 특징을 가진다. 128비트 마스터 키 <code>MK</code>로부터 두 종류의 키, 즉 **화이트닝 키(Whitening Key)**와 **서브키(Sub-key)**를 생성한다.35</p>
<ul>
<li>
<p><strong>화이트닝 키 생성:</strong> 총 8바이트의 화이트닝 키(<span class="math math-inline">WK_0, \dots, WK_7</span>)가 생성된다. 이 키들은 32라운드의 반복적인 라운드 함수 바깥, 즉 암호화의 가장 처음(초기 변환)과 가장 마지막(최종 변환)에 평문 및 암호문과 직접 연산된다. 이는 모든 라운드 함수가 동일한 구조를 가지더라도, 실제 암호화 과정은 마스터 키에 강하게 의존하도록 만들어 키 관련 공격(Key-related attack)을 방어하는 역할을 한다.33</p>
</li>
<li>
<p><strong>서브키 생성:</strong> 총 128바이트의 서브키(<span class="math math-inline">SK_0, \dots, SK_{127}</span>)가 생성되어, 32라운드에 걸쳐 라운드당 4바이트씩 사용된다. 서브키 생성 과정은 7비트 LFSR(선형 되먹임 시프트 레지스터)을 이용한다. 연결 다항식이 <span class="math math-inline">x^7 + x^3 + 1</span>인 LFSR을 통해 128개의 7비트 상수 <span class="math math-inline">\delta_i</span>를 생성하고, 이 상수들을 마스터 키 <code>MK</code>의 특정 바이트와 모듈러 <span class="math math-inline">2^8</span> 덧셈을 하여 최종 서브키를 얻는다.33 이 과정은 마스터 키의 비선형적 확산을 유도하여 암호의 보안 강도를 높인다.</p>
</li>
</ul>
<h3>4.5  표준화 및 구현 효율성 평가</h3>
<p>HIGHT는 2006년 12월 TTA 표준으로 제정되었으며, 2010년 12월에는 ISO/IEC 국제 표준(ISO/IEC 18033-3)으로 채택되어 국제 무대에서 그 기술력을 인정받았다.10 이는 HIGHT가 경량 암호 분야에서 국제적인 경쟁력을 갖추었음을 의미한다.</p>
<p>HIGHT의 가장 큰 장점은 하드웨어 구현 효율성이다. 0.25µm 공정 기준으로 HIGHT는 약 3048개의 논리 게이트(GEs)로 구현이 가능하며, 이는 동일 조건에서 약 3400개의 게이트를 필요로 하는 AES보다 더 적은 면적이다. 그럼에도 불구하고 80MHz 동작 주파수에서 HIGHT는 150.6 Mbps의 처리 속도를 보이는 반면, AES는 9.9 Mbps에 그친다.10 이 데이터는 HIGHT가 저자원, 저전력이라는 목표 환경에서 얼마나 효율적으로 동작하는지를 명확하게 보여준다. 이러한 특성 덕분에 HIGHT는 스마트카드, IoT 보안 모듈 등 다양한 경량 컴퓨팅 환경에서 활용될 수 있는 잠재력을 가지고 있다.35</p>
<h2>5.  고속 해시 함수 LSH: 무결성 보장의 새로운 표준</h2>
<h3>5.1  개발 배경 및 설계 철학</h3>
<p>LSH(Lightweight Secure Hash)는 2014년 국가보안기술연구소에서 개발한 암호학적 해시 함수군이다.13 LSH의 개발은 2000년대 중반, 당시 널리 사용되던 해시 함수인 SHA-1에서 이론적인 충돌(collision) 취약성이 발견되면서 새로운 표준 해시 함수에 대한 필요성이 전 세계적으로 대두된 시점과 맞물린다.14 이에 미국 NIST는 SHA-3 표준화 공모 사업을 진행하였고, 대한민국 역시 독자적인 차세대 해시 함수 개발에 착수하여 LSH를 선보였다.</p>
<p>LSH의 핵심 설계 목표는 PC, 스마트폰 등 범용 CPU 환경에서 데이터의 무결성 검증, 전자서명, 사용자 인증 등 다양한 응용 분야에 사용될 수 있는 고속의 안전한 해시 함수를 제공하는 것이었다.13 이를 위해 LSH는 LEA와 마찬가지로 ARX(덧셈, 회전, XOR) 연산을 기반으로 설계되었다. 이러한 구조는 최신 CPU에 탑재된 SIMD(Single Instruction, Multiple Data) 명령어(예: SSE, AVX)를 활용한 병렬 처리에 매우 유리하여, 소프트웨어 구현 시 높은 처리 속도를 달성할 수 있도록 한다.38</p>
<h3>5.2  기술 명세 및 Wide-pipe Merkle-Damgård 구조</h3>
<p>LSH는 단일 알고리즘이 아니라, 내부 상태 크기와 최종 출력 길이에 따라 여러 변종을 포함하는 해시 함수군(family of hash functions)이다. LSH의 명명법은 <code>LSH-내부상태크기-출력길이</code>의 형태를 따르지만, 일반적으로 워드 크기를 기준으로 LSH-256과 LSH-512 계열로 나뉜다. 주요 기술적 제원은 아래 표와 같다.40</p>
<p><strong>표 4-1: LSH 기술 명세</strong></p>
<table><thead><tr><th>알고리즘</th><th>출력 길이 (n)</th><th>체인 변수 크기</th><th>메시지 블록 크기</th><th>워드 크기 (w)</th></tr></thead><tbody>
<tr><td>LSH-256-224</td><td>224비트</td><td>512비트</td><td>1024비트</td><td>32비트</td></tr>
<tr><td>LSH-256-256</td><td>256비트</td><td>512비트</td><td>1024비트</td><td>32비트</td></tr>
<tr><td>LSH-512-224</td><td>224비트</td><td>1024비트</td><td>2048비트</td><td>64비트</td></tr>
<tr><td>LSH-512-256</td><td>256비트</td><td>1024비트</td><td>2048비트</td><td>64비트</td></tr>
<tr><td>LSH-512-384</td><td>384비트</td><td>1024비트</td><td>2048비트</td><td>64비트</td></tr>
<tr><td>LSH-512-512</td><td>512비트</td><td>1024비트</td><td>2048비트</td><td>64비트</td></tr>
</tbody></table>
<p>LSH의 전체 구조는 전통적인 해시 함수 구조인 <strong>Merkle-Damgård</strong> 구조를 기반으로 하되, 내부 상태(체인 변수)의 크기를 최종 출력 크기보다 크게 설계한 <strong>Wide-pipe</strong> 구조를 채택했다.40 예를 들어, LSH-256-256은 256비트 해시 값을 출력하지만 내부적으로는 512비트의 체인 변수를 사용한다. 이러한 Wide-pipe 설계는 길이 확장 공격(Length extension attack)과 같은 Merkle-Damgård 구조의 고전적인 취약점에 대한 저항성을 높여준다. 전체 해싱 과정은 <code>초기화(Initialization)</code>, <code>압축(Compression)</code>, <code>완료(Finalization)</code>의 3단계로 구성된다.13</p>
<h3>5.3  핵심 연산 분석: 압축 함수</h3>
<p>LSH의 핵심은 압축 함수 <span class="math math-inline">CF</span>이다. 이 함수는 이전 단계의 체인 변수 <span class="math math-inline">CV^{(i)}</span>와 현재 메시지 블록 <span class="math math-inline">M^{(i)}</span>를 입력받아 다음 단계의 체인 변수 <span class="math math-inline">CV^{(i+1)}</span>을 생성한다. 이 과정은 4개의 정교한 보조 함수들의 조합으로 이루어진다.13</p>
<h4>5.3.1  메시지 확장 (MsgExp)</h4>
<p>입력된 메시지 블록(LSH-256의 경우 32워드)으로부터 여러 개의 서브 메시지(16워드)를 생성하는 과정이다. 이는 블록 암호의 키 스케줄과 유사한 역할을 하며, 입력 메시지의 작은 변화가 압축 과정 전반에 걸쳐 큰 영향을 미치도록 확산시키는 역할을 한다. 이전 서브 메시지들을 모듈러 덧셈하여 다음 서브 메시지를 생성하는 방식으로, 메시지 자체의 통계적 특성을 제거하고 복잡성을 증대시킨다.13</p>
<h4>5.3.2  메시지 덧셈 (MsgAdd)</h4>
<p>두 개의 16워드 변수를 입력받아 각 워드별로 XOR 연산을 수행하는 단순한 함수이다. <span class="math math-inline">MsgAdd(X, Y) := (X_0 \oplus Y_0, \dots, X_{15} \oplus Y_{15})</span>로 정의된다.13</p>
<h4>5.3.3  섞음 (Mix)</h4>
<p>LSH의 비선형성을 제공하는 가장 핵심적인 함수이다. 16워드(512비트)의 체인 변수를 8쌍의 워드로 나누어, 각 쌍에 대해 ARX 연산과 라운드 상수를 이용한 복잡한 혼합 연산을 수행한다. 이 과정은 데이터의 비트들을 비선형적으로 섞어 예측을 불가능하게 만든다.13</p>
<h4>5.3.4  워드 단위 치환 (WordPerm)</h4>
<p>16개의 워드 위치를 사전에 정의된 순열 <span class="math math-inline">\sigma</span>에 따라 재배치한다. 이는 섞음 함수가 워드 내의 비트들을 섞는 역할을 하는 것과 달리, 워드 간의 위치를 바꾸어 전체 상태의 확산을 돕는다. <span class="math math-inline">WordPerm(X) := (X[\sigma(0)], \dots, X[\sigma(15)])</span>로 정의된다.13</p>
<p>이 네 가지 함수가 단계 함수(Step function)를 구성하고, 이 단계 함수가 여러 번 반복되면서 하나의 메시지 블록이 압축된다.</p>
<h3>5.4  핵심 연산 분석: 완료 함수</h3>
<p>모든 메시지 블록에 대한 압축 과정이 끝나면, 최종적으로 남은 체인 변수 <span class="math math-inline">CV^{(t)}</span>로부터 <code>n</code>비트의 해시 값을 생성한다. 완료 함수는 최종 체인 변수의 앞부분 8워드와 뒷부분 8워드를 XOR하여 8워드의 중간 값을 생성한다. 그 후, 이 중간 값들을 바이트 단위로 분해하고 재조합하여 원하는 길이(<code>n</code>비트)의 최종 해시 값을 잘라내어 출력한다.40</p>
<h3>5.5  표준화 및 보안성 평가</h3>
<p>LSH는 2015년 12월 TTA 표준으로 제안되었으며 41, 이후 대한민국 국가 표준(KS X 3262)으로 제정되었다.13 보안성 측면에서 LSH는 충돌쌍 공격, 역상 공격 등 현재까지 알려진 모든 종류의 해시 함수 공격에 대해 안전하도록 설계되었다. 특히, 전체 라운드의 50% 이상에 해당하는 안전성 마진(security margin)을 확보하여 미래의 새로운 공격 기법에도 충분한 저항성을 갖도록 하였다.13 이러한 안전성은 벨기에의 저명한 암호 연구 기관인 COSIC 연구소로부터 객관적인 검증을 받았다.43</p>
<p>성능 면에서 LSH는 설계 목표였던 고속 처리를 성공적으로 달성했다. 다양한 소프트웨어 플랫폼에서 측정한 결과, 국제 표준인 SHA-2 및 SHA-3와 비교하여 2배에서 3배 이상 우수한 성능을 보이는 것으로 나타났다.13 이는 ARX 기반 구조가 현대 CPU 아키텍처와 시너지를 내어 높은 효율성을 발휘함을 입증하는 결과이다.</p>
<h2>6. 결론: 대한민국 국가 암호의 현재와 미래</h2>
<h3>6.1 주요 알고리즘의 기술적 성과 및 활용 분야 종합</h3>
<p>지난 20여 년간 대한민국은 국가 주도하에 전략적으로 암호 기술 포트폴리오를 구축해왔다. 본 보고서에서 분석한 ARIA, LEA, HIGHT, LSH는 각각 명확한 목표와 기술적 차별성을 가지며 국가 정보보호 시스템의 다양한 요구사항을 충족시켜왔다.</p>
<p><strong>표 5-1: 국가 표준 암호 알고리즘 종합 비교</strong></p>
<table><thead><tr><th>알고리즘</th><th>개발 연도</th><th>핵심 구조</th><th>주된 특징</th><th>목표 적용 분야</th></tr></thead><tbody>
<tr><td><strong>ARIA</strong></td><td>2003</td><td>Involutional SPN</td><td>AES 호환성, 암/복호화 대칭성</td><td>국가 표준, 범용 암호화 8</td></tr>
<tr><td><strong>LEA</strong></td><td>2013</td><td>ARX 기반 GFN</td><td>S-box 부재, SW 고속 처리</td><td>빅데이터, 클라우드, 모바일 11</td></tr>
<tr><td><strong>HIGHT</strong></td><td>2005</td><td>Feistel 변형</td><td>64비트 블록, HW 최적화</td><td>RFID, USN, IoT 디바이스 10</td></tr>
<tr><td><strong>LSH</strong></td><td>2014</td><td>Merkle-Damgård</td><td>ARX 기반, 고속 해시</td><td>전자서명, 무결성 검증 13</td></tr>
</tbody></table>
<p>ARIA는 국제 표준과의 호환성을 바탕으로 국가·공공 부문의 범용 암호화 표준으로 자리 잡았다. LEA는 탁월한 소프트웨어 처리 속도를 무기로 금융권의 대용량 데이터 처리 및 모바일 보안 분야에서 경쟁력을 확보했다.45 HIGHT는 하드웨어 구현에 최적화된 초경량 설계로 사물인터넷(IoT) 디바이스 보안의 핵심 기술로 부상했으며 27, LSH는 빠른 속도와 강력한 보안성으로 알집과 같은 상용 압축 소프트웨어의 파일 무결성 검증에 채택되는 등 45 각자의 영역에서 뚜렷한 성과를 보이고 있다.</p>
<h3>6.2 국제 표준과의 관계 및 정책 변화 고찰</h3>
<p>KCMVP를 통한 국내 표준 암호 알고리즘의 의무화 정책은 국내 암호 기술의 자립과 관련 산업 생태계를 육성하는 데 결정적인 역할을 했다. 이는 기술 개발 초기 단계에서 시장을 확보하고 기술력을 축적하기 위한 필수적인 보호 장치였다. 그러나 글로벌 클라우드 서비스와 오픈소스 소프트웨어의 사용이 보편화되면서, 국내 표준만을 고집하는 정책은 국제 표준과의 상호운용성을 저해하고 기술적 고립, 즉 ’갈라파고스화’를 초래할 수 있다는 비판에 직면하기도 했다.</p>
<p>이러한 배경 속에서 2026년부터 공공분야에 국제 표준 암호인 AES의 사용을 허용하기로 한 정부의 결정은 매우 중요한 정책적 전환을 의미한다.47 이는 과거의 ’보호주의’에서 벗어나 ’실용주의’로 정책 패러다임이 변화하고 있음을 명확히 보여준다. 이 결정의 이면에는 몇 가지 복합적인 요인이 작용한다. 첫째, 글로벌 IT 환경과의 호환성 문제를 해결하고, 국제적으로 검증된 안전한 기술을 유연하게 채택하여 행정 및 개발 효율성을 높이려는 실용적 판단이 있다. 둘째, 이는 그간 축적된 국내 암호 기술(ARIA, LEA 등)이 이제는 보호 장벽 없이도 국제 표준과 동등하게 경쟁할 수 있다는 자신감의 표현이기도 하다. 따라서 이 정책 변화는 대한민국 암호 정책이 ’자립’이라는 1차 목표를 성공적으로 달성하고, 이제는 ’글로벌 표준과의 조화 및 경쟁’이라는 더 성숙한 단계로 진입했음을 알리는 중요한 변곡점으로 해석할 수 있다.7</p>
<h3>6.3 미래 전망: 양자내성암호(PQC)로의 전환과 차세대 국가 표준 암호의 방향성</h3>
<p>미래의 가장 큰 사이버 안보 위협은 양자컴퓨터의 등장이다. 양자컴퓨터는 쇼어(Shor)의 알고리즘을 통해 현재 인터넷 보안의 근간을 이루는 공개키 암호 체계(RSA, ECC 등)를 다항 시간 내에 해독할 수 있어, 디지털 사회 전체를 마비시킬 잠재력을 가지고 있다.15 이러한 위협에 대응하기 위해 전 세계는 양자컴퓨터로도 해독하기 어려운 새로운 수학적 난제에 기반한<strong>양자내성암호(PQC)</strong> 개발에 총력을 기울이고 있다.</p>
<p>대한민국 역시 이러한 흐름에 발맞추어 국가보안기술연구소 주도로 ’양자내성암호연구단’을 발족하고, 산·학·연 전문가들과 함께 PQC 표준화 공모를 진행하는 등 차세대 암호 주권 확보를 위한 선제적 대응에 나서고 있다.15 이는 미래의 정보보호 체계가 양자내성을 기본 전제로 구축될 것임을 예고한다.</p>
<p>따라서 차세대 국가 표준 암호는 양자내성을 핵심적인 보안 요구사항으로 포함하면서, 동시에 인공지능(AI), 블록체인, 6G 통신 등 새로운 기술 환경에 최적화된 성능과 효율성을 제공하는 방향으로 발전할 것이다. 과거 ARIA, LEA, HIGHT, LSH가 각 시대의 기술적 요구에 부응하며 진화해왔듯이, 미래의 국가 암호 기술 역시 다가올 양자 시대의 도전에 맞서 대한민국의 디지털 주권을 수호하는 핵심적인 역할을 수행할 것으로 전망된다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>국가정보통신망을 위한 KCMVP 암호모듈 검증 제도의 역할과 중요성 - Goover, https://seo.goover.ai/report/202503/go-public-report-ko-ec9201bb-06f3-455c-8894-b2e12b90885d-0-0.html</li>
<li>암호모듈검증 - 개요 - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/kcmvp/EgovSummary.do</li>
<li>보안성 | 참조모듈조회 | 표준기능 | EMR 표준프레임워크, https://emrcert.mohw.go.kr/referModule/referModuleLookup.es?mid=a11204020000&amp;crtfc_gb=03&amp;crtfc_id=CRT_0000000000000124</li>
<li>암호모듈검증 - 국가사이버안보센터, <a href="https://www.ncsc.go.kr:4018/PageLink.do?link=forward:/cop/bbs/selectBoardList.do?bbsId%3DCryptoQna_main&amp;tempParam1&amp;menuNo=060000&amp;subMenuNo=060400&amp;thirdMenuNo">https://www.ncsc.go.kr:4018/PageLink.do?link=forward:/cop/bbs/selectBoardList.do?bbsId=CryptoQna_main&amp;tempParam1=&amp;menuNo=060000&amp;subMenuNo=060400&amp;thirdMenuNo=</a></li>
<li>공공기관 보안규제 확 푼다 (CSK 2024) - 정보보안트렌드, https://security-trendsetter.tistory.com/18</li>
<li>국산 암호기술 - ARIA - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/algorithm/EgovAriaInfo.do</li>
<li>ARIA: 국내 표준 암호 알고리즘 - Moxie of Dev - 티스토리, https://moxie2ks.tistory.com/m/60</li>
<li>국산 암호기술 - HIGHT - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/algorithm/EgovHightInfo.do</li>
<li>국산 암호기술 - LEA - KISA 암호이용활성화, https://seed.kisa.or.kr/kisa/algorithm/EgovLeaInfo.do</li>
<li>표준소개 - 128비트 - 블록 암호 LEA, https://www.tta.or.kr/data/androReport/ttaJnal/157-4.pdf</li>
<li>LSH (해시 함수) - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/LSH_(%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98)">https://ko.wikipedia.org/wiki/LSH_(%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98)</a></li>
<li>국내 암호제품 경쟁력 강화…해시함수 LSH 보급 나선다 - 보안뉴스, https://www.boannews.com/media/view.asp?idx=51023&amp;page=20&amp;kind=2</li>
<li>양자내성암호연구단 소개 - kms 대한수학회, https://www.kms.or.kr/conference/2023_spring/program/abst_view.html?period=84&amp;session_detail=111&amp;num=8639</li>
<li>정부, 한국형 양자내성암호 알고리즘 4종 확보 - 뉴시스, https://mobile.newsis.com/view/NISX20250120_0003039185</li>
<li>하둡 상에서 ARIA 알고리즘을 이용한 HDFS 데이터 암호화 기법의 설계 및 구현, https://www.koreascience.kr/article/JAKO201611962637689.pdf</li>
<li>아리아 (암호) - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%95%84%EB%A6%AC%EC%95%84_(%EC%95%94%ED%98%B8)">https://ko.wikipedia.org/wiki/%EC%95%84%EB%A6%AC%EC%95%84_(%EC%95%94%ED%98%B8)</a></li>
<li>국산 암호화 알고리즘 ARIA와 SEED를 활용한 PostgreSQL 데이터베이스 보안 강화 - 비트나인, <a href="https://bitnine.net/blog-postgresql/aria-seed-postgresql-db-%EB%B3%B4%EC%95%88-%EA%B0%95%ED%99%94/">https://bitnine.net/blog-postgresql/aria-seed-postgresql-db-%EB%B3%B4%EC%95%88-%EA%B0%95%ED%99%94/</a></li>
<li>아리아 (암호) - 오늘의AI위키, AI가 만드는 백과사전, <a href="https://wiki.onul.works/w/%EC%95%84%EB%A6%AC%EC%95%84_(%EC%95%94%ED%98%B8)">https://wiki.onul.works/w/%EC%95%84%EB%A6%AC%EC%95%84_(%EC%95%94%ED%98%B8)</a></li>
<li>ARIA 암호 알고리즘에 대하여 - TEAMCR@K - 티스토리, https://teamcrak.tistory.com/69</li>
<li>New block cipher: ARIA, https://www.math.snu.ac.kr/~jinhong/04Aria.pdf</li>
<li>(PDF) New block cipher: ARIA - ResearchGate, https://www.researchgate.net/publication/220833858_New_block_cipher_ARIA</li>
<li>Independent Submission J. Lee Request for Comments: 5794 J. Lee …, https://www.rfc-editor.org/rfc/pdfrfc/rfc5794.txt.pdf</li>
<li>KS X 1213-1 정보기술 — 보안기술 — 128비트 블록 암호 알고리즘 ARIA — 제1부: 일반 - 한국표준정보망, https://www.kssn.net/search/stddetail.do?itemNo=K001010104903</li>
<li>서버환경에서의 LEA 암호 알고리즘 구현 및 성능분석, https://koreascience.kr/article/CFKO201423965827889.pdf</li>
<li>암호화 알고리즘 - LEA (Lightweight Encryption Algorithm) - Char - 티스토리, https://charstring.tistory.com/383</li>
<li>LEA 알고리즘 구현 - Joseoyeon, https://joseoyeon.github.io/posts/LEA/</li>
<li>LEA (암호) - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/LEA_(%EC%95%94%ED%98%B8)">https://ko.wikipedia.org/wiki/LEA_(%EC%95%94%ED%98%B8)</a></li>
<li>LEA - 나무위키, https://namu.wiki/w/LEA</li>
<li>더 빠르게, 더 가볍게, 더 강력하게! - 한국정보통신기술협회, https://www.tta.or.kr/data/2019_wellmade/html/sub06-m.html</li>
<li>국가보안기술연구소 경량 블록암호 ‘美’ 제치고 국제표준 됐다/김동찬(금융정보보안학과) 교수 - 국민인! 국민인!! - 커뮤니티 | 국민New&amp;Hot | 국민인! 국민인!! - 국민대학교 예술대학, https://art.kookmin.ac.kr/community/newnhot/people/1069829?pn=81</li>
<li>HIGHT: A New Block Cipher Suitable for Low-Resource … - IACR, https://www.iacr.org/archive/ches2006/04/04.pdf</li>
<li>국산 경량 블록 암호 PIPO, HIGHT, CHAM 고속 구현 연구, http://journal.dcs.or.kr/xml/31792/31792.pdf</li>
<li>HIGHT - 위키원 - 해시넷, http://wiki.hash.kr/index.php/HIGHT</li>
<li>HIGHT: A new block cipher suitable for low-resource device - ResearchGate, https://www.researchgate.net/publication/221291745_HIGHT_A_new_block_cipher_suitable_for_low-resource_device</li>
<li>[논문]블록 암호 HIGHT를 위한 암·복호화기 코어 설계 - 한국과학기술정보연구원, https://scienceon.kisti.re.kr/srch/selectPORSrchArticle.do?cn=JAKO201215239621159</li>
<li>Intel CPU 에서 지원하는 SIMD 를 이용한 고속해시함수 LSH 최적화 구현, https://koreascience.kr/article/CFKO201529368417580.pdf</li>
<li>SSE와 AVX를 활용한 LSH의 병렬 최적 구현*, https://koreascience.kr/article/JAKO201609562997961.pdf</li>
<li>LSH (hash function) - Wikipedia, https://en.wikipedia.org/wiki/LSH_(hash_function)</li>
<li>정보보안 과정 Day88 : 일방향 해시 함수(이론) - 타쿠대디, https://takudaddy.tistory.com/289</li>
<li>Cryptol 을 이용한 LSH 해시함수 정형검증, https://koreascience.kr/article/CFKO201835372170904.pdf</li>
<li>Resource Eestimation of Grover Algorithm through Hash Function LSH Quantum Circuit Optimization - Korea Science, https://koreascience.kr/article/JAKO202118350256335.page</li>
<li>LSH 암호화 (Lightweight Secure Hash) - 도리의 디지털라이프, <a href="https://blog.skby.net/lsh-%EC%95%94%ED%98%B8%ED%99%94-lightweight-secure-hash/">https://blog.skby.net/lsh-%EC%95%94%ED%98%B8%ED%99%94-lightweight-secure-hash/</a></li>
<li>국산 경량암호 LEA 적용 사례 늘어 - 전자신문, https://www.etnews.com/20160801000139</li>
<li>[금융보안원][정보보호] 금융부문 암호 기술 활용 가이드 (2019.01) - 황컴플라이언스의 공간, <a href="https://abraham-hwang.tistory.com/entry/%EA%B8%88%EC%9C%B5%EB%B3%B4%EC%95%88%EC%9B%90%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8-%EA%B8%88%EC%9C%B5%EB%B6%80%EB%AC%B8-%EC%95%94%ED%98%B8-%EA%B8%B0%EC%88%A0-%ED%99%9C%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-201901">https://abraham-hwang.tistory.com/entry/%EA%B8%88%EC%9C%B5%EB%B3%B4%EC%95%88%EC%9B%90%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8-%EA%B8%88%EC%9C%B5%EB%B6%80%EB%AC%B8-%EC%95%94%ED%98%B8-%EA%B8%B0%EC%88%A0-%ED%99%9C%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C-201901</a></li>
<li>[CSK 2024] 공공분야에 국제표준암호 <code>AES</code> 허용…2026년 1월 시행 - 디지털데일리, https://m.ddaily.co.kr/page/view/2024091115400677998</li>
<li>2026년부터 우리나라에 국제표준암호 AES 도입 허용된다 - 보안뉴스, https://m.boannews.com/html/detail.html?tab_type=1&amp;idx=132764</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>