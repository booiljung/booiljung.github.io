<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:CrossC2 공격 유형 분석</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>CrossC2 공격 유형 분석</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">정보 보안 (Information Security)</a> / <a href="index.html">공격 유형</a> / <span>CrossC2 공격 유형 분석</span></nav>
                </div>
            </header>
            <article>
                <h1>CrossC2 공격 유형 분석</h1>
<h2>1.  요약</h2>
<h3>1.1  위협 개요</h3>
<p>CrossC2는 악명 높은 공격 프레임워크인 코발트 스트라이크(Cobalt Strike)의 비컨(Beacon) 에이전트 기능을 기존의 Windows 환경을 넘어 Linux 및 macOS 운영체제로 확장하는 비공식 프레임워크다.1 이 도구의 등장은 공격자들이 다양한 운영체제가 혼재된 기업 환경 전체를 단일 C2(Command and Control) 인프라를 통해 통제할 수 있게 되었음을 의미하며, 이는 사이버 위협 환경의 중대한 전략적 변화를 시사한다. 특히, 상대적으로 보안 감시가 소홀할 수 있는 Linux 서버나 macOS 워크스테이션을 초기 침투 거점으로 활용하여 기업 내부망의 핵심 자산으로 접근하려는 시도가 가능해졌다는 점에서 그 위협의 심각성이 크다.</p>
<h3>1.2  핵심 분석 결과</h3>
<p>본 안내서는 CrossC2와 관련된 공격 캠페인에 대한 심층 분석을 통해 다음과 같은 핵심적인 사실을 규명하였다.</p>
<ul>
<li>
<p><strong>고도로 정교화된 공격 체인</strong>: 공격자는 최신 보안 솔루션을 회피하기 위해 설계된 다단계 메모리 기반 실행 체인을 사용한다. 여기에는 Nim 프로그래밍 언어로 개발된 맞춤형 로더인 ’ReadNimeLoader’와 오픈소스 셸코드 로더 ’OdinLdr’가 포함되어, 디스크에 악성 코드의 흔적을 최소화하며 최종 페이로드를 실행한다.3</p>
</li>
<li>
<p><strong>다양한 공격 그룹의 활용</strong>: CrossC2는 금전적 동기를 가진 랜섬웨어 그룹(BlackSuit/Black Basta)과 국가 지원이 의심되는 스파이 활동 그룹(TAG-100) 모두에 의해 사용되는 것이 확인되었다. 이는 특정 공격 도구가 공격자의 성향과 무관하게 그 기술적 효율성만으로 채택되는 ‘공격 기술의 상용화’ 현상을 보여주며, 방어자 입장에서 공격의 배후와 의도를 파악하는 것을 더욱 어렵게 만든다.1</p>
</li>
<li>
<p><strong>전략적 표적 선정</strong>: 공격자들은 보안 탐지 및 대응(EDR) 솔루션이 상대적으로 부족하게 배포된 Linux 서버를 초기 침투 지점으로 집중 공략한다. 이후 내부 네트워크로 이동하여 최종 목표인 Active Directory(AD)와 같은 핵심 기업 인프라를 장악하려는 전략적 패턴을 보인다.1</p>
</li>
</ul>
<h3>1.3  전략적 시사점</h3>
<p>CrossC2의 등장은 기존의 Windows 중심적인 보안 관점이 더 이상 유효하지 않음을 명백히 보여준다. 기업은 이제 모든 운영체제를 포괄하는 통합적인 엔드포인트 보안 가시성을 확보해야 하며, 알려진 위협 지표에 의존하는 수동적 방어를 넘어 잠재적 위협 행위를 능동적으로 탐지하고 추적하는 프로액티브 위협 헌팅(Threat Hunting) 체계를 구축하는 것이 시급한 과제로 부상했다.</p>
<h3>1.4  안내서 구성</h3>
<p>본 안내서는 CrossC2 프레임워크의 기술적 구조 분석부터 시작하여, 실제 공격 사례의 전체 공격 주기, 배후 공격 그룹 프로파일링, 그리고 이에 대응하기 위한 구체적이고 실행 가능한 방어 전략에 이르기까지 심층적인 정보를 단계적으로 제공한다. 독자는 이 안내서를 통해 CrossC2 위협의 본질을 이해하고, 자사의 보안 체계를 강화하기 위한 실질적인 통찰을 얻을 수 있을 것이다.</p>
<h2>2.  CrossC2 프레임워크: 아키텍처 및 핵심 기능</h2>
<h3>2.1  CrossC2 소개</h3>
<p>CrossC2는 C 언어로 개발된 비공식 빌더(Builder) 및 비컨(Beacon)으로, 코발트 스트라이크 버전 4.1 이상과 호환되도록 설계되었다.2 이 프레임워크의 핵심 목적은 코발트 스트라이크의 강력한 후속 침투(Post-Exploitation) 기능을 Windows 운영체제의 한계를 넘어 다른 플랫폼으로 확장하는 것이다.1</p>
<p>구체적으로 CrossC2는 다양한 시스템 아키텍처를 지원하여 공격의 유연성을 극대화한다. 지원 대상은 Linux (x86, x64) 및 macOS (x86, x64, Apple M1)를 포함하며, 이를 통해 최신 하드웨어를 포함한 대부분의 비-Windows 환경에서 코발트 스트라이크 비컨을 운용할 수 있다.2</p>
<p>한 가지 주목할 점은 CrossC2의 배포 방식이다. 비컨을 생성하는 빌더는 GitHub를 통해 공개되어 있어 누구나 접근하여 페이로드를 생성할 수 있지만, 빌더와 비컨 페이로드의 소스 코드는 공개되지 않았다.2 이는 개발자가 도구의 사용을 촉진하면서도 핵심적인 내부 로직과 기술은 통제하려는 의도적인 선택으로 분석된다.</p>
<h3>2.2  비컨 내부 구조 및 실행 흐름</h3>
<p>CrossC2 비컨이 감염된 시스템에서 실행될 때의 동작 방식은 은밀함과 지속성을 확보하는 데 중점을 둔다. 실행 즉시 비컨은 자신을 복제하는 <code>fork</code> 시스템 콜을 호출하여 자식 프로세스를 생성하고, 모든 주요 악성 행위는 이 자식 프로세스 내에서 수행된다.2 이는 전형적인 유닉스(Unix) 계열 시스템의 데몬(daemon) 생성 기법으로, 부모 프로세스와의 연결을 끊어 셸 세션이 종료되더라도 악성 프로세스가 계속 실행되도록 보장한다.</p>
<p>C2 서버 정보 획득 방식 또한 공격자의 운영 유연성을 고려하여 다중 경로로 설계되었다. 비컨은 우선적으로 자신의 바이너리 내부에 암호화되어 저장된 설정값을 읽어 C2 서버 정보를 확인한다. 만약 이 정보가 존재하지 않거나 유효하지 않을 경우, 시스템 환경 변수인 <code>CCHOST</code>와 <code>CCPORT</code>를 확인하여 C2 서버의 주소와 포트를 획득하는 예비 수단을 갖추고 있다.2</p>
<h3>2.3  설정 구조 및 암호화</h3>
<p>CrossC2 비컨의 C2 설정 데이터는 바이너리 파일의 끝부분에 추가 블록 형태로 저장된다.2 이 데이터 블록의 위치를 찾는 메커니즘은 매우 구체적이다. 먼저 비컨은</p>
<p><code>readlink</code> 함수를 사용하여 자신의 전체 파일 경로를 얻는다. 그 후, <code>fread</code> 함수를 통해 자신의 바이너리 전체를 메모리로 읽어 들인 뒤, 설정 데이터 블록의 시작을 알리는 매직 넘버(magic number) 역할을 하는 ASCII 문자열 “HOOK“를 검색한다.2</p>
<p>설정 블록의 구조는 다음과 같이 명확하게 정의되어 있다.</p>
<ul>
<li>
<p>오프셋 <code>0x0</code>: “HOOK” (4바이트 검색 태그)</p>
</li>
<li>
<p>오프셋 <code>0x4</code>: 암호화된 설정 데이터의 크기 (4바이트 정수)</p>
</li>
<li>
<p>오프셋 <code>0x8</code>: 암호화된 설정 데이터</p>
</li>
</ul>
<p>설정 데이터는 강력한 표준 암호화 알고리즘인 <code>AES128-CBC</code> (패딩 없음)를 사용하여 암호화된다. 비컨은 암호 해독을 위해 OpenSSL 라이브러리 함수를 활용하는데, 이는 트래픽 분석을 어렵게 하고 악성코드의 핵심 정보를 보호하는 효과적인 방법이다.2</p>
<h3>2.4  방어 회피 및 분석 방해 기술</h3>
<p>CrossC2 비컨은 정적 및 동적 분석을 회피하기 위해 여러 계층의 방어 회피 기술을 내장하고 있다.2</p>
<ul>
<li>
<p><strong>난독화</strong>: 두 가지 주요 분석 방해 기능이 포함되어 있다.</p>
</li>
<li>
<p><strong>문자열 인코딩</strong>: C2 서버 주소, 실행할 명령어 등 분석에 단서가 될 수 있는 주요 문자열들은 간단한 단일 바이트(single-byte) XOR 연산을 통해 인코딩된다. 이는 정적 분석 도구가 악성 행위와 관련된 키워드를 쉽게 식별하는 것을 방해한다.</p>
</li>
<li>
<p><strong>쓰레기 코드 삽입 (Junk Code Insertion)</strong>: 실제 기능과 무관한 방대한 양의 쓰레기 코드가 핵심 기능 함수 내에 삽입된다. 이는 디스어셈블된 코드의 가독성을 떨어뜨리고, 제어 흐름 분석을 방해하며, 시그니처 기반 탐지를 무력화하는 데 사용된다.</p>
</li>
<li>
<p><strong>난독화 해제 기법</strong>: 분석가를 위해 이 쓰레기 코드 난독화를 무력화하는 방법이 식별되었다. 특정 바이트 시퀀스를 검색하여 NOP(No-Operation, 예: <code>$0x90$</code>) 명령어로 대체하면 코드를 정리하고 실제 실행 흐름을 파악할 수 있다.2 해당 바이트 시퀀스는 다음과 같다.</p>
<pre><code>8B 85???????? 2D???????? 89 85???????? 0F 84???????? E9 00 00 00 00
</code></pre>
</li>
</ul>
<pre><code>
- **UPX 패킹**: 생성된 비컨은 기본적으로 UPX(Ultimate Packer for eXecutables)로 패킹된다. 여기서 중요한 점은, 파일 끝에 추가된 설정 블록으로 인해 표준적인 PE/ELF 파일 구조가 변형되어 일반적인 UPX 압축 해제 도구는 실패한다는 것이다. 바이너리를 성공적으로 분석하기 위해서는, 분석가가 먼저 "HOOK" 태그부터 파일 끝까지의 설정 블록을 수동으로 제거한 후, UPX로 압축을 해제하고, 필요에 따라 다시 설정 블록을 파일 끝에 붙여야 한다.2

이러한 구조적 특징들은 CrossC2가 단순한 기능 확장을 넘어, 탐지를 회피하고 분석을 방해하도록 치밀하게 설계되었음을 보여준다. 비컨의 기능 범위는 표준 Windows 비컨에 비해 제한적일 수 있으나 2, 그 본질적인 위협은 기능의 수가 아닌, 탐지를 뚫고 안정적인 C2 채널을 구축하는 능력에 있다. 방어자들은 CrossC2의 '제한된' 기능이라는 표면적 정보에 안주해서는 안 되며, 오히려 덜 감시받는 플랫폼에서 은밀하게 초기 거점을 확보하고 지속성을 유지하는 데 특화된 위험한 도구로 인식해야 한다.

## 3.  공격 생명주기: 초기 침투부터 페이로드 실행까지


### 3.1  초기 침투 및 예약 작업을 통한 지속성 확보


문서화된 공격 사례에서 확인된 초기 침투 및 지속성 확보 방식은 Windows 시스템의 합법적인 기능을 악용하는 정교한 형태를 띤다. 공격자는 먼저 대상 시스템에 악성 '예약 작업(Scheduled Task)'을 생성한다.3 이 예약 작업은 신뢰할 수 있는 서명된 바이너리인 `java.exe`를 실행하도록 설정된다.1 이 기법은 '서명된 바이너리 프록시 실행(Signed Binary Proxy Execution)'으로 알려져 있으며, `java.exe`와 같은 정상 프로세스의 실행을 허용하는 애플리케이션 화이트리스팅(Application Whitelisting) 및 기타 프로세스 기반 보안 통제를 우회하기 위한 목적으로 사용된다.

### 3.2  ReadNimeLoader: Nim 기반의 맞춤형 로더


공격의 핵심에는 `ReadNimeLoader`라는 맞춤형 악성코드 로더가 있다.1 이 로더는 상대적으로 덜 사용되는 프로그래밍 언어인 Nim으로 작성되었는데, 이는 C/C++/C# 기반 악성코드에 집중된 기존의 시그니처 기반 안티바이러스 솔루션의 탐지를 회피하는 데 효과적이다.

공격자는 DLL 사이드로딩(DLL Sideloading) 기법을 활용한다. 예약 작업은 악성 DLL인 `jli.dll`이 위치한 디렉터리에서 `java.exe`를 실행시킨다. 이 악성 `jli.dll`의 실체가 바로 `ReadNimeLoader`다. `java.exe`가 시작될 때, 시스템 디렉터리에 있는 합법적인 `jli.dll` 대신 현재 작업 디렉터리에 있는 악성 `jli.dll`을 우선적으로 로드하게 된다.2

분석된 사례에서 악성 파일들은 `C:\$recycle.bin\` 경로에 저장되어 있었는데, 이는 시스템의 휴지통 폴더로 위장하여 분석가의 주의를 피하거나 일부 보안 스캔에서 제외되려는 의도로 보인다.2 일부 샘플에서는 `D:\BuildServer\bna-4\work-git\phoenix-repository\phoenix\Release\Battle.net Launcher.exe.pdb`와 같은 PDB(Program Database) 경로가 발견되었으며, 이는 개발 환경을 위장하기 위한 허위 정보이거나 실제 개발 환경의 단서일 수 있다.2

### 3.3  OdinLdr를 통한 메모리 내 실행


다음 공격 단계는 `ReadNimeLoader`(`jli.dll`)가 동일한 디렉터리에 있는 `readme.txt`라는 이름의 파일을 읽는 것으로 시작된다.2 이 파일은 일반 텍스트 파일이 아니라, 다음 단계의 페이로드인 `OdinLdr`를 담고 있는 데이터 블롭(data blob)이다. `OdinLdr`는 공개된 오픈소스 셸코드 로더로 알려져 있다.1

`ReadNimeLoader`는 `OdinLdr`를 디스크에 쓰지 않고 직접 메모리 상에서 복호화하여 실행한다.3 이어서 `OdinLdr`는 자신 내부에 인코딩된 최종 페이로드, 즉 코발트 스트라이크 비컨을 디코딩하여 마찬가지로 메모리 상에서 실행한다.2 이와 같은 완전한 파일리스(fileless) 실행 체인은 시스템에 포렌식 흔적을 최소화하여 공격 후 분석을 극도로 어렵게 만든다.

### 3.4  로더 체인 내의 고급 회피 기술


이 공격 체인은 단순한 파일리스 실행을 넘어, 최신 엔드포인트 보안 솔루션을 무력화하기 위한 다층적인 회피 기술을 포함한다.

- **ReadNimeLoader의 분석 방해 기술**: `ReadNimeLoader`는 자동화된 분석 환경을 탐지하기 위해 네 가지의 특정 기술을 사용한다.2

1. PEB(Process Environment Block)의 `BeingDebugged` 플래그 확인을 통한 디버거 탐지.

2. `CONTEXT_DEBUG_REGISTER` 값을 확인하여 하드웨어 브레이크포인트 사용 여부 탐지.

3. 코드 실행 시간 측정을 통해 샌드박스 환경의 실행 지연 탐지.

4. 의도적으로 예외(exception)를 발생시켜 예외 핸들러의 존재 여부를 확인하는 디버거 탐지.

- **분석 방해 기술과 연동된 복호화**: 이 로더의 가장 정교한 부분은 `OdinLdr` 페이로드를 복호화하는 데 필요한 키의 일부가 상기된 분석 방해 함수들 내부에서 생성된다는 점이다. 이는 자동화된 샌드박스가 분석 방해 코드를 우회하거나 패치할 경우, 복호화 키가 올바르게 생성되지 않아 최종 페이로드가 드러나지 않게 만드는 고도의 분석 회피 전략이다.2

- **OdinLdr의 메모리 내 회피 기술**: `OdinLdr`는 메모리 스캐너를 회피하기 위한 독특한 기법을 사용한다. 비컨을 실행한 후, 주기적으로 새로운 무작위 단일 바이트 XOR 키를 생성하여 메모리 상의 비컨 이미지를 재암호화하고, 새로운 힙(heap) 공간으로 이동시킨다. 이 과정은 메모리 시그니처를 지속적으로 변경하여 패턴 기반 메모리 분석을 무력화한다. 다만, 힙 공간의 시작 부분에 "OdinLdr1337"이라는 정적 문자열을 남겨두어, 위협 헌터에게는 중요한 탐지 단서가 될 수 있다.2

결론적으로, 이 공격 체인은 최신 엔드포인트 보안 통제의 각 계층을 체계적으로 무력화하기 위해 설계되었다. 예약 작업을 통한 서명된 바이너리 실행은 애플리케이션 제어 솔루션을, DLL 사이드로딩은 프로세스 기반 모니터링을, Nim 언어 사용은 시그니처 기반 안티바이러스를, 다단계 메모리 실행은 디스크 기반 포렌식을, 분석 방해와 연동된 복호화는 자동화된 샌드박스를, 주기적인 메모리 재암호화는 EDR의 메모리 스캐닝을 회피하려는 명확한 의도를 보여준다. 이는 단일 방어 기술에 의존하는 전략이 실패할 수밖에 없음을 증명하며, 행위 기반의 다층적 탐지 전략의 필요성을 역설한다.

## 4.  공격 그룹 분석 및 캠페인 귀속


### 4.1  BlackSuit/Black Basta 랜섬웨어 그룹과의 연관성


CrossC2를 활용한 공격 캠페인은 금전적 동기를 가진 BlackSuit/Black Basta 랜섬웨어 조직과 강력한 연관성을 보인다.1 JPCERT/CC를 비롯한 여러 보안 연구 기관들은 다음과 같은 구체적인 증거들을 통해 두 활동 간의 중첩을 확인했다.1

- **C2 인프라 공유**: 공격에 사용된 일부 C2 서버의 도메인 및 IP 주소가 이전에 Black Basta 랜섬웨어 캠페인에서 사용된 인프라와 일치하는 것으로 확인되었다.

- **일관된 파일명 규칙**: 로더에 `jli.dll`, 페이로드 데이터 블롭에 `readme.txt`라는 파일명을 사용하는 패턴은 기존 Black Basta 공격에서도 관찰된 특징이다.

- **공통된 도구 사용**: 공격 과정에서 SystemBC 백도어의 ELF 변종이 사용된 점 또한 중요한 연결고리다. SystemBC는 코발트 스트라이크 배포나 랜섬웨어 실행 전 단계에서 프록시 및 백도어 역할을 위해 Black Basta 조직이 자주 활용하는 도구다.1

Black Basta는 이중 갈취(double extortion) 전략을 사용하는 서비스형 랜섬웨어(RaaS, Ransomware-as-a-Service) 조직으로, 악명 높았던 Conti 랜섬웨어 그룹의 후계 조직으로 추정된다.10

### 4.2  TAG-100: 스파이 활동 의심 그룹


한편, CrossC2는 TAG-100으로 임시 명명된 또 다른 공격 그룹에 의해서도 사용되었다. 이 그룹은 전 세계적인 스파이 활동 캠페인을 수행하는 것으로 의심된다.4

TAG-100의 공격 대상은 매우 명확한 전략적 의도를 보여준다. 아시아, 아프리카, 북미 등 최소 10개국에 위치한 정부 기관, 외교 단체, 그리고 방산, 기술, 의료 등 핵심 산업 분야의 민간 기업이 주요 표적이다.4 공격의 배후가 명확히 특정되지는 않았으나, 이러한 표적 프로파일은 중국 국가 지원 공격 그룹의 전략적 관심사와 일치하는 경향을 보인다.13

TAG-100은 특히 Linux 시스템을 겨냥한 코발트 스트라이크 비컨 페이로드를 생성하기 위해 CrossC2를 활용했으며, 이 외에도 Pantegana, SparkRAT과 같은 다양한 오픈소스 공격 도구를 함께 사용했다.4 이들의 초기 침투 방식은 주로 인터넷에 노출된 VPN, 방화벽, 이메일 서버 등 네트워크 경계 장비의 취약점을 악용하는 것이다.4

### 4.3  관찰된 표적 및 전략적 목표


두 공격 그룹의 활동을 종합해 볼 때, CrossC2를 활용한 공격의 공통된 전략적 목표가 드러난다. JPCERT/CC가 분석한 캠페인의 주된 목표는 기업 내부의 Linux 서버를 장악하여 이를 발판으로 Windows Active Directory(AD) 환경을 공격하는 것이었다.5

이는 공격자들이 Linux 서버의 전략적 가치를 명확히 인지하고 있음을 보여준다. 많은 기업 환경에서 Linux 서버는 Windows 클라이언트에 비해 상대적으로 EDR과 같은 고급 보안 솔루션의 적용이 미흡하여 보안 사각지대에 놓여 있는 경우가 많다. 공격자들은 바로 이 지점을 파고들어 초기 거점을 확보하고 내부망으로 확산하려는 것이다.1

이러한 캠페인은 일본을 포함한 여러 국가에서 동시에 관찰되었으며, 이는 VirusTotal과 같은 위협 인텔리전스 플랫폼에 제출된 아티팩트 분석을 통해 확인되었다.2

이처럼 상이한 목적을 가진 두 유형의 최상위 공격 그룹—금전적 동기의 랜섬웨어 조직과 국가 지원이 의심되는 스파이 그룹—이 동일한 CrossC2 프레임워크를 채택했다는 사실은 중요한 시사점을 가진다. 이는 특정 공격 도구나 기술이 더 이상 특정 그룹의 전유물이 아니라, 그 기술적 유용성에 따라 널리 채택되는 '공격 기술의 상용화(commoditization)'가 심화되고 있음을 보여준다. 공격자들은 자신의 목적 달성에 가장 효율적인 도구를 선택할 뿐이며, 이로 인해 방어자는 탐지된 도구만으로 공격의 배후나 최종 목표를 단정하기 어려워졌다. 따라서, 'CrossC2 활동 탐지'라는 초기 경보는 랜섬웨어 공격과 스파이 활동 시나리오 모두를 염두에 둔 포괄적인 대응 계획을 촉발해야 하며, 이후 수집되는 추가적인 TTP, 인프라, 공격 목표 등의 증거를 통해 위협의 실체를 구체화해 나가야 한다.

## 5.  침해 지표 및 전술 매핑


### 5.1  침해 지표 (Indicators of Compromise, IOCs)


침해 지표(IOC)는 공격이 발생했거나 진행 중임을 나타내는 포렌식 증거로, 보안팀이 위협을 탐지하고 사고에 대응하는 데 결정적인 역할을 한다.15 CrossC2 관련 공격 캠페인에서 식별된 주요 IOC는 다음과 같으며, 보안팀이 즉각적으로 활용할 수 있도록 네트워크 및 호스트 기반 지표로 분류하여 제공한다.

#### 5.1.1 표 1: 네트워크 침해 지표


네트워크 기반 IOC는 방화벽, 침입 탐지 시스템(IDS), 위협 헌팅 쿼리 등에서 C2 통신을 탐지하고 차단하는 데 필수적이다. 아래 표는 JPCERT/CC 안내서 등에서 확인된 주요 네트워크 지표를 정리한 것이다.2

| 지표 유형 | 지표 값                            | 관련 포트  | 컨텍스트 / 귀속                        |
| ----- | ------------------------------- | ------ | -------------------------------- |
| IP 주소 | `64.52.80[.]62`                 | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `64.95.10[.]209`                | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `67.217.228[.]55`               | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `137.184.155[.]92`              | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `159.65.241[.]37`               | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `162.33.179[.]247`              | `8443` | CrossC2 C2                       |
| IP 주소 | `165.227.113[.]183`             | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `179.60.149[.]209`              | `443`  | Black Basta/CrossC2 C2           |
| IP 주소 | `192.241.190[.]181`             | `443`  | Black Basta/CrossC2 C2           |
| 도메인   | `api.glazeceramics[.]com`       | `443`  | Black Basta/CrossC2 C2           |
| 도메인   | `doc.docu-duplicator[.]com`     | `53`   | Black Basta/CrossC2 C2 (DNS 터널링) |
| 도메인   | `doc2.docu-duplicator[.]com`    | `53`   | Black Basta/CrossC2 C2 (DNS 터널링) |
| 도메인   | `comdoc1.docu-duplicator[.]com` | `53`   | Black Basta/CrossC2 C2 (DNS 터널링) |

#### 5.1.2 표 2: 호스트 기반 침해 지표


호스트 기반 IOC는 EDR 솔루션, 위협 헌팅, 포렌식 분석을 통해 시스템 내부의 악성 아티팩트를 식별하는 데 사용된다. 아래 표는 관련 파일 해시, 경로, 문자열 등 주요 호스트 지표를 정리한 것이다.2

| 지표 유형   | 지표 값                                                               | 파일명 / 설명                 | 컨텍스트                                |
| ------- | ------------------------------------------------------------------ | ------------------------ | ----------------------------------- |
| SHA256  | `56b941f6dcb769ae6d6995412559012abab830f05d5d8acf2648f7fa48c20833` | `jli.dll`                | ReadNimeLoader                      |
| SHA256  | `dfe79b9c57cfb9fc10597b43af1c0a798991b6ceeec2af9b1e0ed46e6a8661c8` | `jli.dll`                | ReadNimeLoader                      |
| SHA256  | `6246fb5c8b714707ac49ade53e6fe5017d96442db393b1c0ba964698ae24245d` | `readme.txt`             | 코발트 스트라이크 비컨 (OdinLdr)              |
| SHA256  | `acdf2a87ed03f2c6fe1d9899e8a74e8b56f7b77bb8aed5adf2cc374ee5465168` | `readme.txt`             | 코발트 스트라이크 비컨 (OdinLdr)              |
| SHA256  | `28d668f3e1026a56d55bc5d6e36fad71622c1ab20ace52d3ab12738f9f8c6589` | `gds`                    | CrossC2 비컨 (Linux)                  |
| SHA256  | `9e8c550545aea5212c687e15399344df8a2c89f8359b90d8054f233a757346e7` | `gss`                    | CrossC2 비컨 (Linux)                  |
| SHA256  | `74a33138ce1e57564baa4ea4db4a882d6bf51081b79a167a6cb2bf9130ddad7f` | `monitor`                | ELF-SystemBC                        |
| SHA256  | `e0e827198a70eef6c697559660106cfab7229483b0cd7f0c7abd384a3d2ee504` | `GetNPUsers_windows.exe` | GetNPUsers                          |
| 파일 경로   | `C:\$recycle.bin\`                                                 | -                        | `jli.dll` 및 `readme.txt`의 스테이징 디렉터리 |
| PDB 문자열 | `D:\BuildServer\...\Battle.net Launcher.exe.pdb`                   | -                        | ReadNimeLoader 샘플에서 발견됨             |
| 메모리 문자열 | `OdinLdr1337`                                                      | -                        | OdinLdr가 할당한 힙 메모리 시작 부분            |

### 5.2  MITRE ATT&amp;CK® TTP 매핑


MITRE ATT&amp;CK 프레임워크는 공격자의 전술(Tactics)과 기술(Techniques)을 체계적으로 정리한 지식 베이스로, 위협 행위를 표준화된 용어로 설명하는 데 사용된다.17 CrossC2 캠페인에서 관찰된 공격 행위들을 ATT&amp;CK 프레임워크에 매핑하면, 방어팀이 자사의 보안 통제 수준을 평가하고 위협 헌팅 시나리오를 개발하는 데 매우 유용하다.

#### 5.2.1 표 3: CrossC2 캠페인에 대한 MITRE ATT&amp;CK® 매핑


| 전술 (Tactic)                   | 기술 ID (Technique ID) | 기술명 (Technique Name)                             | 절차 설명 (Procedure Description)                                                  |
| ----------------------------- | -------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------ |
| 실행 (Execution)                | T1053.005            | Scheduled Task/Job: Scheduled Task               | 공격자는 `java.exe`를 실행하여 로더 체인을 시작하고 지속성을 확보하기 위해 예약 작업을 생성한다.                    |
| 방어 회피 (Defense Evasion)       | T1574.002            | Hijack Execution Flow: DLL Side-Loading          | 합법적인 `java.exe` 프로세스가 비표준 경로에 위치한 악성 `jli.dll`(ReadNimeLoader)을 로드하도록 악용된다.    |
| 방어 회피 (Defense Evasion)       | T1027                | Obfuscated Files or Information                  | CrossC2 비컨은 단일 바이트 XOR 문자열 인코딩과 쓰레기 코드를 사용한다. ReadNimeLoader 역시 XOR 인코딩을 사용한다. |
| 방어 회피 (Defense Evasion)       | T1497                | Virtualization/Sandbox Evasion                   | ReadNimeLoader는 PEB 플래그, 디버그 레지스터, 실행 시간 측정 등 다수의 분석 방해 기술을 포함한다.              |
| 방어 회피 (Defense Evasion)       | T1055                | Process Injection                                | OdinLdr는 최종 코발트 스트라이크 비컨 페이로드를 메모리 내에서 디코딩하고 실행한다.                             |
| 자격 증명 접근 (Credential Access)  | T1558.003            | Steal or Forge Kerberos Tickets: AS-REP Roasting | 공격자는 Active Directory를 대상으로 AS-REP Roasting 공격을 수행하기 위해 GetNPUsers 도구를 사용한다.   |
| 측면 이동 (Lateral Movement)      | T1021.002            | Remote Services: SMB/Windows Admin Shares        | 공격자는 Windows 환경 내에서 측면 이동을 위해 PsExec 도구를 사용한다.                                 |
| 측면 이동 (Lateral Movement)      | T1021.004            | Remote Services: SSH                             | 공격자는 SSH 클라이언트 도구인 Plink를 사용하여 측면 이동을 시도한다.                                    |
| 명령 및 제어 (Command and Control) | T1071.001            | Application Layer Protocol: Web Protocols        | CrossC2 및 코발트 스트라이크 비컨은 표준 포트(443, 8443)를 통해 HTTP/HTTPS로 C2 통신을 수행한다.          |
| 명령 및 제어 (Command and Control) | T1071.004            | Application Layer Protocol: DNS                  | 포트 53을 통한 C2 통신이 관찰되었으며, 이는 DNS 터널링 기법의 사용을 시사한다.                              |

## 6.  방어 전략 및 권고 사항


### 6.1  사전 예방 및 강화 (예방)


- **크로스플랫폼 엔드포인트 보안**: CrossC2 위협의 가장 중요한 교훈은 보안의 초점이 더 이상 Windows에만 머물러서는 안 된다는 것이다. 기업은 반드시 모든 엔드포인트, 특히 Linux 서버와 macOS 워크스테이션에 EDR(Endpoint Detection and Response) 또는 XDR(Extended Detection and Response) 솔루션을 배포하고 올바르게 설정해야 한다.1

- **애플리케이션 제어 및 강화**: 비인가 실행 파일의 실행을 차단하기 위해 엄격한 애플리케이션 제어 정책을 구현해야 한다. 특히 `java.exe`와 같은 합법적인 프로세스가 `C:\$recycle.bin\`과 같은 비표준 디렉터리에서 DLL을 로드하는 행위를 차단하도록 규칙을 설정하는 것이 효과적이다.3

- **스크립팅 환경 비활성화 또는 제한**: 명시적으로 필요하지 않은 환경에서는 PowerShell과 같은 스크립팅 환경을 비활성화하거나, '제한된 언어 모드(Constrained Language Mode)'와 같은 기능을 사용하여 그 능력을 제한해야 한다.19

- **취약점 및 패치 관리**: TAG-100과 같은 공격 그룹은 인터넷에 노출된 서비스의 취약점을 초기 침투 경로로 악용하므로, 모든 시스템과 소프트웨어에 대한 엄격하고 시기적절한 패치 관리 프로그램을 운영하는 것이 필수적이다.19

- **최소 권한 원칙**: 모든 사용자 및 서비스 계정에 대해 최소 권한 원칙(Principle of Least Privilege)을 적용하여, 초기 침해가 발생하더라도 공격자가 권한을 상승시키고 네트워크 내에서 측면 이동하는 것을 어렵게 만들어야 한다.21

### 6.2  탐지 엔지니어링 및 위협 헌팅 (탐지)


- **행위 기반 탐지 규칙**: 보안팀은 다음과 같은 구체적이고 신뢰도 높은 탐지 로직을 구현해야 한다.
- `java.exe`, `rundll32.exe` 등과 같은 정상 시스템 유틸리티(LOLBAS, Living Off the Land Binaries)를 실행하는 새로운 예약 작업 생성을 모니터링한다. 특히 실행 대상 바이너리가 비정상적인 경로에 있을 경우 경고 수준을 높여야 한다.3

- 프로세스가 예기치 않은 위치(예: 사용자 프로필, 임시 디렉터리)에서 DLL을 로드하는 행위를 탐지한다. `java.exe`가 `jli.dll`을 로드하는 것이 대표적인 예다.

- 프로세스 메모리 덤프에서 "OdinLdr1337" 문자열과 같은 특정 메모리 아티팩트를 주기적으로 검색하는 위협 헌팅을 수행한다.2

- **네트워크 트래픽 분석**: 서버에서 드물게 접속하는 외부 IP 주소로 주기적인 '하트비트(heartbeat)' 형태의 비커닝(beaconing) 트래픽이 발생하는지 등 의심스러운 C2 통신을 식별하기 위해 아웃바운드 네트워크 연결을 감사해야 한다.3 DNS 필터링 및 싱크홀링(sinkholing) 기술을 사용하여 알려진 악성 도메인으로의 접근을 차단하는 것도 중요하다.23

- **로그 모니터링**: `PsExec.exe`가 관리자가 아닌 일반 사용자 워크스테이션에서 실행되거나 비업무 시간에 실행되는 등, 합법적인 관리 도구가 비정상적인 맥락에서 사용되는 것을 탐지하기 위해 로그를 적극적으로 모니터링해야 한다.25

### 6.3  사고 대응 플레이북 (대응 및 복구)


NIST(미국 국립표준기술연구소) 프레임워크와 같은 검증된 모델에 기반한 체계적인 사고 대응 계획을 수립하고 훈련해야 한다.26

- **1. 식별 (Identification)**: 본 안내서의 5.1절과 6.2절에서 제시된 IOC 및 탐지 규칙을 활용하여 침해 사실을 확인한다.

- **2. 격리 (Containment)**: 추가적인 측면 이동을 방지하기 위해 침해된 호스트를 네트워크로부터 즉시 격리한다. 이는 EDR 에이전트의 격리 명령이나 네트워크 접근 제어(NAC) 정책 변경을 통해 수행할 수 있다. 악성 C2 통신 세션을 강제 종료하고, 탈취된 계정은 비활성화한다.24

- **3. 제거 (Eradication)**: 예약 작업, 스테이징된 파일(`jli.dll`, `readme.txt`) 등 식별된 모든 악성 아티팩트를 시스템에서 제거한다. 최종 페이로드가 메모리 상에서만 동작하므로, 시스템을 재부팅하여 메모리 상의 비컨을 제거하는 것이 효과적일 수 있다.

- **4. 복구 (Recovery)**: 사전에 검증된 깨끗한 백업으로부터 시스템을 복구한다. 침해된 시스템 및 계정과 관련된 모든 자격 증명을 교체한다. 근본 원인 분석을 통해 초기 침투 벡터를 식별하고 해당 보안 취약점을 해결한다.

- **5. 교훈 (Lessons Learned)**: 사고 분석 결과를 바탕으로 보안 정책, 탐지 규칙, 사용자 교육 등을 개선한다. 정기적인 모의 훈련(Tabletop Exercise) 및 레드팀 훈련을 통해 개선된 방어 체계의 효과성을 검증한다.20

CrossC2와 같은 고도화된 위협에 대한 성공적인 방어는 예방 중심의 시그니처 기반 보안에서 탐지 심층의 행위 기반 보안으로의 전환을 요구한다. 공격 체인은 서명된 바이너리, 파일리스 실행, 난독화 등 전통적인 예방 통제를 체계적으로 우회하도록 설계되었다. 따라서 '침해를 가정하는(assume breach)' 자세를 견지하고, 예약 작업 생성, 비정상적 DLL 로딩, 주기적 아웃바운드 연결과 같은 '행위'를 탐지하는 데 집중해야 한다. 결국, 이러한 위협과의 싸움은 모든 플랫폼에 걸친 가시성, 행위 분석, 신속한 자동화 대응 역량의 질에 따라 승패가 결정될 것이다. 이는 더 이상 선택이 아닌 현대 기업 보안의 근본적인 요구사항이다.

## 7. 참고 자료


1. CrossC2 enables multi-platform Cobalt Strike attacks on Linux, macOS | SC Media, https://www.scworld.com/brief/crossc2-enables-multi-platform-cobalt-strike-attacks-on-linux-macos
2. CrossC2 Expanding Cobalt Strike Beacon to Cross-Platform Attacks - JPCERT/CC Eyes, https://blogs.jpcert.or.jp/en/2025/08/crossc2.html
3. Stealth Malware on the Rise: PS1Bot &amp; CrossC2 Attacks - Medium, https://medium.com/@anirudh.brahh/stealth-malware-on-the-rise-ps1bot-crossc2-attacks-c87b231fa966
4. TAG-100 Uses Open-Source Tools in Suspected ... - Recorded Future, https://go.recordedfuture.com/hubfs/reports/cta-2024-0716.pdf
5. CrossC2 Expanding Cobalt Strike Beacon to Cross-Platform Attacks - Osint Advisory IBM X-Force Report, https://exchange.xforce.ibmcloud.com/osint/guid:9c7c6aa1a884434aa540c9cb396f6def
6. Hackers Found Using CrossC2 to Expand Cobalt Strike Beacon's Reach to Linux and macOS - Teamwin Global Technologica, https://teamwin.in/hackers-found-using-crossc2-to-expand-cobalt-strike-beacons-reach-to-linux-and-macos/
7. CrossC2 Enables Cobalt Strike to Go Multi-Platform - Linux and macOS Now in the Crosshairs - Cyber Press, https://cyberpress.org/crossc2-cobalt-strike/
8. gloxec/CrossC2: generate CobaltStrike's cross-platform payload - GitHub, https://github.com/gloxec/CrossC2
9. Hackers Found Using CrossC2 to Expand Cobalt Strike Beacon's Reach to Linux and macOS, https://thehackernews.com/2025/08/researchers-warn-crossc2-expands-cobalt.html
10. Analysis of Black Basta Ransomware Chat Leaks - Trellix, https://www.trellix.com/blogs/research/analysis-of-black-basta-ransomware-chat-leaks/
11. HC3: Analyst Note – BlackSuit Ransomware - HHS.gov, https://www.hhs.gov/sites/default/files/blacksuit-ransomware-analyst-note-tlpclear.pdf
12. Threat Assessment: Black Basta Ransomware - Palo Alto Networks Unit 42, https://unit42.paloaltonetworks.com/threat-assessment-black-basta-ransomware/
13. New hacker group uses open-source tools to spy on entities in Asia-Pacific region, https://therecord.media/tag-100-espionage-hacking-backdoors-asia-pacific
14. Global Cyber Espionage Campaign Launched by Novel TAG-100 Operation | MSSP Alert, https://www.msspalert.com/brief/global-cyber-espionage-campaign-launched-by-novel-tag-100-operation
15. What Are Indicators of Compromise (IOC)? | Microsoft Security, https://www.microsoft.com/en-us/security/business/security-101/what-are-indicators-of-compromise-ioc
16. Indicators of Compromise (IOC) Security Explained - CrowdStrike, https://www.crowdstrike.com/en-us/cybersecurity-101/threat-intelligence/indicators-of-compromise-ioc/
17. MITRE ATT&amp;CK mapping and visualization - IBM, https://www.ibm.com/docs/en/qradar-common?topic=app-mitre-attck-mapping-visualization
18. What is the Mitre Att&amp;ck Framework? - CrowdStrike, https://www.crowdstrike.com/en-us/cybersecurity-101/cyberattacks/mitre-attack-framework/
19. Mitigating malware and ransomware attacks - NCSC.GOV.UK, https://www.ncsc.gov.uk/guidance/mitigating-malware-and-ransomware-attacks
20. 10 Strategies for Effective Cybersecurity Risk Mitigation, https://cymulate.com/blog/strategies-for-effective-cybersecurity-risk-mitigation/
21. What is a Lateral Movement? Prevention and Detection Methods - Fortinet, https://www.fortinet.com/resources/cyberglossary/lateral-movement
22. NSA'S Top Ten Cybersecurity Mitigation Strategies, https://www.nsa.gov/portals/75/documents/what-we-do/cybersecurity/professional-resources/csi-nsas-top10-cybersecurity-mitigation-strategies.pdf
23. Command and Control: How to Prevent a C2 Server Attack | DNSFilter, https://www.dnsfilter.com/blog/c2-server-command-and-control-attack
24. Detect and Stop C2 Attacks - Fidelis Security, https://fidelissecurity.com/threatgeek/threat-detection-response/c2-command-and-control-detection/
25. How Huntress Addresses Lateral Movement, https://www.huntress.com/blog/how-huntress-addresses-lateral-movement
26. Guide to Malware Incident Prevention and Handling for Desktops and Laptops - NIST Technical Series Publications, https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-83r1.pdf
27. Cyber incident response toolkit: malware playbook - The Scottish Government, https://www.gov.scot/binaries/content/documents/govscot/publications/advice-and-guidance/2019/10/cyber-resilience-incident-management/documents/cyber-incident-response-malware-playbook/cyber-incident-response-malware-playbook/govscot%3Adocument/Cyber%2Bincident%2Bresponse%2Btoolkit%2B-%2Bmalware%2Bplaybook%2Bv2.6.docx
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>