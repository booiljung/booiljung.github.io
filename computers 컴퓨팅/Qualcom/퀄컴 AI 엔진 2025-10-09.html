<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:퀄컴 AI 엔진</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>퀄컴 AI 엔진</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">컴퓨터 (Computers)</a> / <a href="index.html">퀄컴</a> / <span>퀄컴 AI 엔진</span></nav>
                </div>
            </header>
            <article>
                <h1>퀄컴 AI 엔진</h1>
<h2>1.  온디바이스 AI와 이기종 컴퓨팅의 부상</h2>
<h3>1.1  클라우드 AI의 한계와 온디바이스 AI의 패러다임 전환</h3>
<p>인공지능(AI) 기술의 발전은 초기 데이터센터 중심의 클라우드 컴퓨팅 모델에 크게 의존해왔다. 방대한 양의 데이터를 처리하고 복잡한 신경망 모델을 훈련시키기 위해서는 클라우드의 막대한 연산 자원이 필수적이었다. 그러나 AI가 일상적인 애플리케이션과 서비스에 깊숙이 통합되면서, 클라우드 중심 모델은 몇 가지 근본적인 한계에 직면하게 되었다. 첫째, <strong>지연 시간(latency)</strong> 문제는 실시간 상호작용이 필수적인 애플리케이션에서 치명적인 단점으로 작용한다. 사용자의 데이터를 클라우드로 전송하고, 연산 결과를 다시 디바이스로 수신하는 과정에서 발생하는 시간 지연은 자율 주행, 증강 현실(AR), 실시간 번역과 같은 서비스의 사용자 경험을 저해한다. 둘째, 민감한 개인 정보를 외부 서버로 전송해야 하는 <strong>개인정보보호(privacy)</strong> 문제는 사용자의 데이터 주권에 대한 우려를 낳는다. 셋째, 안정적인 네트워크 연결이 보장되지 않는 환경에서는 서비스 이용이 불가능한 **연결 의존성(reliability)**은 AI 서비스의 보편적 확산을 가로막는다. 마지막으로, 대규모 데이터센터를 유지하고 운영하는 데 드는 막대한 **운영 비용(operational cost)**은 AI 서비스의 경제적 지속 가능성에 대한 질문을 제기한다.</p>
<p>이러한 클라우드 AI의 한계를 극복하기 위한 대안으로 **온디바이스 AI(On-Device AI)**가 새로운 패러다임으로 부상했다. 온디바이스 AI는 스마트폰, PC, 자동차, IoT 기기 등 사용자의 엣지 디바이스에서 직접 AI 연산을 수행하는 방식을 의미한다. 데이터를 외부로 전송할 필요가 없으므로 즉각적인 응답이 가능하여 **실시간 반응성(real-time responsiveness)**이 극대화되고, 모든 데이터가 디바이스 내부에 머물러 <strong>개인정보보호</strong>가 강화된다.1 또한, 네트워크 연결 없이도 AI 기능이 동작하여 <strong>신뢰성</strong>과 안정성이 향상된다. 퀄컴은 이러한 패러다임 전환의 잠재력을 일찍이 인지하고, 2018년 자사의 하드웨어 및 소프트웨어 AI 기술을 ’퀄컴 AI 엔진(Qualcomm AI Engine)’이라는 통합 브랜드로 공식화하며 온디바이스 AI 시장을 선점하기 위한 전략적 행보를 시작했다.1 이는 단순히 개별 하드웨어 구성 요소를 제공하는 것을 넘어, 온디바이스 AI를 위한 포괄적인 솔루션 제공자로서의 정체성을 확립하려는 의도였다. 이 브랜드 전략은 복잡한 기술의 집합체를 ’엔진’이라는 직관적인 개념으로 포장하여 OEM 제조사와 소비자에게 퀄컴 플랫폼의 AI 역량을 효과적으로 전달하는 역할을 수행했다.</p>
<h3>1.2  이기종 컴퓨팅(Heterogeneous Computing)의 개념과 필요성</h3>
<p>현대의 AI 워크로드는 그 종류와 요구사항이 매우 다양하다. 이미지 인식, 자연어 처리, 생성형 AI 등 각기 다른 모델은 서로 다른 연산 특성을 가지며, 이는 단일 종류의 프로세서만으로는 최적의 효율을 달성하기 어렵다는 것을 의미한다. 예를 들어, 중앙 처리 장치(CPU)는 복잡한 제어 흐름과 순차적인 작업에 강점을 보이지만, 대규모 병렬 연산에는 비효율적이다. 반면, 그래픽 처리 장치(GPU)는 수천 개의 코어를 활용하여 병렬 연산을 가속화하는 데 탁월하지만, 항상 최고의 전력 효율을 보장하지는 않는다.</p>
<p>이러한 배경에서 **이기종 컴퓨팅(Heterogeneous Computing)**의 개념이 필수적으로 대두되었다. 이기종 컴퓨팅은 CPU, GPU, 그리고 신경망 처리 장치(NPU)나 디지털 신호 처리 장치(DSP)와 같은 전문화된 가속기 등, 각기 다른 아키텍처와 특성을 가진 프로세서들을 단일 시스템 온 칩(SoC)에 통합하는 설계 방식이다.3 핵심 아이디어는 처리해야 할 작업(workload)의 특성을 분석하여, 해당 작업을 가장 효율적으로 수행할 수 있는 최적의 프로세서에 동적으로 할당하는 것이다. 예를 들어, AI 모델의 행렬 곱셈 연산은 NPU에, 사용자 인터페이스 렌더링은 GPU에, 운영체제의 일반적인 작업은 CPU에 할당함으로써 전체 시스템의 성능과 효율을 극대화할 수 있다.5</p>
<p>이기종 컴퓨팅의 필요성은 AI 애플리케이션의 사용 시나리오를 통해 더욱 명확해진다. 퀄컴은 AI 사용 사례를 세 가지 유형으로 분류한다: <strong>순간적(On-demand)</strong>, <strong>지속적(Sustained)</strong>, <strong>상시적(Pervasive)</strong> 사용 사례.3 이미지 생성이나 문서 요약과 같은 ‘순간적’ 작업은 짧은 시간 안에 최대의 성능을 요구하며 NPU의 폭발적인 연산 능력을 활용한다. 실시간 비디오 해상도 향상이나 게임 AI와 같은 ‘지속적’ 작업은 높은 성능을 오랜 시간 유지해야 하므로, 성능뿐만 아니라 발열 제어와 전력 효율이 무엇보다 중요하다. NPU와 GPU가 협력하여 부하를 분산 처리하는 것이 이상적이다. 마지막으로, 항상 켜져 있는 AI 비서나 상황인지 기반의 개인화 서비스와 같은 ‘상시적’ 작업은 배터리 소모를 최소화해야 하므로, 초저전력으로 설계된 전용 프로세서(예: Sensing Hub)에서 처리되어야 한다. 이처럼 다양한 AI 작업의 요구사항을 단 하나의 ‘만능’ 프로세서로 충족시키는 것은 불가능하며, 각기 다른 강점을 가진 프로세서들의 조합, 즉 이기종 컴퓨팅 아키텍처가 현대 온디바이스 AI를 위한 필연적인 해답임을 알 수 있다.</p>
<h3>1.3  퀄컴 AI 엔진의 역할 및 비전</h3>
<p>퀄컴 AI 엔진은 단순히 NPU 하드웨어 블록 하나를 지칭하는 용어가 아니다. 이는 퀄컴의 온디바이스 AI 비전을 실현하기 위한 하드웨어와 소프트웨어의 총체적인 결합체이다. 하드웨어 측면에서는 AI 추론 가속의 핵심인 <strong>퀄컴 Hexagon™ NPU</strong>를 중심으로, 병렬 연산을 담당하는 <strong>퀄컴 Adreno™ GPU</strong>, 범용 연산을 처리하는 <strong>퀄컴 Kryo™ 또는 Oryon™ CPU</strong>, 초저전력 상시 센싱을 위한 <strong>퀄컴 Sensing Hub</strong>, 그리고 이들 프로세서가 원활하게 데이터를 공유할 수 있도록 설계된 <strong>메모리 서브시스템</strong>까지 포괄하는 이기종 컴퓨팅 아키텍처 그 자체를 의미한다.1 이 프로세서들은 개별적으로 동작하는 것이 아니라, 단일 칩 위에서 유기적으로 연동되도록 설계되어 AI 애플리케이션을 빠르고 효율적으로 실행한다.</p>
<p>소프트웨어 측면에서는 이러한 복잡한 하드웨어를 개발자들이 손쉽게 활용할 수 있도록 지원하는 **퀄컴 AI 스택(Qualcomm AI Stack)**이 존재한다. 이 소프트웨어 스택은 다양한 AI 프레임워크(TensorFlow, PyTorch 등)로 개발된 모델을 퀄컴 하드웨어에 최적화하고, 각 연산에 가장 적합한 프로세서를 선택하여 작업을 분배하는 역할을 수행한다.</p>
<p>퀄컴 AI 엔진의 비전은 ’모든 곳에 지능형 컴퓨팅(intelligent computing everywhere)’을 구현하는 것이다.3 이는 스마트폰을 넘어 PC, 자동차, 확장 현실(XR), 사물 인터넷(IoT) 등 인간의 삶과 연결된 모든 디바이스에 온디바이스 AI를 내장하여, 더욱 개인화되고, 지능적이며, 안전한 사용자 경험을 제공하는 것을 목표로 한다.6 퀄컴은 개발자들이 퀄컴 AI 스택을 사용하여 한 번의 코딩으로 전 세계 수십억 개에 달하는 스냅드래곤 기반 디바이스에 자신의 AI 애플리케이션을 배포할 수 있는 강력한 생태계를 구축하고 있다.3 이를 통해 퀄컴은 단순한 반도체 공급자를 넘어, 온디바이스 생성형 AI 시대를 이끄는 핵심 플랫폼 제공자로서의 입지를 공고히 하고자 한다.</p>
<h2>2.  퀄컴 AI 엔진 하드웨어 아키텍처 분석</h2>
<h3>2.1  핵심 처리 장치: Hexagon, Adreno, Kryo/Oryon</h3>
<p>퀄컴 AI 엔진의 강력한 성능과 효율성은 각기 다른 역할에 특화된 세 가지 핵심 처리 장치의 유기적인 협력을 통해 구현된다. 이들은 Hexagon NPU, Adreno GPU, 그리고 Kryo/Oryon CPU로, 이기종 컴퓨팅 아키텍처의 근간을 이룬다.</p>
<p><strong>Qualcomm Hexagon™ 프로세서 (NPU):</strong> AI 엔진의 심장부라 할 수 있는 Hexagon 프로세서는 저전력으로 지속적인 고성능 AI 추론(inference)을 수행하도록 처음부터 설계된 핵심적인 AI 가속기이다.3 본래 디지털 신호 처리(Digital Signal Processing, DSP)를 위해 개발되었으나, AI 시대가 도래하면서 신경망 연산에 특화된 기능을 통합하며 강력한 NPU(Neural Processing Unit)로 진화했다.7 Hexagon 프로세서는 스칼라(scalar), 벡터(vector), 텐서(tensor) 연산을 모두 효율적으로 처리할 수 있는 아키텍처를 갖추고 있어, 현대 딥러닝 모델의 다양한 연산 요구사항에 효과적으로 대응한다. 특히, 전력 소모 대비 성능이 뛰어나 배터리 수명이 중요한 모바일 기기에서 AI 기능을 상시 활성화하는 데 결정적인 역할을 한다.3</p>
<p><strong>Qualcomm Adreno™ GPU:</strong> Adreno GPU는 본래 그래픽 렌더링을 위해 설계되었지만, 수천 개의 연산 코어를 통해 대규모 데이터를 병렬로 처리하는 능력 덕분에 AI 워크로드 가속에도 효과적으로 활용된다. 특히 컨볼루션 신경망(CNN)의 컨볼루션 레이어나 대규모 행렬 연산과 같이 병렬성이 높은 특정 AI 연산을 처리하는 데 강점을 보인다.1 또한, AI 모델의 입력 데이터를 처리하는 전처리(pre-processing) 과정이나 추론 결과를 후처리(post-processing)하는 단계에서도 GPU의 병렬 처리 능력이 활용되어 전체 AI 파이프라인의 속도를 높인다.9 개발자들은 OpenCL과 같은 API를 통해 Adreno GPU의 연산 자원에 접근하여 AI 워크로드를 가속할 수 있다.</p>
<p><strong>Qualcomm Kryo™/Oryon™ CPU:</strong> Kryo 또는 Oryon CPU는 시스템의 두뇌 역할을 하는 범용 프로세서로서, AI 엔진 내에서 복잡한 제어 로직을 수행하거나 다른 전문 가속기들이 효율적으로 처리하기 어려운 비정형적인 연산을 담당한다.1 예를 들어, AI 모델 내에서 조건부 분기나 희소(sparse) 데이터 처리와 같이 병렬화하기 어려운 연산들은 CPU에서 처리하는 것이 더 효율적일 수 있다. 또한, CPU는 전체 AI 애플리케이션의 실행 흐름을 제어하고, Hexagon NPU와 Adreno GPU에 작업을 분배하며, 최종 결과를 취합하는 등 오케스트레이터(orchestrator)로서의 중요한 역할을 수행한다.10 이처럼 세 가지 프로세서는 각자의 강점을 바탕으로 AI 워크로드를 분담하고 협력함으로써, 퀄컴 AI 엔진이 단일 프로세서로는 달성할 수 없는 높은 수준의 성능과 전력 효율을 동시에 달성할 수 있도록 한다.</p>
<h3>2.2  Hexagon 프로세서 심층 분석</h3>
<p>Hexagon 프로세서가 AI 시대의 핵심 NPU로 자리매김할 수 있었던 배경에는 수년에 걸쳐 발전해 온 독자적인 아키텍처 설계가 있다. 이 아키텍처의 핵심은 VLIW, SIMD, 하드웨어 다중 스레딩, 그리고 AI 연산에 특화된 전용 가속기인 HVX와 HTA에 있다.</p>
<p><strong>VLIW (Very Long Instruction Word) 및 SIMD (Single Instruction, Multiple Data) 아키텍처:</strong> Hexagon 아키텍처의 근간을 이루는 두 가지 핵심 원리는 VLIW와 SIMD이다. VLIW는 서로 의존성이 없는 여러 개의 명령어(최대 4개)를 하나의 긴 명령어 워드 ’패킷’으로 묶어, 한 클럭 사이클에 동시에 실행 유닛으로 보내는 기술이다.7 이를 통해 명령어 수준의 병렬성(Instruction-Level Parallelism)을 극대화하여 높은 처리량을 달성한다. SIMD는 하나의 명령어로 여러 개의 데이터 요소를 동시에 처리하는 데이터 수준 병렬성(Data-Level Parallelism) 기술이다.7 예를 들어, ‘벡터 덧셈’ 명령어 하나로 128비트 레지스터에 담긴 16개의 8비트 정수를 한 번에 더할 수 있다. AI 추론의 핵심 연산이 대부분 행렬 곱셈과 컨볼루션 같은 벡터 및 행렬 연산으로 이루어져 있다는 점을 고려할 때, VLIW와 SIMD의 조합은 Hexagon 프로세서가 이러한 연산을 매우 효율적으로 처리할 수 있게 하는 결정적인 요소이다.</p>
<p><strong>하드웨어 다중 스레딩 (Hardware Multithreading):</strong> Hexagon 프로세서는 단일 코어에서 여러 개의 스레드를 동시에 처리할 수 있는 하드웨어 다중 스레딩을 지원하여 프로세서의 활용률을 극대화한다.7 초기 버전에서는 매 클럭 사이클마다 스레드를 순차적으로 전환하는 ‘배럴 시간적 다중 스레딩(barrel temporal multithreading)’ 방식을 사용했다. 이는 메모리 접근과 같이 지연 시간이 긴 명령어가 실행될 때 다른 스레드의 명령어를 처리함으로써 코어의 유휴 상태를 최소화하는 효과가 있었다. Hexagon v5부터는 L2 캐시 미스나 인터럽트 대기와 같은 특정 이벤트가 발생했을 때 스레드를 전환하는 ‘동적 다중 스레딩(Dynamic Multithreading, DMT)’ 방식으로 발전했다.7 이 기술은 지연 시간을 효과적으로 숨기고, 외부에서 보기에는 여러 개의 논리적 코어가 동시에 작동하는 것처럼 보이게 하여 전체적인 처리 성능을 향상시킨다.</p>
<p><strong>Hexagon 벡터 확장 (HVX) 및 텐서 가속기 (HTA)의 진화:</strong> Hexagon 프로세서의 발전 과정은 AI 워크로드의 진화와 궤를 같이한다. 초기에는 DSP로서의 역할에 충실했지만, 스마트폰 카메라의 성능이 고도화되고 컴퓨터 비전 기술의 중요성이 커지면서, 이미지 및 비디오 처리에 특화된 대규모 벡터 연산의 필요성이 대두되었다. 이에 대응하기 위해 퀄컴은 **Hexagon 벡터 확장(Hexagon Vector eXtensions, HVX)**을 도입했다.7 HVX는 1024비트 폭의 벡터 레지스터와 관련 명령어 셋을 제공하여, 컴퓨터 비전 및 이미지 처리 워크로드를 CPU에서 오프로드하여 저전력으로 고속 처리할 수 있게 했다.10</p>
<p>이후 딥러닝이 AI의 주류가 되면서, 모델의 연산은 대규모 행렬(텐서) 곱셈 중심으로 재편되었다. 일반적인 벡터 연산 유닛으로 텐서 연산을 처리하는 것은 비효율적이었고, 이에 퀄컴은 텐서 연산에 특화된 전용 하드웨어 블록인 **Hexagon 텐서 가속기(Hexagon Tensor Accelerator, HTA)**를 도입했다.7 HTA는 대규모 행렬 곱셈 연산을 하드웨어 수준에서 직접 처리하여 AI 추론 성능을 비약적으로 향상시켰다. HTA의 도입은 Hexagon이 단순한 DSP를 넘어 완전한 NPU로 진화했음을 상징하는 중요한 이정표였다. 4세대 AI 엔진(Snapdragon 855)에 HTA가 처음 탑재된 이후, 세대를 거듭하며 그 성능은 기하급수적으로 증가했다. 5세대 AI 엔진(Snapdragon 865)은 15 TOPS, 6세대 AI 엔진(Snapdragon 888)은 26 TOPS의 성능을 달성했으며 7, 이는 Hexagon 아키텍처가 AI 산업의 요구사항 변화에 맞춰 얼마나 빠르고 효과적으로 진화해왔는지를 명확히 보여준다.</p>
<p>이러한 하드웨어 아키텍처의 진화는 단순히 개별 프로세서의 성능 향상에 그치지 않는다. 퀄컴 AI 엔진의 진정한 강점은 이들 프로세서가 단일 SoC 위에서 공유 메모리 서브시스템을 통해 긴밀하게 통합되어 있다는 점에 있다. 만약 CPU, GPU, NPU가 별도의 칩으로 존재한다면 각 칩 간의 데이터 전송이 심각한 성능 병목과 전력 낭비를 유발할 것이다.3 하지만 AI 엔진은 이들을 하나의 다이(die)에 집적함으로써 데이터 이동 거리를 최소화하고, Hexagon Direct Link와 같은 전용 데이터 경로를 통해 프로세서 간 통신 오버헤드를 줄인다.11 따라서 AI 엔진의 이기종 컴퓨팅 우위는 개별 프로세서의 성능뿐만 아니라, 데이터 이동을 최소화하여 시스템 전체의 효율을 극대화하는 시스템 수준의 아키텍처 설계에서 비롯된다고 할 수 있다.</p>
<h2>3.  퀄컴 AI 소프트웨어 스택 및 개발자 생태계</h2>
<p>강력한 하드웨어 아키텍처는 그 잠재력을 최대한 이끌어낼 수 있는 정교한 소프트웨어 스택이 뒷받침될 때 비로소 완성된다. 퀄컴 AI 엔진은 개발자들이 복잡한 이기종 하드웨어를 효율적으로 활용할 수 있도록 지원하는 포괄적인 소프트웨어 스택과 개발자 생태계를 제공한다. 이 생태계의 핵심에는 개발자의 요구 수준에 따라 선택할 수 있는 두 가지 주요 개발 프레임워크, SNPE와 QNN이 있다.</p>
<h3>3.1  개발 프레임워크: SNPE와 QNN 비교 분석</h3>
<p>퀄컴은 개발자의 전문성과 애플리케이션의 요구사항에 따라 각기 다른 수준의 제어 권한과 추상화를 제공하는 이원화된 SDK 전략을 채택하고 있다. 이는 광범위한 개발자 커뮤니티를 포용하기 위한 전략적 선택으로, 고수준 API를 선호하는 애플리케이션 개발자부터 하드웨어 수준의 최적화를 추구하는 전문가까지 모두를 만족시키려는 의도를 담고 있다.</p>
<p><strong>Qualcomm Neural Processing SDK (SNPE):</strong> SNPE는 퀄컴의 온디바이스 AI 개발을 위한 고수준 소프트웨어 가속 런타임이다.8 SNPE의 가장 큰 특징은 <strong>추상화</strong>에 있다. 개발자는 복잡한 하드웨어의 내부 구조나 각 프로세서의 특성을 깊이 이해하지 않아도, 간단한 API 호출을 통해 AI 모델을 스냅드래곤 플랫폼에 배포하고 가속할 수 있다.13 SNPE 런타임은 모델의 연산 그래프를 분석하여 각 연산(operation)을 Hexagon NPU, Adreno GPU, Kryo CPU 중 가장 적합한 처리 장치에 자동으로 할당한다.1 이는 개발 과정을 단순화하고 프로토타이핑 속도를 높여주므로, AI 기능을 애플리케이션에 빠르게 통합하고자 하는 대부분의 개발자에게 이상적인 솔루션이다. 즉, SNPE는 개발 편의성과 빠른 시장 출시에 중점을 둔 ‘쉬운 버튼(easy button)’ 접근 방식을 제공한다.</p>
<p><strong>Qualcomm AI Engine Direct (QNN):</strong> QNN은 SNPE보다 한 단계 더 깊이 들어가는 저수준 소프트웨어 아키텍처이다.8 QNN은 개발자에게 퀄컴 AI 엔진의 각 하드웨어 가속기에 대한 <strong>직접적인 접근과 세밀한 제어 권한</strong>을 부여한다.13 개발자는 QNN API를 사용하여 AI 모델의 특정 부분을 특정 프로세서에서 실행하도록 명시적으로 지정할 수 있으며, 메모리 관리나 연산 스케줄링을 수동으로 최적화하여 성능을 극한까지 끌어올릴 수 있다. QNN은 SNPE와 같은 고수준 런타임의 기반이 되는 모듈식 라이브러리 형태로 구성되어 있으며, 최고의 성능과 전력 효율을 달성해야 하는 고성능 컴퓨팅, 자동차, 또는 주요 OEM의 플래그십 기능 개발과 같은 전문적인 분야에 적합하다. QNN은 최고의 성능을 추구하는 전문가를 위한 ’전문가 모드(expert mode)’라 할 수 있다.</p>
<p><strong>사용 사례에 따른 SDK 선택 가이드:</strong> 두 SDK의 선택은 전적으로 프로젝트의 목표에 달려 있다.</p>
<ul>
<li>
<p><strong>SNPE가 적합한 경우:</strong></p>
</li>
<li>
<p>다양한 안드로이드 기기에 범용적으로 동작하는 AI 앱을 빠르게 개발해야 할 때.</p>
</li>
<li>
<p>AI 하드웨어에 대한 깊은 지식 없이 기존 AI 모델을 손쉽게 통합하고 싶을 때.</p>
</li>
<li>
<p>개발 속도와 편의성이 절대적인 성능보다 우선시될 때.</p>
</li>
<li>
<p><strong>QNN이 적합한 경우:</strong></p>
</li>
<li>
<p>특정 스냅드래곤 플랫폼에서 성능과 전력 효율을 한계까지 최적화해야 할 때.</p>
</li>
<li>
<p>모델의 각 레이어를 어느 하드웨어에서 실행할지 정밀하게 제어해야 하는 복잡한 AI 파이프라인을 구축할 때.</p>
</li>
<li>
<p>자체적인 AI 런타임이나 프레임워크를 퀄컴 하드웨어 위에서 구축하고자 할 때.</p>
</li>
</ul>
<p>이러한 이원화 전략을 통해 퀄컴은 AI 개발 생태계의 진입 장벽을 낮추는 동시에, 최상위 성능을 요구하는 파트너사들의 요구까지 충족시키며 폭넓은 개발자 기반을 확보하고 있다.</p>
<h3>3.2  개발 워크플로우 및 핵심 도구</h3>
<p>퀄컴 AI 스택은 아이디어 구상부터 최종 제품 배포에 이르는 전체 AI 개발 워크플로우를 지원하는 강력한 도구들을 제공한다. 이 워크플로우는 크게 모델 변환, 모델 최적화, 그리고 배포 및 프로파일링의 단계로 나눌 수 있다.</p>
<p><strong>모델 변환 및 지원 형식:</strong> AI 개발의 첫 단계는 TensorFlow, PyTorch, ONNX와 같은 표준 프레임워크에서 훈련된 모델을 퀄컴 하드웨어에서 실행 가능한 형식으로 변환하는 것이다.9 퀄컴은 이를 위해 <code>qnn-tensorflow-converter</code>, <code>qnn-pytorch-converter</code>, <code>qnn-onnx-converter</code> 등 각 프레임워크에 특화된 변환 도구들을 제공한다.14 이 도구들은 원본 모델의 연산 그래프를 분석하여 퀄컴 AI 엔진의 하드웨어 백엔드(NPU, GPU, CPU)가 이해할 수 있는 내부 표현(internal representation)으로 변환한다. 이 과정에서 지원되지 않는 연산을 CPU에서 실행하도록 분할하거나, 특정 연산 패턴을 하드웨어에 최적화된 융합 연산(fused operation)으로 대체하는 등의 최적화가 이루어진다.</p>
<p><strong>AI Model Efficiency Toolkit (AIMET):</strong> 모델의 성능을 극대화하기 위한 핵심 과정은 **양자화(quantization)**이다. AIMET는 퀄컴이 오픈소스로 제공하는 모델 효율화 도구로, AI 모델을 압축하고 양자화하는 고급 기술들을 집약하고 있다.9 AIMET는 단순한 훈련 후 양자화(Post-Training Quantization, PTQ)를 넘어, <strong>Adaround</strong>와 같이 가중치를 반올림하는 방식을 학습하여 양자화 오류를 최소화하는 정교한 기술을 제공한다. 또한, 양자화 과정에서 발생할 수 있는 정확도 저하를 최소화하기 위해, 양자화 효과를 시뮬레이션하며 모델을 재훈련하는 **양자화 인식 훈련(Quantization-Aware Training, QAT)**과 같은 기법도 지원한다.16 AIMET의 효과는 실제 상용 애플리케이션에서도 입증되었는데, 예를 들어 Snapchat은 AIMET를 사용하여 자사의 인기 있는 렌즈(Lenses) 필터에 사용되는 AI 모델들을 양자화함으로써 얼굴 인식의 정확도와 성능을 동시에 향상시켰다.16</p>
<p><strong>Qualcomm AI Hub:</strong> 퀄컴 AI 허브는 온디바이스 AI 개발의 복잡성을 해결하고 확장성을 부여하는 중추적인 플랫폼이다.17 이는 단순한 모델 저장소(model zoo)를 넘어선다. AI 허브는 이미지 분류, 객체 탐지 등 다양한 사용 사례에 맞춰 사전 최적화된 100개 이상의 AI 모델 라이브러리를 제공하여 개발자가 즉시 활용할 수 있도록 한다.18 더 중요한 기능은 <strong>‘Bring Your Own Model (BYOM)’</strong> 워크플로우이다.17 개발자는 자신이 훈련한 PyTorch 또는 ONNX 모델을 AI 허브에 업로드하기만 하면, 클라우드 기반의 자동화된 파이프라인이 해당 모델을 목표 스냅드래곤 디바이스에 맞게 자동으로 변환, 양자화, 최적화해준다. 나아가, 개발자는 실제 물리 디바이스 클러스터에서 자신의 모델을 원격으로 실행하고, 지연 시간, 메모리 사용량, 각 처리 장치별 성능 등 상세한 프로파일링 결과를 얻을 수 있다.17 이는 값비싼 개발 보드 없이도 정확한 성능 측정이 가능하게 하여 개발 사이클을 획기적으로 단축시킨다. 이처럼 AI 허브는 온디바이스 AI 모델 배포라는 고도로 전문화된 작업을 확장 가능한 서비스형(as-a-service) 워크플로우로 전환함으로써, 더 많은 개발자들이 퀄컴 AI 엔진의 성능을 손쉽게 활용할 수 있도록 생태계의 문을 활짝 열어주는 역할을 한다.</p>
<h2>4.  신경망 양자화 기술의 원리</h2>
<p>신경망 양자화는 퀄컴 AI 엔진과 같은 온디바이스 AI 가속기의 성능을 최대한 활용하기 위한 필수 불가결한 기술이다. 이는 단순히 모델의 크기를 줄이는 압축 기술을 넘어, 연산의 본질을 부동소수점에서 정수 기반으로 전환하여 하드웨어 가속을 가능하게 하는 핵심적인 변환 과정이다.</p>
<h3>4.1  양자화의 수학적 기초</h3>
<p><strong>양자화의 정의 및 목적:</strong> 대부분의 딥러닝 모델은 32비트 부동소수점(FP32) 정밀도로 훈련된다. FP32는 넓은 범위의 숫자를 높은 정밀도로 표현할 수 있지만, 많은 메모리와 연산 자원을 소모한다. 양자화는 이러한 FP32로 표현된 모델의 가중치(weights)와 활성화(activations)를 INT8(8비트 정수), FP16(16비트 부동소수점) 등 더 낮은 정밀도의 데이터 타입으로 변환하는 기술이다.19 이 변환을 통해 다음과 같은 세 가지 주요 이점을 얻는다. 첫째, <strong>모델 크기 감소</strong>: 데이터 타입의 비트 수가 줄어듦에 따라 모델이 차지하는 저장 공간과 메모리 점유율이 크게 감소한다(예: FP32에서 INT8로 변환 시 약 4배 감소). 둘째, <strong>메모리 대역폭 절약</strong>: 모델이 작아지면 프로세서와 메모리 간에 데이터를 주고받는 데 필요한 대역폭이 줄어들어 병목 현상을 완화하고 전력 소모를 줄인다. 셋째, <strong>추론 가속화</strong>: Hexagon NPU와 같은 많은 AI 가속기는 저정밀도 정수 연산에 특화된 대규모 병렬 연산 유닛을 탑재하고 있다. 양자화를 통해 모델의 연산을 정수 연산으로 변환하면, 이러한 하드웨어의 능력을 100% 활용하여 추론 속도를 극적으로 향상시킬 수 있다.20</p>
<p><strong>어파인(Affine) 및 대칭(Symmetric) 양자화:</strong> 부동소수점 값을 정수 값으로 매핑하는 방식에는 크게 두 가지가 있다.</p>
<ul>
<li>
<p><strong>어파인 양자화(Affine Quantization):</strong> 이는 가장 일반적인 양자화 방식으로, 선형 변환을 통해 부동소수점 값의 범위 <code>[\alpha, \beta]</code>를 정수 값의 범위 <code>[\alpha_q, \beta_q]</code>로 매핑한다. 이 매핑은 두 개의 파라미터, 즉 **스케일(Scale, S)**과 **제로포인트(Zero-Point, Z)**에 의해 정의된다.19 스케일은 부동소수점 값의 간격을 결정하는 양의 실수이며, 제로포인트는 부동소수점 값 0에 해당하는 정수 값이다. 이 방식은 비대칭적인 데이터 분포도 효과적으로 표현할 수 있어 정확도 측면에서 유리하다.</p>
</li>
<li>
<p><strong>대칭 양자화(Symmetric Quantization):</strong> 이 방식은 어파인 양자화의 특별한 경우로, 부동소수점 값 0이 정수 값 0에 정확히 매핑되도록 제로포인트 <code>Z</code>를 0으로 고정한다.19 이를 위해 부동소수점 값의 범위를 원점을 기준으로 대칭적인 <code>[-a, a]</code>로 설정한다. 제로포인트가 0이 되면 일부 연산(예: 제로포인트 덧셈)을 생략할 수 있어 연산 오버헤드가 줄어들고 추론 속도가 빨라지는 장점이 있다. 하지만 데이터 분포가 비대칭적일 경우, 매핑 과정에서 정보 손실이 발생하여 정확도가 약간 저하될 수 있다. 따라서 대칭 양자화는 성능과 정확도 간의 트레이드오프 관계에 있다.</p>
</li>
</ul>
<p><strong>양자화 및 역양자화 수식:</strong> 실수 값 <span class="math math-inline">x</span>를 양자화된 정수 값 <span class="math math-inline">x_q</span>로 변환하고 다시 복원하는 과정은 다음과 같은 수식으로 표현된다.</p>
<ul>
<li>
<p><strong>역양자화 (De-quantization):</strong> 양자화된 정수 값 <span class="math math-inline">x_q</span>를 원래의 부동소수점 값 <span class="math math-inline">x</span>로 근사하여 복원하는 과정이다.<br />
<span class="math math-display">
x = S \cdot (x_q - Z)
</span><br />
여기서 <span class="math math-inline">S</span>는 스케일, <span class="math math-inline">Z</span>는 제로포인트이다.19</p>
</li>
<li>
<p><strong>양자화 (Quantization):</strong> 부동소수점 값 <span class="math math-inline">x</span>를 정수 값 <span class="math math-inline">x_q</span>로 변환하는 과정이다. 이 과정에는 반올림(rounding)과 클리핑(clipping)이 포함된다.</p>
<p><span class="math math-display">
x_q = \text{clip}(\text{round}(\frac{x}{S} + Z), q_{\text{min}}, q_{\text{max}})
</span><br />
<code>round()</code> 함수는 가장 가까운 정수로 변환하는 역할을 하며, <code>clip()</code> 함수는 결과값이 해당 정수 타입이 표현할 수 있는 최소값(<span class="math math-inline">q_{\text{min}}</span>)과 최대값(<span class="math math-inline">q_{\text{max}}</span>) 범위를 벗어나지 않도록 제한한다.19 스케일 <span class="math math-inline">S</span>와 제로포인트 <span class="math math-inline">Z</span>는 일반적으로 데이터의 실제 범위 <span class="math math-inline">[\alpha, \beta]</span>와 목표 정수 범위 <span class="math math-inline">[\alpha_q, \beta_q]</span>를 기반으로 다음과 같이 계산된다.<br />
<span class="math math-display">
S = \frac{\beta - \alpha}{\beta_q - \alpha_q}, \quad Z = \text{round}\left(\frac{\beta \alpha_q - \alpha \beta_q}{\beta - \alpha}\right)
</span><br />
22</p>
</li>
</ul>
<h3>4.2  양자화 행렬 곱셈</h3>
<p>신경망 추론 연산의 약 80% 이상을 차지하는 핵심 연산은 행렬 곱셈이다. 따라서 양자화의 실질적인 성능 향상은 이 행렬 곱셈 연산을 얼마나 효율적으로 변환하는지에 달려 있다.</p>
<p>부동소수점 행렬 곱셈 <span class="math math-inline">Y = XW + b</span>는 각 원소에 대해 다음과 같이 계산된다.22</p>
<p><span class="math math-display">
Y_{i,j} = b_j + \sum_{k} X_{i,k} W_{k,j}
</span><br />
이 연산은 모두 부동소수점 곱셈과 덧셈으로 이루어진다.</p>
<p>이 식을 양자화하면, 각 행렬은 역양자화 수식 <span class="math math-inline">x = S(x_q - Z)</span>를 통해 부동소수점 값으로 변환된 후 연산된다.</p>
<p><span class="math math-display">
S_Y(Y_q - Z_Y) \approx \left( S_b(b_q - Z_b) \right) + \sum_{k} \left( S_X(X_{q,ik} - Z_X) \cdot S_W(W_{q,kj} - Z_W) \right)
</span><br />
이 식을 <span class="math math-inline">Y_q</span>에 대해 정리하면, 최종적인 양자화된 행렬 곱셈의 형태를 얻을 수 있다.</p>
<p><span class="math math-display">
Y_q \approx Z_Y + \frac{S_X S_W}{S_Y} \sum_{k} (X_{q,ik} - Z_X)(W_{q,kj} - Z_W) + \frac{S_b}{S_Y}(b_q - Z_b)
</span><br />
22</p>
<p>이 수식의 핵심은 복잡한 부동소수점 연산이 대부분 <strong>정수 곱셈과 덧셈</strong>으로 대체되었다는 점이다. <span class="math math-inline">(X_q - Z_X)(W_q - Z_W)</span> 항의 계산은 모두 정수 연산이다. 스케일 항(<span class="math math-inline">\frac{S_X S_W}{S_Y}</span> 등)은 부동소수점이지만, 이 값들은 행렬 전체 또는 채널별로 고정된 상수이므로, 대규모 누적합(accumulation) 연산이 끝난 후에 한 번만 적용하면 된다. Hexagon NPU의 HTA와 같은 하드웨어 가속기는 바로 이 정수 기반의 누적-곱셈(MAC) 연산을 병렬로 처리하는 데 극도로 특화되어 있다. 수천 개의 8비트 MAC 유닛이 동시에 이 연산을 수행함으로써, 부동소수점 연산 대비 압도적인 속도와 전력 효율을 달성하는 것이다.</p>
<p>결론적으로, 양자화는 단순히 모델을 압축하는 기술이 아니라, 딥러닝 모델의 연산 패러다임을 고비용의 부동소수점 연산에서 저비용의 정수 연산으로 전환하는 **하드웨어 활성화 기술(Hardware Enablement Technology)**이다. 양자화 없이는 Hexagon NPU와 같은 전문화된 AI 가속기의 진정한 잠재력을 이끌어낼 수 없으며, 온디바이스 AI의 고성능, 저전력 목표 달성은 불가능에 가깝다.</p>
<h2>5.  퀄컴 AI 엔진 성능 진화 및 벤치마크</h2>
<p>퀄컴 AI 엔진의 발전은 스냅드래곤 모바일 플랫폼의 세대교체와 함께 지속적인 성능 향상을 거듭해왔다. 이러한 성능을 정량적으로 평가하고 세대 간 발전을 비교하기 위해 TOPS와 같은 표준화된 지표가 사용되며, 실제 벤치마크 결과를 통해 그 진화 과정을 구체적으로 확인할 수 있다.</p>
<h3>5.1  성능 지표로서의 TOPS</h3>
<p><strong>TOPS(Trillions of Operations Per Second)의 정의:</strong> TOPS는 AI 가속기의 이론적인 최대 연산 처리 능력을 나타내는 핵심 지표이다. 1 TOPS는 1초에 1조 번의 연산을 수행할 수 있음을 의미한다.25 AI 연산에서 가장 기본이 되는 연산은 곱셈(multiplication)과 덧셈(accumulation)이 결합된 MAC(Multiply-Accumulate) 연산이므로, TOPS는 보통 이 MAC 연산을 기준으로 계산된다. MAC 연산 한 번은 곱셈과 덧셈, 즉 2개의 연산(operation)으로 간주된다. 따라서 TOPS는 다음과 같은 근사식으로 계산할 수 있다.26</p>
<p><span class="math math-display">
\text{TOPS} \approx \frac{2 \times (\text{Number of MAC units}) \times \text{Frequency (Hz)}}{10^{12}}
</span><br />
예를 들어, 1,000개의 MAC 유닛을 가진 칩이 1 GHz로 동작한다면 약 2 TOPS의 성능을 갖는다. 이 지표는 서로 다른 AI 칩의 순수 연산 능력을 직관적으로 비교하는 데 유용하다.</p>
<p><strong>최대 성능(Peak Performance)과 지속 성능(Sustained Performance)의 함의:</strong> 벤치마크나 제품 사양에 명시된 TOPS 수치는 대부분 <strong>최대 성능</strong>을 의미한다. 이는 모든 연산 유닛이 이상적인 조건 하에서 100% 가동될 때 달성할 수 있는 이론적인 최고치이다.26 그러나 실제 애플리케이션 환경에서는 이러한 이상적인 조건이 유지되기 어렵다. 실제 AI 추론 성능, 즉 <strong>지속 성능</strong>은 칩의 연산 능력뿐만 아니라 메모리 대역폭, 캐시 효율, 발열로 인한 스로틀링(throttling), 그리고 전력 공급 제한 등 다양한 시스템 수준의 요인에 의해 결정된다.26 따라서 높은 TOPS 수치가 항상 실제 애플리케이션의 우수한 성능으로 직결되는 것은 아니며, 시스템 전체의 균형 잡힌 설계가 뒷받침되어야 한다. 그럼에도 불구하고, TOPS는 AI 하드웨어의 기본적인 연산 잠재력을 가늠하는 중요한 출발점으로 기능한다.</p>
<h3>5.2  세대별 성능 분석</h3>
<p>퀄컴 AI 엔진은 매년 새로운 스냅드래곤 플래그십 플랫폼과 함께 괄목할 만한 성능 도약을 이루어왔다.</p>
<p><strong>Snapdragon 8 Gen 1 (7세대 AI 엔진):</strong> 4나노미터(nm) 공정을 기반으로 한 이 플랫폼은 7세대 AI 엔진을 탑재하며 온디바이스 AI 성능의 새로운 기준을 제시했다. 퀄컴은 이전 세대(Snapdragon 888) 대비 최대 4배의 AI 성능 향상을 주장했다.28 실제 벤치마크 결과는 이러한 주장을 뒷받침했다. AITuTu 벤치마크에서 Snapdragon 8 Gen 1은 이전 세대 플래그십 기기 대비 142% 이상 높은 점수를 기록하며, AI 연산 능력에서 압도적인 세대 간 도약을 이루었음을 입증했다.28 이는 AI가 카메라, 음성 비서 등 모바일 경험의 핵심 요소로 자리 잡기 시작한 시점에서 매우 중요한 성능적 기반이 되었다.</p>
<p><strong>Snapdragon 8 Gen 2 (HTP Gen 2):</strong> 이 세대에서는 두 가지 중요한 아키텍처 혁신이 이루어졌다. 첫째는 <strong>마이크로 타일 추론(Micro Tile Inferencing)</strong> 아키텍처의 도입이다. 이는 신경망을 더 작은 타일 단위로 분할하여 Hexagon 프로세서 내부의 여러 처리 유닛이 동시에 효율적으로 작업할 수 있도록 하는 기술로, 성능과 전력 효율을 동시에 개선했다.29 둘째는 모바일 플랫폼 최초로 <strong>INT4 정밀도</strong>를 하드웨어 수준에서 지원하기 시작했다는 점이다.30 INT4는 INT8 대비 이론적으로 2배의 성능 향상과 메모리 절감 효과를 가져올 수 있는 매우 공격적인 양자화 기법이다. 퀄컴은 INT4 지원을 통해 와트당 성능(performance per watt)을 60% 향상시켰다고 발표했다.30 이러한 혁신을 바탕으로 Snapdragon 8 Gen 2는 특정 AI 모델(MobileBERT)에서 이전 세대 대비 최대 4.35배 빠른 AI 성능을 달성했다.29 이는 향후 폭발적으로 증가할 생성형 AI 모델의 연산량을 감당하기 위한 선제적인 기술적 투자로 평가할 수 있다.</p>
<p><strong>Snapdragon 8 Gen 3 (HTP Gen 3):</strong> 이 플랫폼은 기획 단계부터 <strong>생성형 AI</strong>를 염두에 두고 설계된 최초의 모바일 칩셋이다.31 최대 100억 개의 파라미터를 가진 대규모 언어 모델(LLM)이나 언어 비전 모델(LVM)과 같은 멀티모달 생성형 AI 모델을 클라우드 연결 없이 온디바이스에서 직접 실행할 수 있는 능력을 갖췄다.32 이를 위해 Hexagon NPU의 성능은 이전 세대 대비 98% 향상되었고, 와트당 성능은 40% 개선되었다.11 이 칩은 70억 파라미터 규모의 Llama 2 모델을 초당 20 토큰(tokens/sec)의 속도로 실행할 수 있으며, 이미지 생성 모델인 Stable Diffusion을 1초 미만의 시간에 실행하는 놀라운 성능을 보여준다.32</p>
<p><strong>Snapdragon X Elite (HTP Gen 4):</strong> 퀄컴은 모바일에서의 성공을 바탕으로 AI 엔진을 PC 플랫폼으로 확장했다. Snapdragon X Elite에 탑재된 NPU는 노트북용 프로세서 중 가장 빠른 <strong>45 TOPS</strong>의 성능을 제공한다.25 이는 Microsoft가 차세대 AI PC인 ’Copilot+ PC’의 하드웨어 요구사항으로 제시한 40 TOPS를 상회하는 수치로, 퀄컴이 이 시장을 선도할 수 있는 기술적 우위를 점했음을 의미한다.25 모바일 환경에서 AI 엔진이 특정 기능을 ’가속’하는 역할을 주로 수행했다면, PC 환경에서는 운영체제 및 여러 애플리케이션의 AI 워크로드를 상시적으로 처리하는 ’주요 연산 유닛’으로 그 역할이 격상되었다. 강력한 NPU가 AI 작업을 전담함으로써 CPU와 GPU는 각자의 본연의 작업에 집중할 수 있게 되어, 전체 시스템의 반응성과 배터리 효율이 극대화된다.</p>
<p>이러한 세대별 진화 과정을 아래 표로 요약할 수 있다.</p>
<table><thead><tr><th><strong>항목</strong></th><th><strong>Snapdragon 8 Gen 1</strong></th><th><strong>Snapdragon 8 Gen 2</strong></th><th><strong>Snapdragon 8 Gen 3</strong></th><th><strong>Snapdragon X Elite</strong></th></tr></thead><tbody>
<tr><td><strong>AI 엔진 세대</strong></td><td>7th Gen</td><td>8th Gen</td><td>9th Gen</td><td>10th Gen</td></tr>
<tr><td><strong>NPU 아키텍처</strong></td><td>Hexagon (HTP Gen 1)</td><td>Hexagon (HTP Gen 2)</td><td>Hexagon (HTP Gen 3)</td><td>Hexagon (HTP Gen 4)</td></tr>
<tr><td><strong>주요 혁신 기술</strong></td><td>4nm 공정, 텐서 가속기 성능 2배 향상</td><td>마이크로 타일 추론, INT4 정밀도 지원</td><td>온디바이스 생성형 AI, 멀티모달 모델 지원</td><td>PC 플랫폼 확장, Copilot+ PC 지원</td></tr>
<tr><td><strong>최대 성능 (INT8 TOPS)</strong></td><td>N/A (성능 향상률로 발표)</td><td>26 TOPS 7</td><td>34 TOPS 7</td><td>45 TOPS 25</td></tr>
</tbody></table>
<p><em>표 1: Snapdragon AI Engine 세대별 성능 비교</em></p>
<h2>6.  경쟁 환경 분석: Apple 및 Google과의 비교</h2>
<p>온디바이스 AI 시장은 기술 발전의 최전선으로, 퀄컴 외에도 Apple과 Google과 같은 주요 기업들이 자체적인 AI 가속기 개발을 통해 치열한 경쟁을 벌이고 있다. 각 기업은 서로 다른 철학과 전략을 바탕으로 독자적인 하드웨어 및 소프트웨어 생태계를 구축하고 있다.</p>
<h3>6.1  Qualcomm AI Engine vs. Apple Neural Engine (ANE)</h3>
<p><strong>아키텍처 및 성능:</strong> Apple은 2017년 A11 Bionic 칩에 처음으로 Neural Engine(ANE)을 탑재하며 온디바이스 AI 가속기 시장을 개척했다. 최신 iPhone 15 Pro에 탑재된 A17 Pro 칩의 16코어 Neural Engine은 <strong>35 TOPS</strong>의 연산 성능을 제공한다.33 이는 Snapdragon 8 Gen 3에 탑재된 Hexagon NPU의 성능(34 INT8 TOPS)과 거의 동등한 수준으로 7, 두 회사가 모바일 AI 하드웨어 성능의 정점에서 기술적 우위를 차지하기 위해 치열하게 경쟁하고 있음을 보여준다. 성능 수치의 유사성은 두 기업 모두 최첨단 공정 기술과 정교한 아키텍처 설계를 통해 모바일 폼팩터에서 구현 가능한 물리적 한계에 근접하고 있음을 시사한다.</p>
<p><strong>생태계 및 전략:</strong> 두 기업의 가장 큰 차이점은 성능 수치가 아닌 생태계 전략에 있다. Apple은 하드웨어(A-시리즈, M-시리즈 칩)와 소프트웨어(iOS, macOS), 그리고 개발 프레임워크(Core ML)를 모두 직접 설계하고 통제하는 <strong>수직 통합(vertically integrated) 기반의 폐쇄형 생태계</strong>를 구축했다.34 개발자들은 Core ML이라는 단일화된 프레임워크를 통해 ANE의 성능을 활용하며, 이는 일관되고 안정적인 개발 경험을 제공한다. 하지만 이는 Apple의 생태계 내에서만 유효하다는 한계를 가진다. 반면, 퀄컴은 삼성, 샤오미, OnePlus 등 전 세계 수많은 OEM 제조사에 스냅드래곤 플랫폼을 공급하고, TensorFlow Lite, ONNX 등 다양한 표준 AI 프레임워크를 지원하는 <strong>개방형 생태계</strong> 전략을 추구한다.1 이러한 수평적 협력 모델은 안드로이드 및 윈도우 진영의 다양한 디바이스에 퀄컴 AI 엔진이 탑재될 수 있도록 하여 막대한 시장 점유율을 확보하는 기반이 된다. 결국, Apple은 완벽하게 통제된 환경에서 최적화된 사용자 경험의 질로 경쟁하는 반면, 퀄컴은 생태계의 폭과 유연성, 그리고 파트너사들이 혁신을 이룰 수 있는 강력한 플랫폼을 제공함으로써 경쟁 우위를 확보한다.</p>
<h3>6.2  Qualcomm AI Engine vs. Google Tensor Processing Unit (TPU)</h3>
<p><strong>온디바이스(Edge TPU) vs. 클라우드 TPU:</strong> Google의 TPU는 그 목적에 따라 두 가지로 나뉜다. 하나는 데이터센터에서 대규모 AI 모델을 훈련하고 서비스하기 위한 <strong>클라우드 TPU</strong>이고, 다른 하나는 Pixel 스마트폰과 같은 엣지 디바이스에 탑재되어 온디바이스 추론을 수행하는 <strong>Edge TPU</strong>이다.34 따라서 퀄컴 AI 엔진과의 직접적인 비교 대상은 Pixel 스마트폰에 내장된 Edge TPU이다. 최신 Pixel 8 시리즈에 탑재된 Tensor G3 칩에는 3세대 Edge TPU가 포함되어 있다.36</p>
<p><strong>소프트웨어-하드웨어 통합 전략:</strong> Google의 Tensor 칩 개발 전략은 퀄컴이나 Apple과는 근본적으로 다르다. Google의 최우선 목표는 자사의 AI 연구(TensorFlow, JAX)와 소프트웨어 서비스(Google 포토, 어시스턴트, 실시간 번역 등)를 위한 <strong>최적의 맞춤형 하드웨어</strong>를 만드는 것이다.36 즉, Tensor 칩과 Edge TPU는 범용 AI 가속 플랫폼이라기보다는, Google의 최첨단 AI 모델을 가장 효율적으로 실행하기 위해 공동 설계(co-design)된 <strong>1차 소비자(first-party) AI 가속기</strong>에 가깝다. 이 전략 덕분에 Pixel 스마트폰은 Night Sight(야간 사진), Magic Eraser(사진 일부 삭제), Motion Mode와 같이 소프트웨어와 하드웨어가 긴밀하게 결합된 독창적인 AI 기반 기능을 제공할 수 있다. 반면, 퀄컴 AI 엔진은 특정 서비스가 아닌, 광범위한 AI 애플리케이션을 가속할 수 있는 **수평적 플랫폼(horizontal platform)**을 지향한다. 퀄컴은 파트너사들이 자사의 하드웨어 위에서 각자의 혁신적인 AI 서비스를 자유롭게 구현할 수 있도록 강력한 범용 성능과 개발 도구를 제공하는 데 집중한다. 이러한 전략의 차이로 인해, Tensor 칩은 순수 CPU/GPU 벤치마크에서는 동시대의 스냅드래곤 칩에 뒤처지는 경향을 보이지만 37, Google이 정의한 특정 AI 작업에서는 뛰어난 효율성을 발휘한다.</p>
<p>각 사의 전략과 기술적 특징을 종합하면 아래 표와 같이 정리할 수 있다.</p>
<table><thead><tr><th><strong>항목</strong></th><th><strong>Qualcomm AI Engine (Snapdragon 8 Gen 3)</strong></th><th><strong>Apple Neural Engine (A17 Pro)</strong></th><th><strong>Google Edge TPU (Tensor G3)</strong></th></tr></thead><tbody>
<tr><td><strong>NPU 아키텍처</strong></td><td>Hexagon NPU with HTA (HTP Gen 3)</td><td>16-core Neural Engine</td><td>3rd Gen Edge TPU (“Rio”)</td></tr>
<tr><td><strong>최대 성능 (TOPS)</strong></td><td>34 (INT8) 7</td><td>35 33</td><td>N/A (비공개)</td></tr>
<tr><td><strong>제조 공정</strong></td><td>4nm (TSMC) 11</td><td>3nm (TSMC) 33</td><td>4nm (Samsung) 37</td></tr>
<tr><td><strong>CPU 구성</strong></td><td>1+5+2 (9-core) 11</td><td>2+4 (6-core) 33</td><td>1+4+4 (9-core) 36</td></tr>
<tr><td><strong>주요 SDK</strong></td><td>QNN, SNPE 13</td><td>Core ML 34</td><td>Android NNAPI, ML Kit 39</td></tr>
<tr><td><strong>대상 생태계</strong></td><td>개방형 (Android, Windows OEM)</td><td>폐쇄형 (Apple 자체 제품)</td><td>1차 소비자 (Google Pixel 제품군)</td></tr>
<tr><td><strong>핵심 차별점</strong></td><td>최고의 범용 성능, 생태계 확장성</td><td>하드웨어-소프트웨어 수직 통합</td><td>Google 서비스 맞춤형 AI/ML 최적화</td></tr>
</tbody></table>
<p><em>표 2: 주요 모바일 AI 프로세서 비교</em></p>
<h2>7.  주요 응용 사례 및 미래 전망</h2>
<p>퀄컴 AI 엔진의 강력한 성능과 정교한 소프트웨어 스택은 스마트폰을 비롯한 다양한 엣지 디바이스에서 이전에는 불가능했던 혁신적인 AI 경험을 현실로 만들고 있다. 특히 생성형 AI, 지능형 카메라, 상황 인식 기술은 퀄컴 AI 엔진이 만들어갈 미래를 엿볼 수 있는 대표적인 응용 분야이다.</p>
<h3>7.1  생성형 AI 및 멀티모달 기능</h3>
<p><strong>온디바이스 LLM 및 Stable Diffusion:</strong> 퀄컴 AI 엔진의 발전은 생성형 AI의 패러다임을 클라우드에서 디바이스로 전환하는 기폭제가 되었다. Snapdragon 8 Gen 3는 100억 개 이상의 파라미터를 가진 대규모 언어 모델(LLM)을 온디바이스에서 직접 실행할 수 있는 최초의 모바일 플랫폼이다.32 이는 사용자가 인터넷 연결 없이도 개인 비서와 자연스럽게 대화하고, 이메일 초안을 작성하며, 문서를 요약하는 등 복잡한 작업을 실시간으로 수행할 수 있음을 의미한다. Llama 2 (7B) 모델을 초당 20 토큰의 속도로 처리하는 능력은 클라우드 기반 서비스와 견주어도 손색없는 반응성을 제공한다.32 또한, 텍스트를 이미지로 변환하는 Stable Diffusion 모델을 1초 미만의 시간에 실행하여, 사용자가 즉석에서 아이디어를 시각화하고 소셜 미디어 콘텐츠를 생성할 수 있게 한다.15 이러한 온디바이스 생성형 AI는 지연 시간이 없고 개인 정보가 외부로 유출될 위험이 없다는 점에서 사용자에게 새로운 차원의 가치를 제공한다.</p>
<p><strong>멀티모달 AI 지원:</strong> 미래의 AI는 텍스트, 이미지, 음성, 센서 데이터 등 여러 종류의 정보를 동시에 이해하고 처리하는 <strong>멀티모달(multimodal)</strong> 형태로 발전할 것이다. Snapdragon 8 Gen 3는 이러한 멀티모달 생성형 AI 모델을 지원하도록 설계된 최초의 AI 엔진을 탑재했다.32 예를 들어, 사용자가 촬영한 사진을 보여주며 음성으로 “이 사진 속 배경을 해변으로 바꿔줘“라고 명령하면, AI는 이미지와 음성 명령을 함께 이해하여 원하는 결과물을 생성해낸다. 이는 더욱 직관적이고 인간과 유사한 상호작용을 가능하게 하여, AI 비서를 단순한 명령어 실행 도구가 아닌 진정한 창의적 파트너로 격상시키는 계기가 될 것이다.</p>
<h3>7.2  지능형 카메라 및 상황 인식</h3>
<p><strong>Cognitive ISP와 AI의 결합:</strong> 퀄컴은 자사의 이미지 신호 처리 장치(ISP)에 ’Cognitive ISP’라는 명칭을 부여하며, AI 엔진과의 깊은 통합을 강조하고 있다. 이 결합은 스마트폰 카메라를 단순한 이미지 기록 장치에서 ‘보고 이해하는’ 지능형 시스템으로 변모시킨다.</p>
<ul>
<li>
<p><strong>Semantic Segmentation:</strong> 이 기술은 AI를 사용하여 사진이나 비디오 프레임 내의 각 객체(예: 인물, 머리카락, 옷, 하늘, 배경)를 실시간으로 인식하고 최대 12개의 의미론적 레이어(semantic layer)로 분할한다.32 그리고 각 레이어에 가장 적합한 이미지 최적화(색감, 선명도, 노이즈 제거 등)를 개별적으로 적용한다. 그 결과, 전체 이미지에 단일 필터를 적용하는 기존 방식과는 차원이 다른 깊이 있고 생생한 결과물을 만들어낸다.</p>
</li>
<li>
<p><strong>Video Object Eraser:</strong> Arcsoft와의 협력을 통해 제공되는 이 기능은 촬영된 비디오에서 원치 않는 사람이나 사물을 손가락 터치 한 번으로 감쪽같이 제거한다.32 이는 복잡한 배경을 AI가 실시간으로 분석하고 빈 공간을 자연스럽게 채워 넣는 정교한 인페인팅(inpainting) 기술을 온디바이스에서 구현한 것이다.</p>
</li>
<li>
<p><strong>Zoom Anyplace:</strong> 삼성의 200MP 이미지 센서와 결합된 이 기능은 AI 기반 객체 추적 기술을 활용한다.32 사용자가 광각으로 전체 장면을 4K 비디오로 녹화하는 동시에, 특정 피사체를 지정하면 AI가 해당 피사체를 자동으로 추적하며 2배 또는 4배로 확대된 또 다른 4K 비디오를 동시에 생성한다. 이는 마치 두 대의 카메라로 촬영하는 듯한 효과를 제공한다.</p>
</li>
</ul>
<p><strong>Qualcomm Sensing Hub:</strong> AI는 사용자가 명시적으로 명령을 내릴 때만 작동하는 것이 아니라, 항상 켜져 있으면서 사용자의 상황과 환경을 이해하는 방향으로 진화하고 있다. 2세대 퀄컴 Sensing Hub는 이러한 **상황 인식(contextual awareness)**을 구현하는 핵심 요소이다.16 듀얼 AI 프로세서를 탑재한 이 허브는 5G, Wi-Fi, Bluetooth와 같은 연결성 데이터와 마이크, 가속도계 등 각종 센서 데이터를 초저전력으로 지속적으로 수집하고 분석한다. 예를 들어, Audio Analytic의 기술과 결합하여 주변의 소리 환경(예: 조용한 도서관, 시끄러운 거리)을 인식하고, 그에 맞춰 스마트폰의 벨소리나 알림 볼륨을 자동으로 조절해주는 지능형 경험을 제공할 수 있다.16 이는 AI가 사용자의 일상에 자연스럽게 녹아들어 불편함을 해소하고 편의를 증진시키는 ’앰비언트 인텔리전스(ambient intelligence)’의 시작을 보여준다.</p>
<h3>7.3  결론 및 향후 방향성</h3>
<p>지난 몇 년간 퀄컴 AI 엔진의 발전 과정은 온디바이스 AI 기술이 얼마나 빠르게 진화하고 있는지를 명확하게 보여주었다. 단순한 기능 가속기에서 시작하여, 이제는 수십억 개의 파라미터를 가진 생성형 AI 모델을 디바이스 내에서 직접 구동하는 수준에 이르렀다. 이는 퀄컴이 VLIW/SIMD 기반의 효율적인 Hexagon 아키텍처부터, INT4와 같은 공격적인 양자화 지원, 그리고 AIMET와 AI Hub와 같은 정교한 소프트웨어 도구에 이르기까지, 하드웨어와 소프트웨어 전반에 걸쳐 장기적인 비전을 가지고 일관되게 투자해 온 결과이다.</p>
<p>미래의 AI는 온디바이스와 클라우드 중 하나를 선택하는 양자택일의 문제가 아닐 것이다. 대신, 각자의 장점을 극대화하는 <strong>하이브리드 AI(Hybrid AI)</strong> 형태로 발전할 것이 자명하다.4 온디바이스 AI는 빠른 응답 속도, 강력한 개인정보보호, 그리고 개인화된 경험을 제공하고, 클라우드 AI는 방대한 데이터를 활용한 모델 재훈련과 온디바이스에서는 실행하기 어려운 초거대 모델의 연산을 담당하게 될 것이다. 이 두 세계를 매끄럽게 연결하고, 워크로드를 상황에 맞게 최적으로 분배하는 것이 미래 AI 플랫폼의 핵심 경쟁력이 될 것이다.</p>
<p>이러한 하이브리드 AI 시대에 퀄컴은 독보적인 위치를 점하고 있다. 업계 최고 수준의 온디바이스 AI 추론 성능과 전력 효율, 그리고 안드로이드와 윈도우를 아우르는 개방적이고 광범위한 생태계는 퀄컴이 하이브리드 AI의 핵심인 엣지(edge) 단을 장악할 수 있는 강력한 기반이다. 앞으로 퀄컴의 과제는 지속적인 NPU 성능 향상을 통해 온디바이스에서 처리할 수 있는 모델의 규모와 복잡성을 계속해서 확장하고, QNN과 SNPE 같은 소프트웨어 스택을 더욱 고도화하여 개발자들이 하이브리드 AI 애플리케이션을 손쉽게 개발할 수 있도록 지원하며, AI Hub를 중심으로 한 개발자 생태계를 더욱 활성화하는 것이 될 것이다. 이러한 노력이 성공적으로 이어진다면, 퀄컴 AI 엔진은 차세대 지능형 디바이스 시대를 여는 핵심 동력으로 자리매김할 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>Qualcomm Artificial Intelligence Engine Powers AI Capabilities of Snapdragon Mobile Platform, https://investor.qualcomm.com/news-events/press-releases/news-details/2018/Qualcomm-Artificial-Intelligence-Engine-Powers-AI-Capabilities-of-Snapdragon-Mobile-Platform-02-21-2018/default.aspx</li>
<li>Qualcomm Artificial Intelligence Engine Powers AI Capabilities of Snapdragon Mobile Platform - PR Newswire, https://www.prnewswire.com/news-releases/qualcomm-artificial-intelligence-engine-powers-ai-capabilities-of-snapdragon-mobile-platform-300601736.html</li>
<li>Unlocking on-device generative AI with an NPU and … - Qualcomm, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/Unlocking-on-device-generative-AI-with-an-NPU-and-heterogeneous-computing.pdf</li>
<li>The future of AI is hybrid - Qualcomm, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/Whitepaper-The-future-of-AI-is-hybrid-Part-2-Qualcomm-is-uniquely-positioned-to-scale-hybrid-AI.pdf</li>
<li>Qualcomm Introduces New Snapdragon 700 Mobile Platform Series, https://investor.qualcomm.com/news-events/press-releases/news-details/2018/Qualcomm-Introduces-New-Snapdragon-700-Mobile-Platform-Series-02-27-2018/default.aspx</li>
<li>Qualcomm AI Products | Intuitive AI Technology, https://www.qualcomm.com/products/technology/artificial-intelligence</li>
<li>Qualcomm Hexagon - Wikipedia, https://en.wikipedia.org/wiki/Qualcomm_Hexagon</li>
<li>Qualcomm Linux AI/ML Developer Workflow, https://docs.qualcomm.com/bundle/publicresource/topics/80-70017-15B/overview.html</li>
<li>AI Developer Workflow, https://docs.qualcomm.com/bundle/publicresource/topics/80-70020-15B/ai-ml-developer-workflow.html</li>
<li>QUALCOMM(R) QCS410/QCS610 PRODUCT BRIEF, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/87-PN006-1.pdf</li>
<li>Qualcomm Snapdragon 8 Gen 3 review: I finally don’t feel the need to upgrade, https://www.xda-developers.com/qualcomm-snapdragon-8-gen-3-review/</li>
<li>Qualcomm Neural Processing SDK | Qualcomm Developer, https://www.qualcomm.com/developer/software/neural-processing-sdk-for-ai</li>
<li>What are the differences between the AI engine direct SDK, the …, https://mysupport.qualcomm.com/supportforums/s/question/0D5dK000002smEmSAI/what-are-the-differences-between-the-ai-engine-direct-sdk-the-neural-processing-sdk-and-the-hexagon-npu-sdk</li>
<li>Overview - Qualcomm AI Engine Direct SDK, https://docs.qualcomm.com/bundle/publicresource/topics/80-63442-50/overview.html</li>
<li>AI on the Edge: Run Local LLMs with ONNX and Qualcomm Technologies | by James Fahey, https://medium.com/@fahey_james/ai-on-the-edge-run-local-llms-with-onnx-and-qualcomm-technologies-ced86242462d</li>
<li>Exploring the AI capabilities of the Snapdragon 888 Mobile Platform - Qualcomm, https://www.qualcomm.com/media/documents/files/snapdragon-888-ai-blog-post-by-jeff-gehlhaar-vp-of-technology-hsin-i-hsu-senior-product-manager.pdf</li>
<li>Qualcomm AI Hub, https://aihub.qualcomm.com/</li>
<li>AI from deep cloud to far-edge: A flawless end-to-end experience - IBM Research, https://research.ibm.com/blog/ibm-qualcomm-cloud-edge-ai</li>
<li>Quantization - Hugging Face, https://huggingface.co/docs/optimum/concept_guides/quantization</li>
<li>A Comprehensive Study on Quantization Techniques for Large Language Models - arXiv, https://arxiv.org/html/2411.02530v1</li>
<li>Quantization - Neural Network Distiller - Intel Labs, https://intellabs.github.io/distiller/algo_quantization.html</li>
<li>Quantization for Neural Networks - Lei Mao’s Log Book, https://leimao.github.io/article/Neural-Networks-Quantization/</li>
<li>leimao.github.io, <a href="https://leimao.github.io/article/Neural-Networks-Quantization/#:~:text=Quantized%20Matrix%20Multiplication%20Mathematics,%E2%88%88%20R%20m%20%C3%97%20n%20.&amp;text=We%20would%20need%20to%20do,compute%20one%20single%20entry%20in%20.">https://leimao.github.io/article/Neural-Networks-Quantization/#:~:text=Quantized%20Matrix%20Multiplication%20Mathematics,%E2%88%88%20R%20m%20%C3%97%20n%20.&amp;text=We%20would%20need%20to%20do,compute%20one%20single%20entry%20in%20.</a></li>
<li>DML_QUANTIZED_LINEAR_MA… - Microsoft Learn, https://learn.microsoft.com/en-us/windows/win32/api/directml/ns-directml-dml_quantized_linear_matrix_multiply_operator_desc</li>
<li>What TOPS MEANS | Qualcomm, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/What-TOPS-Means-Snapdragon-X-Series.pdf</li>
<li>TOPS as a Hardware Performance Metric for AI: Evaluating HP ZGX Systems, https://community.datascience.hp.com/compute-63/tops-as-a-hardware-performance-metric-for-ai-evaluating-hp-zgx-systems-402</li>
<li>A guide to AI TOPS and NPU performance metrics - Qualcomm, https://www.qualcomm.com/news/onq/2024/04/a-guide-to-ai-tops-and-npu-performance-metrics</li>
<li>Snapdragon 8 Gen 1 Benchmarks: Huge AI And Gaming Gains For …, https://hothardware.com/reviews/snapdragon-8-gen-1-performance-benchmarks</li>
<li>Innovating on AI with Snapdragon 8 Gen 2: A Snapdragon Summit Tech Talk - YouTube, https://www.youtube.com/watch?v=vMFJsbBoqk8</li>
<li>SNAPDRAGON® 8 GEN 2 MOBILE PLATFORM - Qualcomm, https://www.qualcomm.com/content/dam/qcomm-martech/dm-assets/documents/Snapdragon-8-Gen-2-Product-Brief.pdf</li>
<li>Snapdragon 8 Gen 3 Mobile Platform - Qualcomm AI Engine - CES, https://www.ces.tech/ces-innovation-awards/2024/snapdragon-8-gen-3-mobile-platform-qualcomm-ai-engine/</li>
<li>SNAPDRAGON® 8 GEN 3 MOBILE PLATFORM, https://docs.qualcomm.com/bundle/publicresource/87-71408-1_REV_C_Snapdragon_8_gen_3_Mobile_Platform_Product_Brief.pdf</li>
<li>Apple A17 - Wikipedia, https://en.wikipedia.org/wiki/Apple_A17</li>
<li>Apple Neural Engine vs. Google TPU vs. NVIDIA Tensor Cores - Pynomial, https://pynomial.com/2025/03/apple-neural-engine-vs-google-tpu-vs-nvidia-tensor-cores/</li>
<li>Tensor Processing Unit - Wikipedia, https://en.wikipedia.org/wiki/Tensor_Processing_Unit</li>
<li>Google Tensor - Wikipedia, https://en.wikipedia.org/wiki/Google_Tensor</li>
<li>Google Tensor G3 Processor - Benchmarks and Specs - NotebookCheck.net Tech, https://www.notebookcheck.net/Google-Tensor-G3-Processor-Benchmarks-and-Specs.762527.0.html</li>
<li>Google Tensor vs Apple A15 and Others | Tech Journeyman, https://techjourneyman.com/blog/google-tensor-vs-apple-a15-and-others/</li>
<li>[D] What is the difference between the TPU found in Google Tensor chips vs the Neural Engine found in Apple’s A and M series? : r/MachineLearning - Reddit, https://www.reddit.com/r/MachineLearning/comments/16jjx4m/d_what_is_the_difference_between_the_tpu_found_in/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>