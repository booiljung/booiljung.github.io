<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:NVIDIA Jetson AGX Orin 64GB 성능 벤치마크 방법론</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>NVIDIA Jetson AGX Orin 64GB 성능 벤치마크 방법론</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">컴퓨터 (Computers)</a> / <a href="../../index.html">NVIDIA 제품</a> / <a href="../index.html">NVIDIA Orin</a> / <a href="index.html">NVIDIA Jetson Orin</a> / <span>NVIDIA Jetson AGX Orin 64GB 성능 벤치마크 방법론</span></nav>
                </div>
            </header>
            <article>
                <h1>NVIDIA Jetson AGX Orin 64GB 성능 벤치마크 방법론</h1>
<h2>1. 서론</h2>
<h3>1.1 목적 및 범위</h3>
<p>본 보고서는 NVIDIA Jetson AGX Orin 64GB 모듈의 성능을 체계적이고 재현 가능하게 평가하기 위한 포괄적인 벤치마킹 방법론을 제시하는 것을 목적으로 한다. Jetson AGX Orin은 엣지 컴퓨팅 환경에서 전례 없는 수준의 AI 연산 능력을 제공하는 플랫폼으로, 그 잠재력을 최대한 활용하기 위해서는 성능 특성에 대한 깊이 있는 이해가 필수적이다. 본 보고서의 범위는 CPU, GPU, 메모리, 스토리지 및 AI 추론 가속기(GPU Tensor Core, DLA)에 이르는 모든 핵심 서브시스템을 포함한다. 각 구성 요소의 개별 성능을 정밀하게 측정하고, 이들이 결합하여 전체 시스템 성능에 어떻게 기여하는지를 분석하는 절차를 상세히 기술할 것이다. 이를 통해 개발자와 시스템 통합자는 실제 애플리케이션 개발 및 최적화 과정에 필수적인 실증적 데이터를 확보할 수 있을 것이다.1</p>
<h3>1.2 Jetson AGX Orin의 의의</h3>
<p>NVIDIA Jetson AGX Orin은 임베디드 AI 컴퓨팅의 패러다임을 바꾸는 혁신적인 플랫폼이다. 이전 세대인 Jetson AGX Xavier와 동일한 폼팩터와 핀 호환성을 유지하면서도, 최대 275 TOPS(Tera Operations Per Second)에 달하는 AI 성능을 제공한다. 이는 Xavier 대비 최대 8배에 달하는 이론적 성능 향상이며, 엣지 디바이스에서 이전에는 불가능했던 서버급 대규모 AI 모델의 구동을 현실화한다.3 자율 로봇, 지능형 비디오 분석, 의료 영상 진단 등 복잡하고 까다로운 AI 워크로드를 실시간으로 처리할 수 있는 능력을 갖춤으로써, 진정한 의미의 소프트웨어 정의(Software-Defined) 자율 기계 시대를 열고 있다. 본 보고서에서 제시하는 벤치마크 방법론은 이러한 경이적인 성능 도약의 실체를 정량적으로 분석하고, 개발자가 플랫폼의 잠재력을 최대한 활용하여 차세대 AI 솔루션을 구축할 수 있는 견고한 기술적 기반을 제공하는 데 그 의의가 있다.</p>
<h2>2.  기초 분석: 아키텍처 및 시스템 준비</h2>
<p>성능 벤치마크의 신뢰성은 대상 시스템의 아키텍처에 대한 정확한 이해와 일관된 테스트 환경 구축에서 시작된다. 이 장에서는 Jetson AGX Orin 64GB의 핵심 아키텍처를 심층 분석하고, 재현 가능한 결과를 얻기 위한 필수적인 시스템 준비 과정을 다룬다.</p>
<h3>2.1  Jetson AGX Orin 64GB 아키텍처 심층 분석</h3>
<p>Jetson AGX Orin의 성능은 이전 세대를 압도하는 최신 아키텍처 구성 요소들의 유기적인 결합에 기인한다. 각 서브시스템의 특징을 이해하는 것은 벤치마크 결과를 올바르게 해석하는 데 필수적이다.</p>
<h4>2.1.1 NVIDIA Ampere 아키텍처 GPU</h4>
<p>Orin의 심장부에는 서버 및 데이터센터용 GPU에 사용되는 NVIDIA Ampere 아키텍처가 탑재되어 있다. 64GB 모델은 2개의 그래픽 처리 클러스터(GPC), 8개의 텍스처 처리 클러스터(TPC), 16개의 스트리밍 멀티프로세서(SM)로 구성된다.6 이를 통해 총 2048개의 CUDA 코어와 64개의 3세대 Tensor 코어를 제공한다.8 특히 3세대 Tensor 코어는 구조적 희소성(Structured Sparsity)을 지원하는 것이 핵심적인 특징이다. 이는 딥러닝 모델의 가중치에서 불필요한 부분을 제거하여 연산량을 줄이는 기술로, 이론적으로 INT8 정밀도에서의 처리량을 두 배로 향상시켜 최대 275 TOPS(Sparse)의 AI 성능을 달성하게 한다. 이는 희소성을 지원하지 않는 Xavier의 Volta 아키텍처와의 근본적인 차이점이며, Orin의 폭발적인 AI 성능 향상의 핵심 동력이다.5</p>
<h4>2.1.2 Arm Cortex-A78AE CPU 클러스터</h4>
<p>CPU는 12개의 고성능 Arm Cortex-A78AE v8.2 64비트 코어로 구성되어 있으며, 최대 2.2 GHz로 동작한다.6 이 코어들은 4개씩 3개의 클러스터로 나뉘어 있으며, 각 클러스터는 2MB의 L3 캐시를 공유한다. 또한 각 코어는 256KB의 L2 캐시를 독립적으로 가진다.7 이 구성은 이전 세대인 Xavier의 8코어 NVIDIA Carmel CPU 대비 약 1.7배의 순수 연산 성능 향상을 제공하며, AI 파이프라인의 데이터 전처리 및 후처리, 시스템 제어 등 GPU가 담당하지 않는 연산을 효율적으로 처리한다.4</p>
<h4>2.1.3 메모리 및 스토리지 계층 구조</h4>
<p>Orin은 256비트 버스 폭의 64GB LPDDR5 메모리를 탑재하여 최대 204.8 GB/s의 압도적인 메모리 대역폭을 제공한다.9 이는 LPDDR4x를 사용했던 Xavier의 137 GB/s 대비 약 1.5배 향상된 수치로, 거대한 Ampere GPU가 데이터 병목 현상 없이 원활하게 동작할 수 있도록 지원하는 핵심 요소다.4 대규모 AI 모델의 가중치와 대용량 센서 데이터를 메모리에 상주시키기에 충분한 용량과 속도를 제공한다. 기본 저장 장치로는 64GB eMMC 5.1이 내장되어 있으며, M.2 Key M 슬롯을 통해 고속 NVMe SSD를 추가 확장할 수 있다.12</p>
<h4>2.1.4 전용 가속기 (Dedicated Accelerators)</h4>
<p>Orin은 GPU 외에도 특정 작업을 위한 전용 하드웨어 가속기를 탑재하여 시스템 전체의 효율성을 극대화한다. 2개의 NVDLA v2.0(NVIDIA Deep Learning Accelerator) 엔진은 컨볼루션 신경망(CNN) 추론에 특화되어 GPU보다 월등한 전력 효율성을 보인다.6 또한, 1개의 PVA v2.0(Programmable Vision Accelerator)은 특징점 검출, 스테레오 깊이 추정 등 전통적인 컴퓨터 비전 알고리즘을 가속하여 GPU의 부담을 덜어준다.6 이러한 가속기들은 AI 및 비전 워크로드를 GPU로부터 오프로드하여, GPU가 더 복잡한 연산에 집중할 수 있도록 하고 시스템 전체의 전력 소모를 최적화하는 역할을 수행한다.14</p>
<p>아래 표는 Jetson AGX Orin 64GB와 이전 세대인 Jetson AGX Xavier의 핵심 사양을 비교하여 아키텍처의 발전을 한눈에 보여준다.</p>
<p><strong>표 1: Jetson AGX Orin 64GB vs. Jetson AGX Xavier - 핵심 사양 비교</strong></p>
<table><thead><tr><th>사양</th><th>Jetson AGX Orin 64GB</th><th>Jetson AGX Xavier</th></tr></thead><tbody>
<tr><td><strong>AI 성능</strong></td><td>275 TOPS (INT8 Sparse)</td><td>32 TOPS (INT8 Dense)</td></tr>
<tr><td><strong>GPU 아키텍처</strong></td><td>NVIDIA Ampere</td><td>NVIDIA Volta</td></tr>
<tr><td><strong>CUDA 코어</strong></td><td>2048</td><td>512</td></tr>
<tr><td><strong>Tensor 코어</strong></td><td>64 (3세대)</td><td>64 (1세대)</td></tr>
<tr><td><strong>GPU 최대 주파수</strong></td><td>1.3 GHz</td><td>1.37 GHz</td></tr>
<tr><td><strong>CPU 아키텍처</strong></td><td>12코어 Arm Cortex-A78AE v8.2</td><td>8코어 NVIDIA Carmel v8.2</td></tr>
<tr><td><strong>CPU 최대 주파수</strong></td><td>2.2 GHz</td><td>2.26 GHz</td></tr>
<tr><td><strong>메모리</strong></td><td>64GB 256-bit LPDDR5</td><td>32GB/64GB 256-bit LPDDR4x</td></tr>
<tr><td><strong>메모리 대역폭</strong></td><td>204.8 GB/s</td><td>137 GB/s</td></tr>
<tr><td><strong>스토리지</strong></td><td>64GB eMMC 5.1</td><td>32GB eMMC 5.1</td></tr>
<tr><td><strong>DL 가속기 (DLA)</strong></td><td>2x NVDLA v2.0</td><td>2x NVDLA v1.0</td></tr>
<tr><td><strong>비전 가속기 (PVA)</strong></td><td>PVA v2.0</td><td>7-way VLIW Vision Processor</td></tr>
<tr><td><strong>전력 소모</strong></td><td>15W - 60W</td><td>10W - 30W</td></tr>
</tbody></table>
<p>자료 출처: 3</p>
<p>이러한 아키텍처의 발전은 단순히 개별 부품의 성능 향상을 넘어선다. 예를 들어, Ampere GPU의 도입은 8배의 이론적 AI 성능 향상을 가져왔지만, 이는 희소성(Sparsity)이라는 소프트웨어 최적화가 동반될 때 완전히 실현된다. 희소성을 지원하지 않는 일반적인 딥러닝 모델(Dense model)을 실행할 경우, 실제 벤치마크에서는 약 3배에서 5배 사이의 성능 향상을 보인다.16 이는 하드웨어의 잠재력이 소프트웨어 스택과 모델 최적화 수준에 의해 결정된다는 중요한 사실을 시사한다. 즉, Orin의 성능을 제대로 평가하기 위해서는 하드웨어 사양뿐만 아니라, 테스트에 사용된 소프트웨어 환경까지 명확히 규정해야 한다.</p>
<h3>2.2  벤치마크 환경 구축</h3>
<p>일관되고 신뢰성 있는 벤치마크 결과를 얻기 위해서는 모든 테스트의 기반이 되는 소프트웨어 환경을 엄격하게 통제하고 표준화해야 한다.</p>
<h4>2.2.1 NVIDIA JetPack 설치 및 검증</h4>
<p>NVIDIA JetPack SDK는 Jetson 플랫폼을 위한 공식 소프트웨어 스택으로, 운영체제, 드라이버, CUDA 툴킷, TensorRT, cuDNN 등 성능에 직접적인 영향을 미치는 모든 핵심 라이브러리를 포함한다.18 따라서 모든 벤치마크는 최신 안정화 버전의 JetPack(예: JetPack 6.2)을 기반으로 수행해야 한다. JetPack 6.2는 Linux Kernel 5.15, Ubuntu 22.04를 기반으로 하며, CUDA 12.x, TensorRT 10.x, cuDNN 9.x와 같은 최신 버전의 라이브러리를 포함하여 Orin의 하드웨어 성능을 최대한 이끌어낸다.20 설치 후에는 터미널에서</p>
<p><code>cat /etc/nv_tegra_release</code> 명령어를 실행하여 설치된 Jetson Linux(L4T) 버전을 명확히 확인하고 기록해야 한다. 이는 벤치마크 결과의 재현성을 보장하는 첫걸음이다.22</p>
<h4>2.2.2 펌웨어 및 시스템 업데이트</h4>
<p>JetPack 설치 직후, 시스템에 내장된 모든 소프트웨어 패키지를 최신 상태로 업데이트하는 것이 필수적이다. 터미널에서 다음 명령어를 실행하여 이 과정을 수행한다:</p>
<pre><code>sudo apt update &amp;&amp; sudo apt upgrade
</code></pre>
<p>이 과정은 잠재적인 소프트웨어 버그나 비효율성을 제거하여, 시스템 외부 요인으로 인한 성능 변동을 최소화하고 순수한 하드웨어 성능을 측정할 수 있는 안정적인 기반을 마련한다.23</p>
<h4>2.2.3 초기 설정 (Initial Setup)</h4>
<p>특히 공장에서 출고된 지 오래된 개발자 키트의 경우, 내장된 QSPI-NOR 플래시 메모리의 펌웨어 버전이 낮아 최신 JetPack 이미지로 직접 부팅되지 않는 문제가 발생할 수 있다. 이 경우, 중간 버전의 JetPack(예: JetPack 5.1.3)이 담긴 SD 카드나 이미지를 사용하여 먼저 부팅한 후, 펌웨어 업데이트를 수행하고, 그 다음에 목표로 하는 최신 JetPack(예: 6.2)을 설치하는 다단계 절차가 필요할 수 있다. 이 과정은 공식 문서를 통해 사전에 확인하고 진행해야 한다.23</p>
<h3>2.3  전력 모드 및 열 관리 구성</h3>
<p>Jetson AGX Orin의 성능은 전력 소모 및 발열과 밀접한 관계를 맺고 있다. 따라서 벤치마크 시나리오에 맞는 전력 모드를 설정하고, 발열로 인한 성능 저하(스로틀링)를 방지하는 것은 매우 중요하다.</p>
<h4>2.3.1 <code>nvpmodel</code>을 이용한 전력 모드 제어</h4>
<p>NVIDIA는 <code>nvpmodel</code>이라는 유틸리티를 통해 사전 정의된 여러 전력 프로파일을 제공한다. AGX Orin 64GB 모듈은 15W, 30W, 50W, 60W 등 다양한 전력 제한 모드와, 전력 제한을 해제하고 최대 성능을 추구하는 MAXN 모드를 지원한다.25 각 모드는 CPU/GPU 코어 활성화 수와 최대 클럭 주파수를 다르게 설정하여 성능과 전력 효율성 간의 균형을 조절한다. 벤치마크 목적에 따라 적절한 모드를 선택해야 한다. 예를 들어, 최대 성능을 측정하고자 할 때는 MAXN 모드를, 특정 전력 제약 하에서의 성능을 평가하고자 할 때는 해당 와트(W) 모드를 사용해야 한다. 전력 모드는 다음 명령어로 설정하고 확인할 수 있다.</p>
<ul>
<li>
<p>모드 설정: <code>sudo nvpmodel -m &lt;모드 ID&gt;</code> (예: MAXN 모드는 <code>sudo nvpmodel -m 0</code>)</p>
</li>
<li>
<p>현재 모드 확인: <code>sudo nvpmodel -q</code></p>
</li>
</ul>
<p>설정된 모드는 재부팅 후에도 유지된다.27</p>
<h4>2.3.2 <code>jetson_clocks</code>를 이용한 최대 클럭 고정</h4>
<p>nvpmodel로 전력 모드를 설정하더라도, 시스템은 부하에 따라 동적으로 CPU, GPU, 메모리 컨트롤러(EMC)의 클럭 주파수를 조절하는 DVFS(Dynamic Voltage and Frequency Scaling) 기능을 사용한다. 이는 벤치마크 실행 시 성능 변동을 유발하여 결과의 일관성을 해칠 수 있다. jetson_clocks 스크립트는 이러한 DVFS를 비활성화하고, 현재 nvpmodel에서 허용하는 최대 클럭으로 모든 주요 부품을 고정시키는 역할을 한다. 따라서 일관되고 재현 가능한 최고 성능을 측정하기 위해서는 벤치마크 실행 전에 반드시 다음 명령어를 실행해야 한다.</p>
<pre><code>sudo jetson_clocks
</code></pre>
<p>이 설정은 재부팅 시 초기화되므로, 매 테스트 세션마다 다시 실행해야 한다.28</p>
<h4>2.3.3 열 관리의 중요성 (The Critical Role of Thermal Management)</h4>
<p>MAXN 모드나 JetPack 6.2에서 도입된 ’Super Mode’와 같은 고성능 모드는 상당한 전력을 소모하며, 이는 필연적으로 많은 열을 발생시킨다.20 개발자 키트에 포함된 액티브 쿨링 솔루션(팬과 방열판)은 이러한 발열을 효과적으로 제어하도록 설계되었지만, 통풍이 원활하지 않은 밀폐된 환경이나 고온의 주변 환경에서는 열이 누적될 수 있다. 온도가 임계치를 초과하면 시스템은 하드웨어 손상을 방지하기 위해 강제로 클럭 속도를 낮추는 열 스로틀링(thermal throttling) 현상을 발생시킨다.32 스로틀링이 발생하면 벤치마크 결과는 하드웨어의 실제 최대 성능을 반영하지 못하므로, 테스트의 신뢰성이 심각하게 훼손된다. 따라서 벤치마크를 수행하는 동안 실시간 모니터링 도구를 사용하여 온도를 지속적으로 확인하고, 시스템이 안정적인 온도 범위 내에서 동작하는지 반드시 검증해야 한다.34</p>
<p>이처럼 Jetson 플랫폼의 성능은 하드웨어 자체뿐만 아니라 소프트웨어 스택과 운영 설정에 따라 크게 좌우된다. 특히 JetPack 6.2에서 Orin Nano 및 NX 모델을 위해 도입된 ’Super Mode’는 단순히 소프트웨어 업데이트를 넘어, 더 높은 전력(예: Orin NX 40W)을 허용하여 하드웨어의 성능 한계를 재정의한다.20 이는 동일한 하드웨어라도 어떤 버전의 JetPack을 사용하느냐에 따라 성능이 최대 2배까지 차이 날 수 있음을 의미한다.20 따라서 모든 벤치마크 결과는 반드시 테스트에 사용된 JetPack 버전과 전력 모드(<code>nvpmodel</code>, <code>jetson_clocks</code> 상태 포함)를 함께 명시해야만 그 의미를 정확히 전달할 수 있다.</p>
<h2>3.  실시간 시스템 모니터링 및 진단</h2>
<p>벤치마크를 실행하는 동안 시스템의 내부 상태를 실시간으로 파악하는 것은 테스트의 유효성을 검증하고 결과를 심층적으로 분석하는 데 필수적이다. NVIDIA는 이를 위해 강력한 커맨드 라인 도구와 시각적 유틸리티를 제공한다.</p>
<h3>3.1  <code>tegrastats</code>를 활용한 세부 모니터링</h3>
<p><code>tegrastats</code>는 Jetson 플랫폼에 기본적으로 내장된 강력한 모니터링 도구로, 시스템의 핵심 하드웨어 지표를 텍스트 기반으로 실시간 출력한다.36 벤치마크 실행 중 별도의 터미널 창에서 이 도구를 실행하여 시스템이 의도한 대로 최대 성능을 내고 있는지, 혹은 열 스로틀링과 같은 이상 현상이 발생하는지를 지속적으로 감시해야 한다.</p>
<h4>3.1.1 기본 사용법</h4>
<p>tegrastats는 루트 권한으로 실행해야 하며, –interval 옵션을 통해 데이터 갱신 주기를 밀리초(ms) 단위로 지정할 수 있다. 예를 들어, 0.5초(500ms)마다 시스템 상태를 확인하려면 다음 명령어를 사용한다:</p>
<pre><code>sudo tegrastats --interval 500
</code></pre>
<p>이 명령을 실행하면 터미널에 주기적으로 한 줄의 상태 정보가 출력된다. 이 정보를 통해 벤치마크 부하가 각 하드웨어 구성 요소에 어떻게 분배되는지, 그리고 온도가 안정적으로 유지되는지 확인할 수 있다.36</p>
<h4>3.1.2 출력 해석</h4>
<p><code>tegrastats</code>의 출력은 압축된 형태의 많은 정보를 담고 있으므로, 각 항목의 의미를 정확히 이해하는 것이 중요하다. 아래 표는 주요 출력 항목과 그에 대한 해석을 정리한 것이다.</p>
<p><strong>표 2: <code>tegrastats</code> 출력 해석</strong></p>
<table><thead><tr><th>메트릭 (예시)</th><th>설명</th></tr></thead><tbody>
<tr><td><code>RAM 5059/61343MB (lfb 5843x4MB)</code></td><td>현재 5059MB의 RAM이 사용 중이며, 총 RAM은 61343MB이다.</td></tr>
<tr><td><code>SWAP 0/30671MB (cached 0MB)</code></td><td>스왑 메모리는 사용되지 않고 있다.</td></tr>
<tr><td><code>CPU [15%@735, 8%@735,...]</code></td><td>각 CPU 코어의 부하율(%)과 현재 동작 주파수(MHz)를 보여준다. 12개 코어의 상태가 순서대로 표시된다.</td></tr>
<tr><td><code>EMC_FREQ 5%@3199</code></td><td>외부 메모리 컨트롤러(EMC)의 대역폭 사용률이 5%이며, 3199MHz로 동작 중이다. LPDDR5 메모리의 동작 속도를 나타낸다.</td></tr>
<tr><td><code>GR3D_FREQ 99%@1300</code></td><td>GPU의 부하율이 99%이며, 1300MHz로 동작 중이다. GPU가 최대 성능으로 작동하고 있음을 의미한다.</td></tr>
<tr><td><code>NVENC 115, NVDEC 998</code></td><td>비디오 인코더(NVENC)와 디코더(NVDEC) 엔진의 동작 주파수(MHz)를 보여준다.</td></tr>
<tr><td><code>DLA0 1600, DLA1 1600</code></td><td>2개의 딥러닝 가속기(DLA) 엔진의 동작 주파수(MHz)를 보여준다.</td></tr>
<tr><td><code>PVA0_VPS 1152</code></td><td>비전 가속기(PVA)의 동작 주파수(MHz)를 보여준다.</td></tr>
<tr><td><code>CPU@53.5C, GPU@48.4C, SOC2@51.0C</code></td><td>CPU, GPU 등 주요 칩의 온도를 섭씨(°C) 단위로 보여준다. 이 온도가 임계치를 넘지 않는지 주시해야 한다.</td></tr>
<tr><td><code>VDD_GPU_SOC 7968/7969, VDD_CPU_CV 4589/4591</code></td><td>각 전력 레일의 현재/평균 전력 소모량(mW)을 보여준다. 시스템의 총 전력 소모를 추정하는 데 사용된다.</td></tr>
</tbody></table>
<p>자료 출처: 36</p>
<p>이러한 모니터링 도구는 단순히 상태를 보여주는 것을 넘어, 벤치마크의 유효성을 검증하는 핵심적인 역할을 한다. 예를 들어, 1장에서 <code>jetson_clocks</code>를 실행하여 GPU 클럭을 1300MHz로 고정했음에도 불구하고, <code>tegrastats</code>의 <code>GR3D_FREQ</code> 항목이 1300MHz보다 낮은 값으로 계속 떨어진다면, 이는 온도가 너무 높아 시스템이 강제로 성능을 낮추는 열 스로틀링이 발생하고 있음을 의미한다. 이 경우, 해당 벤치마크 결과는 신뢰할 수 없으며, 냉각 환경을 개선한 후 테스트를 다시 수행해야 한다. 이처럼 설정(1장)과 검증(2장)을 연결하는 과정이 신뢰성 있는 벤치마크의 핵심이다.</p>
<h3>3.2  <code>jtop</code>을 이용한 시각적 분석</h3>
<p><code>jtop</code>은 <code>tegrastats</code>가 제공하는 정보를 터미널 기반의 그래픽 인터페이스(TUI)로 시각화하여 보여주는 매우 유용한 서드파티 유틸리티다. 시스템 상태를 훨씬 직관적으로 파악할 수 있게 해준다.37</p>
<h4>3.2.1 설치 및 실행</h4>
<p><code>jtop</code>은 Python 패키지 관리자인 <code>pip</code>를 통해 간단히 설치할 수 있다. 설치 후에는 시스템 재부팅이 권장된다.23</p>
<ol>
<li>
<p><code>pip</code> 설치: <code>sudo apt install python3-pip</code></p>
</li>
<li>
<p><code>jetson-stats</code> 설치: <code>sudo pip3 install -U jetson-stats</code></p>
</li>
<li>
<p>재부팅: <code>sudo reboot</code></p>
</li>
<li>
<p>실행: 터미널에 <code>jtop</code> 입력</p>
</li>
</ol>
<p>실행하면 CPU 코어별 사용률, GPU 사용률, 메모리 사용량, 온도, 전력 소모 등 주요 정보가 실시간으로 업데이트되는 대시보드가 나타난다.</p>
<h4>3.2.2 주요 기능</h4>
<p><code>jtop</code>의 가장 큰 장점은 모니터링과 제어 기능을 통합했다는 점이다. 대시보드 내에서 단축키를 사용하여 다음과 같은 작업을 수행할 수 있다 37:</p>
<ul>
<li>
<p><strong>시스템 정보 확인 (INFO 페이지):</strong> JetPack 버전, CUDA 버전, IP 주소 등 시스템의 기본 정보를 한눈에 볼 수 있다.</p>
</li>
<li>
<p><strong>전력 모드 변경 (CTRL 페이지):</strong> <code>nvpmodel</code>이 제공하는 전력 모드를 메뉴에서 선택하여 변경할 수 있다.</p>
</li>
<li>
<p><strong><code>jetson_clocks</code> 활성화 (CTRL 페이지):</strong> <code>jetson_clocks</code> 스크립트를 직접 실행하지 않고도 <code>jtop</code> 내에서 활성화/비활성화할 수 있다.</p>
</li>
<li>
<p><strong>팬 속도 제어 (CTRL 페이지):</strong> 팬 모드를 변경하거나 속도를 수동으로 조절할 수 있다.</p>
</li>
</ul>
<p>이러한 통합 기능 덕분에 벤치마크를 준비하고 실행하는 과정이 매우 간소화된다. 또한 <code>jetson-stats</code>는 Python 라이브러리로도 제공되므로, 커스텀 모니터링 스크립트를 작성하여 장기간의 성능 및 온도 데이터를 수집하고 분석하는 데 활용할 수도 있다.38 이는 단기 벤치마크로는 파악하기 어려운, 실제 운영 환경에서의 열 관리 설계나 장기적인 성능 안정성을 평가하는 데 매우 중요하다.</p>
<h2>4.  핵심 연산 서브시스템 벤치마킹</h2>
<p>전체 시스템 성능은 각 서브시스템(CPU, GPU, 메모리, 스토리지)의 성능과 이들 간의 상호작용에 의해 결정된다. 이 장에서는 표준화된 벤치마크 도구를 사용하여 각 핵심 서브시스템의 순수 성능을 독립적으로 측정하고 평가하는 방법론을 제시한다. 이를 통해 시스템의 강점과 약점을 파악하고, 애플리케이션의 잠재적 병목 지점을 예측할 수 있다.</p>
<h3>4.1  CPU 성능 평가</h3>
<p>Jetson AGX Orin의 12코어 Arm Cortex-A78AE CPU는 AI 파이프라인의 전후 처리 및 일반 연산을 담당하는 중요한 요소다. CPU 성능은 시스템의 전반적인 반응성과 처리 능력에 직접적인 영향을 미친다.</p>
<h4>4.1.1 <code>sysbench</code>를 이용한 순수 연산 처리량 측정</h4>
<p><code>sysbench</code>는 시스템의 원시적인 연산 처리 능력을 측정하는 데 널리 사용되는 도구다. 특히 <code>cpu</code> 테스트는 다른 시스템 요소의 영향을 최소화하고 순수하게 CPU의 정수 연산 성능을 평가한다. 멀티코어 성능과 싱글코어 성능을 각각 측정하여 CPU의 확장성과 개별 코어의 효율성을 분석할 수 있다.40</p>
<ul>
<li>
<p><strong>설치:</strong> <code>sudo apt install sysbench</code></p>
</li>
<li>
<p>멀티코어 성능 측정: 모든 12개 스레드를 사용하여 10초간 소수(prime number)를 찾는 연산을 수행한다.</p>
</li>
</ul>
<p>sysbench cpu –threads=12 –time=10 run</p>
<ul>
<li>싱글코어 성능 측정: 단일 스레드만 사용하여 동일한 연산을 수행한다.</li>
</ul>
<p>sysbench cpu –threads=1 –time=10 run</p>
<p>결과는 초당 처리한 이벤트 수(events per second)로 표시되며, 이 값이 높을수록 CPU의 연산 처리량이 높음을 의미한다. 이 테스트는 데이터 전처리(이미지 리사이징, 정규화 등)나 복잡한 알고리즘 실행과 같이 CPU 집약적인 작업의 성능을 예측하는 데 유용하다.41</p>
<h4>4.1.2 <code>Geekbench</code>를 이용한 표준화된 성능 비교</h4>
<p><code>Geekbench</code>는 다양한 종류의 실제 워크로드를 시뮬레이션하여 싱글코어 및 멀티코어 성능을 점수로 환산해주는 표준 벤치마크 도구다. 이 점수를 통해 Jetson AGX Orin의 CPU 성능을 다른 모바일 AP, 데스크톱 CPU, 서버 CPU 등과 객관적으로 비교할 수 있다.42</p>
<ul>
<li>
<p><strong>실행:</strong> <code>Geekbench</code> 웹사이트에서 AArch64용 Linux 버전을 다운로드하고 압축을 해제한 후, 실행 파일을 실행한다.</p>
</li>
<li>
<p><strong>결과 분석:</strong> Jetson AGX Orin 64GB는 Geekbench 6 기준으로 일반적으로 <strong>싱글코어 점수 약 965점, 멀티코어 점수 약 5653점</strong>을 기록한다.43 이 점수는 이전 세대인 Xavier나 다른 임베디드 플랫폼과 비교하여 얼마나 성능이 향상되었는지 정량적으로 보여주는 중요한 지표가 된다.42</p>
</li>
</ul>
<h3>4.2  GPU 그래픽 및 연산 분석</h3>
<p>NVIDIA Ampere 아키텍처 기반의 GPU는 Orin의 핵심적인 성능 요소다. 그래픽 렌더링 능력과 범용 병렬 연산(GPGPU) 능력을 모두 평가해야 한다.</p>
<h4>4.2.1 <code>glmark2</code>를 이용한 그래픽 렌더링 성능</h4>
<p><code>glmark2</code>는 다양한 3D 씬을 렌더링하여 OpenGL 2.0 및 ES 2.0 성능을 측정하는 벤치마크다. 최종 점수는 GPU의 텍스처링, 버퍼링, 셰이딩 등 종합적인 3D 그래픽 처리 능력을 나타낸다. 이는 로봇 시뮬레이션의 시각화, 의료 영상의 3D 렌더링, 디지털 사이니지 등 GUI 기반 애플리케이션의 성능을 가늠하는 데 유용하다.47</p>
<ul>
<li>
<p><strong>설치:</strong> <code>sudo apt install glmark2</code></p>
</li>
<li>
<p><strong>실행:</strong> <code>glmark2</code></p>
</li>
</ul>
<h4>4.2.2 NVIDIA CUDA Samples를 이용한 CUDA 연산 능력 측정</h4>
<p>NVIDIA CUDA Toolkit에 포함된 예제 코드는 GPU의 순수 연산 성능을 측정하는 데 가장 신뢰할 수 있는 방법을 제공한다.</p>
<ul>
<li>
<p><strong>컴파일 및 준비:</strong> CUDA Samples는 소스 코드 형태로 제공되므로, <code>cmake</code>와 <code>make</code>를 사용하여 직접 빌드해야 한다.</p>
<pre><code class="language-Bash">git clone https://github.com/NVIDIA/cuda-samples.git
cd cuda-samples
mkdir build &amp;&amp; cd build
cmake..
make -j$(nproc)
</code></pre>
</li>
</ul>
<pre><code>
49

- **`deviceQuery`:** 빌드된 샘플 중 `0_Introduction/deviceQuery` 디렉터리의 `deviceQuery`를 실행한다. 이는 GPU의 상세 사양(CUDA 코어 수, SM 수, 최대 클럭, 글로벌 메모리 크기 등)을 출력하고 CUDA 드라이버와 런타임이 정상적으로 설치되었는지 확인하는 첫 단계다.22

- **`bandwidthTest`:** `0_Introduction/bandwidthTest`의 `bandwidthTest`를 실행한다. 이는 호스트(CPU-RAM)와 디바이스(GPU-VRAM) 간의 데이터 전송 속도를 측정한다. AI 파이프라인에서 데이터 전송이 병목이 되는 경우를 진단하는 데 필수적이다.50

- **`matrixMul`:** `0_Introduction/matrixMul`의 `matrixMul`은 기본적인 단정밀도 부동소수점(FP32) 행렬 곱셈 연산을 수행하여 GPU의 이론적 연산 성능(TFLOPS)을 측정한다. 이는 딥러닝의 핵심 연산 성능을 가늠하는 기초적인 지표다.50

정확한 CUDA 커널 실행 시간을 측정할 때는 CPU의 `chrono`와 같은 타이머 대신 `cudaEvent` API를 사용해야 한다. CPU 타이머는 커널 실행을 GPU에 요청하는 시간까지만 측정하므로 실제 GPU 연산 시간을 반영하지 못한다. 또한, CUDA 커널은 처음 실행될 때 JIT(Just-In-Time) 컴파일 과정을 거치므로, 이 오버헤드를 배제하기 위해 벤치마크 측정 전에 동일한 커널을 몇 차례 실행하는 '워밍업' 과정을 반드시 포함해야 한다.51

### 4.3  메모리 서브시스템 대역폭 측정


#### 4.3.1 `STREAM` 벤치마크


AI 및 고성능 컴퓨팅(HPC) 워크로드는 대량의 데이터를 처리하므로, 메모리 대역폭은 GPU 성능만큼이나 전체 시스템 성능에 결정적인 영향을 미친다. `STREAM` 벤치마크는 Copy, Scale, Add, Triad와 같은 간단한 벡터 연산을 통해 지속 가능한 메모리 대역폭(Sustainable Memory Bandwidth)을 측정한다. `STREAM`의 핵심은 L1/L2/L3 캐시 크기보다 훨씬 큰 데이터 배열을 사용하여, 캐시의 영향을 배제하고 순수하게 DRAM의 읽기/쓰기 성능을 측정한다는 점이다.53

- **컴파일 및 실행:**

  ```Bash
  wget https://www.cs.virginia.edu/stream/FTP/Code/stream.c
  gcc -O -DSTREAM_ARRAY_SIZE=&lt;large_number&gt; stream.c -o stream
  ./stream
</code></pre>
<p>STREAM_ARRAY_SIZE는 Orin의 캐시(L3 6MB)보다 충분히 크게 설정해야 한다. 이 벤치마크 결과는 Orin의 204.8 GB/s라는 이론적 대역폭에 얼마나 근접하는 실제 성능을 보이는지 알려준다.</p>
<h3>4.4  스토리지 I/O 성능</h3>
<p>데이터를 읽고 쓰는 스토리지의 성능은 AI 모델 로딩, 데이터셋 로딩, 로그 기록 등 전체 워크플로우의 시작과 끝에서 병목이 될 수 있다. 특히 대용량 비디오 데이터를 처리하거나 거대한 모델을 로딩할 때 스토리지 성능은 매우 중요하다.</p>
<h4>4.4.1 <code>fio</code> (Flexible I/O Tester) 활용</h4>
<p><code>fio</code>는 스토리지 성능을 측정하는 산업 표준 도구로, 다양한 I/O 패턴을 시뮬레이션할 수 있다. Orin의 내장 64GB eMMC와 사용자가 추가한 NVMe SSD의 성능을 각각 평가해야 한다.54</p>
<ul>
<li>
<p><strong>설치:</strong> <code>sudo apt install fio</code></p>
</li>
<li>
<p><strong>테스트 시나리오:</strong></p>
</li>
<li>
<p>순차 읽기/쓰기 (대용량 파일): 대용량 파일 복사나 비디오 스트리밍과 같은 워크로드를 시뮬레이션한다. 블록 크기(bs)를 크게(예: 1MB) 설정한다.</p>
<pre><code>sudo fio --name=seq-read --filename=/dev/nvme0n1 --rw=read --bs=1M --direct=1 --numjobs=4 --group_reporting
</code></pre>
</li>
</ul>
<pre><code>
- 랜덤 읽기/쓰기 (작은 파일, 데이터베이스): 데이터베이스나 다수의 작은 파일에 접근하는 워크로드의 성능(IOPS)을 측정한다. 블록 크기(bs)를 작게(예: 4KB) 설정한다.

    ```
    sudo fio --name=rand-read --filename=/dev/nvme0n1 --rw=randread --bs=4k --direct=1 --numjobs=4 --group_reporting
</code></pre>
<ul>
<li><strong>핵심 옵션 <code>direct=1</code>:</strong> 이 옵션은 운영체제의 페이지 캐시를 우회하여 I/O 요청이 스토리지 하드웨어로 직접 전달되도록 한다. 이를 통해 소프트웨어 캐싱 효과를 배제하고 스토리지 디바이스의 순수한 물리적 성능을 측정할 수 있으므로, 벤치마크 시 반드시 사용해야 한다.54</li>
</ul>
<p>이러한 개별 서브시스템 벤치마크를 통해 얻은 데이터는 Orin의 전반적인 성능 프로파일을 구성한다. 예를 들어, AI 추론 성능이 기대에 미치지 못할 때, <code>fio</code> 결과가 낮다면 데이터 로딩이 병목일 수 있고, <code>STREAM</code> 결과가 낮다면 메모리 대역폭이 한계일 수 있으며, <code>sysbench</code> 결과가 낮다면 CPU 기반 전처리가 문제일 수 있다. 이처럼 종합적인 벤치마크는 단순한 성능 측정을 넘어, 시스템 전체의 병목을 진단하고 최적화 방향을 제시하는 강력한 도구가 된다.</p>
<h2>5.  AI 추론 성능: 다층적 접근법</h2>
<p>Jetson AGX Orin의 핵심 가치는 AI 추론 성능에 있다. 이 성능을 정확하고 다각적으로 평가하기 위해서는 산업 표준 벤치마크, NVIDIA의 최적화 도구, 그리고 하드웨어 가속기 활용의 세 가지 차원에서 접근해야 한다.</p>
<h3>5.1  MLPerf를 이용한 표준화된 AI 벤치마킹</h3>
<p>MLPerf는 학계와 산업계가 공동으로 개발한 AI 성능 측정의 표준으로, 다양한 하드웨어와 소프트웨어 스택을 공정하게 비교할 수 있는 기준을 제공한다.57 NVIDIA는 Jetson 플랫폼의 성능을 검증하기 위해 정기적으로 MLPerf 벤치마크 결과를 제출하고 있으며, 이는 Orin의 공식적인 성능을 가늠하는 가장 신뢰도 높은 지표 중 하나다.16</p>
<h4>5.1.1 MLPerf 소개 및 재현</h4>
<p>MLPerf Inference 벤치마크는 엣지(Edge)와 데이터센터(Datacenter) 두 부문으로 나뉘며, Jetson 플랫폼은 엣지 부문에 속한다. 개발자는 MLCommons의 공식 GitHub 저장소에 공개된 코드와 절차에 따라, 로컬 Jetson AGX Orin 환경에서 NVIDIA가 제출한 공식 결과를 직접 재현해볼 수 있다. 이 과정은 로컬 시스템의 설정이 올바른지 검증하고, 공식 결과와의 성능 차이를 분석하는 데 매우 중요하다.59</p>
<h4>5.1.2 주요 모델 및 시나리오</h4>
<p>MLPerf는 실제 AI 애플리케이션에서 널리 사용되는 다양한 모델을 포함하여 종합적인 성능을 평가한다.</p>
<ul>
<li>
<p><strong>주요 모델:</strong></p>
</li>
<li>
<p><strong>이미지 분류:</strong> ResNet-50</p>
</li>
<li>
<p><strong>객체 탐지:</strong> RetinaNet, SSD-MobileNet</p>
</li>
<li>
<p><strong>자연어 처리:</strong> BERT</p>
</li>
<li>
<p><strong>의료 영상 분할:</strong> 3D-Unet</p>
</li>
<li>
<p>음성 인식: RNN-T</p>
</li>
</ul>
<p>59</p>
<ul>
<li>
<p><strong>핵심 시나리오:</strong></p>
</li>
<li>
<p><strong>Single-Stream:</strong> 한 번에 하나의 입력이 들어오는 상황을 가정하여, 시스템이 얼마나 빨리 응답하는지, 즉 **최소 지연 시간(latency)**을 측정한다. 이는 자율주행 로봇이 장애물을 회피하는 것과 같이 실시간 반응성이 극도로 중요한 애플리케이션의 성능을 평가하는 데 적합하다. 결과는 밀리초(ms) 단위로 표시된다.</p>
</li>
<li>
<p>Offline: 시스템이 처리할 수 있는 모든 데이터를 한 번에 받아 최대 속도로 처리하는 상황을 가정하여, **최대 처리량(throughput)**을 측정한다. 이는 수십 개의 CCTV 영상을 동시에 분석하거나, 대규모 데이터셋을 일괄 처리하는 시나리오의 성능을 평가하는 데 사용된다. 결과는 초당 샘플 수(samples/second)로 표시된다.</p>
</li>
</ul>
<p>58</p>
<p>이 두 시나리오는 성능의 상반된 측면을 보여준다. 지연 시간과 처리량은 종종 상충 관계에 있으므로, 애플리케이션의 요구사항에 따라 어떤 지표가 더 중요한지를 명확히 하고 해당 시나리오의 결과를 중심으로 성능을 평가해야 한다.</p>
<h3>5.2  TensorRT를 이용한 고성능 모델 최적화 및 벤치마킹</h3>
<p>NVIDIA TensorRT는 훈련된 딥러닝 모델을 NVIDIA GPU에서 고성능으로 추론할 수 있도록 최적화하는 SDK다. 레이어 융합(layer fusion), 정밀도 보정(precision calibration), 커널 자동 튜닝 등의 기술을 통해 모델의 지연 시간을 최소화하고 처리량을 극대화한다.60</p>
<h4>5.2.1 <code>trtexec</code> 도구 활용</h4>
<p>TensorRT SDK에 포함된 <code>trtexec</code>는 별도의 C++이나 Python 코드를 작성하지 않고도 커맨드 라인에서 직접 딥러닝 모델의 성능을 벤치마킹할 수 있는 강력한 도구다. PyTorch나 TensorFlow에서 훈련된 모델을 ONNX(Open Neural Network Exchange) 형식으로 변환한 후, <code>trtexec</code>를 사용하여 TensorRT 엔진으로 최적화하고 성능을 즉시 측정할 수 있다.61</p>
<ul>
<li>기본 명령어:</li>
</ul>
<p>trtexec –onnx=&lt;모델.onnx&gt; –saveEngine=&lt;엔진.engine&gt;</p>
<p>이 명령어는 ONNX 모델을 FP32 정밀도의 TensorRT 엔진으로 변환하고, 변환된 엔진의 추론 성능(지연 시간, 처리량)을 출력한다.</p>
<h4>5.2.2 정밀도와 성능의 트레이드오프 분석</h4>
<p><code>trtexec</code>의 플래그를 사용하여 다양한 정밀도로 모델을 최적화하고 성능을 비교 분석하는 것은 Orin의 Tensor Core를 최대한 활용하기 위한 핵심 과정이다.</p>
<ul>
<li>
<p><strong>FP32 (32-bit Floating Point):</strong> 기본 정밀도로, 가장 높은 정확도를 제공하지만 성능은 가장 낮다. 별도의 플래그가 필요 없다.</p>
</li>
<li>
<p><strong>FP16 (16-bit Floating Point):</strong> <code>--fp16</code> 플래그를 사용한다. Ampere 아키텍처의 Tensor Core는 FP16 연산에 최적화되어 있어, 정확도 손실이 거의 없이 FP32 대비 2배 이상의 성능 향상을 기대할 수 있다.61</p>
</li>
<li>
<p><strong>INT8 (8-bit Integer):</strong> <code>--int8</code> 플래그를 사용한다. 가장 높은 성능을 제공하지만, 부동소수점 값을 정수로 변환하는 양자화(quantization) 과정에서 정확도 손실이 발생할 수 있다. 이를 최소화하기 위해 TensorRT는 대표적인 입력 데이터셋을 사용하여 각 레이어의 활성화 값 분포를 측정하고 최적의 스케일링 팩터를 찾는 <strong>보정(calibration)</strong> 과정을 수행한다. 성공적으로 보정된 INT8 모델은 FP16 대비 다시 2배 이상의 성능 향상을 가져올 수 있다.60</p>
</li>
</ul>
<p>예를 들어, 최신 객체 탐지 모델인 YOLOv8의 경우, PyTorch 모델(<code>.pt</code>)을 ONNX로 변환한 뒤, <code>trtexec</code>를 사용하여 각 정밀도에서의 성능을 측정할 수 있다. 실제 벤치마크 결과에 따르면, Jetson AGX Orin 32GB 모델에서 YOLOv8x(가장 큰 버전)를 INT8로 최적화했을 때 약 75 FPS(초당 프레임 수)의 처리량을 달성할 수 있다. 이는 임베디드 디바이스로서는 매우 인상적인 수치다.61</p>
<h3>5.3  딥러닝 가속기(DLA) 성능 평가</h3>
<p>Jetson AGX Orin에는 GPU 외에도 2개의 NVDLA v2.0 엔진이 탑재되어 있다. DLA는 특히 컨볼루션(Convolution) 및 완전 연결(Fully-Connected) 레이어와 같은 CNN의 핵심 연산을 매우 높은 전력 효율성으로 처리하도록 설계된 전용 하드웨어다.</p>
<h4>5.3.1 DLA의 역할과 중요성</h4>
<p>DLA는 Orin의 전체 AI 연산 능력(TOPS)에서 상당한 비중을 차지하며, 전력 모드에 따라 최소 38%에서 최대 74%까지 기여한다.14 GPU가 최고의 ’성능’을 제공한다면, DLA는 최고의 ’</p>
<p><strong>와트당 성능(performance per watt)</strong>’을 제공한다. 실제 측정 결과, DLA의 와트당 성능은 동일한 작업을 수행하는 GPU 대비 평균 3~5배 더 높다.14 이는 배터리로 구동되는 로봇이나 발열 제약이 심한 소형 장치에서 AI 기능을 구현할 때 DLA가 핵심적인 역할을 할 수 있음을 의미한다.</p>
<h4>5.3.2 DLA 오프로딩 및 성능 분석</h4>
<p>TensorRT는 모델의 특정 레이어를 DLA에서 실행하도록 지정하는 기능을 지원한다. <code>trtexec</code>를 사용할 때 <code>--useDLACore=&lt;ID&gt;</code> 플래그를 추가하면 해당 DLA 코어(0 또는 1)를 사용하여 추론을 수행한다.</p>
<ul>
<li>
<p>DLA 성능 측정 명령어:</p>
<pre><code>trtexec --onnx=&lt;모델.onnx&gt; --useDLACore=0 --allowGPUFallback
</code></pre>
</li>
</ul>
<pre><code>
--allowGPUFallback 옵션은 DLA가 지원하지 않는 연산(레이어)을 만났을 때 GPU가 대신 처리하도록 하여 전체 모델이 실행될 수 있게 한다.

벤치마킹 절차는 GPU 단독 실행 시의 성능과 전력 소모, 그리고 DLA를 활용했을 때의 성능과 전력 소모를 각각 측정한 후, 와트당 성능(예: FPS/Watt)을 비교 분석하는 것이다. 이를 통해 특정 AI 모델이나 레이어가 DLA에 적합한지, 그리고 DLA 오프로딩을 통해 얻을 수 있는 전력 효율성 이득이 어느 정도인지 정량적으로 평가할 수 있다. 정교한 시스템 설계는 GPU의 최대 성능과 DLA의 최대 효율성을 조합하여, 전체 애플리케이션의 요구사항에 맞는 최적의 하이브리드 실행 전략을 수립하는 것을 포함한다.

이러한 다층적 접근법을 통해 얻어진 AI 추론 벤치마크 결과는 JetPack 버전, TensorRT 버전, 사용된 정밀도, 그리고 DLA 활용 여부와 함께 기록되어야 한다. NVIDIA의 소프트웨어 스택은 지속적으로 발전하며, 새로운 버전의 TensorRT는 종종 동일한 하드웨어에서도 더 나은 최적화 전략을 찾아내어 상당한 성능 향상을 가져온다.16 따라서 AI 성능을 논할 때, 하드웨어 사양만큼이나 소프트웨어 스택의 버전이 중요한 변수임을 명심해야 한다.

## 6.  결과 종합 및 성능 특성 분석


개별 서브시스템과 AI 추론 능력에 대한 벤치마크가 완료되면, 이 데이터들을 종합하여 Jetson AGX Orin 64GB의 전체적인 성능 프로파일을 도출하고, 그 특성을 심층적으로 분석해야 한다. 이는 플랫폼의 잠재력을 완전히 이해하고, 실제 애플리케이션에 대한 최적화 전략을 수립하는 최종 단계다.

### 6.1  성능 프로파일 분석


#### 6.1.1 벤치마크 결과의 상관관계 분석


각각의 벤치마크 결과는 독립적인 데이터가 아니라 서로 연결된 시스템의 일부다. 이들 간의 상관관계를 분석함으로써 시스템 전체의 동작 방식을 이해할 수 있다.

- **메모리 대역폭과 AI 성능:** `STREAM` 벤치마크에서 측정된 204.8 GB/s에 근접하는 높은 메모리 대역폭은 MLPerf의 BERT와 같은 대규모 언어 모델(LLM)이나 고해상도 이미지를 처리하는 비전 모델의 성능에 직접적인 영향을 미친다.9 GPU가 아무리 빨라도 데이터를 충분히 빠르게 공급받지 못하면 유휴 상태에 빠지게 된다. Orin의 LPDDR5 메모리 시스템은 Ampere GPU가 데이터에 굶주리지 않도록 보장하는 핵심적인 기반 요소다.

- **스토리지 I/O와 파이프라인 지연:** AI 애플리케이션 파이프라인은 '데이터 로딩 → 전처리 → 추론 → 후처리'의 단계를 거친다. `fio` 벤치마크에서 NVMe SSD의 랜덤 읽기 성능(IOPS)이 낮게 측정되었다면, 수많은 작은 이미지 파일로 구성된 데이터셋을 로딩하는 단계에서 병목이 발생할 수 있다. 이 경우, GPU는 대부분의 시간 동안 데이터를 기다리게 되어 전체 처리량은 스토리지 성능에 의해 제한된다.

- **CPU와 전체 처리량:** `sysbench`나 `Geekbench`에서 확인된 강력한 CPU 성능은 이미지 리사이징, 정규화, 데이터 증강과 같은 복잡한 전처리 과정을 빠르게 수행하여 GPU가 추론에만 집중할 수 있도록 한다. 만약 전처리 과정이 CPU 성능의 한계에 부딪힌다면, GPU 활용률은 낮아지고 전체 파이프라인의 효율성이 저하될 것이다.

이처럼 종합적인 벤치마크 데이터는 AI 애플리케이션의 성능이 저하될 때, 그 원인이 GPU 자체의 한계인지, 아니면 메모리, 스토리지, CPU 등 다른 서브시스템의 병목 현상인지를 진단하는 강력한 도구를 제공한다.

#### 6.1.2 전력 대비 성능 (Performance per Watt)


엣지 컴퓨팅 환경에서는 절대적인 성능만큼이나 전력 효율성이 중요하다. 각 벤치마크를 실행하는 동안 `tegrastats`를 통해 측정한 평균 전력 소모량(mW)을 사용하여 와트당 성능을 계산해야 한다.

- **계산식:** `성능 지표 / (평균 전력 소모량 / 1000)`

- 예: AI 추론의 경우 `FPS / Watt`

- 예: 비디오 인코딩의 경우 `인코딩된 프레임 수 / Watt`

이 지표는 특히 15W, 30W와 같은 저전력 모드에서 Orin이 얼마나 효율적으로 작업을 수행하는지 보여준다. MLPerf 벤치마크 결과에 따르면, Jetson AGX Orin은 이전 세대인 Xavier 대비 평균 2배 더 높은 에너지 효율성을 달성했다.3 이는 배터리로 구동되는 자율 로봇이나 드론과 같이 전력 공급이 제한적인 애플리케이션에 Orin이 최적의 솔루션임을 입증하는 데이터다.66

### 6.2  Orin 대 Xavier: 세대 간 도약의 정량화


본 보고서에서 제시된 방법론에 따라 수집된 벤치마크 데이터는 Jetson AGX Orin과 Xavier 간의 세대 차이를 명확하게 정량화한다.

- **종합 성능 비교:**

- **AI 추론:** 사용된 모델, 정밀도, 소프트웨어 스택 버전에 따라 실제 애플리케이션에서 **2.5배에서 최대 5배**에 달하는 실질적인 성능 향상을 보인다.17

- **CPU:** `sysbench` 및 `Geekbench` 결과는 Cortex-A78AE 코어 덕분에 약 **1.7배**의 성능 향상을 일관되게 보여준다.4

- **메모리 대역폭:** `STREAM` 벤치마크는 LPDDR5 메모리 채택으로 약 **1.5배**의 지속 가능한 대역폭 증가를 확인시켜 준다.4

- **성능 향상의 원인 분석:** 이러한 성능 향상은 단순히 클럭 속도를 높인 결과가 아니다. 이는 1장에서 분석한 근본적인 아키텍처 개선의 결과다. AI 성능의 비약적인 도약은 **Ampere 아키텍처의 3세대 Tensor Core와 희소성 지원**에 기인하며, CPU 성능 향상은 **NVIDIA Carmel 코어에서 Arm Cortex-A78AE로의 전환** 덕분이다. 또한, 시스템 전반의 성능 향상은 **LPDDR5 메모리의 도입**으로 인한 대역폭 증가가 뒷받침하고 있다.5 이처럼 벤치마크 결과를 아키텍처의 변화와 명확히 연결하여 설명함으로써, 성능 향상의 '무엇'을 넘어 '왜'를 이해할 수 있다.

### 6.3  실행 가능한 권장 사항


수집된 벤치마크 데이터는 다양한 애플리케이션 시나리오에 대한 최적화 전략을 수립하는 데 직접적으로 활용될 수 있다.

- **애플리케이션 유형별 최적화 전략:**

- **최대 처리량 목표 (예: 다중 채널 비디오 분석 시스템):**

- **전력 모드:** `nvpmodel -m 0` (MAXN) 설정 후 `sudo jetson_clocks` 실행.

- **AI 모델:** TensorRT를 사용하여 **INT8 정밀도**로 양자화하고, 가능한 **큰 배치 사이즈(batch size)**를 사용하여 GPU의 병렬 처리 능력을 극대화한다.

- **가속기 활용:** 모델의 일부 레이어를 **DLA로 오프로딩**하여 GPU의 부담을 줄이고, GPU가 다른 스트림 처리에 집중할 수 있도록 한다.

- **최소 지연 시간 목표 (예: 실시간 로봇 제어, 드론 장애물 회피):**

- **전력 모드:** `nvpmodel -m 0` (MAXN) 설정 후 `sudo jetson_clocks` 실행.

- **AI 모델:** **배치 사이즈를 1**로 설정하여 단일 입력에 대한 처리 시간을 최소화한다. INT8 양자화는 추가적인 연산 오버헤드를 유발할 수 있으므로, 지연 시간에 매우 민감한 경우 정확도 손실이 적은 **FP16 정밀도**가 더 유리할 수 있다.

- **전력 효율성 최적화 목표 (예: 배터리 구동 장치):**

- **전력 모드:** 애플리케이션의 최소 성능 요구사항을 만족하는 가장 낮은 전력 모드(예: **15W 또는 30W**)를 선택한다.

- **가속기 활용:** 워크로드를 최대한 **DLA로 오프로딩**하여 GPU의 가동률을 최소화한다. DLA는 GPU보다 월등한 와트당 성능을 제공하므로, 이는 전력 소모를 줄이는 가장 효과적인 방법이다.

Jetson AGX Orin의 진정한 가치는 단순히 MAXN 모드에서의 최고 성능이 아니라, **15W의 고효율 모드부터 60W 이상의 서버급 성능 모드까지 아우르는 넓은 성능 스펙트럼**에 있다. 일부 CPU나 메모리 집약적인 저부하 작업에서는 저전력 모드에서 Xavier가 더 효율적인 모습을 보일 수도 있다.69 이는 Orin의 복잡한 아키텍처가 고성능 병렬 연산에 최적화되어 있기 때문이다. 따라서 개발자는 이 넓은 스펙트럼 안에서 자신의 애플리케이션 요구사항(성능, 지연 시간, 전력)에 가장 적합한 운영 지점(operating point)을 찾는 것이 중요하다. 본 보고서에서 제시한 종합적인 벤치마크 방법론은 바로 그 최적의 지점을 데이터에 기반하여 찾을 수 있도록 돕는 나침반 역할을 할 것이다.

## 7. 결론


NVIDIA Jetson AGX Orin 64GB는 엣지 AI 컴퓨팅의 새로운 지평을 여는 기념비적인 플랫폼이다. 이전 세대를 압도하는 연산 능력은 자율 기계, 스마트 시티, 차세대 로보틱스 분야에서 혁신적인 애플리케이션의 등장을 가속화할 것이다. 그러나 이러한 막대한 잠재력은 시스템에 대한 깊이 있는 이해와 체계적인 성능 평가가 뒷받침될 때 비로소 완전히 발현될 수 있다.

본 보고서는 Jetson AGX Orin 64GB의 성능을 평가하기 위한 포괄적이고 다각적인 방법론을 제시했다. 아키텍처 분석과 시스템 환경 구축에서 시작하여, `tegrastats`와 `jtop`을 이용한 실시간 모니터링, 그리고 CPU, GPU, 메모리, 스토리지 등 핵심 서브시스템에 대한 개별 벤치마킹 절차를 상세히 기술했다. 나아가 MLPerf, TensorRT, DLA를 활용하여 AI 추론 성능을 지연 시간, 처리량, 전력 효율성이라는 다차원적 관점에서 분석하는 접근법을 제안했다.

분석을 통해 도출된 핵심 결론은 다음과 같다. 첫째, Jetson AGX Orin의 성능은 단일한 수치로 정의될 수 없으며, **하드웨어 아키텍처, 소프트웨어 스택(JetPack, TensorRT), 전력 모드, 그리고 애플리케이션 워크로드 간의 복잡한 상호작용의 결과물**이라는 점이다. 특히 소프트웨어 스택의 지속적인 발전은 동일한 하드웨어의 성능 한계를 계속해서 끌어올리므로, 벤치마크 결과는 반드시 소프트웨어 버전을 명시하여 맥락적으로 해석되어야 한다.

둘째, Orin의 진정한 강점은 최고 성능이 아닌 **넓은 성능 범위와 유연성**에 있다. 15W의 저전력 모드에서부터 60W 이상의 최대 성능 모드까지, 하나의 플랫폼이 다양한 전력 및 열 예산에 대응할 수 있는 능력은 여러 제품 라인업에 걸쳐 단일 개발 플랫폼을 사용하고자 하는 기업에게 막대한 전략적 이점을 제공한다.

따라서 본 보고서에서 제시한 종합적인 벤치마크 방법론은 단순히 성능 수치를 나열하는 것을 넘어, 시스템 전반의 병목을 진단하고, 애플리케이션의 요구사항에 맞춰 성능과 효율성 간의 최적 균형점을 찾는 **시스템 레벨의 분석 도구**로서 기능한다. 이 방법론을 충실히 따름으로써 개발자들은 Jetson AGX Orin이라는 강력한 도구를 완벽히 이해하고, 그 잠재력을 최대한 활용하여 미래의 AI 시대를 선도할 혁신적인 솔루션을 창조할 수 있을 것이다.

## 8. 참고 자료


1. NVIDIA Jetson AGX Orin Series, https://www.nvidia.com/content/dam/en-zz/Solutions/gtcf21/jetson-orin/nvidia-jetson-agx-orin-technical-brief.pdf
2. Jetson AGX Orin for Next-Gen Robotics - NVIDIA, https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-orin/
3. Delivering Server-Class Performance at the Edge with NVIDIA Jetson Orin, https://developer.nvidia.com/blog/delivering-server-class-performance-at-the-edge-with-nvidia-jetson-orin/
4. NVIDIA Jetson AGX Orin vs NVIDIA Jetson AGX Xavier - Assured Systems, https://www.assured-systems.com/nvidia-jetson-agx-orin-vs-nvidia-jetson-agx-xavier/
5. Compare NVIDIA Jetson AGX Orin with AGX Xavier: 8x AI performance, in-advance Ampere GPU, CPU, Memory &amp; Storage - Latest News from Seeed Studio, https://www.seeedstudio.com/blog/2022/03/17/compare-nvidia-jetson-agx-orin-with-agx-xavier-6x-ai-performance-in-advance-ampere-gpu-cpu-memory-storage/
6. NVIDIA Jetson Orin AGX - Introduction - SoM Overview - RidgeRun Developer Wiki, https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin/Introduction/SoM_Overview
7. NVIDIA Jetson AGX Orin Series - OpenZeka, https://openzeka.com/wp-content/uploads/2022/02/Jetson_AGX_Orin_DS-10662-001_v1.1.pdf
8. NVIDIA Jetson AGX Orin 64 GB Specs | TechPowerUp GPU Database, https://www.techpowerup.com/gpu-specs/jetson-agx-orin-64-gb.c4085
9. NVIDIA Jetson AGX Orin GPU: Technical Specs, Features, and Use Cases - server-parts.eu, https://www.server-parts.eu/post/nvidia-jetson-agx-orin-gpu-specs
10. NVIDIA Jetson AGX Orin 64GB Module - Tanna TechBiz, https://tannatechbiz.com/nvidia-jetson-agx-orin-64gb-module.html
11. NVIDIA Jetson AGX Orin Series - Mouser Electronics, https://www.mouser.com/datasheet/2/744/Seeed_Studio_06132023_102110758-3216382.pdf
12. NVIDIA Jetson AGX Orin 64GB Developer Kit - SparkFun Electronics, https://www.sparkfun.com/nvidia-jetson-agx-orin-64gb-developer-kit.html
13. NVIDIA Jetson AGX Orin 64GB Developer Kit - OpenZeka, https://openzeka.com/en/wp-content/uploads/2023/04/jetson-agx-orin-64GB-developer-kit-datasheet-web-us.pdf
14. Maximizing Deep Learning Performance on NVIDIA Jetson Orin with DLA, https://developer.nvidia.com/blog/maximizing-deep-learning-performance-on-nvidia-jetson-orin-with-dla/
15. Benchmark comparison for Jetson TX2, Xavier NX/AGX, Orin AGX, https://www.fastcompression.com/blog/jetson-benchmark-comparison.htm
16. Getting the Best Performance on MLPerf Inference 2.0 | NVIDIA Technical Blog, https://developer.nvidia.com/blog/getting-the-best-performance-on-mlperf-inference-2-0/
17. Is the new NVIDIA Jetson AGX Orin really a game changer ? We benchmarked it. - Medium, https://medium.com/@Smartcow_ai/is-the-new-nvidia-jetson-agx-orin-really-a-game-changer-we-benchmarked-it-b3e390f4830a
18. JetPack SDK - NVIDIA Developer, https://developer.nvidia.com/embedded/jetpack-sdk-514
19. JetPack Software Stack for NVIDIA Jetson - NVIDIA Developer, https://developer.nvidia.com/embedded/jetpack
20. NVIDIA JetPack 6.2 Brings Super Mode to NVIDIA Jetson Orin Nano and Jetson Orin NX Modules | NVIDIA Technical Blog - NVIDIA Developer, https://developer.nvidia.com/blog/nvidia-jetpack-6-2-brings-super-mode-to-nvidia-jetson-orin-nano-and-jetson-orin-nx-modules/
21. What Is NVIDIA JetPack 6.2? How It Boosts Jetson Orin AI Performance - C&amp;T Solution Inc., https://www.candtsolution.com/news_events-detail/what-is-nvidia-jetpack-sdk-for-jetson-module/
22. Jetson AGX Orin and Orin Nano Comparison Part 2: Performance - RS Online, https://www.rs-online.com/designspark/jetson-agx-orin-and-orin-nano-comparison-part-2-performance
23. Jetson Orin Nano Super Developer Kit — Initial Setup | by Matt Dixon - Medium, https://medium.com/@matt.dixon1010/jetson-orin-nano-super-developer-kit-initial-setup-fccba1d46b09
24. Initial Setup Guide for Jetson Orin Nano Developer Kit, https://www.jetson-ai-lab.com/initial_setup_jon.html
25. NVIDIA Jetson Orin AGX - JetPack 5.0.2 - Performance Tuning - RidgeRun Developer Wiki, https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin/JetPack_5.0.2/Performance_Tuning/Tuning_Power
26. NVIDIA Jetson Orin NX - Performance Tuning by Tuning Power - RidgeRun Developer Wiki, https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin_NX/JetPack_5.1.1/Performance_Tuning/Tuning_Power
27. Jetson AGX Orin Developer Kit User Guide - How-to | NVIDIA Developer, https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/howto.html
28. NVPModel - NVIDIA Jetson AGX Xavier Developer Kit - JetsonHacks, https://jetsonhacks.com/2018/10/07/nvpmodel-nvidia-jetson-agx-xavier-developer-kit/
29. Test Plan and Validation — NVIDIA Jetson Linux Developer Guide, https://docs.nvidia.com/jetson/archives/r36.4.3/DeveloperGuide/SD/TestPlanValidation.html
30. Questions Regarding Adjusting the Power Settings of Jetson AGX Orin, https://forums.developer.nvidia.com/t/questions-regarding-adjusting-the-power-settings-of-jetson-agx-orin/314913
31. What Is Super Mode on NVIDIA Jetson Orin Nano and NX in JetPack 6.2 Release?, https://www.candtsolution.com/news_events-detail/what-is-super-mode-on-jetson-orin-nano-and-nx/
32. Help Needed – Jetson Orin Nano Overheating in Enclosed Outdoor Setup, https://forums.developer.nvidia.com/t/help-needed-jetson-orin-nano-overheating-in-enclosed-outdoor-setup/342224
33. NVIDIA Jetson Thermal Design Guide: Unleash Peak AI Performance - Things Embedded, https://things-embedded.com/us/white-paper/nvidia-jetson-thermal-design-guide-unleash-peak-ai-performance/
34. Jetson Orin NX Series and Jetson Orin Nano Series Modules Thermal Design Guide - NVIDIA Developer, https://developer.nvidia.com/downloads/jetson-orin-nx-orin-nano-series-thermal-design-guide
35. Frore Systems is keeping pace with NVIDIA in enabling AI Performance | Blog, https://www.froresystems.com/blog/frore-systems-is-keeping-pace-with-nvidia-in-enabling-ai-performance
36. NVIDIA Jetson Orin AGX - JetPack 5.0.2 - Performance Tuning ..., https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin/JetPack_5.0.2/Performance_Tuning/Evaluating_Performance
37. Jetson Stats - NVIDIA Developer, https://developer.nvidia.com/embedded/community/jetson-projects/jetson_stats
38. jetson-stats 4.3.2 - rnext - Raffaello Bonghi, https://rnext.it/jetson_stats/
39. The NVIDIA Jetson Series - Part 1 (Jetson-Stats) - InfluxData, https://www.influxdata.com/blog/nvidia-jetson-series-part-1-jetson-stats/
40. akopytov/sysbench: Scriptable database and system performance benchmark - GitHub, https://github.com/akopytov/sysbench
41. CPU Models by single-threaded Sysbench Performance - VPSBenchmarks, https://www.vpsbenchmarks.com/labs/cpus_by_singlethreaded_sysbench_perf
42. Jetson AGX Orin vs Jetson-TX1 - Geekbench Browser, https://browser.geekbench.com/v5/cpu/compare/18647313?baseline=18468165
43. Jetson AGX Orin - Geekbench Browser, https://browser.geekbench.com/v6/cpu/baseline/2599708
44. NVIDIA NVIDIA Jetson Orin Nano Developer Kit - Geekbench, https://browser.geekbench.com/v6/cpu/9659138
45. NVIDIA Jetson Orin Nano NX - Geekbench Browser, https://browser.geekbench.com/v6/cpu/baseline/1206997
46. NVIDIA NVIDIA Jetson AGX Orin Developer Kit - Geekbench Browser, https://browser.geekbench.com/v6/cpu/baseline/7977801
47. glmark2 is an OpenGL 2.0 and ES 2.0 benchmark - GitHub, https://github.com/glmark2/glmark2
48. How to install SLE-15-SP6 on NVIDIA's Jetson AGX Orin, Jetson Orin Nano/NX and IGX Orin, https://sndirsch.github.io/nvidia/2024/05/07/nvidia-jetson.html
49. NVIDIA/cuda-samples: Samples for CUDA Developers which demonstrates features in CUDA Toolkit - GitHub, https://github.com/NVIDIA/cuda-samples
50. How to Install CUDA Samples for Testing - Exxact Corporation, https://support.exxactcorp.com/hc/en-us/articles/30339827019287-How-to-Install-CUDA-Samples-for-Testing
51. How to Benchmark CUDA Kernels - Guillesanbri, https://guillesanbri.com/CUDA-Benchmarks/
52. CUDA C++ Best Practices Guide - NVIDIA Docs Hub, https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/
53. STREAM Benchmark Reference Information - Computer Science, https://www.cs.virginia.edu/stream/ref.html
54. Performance benchmarking with Fio on Nutanix, https://portal.nutanix.com/kb/12075
55. 1. fio - Flexible I/O tester rev. 3.38 - FIO's documentation! - Read the Docs, https://fio.readthedocs.io/en/latest/fio_doc.html
56. Quick NVMe performance testing with fio - Jeff Geerling, https://www.jeffgeerling.com/blog/2024/quick-nvme-performance-testing-fio
57. Benchmark MLPerf Inference: Datacenter | MLCommons V3.1, https://mlcommons.org/benchmarks/inference-datacenter/
58. Benchmark MLPerf Inference: Edge | MLCommons V3.1 Results, https://mlcommons.org/benchmarks/inference-edge/
59. Jetson Benchmarks - NVIDIA Developer, https://developer.nvidia.com/embedded/jetson-benchmarks
60. TensorRT Export for YOLO11 Models - Ultralytics YOLO Docs, https://docs.ultralytics.com/integrations/tensorrt/
61. YOLOv8 Performance Benchmarks on NVIDIA Jetson Devices - Seeed Studio, https://www.seeedstudio.com/blog/2023/03/30/yolov8-performance-benchmarks-on-nvidia-jetson-devices/
62. Benchmarking Deep Neural Networks on NVIDIA Jetson AGX Orin with Kenning - Antmicro, https://antmicro.com/blog/2022/12/benchmarking-dnn-on-nvidia-jetson-agx-orin-with-kenning/
63. Tutorial - Ultralytics YOLOv8 - NVIDIA Jetson AI Lab, https://www.jetson-ai-lab.com/tutorial_ultralytics.html
64. Deploy YOLOv8 on NVIDIA Jetson using TensorRT - Seeed Studio Wiki, https://wiki.seeedstudio.com/YOLOv8-TRT-Jetson/
65. NVIDIA Blackwell Sets New Standard for Generative AI in MLPerf Inference Debut, https://blogs.nvidia.com/blog/mlperf-inference-benchmark-blackwell/
66. NVIDIA Jetson AGX Orin and RTX 4090 Comparison - Lowtouch.Ai, https://www.lowtouch.ai/nvidia-jetson-agx-orin-and-rtx-4090-in-ai-applications/
67. Is the New NVIDIA Jetson AGX Orin Really a Game Changer? We Benchmarked It, https://www.edge-ai-vision.com/2022/04/is-the-new-nvidia-jetson-agx-orin-really-a-game-changer-we-benchmarked-it/
68. AGX Orin vs AGX Xavier: Jetson Ampere GPU Brings 8x AI Performance - Things Embedded, https://things-embedded.com/us/white-paper/agx-orin-vs-agx-xavier-jetson-ampere-gpu-brings-8x-ai-performance/
69. Performance of Orin vs Xavier - Jetson AGX Orin - NVIDIA Developer Forums, https://forums.developer.nvidia.com/t/performance-of-orin-vs-xavier/304129</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>