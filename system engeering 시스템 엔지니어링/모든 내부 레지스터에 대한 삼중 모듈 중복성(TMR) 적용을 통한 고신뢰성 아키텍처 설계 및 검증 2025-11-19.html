<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:모든 내부 레지스터에 대한 삼중 모듈 중복성(TMR) 적용을 통한 고신뢰성 아키텍처 설계 및 검증</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>모든 내부 레지스터에 대한 삼중 모듈 중복성(TMR) 적용을 통한 고신뢰성 아키텍처 설계 및 검증</h1>
                    <nav class="breadcrumbs"><a href="../index.html">Home</a> / <a href="index.html">시스템 엔지니어링 (System Engineering)</a> / <span>모든 내부 레지스터에 대한 삼중 모듈 중복성(TMR) 적용을 통한 고신뢰성 아키텍처 설계 및 검증</span></nav>
                </div>
            </header>
            <article>
                <h1>모든 내부 레지스터에 대한 삼중 모듈 중복성(TMR) 적용을 통한 고신뢰성 아키텍처 설계 및 검증</h1>
<p>2025-11-19, G30DR</p>
<h2>1.  서론: 방사선 환경과 고신뢰성 컴퓨팅의 패러다임 전환</h2>
<p>현대 반도체 기술의 미세화 공정은 집적도의 비약적인 향상을 가져왔으나, 이는 동시에 시스템의 신뢰성을 위협하는 새로운 난제들을 야기했다. 특히 우주 항공, 원자력 발전 제어, 고고도 무인기(UAV), 그리고 차세대 자율주행 자동차와 같은 미션 크리티컬(Mission-Critical) 환경에서 운영되는 전자 시스템은 자연계에 존재하는 고에너지 입자(양성자, 중성자, 중이온 등)의 지속적인 위협에 노출되어 있다. 이러한 입자들이 반도체 소자의 민감한 노드(Sensitive Node)를 타격할 때 발생하는 전하 침적 현상은 회로의 논리 상태를 일시적으로 반전시키는 단일 이벤트 효과(SEE, Single Event Effect)를 유발한다.1</p>
<p>과거의 내방사선 설계(Radiation Hardening)는 주로 소자 자체의 물성을 변경하거나 공정을 개선하는 ’Process Level’의 접근(Radiation Hardening By Process, RHBP)에 의존하였다. 그러나 최신 상용(COTS, Commercial Off-The-Shelf) FPGA나 ASIC 공정을 활용하여 비용 효율적인 고성능 시스템을 구축하려는 요구가 증가함에 따라, 설계 단계에서 논리적으로 결함을 허용하고 수정하는 ’Design Level’의 접근(Radiation Hardening By Design, RHBD)이 필수적인 표준으로 자리 잡고 있다. 이 중에서도 삼중 모듈 중복성(TMR, Triple Modular Redundancy)은 가장 직관적이면서도 강력한 오류 마스킹(Error Masking) 능력을 제공하는 기법으로 평가받는다.2</p>
<p>본 보고서는 시스템의 일부가 아닌 ’모든 내부 레지스터’에 TMR을 적용하여 상태(State) 무결성을 완벽하게 보장하는 아키텍처를 설계하는 방법론을 심층적으로 분석한다. 특히 단순한 중복을 넘어, 오류가 누적되는 것을 방지하기 위한 자기 수정(Self-Correcting) 피드백 메커니즘의 회로적 구현, 이를 FPGA 및 ASIC 합성 툴의 최적화로부터 보호하기 위한 구체적인 제약 조건(Constraints) 전략, 그리고 레지스터 파일(Register File) 보호에 있어 오류 정정 코드(ECC) 대비 TMR이 갖는 공학적 트레이드오프를 포괄적으로 다룬다.</p>
<h2>2.  삼중 모듈 중복성(TMR)의 이론적 토대와 아키텍처 위상</h2>
<h3>2.1  TMR의 수학적 신뢰성 모델링</h3>
<p>TMR의 핵심 원리는 동일한 기능을 수행하는 세 개의 모듈이 병렬로 동작하고, 그 출력을 다수결 투표기(Majority Voter)를 통해 결정하는 것이다. 이는 폰 노이만(von Neumann)이 제안한 확률론적 논리 합성의 개념에 뿌리를 두고 있다. 단일 모듈의 신뢰도를 <span class="math math-inline">R_m(t)</span>라고 하고, 투표기의 신뢰도를 <span class="math math-inline">R_v(t)</span>라고 정의할 때, TMR 시스템 전체의 신뢰도 <span class="math math-inline">R_{TMR}(t)</span>는 이항 분포(Binomial Distribution)에 기초하여 다음과 같이 유도된다.5</p>
<p><span class="math math-display">
R_{TMR}(t) = R_v(t) \cdot \sum_{i=2}^{3} \binom{3}{i} R_m(t)^i (1 - R_m(t))^{3-i}
</span><br />
이를 전개하면 다음과 같은 식을 얻을 수 있다.</p>
<p><span class="math math-display">
R_{TMR}(t) = R_v(t) \cdot (3 R_m(t)^2 - 2 R_m(t)^3)
</span><br />
이 수식은 두 가지 중요한 공학적 함의를 내포한다. 첫째, 시스템의 신뢰성은 개별 모듈의 신뢰도보다 투표기 자체의 신뢰도(<span class="math math-inline">R_v</span>)에 의해 상한선이 결정된다. 즉, 투표기는 단일 실패 지점(Single Point of Failure, SPOF)으로 작용하므로, 투표기 회로는 극도로 단순하고 견고해야 하며, 경우에 따라 투표기 자체도 중복 설계되어야 한다.7 둘째, <span class="math math-inline">R_m(t) &gt; 0.5</span>인 구간에서만 <span class="math math-inline">R_{TMR}(t) &gt; R_m(t)</span>가 성립한다. 시간이 지남에 따라 개별 모듈의 고장 확률이 누적되어 신뢰도가 0.5 이하로 떨어지면, TMR 시스템은 단일 시스템보다 오히려 더 빠르게 붕괴한다. 이는 TMR 시스템에 주기적인 ‘리프레시(Refresh)’ 또는 ’스크러빙(Scrubbing)’이 반드시 동반되어야 함을 수학적으로 증명한다.5</p>
<h3>2.2  TMR 토폴로지 계층 구조 및 분산 TMR(DTMR)의 우위</h3>
<p>TMR은 적용 범위와 입도(Granularity)에 따라 다양한 위상(Topology)을 가진다. 사용자의 요구사항인 “모든 내부 레지스터 적용“은 분산 TMR(DTMR) 또는 전역 TMR(GTMR)에 해당하며, 이는 가장 높은 비용을 요구하지만 가장 강력한 내성을 제공한다.10</p>
<table><thead><tr><th><strong>TMR 위상 (Topology)</strong></th><th><strong>구조적 특징 및 투표기 배치</strong></th><th><strong>보호 범위 및 한계</strong></th><th><strong>적용 적합성</strong></th></tr></thead><tbody>
<tr><td><strong>Block TMR (BTMR)</strong></td><td>전체 IP 코어 또는 대형 모듈을 3개 복제하고, 최종 출력단에만 투표기를 배치.</td><td>입출력 인터페이스만 보호됨. 모듈 내부 상태 머신(FSM)이 오염될 경우, 리셋 전까지 복구 불가능. 내부 오류 누적(Accumulation)에 취약함.</td><td>블랙박스 IP, 수정 권한이 없는 레거시 코어</td></tr>
<tr><td><strong>Local TMR (LTMR)</strong></td><td>플립플롭(FF)만 3중화하고, 조합 논리(Combinational Logic)는 공유함. FF 입력단에 투표기를 배치.</td><td>FF의 SEU(Single Event Upset)는 방어하나, 조합 논리에서 발생하는 SET(Single Event Transient)가 3개의 FF로 동시에 전파될 경우 방어 실패.</td><td>면적 제약이 심한 데이터패스, 낮은 방사선 환경</td></tr>
<tr><td><strong>Distributed TMR (DTMR)</strong></td><td><strong>플립플롭, 조합 논리, 투표기를 모두 3중화.</strong> 각 FF의 데이터 경로와 피드백 루프에 개별 투표기 배치.</td><td><strong>SEU 및 SET 완벽 방어.</strong> 오류가 발생한 즉시 해당 스테이지에서 차단(Masking)되어 전파되지 않음. 단일 이벤트가 시스템 상태를 오염시키는 것을 원천 봉쇄.</td><td><strong>고신뢰성 프로세서 코어, FSM, 제어 로직</strong></td></tr>
<tr><td><strong>Global TMR (GTMR)</strong></td><td>DTMR에 더해 글로벌 클록 트리와 리셋 트리까지 3중화하여 스큐(Skew) 및 글로벌 시그널 SET 방어.</td><td>클록 네트워크 타격에 의한 전체 시스템 동기화 실패 방어. 구현 난이도가 최상급이며 FPGA 내 글로벌 라우팅 자원 고갈 위험.</td><td>위성 메인 컴퓨터, 생명 유지 장치</td></tr>
</tbody></table>
<p>사용자가 요청한 아키텍처는 <strong>DTMR(Distributed TMR)</strong> 방식에 해당한다. 이 방식에서는 데이터패스와 제어 로직이 모두 3중화되며, 투표기는 각 레지스터의 경계에 위치하여 “방화벽” 역할을 수행한다. DTMR의 핵심은 오류가 발생한 모듈(도메인)을 나머지 두 도메인으로부터 격리하고, 다음 클록 사이클에 정상 상태로 복귀시키는 것이다. 이는 단순히 출력을 다수결로 결정하는 것을 넘어, 시스템의 **내부 상태(Internal State)**를 지속적으로 정화하는 과정이다.10</p>
<h2>3.  자기 수정(Self-Correcting) 메커니즘의 심층 회로 설계</h2>
<h3>3.1  오류 누적(Error Accumulation) 문제와 피드백 루프의 필연성</h3>
<p>기본적인 TMR은 오류를 감지하고 올바른 값을 출력하지만, 오류가 발생한 원본 레지스터의 값을 수정하지는 않는다. 예를 들어, 레지스터 <span class="math math-inline">R_A, R_B, R_C</span> 중 <span class="math math-inline">R_A</span>가 SEU로 인해 ’0’에서 ’1’로 반전되었다고 가정하자. 투표기는 <span class="math math-inline">R_B, R_C</span>의 ‘0’ 값을 근거로 ’0’을 출력하여 시스템의 오작동을 막는다. 그러나 <span class="math math-inline">R_A</span>는 여전히 ’1’인 상태로 남아 있다. 만약 시간이 흘러 또 다른 입자가 <span class="math math-inline">R_B</span>를 타격하여 반전시킨다면, 이제 시스템은 두 개의 오류(<span class="math math-inline">R_A, R_B</span>)를 갖게 되어 다수결 논리가 실패하게 된다. 이를 **오류 누적(Accumulation of Errors)**이라 하며, 장기 가동 시스템에서 TMR이 실패하는 주된 원인이다.5</p>
<p>이를 해결하기 위해 필수적인 것이 <strong>자기 수정(Self-Correcting) 피드백 루프</strong>이다. 이는 투표기의 결과(올바른 값)를 다시 레지스터의 입력으로 피드백하여, 오염된 레지스터의 값을 다음 클록 사이클에 강제로 덮어쓰는(Scrubbing) 기법이다.8</p>
<h3>3.2  피드백 TMR(Feedback TMR) 회로의 상세 설계</h3>
<p>자기 수정 기능을 갖춘 레지스터는 일반적인 D 플립플롭과 달리, 투표기 출력을 피드백 받는 멀티플렉서(MUX) 구조를 내장하거나, 데이터 경로 자체가 투표기를 통과하도록 설계된다.</p>
<h4>3.2.1  회로 구성 요소</h4>
<ol>
<li><strong>복제된 저장소:</strong> 3개의 동일한 D 플립플롭 (<span class="math math-inline">DFF_0, DFF_1, DFF_2</span>).</li>
<li><strong>다수결 투표기:</strong> 3개의 <span class="math math-inline">Q</span> 출력(<span class="math math-inline">Q_0, Q_1, Q_2</span>)을 입력받아 다수결 값 <span class="math math-inline">Q_{voted}</span>를 출력하는 조합 논리 회로.</li>
</ol>
<ul>
<li>논리식: <span class="math math-inline">Q_{voted} = (Q_0 \land Q_1) \lor (Q_1 \land Q_2) \lor (Q_0 \land Q_2)</span></li>
</ul>
<ol start="3">
<li><strong>피드백 경로:</strong> <span class="math math-inline">Q_{voted}</span> 신호가 다음 클록 사이클의 데이터 입력 로직에 포함됨.</li>
</ol>
<h4>3.2.2  동작 모드별 메커니즘</h4>
<ul>
<li><strong>로드(Load) 모드 (새로운 데이터 쓰기):</strong> 시스템이 레지스터에 새로운 값을 쓸 때, 3개의 <span class="math math-inline">DFF</span>는 모두 새로운 입력 <span class="math math-inline">D_{in}</span>을 받아들인다. 이때 입력 <span class="math math-inline">D_{in}</span> 자체도 이전 스테이지의 투표기를 거쳐 온 신뢰할 수 있는 값이어야 한다.</li>
<li><strong>홀드(Hold) 모드 (값 유지):</strong> 시스템이 값을 유지해야 할 때(Enable 신호가 비활성일 때), 일반적인 레지스터는 자신의 출력 <span class="math math-inline">Q</span>를 다시 <span class="math math-inline">D</span>로 입력받는다(<span class="math math-inline">Q \to D</span>). 그러나 자기 수정 TMR에서는 자신의 출력 <span class="math math-inline">Q</span> 대신 **투표기의 출력 <span class="math math-inline">Q_{voted}</span>**를 입력받아야 한다.</li>
<li>만약 <span class="math math-inline">DFF_0</span>가 오류로 반전되었더라도, <span class="math math-inline">Q_{voted}</span>는 정상이므로, 다음 클록 엣지(Clock Edge)에서 <span class="math math-inline">DFF_0</span>는 <span class="math math-inline">Q_{voted}</span> 값을 캡처하여 정상 상태로 복구된다.13</li>
</ul>
<p>이러한 “Scrubbing-in-the-loop” 방식은 별도의 외부 스크러빙 컨트롤러 없이도, 클록이 인가되는 한 매 사이클마다 자동으로 오류를 정정한다. 이는 수 밀리초(ms)가 소요되는 구성 메모리(Configuration Memory) 스크러빙보다 훨씬 빠른 나노초(ns) 단위의 복구 속도를 제공한다.16</p>
<h3>3.3  Verilog HDL 구현 및 구조적 코딩 기법</h3>
<p>자기 수정 TMR을 Verilog로 구현할 때는 합성 툴이 피드백 루프를 최적화(제거)하지 않도록 명시적으로 구조를 기술해야 한다. 다음은 자기 수정 기능이 포함된 TMR 레지스터의 개념적 코드이다.15</p>
<pre><code class="language-Verilog">module tmr_dff_self_correcting (
    input wire clk,
    input wire rst_n,
    input wire load_en, // Write Enable
    input wire d_in,    // Data Input (Should be from majority voter of prev stage)
    output wire q_out
);

    // 1. 3중화된 레지스터 선언 (Attributes for Synthesis Prevention)
    (* DONT_TOUCH = "TRUE" *) reg q0;
    (* DONT_TOUCH = "TRUE" *) reg q1;
    (* DONT_TOUCH = "TRUE" *) reg q2;
    
    wire q_voted;

    // 2. 다수결 투표기 (Combinational Logic)
    // 이 로직 역시 최적화로 인해 단소화되지 않도록 주의
    assign q_voted = (q0 &amp; q1) | (q1 &amp; q2) | (q0 &amp; q2);

    // 3. 출력 할당
    assign q_out = q_voted;

    // 4. 순차 논리 (Sequential Logic) with Feedback
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            q0 &lt;= 1'b0;
            q1 &lt;= 1'b0;
            q2 &lt;= 1'b0;
        end else begin
            if (load_en) begin
                // 로드 모드: 외부 데이터 입력
                q0 &lt;= d_in;
                q1 &lt;= d_in;
                q2 &lt;= d_in;
            end else begin
                // 홀드 모드: 자기 수정 (Self-Correcting)
                // 자신의 Q가 아닌 Voted Q를 피드백 받음
                q0 &lt;= q_voted; 
                q1 &lt;= q_voted;
                q2 &lt;= q_voted;
            end
        end
    end
endmodule
</code></pre>
<p>이 코드에서 핵심은 <code>else</code> 블록(홀드 모드)에서 <code>q0 &lt;= q0</code>가 아니라 <code>q0 &lt;= q_voted</code>를 수행한다는 점이다. 이것이 바로 자기 수정의 핵심 알고리즘이다. 만약 <code>q0</code>가 SEU로 인해 뒤집혔어도, <code>q_voted</code>는 <code>q1</code>, <code>q2</code>에 의해 올바른 값을 유지하고 있으므로 다음 클록에 <code>q0</code>가 복구된다.15</p>
<h2>4.  레지스터 파일(Register File) 보호 전략: TMR 대 ECC</h2>
<p>범용 프로세서(CPU)나 GPU 아키텍처에서 레지스터 파일(Register File, RF)은 가장 빈번하게 액세스되는 고속 메모리 블록이다. 모든 내부 레지스터에 TMR을 적용한다는 것은 수십에서 수백 개의 워드를 가진 RF 전체를 3중화한다는 것을 의미하며, 이는 막대한 면적 오버헤드를 유발한다. 따라서 많은 설계자가 ECC(Error Correcting Code)와 TMR 사이에서 고민하게 된다.</p>
<h3>4.1  레지스터 파일 취약성 분석</h3>
<p>레지스터 파일은 파이프라인의 중심에 위치하며, 이곳의 데이터 오염은 연산 유닛(ALU), 주소 생성 유닛(AGU), 제어 유닛 등으로 즉시 전파된다. 연구에 따르면 레지스터 파일은 프로세서 내에서 소프트 에러 취약성 인자(AVF, Architectural Vulnerability Factor)가 가장 높은 구성 요소 중 하나이다.19 특히 최신 공정에서는 인접한 여러 비트가 한 번의 입자 타격으로 동시에 반전되는 다중 비트 업셋(MBU, Multi-Bit Upset)의 확률이 증가하고 있어, 단일 비트 수정에 그치는 기존 보호 기법들을 위협하고 있다.</p>
<h3>4.2  TMR과 ECC(SEC-DED)의 공학적 트레이드오프</h3>
<p>일반적으로 상용 프로세서는 SEC-DED(Single Error Correction, Double Error Detection) 해밍 코드(Hamming Code)를 사용하여 RF를 보호한다. 그러나 극한의 신뢰성을 요구하는 본 과제에서는 TMR이 ECC보다 우월한 선택지가 될 수 있다. 다음은 두 방식의 상세 비교 분석이다.21</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>TMR (Triple Modular Redundancy)</strong></th><th><strong>ECC (SEC-DED Hamming Code)</strong></th></tr></thead><tbody>
<tr><td><strong>오류 수정 메커니즘</strong></td><td>실시간 마스킹 (투표기 통과 즉시 수정). 별도의 수정 사이클 불필요.</td><td>읽기 시 신드롬 계산 및 디코딩 필요. 쓰기 시 패리티 인코딩 필요.</td></tr>
<tr><td><strong>지연 시간 (Latency)</strong></td><td><strong>매우 낮음.</strong> 투표기(2-level logic) 지연만 추가됨. 고속 동작 주파수 유지 유리.</td><td><strong>높음.</strong> 인코딩/디코딩 로직이 크리티컬 패스에 위치하여 <span class="math math-inline">F_{max}</span> 저하 유발.</td></tr>
<tr><td><strong>면적 오버헤드</strong></td><td><strong>매우 큼 (&gt;200%).</strong> 레지스터 3배 + 투표기 + 라우팅 복잡도 증가.</td><td><strong>중간 (~20~40%).</strong> 체크 비트(32비트 데이터 기준 7비트) + 인코더/디코더 로직.</td></tr>
<tr><td><strong>MBU 대응 능력</strong></td><td><strong>우수.</strong> 3개의 레지스터 뱅크를 물리적으로 이격 배치(Interleaving)하면 MBU 완벽 방어.</td><td><strong>취약.</strong> 한 워드 내에서 2비트 이상 오류 발생 시 수정 불가(DED), 3비트 이상 시 오진 가능성.</td></tr>
<tr><td><strong>복구 방식</strong></td><td>피드백 루프를 통해 다음 사이클에 자동 복구 (Scrubbing).</td><td>오류 검출 시 파이프라인 스톨(Stall) 후 수정된 값을 재기입(Write-back)하는 복잡한 제어 필요.</td></tr>
</tbody></table>
<h3>4.3  고신뢰성 설계를 위한 레지스터 파일 아키텍처</h3>
<p>연구 결과 및 실제 미션 크리티컬 프로세서(예: RISC-V 기반 Klessydra-fT03, LEON3-FT 등)의 사례를 종합할 때, 면적 제약이 허용된다면 <strong>RF에 대한 TMR 적용</strong>이 권장된다.24</p>
<ol>
<li><strong>공간적 격리(Spatial Isolation):</strong> TMR을 적용한 RF는 3개의 독립적인 뱅크(Bank 0, Bank 1, Bank 2)로 구성해야 하며, FPGA 배치 단계에서 이들을 서로 다른 클록 영역이나 물리적 블록(Pblock)에 할당하여 MBU가 다수결 투표를 무력화하지 못하도록 해야 한다.</li>
<li><strong>읽기 포트 투표(Read Port Voting):</strong> RF에서 데이터를 읽어내는 순간, 3개의 뱅크에서 읽은 값을 투표하여 ALU로 전달한다. 이는 연산 유닛이 항상 정제된 데이터를 받도록 보장한다.</li>
<li><strong>쓰기 포트 복제(Write Port Replication):</strong> RF에 데이터를 쓸 때는 3개의 뱅크에 동일한 데이터를 동시에 쓴다. 이때 쓰려는 데이터 역시 이전 단계에서 투표를 거친 값이어야 한다.</li>
</ol>
<p>ECC는 메모리(SRAM, DRAM)와 같이 밀도가 높은 저장소에는 효율적이지만, 빈번하게 읽고 쓰며 속도가 중요한 레지스터 파일에서는 인코딩/디코딩 오버헤드와 복잡한 예외 처리 로직으로 인해 TMR보다 시스템 복잡도를 높이고 성능을 저하시킬 수 있다. 따라서 “모든 내부 레지스터“라는 요구사항에 부합하고 최고 수준의 신뢰성을 달성하기 위해 RF 역시 완전한 분산 TMR로 설계하는 것이 타당하다.21</p>
<h2>5.  합성(Synthesis) 및 구현: 최적화와의 전쟁</h2>
<p>설계자가 RTL 레벨에서 완벽한 TMR 코드를 작성했다 하더라도, 논리 합성(Logic Synthesis) 도구는 이를 “비효율적인 중복 로직“으로 간주하여 제거하려는 강력한 경향을 보인다. 합성 툴의 기본 목표는 면적과 전력을 최소화하는 것이기 때문에, 입출력이 동일한 3개의 레지스터는 1개로 병합(Resource Sharing/Merging)되고, 동일한 논리를 수행하는 3개의 투표기는 하나의 와이어로 축소될 수 있다. 이를 막기 위해 벤더별, 툴별로 강력한 **합성 제약 조건(Synthesis Attributes/Constraints)**을 적용해야 한다.27</p>
<h3>5.1  Xilinx Vivado: <code>DONT_TOUCH</code>의 위력과 주의점</h3>
<p>Xilinx Vivado 합성기에서 TMR 로직 보존을 위한 가장 강력하고 권장되는 속성은 <code>DONT_TOUCH</code>이다. <code>KEEP</code>이나 <code>KEEP_HIERARCHY</code>도 존재하지만, <code>DONT_TOUCH</code>는 합성 단계뿐만 아니라 배치 및 배선(Place &amp; Route) 단계까지 속성이 전파(Forward-annotated)되어, 물리적 최적화 과정에서도 로직이 삭제되는 것을 방지한다.27</p>
<ul>
<li>
<p><strong>적용 대상:</strong></p>
</li>
<li>
<p><strong>Leaf Cells (Primitive):</strong> 플립플롭이나 LUT와 같은 기본 소자에 적용할 때 가장 안전하고 효과적이다.</p>
</li>
<li>
<p><strong>Hierarchical Cells (Modules):</strong> 모듈 전체에 적용할 경우, 모듈 내부의 경계 최적화(Boundary Optimization)까지 막아버려 타이밍 제약 만족을 어렵게 하거나 면적을 불필요하게 증가시킬 수 있다. 따라서 TMR이 적용된 특정 신호나 레지스터에 선별적으로 적용하는 것이 좋다.27</p>
</li>
<li>
<p><strong>Nets:</strong> 투표기 출력 넷에 적용하여 투표기 로직이 흡수(Absorbed)되거나 제거되는 것을 방지한다.</p>
</li>
<li>
<p><strong>문법 예시:</strong></p>
</li>
<li>
<p><strong>Verilog (RTL):</strong></p>
<pre><code class="language-Verilog">(* DONT_TOUCH = "TRUE" *) reg [31:0] data_r1, data_r2, data_r3;
(* DONT_TOUCH = "TRUE" *) wire voted_output;
</code></pre>
</li>
</ul>
<pre><code>
- **XDC (Constraint File):** RTL 수정이 불가능할 때 사용한다.

    ```Tcl
  set_property DONT_TOUCH TRUE
    set_property DONT_TOUCH TRUE [get_nets u_core/voter_out]
</code></pre>
<h3>5.2  Intel (Altera) Quartus: <code>preserve</code>와 <code>noprune</code></h3>
<p>Intel Quartus Prime에서는 레지스터 최적화를 방지하기 위해 <code>preserve</code> 속성을 사용한다. 이는 레지스터가 상수로 대체되거나(Constant propagation), 다른 레지스터와 병합(Merging)되는 것을 막는다. 하지만 팬아웃(Fan-out)이 없는 레지스터는 <code>preserve</code>를 써도 삭제될 수 있는데, 이를 막기 위해서는 <code>noprune</code> 속성을 추가로 사용해야 한다.32</p>
<ul>
<li>
<p><strong>속성 분류:</strong></p>
</li>
<li>
<p><code>preserve</code>: 레지스터를 상태 머신으로 추론하지 않고, 논리를 그대로 유지함. (Synopsys의 <code>syn_preserve</code>와 동일)</p>
</li>
<li>
<p><code>noprune</code>: 출력이 연결되지 않은 레지스터도 삭제하지 않음.</p>
</li>
<li>
<p><code>PRESERVE_REGISTER_SYN_ONLY</code>: 합성 단계에서만 보존하고, 피터(Fitter) 단계에서는 최적화를 허용함. TMR에는 부적합할 수 있음.33</p>
</li>
<li>
<p><strong>Verilog 문법:</strong></p>
</li>
</ul>
<p>Verilog</p>
<pre><code>(* preserve *) reg q_replica;
(* noprune *) reg dummy_reg; // 디버깅용 혹은 강제 유지용
</code></pre>
<h3>5.3  Synopsys &amp; Synplify: <code>syn_preserve</code>와 <code>syn_keep</code></h3>
<p>ASIC 설계를 위한 Synopsys Design Compiler나 FPGA용 Synplify Pro에서는 <code>syn_preserve</code>와 <code>syn_keep</code>이 표준적으로 사용된다. 두 속성의 차이를 명확히 구분해야 한다.28</p>
<ul>
<li>
<p><strong><code>syn_preserve</code>:</strong> 레지스터(Sequential Logic)에 적용된다. 중복 레지스터 제거 및 순차 최적화(Sequential Optimization)를 비활성화한다. TMR 레지스터(<span class="math math-inline">Q_1, Q_2, Q_3</span>)에 필수적이다.</p>
</li>
<li>
<p><strong><code>syn_keep</code>:</strong> 넷(Net)이나 와이어(Wire)에 적용된다. 해당 와이어를 기준으로 논리가 합쳐지는 것을 방지한다. 즉, 투표기 로직이 최적화에 의해 사라지지 않게 하려면 투표기 출력 와이어에 이 속성을 적용해야 한다. 이를 통해 와이어가 “Hard Net“으로 보존된다.35</p>
</li>
<li>
<p><strong>Verilog 문법:</strong></p>
<pre><code class="language-Verilog">(* syn_preserve = 1 *) reg q_tmr;
(* syn_keep = 1 *) wire voter_net;
</code></pre>
</li>
</ul>
<pre><code>
### 5.4  TMR 자동화 도구 활용: TMRG 및 SpyDrNet


수작업으로 모든 레지스터에 TMR을 적용하고 속성을 부여하는 것은 실수하기 쉽고 시간이 많이 소요된다. 이를 해결하기 위해 연구계와 산업계에서는 자동화 도구를 활용한다.

- **TMRG (Triple Modular Redundancy Generator):** CERN과 고에너지 물리학계(HEP)에서 개발한 도구로, Verilog/SystemVerilog 코드를 입력받아 자동으로 TMR 로직과 투표기를 삽입하고, 합성 제약 조건까지 생성해준다.18
- **SpyDrNet:** BYU에서 개발한 Python 기반 프레임워크로, 합성된 넷리스트(EDIF, JSON 등)를 직접 파싱하여 구조적으로 TMR을 삽입한다. 이는 합성 툴의 최적화를 우회할 수 있는 강력한 방법이다.15

## 6.  스크러빙(Scrubbing)과 TMR의 상호 보완적 통합


많은 엔지니어들이 TMR만 적용하면 시스템이 안전할 것이라고 오해하지만, TMR과 스크러빙은 서로 다른 계층의 오류를 다루는 상호 보완적 기술이다.

### 6.1  구성 메모리(CRAM) 스크러빙과 피드백 TMR의 차이


FPGA, 특히 SRAM 기반 FPGA(Xilinx Virtex/Kintex, UltraScale 등)는 사용자의 회로 정보(LUT 내용, 라우팅 연결)를 CRAM(Configuration RAM)에 저장한다. SEU가 CRAM을 타격하면 회로의 **기능(Functionality)이나 배선(Wiring)** 자체가 변경된다. 이를 수정하는 것이 **구성 스크러빙(Configuration Scrubbing)**이다.9

반면, 앞서 설명한 자기 수정(피드백) TMR은 사용자 로직 내의 플립플롭에 저장된 **데이터(Data/State)**를 수정하는 것이다.

- **상호 의존성:** 피드백 TMR이 정상 동작하려면 투표기와 피드백 경로의 회로가 온전해야 한다. 만약 CRAM에 오류가 발생하여 투표기 회로 자체가 망가지면, 피드백 TMR은 동작하지 않거나 잘못된 값을 무한히 피드백할 수 있다. 따라서 **"CRAM 스크러빙으로 하드웨어(그릇)를 복구하고, 피드백 TMR로 데이터(내용물)를 복구하는"** 이중 보호 전략이 필수적이다.16

### 6.2  스크러빙 아키텍처 구현


스크러빙은 크게 내부(Internal) 방식과 외부(External) 방식으로 나뉜다. 고신뢰성 시스템에서는 외부 스크러빙이 선호된다.

- **내부 스크러빙 (Internal Scrubbing):** FPGA 내부의 `ICAP` (Internal Configuration Access Port)와 SEM(Soft Error Mitigation) IP를 사용하여 스스로를 검사한다. 구현이 쉽지만, 스크러빙 로직 자체가 방사선에 피폭되어 오동작할 위험이 있다.39
- **외부 스크러빙 (External Scrubbing):** 방사선 내성이 강한(Rad-Hard) 별도의 반도체(예: Antifuse FPGA, Rad-Hard ASIC)가 주기적으로 FPGA의 구성 메모리를 읽어(Readback) 황금 참조(Golden Copy)와 비교하거나 ECC를 검사하여 수정한다. 이는 "Scrubber가 고장 나는" 상황을 방지하여 전체 시스템의 신뢰성을 극대화한다.40

## 7.  물리적 설계(Physical Design) 및 배치 제약


논리적으로 완벽한 TMR도 물리적 배치(Layout) 단계에서 취약점이 노출될 수 있다. 하나의 고에너지 입자는 실리콘 기판 상에서 수 마이크로미터의 트랙을 형성하며, 인접한 여러 셀에 영향을 미치는 MBU(Multi-Bit Upset)를 유발할 수 있다.

### 7.1  물리적 배치 분리 (Physical Isolation)


만약 TMR의 세 모듈($M_1, M_2, M_3$)이 FPGA의 동일한 슬라이스(Slice)나 인접한 CLB(Configurable Logic Block)에 배치된다면, 단일 입자 타격으로 두 개 이상의 모듈이 동시에 오류를 일으킬 수 있다. 이 경우 다수결 투표는 실패한다. 이를 방지하기 위해 다음과 같은 물리적 제약을 적용해야 한다.

- **Interleaving 및 Striping:** 레지스터 비트들을 물리적으로 섞어서 배치하거나, TMR 도메인별로 칩의 영역을 분할하여 배치한다. 예를 들어, $M_1$은 칩의 상단, $M_2$는 중단, $M_3$는 하단에 배치하는 식이다.25
- **Pblock (Partition Block) 제약:** Vivado와 같은 툴에서 `Pblock` 기능을 사용하여 각 TMR 도메인을 특정 좌표 범위 내에 강제로 할당함으로써 물리적 거리를 확보한다.
- **배치 알고리즘:** TMRG와 같은 도구는 합성 후 배치 제약 파일(XDC)을 생성하여 3중화된 플립플롭들이 서로 최소 거리 이상 떨어지도록 강제하는 기능을 제공하기도 한다.36

## 8.  성능 오버헤드 분석 및 검증 방법론


모든 레지스터에 TMR을 적용하는 것은 막대한 자원을 소모한다. 이를 정량적으로 분석하고 검증하는 것은 프로젝트의 타당성을 입증하는 데 중요하다.

### 8.1  오버헤드 분석 (Area, Power, Timing)


- **면적 (Area):** 플립플롭 개수는 정확히 3배가 되며, 투표기 로직(LUT)과 복잡해진 라우팅 자원까지 포함하면 전체 자원 사용량은 **3.5배에서 4배 이상** 증가한다. 이는 더 큰 용량의 FPGA나 더 넓은 다이(Die) 면적의 ASIC을 요구하며 비용 상승의 주원인이 된다.21
- **전력 (Power):** 3개의 모듈이 동시에 클록 스위칭을 하므로 동적 전력이 3배 이상 증가한다. 클록 게이팅(Clock Gating)을 적극적으로 활용해야 하나, 클록이 멈춘 동안에는 피드백 스크러빙이 동작하지 않으므로, 주기적인 'Wake-up &amp; Scrub' 정책이 필요하다.44
- **타이밍 (Timing):** 투표기는 데이터 경로상에 조합 논리 지연(Logic Delay)을 추가한다. 또한, 3중화로 인한 배선 혼잡도(Congestion) 증가는 라우팅 지연(Net Delay)을 심화시킨다. 일반적으로 TMR 적용 시 최대 동작 주파수($F_{max}$)는 **15%~25% 감소**하는 것으로 보고된다.2

### 8.2  검증 방법론: 결함 주입(Fault Injection)


설계된 TMR 아키텍처가 실제로 오류를 수정하는지 검증하기 위해 결함 주입(Fault Injection) 테스트가 필수적이다.

- **시뮬레이션 기반 결함 주입:** RTL 시뮬레이션 상에서 `force` 명령어를 사용하여 특정 레지스터 값을 강제로 반전시킨 후, 다음 클록 사이클에 값이 복구되는지, 시스템 출력이 유지되는지 확인한다.47
- **FPGA 내부 결함 주입:** SEM IP나 사용자 정의 로직을 통해 FPGA 동작 중 CRAM 비트를 고의로 뒤집거나(Configuration Upset), 플립플롭 값을 변경하여 시스템의 복원력을 실시간으로 테스트한다.39
- **방사선 빔 테스트 (Beam Testing):** 최종적으로는 양성자나 중성자 빔 시설(가속기)에서 실제 방사선에 노출시키며 단면적(Cross-section)과 FIT(Failures In Time)율을 측정하여 신뢰성 목표 달성 여부를 검증해야 한다.1

## 9.  결론 및 제언


모든 내부 레지스터에 삼중 모듈 중복성(TMR)을 적용하는 분산 TMR(DTMR) 아키텍처는 우주 및 극한 환경에서 시스템의 생존성을 보장하는 가장 강력하고 입증된 설계 방법론이다. 본 보고서를 통해 분석된 바와 같이, 성공적인 TMR 구현은 단순한 논리 복제를 넘어선다. **자기 수정(Self-Correcting) 피드백 루프**를 통해 오류 누적을 차단하고, **합성 제약 조건(Constraints)**을 통해 최적화 도구의 간섭을 배제하며, **물리적 배치 제약**을 통해 다중 비트 오류를 방어하고, **스크러빙(Scrubbing)**을 통해 하드웨어 무결성을 유지하는 다층적인 방어 전략이 유기적으로 결합되어야 한다.

비록 300% 이상의 면적 및 전력 오버헤드와 성능 저하가 수반되지만, 데이터 무결성과 임무의 연속성이 비용보다 우선시되는 미션 크리티컬 시스템에서는 타협할 수 없는 선택이다. 설계자는 이러한 오버헤드를 초기 단계에서 예측하여 충분한 자원을 가진 디바이스를 선정해야 하며, TMRG와 같은 자동화 도구와 철저한 결함 주입 검증을 통해 인간의 실수를 최소화하고 설계의 견고함을 입증해야 한다. 궁극적으로 이러한 TMR 아키텍처는 불확실한 방사선 환경 속에서도 시스템이 스스로를 치유하고 임무를 완수하게 하는 디지털 면역 체계의 핵심이 될 것이다.

## 10. 참고 자료


1. Functional Triple Modular Redundancy (FTMR) - ESA Microelectronics Section, http://microelectronics.esa.int/techno/fpga_003_01-0-2.pdf
2. Power, Delay and Area Comparisons of Majority Voters relevant to TMR Architectures - arXiv, https://arxiv.org/pdf/1603.07964
3. A Review on Soft Error Correcting Techniques of Aerospace-Grade Static RAM-Based Field-Programmable Gate Arrays - PMC - NIH, https://pmc.ncbi.nlm.nih.gov/articles/PMC11360524/
4. 8.2.3. Triple-Module Redundancy - Intel, https://www.intel.com/content/www/us/en/docs/programmable/683461/current/triple-module-redundancy.html
5. Triple modular redundancy - Wikipedia, https://en.wikipedia.org/wiki/Triple_modular_redundancy
6. A Self-Checking TMR Voter for Increased Reliability Consensus Voting in FPGAs - Sci-Hub, https://dacemirror.sci-hub.box/journal-article/774a6306ae25454b31d667c72a5f38b1/afzaal2018.pdf
7. design and characterization of a radiation tolerant triple mode redundant sense amplifier flip- flop - DTIC, https://apps.dtic.mil/sti/tr/pdf/ADA452668.pdf
8. Physical Design Methodologies for Soft Error Mitigation Using Redundancy | Request PDF, https://www.researchgate.net/publication/308728966_Physical_Design_Methodologies_for_Soft_Error_Mitigation_Using_Redundancy
9. Improving the Effectiveness of TMR Designs on FPGAs with SEU-Aware Incremental Placement, https://par.nsf.gov/servlets/purl/10110501/1000
10. New Developments in Error Detection and Correction Strategies for Critical Applications, https://ntrs.nasa.gov/api/citations/20160006688/downloads/20160006688.pdf
11. Verification of Triple Modular Redundancy (TMR) Insertion for Reliable and Trusted Systems - NASA Technical Reports Server (NTRS), https://ntrs.nasa.gov/api/citations/20160001756/downloads/20160001756.pdf
12. a) Combinatorial logic registered in a TMR'ed flip-flop with voting. b)... - ResearchGate, https://www.researchgate.net/figure/a-Combinatorial-logic-registered-in-a-TMRed-flip-flop-with-voting-b-Distributed-TMR_fig5_273440642
13. Partial TMR for Improving the Soft Error Reliability of SRAM-Based FPGA Designs - NSF PAR, https://par.nsf.gov/servlets/purl/10231638
14. Triple modular redundancy Flip-Flop (TMR FF) votes between three copies... | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/Triple-modular-redundancy-Flip-Flop-TMR-FF-votes-between-three-copies-of-FFs-with-the_fig2_352871091
15. Toggle TMR Example — SpyDrNet TMR 1.0.0 documentation, https://byuccl.github.io/spydrnet-tmr/docs/1.0/auto_examples/basic/toggle_tmr.html
16. Strategies for Removing Common Mode Failures From TMR Designs Deployed on SRAM FPGAs - nsf shrec, https://www.nsf-shrec.org/sites/default/files/2024-03/Strategies-for-Removing-Common-Mode-Failures-From-TMR-Designs-Deployed-on-SRAM-FPGAs.pdf
17. Single Event Effects Mitigation Techniques Report - Federal Aviation Administration, https://www.faa.gov/sites/faa.gov/files/aircraft/air_cert/design_approvals/air_software/TC-15-62.pdf
18. Single Event Upsets mitigation techniques - CERN Indico, https://indico.cern.ch/event/465343/attachments/1256299/1854682/tmrg_skulis_ep_ese.pdf
19. Exploiting Existing Copies in Register File for Soft Error Correction - University of Edinburgh Research Explorer, https://www.research.ed.ac.uk/files/24669993/Final_Manuscript_Preprint_WORD_afterProof_2.pdf
20. To Improve Register File Integrity against Soft Errors By using self - Immunity Technique - International Journal of Latest Trends in Engineering and Technology, https://www.ijltet.org/wp-content/uploads/2013/05/30.pdf
21. Error correction code (ECC) and triple modular redundancy (TMR). - ResearchGate, https://www.researchgate.net/figure/Error-correction-code-ECC-and-triple-modular-redundancy-TMR_fig9_258649959
22. Error correction code (ECC) and triple modular redundancy (TMR). - ResearchGate, https://www.researchgate.net/figure/Error-correction-code-ECC-and-triple-modular-redundancy-TMR_fig5_224240368
23. Error Masking Technique For Register File In Xilinx FPGA - JETIR.org, https://www.jetir.org/papers/JETIRCV06041.pdf
24. Evaluation of Dynamic Triple Modular Redundancy in an Interleaved-Multi-Threading RISC-V Core - MDPI, https://www.mdpi.com/2079-9268/13/1/2
25. Design and Evaluation of Buffered Triple Modular Redundancy in Interleaved-Multi-Threading Processors - IRIS, https://iris.uniroma1.it/bitstream/11573/1669461/1/Barbirotta_Design_2022.pdf
26. Analysis of Soft Error Mitigation Techniques for Register Files in IBM Cu-08 90nm Technology | Request PDF - ResearchGate, https://www.researchgate.net/publication/224716119_Analysis_of_Soft_Error_Mitigation_Techniques_for_Register_Files_in_IBM_Cu-08_90nm_Technology
27. DONT_TOUCH - 2025.1 English - UG903, https://docs.amd.com/r/en-US/ug903-vivado-using-constraints/DONT_TOUCH
28. 3.4.16. Preserve Registers - Intel, https://www.intel.com/content/www/us/en/docs/programmable/683283/18-1/preserve-registers.html
29. Addressing Sequential Elements Optimization in the VLSI Chip Design - Cadence Blogs, https://community.cadence.com/cadence_blogs_8/b/di/posts/addressing-sequential-elements-optimization-in-the-vlsi-chip-design
30. DONT_TOUCH - 2025.1 English - UG901, https://docs.amd.com/r/en-US/ug901-vivado-synthesis/DONT_TOUCH
31. What's the difference among "keep" "dont_touch" and "mark_debug"? When to use them?, https://adaptivesupport.amd.com/s/question/0D52E00006iHkE6SAK/whats-the-difference-among-keep-donttouch-and-markdebug-when-to-use-them?language=en_US
32. preserve VHDL Synthesis Attribute - Intel, https://www.intel.com/content/www/us/en/programmable/quartushelp/17.0/hdl/vhdl/vhdl_file_dir_preserve.htm
33. 2.3.1.1. Preserving Registers During Synthesis - Intel, https://www.intel.com/content/www/us/en/docs/programmable/683236/22-1/preserving-registers-during-synthesis.html
34. preserve Verilog HDL Synthesis Attribute - Intel, https://www.intel.com/content/www/us/en/programmable/quartushelp/17.0/hdl/vlog/vlog_file_dir_preserve.htm
35. How to prevent Synplify Pro changing the net name? - Adaptive Support, https://adaptivesupport.amd.com/s/question/0D52E00006hpRewSAE/how-to-prevent-synplify-pro-changing-the-net-name?language=en_US
36. Digital synthesis for rad-hard components - IN2P3 Events Directory (Indico), https://indico.in2p3.fr/event/14305/contributions/17791/attachments/14702/18015/kulis_tmgr_in2p3.pdf
37. A Review on Soft Error Correcting Techniques of Aerospace-Grade Static RAM-Based Field-Programmable Gate Arrays - MDPI, https://www.mdpi.com/1424-8220/24/16/5356
38. TMR registers with Voters and Scrubbing [6] - ResearchGate, https://www.researchgate.net/figure/TMR-registers-with-Voters-and-Scrubbing-6_fig3_261177544
39. Generic Scrubbing-based Architecture for Custom Error Correction Algorithms - cfaed, https://cfaed.tu-dresden.de/files/user/akumar/publications/RSP2015_final.pdf
40. Self-reference Scrubber for TMR Systems Based on Xilinx Virtex FPGAs - CORE, https://core.ac.uk/download/pdf/148662057.pdf
41. (PDF) Redundant-Configuration Scrubbing of SRAM-based FPGAs - ResearchGate, https://www.researchgate.net/publication/318668330_Redundant-Configuration_Scrubbing_of_SRAM-based_FPGAs
42. A Rad Hard ASIC Design Approach: Triple Modular Redundancy (TMR), https://www.asicnorth.com/blog/rad-hard-asic-design-approach/
43. Categorization and SEU Fault Simulations of Radiation-Hardened-by-Design Flip-Flops, https://www.mdpi.com/2079-9292/10/13/1572
44. EFFICIENT SOFT ERROR TOLERANT FLIP-FLOP CIRCUITS AND DESIGN METHODOLOGY FOR CMOS DIGITAL SYSTEMS, https://www.research.unipd.it/retrieve/469c21d5-b25c-498e-bcfe-3c9093afd1ad/final_thesis_abhishek_jain.pdf
45. Performance Testing of the Triple Modular Redundancy Mitigation Circuit Test Environment Implementation in Field Programmable Gate Array Structures - MDPI, https://www.mdpi.com/2076-3417/14/19/8604
46. Synchronization Voter Insertion Algorithms for FPGA Designs Using Triple Modular Redundancy - BYU ScholarsArchive, https://scholarsarchive.byu.edu/etd/2068/
47. Circuit VR: Redundant Flip Flops And Voting Logic | Hackaday, https://hackaday.com/2019/01/25/circuit-vr-redundant-flip-flops-and-voting-logic/
48. Soft error mitigation and recovery of SRAM-based FPGAs using brain-inspired hybrid-grained scrubbing mechanism - Frontiers, https://www.frontiersin.org/journals/computational-neuroscience/articles/10.3389/fncom.2023.1268374/full</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>