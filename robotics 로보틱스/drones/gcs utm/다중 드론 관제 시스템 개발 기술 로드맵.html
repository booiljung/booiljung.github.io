<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:다중 드론 관제 시스템 개발 기술 로드맵</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>다중 드론 관제 시스템 개발 기술 로드맵</h1>
                    <nav class="breadcrumbs"><a href="../../../index.html">Home</a> / <a href="../../index.html">로봇공학 (Robotics)</a> / <a href="../index.html">드론 (Drones)</a> / <a href="index.html">지상 관제 시스템 (GCS)</a> / <span>다중 드론 관제 시스템 개발 기술 로드맵</span></nav>
                </div>
            </header>
            <article>
                <h1>다중 드론 관제 시스템 개발 기술 로드맵</h1>
<h2>1.  시스템 아키텍처 및 기술 기반</h2>
<h3>1.1  아키텍처 청사진: 분산형 서비스 지향 접근법</h3>
<p>본 다중 드론 관제 시스템의 핵심 아키텍처는 느슨하게 결합된(loosely coupled) 독립 서비스들의 집합으로 설계된다. 각 서비스는 데이터 중심 미들웨어인 DDS(Data Distribution Service)를 통해 통신하며, 이는 시스템의 유연성, 확장성, 그리고 강건함(robustness)을 보장하는 핵심 원칙이다. 이 아키텍처는 사용자가 요구한 서버-클라이언트 모드와 독립형(standalone) 현장 PC 모드라는 이중 운영 환경을 본질적으로 지원한다.</p>
<h4>1.1.1  서버-클라이언트 운영 모드</h4>
<p>이 모드에서 드론, 도크, 그리고 지상관제스테이션(Ground Control Station, GCS)은 중앙에 위치한 백엔드 서비스 스위트(suite)와 통신한다. 이는 대규모 드론 편대 관리, 중앙 집중식 데이터 수집 및 분석, 그리고 포괄적인 임무 통제를 위한 표준 운영 방식이다. 모든 데이터는 중앙 서버로 집결되어 처리 및 저장되므로, 전체 작전 상황에 대한 통합적인 가시성을 확보할 수 있다.</p>
<h4>1.1.2  독립형(현장 PC) 운영 모드</h4>
<p>전술적 환경이나 네트워크 연결이 제한된 현장에서의 작전을 위해, GCS 애플리케이션과 필수 서비스들은 단일 현장 PC에서 구동된다. 이 모드에서 GCS는 중앙 서버 없이 현장의 드론과 직접 통신한다. 통신은 Wi-Fi, 5G 또는 기타 전술 데이터 링크를 통해 P2P(Peer-to-Peer) 방식으로 이루어진다. 이는 네트워크 인프라에 대한 의존성을 제거하여 작전의 자율성과 신속성을 극대화한다.</p>
<h4>1.1.3  아키텍처의 통일성</h4>
<p>두 운영 모드를 지원하는 핵심은 드론과 GCS에 탑재되는 핵심 소프트웨어 스택이 동일하다는 점이다. 아키텍처의 유일한 차이점은 DDS 네트워크 구성에 있다. 독립형 모드에서는 로컬 링크를 통한 P2P 통신이 이루어지는 반면, 서버-클라이언트 모드에서는 DDS-to-WAN 브리지를 통해 중앙 서버로 통신이 라우팅된다. 이처럼 통신 미들웨어를 통해 운영 환경을 추상화함으로써, 애플리케이션 로직의 변경 없이 다양한 시나리오에 대응할 수 있는 고도의 유연성을 확보한다.</p>
<h3>1.2  Rust의 장점: 성능, 안전성, 동시성을 기반으로 한 견고한 토대 구축</h3>
<p>본 시스템의 개발 언어로 Rust를 선택한 것은 복잡하고 미션 크리티컬한 시스템의 요구사항을 충족시키기 위한 전략적 결정이다. Rust는 고성능 백엔드 서비스부터 자원이 제한된 임베디드 시스템에 이르기까지, 프로젝트의 전 영역에 걸쳐 일관된 기술 스택을 제공하며 이는 연구 자료에서도 강력하게 뒷받침된다.1</p>
<h4>1.2.1  성능 저하 없는 메모리 안전성</h4>
<p>Rust의 가장 독보적인 특징은 소유권(ownership) 모델과 빌림 검사기(borrow checker)를 통해 컴파일 시점에 메모리 관련 버그를 원천적으로 제거하는 것이다.1 널 포인터 역참조, 버퍼 오버플로우, 데이터 경쟁(data race)과 같은 전통적인 시스템 프로그래밍 언어(C/C++)에서 흔히 발생하는 치명적인 오류들을 사전에 방지할 수 있다. 이는 단순히 개발 편의성을 높이는 것을 넘어, 런타임 실패가 심각한 결과로 이어질 수 있는 드론 관제 시스템의 안정성을 근본적으로 향상시키는 핵심 요소이다. 특히, 이러한 안전성은 가비지 컬렉터(garbage collector) 없이 달성되므로, 드론 제어 및 실시간 영상 처리에 필수적인 결정론적(deterministic) 성능을 보장한다.2</p>
<h4>1.2.2  두려움 없는 동시성(Fearless Concurrency)</h4>
<p>다중 드론 관제 시스템은 수많은 드론으로부터 들어오는 텔레메트리, 영상, 명령어, AI 분석 결과 등 다수의 데이터 스트림을 동시에 처리해야 한다. Rust는 컴파일 시점에 데이터 경쟁을 방지함으로써, 개발자가 다중 스레드 애플리케이션을 훨씬 더 안전하고 신뢰성 있게 구축할 수 있도록 지원한다.1 이는 복잡한 동시성 문제로 인한 잠재적 버그를 줄여 개발 속도를 높이고, 최종 시스템의 안정성을 극대화하는 데 직접적으로 기여한다.</p>
<h4>1.2.3  풍부한 생태계와 도구</h4>
<p>Rust의 패키지 매니저이자 빌드 도구인 <code>cargo</code>는 의존성 관리와 프로젝트 빌드를 매우 효율적으로 만든다.5 또한, 비동기 처리를 위한 Embassy, 다양한 마이크로컨트롤러를 위한 하드웨어 추상화 계층(HAL) 등 성장하는 임베디드 생태계는 드론 온보드 소프트웨어와 지상 시스템 소프트웨어를 모두 개발하는 데 필요한 강력한 기반을 제공한다.8</p>
<h4>1.2.4  아키텍처 강화자로서의 Rust</h4>
<p>Rust의 선택은 단순히 개별적인 성능이나 안전성 확보를 넘어선다. Rust의 엄격한 컴파일러는 아키텍처 설계 단계에서부터 개발자에게 데이터 소유권과 접근 패턴에 대해 명시적으로 고민하도록 강제한다. 이는 복잡한 분산 시스템에서 흔히 발생하는 문제의 근원인, C++ 등에서 허용되는 유연하지만 규율 없는 메모리 관리나 동시성 패턴을 방지하는 역할을 한다.10 결과적으로, Rust는 서비스, 스레드, 모듈 간에 명확하고 잘 정의된 API를 사용하도록 유도하며, ‘영리하지만 안전하지 않은’ 지름길을 차단한다. 이처럼 컴파일러가 ’선임 아키텍트’의 역할을 수행함으로써, 대규모 미션 크리티컬 분산 시스템의 장기적인 유지보수성과 신뢰성에 필수적인 설계 규율을 강제한다. 이는 기술 부채를 줄이고 개발 후반부에 발견될 수 있는 미묘하지만 치명적인 버그의 위험을 크게 낮춘다.</p>
<h3>1.3  시스템의 신경망 DDS: 실시간, 탄력적, 분산형 통신</h3>
<p>시스템 내 서비스 간의 통신은 OMG(Object Management Group)의 데이터 중심 발행-구독(publish-subscribe) 미들웨어 표준인 DDS(Data Distribution Service)를 통해 이루어진다. DDS는 단순한 메시지 큐가 아니라, 미션 크리티컬 실시간 시스템을 위해 설계된 가상의 ’글로벌 데이터 공간’이다.11</p>
<h4>1.3.1  발행-구독 모델</h4>
<p>DDS에서 데이터 생산자(예: 드론의 GPS 센서)는 특정 ‘토픽’(예: <code>drone/123/position</code>)으로 데이터를 발행한다. 데이터 소비자(예: GCS 지도 디스플레이, 서버의 임무 로거)는 해당 토픽을 구독하여 데이터를 수신한다. 이 모델의 핵심은 생산자와 소비자가 서로의 존재, 위치, 또는 수를 알 필요가 없다는 점이다.11 이러한 공간적, 시간적 분리(decoupling)는 시스템 아키텍처 유연성의 핵심이다.</p>
<h4>1.3.2  본 프로젝트를 위한 DDS의 핵심 기능</h4>
<ul>
<li><strong>저지연 및 고처리량:</strong> 실시간 제어 및 데이터 스트리밍에 필수적이다.11</li>
<li><strong>서비스 품질(QoS):</strong> DDS는 신뢰성, 지속성, 마감 시간 등에 대한 세밀한 제어를 제공하여, 덜 중요한 텔레메트리 데이터보다 중요한 명령 및 제어 데이터의 우선순위를 높일 수 있다.15</li>
<li><strong>분산 아키텍처:</strong> P2P 통신에 중앙 브로커가 필요 없어 단일 장애점(single point of failure)과 성능 병목 현상을 제거한다. 이는 독립형 현장 모드에 이상적이다.12</li>
<li><strong>보안:</strong> DDS는 전송 중인 데이터를 보호하기 위해 인증, 접근 제어, 암호화를 위한 보안 플러그인을 내장하고 있다.11</li>
</ul>
<h4>1.3.3  권장 Rust 구현: Zenoh + CycloneDDS</h4>
<p>Rust로 작성된 Zenoh 프로토콜은 이동 중인 데이터와 정지된 데이터를 통합하도록 설계되었으며, 다양한 네트워크 유형을 연결할 수 있는 강력한 기능을 제공한다.17 Zenoh는 성숙하고 성능이 뛰어난 오픈 소스 DDS 구현체인 CycloneDDS를 활용하는 DDS 플러그인을 제공한다.19 이 조합은 고성능의 네이티브 Rust 솔루션을 제공하며, Zenoh 라우터를 통해 전술적 DDS 네트워크(예: 드론과 GCS 간의 로컬 Wi-Fi)와 인터넷(WAN)을 통한 백엔드 DDS 네트워크를 원활하게 연결할 수 있다. 이는 이중 운영 모드 아키텍처를 완벽하게 구현하는 이상적인 방법이다.21</p>
<h3>1.4  미션 데이터 영속성을 위한 PostgreSQL: 견고하고 확장 가능한 기반</h3>
<p>미션 수행 중 생성되는 구조화된 데이터를 저장하기 위해, 성숙하고 신뢰성 높으며 기능이 풍부한 오픈 소스 관계형 데이터베이스인 PostgreSQL을 채택한다.</p>
<h4>1.4.1  스키마 설계 전략</h4>
<p>하이브리드 데이터 모델링 접근법을 사용한다.</p>
<ul>
<li><strong>관계형 코어 (스타 스키마):</strong> 핵심 운영 엔티티(드론, 도크, 임무, 사용자 등)에 대해서는 분석 쿼리에 최적화된 스타 스키마를 권장한다.22 이는 <code>drones</code>, <code>docks</code>, <code>mission_templates</code>, <code>users</code>와 같은 차원 테이블과 <code>mission_executions</code>, <code>flight_logs</code>, <code>analysis_results</code>와 같은 팩트 테이블로 구성된다.</li>
<li><strong>시계열 확장 (TimescaleDB):</strong> 드론 텔레메트리(위치, 자세, 배터리 등)는 고주파 시계열 데이터이다. 이를 표준 관계형 테이블에 저장하는 것은 비효율적이다. Telegraf PostgreSQL 플러그인 문서는 이러한 유형의 데이터를 효율적으로 처리하기 위해 PostgreSQL 확장인 TimescaleDB와 하이퍼테이블(hypertable)의 가치를 강조한다.23 이는 효율적인 파티셔닝과 쿼리를 가능하게 하는 핵심적인 최적화이다.</li>
</ul>
<h4>1.4.2  데이터 타입 활용</h4>
<p>PostgreSQL의 풍부한 데이터 타입을 적극적으로 활용한다. 비행 경로, 지오펜스(geofence) 등 지리 공간 데이터를 저장하기 위해 PostGIS 확장을 사용하고, 임무 매개변수나 비정형 센서 데이터와 같이 유연한 구조가 필요한 데이터는 JSONB 타입을 사용한다.22</p>
<h2>2.  온보드 시스템 개발: 자율적 엣지</h2>
<p>이 섹션은 드론 자체에 탑재되는 소프트웨어 및 하드웨어 스택 개발을 상세히 다룬다. 이는 자율 운영과 데이터 보안에 있어 가장 중요한 구성 요소이다.</p>
<h3>2.1  임무 컴퓨터 선정: 비교 불가의 AI 성능을 위한 NVIDIA Jetson</h3>
<p>사용자 요구사항은 영상 분석을 위한 ’경량 고성능 임무 컴퓨터’를 명시하고 있으며, 이는 강력한 병렬 처리 능력, 즉 고성능 GPU의 필요성을 직접적으로 시사한다.</p>
<h4>2.1.1  하드웨어 비교 분석</h4>
<p>연구 자료들은 NVIDIA Jetson 제품군과 Raspberry Pi와 같은 대안 간의 명확한 차이점을 보여준다.24</p>
<ul>
<li><strong>Raspberry Pi:</strong> 강력한 CPU, 저렴한 비용, 내장 연결성을 갖춘 범용 컴퓨팅에 탁월하다.25 하지만 AI 가속기를 사용하더라도 AI 성능은 현저히 낮으며, 성숙한 CUDA/TensorRT 소프트웨어 생태계가 부족하다.</li>
<li><strong>NVIDIA Jetson (Orin Nano/Nano):</strong> 엣지 AI를 위해 특별히 제작되었다. 핵심 장점은 CUDA 코어가 내장된 NVIDIA GPU로, 객체 탐지와 같은 AI 워크로드에서 수십 배 높은 성능을 제공한다(Nano의 경우 최대 472 GFLOPS, Orin Nano는 훨씬 더 높음).25 이는 단순히 속도 향상을 넘어, 더 복잡하고 정확한 AI 모델을 실시간으로 사용할 수 있게 만든다.</li>
</ul>
<h4>2.1.2  최종 결정 및 근거</h4>
<p><strong>NVIDIA Jetson Orin Nano</strong>를 임무 컴퓨터 플랫폼으로 최종 권장한다. 기존 Jetson Nano도 충분한 성능을 제공하지만, Orin 시리즈는 상당한 성능 향상과 현대적인 아키텍처를 제공하여 AI 모델이 진화함에 따른 미래 대응력을 확보한다.32 CUDA, cuDNN, 그리고 특히 TensorRT와 같은 전체 NVIDIA 소프트웨어 스택을 활용할 수 있다는 점은 영상 분석 요구사항을 직접적으로 충족시키는 결정적인 요소이다. Wi-Fi 모듈이 내장되어 있지 않다는 점은 M.2 모듈을 통해 쉽게 해결할 수 있는 사소한 문제이다.24</p>
<p><strong>표 1: 임무 컴퓨터 하드웨어 비교</strong></p>
<table><thead><tr><th>기능</th><th>Raspberry Pi 5</th><th>NVIDIA Jetson Nano (Legacy)</th><th>NVIDIA Jetson Orin Nano (8GB)</th></tr></thead><tbody>
<tr><td><strong>CPU</strong></td><td>Quad-core ARM Cortex-A76</td><td>Quad-core ARM Cortex-A57</td><td>6-core ARM Cortex-A78AE</td></tr>
<tr><td><strong>GPU</strong></td><td>VideoCore VII</td><td>128-core NVIDIA Maxwell</td><td>1024-core NVIDIA Ampere</td></tr>
<tr><td><strong>AI 성능</strong></td><td>~13 TOPS (AI Kit 사용 시)</td><td>472 GFLOPS</td><td>40 TOPS</td></tr>
<tr><td><strong>RAM</strong></td><td>2GB, 4GB, 8GB LPDDR4X</td><td>4GB LPDDR4</td><td>8GB LPDDR5</td></tr>
<tr><td><strong>연결성</strong></td><td>Wi-Fi/BT 내장</td><td>M.2 Key E 확장 필요</td><td>M.2 Key E 확장 필요</td></tr>
<tr><td><strong>전력 소비</strong></td><td>3-5W</td><td>5-10W</td><td>7-15W</td></tr>
<tr><td><strong>소프트웨어 생태계</strong></td><td>광범위한 범용 Linux 지원</td><td>NVIDIA JetPack (CUDA, cuDNN, TensorRT)</td><td>NVIDIA JetPack (CUDA, cuDNN, TensorRT)</td></tr>
<tr><td><strong>예상 비용</strong></td><td>상대적으로 저렴</td><td>중간</td><td>상대적으로 높음</td></tr>
</tbody></table>
<p>이 표는 드론의 ‘두뇌’ 역할을 할 하드웨어 선택이 범용 성능(CPU), AI 성능(GPU), 전력 소비, 비용 간의 트레이드오프임을 명확히 보여준다. 본 프로젝트의 핵심 요구사항인 실시간 영상 분석을 위해서는, Jetson Orin Nano의 압도적인 AI 성능이 Raspberry Pi의 CPU 속도나 내장 연결성 등의 장점을 상회하므로, Jetson Orin Nano를 선택하는 것이 가장 합리적이다.</p>
<h3>2.2  임베디드 Rust 환경 및 드론 통합</h3>
<h4>2.2.1  운영 체제 및 개발 환경</h4>
<p>Jetson은 특화된 Ubuntu 버전인 Jetson Linux를 실행하므로, Rust의 표준 라이브러리(<code>std</code>)를 사용할 수 있다. 이는 <code>no_std</code> 베어메탈 환경에 비해 개발을 현저히 단순화한다.35 네트워킹, 파일 시스템 접근, 스레딩 등을 위해 표준 라이브러리를 활용하면서도 고성능 코드를 작성할 수 있다.</p>
<h4>2.2.2  하드웨어 추상화 및 통합</h4>
<ul>
<li>
<p><strong>Pixhawk 통합:</strong> Pixhawk 비행 컨트롤러와의 통신은 UART 연결을 통해 MAVLink 프로토콜로 이루어진다. <code>mavlink</code> 또는 <code>mavrust</code>와 같은 성숙한 Rust MAVLink 라이브러리를 사용한다.</p>
</li>
<li>
<p><strong>DJI 통합:</strong> DJI 드론(Mavic)과의 통합은 DJI Onboard SDK를 사용해야 한다. 이 SDK는 일반적으로 C++ 라이브러리로 제공되므로, Rust의 FFI(Foreign Function Interface)와 <code>bindgen</code> 도구를 사용하여 SDK 기능에 대한 안전한 Rust 래퍼(wrapper)를 생성한다.8 이는</p>
</li>
</ul>
<p><code>unsafe</code> 코드의 신중한 관리가 필요한 중요한 통합 작업이다.</p>
<h4>2.2.3  핵심 온보드 서비스</h4>
<p>Jetson에서는 단일 다중 스레드 Rust 애플리케이션이 실행된다. 이 애플리케이션의 책임은 다음과 같다:</p>
<ol>
<li>비행 컨트롤러와 통신 (MAVLink/DJI SDK)</li>
<li>텔레메트리 및 상태 데이터를 DDS 토픽으로 발행</li>
<li>GCS로부터의 명령 및 제어 DDS 토픽 구독</li>
<li>영상 캡처 및 처리 파이프라인 관리</li>
<li>KCMVP 인증 암호화 모듈 실행</li>
</ol>
<h3>2.3  KCMVP 암호화 모듈 통합 전략</h3>
<h4>2.3.1  과제 분석</h4>
<p>KCMVP(한국형 암호모듈 검증 프로그램)는 대한민국 정부 및 공공기관 시스템에 필수적인 국가 암호모듈 검증 제도이다.37 현재 KCMVP 인증을 받은 네이티브 Rust 암호화 라이브러리는 존재하지 않는다. 인증된 모듈은 일반적으로 C/C++ 공유 또는 정적 라이브러리 형태로 제공된다 (FIPS 인증 OpenSSL 라이브러리와 유사).41</p>
<h4>2.3.2  해결책: FFI(Foreign Function Interface)</h4>
<ol>
<li><strong>인증 모듈 확보:</strong> 국내 벤더(예: Fasoo 40)로부터 Jetson의 아키텍처인 ARM64(aarch64)용 Linux에서 사용 가능한 C 호환 API와 라이브러리 파일(<code>.so</code> 또는 <code>.a</code>)을 제공하는 KCMVP 인증 암호화 모듈을 확보해야 한다.</li>
<li><strong>바인딩 생성:</strong> <code>bindgen</code> 도구를 사용하여 벤더가 제공하는 C 헤더 파일로부터 <code>unsafe</code> Rust 함수 시그니처를 자동으로 생성한다.36</li>
<li><strong>안전한 래퍼 개발:</strong> <code>kcmvp-wrapper</code>와 같은 전용 Rust 크레이트(crate)를 생성한다. 이 크레이트는 생성된 원시 바인딩을 포함하고, 애플리케이션의 나머지 부분에 안전하고 관용적인 Rust API(예: <code>encrypt(data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, KcmvpError&gt;</code>)를 제공한다.</li>
</ol>
<h4>2.3.3  ’Unsafe Abstraction’을 통한 보안 경계 설정</h4>
<p>FFI를 사용하는 것은 Rust 컴파일러에게 “여기서의 메모리 안전성은 내가 책임지겠다“고 선언하는 <code>unsafe</code> 블록을 필요로 한다. 이는 Rust의 핵심 안전 보장을 우회하는 행위이다.1 만약</p>
<p><code>unsafe</code> FFI 호출이 주 애플리케이션 로직 전반에 흩어져 있다면, 이는 보안 감사를 불가능하게 만들고 위험을 시스템 전체로 확산시키는 재앙이 될 것이다. KCMVP 요구사항은 이 시스템이 민감 데이터를 다루며 보안 감사의 대상이 될 가능성이 높다는 것을 의미한다.37</p>
<p>따라서, <code>kcmvp-wrapper</code>라는 전용 크레이트를 만드는 것은 단순한 코드 구성을 넘어, 필수적인 보안 아키텍처 결정이다. 이 크레이트는 ‘보안 격리 경계’ 역할을 한다. C 암호화 라이브러리에 대한 모든 <code>unsafe</code> FFI 호출은 이 작고 잘 정의된 단일 모듈 내에 국한된다. 이 래퍼 크레이트의 공개 API는 완전히 안전한 Rust로 구성된다. 이를 통해 주 애플리케이션은 단 하나의 <code>unsafe</code> 블록도 없이 KCMVP 암호화를 사용할 수 있으며, 코드베이스의 99% 이상에서 Rust의 안전 보장을 유지할 수 있다. 이러한 추상화는 가장 중요하고 위험한 코드를 검증 가능한 단일 구성 요소로 격리함으로써 시스템의 감사 가능성, 유지보수성, 그리고 보안을 극적으로 향상시킨다. 이 전략은 개발 계획에서 타협할 수 없는 부분이어야 한다.</p>
<h2>3.  지상 관제 및 백엔드 인프라</h2>
<p>이 섹션은 운영자가 직접 상호작용하는 소프트웨어 구성 요소와 편대 관리를 가능하게 하는 중앙 서버 인프라를 다룬다.</p>
<h3>3.1  지상관제스테이션(GCS) 아키텍처</h3>
<h4>3.1.1  기술 스택</h4>
<p>Rust 바인딩이 우수한 크로스플랫폼 GUI 프레임워크를 권장한다. 웹 기술을 UI에 활용하는 Tauri 또는 성능 중심의 egui가 좋은 선택지가 될 수 있다. 선택은 UI의 복잡성과 요구되는 성능 수준에 따라 결정된다.</p>
<h4>3.1.2  핵심 기능</h4>
<p>GCS는 주 사용자 인터페이스로서 다음 기능을 반드시 제공해야 한다:</p>
<ul>
<li>드론 위치 및 텔레메트리를 표시하는 실시간 지도 디스플레이</li>
<li>저지연 영상 피드 디스플레이</li>
<li>임무 계획 및 업로드 도구 (경로점 기반, 지역 스캔 등)</li>
<li>수동 드론 제어 오버라이드 (필요시)</li>
<li>AI 분석 결과 표시 (예: 영상 위에 경계 상자 표시)</li>
</ul>
<h4>3.1.3  이중 모드 운영</h4>
<p>GCS 애플리케이션은 단일 코드베이스로 개발된다. 시작 시 구성에 따라 로컬 P2P DDS 도메인(독립형 모드)에 연결하거나 원격 서버의 DDS 도메인(서버-클라이언트 모드)에 연결하도록 설정할 수 있다.</p>
<h3>3.2  Rust 기반 백엔드 마이크로서비스</h3>
<h4>3.2.1  프레임워크</h4>
<p>백엔드 서비스 구축에는 <code>tokio</code> 기반의 고성능 비동기 웹 프레임워크인 <code>actix-web</code> 또는 <code>axum</code>을 권장한다.</p>
<h4>3.2.2  서비스 분할</h4>
<ol>
<li><strong>드론 게이트웨이 서비스:</strong> 드론으로부터의 연결을 관리하고 인증하며, 외부 네트워크와 내부 DDS 데이터 공간 간의 브리지 역할을 한다.</li>
<li><strong>임무 관리 서비스:</strong> 임무 계획에 대한 CRUD(생성, 읽기, 갱신, 삭제) 작업을 처리하고, 계획을 검증하며, 드론에 할당한다.</li>
<li><strong>데이터 수집 및 아카이빙 서비스:</strong> 모든 관련 DDS 토픽(텔레메트리, 영상 메타데이터, 로그)을 구독하고 PostgreSQL 데이터베이스에 데이터를 영속화한다.</li>
<li><strong>API 및 사용자 관리 서비스:</strong> GCS(서버-클라이언트 모드) 및 다른 잠재적 클라이언트를 위한 REST/GraphQL API를 제공하고, 사용자 인증 및 권한 부여를 처리한다.</li>
<li><strong>영상 분석 서비스 (선택적 후처리):</strong> 실시간 분석은 드론에서 수행되지만, 이 서비스는 저장된 영상에 대해 더 계산 집약적인 비실시간 분석을 수행할 수 있다.</li>
</ol>
<h3>3.3  데이터베이스 스키마 및 데이터 관리</h3>
<h4>3.3.1  상세 스키마 제안</h4>
<ul>
<li><code>drones</code> (drone_id, drone_type, mission_computer_id, registration_info)</li>
<li><code>docks</code> (dock_id, location_gis, status, associated_drone_id)</li>
<li><code>missions</code> (mission_id, name, description, created_by, mission_plan_jsonb)</li>
<li><code>flights</code> (flight_id, drone_id, mission_id, start_time, end_time, flight_path_gis)</li>
<li><code>telemetry</code> (HYPERTABLE: time, flight_id, location_gis, altitude, velocity, battery_percent)</li>
<li><code>video_metadata</code> (video_id, flight_id, start_time, duration, storage_uri)</li>
<li><code>detection_events</code> (event_id, video_id, timestamp, object_class, confidence, bounding_box_jsonb)</li>
</ul>
<h4>3.3.2  데이터 흐름</h4>
<p>데이터 수집 서비스가 데이터베이스에 대한 유일한 쓰기 주체가 되어 데이터 일관성을 보장한다. 다른 서비스들은 필요에 따라 데이터베이스에서 데이터를 읽는다.</p>
<h2>4.  데이터 파이프라인: 실시간 캡처에서 실행 가능한 통찰력까지</h2>
<p>이 섹션은 시스템에서 가장 복잡하고 성능에 민감한 부분인 영상 데이터의 실시간 캡처, 스트리밍, 분석 과정을 상세히 설명한다.</p>
<h3>4.1  저지연 영상 스트리밍 프로토콜 선정</h3>
<h4>4.1.1  후보 기술 분석</h4>
<p>주요 선택지는 RTSP, WebRTC, 그리고 원시 영상 프레임을 DDS를 통해 전송하는 방식이다.</p>
<ul>
<li><strong>RTSP:</strong> 전통적인 클라이언트-서버 프로토콜로, 감시 시스템에 적합하지만 네이티브 브라우저 지원이 부족하고 지연 시간이 더 길 수 있다.47</li>
<li><strong>WebRTC:</strong> 웹 브라우저에서 직접 P2P 통신을 위해 설계된 기술로, 500ms 미만의 초저지연을 제공한다. 필수적인 암호화와 적응형 비트레이트 기능을 포함하여 매우 견고하다.47 이는 GCS의 주 운영자 뷰에 가장 이상적인 선택이다.</li>
<li><strong>Video over DDS:</strong> 모든 데이터를 단일 미들웨어 내에서 처리하는 새로운 패턴이다. 세밀한 QoS 제어가 가능하지만, 특히 Wi-Fi와 같이 신뢰할 수 없는 네트워크에서 대용량 영상 프레임에 대해 TCP와 같은 신뢰성이 필요할 경우 효율적으로 구현하기 복잡할 수 있다.16</li>
</ul>
<h4>4.1.2  권장 전략: GStreamer를 활용한 하이브리드 접근법</h4>
<ul>
<li><strong>핵심 기술:</strong> GStreamer는 강력하고 유연한 멀티미디어 프레임워크로, 위 프로토콜들을 위한 파이프라인을 생성할 수 있다. 결정적으로, WebRTC 및 RTSP 서버를 포함한 우수한 Rust 바인딩(<code>gstreamer-rs</code>)을 제공한다.56</li>
<li><strong>구현 방안:</strong></li>
</ul>
<ol>
<li><strong>주요 뷰 (WebRTC):</strong> 온보드 Rust 애플리케이션은 GStreamer를 사용하여 카메라 피드를 캡처하고, H.264 등으로 인코딩한 후, WebRTC P2P 연결을 통해 GCS로 스트리밍한다. 이는 수동 제어 및 즉각적인 상황 인식을 위한 가장 낮은 지연 시간을 제공한다.</li>
<li><strong>메타데이터 및 키프레임 (DDS):</strong> 동일한 애플리케이션이 DDS 토픽을 통해 중요한 메타데이터를 발행한다. 여기에는 AI 분석 결과(예: 경계 상자 및 클래스 레이블이 포함된 <code>detections</code> 토픽)와 잠재적으로 낮은 빈도의 키프레임이 포함된다. 이를 통해 시각적이지 않은 백엔드 서비스가 전체 영상 스트림을 디코딩하는 오버헤드 없이 이벤트에 반응하고 소비할 수 있다.</li>
</ol>
<p><strong>표 2: 영상 스트리밍 프로토콜 장단점 비교</strong></p>
<table><thead><tr><th>기능</th><th>WebRTC</th><th>RTSP</th><th>Video-over-DDS</th></tr></thead><tbody>
<tr><td><strong>일반적 지연 시간</strong></td><td>&lt; 500ms (초저지연)</td><td>0.5 - 3s (저지연)</td><td>가변적 (QoS에 따라 다름)</td></tr>
<tr><td><strong>주요 전송 프로토콜</strong></td><td>UDP (선호), TCP</td><td>TCP 또는 UDP</td><td>UDP (일반적)</td></tr>
<tr><td><strong>네이티브 브라우저 지원</strong></td><td>예</td><td>아니요</td><td>아니요</td></tr>
<tr><td><strong>내장 보안</strong></td><td>필수 (DTLS, SRTP)</td><td>선택적 (RTSPS)</td><td>선택적 (DDS-Security)</td></tr>
<tr><td><strong>확장성 모델</strong></td><td>P2P (분산형)</td><td>클라이언트-서버 (중앙형)</td><td>발행-구독 (분산형)</td></tr>
<tr><td><strong>본 프로젝트에서의 활용</strong></td><td>GCS 주 영상 피드 (저지연)</td><td>레거시 시스템 연동 (필요시)</td><td>AI 분석 결과, 메타데이터 전송</td></tr>
</tbody></table>
<p>이 비교표는 왜 WebRTC가 상호작용이 중요한 주 피드에 선택되고, DDS가 메타데이터 전송에 사용되는지를 명확히 보여준다. 이 하이브리드 접근법은 각 기술의 장점을 최대한 활용하여 최적의 솔루션을 구성한다.</p>
<h3>4.2  실시간 정찰: YOLO 기반 객체 탐지 구현</h3>
<h4>4.2.1  모델 선정</h4>
<p>YOLO 계열 모델은 실시간 객체 탐지 분야에서 최신 기술을 대표한다.61 향상된 정확도를 위해 어텐션 중심 아키텍처를 사용하는 <strong>YOLOv12</strong>와 같은 최신 고성능 모델로 시작하는 것을 권장한다.62 모델 크기(예: 속도 중심의 YOLOv12-N 대 정확도 중심의 YOLOv12-S)의 선택은 Jetson Orin Nano에서의 성능 벤치마크 결과에 따라 결정될 것이다.</p>
<h4>4.2.2  훈련 및 미세 조정</h4>
<p>COCO와 같은 데이터셋으로 훈련된 기성 모델은 좋은 출발점이지만, 특정 정찰 임무(예: 상공에서 특정 유형의 차량 식별)에서는 성능이 저하될 수 있다. 중요한 단계는 맞춤형 데이터셋을 수집하고, Ultralytics 프레임워크를 사용하여 선택된 YOLO 모델을 이 데이터에 맞게 미세 조정(fine-tuning)하는 것이다.61</p>
<h4>4.2.3  통합</h4>
<p>훈련된 모델은 온보드 GStreamer 파이프라인에 처리 요소로 통합된다. 이를 통해 라이브 비디오 스트림에서 원활한 추론이 가능해진다.</p>
<h3>4.3  NVIDIA TensorRT를 통한 성능 최적화</h3>
<h4>4.3.1  필요성</h4>
<p>Jetson과 같은 임베디드 장치에서 복잡한 YOLO 모델을 실행하여 실시간 프레임 속도를 달성하려면 공격적인 최적화가 필수적이다. NVIDIA TensorRT는 이를 위한 고성능 딥러닝 추론 옵티마이저 및 런타임이다.64</p>
<h4>4.3.2  최적화 워크플로우</h4>
<ol>
<li><strong>내보내기(Export):</strong> 미세 조정된 PyTorch 모델을 ONNX(Open Neural Network Exchange) 형식으로 내보낸다.</li>
<li><strong>최적화 및 양자화(Quantize):</strong> TensorRT 툴킷을 사용하여 ONNX 모델을 파싱하고 계층 융합, 커널 자동 튜닝, 그리고 가장 중요한 정밀도 양자화 등 수많은 최적화를 적용한다. INT8 양자화를 목표로 하며, 이는 최소한의 정확도 손실로 모델 크기를 최대 4배 줄이고 속도를 크게 향상시킬 수 있다.64</li>
<li><strong>엔진 생성:</strong> 결과물은 Jetson Orin Nano의 GPU 아키텍처에 특화된 고도로 최적화된 TensorRT “엔진” 파일이다.</li>
</ol>
<h4>4.3.3  Rust 통합</h4>
<p>최적화된 TensorRT 엔진은 온보드 Rust 애플리케이션에서 로드 및 실행된다. 이를 위해서는 <code>tensorrt</code> 크레이트와 같은 TensorRT C++ API용 Rust 래퍼를 사용해야 하며, 이는 다시 FFI를 포함한다.67 KCMVP 모듈과 마찬가지로, <code>unsafe</code> 코드를 격리하기 위해 전용 <code>tensorrt-wrapper</code> 크레이트를 생성해야 한다.</p>
<h2>5.  단계별 개발 및 배포 로드맵</h2>
<p>이 섹션은 가장 어려운 구성 요소의 위험을 먼저 제거하는 데 우선순위를 둔 실용적이고 단계적인 구현 계획을 제공한다.</p>
<p><strong>표 3: 단계별 개발 및 배포 로드맵</strong></p>
<table><thead><tr><th>단계</th><th>주요 목표</th><th>핵심 기능 및 결과물</th><th>구현 기술</th><th>성공 기준/마일스톤</th></tr></thead><tbody>
<tr><td><strong>1단계: 기반 및 핵심 제어</strong></td><td>핵심 기술 위험 제거 및 단일 드론 제어 루프 구축</td><td>- Pixhawk 드론용 온보드 Rust 앱 - 기본 GCS 앱 (텔레메트리 표시, 명령 전송) - DDS P2P 통신 백본 구현 - <strong><code>kcmvp-wrapper</code> 크레이트 개발 및 테스트</strong></td><td>Rust, DDS (Zenoh/CycloneDDS), MAVLink, KCMVP C Library (FFI)</td><td>현장 PC의 GCS에서 DDS를 통해 단일 Pixhawk 드론을 제어하고, 모든 제어 트래픽이 KCMVP로 암호화됨.</td></tr>
<tr><td><strong>2단계: 다중 드론 및 DJI 통합</strong></td><td>다중 드론으로 확장 및 상용 하드웨어 통합</td><td>- 백엔드 마이크로서비스 (게이트웨이, 임무 관리 등) - PostgreSQL 데이터베이스 스키마 구축 - 다중 드론 관리 로직 (GCS, 백엔드) - DJI Mavic/Dock 2 통합 (Onboard SDK, FFI)</td><td>PostgreSQL, Actix-web/Axum, DJI SDK (FFI)</td><td>중앙 서버를 통해 혼합된 Pixhawk 및 DJI 드론 편대를 GCS에서 제어하고, 모든 데이터가 DB에 기록됨.</td></tr>
<tr><td><strong>3단계: AI 기반 분석</strong></td><td>엔드-투-엔드 영상 분석 파이프라인 구현</td><td>- 맞춤형 데이터셋 구축 및 YOLO 모델 미세 조정 - 온보드 GStreamer/WebRTC 영상 스트리밍 파이프라인 - YOLO 모델의 TensorRT 최적화 - 온보드 앱에 TensorRT 엔진 통합 및 실시간 추론</td><td>GStreamer, WebRTC, YOLOv12, PyTorch, TensorRT (FFI)</td><td>GCS가 드론으로부터 저지연 영상 피드를 수신하고, 탐지된 객체 위에 실시간 경계 상자가 오버레이됨.</td></tr>
<tr><td><strong>4.단계: 확장성, 강화 및 배포</strong></td><td>운영 배포를 위한 시스템 준비</td><td>- 전체 시스템 보안 감사 (특히 FFI 래퍼) - 백엔드 및 DDS 네트워크 성능 튜닝 및 스트레스 테스트 - 배포 스크립트/컨테이너(Docker 등) 개발 - 강력한 오류 처리, 로깅, 시스템 상태 모니터링 구현</td><td>Docker, Prometheus, Grafana</td><td>사전 제작 환경에 시스템이 배포되어 실제 운영 부하 하에서 안정성, 보안, 성능을 입증함.</td></tr>
</tbody></table>
<p>이 로드맵은 가장 불확실하고 기술적으로 어려운 KCMVP FFI 통합과 DDS 통신 백본 구축을 1단계에 배치하여 프로젝트 초기에 핵심 아키텍처의 실행 가능성을 검증한다. 이는 복잡한 시스템 엔지니어링에서 표준적인 위험 완화 전략이다.</p>
<h2>6.  전략적 권장 사항 및 미래 전망</h2>
<p>이 마지막 섹션은 즉각적인 구현을 넘어, 시스템의 장기적인 가치와 역량을 극대화하기 위한 권장 사항을 제공한다.</p>
<h3>6.1  고급 분석: 객체 탐지를 넘어 변화 탐지로</h3>
<p>본 시스템은 본질적으로 동일한 지역의 이미지를 시간에 따라 반복적으로 캡처하는 지속적인 감시를 위해 설계되었다. 이는 가치 있는 시계열 데이터셋을 생성한다. 분석의 다음 논리적 단계는 **원격 감지 변화 탐지(remote sensing change detection)**를 구현하는 것이다.69 시스템은 “이 이미지에 무엇이 있는가?“라는 질문을 넘어 “지난 순찰과 이번 순찰 사이에 무엇이 변했는가?“에 답할 수 있게 된다. 딥러닝 기반 변화 탐지 모델은 조명이나 그림자와 같은 중요하지 않은 변화는 무시하고, 새로운 차량의 출현이나 구조물의 제거와 같은 의미 있는 변화를 강조하도록 훈련될 수 있다. 이는 연속적인 비행 데이터를 처리하는 백엔드 서비스로 구현될 수 있다.</p>
<p>이 기능은 시스템의 목적을 근본적으로 격상시킨다. 3단계까지의 시스템이 강력한 실시간 ’센서’라면, 변화 탐지 기능의 추가는 시스템을 ’지능 플랫폼’으로 변모시킨다. 단순히 원격 카메라의 역할을 넘어, 시간에 따른 이상 징후와 추세를 자율적으로 식별하고 경고하는 자동화된 정보 분석 플랫폼이 되는 것이다. 이는 시스템의 전략적 가치를 극적으로 높이며, 초기 시스템 배포 후 미래 R&amp;D의 핵심 초점이 되어야 한다.</p>
<h3>6.2  보안 강화 및 규정 준수</h3>
<ul>
<li><strong>엔드-투-엔드 암호화:</strong> KCMVP 모듈이 드론의 페이로드를 보호하는 동안, 전체 통신 체인도 보호해야 한다. 이를 위해 DDS-Security 플러그인을 활성화하여 인증 및 유선 암호화를 구현하고, 백엔드 API와의 모든 통신에 TLS를 사용해야 한다.</li>
<li><strong>인프라 보안:</strong> 백엔드 서버와 현장 PC 배포 환경 모두 네트워크 수준의 공격으로부터 보호하기 위해 최소한의 OS, 방화벽 규칙, 침입 탐지 시스템 등으로 강화되어야 한다.</li>
<li><strong>지속적인 감사:</strong> FFI 래퍼 크레이트의 <code>unsafe</code> 코드는 정기적이고 엄격한 코드 검토 및 잠재적으로 제3자 보안 감사의 대상이 되어야 한다.</li>
</ul>
<h3>6.3  확장성 및 편대 관리</h3>
<ul>
<li><strong>DDS 확장성:</strong> 대규모 WAN 배포는 상당한 탐색 트래픽을 생성할 수 있다. Zenoh 라우터를 사용하여 계층적이고 효율적인 라우팅 인프라를 구축하는 것이 이를 관리하는 핵심이다.21</li>
<li><strong>클라우드 네이티브 배포:</strong> 대규모 편대를 위해 백엔드 서비스는 클라우드에 구애받지 않고 Kubernetes와 같은 컨테이너 오케스트레이션 플랫폼에 배포하여 고가용성과 자동 확장을 지원하도록 설계되어야 한다.</li>
<li><strong>데이터 집계:</strong> 편대가 성장함에 따라 데이터 양이 막대해질 것이다. 데이터 수명 주기 관리(예: 오래된 텔레메트리를 핫 스토리지에서 콜드 스토리지로 이동) 및 대규모 분석을 위한 데이터 웨어하우스 구축 전략이 필요하다.</li>
</ul>
<h2>7. 참고 자료</h2>
<ol>
<li>Crafting Real-Time Marvels: Unveiling the Power of Rust for Embedded Systems | by Codex, https://medium.com/@emmaxcharles123/crafting-real-time-marvels-unveiling-the-power-of-rust-for-embedded-systems-9c029a5748fa</li>
<li>Why Rust is the Future of Embedded Systems Development | BICARD, https://www.bicard.org/why-rust-for-embedded-systems.php</li>
<li>Rust Programming Language, https://www.rust-lang.org/</li>
<li>5 Reasons to Use Rust in Embedded Systems for Automotive and Industrial - Promwad, https://promwad.com/news/rust-embedded-systems</li>
<li>Why Rust is a great fit for embedded software - 2023 update - Blog - Tweede golf, https://tweedegolf.nl/en/blog/96/why-rust-is-a-great-fit-for-embedded-software-2023-update</li>
<li>Rust for Real-Time Applications: Techniques and Tools You Need to Know - Medium, https://medium.com/@enravishjeni411/rust-for-real-time-applications-techniques-and-tools-you-need-to-know-94e4e6862712</li>
<li>How to Do Embedded Development with Rust - RunTime Recruitment, https://runtimerec.com/how-to-do-embedded-development-with-rust/</li>
<li>rust-embedded/awesome-embedded-rust: Curated list of resources for Embedded and Low-level development in the Rust programming language - GitHub, https://github.com/rust-embedded/awesome-embedded-rust</li>
<li>Rust for embedded systems programming : r/rust - Reddit, https://www.reddit.com/r/rust/comments/16w3e2l/rust_for_embedded_systems_programming/</li>
<li>Rust for Embedded Systems: Current state, challenges and open problems | Hacker News, https://news.ycombinator.com/item?id=39591694</li>
<li>What is DDS (Data Distribution Service) &amp; How Does it Work? - Fly Eye, https://www.flyeye.io/drone-acronym-dds/</li>
<li>ADLINK Tech | Vortex Data Distribution Service DDS Technologies, https://www.adlinktech.com/en/vortex-data-distribution-service-dds-technologies</li>
<li>Enabling Multi-Mission Interoperable UAS Using Data-Centric Communications - PMC, https://pmc.ncbi.nlm.nih.gov/articles/PMC6210890/</li>
<li>Optimizing Data Distribution Service Discovery for Swarm Unmanned Aerial Vehicles Through Preloading and Network Awareness - MDPI, https://www.mdpi.com/2504-446X/9/8/564</li>
<li>Performance Analysis of an Unmanned Systems Communications Network Using Data Distribution Service in a Lossy Environment - DTIC, https://apps.dtic.mil/sti/trecms/pdf/AD1150444.pdf</li>
<li>(PDF) Wireless video streaming over Data Distribution Service middleware - ResearchGate, https://www.researchgate.net/publication/256005724_Wireless_video_streaming_over_Data_Distribution_Service_middleware</li>
<li>zenoh-plugin-ros2dds - crates.io: Rust Package Registry, https://crates.io/crates/zenoh-plugin-ros2dds/1.4.0</li>
<li>zenoh-plugin-dds - crates.io: Rust Package Registry, https://crates.io/crates/zenoh-plugin-dds</li>
<li>ZettaScale demonstrates Zenoh and Cyclone DDS at ROSCon, https://www.zettascale.tech/news/zettascale-demonstrates-zenoh-and-cyclone-dds-at-roscon/</li>
<li>ZettaScale to demonstrate Zenoh and Cyclone DDS protocols at ROSCon 2022, https://www.prnewswire.com/in/news-releases/zettascale-to-demonstrate-zenoh-and-cyclone-dds-protocols-at-roscon-2022-301648819.html</li>
<li>Integrating ROS2 with Eclipse zenoh, https://zenoh.io/blog/2021-04-28-ros2-integration/</li>
<li>saboye/Data-Modeling-with-Postgres: A project to design a fact and dimension star schema for optimizing queries on a flight booking database using PostgreSQL, a relational database management system. This schema is well-suited for a flight booking database, as it allows for efficient querying of data such as booking dates - GitHub, https://github.com/saboye/Data-Modeling-with-Postgres</li>
<li>MavLink and PostgreSQL Integration - InfluxDB, https://www.influxdata.com/integrations/mavlink-postgresql/</li>
<li>Nvidia Jetson Nano vs Raspberry Pi - Which one is better for your project? - SocketXP, https://www.socketxp.com/iot/nvidia-jetson-nano-vs-raspberry-pi-which-one-is-better-for-your-project/</li>
<li>Jetson Nano vs Raspberry Pi AI: The Ultimate Performance Comparison fo - ThinkRobotics.com, https://thinkrobotics.com/blogs/learn/jetson-nano-vs-raspberry-pi-ai-the-ultimate-performance-comparison-for-edge-computing</li>
<li>Jestson Nano or Raspberry Pi – ROS - DroneBot Workshop Forums, https://forum.dronebotworkshop.com/ros/jestson-nano-or-raspberry-pi/</li>
<li>Pi 4 versus the jetson nano - DroneBot Workshop Forums, https://forum.dronebotworkshop.com/jetson-nano/pi-4-versus-the-jetson-nano/</li>
<li>Raspberry Pi 5 vs. Jetson Nano: General purpose or AI-focused - XDA Developers, https://www.xda-developers.com/raspberry-pi-5-vs-jetson-nano/</li>
<li>DIY Autonomous Drone with Raspberry Pi, Pixhawk, and Machine Learning : r/diydrones, https://www.reddit.com/r/diydrones/comments/1h93h0i/diy_autonomous_drone_with_raspberry_pi_pixhawk/</li>
<li>Comparison between Raspberry Pi and Jetson Nano - NVIDIA Developer Forums, https://forums.developer.nvidia.com/t/comparison-between-raspberry-pi-and-jetson-nano/212121</li>
<li>Jetson Nano vs Raspberry Pi 5 for AI: The Ultimate Performance and Val, https://thinkrobotics.com/blogs/learn/jetson-nano-vs-raspberry-pi-5-for-ai-the-ultimate-performance-and-value-comparison</li>
<li>Raspberry Pi 5 16GB? Or Jetson Nano Super Orin? : r/robotics - Reddit, https://www.reddit.com/r/robotics/comments/1hygz1f/raspberry_pi_5_16gb_or_jetson_nano_super_orin/</li>
<li>AI companion. Raspberry Pi 5 16gb vs Jetson Orin Nano? : r/LocalLLaMA - Reddit, https://www.reddit.com/r/LocalLLaMA/comments/1iplpck/ai_companion_raspberry_pi_5_16gb_vs_jetson_orin/</li>
<li>Raspberry Pi 5 16GB RAM ? Or NVIDIA Jetson Nano Super Orin? - YouTube, https://www.youtube.com/watch?v=0Rp9xmo8bXE</li>
<li>The Embedded Rust ESP Development Ecosystem, https://blog.theembeddedrustacean.com/the-embedded-rust-esp-development-ecosystem</li>
<li>Introduction - The bindgen User Guide, https://rust-lang.github.io/rust-bindgen/</li>
<li>vspd.co.kr, [https://vspd.co.kr/military/#:<sub>:text=KCMVP%20(Korean%20Cryptographic%20Module%20Validation,modules%20used%20in%20IT%20systems.](https://vspd.co.kr/military/#:</sub>:text=KCMVP (Korean Cryptographic Module Validation,modules used in IT systems.)</li>
<li>The Korea Cryptographic Module Validation Program (KCMVP): A Cornerstone of National Cybersecurity - 형사전문변호사 24시간 긴급상담 법무법인 법승 서울, https://www.lawwin.co.kr/seoul/knowledgedetail?index=7281</li>
<li>KCMVP - 중개 플랫폼 서비스, <a href="https://obcon.biz/cms/4_%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4/KCMVP.md?service=service_cms_bluestone">https://obcon.biz/cms/4_%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4/KCMVP.md?service=service_cms_bluestone</a></li>
<li>KCMVP 인증 - Fasoo, <a href="https://www.fasoo.com/glossary/k/kcmvp-%EC%9D%B8%EC%A6%9D">https://www.fasoo.com/glossary/k/kcmvp-%EC%9D%B8%EC%A6%9D</a></li>
<li>Cryptographic Module Validation Program CMVP - NIST Computer Security Resource Center, https://csrc.nist.gov/projects/cryptographic-module-validation-program/certificate/3016</li>
<li>Cryptographic Module Validation Program CMVP - NIST Computer Security Resource Center, https://csrc.nist.gov/projects/cryptographic-module-validation-program/certificate/3784</li>
<li>FIPS Certifications | Secure Development - Oracle, https://www.oracle.com/corporate/security-practices/assurance/development/external-security-evaluations/fips/certifications.html</li>
<li>파수 국정원 인증 KCMVP 암호화 모듈 브로슈어 | Fasoo Crypto, https://www.fasoo.com/document/fasoo-crypto-brochure</li>
<li>Library Usage with build.rs - The bindgen User Guide, https://rust-lang.github.io/rust-bindgen/library-usage.html</li>
<li>rust-lang/rust-bindgen: Automatically generates Rust FFI bindings to C (and some C++) libraries. - GitHub, https://github.com/rust-lang/rust-bindgen</li>
<li>WebRTC vs RTSP Protocols: Unveiling the Differences - Tragofone, https://tragofone.com/webrtc-vs-rtsp-protocols/</li>
<li>RTMP vs. RTSP: Which Streaming Protocol is Best for Your Business in 2025? - Dacast, https://www.dacast.com/blog/rtmp-vs-rtsp/</li>
<li>Choosing the Right Protocol: RTMP vs WebRTC vs RTSP for Conference, Live Streaming and Surveillance - AVIXA Xchange, https://xchange.avixa.org/posts/choosing-the-right-protocol-rtmp-vs-webrtc-vs-rtsp-for-live-streaming-and-surveillance</li>
<li>Guide to WebRTC vs. RTSP Video Streaming Protocols - Nabto, https://www.nabto.com/webrtc-vs-rtsp/</li>
<li>WebRTC vs RTSP : r/tragofone - Reddit, https://www.reddit.com/r/tragofone/comments/1d3alnr/webrtc_vs_rtsp/</li>
<li>WebRTC vs. RTSP: Understanding the IoT Video Streaming Protocols - DZone, https://dzone.com/articles/webrtc-vs-rtsp-understanding-the-iot-video-streami</li>
<li>Architecture of video streaming over DDS. | Download Scientific Diagram - ResearchGate, https://www.researchgate.net/figure/Architecture-of-video-streaming-over-DDS_fig4_259781956</li>
<li>Video Over DDS | High-performance publisher-subscriber video streaming, https://www.s2e-systems.com/use_cases/video_over_dds/</li>
<li>1.1.4. How to handle large data video streaming in ROS 2 - - Vulcanexus Documentation, https://docs.vulcanexus.org/en/jazzy/rst/tutorials/core/wifi/large_data/large_data.html</li>
<li>gstreamer-webrtc - crates.io: Rust Package Registry, https://crates.io/crates/gstreamer-webrtc</li>
<li>snapview/gstreamer-rs: GStreamer bindings for Rust - GitHub, https://github.com/snapview/gstreamer-rs</li>
<li>gstreamer_webrtc - Rust, https://gstreamer.freedesktop.org/documentation/rust/stable/latest/docs/gstreamer_webrtc/index.html</li>
<li>gstreamer_rtsp_server - Rust, https://gstreamer.freedesktop.org/documentation/rust/stable/latest/docs/gstreamer_rtsp_server/index.html</li>
<li>WebRTC Plumbing with GStreamer - webrtcHacks, https://webrtchacks.com/webrtc-plumbing-with-gstreamer/</li>
<li>Home - Ultralytics YOLO Docs, https://docs.ultralytics.com/</li>
<li>[2502.12524] YOLOv12: Attention-Centric Real-Time Object Detectors - arXiv, https://arxiv.org/abs/2502.12524</li>
<li>YOLO12: Attention-Centric Object Detection - Ultralytics YOLO Docs, https://docs.ultralytics.com/models/yolo12/</li>
<li>Optimizing Ultralytics YOLO models with the TensorRT integration, https://www.ultralytics.com/blog/optimizing-ultralytics-yolo-models-with-the-tensorrt-integration</li>
<li>TensorRT SDK - NVIDIA Developer, https://developer.nvidia.com/tensorrt</li>
<li>NVIDIA/TensorRT-Model-Optimizer: A unified library of state-of-the-art model optimization techniques like quantization, pruning, distillation, speculative decoding, etc. It compresses deep learning models for downstream deployment frameworks like TensorRT-LLM or TensorRT to optimize inference speed. - GitHub, https://github.com/NVIDIA/TensorRT-Model-Optimizer</li>
<li>Can I use TensorRT with Rust? - Massed Compute, <a href="https://massedcompute.com/faq-answers/?question=Can+I+use+TensorRT+with+Rust?">https://massedcompute.com/faq-answers/?question=Can%20I%20use%20TensorRT%20with%20Rust?</a></li>
<li>tensorrt - Rust Package Registry - Crates.io, https://crates.io/crates/tensorrt/dependencies</li>
<li>Deep learning for change detection in remote sensing: a review - Taylor &amp; Francis Online, https://www.tandfonline.com/doi/full/10.1080/10095020.2022.2085633</li>
<li>[2305.05813] Change Detection Methods for Remote Sensing in the Last Decade: A Comprehensive Review - arXiv, https://arxiv.org/abs/2305.05813</li>
<li>Deep Learning for Change Detection in Remote Sensing Images: Comprehensive Review and Meta-Analysis - ResearchGate, https://www.researchgate.net/publication/342794285_Deep_Learning_for_Change_Detection_in_Remote_Sensing_Images_Comprehensive_Review_and_Meta-Analysis</li>
<li>A Review of Deep-Learning Methods for Change Detection in Multispectral Remote Sensing Images - MDPI, https://www.mdpi.com/2072-4292/15/8/2092</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>