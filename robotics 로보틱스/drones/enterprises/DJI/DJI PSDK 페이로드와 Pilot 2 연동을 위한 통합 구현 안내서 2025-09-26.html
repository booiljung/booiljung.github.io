<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:DJI PSDK 페이로드와 Pilot 2 연동을 위한 통합 구현 안내서 (2025-09-26)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>DJI PSDK 페이로드와 Pilot 2 연동을 위한 통합 구현 안내서 (2025-09-26)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">로봇공학 (Robotics)</a> / <a href="../../index.html">드론 (Drones)</a> / <a href="../index.html">드론 기업 동향</a> / <a href="index.html">DJI</a> / <span>DJI PSDK 페이로드와 Pilot 2 연동을 위한 통합 구현 안내서 (2025-09-26)</span></nav>
                </div>
            </header>
            <article>
                <h1>DJI PSDK 페이로드와 Pilot 2 연동을 위한 통합 구현 안내서 (2025-09-26)</h1>
<h2>1.  PSDK 페이로드-Pilot 2 연동 아키텍처 개요</h2>
<p>DJI PSDK(Payload SDK)를 사용하여 개발된 페이로드를 조종기의 Pilot 2 애플리케이션에서 제어하기 위해서는, 서로 다른 개발 환경과 목적을 가진 두 SDK 생태계를 연결하는 통합 아키텍처에 대한 깊은 이해가 필수적이다. 본 가이드는 PSDK 기반 임베디드 페이로드와 MSDK(Mobile SDK) 기반 Pilot 2 앱 간의 기술적 격차를 해소하고, 원활한 데이터 통신과 사용자 인터페이스(UI) 구현을 위한 핵심 기술과 방법론을 상세히 다룬다.</p>
<h3>1.1  문제 정의: PSDK와 MSDK 간의 기술적 격차 해소</h3>
<p>PSDK는 C/C++ 언어를 기반으로 리눅스(Linux)나 실시간 운영체제(RTOS) 환경에서 동작하는 임베디드 페이로드 개발에 중점을 둔다.1 반면, Pilot 2와 같은 모바일 애플리케이션은 안드로이드(Android) 환경에서 MSDK를 기반으로 개발된다.3 이처럼 PSDK로 구현된 하드웨어 제어 로직과 MSDK로 구현된 조종기의 UI는 본질적으로 분리되어 있다. 따라서 핵심 과제는 이 두 시스템을 안정적으로 연결하여 사용자가 Pilot 2 화면을 통해 페이로드의 기능을 직관적으로 제어하고 상태를 실시간으로 모니터링하는 통합 솔루션을 구축하는 것이다.</p>
<p>이러한 통합 과정은 DJI가 의도적으로 분리해 놓은 SDK 생태계의 구조를 이해하는 것에서 출발한다. DJI는 하드웨어 및 임베디드 개발자를 위한 PSDK, 모바일 앱 개발자를 위한 MSDK, 그리고 클라우드 기반 엔터프라이즈 솔루션을 위한 Cloud API 등 각기 다른 개발자 페르소나와 비즈니스 요구사항에 맞춰 SDK를 세분화했다.5 이러한 전문화는 각 영역의 기능을 극대화하지만, 페이로드부터 최종 사용자 인터페이스까지 전체 시스템을 구축해야 하는 개발자에게는 상당한 기술적 장벽으로 작용한다. 즉, 개발자는 단순히 PSDK API를 아는 것을 넘어, 데이터가 드론의 무선 링크를 거쳐 MSDK까지 전달되는 전체 경로와 각 단계의 제약사항(대역폭, 지연 시간 등)을 모두 고려하는 ‘풀스택(full-stack)’ 관점을 가져야만 한다.</p>
<h3>1.2  핵심 솔루션 구성 요소: 데이터 통신과 UI 렌더링</h3>
<p>성공적인 연동을 위해서는 두 가지 핵심 기술 축을 중심으로 솔루션을 설계해야 한다.</p>
<ul>
<li>
<p><strong>데이터 통신 채널:</strong> PSDK 페이로드와 MSDK 애플리케이션 간의 안정적이고 효율적인 데이터 교환 경로를 구축하는 것이다. 이 채널은 페이로드의 On/Off와 같은 단순 제어 명령부터 레이더 데이터나 고해상도 센서 값과 같은 대용량 데이터까지 다양한 유형의 정보를 처리할 수 있어야 한다.4</p>
</li>
<li>
<p><strong>UI 렌더링 메커니즘:</strong> Pilot 2 화면에 페이로드 제어를 위한 사용자 인터페이스를 생성하는 방법이다. DJI는 개발의 편의성을 위해 표준화된 ‘커스텀 위젯’ 방식을 제공하며, 더 높은 자유도와 복잡한 UI 구현을 위해 웹 기술을 활용하는 ‘H5/JSBridge’ 방식 또한 지원한다.9</p>
</li>
</ul>
<h3>1.3  전체 시스템 아키텍처 다이어그램 및 데이터 흐름 분석</h3>
<p>페이로드와 Pilot 2 간의 상호작용은 페이로드(PSDK) → 드론(펌웨어) → 조종기(MSDK/Pilot 2) → 사용자 순으로 이루어진다. 이 과정에서 드론의 펌웨어는 두 SDK 사이의 통신을 중계하는 핵심적인 역할을 수행하지만, 개발자에게는 그 내부 동작이 공개되지 않은 ’블랙박스’와 같다. 따라서 PSDK와 MSDK가 제공하는 API는 펌웨어가 중계해주는 기능에 대한 추상화된 인터페이스이며, 개발자는 이 중계 과정에서 발생할 수 있는 데이터 지연이나 유실 가능성을 항상 염두에 두어야 한다.</p>
<ul>
<li>
<p><strong>명령 흐름 (Uplink):</strong> 사용자가 Pilot 2의 UI(예: 버튼)를 조작하면, 해당 이벤트는 MSDK를 통해 조종기에서 드론으로 무선 전송된다. 드론의 펌웨어는 이 신호를 수신하여 PSDK 페이로드에 정의된 해당 기능(예: 콜백 함수)을 실행하도록 명령을 전달한다.</p>
</li>
<li>
<p><strong>상태/데이터 흐름 (Downlink):</strong> PSDK 페이로드에서 수집한 센서 데이터나 현재 상태 정보(예: 온도, 전원 상태)는 드론 펌웨어를 통해 조종기로 무선 전송된다. 조종기의 MSDK는 이 데이터를 수신하여 Pilot 2의 UI에 해당 정보를 업데이트한다. 이 과정에서 데이터의 종류와 양에 따라 저속 채널과 고속 채널이 선택적으로 사용되어 통신 효율을 높인다.4 펌웨어는 무선 링크 상태에 따라 데이터 패킷의 우선순위를 조정하거나 데이터를 압축, 심지어 폐기할 수도 있다. 이것이 바로 PSDK API에 ’흐름 제어(Flow Control)’나 ’채널 상태 모니터링’과 같은 방어적 프로그래밍을 위한 기능이 포함된 이유다.4</p>
</li>
</ul>
<h2>2.  핵심 통신 구현: PSDK와 MSDK 간 데이터 채널 구축</h2>
<p>PSDK 페이로드와 Pilot 2(MSDK) 간의 원활한 정보 교환을 위해서는 견고한 데이터 통신 채널을 구축하는 것이 선행되어야 한다. PSDK는 두 가지 주요 데이터 전송 메커니즘, 즉 ’기본 데이터 전송 모듈’과 ’SDK 상호연결(MOP 채널)’을 제공한다.</p>
<h3>2.1  기본 데이터 전송 모듈 (Standard Data Transmission Module)</h3>
<p>이 모듈은 PSDK가 제공하는 가장 기본적인 양방향 투명 전송(transparent transmission) 채널로, 별도의 채널 설정 없이 즉시 사용할 수 있는 두 종류의 채널로 구성된다.4</p>
<ul>
<li>
<p><strong>명령 신호 채널 (Low-Speed Channel):</strong></p>
</li>
<li>
<p><strong>역할:</strong> 페이로드의 On/Off, 모드 변경, 상태 값 전송 등 짧고 빈번한 제어 명령에 최적화되어 있다.</p>
</li>
<li>
<p><strong>대역폭:</strong> 일반적으로 4 KB/s의 정적 대역폭 제한을 가지며, 데이터 전송의 신뢰성이 비교적 높다.4</p>
</li>
<li>
<p><strong>구현:</strong> PSDK 측에서는 <code>DjiLowSpeedDataChannel_SendData()</code>와 같은 함수를 사용하여 MSDK로 데이터를 전송하며, MSDK로부터 오는 데이터는 사전에 등록된 콜백 함수를 통해 비동기적으로 수신한다.</p>
</li>
<li>
<p><strong>고속 데이터 채널 (High-Speed Channel):</strong></p>
</li>
<li>
<p><strong>역할:</strong> 레이더 포인트 클라우드, 커스텀 비디오 스트림, 대용량 로그 파일 등 대규모 데이터 전송을 위해 설계되었다.4</p>
</li>
<li>
<p><strong>대역폭:</strong> M300 RTK 기종의 경우 최대 4 Mbps와 같이 상대적으로 높은 대역폭을 제공하지만, 이는 무선 링크 상태에 따라 동적으로 변동될 수 있다.4 개발자는<code>DjiHighSpeedDataChannel_SetBandwidthProportion()</code> 함수를 사용하여 비디오, 데이터, 다운로드 스트림 간의 대역폭 점유율을 조절할 수 있다.13</p>
</li>
<li>
<p><strong>구현:</strong> PSDK 측에서는 <code>DjiHighSpeedDataChannel_SendDataStreamData()</code> 함수를 사용하여 대용량 데이터를 전송한다.13</p>
</li>
<li>
<p>흐름 제어(Flow Control) 및 채널 상태 모니터링:</p>
</li>
</ul>
<p>무선 통신 환경은 가변적이므로, PSDK는 데이터 유실을 방지하기 위한 흐름 제어 메커니즘을 내장하고 있다. 전송하려는 데이터가 현재 채널의 처리 용량을 초과하면, 데이터는 내부 버퍼에 임시 저장되었다가 채널에 여유가 생길 때 전송된다. 만약 버퍼마저 가득 차면 데이터는 폐기될 수 있다.4 따라서 안정적인 통신을 위해서는<code>DjiLowSpeedDataChannel_GetSendToMobileState()</code>나 <code>DjiHighSpeedDataChannel_GetDataStreamState()</code>와 같은 함수를 주기적으로 호출하여 채널의 실시간 대역폭(<code>realtimeBandwidthLimit</code>)과 혼잡 상태(<code>busyState</code>)를 확인하고, 이에 따라 데이터 전송률을 동적으로 조절하는 방어적 프로그래밍 기법을 반드시 적용해야 한다.12</p>
<h3>2.2  고급 데이터 전송: SDK 상호연결 (MOP 채널)</h3>
<p>SDK 상호연결, 또는 MOP(MSDK Onboard PSDK) 채널은 기본 데이터 전송 모듈을 넘어, TCP/IP 소켓 프로그래밍과 유사한 강력하고 유연한 통신 기능을 제공한다.8</p>
<ul>
<li>
<p><strong>주요 특징:</strong></p>
</li>
<li>
<p><strong>동적 채널 생성:</strong> 개발자는 필요에 따라 고유한 ID를 가진 여러 개의 통신 채널(파이프라인)을 동적으로 생성하고 관리할 수 있다. 예를 들어, 제어 명령용 채널과 데이터 로깅용 채널을 분리하여 운영할 수 있다.8</p>
</li>
<li>
<p><strong>전송 방식 선택:</strong> 각 채널별로 데이터 전송 방식을 선택할 수 있다. ’신뢰성 있는 전송(Reliable)’은 ACK 및 재전송 메커니즘을 통해 데이터의 정확한 전달을 보장하며, ’비신뢰성 전송(Unreliable)’은 속도를 우선시하여 실시간성이 중요한 데이터에 적합하다.15</p>
</li>
<li>
<p><strong>양방향 통신 (Full-duplex):</strong> 하나의 채널 내에서 데이터 송신과 수신이 동시에 이루어질 수 있어 효율적인 통신이 가능하다.8</p>
</li>
<li>
<p>구현 아키텍처: MOP 채널은 서버-클라이언트 모델을 따른다. 일반적으로 PSDK 페이로드 측이 서버 역할을 하여 PsdkMopChannel_Create(), PsdkMopChannel_Bind(), PsdkMopChannel_Accept() 함수를 순차적으로 호출하여 특정 채널 ID로 연결을 대기한다.15 MSDK(Pilot 2) 측은 클라이언트가 되어 <code>IPipelineManager</code> 관련 API를 사용해 해당 채널 ID로 연결을 요청하고 파이프라인을 확립한다.8</p>
</li>
<li>
<p><strong>주의사항:</strong> MOP 채널은 강력한 기능을 제공하지만, 복수의 채널을 동시에 사용할 경우 내부 리소스 경쟁으로 인해 예기치 않은 타임아웃 문제가 발생할 수 있다는 개발자 커뮤니티의 보고가 있다.18 따라서 채널을 설계할 때는 각 채널의 목적과 데이터 전송 빈도를 신중하게 고려해야 한다.</p>
</li>
</ul>
<h3>2.3  기술 선택 가이드: 통신 방식 비교 분석</h3>
<p>페이로드의 요구사항에 가장 적합한 통신 방식을 선택하는 것은 전체 시스템의 안정성과 성능을 좌우하는 중요한 결정이다. 아래 표는 두 통신 방식의 특징을 비교하여 합리적인 선택을 돕는다.</p>
<p><strong>표 1: PSDK-MSDK 통신 방식 비교</strong></p>
<table><thead><tr><th>항목</th><th>기본 데이터 전송 모듈 (Standard Data Transmission)</th><th>SDK 상호연결 (MOP 채널)</th></tr></thead><tbody>
<tr><td><strong>구현 난이도</strong></td><td>낮음. 단순 API 호출로 데이터 송수신 가능.</td><td>높음. 서버/클라이언트 모델 이해 및 별도 스레드 관리 필요.</td></tr>
<tr><td><strong>유연성</strong></td><td>낮음. 고정된 저속/고속 2개 채널만 사용 가능.</td><td>매우 높음. 다수의 채널을 동적으로 생성/파괴 가능.</td></tr>
<tr><td><strong>신뢰성</strong></td><td>기본 수준의 신뢰성 제공.</td><td>선택 가능. 신뢰성(Reliable) 또는 비신뢰성(Unreliable) 전송 방식 지정.</td></tr>
<tr><td><strong>성능/대역폭</strong></td><td>API 문서에 명시된 정적/동적 대역폭 내에서 동작.</td><td>무선 링크 상태에 따라 가변적이며, 다중 채널을 통한 병렬 처리 가능.</td></tr>
<tr><td><strong>주요 활용 사례</strong></td><td>간단한 On/Off 제어, 단일 센서 데이터 모니터링, 단일 대용량 데이터 스트림 전송.</td><td>복합 기능 페이로드(제어, 원격측정, 데이터 전송 동시 처리), 다중 센서 데이터 분리 전송.</td></tr>
<tr><td><strong>핵심 PSDK API</strong></td><td><code>DjiLowSpeedDataChannel_SendData</code>, <code>DjiHighSpeedDataChannel_SendDataStreamData</code></td><td><code>PsdkMopChannel_Create</code>, <code>PsdkMopChannel_Accept</code>, <code>PsdkMopChannel_SendData</code></td></tr>
</tbody></table>
<h2>3.  Pilot 2 UI 구현: 페이로드 제어 인터페이스 개발</h2>
<p>안정적인 데이터 통신 채널이 구축되었다면, 다음 단계는 사용자가 Pilot 2 화면에서 페이로드를 직관적으로 제어할 수 있는 UI를 구현하는 것이다. DJI는 두 가지 주요 UI 구현 방식을 제공한다.</p>
<h3>3.1  표준 방식: 커스텀 위젯 (Standard Method: Custom Widget)</h3>
<p>커스텀 위젯은 PSDK 페이로드에 UI 구성 정보를 담은 파일을 포함시키면, Pilot 2가 이를 자동으로 해석하여 네이티브 UI 컴포넌트로 화면에 그려주는 간편하고 표준화된 방식이다.19</p>
<ul>
<li>
<p><strong>지원 위젯 종류:</strong> 버튼(<code>PSDK_WIDGET_TYPE_BUTTON</code>), 스위치(<code>PSDK_WIDGET_TYPE_SWITCH</code>), 스케일/슬라이더(<code>PSDK_WIDGET_TYPE_SCALE</code>), 선택 리스트(<code>PSDK_WIDGET_TYPE_LIST</code>), 정수 입력 박스(<code>PSDK_WIDGET_TYPE_INT_INPUT_BOX</code>) 등 기본적인 UI 요소를 지원한다.9</p>
</li>
<li>
<p><strong>단계별 구현 가이드:</strong></p>
</li>
</ul>
<ol>
<li>
<p><strong>JSON 파일 작성:</strong> 위젯 목록을 JSON 형식으로 정의한다. 각 위젯의 타입, 이름, 고유 인덱스, 아이콘 파일명 등을 명시한다. 이때 아이콘은 DJI가 제공하는 디자인 가이드라인을 준수하여 제작해야 한다.9</p>
</li>
<li>
<p><strong>헤더 파일 변환:</strong> DJI가 PSDK 툴체인 내에 제공하는 <code>file2c</code> 유틸리티를 사용하여 작성된 JSON 파일과 아이콘 이미지 파일들을 C 언어 헤더 파일(.h)의 바이너리 배열 형태로 변환한다. 이는 컴파일 시점에 리소스를 펌웨어에 직접 포함시키기 위함이다.9</p>
</li>
<li>
<p><strong>PSDK에 등록:</strong> 페이로드 초기화 코드에서 <code>PsdkWidget_Init()</code> 함수로 위젯 모듈을 초기화한 후, <code>DjiWidget_RegDefaultUiConfigByBinaryArray()</code>와 같은 함수를 호출하여 변환된 헤더 파일을 시스템에 등록한다.9</p>
</li>
<li>
<p><strong>핸들러 함수 작성:</strong> <code>PsdkWidget_RegHandlerList()</code> 함수를 사용하여 각 위젯의 이벤트(예: 버튼 클릭, 스위치 상태 변경)가 발생했을 때 호출될 콜백 함수(핸들러)를 등록한다.20 이 핸들러 함수 내에서 데이터 통신 채널을 통해 MSDK로 명령을 보내거나 페이로드의 하드웨어를 직접 제어하는 로직을 구현한다.</p>
</li>
</ol>
<ul>
<li><strong>플로팅 윈도우 및 임무 연동:</strong> <code>PsdkWidgetFloatingWindow_ShowMessage()</code> API를 사용하면 페이로드의 핵심 상태 정보(예: 온도, 감지 거리 등)를 Pilot 2 화면 상단의 플로팅 윈도우에 텍스트 형태로 실시간 표시할 수 있다.9 또한, 웨이포인트(Waypoint) 임무를 설정할 때 각 지점에서 특정 위젯 동작(예: ‘스위치 켜기’)을 자동으로 실행하도록 지정할 수 있어, 임무 자동화에 매우 유용하다.19</li>
</ul>
<h3>3.2  고급 방식: H5 웹 페이지와 JSBridge 연동</h3>
<p>커스텀 위젯이 제공하는 기능 이상의 복잡하고 동적인 UI/UX가 필요할 경우, H5(HTML5, CSS, JavaScript) 웹 기술을 활용할 수 있다. 이 방식은 Pilot 2 내의 웹뷰(WebView)에 개발자가 직접 제작한 웹 페이지를 로드하고, 이 웹 페이지가 ’JSBridge’라는 특수한 인터페이스를 통해 Pilot 2의 네이티브 기능과 상호작용하는 구조다.10</p>
<ul>
<li>JSBridge 아키텍처:</li>
</ul>
<p>이 아키텍처는 UI와 백엔드 로직을 명확하게 분리한다. 데이터 흐름은 다음과 같다: H5 웹 페이지 (UI/UX 담당) ↔ JSBridge (JavaScript-Native 통신) ↔ Pilot 2 네이티브 코드 (MSDK 기능 호출) ↔ 데이터 통신 채널 (MOP 등) ↔ PSDK 페이로드 (하드웨어 제어). 이 구조 덕분에 개발자는 웹 프론트엔드 기술을 자유롭게 사용하여 매우 정교한 데이터 시각화나 브랜드 맞춤형 UI를 구현할 수 있다.</p>
<ul>
<li>주요 JSBridge API 분석:</li>
</ul>
<p>DJI가 공개한 JSBridge API는 주로 클라우드 연동 및 미디어 스트리밍과 관련된 기능을 제공한다 (예: window.djiBridge.apiGetToken(), window.djiBridge.wsConnect(), window.djiBridge.liveshare…).10 PSDK 페이로드와 직접 데이터를 주고받기 위해서는 MSDK의 데이터 채널 기능(예: <code>sendDataToPayload</code> 22 또는 MOP 채널)과 연동되는 커스텀 JSBridge 인터페이스 구현이 필요하다. 즉, H5 페이지에서 특정 JavaScript 함수를 호출하면, Pilot 2의 네이티브 레이어가 이를 감지하여 해당 MSDK API를 실행하고, 그 결과를 다시 H5 페이지로 전달하는 양방향 통신 로직을 개발해야 한다.</p>
<h3>3.3  UI 기술 선택 가이드: 커스텀 위젯 vs. H5/JSBridge</h3>
<p>어떤 UI 기술을 선택할지는 프로젝트의 요구사항, 개발팀의 기술 스택, 그리고 개발 일정에 따라 신중하게 결정해야 한다.</p>
<p><strong>표 2: Pilot 2 UI 구현 기술 비교</strong></p>
<table><thead><tr><th>항목</th><th>커스텀 위젯 (Custom Widget)</th><th>H5 / JSBridge</th></tr></thead><tbody>
<tr><td><strong>UI/UX 자유도</strong></td><td>낮음. DJI가 제공하는 표준 템플릿과 위젯 종류에 제한됨.</td><td>매우 높음. 웹 기술로 구현할 수 있는 모든 형태의 UI/UX 가능.</td></tr>
<tr><td><strong>개발 복잡도</strong></td><td>낮음. JSON 정의와 C/C++ 핸들러 작성으로 비교적 간단히 구현.</td><td>높음. 웹 프론트엔드 개발과 네이티브-웹 연동(JSBridge) 로직 구현 필요.</td></tr>
<tr><td><strong>필요 기술 스택</strong></td><td>C/C++, JSON</td><td>C/C++, HTML, CSS, JavaScript (웹 프론트엔드 프레임워크 포함)</td></tr>
<tr><td><strong>성능/반응성</strong></td><td>높음. 네이티브 UI로 렌더링되어 반응성이 빠름.</td><td>중간. 웹뷰의 성능에 의존하며, 네이티브 UI보다 다소 느릴 수 있음.</td></tr>
<tr><td><strong>적합한 프로젝트</strong></td><td>기능이 명확하고 표준화된 산업용 페이로드 (예: 탐조등, 스피커, 단일 센서).</td><td>복잡한 데이터 시각화, 동적인 UI, 고객사 브랜딩이 필요한 상용 솔루션.</td></tr>
<tr><td><strong>주요 구현 포인트</strong></td><td>PSDK 프로젝트 내에서 JSON 파일 정의 및 핸들러 함수 작성.</td><td>별도의 웹 프로젝트 개발 및 Pilot 2(MSDK)와의 JSBridge 연동 로직 구현.</td></tr>
</tbody></table>
<h2>4.  통합 개발 및 디버깅 전략</h2>
<p>효율적인 개발과 안정적인 시스템 구축을 위해서는 체계적인 개발 환경 설정과 디버깅 전략이 필수적이다.</p>
<h3>4.1  개발 환경 설정 및 PSDK 샘플 코드 활용</h3>
<p>PSDK 개발은 주로 리눅스(예: Ubuntu) 또는 RTOS 환경에서 진행된다.23 개발을 시작하기에 앞서, DJI의 공식 GitHub 리포지토리에서 최신 버전의 PSDK를 다운로드해야 한다.2 이 PSDK 패키지에는 다양한 기능(커스텀 위젯, 데이터 전송, 카메라 제어 등)을 시연하는 샘플 코드가 포함되어 있다.25</p>
<p>이 샘플 코드는 단순한 예제를 넘어, 실제 개발을 위한 강력한 ‘템플릿’ 또는 ‘프레임워크’ 역할을 한다. 대부분의 개발자는 빈 프로젝트에서 시작하는 대신, 이 샘플 코드의 구조를 기반으로 자신의 로직을 추가하는 방식으로 개발을 진행한다. 이는 DJI가 의도한 개발 패턴으로, 복잡한 PSDK 초기화, 스레드 관리, 하드웨어 추상화 로직을 개발자가 직접 구현하는 수고를 덜어준다. 따라서 개발 초기 단계에서는 샘플 코드(<code>dji_sdk_demo_linux</code> 등)를 직접 컴파일하고 실행해보며 그 구조와 동작 방식을 완벽히 이해하는 것이 매우 중요하다.25 샘플 코드의 아키텍처에서 크게 벗어나는 독자적인 구조를 설계하려면 PSDK 내부 동작에 대한 훨씬 깊은 이해가 필요하며, 이는 상당한 개발 리스크를 동반할 수 있다.</p>
<h3>4.2  애플리케이션 등록 및 인증 정보 설정</h3>
<p>개발된 PSDK 페이로드가 DJI 드론과 정상적으로 통신하기 위해서는 DJI 개발자 웹사이트에서 애플리케이션을 등록하고 인증 정보를 발급받아야 한다.25 이 과정에서 App Name, App ID, App Key, App License와 같은 고유 정보가 생성된다. 이 정보들은 PSDK 소스코드 내의 설정 파일(예: <code>dji_sdk_app_info.h</code>)에 정확하게 기입되어야 한다.27 만약 이 정보가 누락되거나 틀릴 경우, PSDK 초기화(<code>DjiCore_Init</code>) 단계에서 인증 오류가 발생하며 페이로드는 작동하지 않는다. 이는 DJI가 자사의 생태계를 통제하고, 인증된 페이로드만이 드론 시스템에 접근할 수 있도록 보장하는 중요한 보안 메커니즘이다.</p>
<h3>4.3  PSDK 로깅 및 DJI Assistant 2 시뮬레이터를 이용한 디버깅 기법</h3>
<p>PSDK는 개발 중 발생하는 문제를 추적할 수 있도록 강력한 로깅 API를 제공한다. <code>PsdkLogger_UserLogInfo()</code>, <code>PsdkLogger_UserLogError()</code> 등의 함수를 코드의 주요 지점에 삽입하여 페이로드의 내부 상태, 수신된 데이터, 오류 발생 상황 등을 터미널이나 시리얼 포트로 실시간 출력할 수 있다.1</p>
<p>또한, 실제 드론을 비행시키지 않고도 개발 및 테스트를 진행할 수 있는 DJI Assistant 2 데스크톱 애플리케이션의 시뮬레이터 기능은 매우 유용하다.26 시뮬레이터를 사용하면 비행 상태, GPS 좌표, 센서 값 등을 가상으로 생성하여 PSDK 애플리케이션의 동작을 안전하게 검증할 수 있다.</p>
<p>통신 문제 발생 시에는 단편적인 정보만으로는 원인 파악이 어렵다. 체계적인 디버깅을 위해서는 <strong>PSDK 측의 로그</strong>, <strong>Pilot 2의 개발자 모드 로그</strong>, 그리고 **드론 본체에 저장되는 비행 로그(Flight Log)**를 종합적으로 분석해야 한다. 이를 통해 문제의 원인이 PSDK 코드의 로직 오류인지, 펌웨어의 중계 문제인지, 아니면 MSDK 측의 수신 오류인지를 단계적으로 추적하여 해결할 수 있다.</p>
<h2>5.  결론 및 아키텍처 설계 권장 사항</h2>
<h3>5.1  핵심 구현 전략 요약</h3>
<p>DJI PSDK 페이로드를 Pilot 2 앱과 성공적으로 연동하기 위해서는 <strong>데이터 통신</strong>과 <strong>UI 구현</strong>이라는 두 가지 기술 축에 대한 명확한 이해와 전략적 선택이 필요하다. 데이터 통신은 간단하고 빠른 구현을 위한 ’기본 데이터 전송 모듈’과 복잡하지만 유연한 ‘SDK 상호연결(MOP 채널)’ 중에서 선택할 수 있다. UI 구현은 표준화되고 안정적인 ‘커스텀 위젯’ 방식과 최고의 자유도를 제공하는 ‘H5/JSBridge’ 방식 중에서 결정해야 한다. 성공적인 통합 솔루션은 프로젝트의 요구사항에 맞는 최적의 기술 조합을 선택하는 것에서 시작된다.</p>
<h3>5.2  프로젝트 요구사항별 최적 아키텍처 제안</h3>
<ul>
<li>
<p><strong>시나리오 1 (단순 기능 페이로드):</strong> 농업용 분무기나 탐조등의 On/Off 제어와 같이 기능이 단순하고 명확한 경우.</p>
</li>
<li>
<p><strong>추천 아키텍처:</strong> <strong>기본 데이터 전송 모듈(명령 채널) + 커스텀 위젯(스위치 또는 버튼)</strong></p>
</li>
<li>
<p><strong>이유:</strong> 가장 빠르고 간단하게 개발할 수 있으며, 안정성이 검증된 표준 방식으로 최소한의 리소스로 요구사항을 완벽하게 충족할 수 있다.</p>
</li>
<li>
<p><strong>시나리오 2 (실시간 데이터 모니터링 페이로드):</strong> 대기 질 측정 센서나 방사능 측정기와 같이 지속적으로 데이터를 수집하고 핵심 수치를 표시해야 하는 경우.</p>
</li>
<li>
<p><strong>추천 아키텍처:</strong> <strong>기본 데이터 전송 모듈(고속 채널) + 커스텀 위젯(플로팅 윈도우)</strong></p>
</li>
<li>
<p><strong>이유:</strong> 고속 채널을 통해 센서 데이터를 효율적으로 MSDK로 전송하고, 플로팅 윈도우를 사용하여 가장 중요한 수치를 Pilot 2 화면에 간결하게 상시 표시하는 데 최적화된 조합이다.</p>
</li>
<li>
<p><strong>시나리오 3 (복합 기능 및 상용 솔루션):</strong> 열화상, RGB, 레이저 거리 측정기 등 다중 센서를 탑재하고, 자체 클라우드 서버와 연동되며, 고객사 브랜딩이 필요한 고급 검사 솔루션.</p>
</li>
<li>
<p><strong>추천 아키텍처:</strong> <strong>SDK 상호연결(MOP 채널, 다중) + H5/JSBridge</strong></p>
</li>
<li>
<p><strong>이유:</strong> 각 센서 데이터, 제어 명령, 클라우드 통신을 위한 별도의 MOP 채널을 구성하여 통신 로직을 체계적으로 관리할 수 있다. H5/JSBridge를 통해 복잡한 센서 데이터를 융합하여 그래프나 차트 형태로 시각화하고, 고객사 로고와 맞춤형 디자인을 적용하는 등 완전한 커스텀 UI를 구현하여 제품의 완성도를 극대화할 수 있다.</p>
</li>
</ul>
<h3>5.3  개발 시 주요 고려사항 및 잠재적 위험 요소</h3>
<ul>
<li>
<p><strong>펌웨어 호환성:</strong> 개발 과정 전반에 걸쳐 PSDK, MSDK 라이브러리 버전과 드론, 조종기의 펌웨어 버전 간의 호환성을 반드시 확인해야 한다. 특정 기능은 최신 펌웨어에서만 지원될 수 있으며, 버전 불일치는 예기치 않은 오작동의 원인이 될 수 있다.28</p>
</li>
<li>
<p><strong>성능 한계:</strong> 무선 통신 링크의 물리적 대역폭은 제한적이며, 전파 환경에 따라 성능이 저하될 수 있다. 특히 대용량 데이터를 지속적으로 전송하는 애플리케이션의 경우, 데이터 압축, 전송 주기 조절, 그리고 채널 상태 모니터링을 통한 동적 전송률 제어 로직을 견고하게 설계하여 데이터 유실을 최소화해야 한다.</p>
</li>
<li>
<p><strong>생태계 종속성:</strong> 본 솔루션은 DJI의 SDK와 하드웨어 플랫폼에 깊이 의존한다. 향후 DJI의 SDK 정책 변경, API 업데이트, 또는 특정 기종 단종 등이 솔루션의 유지보수 및 확장성에 영향을 미칠 수 있음을 인지하고 장기적인 관점에서 개발 계획을 수립해야 한다.</p>
</li>
</ul>
<h2>6. 참고 자료</h2>
<ol>
<li>PSDK API Documentation | Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-api-reference/v2/en/</li>
<li>DJI Payload SDK (PSDK) - GitHub, https://github.com/dji-sdk/Payload-SDK</li>
<li>Release Note - Mobile SDK, https://developer.dji.com/doc/mobile-sdk-tutorial/en/</li>
<li>Data Transmission - Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/function-set/basic-function/data-transmission.html</li>
<li>SDK Guide for DJI’s Enterprise Drone Ecosystem - Insights, https://enterprise-insights.dji.com/blog/dji-sdk-guide</li>
<li>DJI Developer, https://developer.dji.com/</li>
<li>Lowering Barriers to Entry for Fully-Integrated Custom Payloads on a DJI Matrice - arXiv, https://arxiv.org/html/2405.06176v1</li>
<li>SDK Interconnection - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/function-set/advanced-function/sdk-interconnection.html</li>
<li>Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/basic-function/custom-widget.html</li>
<li>Cloud API - DJI Developer, https://developer.dji.com/doc/cloud-api-tutorial/en/api-reference/pilot-to-cloud/jsbridge.html</li>
<li>Data Transmission - DJI Developer, https://developer.dji.com/document/b954a3fe-2721-4337-8acd-8b611fe54ef0</li>
<li>Data Transmission | Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-api-reference/v2/en/module/psdk_data_transmission.html</li>
<li>High Speed Data Channel - Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-api-reference/en/module/high-speed-data-channel.html</li>
<li>Data Channel | Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-api-reference/v2/en/module/psdk_data_channel.html</li>
<li>SDK Interconnection - DJI Onboard SDK Documentation - DJI Developer, https://developer.dji.com/onboard-sdk/documentation/tutorial/SDK-mop.html</li>
<li>SDK Interconnection - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/basic-function/sdk-interconnection.html</li>
<li>SDK Interconnection Sample - DJI Developer, https://developer.dji.com/doc/mobile-sdk-tutorial/en/tutorials/sdk-interconnection.html</li>
<li>MOP on multiple threads #272 - dji-sdk/Payload-SDK - GitHub, https://github.com/dji-sdk/Payload-SDK/issues/272</li>
<li>Custom Widget - DJI Developer, https://developer.dji.com/document/380a5349-5213-406c-ba35-15d3754e43f6</li>
<li>Payload SDK - Custom Widget - DJI Developer, https://developer.dji.com/doc/payload-sdk-api-reference/v2/en/practice/psdk_widget.html</li>
<li>Custom Widget - Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/function-set/basic-function/custom-widget.html</li>
<li>class Payload - DJI Mobile SDK Documentation, https://developer.dji.com/api-reference/android-api/Components/Payload/DJIPayload.html</li>
<li>How to Use PSDK - Payload SDK, https://developer.dji.com/doc/payload-sdk-tutorial/en/basic-introduction/how-to-use-psdk.html</li>
<li>DJI-SDK - GitHub, https://github.com/dji-sdk</li>
<li>Run Sample Code - Payload SDK, https://developer.dji.com/doc/payload-sdk-tutorial/en/quick-start/run-sample-code.html</li>
<li>Jetson Nano Quick Start - Payload SDK, https://developer.dji.com/doc/payload-sdk-tutorial/en/quick-start/quick-guide/jetson-nano.html</li>
<li>Run Sample Code - Payload SDK, https://developer.dji.com/doc/payload-sdk-tutorial/en/manifold-quick-start/run-sample-code.html</li>
<li>Hardware Platform - Payload SDK - DJI Developer, https://developer.dji.com/doc/payload-sdk-tutorial/en/model-instruction/choose-hardware-platform.html</li>
<li>Cloud API - DJI Developer, https://developer.dji.com/doc/cloud-api-tutorial/en/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>