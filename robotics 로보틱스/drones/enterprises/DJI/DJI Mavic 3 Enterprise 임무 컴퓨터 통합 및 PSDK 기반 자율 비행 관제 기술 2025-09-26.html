<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:DJI Mavic 3 Enterprise 임무 컴퓨터 통합 및 PSDK 기반 자율 비행 관제 기술 (2025-09-26)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>DJI Mavic 3 Enterprise 임무 컴퓨터 통합 및 PSDK 기반 자율 비행 관제 기술 (2025-09-26)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">로봇공학 (Robotics)</a> / <a href="../../index.html">드론 (Drones)</a> / <a href="../index.html">드론 기업 동향</a> / <a href="index.html">DJI</a> / <span>DJI Mavic 3 Enterprise 임무 컴퓨터 통합 및 PSDK 기반 자율 비행 관제 기술 (2025-09-26)</span></nav>
                </div>
            </header>
            <article>
                <h1>DJI Mavic 3 Enterprise 임무 컴퓨터 통합 및 PSDK 기반 자율 비행 관제 기술 (2025-09-26)</h1>
<h2>1. 서론</h2>
<h3>1.1 보고서의 목적 및 범위</h3>
<p>본 보고서는 DJI Mavic 3 Enterprise(이하 M3E) 기체에 서드파티 임무 컴퓨터(Mission Computer)를 물리적으로 통합하고, DJI Payload SDK(PSDK)를 활용하여 기체의 비행을 정밀하게 제어하며, 완전한 자율 임무 시스템을 구축하는 데 필요한 모든 기술적 절차를 포괄적으로 안내하는 것을 목적으로 한다. 보고서의 범위는 하드웨어 연결, 개발 환경 구축, PSDK API를 이용한 비행 제어 프로그래밍, 그리고 통합 관제 시스템 아키텍처 설계까지 포함한다.</p>
<h3>1.2 핵심 아키텍처 정의: PSDK 패러다임의 전환</h3>
<p>M3E 시스템 통합을 논의하기에 앞서, 가장 중요한 전제 조건을 명확히 해야 한다. 그것은 바로 전통적인 Onboard SDK(OSDK)가 아닌 Payload SDK(PSDK)를 통해서만 임무 컴퓨터의 비행 제어 기능에 접근할 수 있다는 점이다. 과거 Matrice 210, 300 RTK와 같은 대형 기체에서는 OSDK를 통해 임무 컴퓨터가 비행 제어 시스템과 직접 통신했으나, M3E 기종부터는 모든 서드파티 하드웨어와의 상호작용이 기체 상단의 PSDK 포트(E-Port)와 PSDK 라이브러리로 표준화되었다.</p>
<p>이러한 변화는 단순한 기술적 차이를 넘어 DJI의 아키텍처 설계 철학의 전환을 의미한다. 즉, 페이로드(Payload)가 단순한 부가 장치(카메라, 스피커 등)에 머무르지 않고, 기체의 ‘두뇌’ 역할을 수행하며 비행 제어까지 관장할 수 있도록 그 역할이 확장된 것이다. 따라서 M3E에 임무 컴퓨터를 통합하려는 개발자는 OSDK 기반의 접근 방식을 완전히 버리고, PSDK를 통해 임무 컴퓨터를 하나의 고도로 지능화된 ’페이로드’로서 다루는 새로운 패러다임에 기반하여 시스템을 설계해야 한다. 본 보고서는 이러한 패러다임 전환을 기반으로 모든 기술적 설명을 전개한다.</p>
<h2>2.  M3E PSDK 시스템 아키텍처 분석</h2>
<h3>2.1  PSDK 포트(E-Port)의 물리적 및 전기적 특성</h3>
<p>M3E 기체 상단에 위치한 PSDK 포트는 모든 서드파티 하드웨어 통합의 관문이다. 이 포트는 물리적으로 USB-C 형태를 채택하고 있으며, DJI의 공식 액세서리인 RTK 모듈이나 스피커뿐만 아니라, 개발자가 직접 제작하는 맞춤형 PSDK 액세서리 연결을 지원한다.</p>
<p>이 포트는 단순한 데이터 통신 채널을 넘어, DJI의 E-Port 규격에 따라 임무 컴퓨터에 전력을 공급하는 역할까지 수행한다. 공식 개발자 문서에 따르면, M3E의 E-Port는 12V∼17V의 전압 범위에서 최대 3.26A의 전류를 출력할 수 있다. 이는 NVIDIA Jetson Nano나 Raspberry Pi와 같은 소형 단일 보드 컴퓨터(SBC)를 별도의 외부 전원 없이 구동하기에 충분한 사양이다. 개발자는 이 포트를 통해 기체로부터 안정적인 전원을 공급받는 동시에, USB 2.0 또는 UART 프로토콜을 기반으로 PSDK 통신 채널을 수립하게 된다.</p>
<h3>2.2  Payload SDK(PSDK)의 역할과 기능 범위</h3>
<p>PSDK는 본래 카메라, 센서, 스피커 등 페이로드 장치 개발을 지원하기 위한 소프트웨어 개발 키트였다. 그러나 M3E를 지원하는 최신 버전의 PSDK에서는 그 기능이 대폭 확장되어, 단순한 장치 제어를 넘어 기체의 비행 자체를 제어하는 핵심적인 역할을 수행하게 되었다.</p>
<p>이제 PSDK는 ‘자동 비행 제어기(Automated Flight Controller)’ 역할을 수행할 수 있는 포괄적인 API 세트를 제공한다. 여기에는 기체의 자세, 속도, 위치 등 핵심 텔레메트리 데이터를 실시간으로 구독하는 기능, 조종기의 스틱 입력을 가상으로 시뮬레이션하여 정밀한 기동을 구현하는 ‘가상 스틱(Joystick)’ 제어 기능, 사전에 정의된 경로를 따라 자율 비행하는 웨이포인트 임무 관리 기능, 그리고 카메라 및 짐벌의 모든 기능을 프로그래밍 방식으로 제어하는 기능 등이 포함된다. 결과적으로 M3E에 연결된 임무 컴퓨터는 PSDK를 통해 사실상 기체의 완전한 자율 비행을 관장하는 핵심 두뇌로 기능할 수 있는 잠재력을 갖추게 된다.</p>
<h3>2.3  SDK 생태계 내 비교 분석</h3>
<p>DJI는 여러 종류의 SDK를 제공하며, 각 SDK는 명확히 구분된 목적을 가진다. M3E 기반의 자율 비행 시스템을 개발하기 위해서는 각 SDK의 역할을 정확히 이해하고 올바른 도구를 선택하는 것이 매우 중요하다.</p>
<ul>
<li>
<p><strong>Onboard SDK (OSDK):</strong> 주로 Matrice 300 RTK와 같은 대형 기체에서 사용되며, 비행 제어 컴퓨터와 시리얼 통신으로 직접 연결되어 심층적인 제어와 데이터 접근을 제공한다. <strong>M3E는 OSDK를 공식적으로 지원하지 않는다</strong>.</p>
</li>
<li>
<p><strong>Payload SDK (PSDK):</strong> M3E에서 임무 컴퓨터를 연결하고 비행을 포함한 모든 기체 기능을 제어하는 <strong>유일한 공식 경로</strong>이다.</p>
</li>
<li>
<p><strong>Mobile SDK (MSDK):</strong> 조종기(RC)에 연결된 안드로이드 또는 iOS 모바일 장치에서 실행되는 애플리케이션을 개발하기 위한 SDK이다. PSDK로 구동되는 임무 컴퓨터와 연동하여 사용자 정의 지상관제시스템(GCS)을 구축하는 데 활용될 수 있다.</p>
</li>
<li>
<p><strong>Cloud API:</strong> DJI Pilot 2 앱이나 DJI Dock과 같은 플랫폼을 서드파티 클라우드 서버와 연동하여 원격 관제, 데이터 관리, 실시간 스트리밍 등의 기능을 구현한다. M3E 시리즈는 Cloud API를 지원하여 클라우드 기반의 대규모 운용을 가능하게 한다.</p>
</li>
</ul>
<p><strong>표 1: DJI SDK 비교 분석</strong></p>
<table><thead><tr><th>SDK 유형</th><th>주요 목적</th><th>통신 인터페이스</th><th>M3E 지원 상태</th><th>대표 사용 사례</th></tr></thead><tbody>
<tr><td><strong>Payload SDK (PSDK)</strong></td><td>페이로드 및 임무 컴퓨터 개발, 비행 제어</td><td>기체 PSDK 포트 (USB, UART)</td><td><strong>지원 (필수)</strong></td><td>온보드 AI 컴퓨터 연결, 자율 비행 로직 구현</td></tr>
<tr><td><strong>Onboard SDK (OSDK)</strong></td><td>임무 컴퓨터의 심층 비행 제어</td><td>기체 OSDK 포트 (UART)</td><td><strong>미지원</strong></td><td>(해당 없음)</td></tr>
<tr><td><strong>Mobile SDK (MSDK)</strong></td><td>모바일 GCS 앱 개발</td><td>조종기 USB 포트</td><td><strong>지원</strong></td><td>PSDK와 연동되는 맞춤형 관제 앱 개발</td></tr>
<tr><td><strong>Cloud API</strong></td><td>클라우드 기반 원격 관제 솔루션 개발</td><td>인터넷 (HTTPS, MQTT)</td><td><strong>지원</strong></td><td>원격지에서 드론 임무 관리 및 데이터 수신</td></tr>
</tbody></table>
<h2>3.  임무 컴퓨터 하드웨어 연결 및 구성</h2>
<h3>3.1  필수 구성 요소 목록</h3>
<p>M3E와 임무 컴퓨터를 성공적으로 통합하기 위해 다음의 구성 요소가 필요하다.</p>
<ul>
<li>
<p><strong>기체:</strong> DJI Mavic 3 Enterprise (3E), Mavic 3 Thermal (3T), 또는 Mavic 3 Multispectral (3M)</p>
</li>
<li>
<p><strong>임무 컴퓨터:</strong> NVIDIA Jetson Nano Developer Kit 또는 Raspberry Pi 4 등 (본 보고서는 Jetson Nano를 기준으로 설명)</p>
</li>
<li>
<p><strong>인터페이스 보드:</strong> DJI E-Port 개발 키트(M350 RTK용 참조) 또는 <strong>커스텀 제작 보드</strong></p>
</li>
<li>
<p><strong>케이블:</strong> E-Port 동축 케이블, USB-C to Micro-USB OTG 어댑터 케이블, USB to TTL 시리얼 모듈, 듀퐁(Dupont) 라인, XT30 to DC 전원 케이블 등</p>
</li>
<li>
<p><strong>기타:</strong> 개발용 모니터, 키보드, 마우스, 고속 MicroSD 카드, Jetson Nano용 전원 공급 장치</p>
</li>
</ul>
<h3>3.2  단계별 물리적 연결 절차</h3>
<p>M3E와 임무 컴퓨터의 물리적 연결은 매우 정밀한 주의를 요구하는 과정이다. 특히, M3E용으로 공식 출시된 개발 키트가 없다는 점은 개발자가 직접 인터페이스 솔루션을 구축해야 함을 의미한다.</p>
<h4>3.2.1  커스텀 인터페이스 보드 제작</h4>
<p>가장 중요한 점은 DJI가 M3E 시리즈용 공식 PSDK 개발 키트를 제공하지 않는다는 사실이다. 이는 개발자가 DJI가 제공하는 하드웨어 참조 설계(Hardware Reference Design) 문서를 기반으로 직접 커스텀 인터페이스 보드를 제작해야 함을 의미한다. 이 과정은 단순한 조립을 넘어 전자 회로 설계 및 제작 능력을 요구한다.</p>
<p>이때, Matrice 350 RTK용으로 출시된 ’E-Port 개발 키트’의 회로 구성과 연결 방식은 매우 중요한 참조 아키텍처가 된다. 커스텀 보드는 M3E의 E-Port로부터 입력받은 전원(12V∼17V)을 Jetson Nano가 요구하는 안정적인 전압(예: 5V 또는 12V)으로 변환하는 전원 레귤레이터 회로와, E-Port의 USB 및 UART 통신 라인을 각 커넥터로 분리(breakout)하는 회로를 포함해야 한다.</p>
<h4>3.2.2  M3E와 인터페이스 보드 연결</h4>
<ol>
<li>
<p>기체의 전원이 완전히 꺼진 상태에서 기체 상단의 PSDK 포트 커버를 제거한다.</p>
</li>
<li>
<p>’E-Port 동축 케이블’을 사용하여 M3E의 PSDK 포트와 제작된 커스텀 인터페이스 보드의 E-Port 입력 단자를 연결한다.</p>
</li>
<li>
<p>이 케이블은 방향성을 가지므로, 연결 시 A면과 B면을 정확히 확인하여 연결해야 한다. 방향이 틀릴 경우 전원 공급 및 통신이 이루어지지 않는다.</p>
</li>
</ol>
<h4>3.2.3  인터페이스 보드와 Jetson Nano 연결</h4>
<ol>
<li>
<p><strong>전원 연결:</strong> 커스텀 인터페이스 보드에 설계된 전원 출력 포트(예: XT30 커넥터)에서 Jetson Nano의 DC 전원 입력 잭으로 전원 케이블을 연결한다.</p>
</li>
<li>
<p><strong>USB 데이터 연결:</strong> PSDK 통신에서 M3E 기체 측은 ’USB Device’로, 임무 컴퓨터(SDK) 측은 ’USB Host’로 동작한다. 따라서 인터페이스 보드의 USB 출력 포트에서 USB-C OTG 어댑터와 Micro-USB 케이블을 사용하여 Jetson Nano의 USB 포트(Host 역할)에 연결한다.</p>
</li>
<li>
<p><strong>UART 데이터 연결 (선택/디버깅용):</strong> 초기 통신 문제를 진단하기 위해 UART 연결을 병행할 수 있다. 인터페이스 보드의 UART 핀(TX, RX, GND)을 ’USB to TTL 시리얼 모듈’에 교차 연결(TX-RX, RX-TX)하고, 이 모듈을 Jetson Nano의 다른 USB 포트에 연결한다.</p>
</li>
</ol>
<p><strong>표 2: E-Port 인터페이스-임무 컴퓨터 간 주요 핀아웃 (참조용)</strong></p>
<table><thead><tr><th>핀 기능</th><th>E-Port 인터페이스 신호</th><th>Jetson Nano 핀 (40핀 헤더)</th><th>설명</th></tr></thead><tbody>
<tr><td>UART_TX</td><td>PSDK UART Transmit</td><td>Pin 10 (UART1_RXD)</td><td>임무 컴퓨터가 드론으로 데이터 전송</td></tr>
<tr><td>UART_RX</td><td>PSDK UART Receive</td><td>Pin 8 (UART1_TXD)</td><td>드론이 임무 컴퓨터로 데이터 전송</td></tr>
<tr><td>USB_D+</td><td>USB Data Plus</td><td>USB 포트</td><td>PSDK 주 통신 채널</td></tr>
<tr><td>USB_D-</td><td>USB Data Minus</td><td>USB 포트</td><td>PSDK 주 통신 채널</td></tr>
<tr><td>PPS</td><td>Pulse-Per-Second</td><td>Pin 7 (GPIO)</td><td>정밀 시간 동기화용 1Hz 신호</td></tr>
<tr><td>GND</td><td>Ground</td><td>다수 (e.g., Pin 6)</td><td>공통 접지</td></tr>
<tr><td>VCC</td><td>Power Input</td><td>DC Power Jack</td><td>인터페이스 보드로부터 전원 공급</td></tr>
</tbody></table>
<h2>4.  PSDK 개발 환경 구축</h2>
<h3>4.1  임무 컴퓨터 운영체제 및 종속성 설정</h3>
<ol>
<li>
<p>NVIDIA의 공식 가이드에 따라 Jetson Nano 개발자 키트용 최신 Ubuntu 시스템 이미지를 다운로드하여 MicroSD 카드에 설치하고, 초기 시스템 설정을 완료한다.</p>
</li>
<li>
<p>Jetson Nano를 부팅하고 터미널을 연 뒤, 다음 명령어를 사용하여 PSDK 컴파일 및 실행에 필요한 필수 라이브러리와 도구를 설치한다.</p>
<pre><code class="language-Bash">sudo apt-get update
sudo apt-get install build-essential cmake libusb-1.0-0-dev
</code></pre>
</li>
</ol>
<pre><code>
이 패키지들은 C/C++ 코드 컴파일(build-essential), 프로젝트 빌드 관리(cmake), 그리고 USB 통신(libusb)에 필수적이다.

### 4.2  DJI PSDK 라이브러리 설치 및 프로젝트 구성


1. 웹 브라우저를 통해 DJI 개발자 웹사이트(developer.dji.com)에 접속하여 기업(Enterprise) 개발자 계정을 생성한다.

2. 로그인 후, 'Payload SDK' 섹션에서 새로운 애플리케이션을 등록한다. 이 과정에서 애플리케이션 이름과 플랫폼 정보 등을 입력하면 고유한 **App ID**와 **App Key**가 발급된다. 이 두 값은 PSDK 소프트웨어가 DJI 서버로부터 인증을 받는 데 사용되므로 반드시 안전하게 보관해야 한다.

3. 터미널에서 `git` 명령어를 사용하여 GitHub의 공식 DJI PSDK 저장소로부터 최신 버전의 소스 코드를 다운로드한다.

   ```Bash
   git clone https://github.com/dji-sdk/Payload-SDK.git
</code></pre>
<ol start="4">
<li>다운로드한 <code>Payload-SDK</code> 디렉토리로 이동하여 샘플 코드 내의 설정 파일(예: <code>samples/sample_c/platform/linux/common/dji_sdk_app_info.h</code>)을 열고, 앞서 발급받은 App ID와 App Key 값을 해당 상수에 정확히 입력한다.</li>
</ol>
<h3>4.3  ‘Hello World’ 통신 검증</h3>
<ol>
<li>
<p>PSDK 프로젝트의 루트 디렉토리에서 빌드 디렉토리를 생성하고 <code>cmake</code>와 <code>make</code>를 사용하여 샘플 코드를 컴파일한다.</p>
<pre><code class="language-Bash">cd Payload-SDK
mkdir build
cd build
cmake..
make
</code></pre>
</li>
</ol>
<pre><code>
2. 모든 하드웨어 연결이 완료되었는지 다시 한번 확인한 후, M3E 기체와 조종기의 전원을 켠다.

3. 터미널에서 컴파일된 샘플 실행 파일을 실행한다 (예: `sudo./bin/dji_payload_sdk_sample_c`).

4. 실행 후 출력되는 로그 메시지를 주의 깊게 확인한다. 로그에 `SDK init successfully` 또는 `Activate successful`과 같은 메시지가 나타나면, 임무 컴퓨터와 드론 간의 PSDK 통신 채널이 성공적으로 수립된 것이다. 이 단계의 성공은 모든 후속 개발을 위한 필수적인 기반이 된다.

## 5.  PSDK API를 활용한 정밀 비행 관제


### 5.1  실시간 데이터 구독 및 텔레메트리 활용


PSDK의 데이터 구독(Data Subscription) 기능은 자율 비행 시스템의 '눈과 귀' 역할을 한다. 개발자는 특정 데이터 토픽(Topic)을 선택하여 구독함으로써, 기체의 핵심 상태 정보를 실시간으로 수신할 수 있다. 이 데이터는 제어 알고리즘의 입력값으로 사용되어 상황 판단과 의사 결정의 기반이 된다.

주요 구독 가능 데이터에는 기체의 3차원 자세(Quaternion), 각속도, 지상 좌표계 기준 속도, 위도/경도/고도, GPS 위성 수, RTK 상태 및 정밀도, 배터리 잔량 및 각 셀의 전압 등이 포함된다. 예를 들어, 실시간 자세(Quaternion) 데이터는 안정화 제어 루프에, GPS 및 RTK 데이터는 경로 추종 알고리즘에, 배터리 데이터는 임무 시간 관리 및 비상 복귀 로직에 필수적으로 사용된다.

**표 3: PSDK 핵심 텔레메트리 데이터 구독 토픽**

| 데이터 토픽               | 데이터 내용                 | 일반적 업데이트 주기 | 제어 루프 중요도      | 관련 PSDK API (예시)                     |
| -------------------- | ---------------------- | ----------- | -------------- | ------------------------------------ |
| `TOPIC_QUATERNION`   | 기체 자세 (쿼터니언)           | 200Hz       | **높음**         | `DjiDataSubscription_SubscribeTopic` |
| `TOPIC_VELOCITY`     | 지상 좌표계 기준 속도 (x, y, z) | 100Hz       | **높음**         | `DjiDataSubscription_SubscribeTopic` |
| `TOPIC_GPS_FUSED`    | 위도, 경도, 고도, 위성 수       | 10Hz        | **중간**         | `DjiDataSubscription_SubscribeTopic` |
| `TOPIC_RTK_POSITION` | RTK 위치 및 상태(FIX/FLOAT) | 5Hz         | **높음 (정밀 임무)** | `DjiDataSubscription_SubscribeTopic` |
| `TOPIC_BATTERY_INFO` | 배터리 잔량(%), 전압(mV)      | 1Hz         | **중간**         | `DjiDataSubscription_SubscribeTopic` |

### 5.2  비행 제어 API 심층 분석


#### 5.2.1  제어권 획득 및 관리


PSDK를 통한 비행 제어는 절대적인 권한이 아니다. 이는 DJI의 안전 철학에 따라 설계된 중요한 아키텍처적 특징이다. 임무 컴퓨터가 기체를 제어하기 위해서는 먼저 `DjiFlightController_ObtainCtrlAuthority()`와 같은 API를 호출하여 명시적으로 제어권(Control Authority)을 획득해야 한다.

그러나 이 제어권은 영구적이지 않다. 만약 지상의 조종사가 조종기의 스틱을 움직이거나, 비행 모드 스위치를 변경하거나, RTH(Return-to-Home) 버튼을 누르는 등 어떠한 조작이라도 가하는 순간, PSDK가 보유하던 제어권은 즉시 해제되고 조종사에게 우선권이 넘어간다. 따라서 안정적인 자율 비행 시스템을 구축하기 위해서는 단순히 제어 명령을 보내는 것만으로는 부족하다. 소프트웨어는 현재 제어권을 보유하고 있는지 지속적으로 상태를 확인하는 로직을 포함해야 하며, 제어권을 상실했을 경우 즉시 제어 명령 전송을 중단하고 안전한 대기 상태로 전환하는 '상태 머신(State Machine)' 구조로 설계되어야 한다. 이는 예기치 않은 충돌을 방지하기 위한 필수적인 안전 장치이다.

#### 5.2.2  기본 제어 명령


PSDK는 복잡한 제어 로직 없이도 수행할 수 있는 고수준의 기본 비행 명령 API를 제공한다. `DjiFlightController_StartTakeoff()`를 호출하면 기체는 자동으로 1.2m 고도까지 이륙하며, `DjiFlightController_StartLanding()`은 자동 착륙을, `DjiFlightController_StartGoHome()`은 사전에 설정된 홈포인트로의 자동 복귀를 수행한다.

#### 5.2.3  'Joystick' 기능을 이용한 가상 스틱 제어


'Joystick' 기능은 PSDK 비행 제어의 가장 핵심적이고 강력한 기능으로, 실시간으로 기체의 움직임을 정밀하게 제어할 수 있게 해준다. 이는 마치 프로그래밍 코드를 통해 가상의 조종 스틱을 움직이는 것과 같다. 개발자는 다음 요소들을 조합하여 원하는 비행 기동을 자유롭게 구현할 수 있다.

- **좌표계 설정:** 제어 명령의 기준이 될 좌표계를 선택한다. '기체 좌표계(Body Frame)'를 선택하면 기체의 전방을 기준으로, '지상 좌표계(Ground Frame, NED - North-East-Down)'를 선택하면 지리적 방위를 기준으로 움직인다.

- **수평 제어 모드:**

- **속도 제어 모드:** 목표 속도(m/s)를 직접 명령한다.

- **위치 제어 모드:** 목표 위치(현재 위치로부터의 상대 변위, m)를 명령한다.

- **자세각 제어 모드:** 목표 Roll, Pitch 각도(degree)를 직접 명령한다.

- **수직 제어 모드:**

- **속도 제어 모드:** 수직 상승/하강 속도(m/s)를 명령한다.

- **위치 제어 모드:** 이륙 지점 기준 절대 고도(m)를 명령한다.

- **스로틀 제어 모드:** 모터의 추력(%)을 직접 제어한다.

예를 들어, '지상 좌표계', '수평 속도 제어', '수직 위치 제어' 모드를 조합하면, 특정 고도를 정밀하게 유지하면서 북쪽으로 초속 2m로 비행하는 것과 같은 복합적인 제어 로직을 손쉽게 구현할 수 있다.

### 5.3  웨이포인트 임무 프로그래밍


PSDK는 사전에 정의된 경로를 따라 비행하는 웨이포인트 임무(Waypoint Mission)를 프로그래밍 방식으로 생성, 업로드, 실행하는 고급 기능을 제공한다.

1. **임무 생성:** 임무 컴퓨터의 소프트웨어 내에서 각 웨이포인트의 정보(위도, 경도, 고도), 지점 간 비행 속도, 해당 지점에서 머무는 시간, 그리고 웨이포인트 도달 시 수행할 특정 액션(예: 사진 촬영, 영상 녹화 시작) 등을 배열이나 리스트 형태로 정의하여 임무 객체를 생성한다.

2. **임무 업로드 및 실행:** 생성된 임무 객체를 PSDK API를 통해 기체의 비행 제어 컴퓨터로 업로드한다. 업로드가 완료되면 임무 시작, 일시 정지, 재개, 중단 등의 명령을 API를 통해 전송하여 전체 임무 수행 과정을 완벽하게 제어할 수 있다.

### 5.4  카메라 및 짐벌 원격 제어


PSDK는 M3E에 탑재된 고성능 카메라와 짐벌의 모든 기능을 원격으로 제어할 수 있는 포괄적인 API를 제공한다. 이를 통해 사진 촬영(`DjiCamera_StartShootPhoto`), 영상 녹화 시작/중지, ISO, 셔터 속도, 조리개(M3E 모델)와 같은 핵심 노출 파라미터 설정, 화이트 밸런스 조정 등을 모두 코드로 제어할 수 있다. 또한, 짐벌의 Pitch, Roll, Yaw 각도를 정밀하게 제어하여 원하는 촬영 구도를 잡거나, 특정 좌표를 지속적으로 바라보도록 하는 POI(Point of Interest) 기능을 자율적으로 구현할 수 있다.

## 6.  통합 관제 시스템 아키텍처 설계


### 6.1  온보드 자율성 구현 전략


임무 컴퓨터의 강력한 연산 능력, 특히 Jetson Nano와 같은 장치의 GPU를 활용하여 기체 자체적으로 판단하고 행동하는 '온보드 자율성(Onboard Autonomy)'을 구현할 수 있다. 이는 지상 관제 시스템과의 통신이 두절되더라도 임무를 지속할 수 있는 고도의 지능형 시스템 구축을 의미한다.

- **AI 기반 객체 탐지 및 추적:** PSDK를 통해 실시간으로 수신한 카메라 영상 스트림을 Jetson Nano의 GPU에서 AI 모델(예: YOLO, SSD)로 분석한다. 특정 객체(사람, 차량, 시설물 결함 등)가 탐지되면, 그 객체의 화면상 위치를 계산하고 이를 기체의 움직임으로 변환하는 제어 로직을 구현한다. Joystick API를 사용하여 탐지된 객체를 영상 중앙에 유지하도록 기체를 자동으로 추적 비행시킬 수 있다.

- **비전 기반 장애물 회피:** 기체에 기본적으로 탑재된 전방위 장애물 감지 시스템을 보완하는 고급 회피 시스템을 구축할 수 있다. 예를 들어, 기본 센서가 감지하기 어려운 얇은 전선이나 나뭇가지 등을 비전 알고리즘으로 인식하고, 이를 회피하기 위한 비행 경로를 동적으로 생성하여 Joystick API로 기체를 제어한다.

### 6.2  SDK 상호연결(Interconnection)을 통한 GCS 연동


DJI의 'SDK 상호연결(SDK Interconnection)' 기능은 PSDK와 MSDK를 유기적으로 결합하여 강력한 통합 관제 시스템을 구축하는 핵심 기술이다. 이 기능은 기체에 탑재된 임무 컴퓨터(PSDK)와 조종기에 연결된 모바일 장치의 맞춤형 GCS 앱(MSDK) 간에 안정적인 양방향 데이터 파이프라인을 생성한다.

이 아키텍처가 가지는 가장 큰 장점은 분산 컴퓨팅 모델을 구현할 수 있다는 점이다. 계산 집약적이고 지연 시간에 민감한 작업(예: 실시간 AI 영상 분석)은 기체에 탑재된 고성능 임무 컴퓨터가 현장에서 직접 처리한다. 그리고 그 처리 결과인 고수준의 정보(예: "차량 3대 발견, 좌표 [x,y,z]")만을 무선 통신 링크를 통해 지상의 GCS 앱으로 전송한다. 지상의 GCS 앱은 복잡한 연산 없이 이 정보를 받아 지도나 영상 위에 시각화하고, 운영자는 이를 바탕으로 '해당 차량 정밀 촬영'과 같은 상위 레벨의 명령을 내릴 수 있다. 이 명령은 다시 PSDK로 전송되어 온보드 임무 컴퓨터가 자율적으로 수행한다.

이러한 구조는 표준 DJI Pilot 2 앱의 기능을 훨씬 뛰어넘어, 특정 임무(예: 수색 구조, 정밀 검사)에 완벽하게 최적화된 맞춤형 관제 솔루션을 가능하게 한다. 운영자의 역할은 단순한 '조종사'에서 처리된 정보를 바탕으로 전략적 결정을 내리는 '임무 감독관'으로 격상된다.

### 6.3  4G/LTE 통신 확장을 통한 BVLOS 운용


M3E 기체와 RC Pro Enterprise 조종기에 DJI Cellular Dongle을 장착하면, 표준 OcuSync 3 Enterprise 전송 시스템의 통신 범위를 넘어서는 BVLOS(Beyond Visual Line of Sight) 환경에서도 안정적인 제어 및 데이터 링크를 유지할 수 있다. 4G/LTE 네트워크는 OcuSync 신호가 약해지거나 장애물로 인해 끊겼을 때 자동으로 활성화되어 제어 명령과 영상 데이터 전송을 보완하거나 완전히 대체하는 역할을 한다.

앞서 설명한 SDK 상호연결 아키텍처와 이 4G 통신 기능을 결합하면, 진정한 의미의 원격 운용이 가능해진다. 인터넷을 통해 수백 킬로미터 떨어진 원격 관제 센터에서 M3E 기체를 실시간으로 제어하고, 온보드 임무 컴퓨터가 처리한 데이터를 받아보며 임무를 수행하는 고도의 시나리오를 구현할 수 있다.

## 7. 결론 및 핵심 고려사항


### 7.1 기술적 요약 및 기대효과


본 보고서에서 제시한 하드웨어 통합, 개발 환경 구축, PSDK API 활용 절차를 통해 개발자는 DJI M3E를 단순한 고성능 촬영용 드론이 아닌, 특정 산업 현장의 복잡한 요구사항에 맞춤화된 고도의 자율 비행 로봇 플랫폼으로 전환시킬 수 있다. 이는 정밀 농업에서의 작황 분석, 대규모 시설물의 자동화된 안전 점검, 공공 안전 분야에서의 실종자 수색 및 상황 인식, 재난 현장에서의 신속한 피해 조사 등 다양한 분야에서 기존의 한계를 뛰어넘는 혁신적인 솔루션 개발의 기술적 기반이 될 것이다.

### 7.2 안전 및 보증 정책 고지


PSDK를 사용하여 기능을 확장하는 것 자체는 DJI가 공식적으로 지원하는 개발 경로이다. 그러나 이 과정에서 발생하는 책임 소재는 명확히 인지해야 한다. DJI의 공식 보증(Warranty) 및 DJI Care Refresh 서비스 정책에 따르면, '승인되지 않은 개조, 분해, 쉘 개방' 또는 '인증되지 않은 서드파티 부품 사용'으로 인해 발생한 손상은 보증 대상에서 제외된다.

개발자가 직접 제작한 커스텀 인터페이스 하드웨어나 직접 작성한 비행 제어 소프트웨어의 결함으로 인해 기체 손상, 추락, 또는 제3자에게 피해가 발생하는 경우, 이는 전적으로 개발자의 책임이며 DJI의 보증 서비스를 받을 수 없다. 또한, DJI SDK 최종 사용자 라이선스 계약(EULA)은 SDK를 인명 피해나 심각한 재산 피해를 유발할 수 있는 안전이 중요한 활동에 사용하는 것을 명시적으로 제한하고 있다. 따라서 개발자는 자신이 구축한 시스템의 모든 부분에 대해 최종적인 책임을 지며, 자율 비행 시스템 운용에 따르는 모든 법적, 윤리적 책임을 인지하고 개발에 임해야 한다.

### 7.3 개발 및 운용 권장사항


- **시뮬레이션 기반 테스트:** 실제 비행에 앞서, DJI Assistant 2 소프트웨어에 내장된 시뮬레이터나 기타 가상 환경에서 개발한 제어 로직을 수백, 수천 번 반복하여 테스트하고 안정성을 철저히 검증해야 한다.

- **안전한 제어권 전환 로직:** PSDK의 제어권이 예기치 않게 상실될 경우(예: 조종사 개입, 통신 두절), 즉시 모든 제어 명령을 중단하고 안전한 호버링 상태로 전환하거나 조종사에게 제어권을 완전히 반환하는 명확하고 신뢰성 있는 페일세이프(Fail-safe) 로직을 개발 최우선 순위로 두어야 한다.

- **단계적 기능 확장:** 처음부터 복잡한 완전 자율 비행 시스템을 구축하려 시도하기보다, 데이터 구독, 짐벌 제어, 간단한 Joystick 기동 등 안정성이 검증된 기능부터 단계적으로 구현하고 각 단계마다 충분한 테스트를 거치며 시스템을 확장해 나가는 점진적 개발 방식을 채택해야 한다.</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>