<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:PSDK 사용자 정의 위젯(Custom Widget) 개발 안내서 (2025-09-26)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>PSDK 사용자 정의 위젯(Custom Widget) 개발 안내서 (2025-09-26)</h1>
                    <nav class="breadcrumbs"><a href="../../../../index.html">Home</a> / <a href="../../../index.html">로봇공학 (Robotics)</a> / <a href="../../index.html">드론 (Drones)</a> / <a href="../index.html">드론 기업 동향</a> / <a href="index.html">DJI</a> / <span>PSDK 사용자 정의 위젯(Custom Widget) 개발 안내서 (2025-09-26)</span></nav>
                </div>
            </header>
            <article>
                <h1>PSDK 사용자 정의 위젯(Custom Widget) 개발 안내서 (2025-09-26)</h1>
<h2>1.  서론: 표준 위젯을 넘어, 사용자 정의 위젯의 세계로</h2>
<h3>1.1  위젯의 진화와 사용자 경험(UX)의 패러다임 변화</h3>
<p>소프트웨어 개발 키트(Software Development Kit, SDK)는 특정 플랫폼을 위한 애플리케이션 개발에 필요한 도구, 라이브러리, 문서, API 등을 집약한 통합 패키지다.1 SDK의 본질적 역할은 사전 빌드된 구성 요소와 프레임워크를 제공함으로써 개발자가 바퀴를 재발명하는 데 드는 시간과 노력을 줄이고, 핵심 비즈니스 로직 구현에 집중할 수 있도록 지원하는 것이다. 이를 통해 개발 효율성을 극대화하고, 제품 출시 기간을 단축하며, 전반적인 개발 비용을 절감하는 효과를 가져온다.1</p>
<p>이러한 SDK가 제공하는 수많은 구성 요소 중, 위젯(Widget)은 현대 모바일 및 웹 환경에서 사용자 경험(UX)의 패러다임을 바꾸는 핵심적인 요소로 자리 잡았다. 위젯은 애플리케이션의 핵심 정보나 기능을 앱을 실행하지 않고도 홈 화면이나 잠금 화면 등에서 직접 접근하고 상호작용할 수 있게 만든 소형 앱 뷰(mini app view)다.4 날씨 정보, 캘린더 일정, 주식 시세 등을 실시간으로 확인하거나 음악을 제어하는 등의 간단한 작업을 앱 실행 과정 없이 즉시 수행하게 함으로써, 사용자의 편의성을 극대화하고 앱에 대한 지속적인 인게이지먼트를 유도하는 강력한 수단이 된다.6</p>
<p>위젯의 기술적 진화는 정적인 정보 표시에서 동적인 상호작용으로의 전환으로 요약할 수 있다. 초기 위젯은 정해진 정보를 주기적으로 업데이트하여 보여주는 단방향 정보 전달자의 역할에 머물렀다. 그러나 사용자들이 더 빠르고 즉각적인 피드백을 요구하고, 앱을 실행하는 과정 자체를 번거롭게 느끼는 ‘앱 피로(App Fatigue)’ 현상이 심화됨에 따라 플랫폼은 위젯의 역할을 재정의하기 시작했다. Android 12와 Jetpack Glance, 그리고 iOS 14의 WidgetKit 도입 이후, 특히 iOS 17에서 상호작용 기능이 대폭 강화되면서 위젯은 단순한 정보창을 넘어 독립적인 기능을 수행하는 마이크로 인터페이스(Micro-Interface)로 진화하고 있다.6 이제 위젯은 단순히 정보를 보여주는 것을 넘어, 사용자의 간단한 작업을 위젯 내에서 직접 완료할 수 있는 새로운 상호작용 채널로 기능하며, 이는 앱의 가치를 사용자에게 지속적으로 상기시키는 중요한 비즈니스 기회를 창출한다.</p>
<h3>1.2  표준 위젯의 한계와 사용자 정의(Customization)의 필연성</h3>
<p>대부분의 플랫폼은 개발자가 손쉽게 사용할 수 있는 표준 위젯 툴킷을 제공한다.8 이러한 표준 위젯은 일반적인 사용 사례를 충족시키고 빠른 개발을 가능하게 하지만, 동시에 명백한 한계를 내포한다. 이러한 한계는 기능, 디자인, 상호작용의 세 가지 측면에서 두드러진다.</p>
<p>첫째, 기능적 제약이다. 표준 위젯은 플랫폼이 미리 정의한 기능 범위 내에서만 동작한다. 복잡한 데이터 시각화, 다단계 상호작용, 또는 앱 고유의 비즈니스 로직과 깊게 연동되는 기능을 구현하는 데에는 한계가 있다. 예를 들어, Android 표준 위젯은 터치와 수직 스와이프 외의 복합적인 제스처를 지원하는 데 제한이 따른다.10 이로 인해 개발자는 차별화된 사용자 경험을 제공하는 데 어려움을 겪게 된다.11</p>
<p>둘째, 디자인의 제약이다. 표준 위젯은 해당 플랫폼의 디자인 가이드라인을 엄격하게 따르도록 설계되어 있다.11 이는 플랫폼 전체의 시각적 일관성을 유지하는 데는 도움이 되지만, 개별 앱의 고유한 브랜딩과 디자인 아이덴티티를 위젯에 온전히 담아내기 어렵게 만든다. 정해진 레이아웃 구조, 제한된 폰트 및 색상 팔레트는 창의적인 디자인 표현을 가로막는 요소로 작용한다. 때로는 텍스트 크기나 색상 대비율 같은 접근성 요구사항을 충족시키지 못하는 경우도 발생할 수 있다.11</p>
<p>마지막으로, 상호작용의 한계다. 앞서 언급했듯, 표준 위젯에서 지원하는 상호작용은 제한적이다. 이는 사용자가 위젯을 통해 수행할 수 있는 작업의 범위를 좁히고, 결국 위젯을 단순한 ‘앱 바로가기’ 수준으로 전락시킬 위험이 있다.</p>
<p>이러한 표준 위젯의 본질적인 한계를 극복하고, 앱의 핵심 가치를 사용자에게 가장 효과적이고 매력적인 방식으로 전달하기 위해 사용자 정의 위젯(Custom Widget) 개발은 더 이상 선택이 아닌 필수가 되었다. 사용자 정의 위젯은 개발자에게 완전한 제어권을 부여하여, 앱의 정체성을 반영한 독창적인 디자인과 혁신적인 기능을 구현할 수 있는 무한한 가능성을 열어준다.</p>
<p>각 플랫폼이 위젯에 부여하는 자유도는 해당 플랫폼의 근본적인 생태계 철학을 반영한다는 점을 이해하는 것이 중요하다. Apple의 iOS는 WidgetKit 가이드라인을 통해 일관되고 높은 품질의 사용자 경험을 보장하기 위해 디자인과 업데이트 주기에 대해 비교적 엄격한 규칙을 제시한다.12 반면, Google의 Android는 개발자에게 높은 자유도를 부여하여 더 다양한 시도를 가능하게 하지만, 이는 자칫 파편화된 사용자 경험으로 이어질 수 있는 트레이드오프를 가진다.11 웹 위젯은 기술적으로 가장 자유롭지만, 호스트 페이지와의 통합, 보안, 그리고 다양한 브라우저 환경에서의 호환성 확보가 핵심 과제가 된다.15 따라서 성공적인 사용자 정의 위젯 개발은 단순히 기술 구현을 넘어, 대상 플랫폼의 철학과 생태계를 깊이 이해하고 그 안에서 최적의 균형점을 찾는 전략적 접근을 요구한다.</p>
<h2>2.  사용자 정의 위젯의 핵심 아키텍처와 생명주기</h2>
<p>사용자 정의 위젯을 성공적으로 개발하기 위해서는 특정 플랫폼의 API를 학습하기에 앞서, 그 기저에 깔린 보편적인 아키텍처 원리와 동작 방식을 이해하는 것이 필수적이다. 플랫폼마다 용어와 구현 방식은 다르지만, 모든 위젯 시스템은 유사한 핵심 구성 요소와 생명주기 모델을 공유한다.</p>
<h3>2.1  플랫폼 독립적인 위젯 구성 요소 분석</h3>
<p>사용자 정의 위젯의 아키텍처는 일반적으로 네 가지 핵심 구성 요소로 나눌 수 있다.</p>
<ul>
<li>
<p><strong>데이터 제공자 (Data Provider)</strong>: 위젯에 표시될 데이터를 생성하고 시스템에 제공하는 책임을 지는 컴포넌트다. 이는 위젯의 ’두뇌’에 해당한다. Android에서는 <code>BroadcastReceiver</code>를 상속하는 <code>AppWidgetProvider</code> 클래스가 이 역할을 수행하며, 시스템이 발송하는 업데이트 관련 브로드캐스트 인텐트를 수신하여 위젯의 상태를 갱신한다.14 iOS의 WidgetKit에서는 <code>TimelineProvider</code> 프로토콜이 동일한 역할을担う. 시스템의 요청에 따라 미래의 특정 시점에 위젯이 어떤 상태를 가져야 하는지를 정의하는 타임라인(Timeline)을 생성하여 반환한다.18 웹 환경에서는 백엔드 API와의 통신을 담당하는 JavaScript 모듈이나 React의 데이터 페칭 훅(<code>useEffect</code>, <code>useSWR</code> 등)이 데이터 제공자의 역할을 수행한다.20</p>
</li>
<li>
<p><strong>뷰/레이아웃 (View/Layout)</strong>: 위젯의 시각적 표현, 즉 사용자 인터페이스(UI)를 정의하는 부분이다. Android는 XML 레이아웃 파일을 통해 정적인 구조를 정의하고, <code>RemoteViews</code>라는 특수한 객체를 사용하여 이 레이아웃을 동적으로 제어한다. <code>RemoteViews</code>는 다른 프로세스(예: 홈 스크린 런처)에서 UI를 안전하게 렌더링하기 위해 직렬화가 가능한 뷰 계층 구조 정보를 담고 있다.5 반면, iOS는 현대적인 선언적 UI 프레임워크인 SwiftUI를 사용하여 위젯 뷰를 구성한다. 이는 코드 기반으로 유연하고 동적인 UI를 손쉽게 제작할 수 있게 해준다.7 웹 위젯은 전통적인 웹 기술인 HTML 템플릿과 CSS를 사용하여 UI를 정의하며, JavaScript를 통해 동적으로 조작한다.16</p>
</li>
<li>
<p><strong>설정/메타데이터 (Configuration/Metadata)</strong>: 위젯의 기본적인 속성과 동작 방식을 시스템에 알리는 역할을 한다. 여기에는 위젯의 최소/최대 크기, 기본 업데이트 주기, 초기 레이아웃, 이름, 설명 등이 포함된다. Android에서는 <code>AppWidgetProviderInfo</code>라는 별도의 XML 파일에 이러한 메타데이터를 상세히 기술한다.14 iOS에서는<code>Widget</code> 프로토콜을 준수하는 구조체 내에서 <code>StaticConfiguration</code> 또는 <code>IntentConfiguration</code> 객체를 생성하여 Swift 코드로 직접 위젯의 종류, 표시 이름, 지원 크기 등을 설정한다.18 웹 위젯의 경우, <code>widget.json</code>과 같은 표준화된 메타데이터 파일을 사용하거나 JavaScript 설정 객체를 통해 이를 관리할 수 있다.15</p>
</li>
<li>
<p><strong>사용자 설정 액티비티/화면 (Configuration Activity/Screen)</strong>: 모든 위젯에 필수적인 요소는 아니지만, 사용자가 위젯을 처음 추가할 때 개인화된 설정을 할 수 있도록 제공하는 선택적 UI다. 예를 들어, 날씨 위젯에 특정 도시를 설정하거나, 주식 위젯에 관심 종목을 등록하는 기능이 이에 해당한다. 이 설정 화면을 통해 수집된 정보는 위젯의 동작과 표시에 직접적인 영향을 미친다.14</p>
</li>
</ul>
<p>이러한 구성 요소들은 서로 유기적으로 작동하며 위젯의 전체 기능을 완성한다. 이들의 관계를 이해하는 것은 플랫폼별 구현의 차이점을 넘어서는 위젯 개발의 근본적인 통찰을 제공한다. 위젯 아키텍처의 핵심은 본질적으로 ’프로세스 간 통신(Inter-Process Communication, IPC)’과 ’상태의 비동기적 동기화’에 기반한다. 애플리케이션은 보안과 안정성을 위해 운영체제에 의해 각각 격리된 프로세스 공간에서 실행되며, 위젯을 호스팅하는 홈 스크린 역시 별개의 시스템 프로세스다. 만약 위젯이 앱 프로세스에서 직접 UI를 렌더링한다면, 해당 앱의 오류나 비정상 종료가 홈 스크린 전체 시스템을 마비시키는 심각한 문제를 야기할 수 있다.</p>
<p>이러한 문제를 해결하기 위해 플랫폼들은 UI 렌더링에 필요한 ’데이터와 명령어 묶음’을 직렬화하여 프로세스 경계를 넘어 호스트 프로세스로 안전하게 전달하는 방식을 채택했다. Android의 <code>RemoteViews</code>는 뷰 계층 구조와 그릴 내용을 담은 명령어 집합이며 17, iOS의 <code>TimelineEntry</code>는 특정 시점에 그려야 할 뷰의 상태(데이터)를 담고 있는 스냅샷이다.18 이처럼 위젯은 앱의 UI를 직접 그리는 것이 아니라, 렌더링에 필요한 상태 객체를 비동기적으로 전달하는 방식으로 동작한다. 따라서 위젯 개발자는 UI를 ’상태(state)’의 함수로 간주하고, 상태가 변경될 때마다 전체 UI를 새로 그리는 데 필요한 데이터를 효율적으로 패키징하여 전달하는 선언적(Declarative) 패러다임에 입각하여 접근해야 한다.</p>
<p>다음 표는 주요 플랫폼별 위젯 핵심 구성 요소의 역할과 명칭을 비교하여 아키텍처에 대한 통합적인 이해를 돕는다.</p>
<p><strong>표 1: 주요 플랫폼별 사용자 정의 위젯 핵심 구성 요소 비교</strong></p>
<table><thead><tr><th>기능 분류</th><th>Android</th><th>iOS (WidgetKit)</th><th>Web (JavaScript)</th></tr></thead><tbody>
<tr><td><strong>핵심 로직/제공자</strong></td><td><code>AppWidgetProvider</code> (BroadcastReceiver)</td><td><code>TimelineProvider</code> 프로토콜</td><td>JavaScript 모듈 / React Component</td></tr>
<tr><td><strong>메타데이터 정의</strong></td><td><code>AppWidgetProviderInfo</code> (XML)</td><td><code>WidgetConfiguration</code> (in Swift)</td><td><code>widget.json</code> 또는 JS 객체</td></tr>
<tr><td><strong>UI 레이아웃</strong></td><td>XML Layout + <code>RemoteViews</code></td><td>SwiftUI <code>View</code></td><td>HTML 템플릿 + CSS</td></tr>
<tr><td><strong>업데이트 관리</strong></td><td><code>AppWidgetManager</code></td><td><code>WidgetCenter</code>, <code>TimelineReloadPolicy</code></td><td><code>setInterval</code>, Event Listeners, API Polling</td></tr>
<tr><td><strong>사용자 설정</strong></td><td><code>Configuration Activity</code></td><td>App Intents, <code>IntentConfiguration</code></td><td>HTML Form in iframe / SDK 제공 UI</td></tr>
<tr><td><strong>상호작용 처리</strong></td><td><code>PendingIntent</code></td><td><code>Button</code>, <code>Toggle</code> with App Intents</td><td>JavaScript Event Handlers (<code>onclick</code> 등)</td></tr>
</tbody></table>
<p>이 표는 플랫폼 간의 상이한 용어와 클래스 이름 이면에 존재하는 공통적인 아키텍처 패턴을 명확히 보여준다. 예를 들어, Android의 <code>AppWidgetProvider</code>와 iOS의 <code>TimelineProvider</code>는 명칭은 다르지만 ’시스템의 요청에 응답하여 위젯의 다음 상태를 제공한다’는 동일한 핵심 역할을 수행한다. 이처럼 역할 중심으로 아키텍처를 이해하면, 특정 플랫폼 경험을 가진 개발자가 다른 플랫폼의 위젯 시스템을 훨씬 빠르고 효과적으로 학습할 수 있다.</p>
<h3>2.2  위젯의 생명주기(Lifecycle) 모델 해부</h3>
<p>위젯은 사용자가 홈 스크린에 추가하는 순간부터 제거될 때까지 명확한 생명주기를 따른다. 이 생명주기를 이해하는 것은 리소스를 효율적으로 관리하고 정확한 시점에 콘텐츠를 업데이트하는 데 매우 중요하다.</p>
<ul>
<li>
<p><strong>생성 (Creation/Binding)</strong>: 생명주기는 사용자가 위젯 갤러리에서 특정 위젯을 선택하여 홈 스크린에 배치할 때 시작된다. 이 시점에서 시스템은 해당 위젯의 인스턴스를 생성하고, <code>AppWidgetHost</code>와 같은 호스트 관리자를 통해 위젯 인스턴스를 식별할 고유 ID를 할당한다.26 만약 위젯이 사용자 설정을 요구하도록 정의되었다면(Configuration Activity/Screen), 이 단계에서 설정 화면이 사용자에게 제시된다. 사용자가 설정을 완료하고 확인하면 위젯이 홈 스크린에 최종적으로 추가되고, 사용자가 설정을 취소하면 생성 과정이 중단된다.14</p>
</li>
<li>
<p><strong>업데이트 (Update)</strong>: 위젯의 핵심 기능으로, 표시되는 콘텐츠를 최신 상태로 유지하는 과정이다. 업데이트는 여러 가지 방식으로 촉발될 수 있다.</p>
</li>
<li>
<p><strong>주기적 업데이트</strong>: 가장 일반적인 방식으로, 위젯 메타데이터에 정의된 고정된 시간 간격에 따라 시스템이 자동으로 업데이트를 요청한다. Android의 <code>updatePeriodMillis</code> 속성 14 또는 iOS의</p>
</li>
</ul>
<p><code>TimelineReloadPolicy</code> 18가 이에 해당한다. 배터리 소모와 시스템 부하를 최소화하기 위해, 플랫폼은 가능한 한 업데이트 주기를 길게 설정할 것을 강력히 권장한다.12</p>
<ul>
<li>
<p><strong>이벤트 기반 업데이트</strong>: 특정 이벤트가 발생했을 때 위젯을 업데이트하는 방식이다. 예를 들어, 메인 앱에서 데이터가 변경되었을 때, 시스템의 시간대나 언어가 변경되었을 때, 또는 원격 푸시 알림을 수신했을 때 위젯을 즉시 갱신할 수 있다.11</p>
</li>
<li>
<p><strong>사용자 상호작용 기반 업데이트</strong>: 사용자가 위젯 내의 새로고침 버튼을 누르거나 특정 UI 요소와 상호작용했을 때 업데이트가 트리거될 수 있다.</p>
</li>
<li>
<p><strong>크기 변경 (Resize)</strong>: 사용자가 홈 스크린에서 위젯의 경계를 끌어 크기를 조절할 때 발생하는 이벤트다. 위젯 메타데이터에 <code>resizeMode</code> 속성을 <code>horizontal</code>, <code>vertical</code>, 또는 <code>horizontal|vertical</code>로 설정하여 크기 조절 가능 여부와 방향을 지정할 수 있다.14 이 이벤트가 발생하면, 위젯은 변경된 크기에 맞춰 레이아웃과 콘텐츠를 최적화하여 다시 렌더링해야 한다.</p>
</li>
<li>
<p><strong>소멸 (Deletion)</strong>: 사용자가 홈 스크린에서 위젯을 길게 눌러 제거할 때 생명주기가 종료된다. 이 이벤트가 발생하면 시스템은 위젯과 관련된 모든 리소스(예: 할당된 고유 ID, 예약된 업데이트 등)를 정리하고 해제한다. 개발자는 이 시점에 위젯 인스턴스와 관련하여 저장했던 영구 데이터나 설정을 정리하는 로직을 수행할 수 있다. Android에서는 <code>AppWidgetManager</code>의 <code>deleteAppWidgetId()</code> 메소드가 호출되어 ID를 시스템에서 해제한다.26</p>
</li>
</ul>
<p>이러한 생명주기 이벤트들은 위젯이 시스템 리소스를 효율적으로 사용하며, 사용자와의 상호작용에 적절히 반응하도록 설계된 핵심적인 제어 메커니즘이다.</p>
<h2>3.  플랫폼별 사용자 정의 위젯 개발: 심층 가이드</h2>
<p>이 장에서는 Android, iOS, Web 각 플랫폼의 고유한 특성에 맞춰 사용자 정의 위젯을 개발하는 구체적인 방법론을 상세한 코드 예시와 함께 단계별로 탐구한다. 각 플랫폼의 UI 업데이트 메커니즘은 해당 플랫폼이 추구하는 성능 최적화 철학을 깊이 반영하고 있으므로, 이를 이해하는 것이 핵심이다.</p>
<h3>3.1  Android 플랫폼: <code>AppWidgetProvider</code>와 <code>RemoteViews</code> 활용</h3>
<p>Android 위젯은 성숙하고 유연한 시스템을 제공하지만, <code>RemoteViews</code>의 특성상 프로세스 간 통신(IPC)에 대한 이해가 필수적이다. Android의 UI 업데이트 메커니즘은 전체 UI를 매번 새로 그리는 대신, 변경이 필요한 부분에 대한 ‘명령’(<code>setTextViewText</code>, <code>setImageViewResource</code> 등)을 <code>RemoteViews</code> 객체에 담아 홈 스크린 프로세스로 전달하는 방식이다. 이는 IPC 비용을 최소화하여 시스템 효율성을 높이려는 설계 철학을 반영한다.</p>
<ul>
<li><strong>프로젝트 설정</strong>:</li>
</ul>
<ol>
<li>
<p><strong><code>build.gradle</code> 설정</strong>: 특별한 의존성 추가는 필요 없으나, Jetpack Glance와 같은 최신 라이브러리를 사용하려면 관련 의존성을 추가해야 한다.</p>
</li>
<li>
<p><strong><code>AndroidManifest.xml</code> 선언</strong>: 위젯의 핵심인 <code>AppWidgetProvider</code>를 <code>&lt;receiver&gt;</code> 태그로 등록해야 한다. 이 태그는 시스템에 위젯의 존재와 이벤트를 수신할 컴포넌트를 알리는 역할을 한다.</p>
</li>
</ol>
<p>XML</p>
<pre><code> ```
 &lt;receiver
    android:name=".ExampleAppWidgetProvider"
    android:exported="false"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/example_appwidget_info" /&gt;
 &lt;/receiver&gt;
</code></pre>
<pre><code>
`meta-data` 태그는 위젯의 속성을 정의하는 `AppWidgetProviderInfo` XML 파일을 가리킨다.14

- AppWidgetProviderInfo XML 상세 분석:

res/xml/ 디렉터리에 위치하며 위젯의 정적 속성을 정의한다.

XML

</code></pre>
<p><appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
      android:minWidth="180dp"
      android:minHeight="110dp"
      android:updatePeriodMillis="86400000"
      android:previewImage="@drawable/example_appwidget_preview"
      android:initialLayout="@layout/example_appwidget"
      android:resizeMode="horizontal|vertical"
      android:widgetCategory="home_screen"
      android:targetCellWidth="3"
      android:targetCellHeight="2"><br />
</appwidget-provider></p>
<pre><code>
- `minWidth`, `minHeight`: 위젯의 최소 크기를 dp 단위로 지정한다.14

- `updatePeriodMillis`: 주기적 업데이트 간격을 밀리초 단위로 설정한다. 배터리 보호를 위해 안드로이드는 이 값을 최소 30분(1800000ms)으로 강제한다.14

- `initialLayout`: 위젯이 처음 추가될 때 표시될 레이아웃 리소스를 지정한다.

- `resizeMode`: `horizontal` 및 `vertical` 조합으로 크기 조절 가능 여부를 설정한다.5

- `targetCellWidth`, `targetCellHeight`: Android 12 이상에서 그리드 셀 단위의 기본 크기를 지정한다.5

- AppWidgetProvider 클래스 구현:

BroadcastReceiver를 상속하며, 위젯의 생명주기 관련 콜백 메소드를 오버라이드하여 로직을 구현한다.

Java

</code></pre>
<p>public class ExampleAppWidgetProvider extends AppWidgetProvider {<br />
@Override<br />
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetIds) {<br />
for (int appWidgetId : appWidgetIds) {<br />
updateAppWidget(context, appWidgetManager, appWidgetId);<br />
}<br />
}</p>
<pre><code>  static void updateAppWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) {
      // 위젯 UI 업데이트 로직
      RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.example_appwidget);
      views.setTextViewText(R.id.appwidget_text, "UPDATED TEXT");

      // 클릭 이벤트 설정
      Intent intent = new Intent(context, MainActivity.class);
      PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);
      views.setOnClickPendingIntent(R.id.appwidget_button, pendingIntent);

      appWidgetManager.updateAppWidget(appWidgetId, views);
  }
  // onEnabled(), onDisabled(), onDeleted() 등 다른 콜백 구현
</code></pre>
<p>}</p>
<pre><code>
`onUpdate()`는 주기적 업데이트 또는 수동 업데이트 요청 시 호출되는 가장 중요한 메소드다.14

- RemoteViews를 이용한 UI 제어:

RemoteViews는 다른 프로세스에서 렌더링될 뷰의 레이아웃과 내용을 기술하는 객체다. setTextViewText(), setImageViewResource(), setOnClickPendingIntent() 등 제한된 메소드만을 사용하여 UI를 조작할 수 있다.17 이는 보안과 성능을 위한 제약이다.

- **실습 예제**: GitHub에서 제공되는 다양한 예제 프로젝트를 통해 실제 구현 사례를 참고할 수 있다. 예를 들어, 조수 시간을 보여주는 위젯, 사용자 정의 아날로그 시계, 차트 라이브러리 위젯 등은 `AppWidgetProvider`와 `RemoteViews`의 실제 활용법을 이해하는 데 큰 도움이 된다.27

### 3.2  iOS 플랫폼: WidgetKit과 SwiftUI의 조화


iOS 위젯 개발은 WidgetKit 프레임워크와 SwiftUI를 중심으로 이루어진다. WidgetKit의 핵심 철학은 '예측 기반' UI 업데이트다. 개발자는 `TimelineProvider`를 통해 미래의 특정 시점에 위젯이 보여줘야 할 상태 스냅샷(`TimelineEntry`)의 목록, 즉 타임라인을 시스템에 미리 제공한다. 시스템은 이 타임라인을 바탕으로 정해진 시간에 효율적으로 위젯을 렌더링하며, 잦은 백그라운드 실행을 피해 배터리 소모를 최소화한다.

- **프로젝트 설정**:

1. **Widget Extension 추가**: 기존 Xcode 프로젝트에서 `File &gt; New &gt; Target`을 선택하고 'Widget Extension' 템플릿을 추가한다.18

2. **App Groups 설정**: 메인 앱과 위젯 익스텐션 간에 데이터를 안전하게 공유하기 위해 'Signing &amp; Capabilities' 탭에서 동일한 App Group을 활성화해야 한다. `UserDefaults`나 Core Data를 공유하는 데 필수적이다.7

- **WidgetKit의 핵심 프로토콜 이해**:

- **`Widget`**: 위젯의 구성을 정의하는 최상위 진입점이다. `body` 프로퍼티 내에서 `StaticConfiguration` (사용자 설정 불필요) 또는 `IntentConfiguration` (사용자 설정 필요)을 반환한다.7

- **`TimelineProvider`**: 위젯의 데이터와 업데이트 시점을 관리하는 핵심 프로토콜이다.18

- `placeholder(in:)`: 위젯이 로딩 중일 때 표시할 기본 뷰의 데이터를 제공한다.

- `getSnapshot(in:completion:)`: 위젯 갤러리에서 위젯을 미리보기 형태로 보여줄 때 사용될 단일 데이터를 제공한다.

- `getTimeline(in:completion:)`: 현재 시점 이후의 위젯 업데이트 계획(타임라인)을 생성하여 시스템에 전달한다.

- **`TimelineEntry`**: 특정 `date`에 위젯이 표시해야 할 모든 데이터를 담는 모델 구조체다. `Date` 타입의 `date` 프로퍼티를 반드시 포함해야 한다.7

- SwiftUI를 활용한 위젯 뷰 제작:

위젯의 UI는 전적으로 SwiftUI로 작성된다. Text, Image, VStack, HStack, ZStack 등 기본적인 뷰와 스택을 조합하여 레이아웃을 구성한다.21 위젯은

`systemSmall`, `systemMedium`, `systemLarge` 등 여러 크기(family)를 지원할 수 있으며, `@Environment(\.widgetFamily)` 프로퍼티를 사용하여 현재 크기에 맞는 뷰를 동적으로 보여줘야 한다.13

Swift

</code></pre>
<p>struct ExampleWidgetEntryView : View {<br />
var entry: Provider.Entry<br />
@Environment(.widgetFamily) var family</p>
<pre><code>  var body: some View {
      switch family {
      case.systemSmall:
          SmallWidgetView(entry: entry)
      case.systemMedium:
          MediumWidgetView(entry: entry)
      default:
          Text("Unsupported size")
      }
  }
</code></pre>
<p>}</p>
<pre><code>
- 설정 가능(Configurable) 위젯 구현:

사용자가 위젯의 내용을 직접 선택하게 하려면 IntentConfiguration을 사용해야 한다. 이를 위해 커스텀 AppIntent를 정의하고, @Parameter 프로퍼티 래퍼를 사용하여 설정 가능한 속성을 추가한다. 예를 들어, 특정 GitHub 저장소를 선택하는 위젯을 만든다면, 저장소 이름을 String 타입의 파라미터로 정의할 수 있다. EntityQuery를 구현하면 API를 통해 동적인 선택 옵션 목록을 사용자에게 제공할 수도 있다.25

- **실습 예제**: GitHub에는 WidgetKit을 활용한 다양한 오픈소스 프로젝트가 있다. iOS 14부터 최신 iOS 17의 Live Activity까지 다양한 기능을 구현한 예제들을 통해 WidgetKit의 실제 적용 사례를 학습할 수 있다.32

### 3.3  Web (JavaScript) 플랫폼: 유연성과 이식성


웹 위젯은 특정 운영체제에 종속되지 않고, HTML, CSS, JavaScript라는 표준 웹 기술을 사용하여 구현되므로 최고의 유연성과 이식성을 자랑한다. React와 같은 현대적인 프레임워크는 웹 위젯 개발을 컴포넌트 기반으로 체계화하여 생산성을 크게 향상시켰다. 웹 위젯의 UI 업데이트는 React의 가상 DOM(Virtual DOM)과 같은 메커니즘을 통해 효율적으로 이루어진다. 상태가 변경되면, 가상 DOM은 이전 상태와 현재 상태를 비교(diffing)하여 실제 DOM에는 변경된 부분만 최소한으로 반영함으로써 렌더링 성능을 최적화한다.

- 순수 JavaScript를 이용한 위젯 컴포넌트화:

프레임워크 없이도 위젯을 모듈화하여 개발할 수 있다. HTML 템플릿, CSS 스타일, JavaScript 로직을 별도의 파일로 분리하고, ES6 클래스나 모듈 패턴을 사용하여 재사용 가능한 컴포넌트를 만든다.15

`onLoad` (초기화), `beforeAppear` (화면에 표시될 때마다)와 같은 생명주기 메소드를 직접 구현하여 위젯의 동작을 제어할 수 있다.15

- React 기반의 재사용 가능한 위젯 컴포넌트 설계:

React는 웹 위젯 개발에 가장 널리 사용되는 라이브러리 중 하나다.

1. **프로젝트 생성**: `npx @staffbase/create-widget`과 같은 CLI 도구를 사용하면 위젯 개발에 필요한 기본 구조를 빠르게 설정할 수 있다.24

2. **컴포넌트 구현**: 위젯의 UI와 로직을 하나의 React 컴포넌트로 캡슐화한다. 외부 데이터는 `props`를 통해 주입받고, 내부 상태는 `useState` 훅으로 관리한다. 백엔드 API 호출과 같은 부수 효과(side effect)는 `useEffect` 훅을 사용하여 처리한다.20

JavaScript

     ```
     // React Widget Example
     import React, { useState, useEffect } from 'react';
     
     const CurrencyWidget = ({ baseCurrency }) =&gt; {
        const = useState(null);
     
        useEffect(() =&gt; {
            fetch(`https://api.exchangerate-api.com/v4/latest/${baseCurrency}`)
               .then(res =&gt; res.json())
               .then(data =&gt; setRate(data.rates.USD));
        }, [baseCurrency]);
     
        return (
            &lt;div className="widget-container"&gt;
                {rate? `1 ${baseCurrency} = ${rate} USD` : 'Loading...'}        &lt;/div&gt;
        );
     };
     
     export default CurrencyWidget;
</code></pre>
<ul>
<li>외부 사이트 임베딩 및 스타일 격리:</li>
</ul>
<p>개발된 웹 위젯은 <script> 태그를 통해 JavaScript 번들 파일을 로드하거나, <iframe>을 사용하여 외부 웹 페이지에 손쉽게 삽입할 수 있다.16 그러나 위젯의 CSS가 호스트 페이지의 스타일에 영향을 주거나 받는 ‘스타일 충돌’ 문제가 발생할 수 있다. 이 문제를 근본적으로 해결하는 가장 효과적인 방법은</p>
<p><strong>Shadow DOM</strong>을 사용하는 것이다. Shadow DOM은 위젯의 DOM 트리와 스타일을 외부로부터 완전히 격리된 ’그림자 영역’에 생성하여, 위젯의 안정성과 이식성을 보장하는 핵심 기술이다.39</p>
<ul>
<li><strong>실습 예제</strong>: GitHub에는 React 기반의 커스텀 위젯, 차트 컴포넌트, 챗봇 위젯 등 다양한 예제가 풍부하게 공개되어 있다. 이러한 프로젝트들은 컴포넌트 설계, 상태 관리, 외부 라이브러리 연동 등 실제 웹 위젯 개발에 필요한 고급 기법들을 학습하는 데 훌륭한 자료가 된다.39</li>
</ul>
<h2>4.  고급 기능 구현: 동적 상호작용과 데이터 바인딩</h2>
<p>위젯을 단순한 정보 표시기를 넘어 사용자와 능동적으로 소통하는 동적인 도구로 만들기 위해서는 사용자 입력을 처리하고, 데이터를 실시간으로 동기화하며, 외부 서비스와 연동하는 고급 기술이 필요하다. 이 과정에서 개발 패러다임이 ’명령형’에서 ’선언형’으로 전환되는 현상이 뚜렷하게 나타난다.</p>
<h3>4.1  사용자 입력 처리를 위한 이벤트 핸들링 심층 분석</h3>
<p>사용자가 위젯 내의 버튼을 클릭하거나 값을 변경하는 등의 상호작용에 응답하는 것은 위젯의 활용성을 극대화하는 핵심 요소다. 각 플랫폼은 고유한 이벤트 처리 모델을 제공한다.</p>
<ul>
<li>
<p><strong>이벤트 처리 모델 비교</strong>:</p>
</li>
<li>
<p><strong>Android</strong>: <code>PendingIntent</code>는 Android 위젯 이벤트 처리의 핵심이다. <code>PendingIntent</code>는 인텐트(Intent)와 그것을 실행할 대상 액션(Activity 시작, Service 시작, Broadcast 전송 등)을 묶은 일종의 토큰이다. 위젯의 <code>RemoteViews</code>에 <code>setOnClickPendingIntent()</code> 메소드를 사용하여 버튼과 같은 뷰에 <code>PendingIntent</code>를 등록하면, 사용자가 해당 뷰를 클릭했을 때 홈 스크린 앱이 위임받은 권한으로 지정된 인텐트를 실행한다. 이는 다른 프로세스에서 안전하게 내 앱의 컴포넌트를 호출하기 위한 정교한 메커니즘이다.</p>
</li>
<li>
<p><strong>iOS</strong>: iOS 17 이전까지 위젯은 단순한 딥링크(Deep Link)만을 지원했지만, iOS 17부터는 <code>Button</code>과 <code>Toggle</code>을 통해 앱을 실행하지 않고도 위젯 내에서 직접적인 상호작용이 가능해졌다. 이 상호작용은 <code>AppIntent</code>라는 구조화된 요청을 통해 처리된다. 개발자는 특정 작업을 수행하는 커스텀 <code>AppIntent</code>를 정의하고, SwiftUI의 <code>Button</code>에 이 인텐트를 연결한다. 사용자가 버튼을 누르면, 시스템은 해당 인텐트를 백그라운드에서 실행하고, 그 결과에 따라 위젯의 타임라인을 갱신하여 UI를 업데이트할 수 있다.7</p>
</li>
<li>
<p><strong>Web</strong>: 웹 플랫폼은 표준 JavaScript 이벤트 모델을 그대로 사용한다. <code>addEventListener</code> 메소드나 <code>onclick</code>과 같은 인라인 속성을 사용하여 클릭, 마우스 오버, 키 입력 등 거의 모든 종류의 사용자 상호작용을 자유롭게 처리할 수 있다. 이는 세 플랫폼 중 가장 유연하고 강력한 이벤트 처리 능력을 제공한다.44</p>
</li>
<li>
<p>이벤트 리스너와 핸들러:</p>
</li>
</ul>
<p>플랫폼에 관계없이 이벤트 처리의 기본 구조는 ’이벤트 리스너(Event Listener)’가 사용자 상호작용을 감지하고, 등록된 ‘이벤트 핸들러(Event Handler)’ 함수를 호출하는 방식이다. Android의 View.OnClickListener, iOS의 Button에 전달되는 클로저, JavaScript의 콜백 함수 등이 모두 이러한 패턴에 해당한다.45</p>
<h3>4.2  실시간 데이터 동기화를 위한 데이터 바인딩 패턴</h3>
<p>데이터 바인딩은 UI 컴포넌트를 데이터 소스에 직접 연결하여, 데이터가 변경될 때 UI가 자동으로 업데이트되도록 하는 기술이다. 이는 <code>findViewById()</code>나 <code>document.getElementById()</code>와 같은 수동적인 뷰 조작 코드를 제거함으로써 코드의 양을 줄이고, 가독성과 유지보수성을 획기적으로 향상시킨다.49</p>
<p>이러한 데이터 바인딩 기술의 도입은 위젯 개발 패러다임을 근본적으로 변화시켰다. 과거의 명령형(Imperative) 프로그래밍은 “버튼 객체를 찾아서, 그 객체의 텍스트를 ’업데이트’로 설정하라“와 같이 UI를 조작하는 방법을 단계별로 명시했다.52 이 방식은 UI가 복잡해지고 상태가 다양해질수록, 어떤 상태에서 어떤 UI 업데이트를 수행해야 하는지에 대한 모든 경우의 수를 개발자가 직접 관리해야 하므로 코드의 복잡도가 기하급수적으로 증가하고 버그 발생 가능성이 높아진다.</p>
<p>반면, 데이터 바인딩이 적용된 선언형(Declarative) 프로그래밍은 “이 텍스트 뷰의 내용은 데이터 모델의 <code>message</code> 속성 값이다“라고 UI와 데이터의 관계를 ’선언’하기만 하면 된다.49 그러면 프레임워크가 데이터 모델의 변경을 감지하여 UI 업데이트를 자동으로 처리한다. 개발자는 더 이상 UI의 ‘전환’ 과정을 고민할 필요 없이, 각 ’상태’에만 집중하면 되므로, 특히 상태 변화가 잦은 동적인 위젯을 개발할 때 생산성과 안정성이 극적으로 향상된다.</p>
<ul>
<li>Android 데이터 바인딩:</li>
</ul>
<p>Android Jetpack의 데이터 바인딩 라이브러리는 XML 레이아웃 파일에 직접 로직을 추가할 수 있게 해준다.</p>
<ol>
<li>
<p>레이아웃 파일의 루트를 <code>&lt;layout&gt;</code> 태그로 감싼다.</p>
</li>
<li>
<p><code>&lt;data&gt;</code> 블록 안에 <code>&lt;variable&gt;</code> 태그를 사용하여 레이아웃에서 사용할 데이터 객체(예: ViewModel)를 선언한다.</p>
</li>
<li>
<p><code>@{variable.property}</code>와 같은 표현식을 사용하여 뷰의 속성을 데이터 객체의 속성에 바인딩한다.</p>
</li>
</ol>
<p>XML</p>
<pre><code>&lt;layout...&gt;
    &lt;data&gt;
        &lt;variable name="userViewModel" type="com.example.UserViewModel" /&gt;
    &lt;/data&gt;
    &lt;TextView android:text="@{userViewModel.userName}"... /&gt;
&lt;/layout&gt;
</code></pre>
<p>또한, <code>@={}</code> 구문을 사용하면 사용자의 입력이 데이터 모델에 자동으로 반영되는 양방향 데이터 바인딩도 구현할 수 있다.49</p>
<ul>
<li>SwiftUI 데이터 바인딩:</li>
</ul>
<p>SwiftUI는 프레임워크 자체가 데이터 바인딩을 핵심 원리로 설계되었다. 다양한 프로퍼티 래퍼(Property Wrapper)를 통해 데이터의 흐름을 관리한다.</p>
<ul>
<li>
<p><code>@State</code>: 뷰 내부에서만 사용되는 단순한 값 타입(String, Int, Bool 등)의 상태를 관리한다. <code>@State</code> 변수의 값이 변경되면 해당 뷰는 자동으로 다시 렌더링된다.55</p>
</li>
<li>
<p><code>@Binding</code>: 부모 뷰가 소유한 <code>@State</code> 변수에 대한 ’참조’를 자식 뷰에 전달할 때 사용된다. 이를 통해 자식 뷰에서 값을 변경하면 부모 뷰의 상태가 업데이트되어, 뷰 계층 구조 간에 양방향 데이터 동기화가 이루어진다.54</p>
</li>
<li>
<p><code>ObservableObject</code>: 여러 뷰에서 공유되어야 하는 복잡한 참조 타입(클래스) 데이터 모델을 관리할 때 사용된다. <code>@Published</code> 프로퍼티 래퍼와 함께 사용하여, 속성 값이 변경될 때마다 이를 구독하는 모든 뷰에 변경 사항을 알린다.56</p>
</li>
</ul>
<h3>4.3  백엔드 API 연동 및 데이터 캐싱 전략</h3>
<p>대부분의 동적 위젯은 네트워크를 통해 외부 서버로부터 최신 데이터를 가져와야 한다. 이 과정에서 성능과 사용자 경험을 최적화하기 위한 전략이 필요하다.</p>
<ul>
<li>비동기 데이터 로딩:</li>
</ul>
<p>네트워크 요청은 시간이 오래 걸릴 수 있으므로 반드시 메인 UI 스레드가 아닌 별도의 백그라운드 스레드에서 비동기적으로 처리해야 한다. 이를 소홀히 하면 UI가 멈추는 현상(ANR in Android)이 발생하여 사용자 경험을 심각하게 저해한다. 각 플랫폼은 현대적인 비동기 처리 방식을 제공한다.</p>
<ul>
<li>
<p><strong>Android</strong>: Kotlin Coroutines</p>
</li>
<li>
<p><strong>iOS</strong>: Swift Concurrency (async/await)</p>
</li>
<li>
<p><strong>Web</strong>: JavaScript Promises 및 async/await</p>
</li>
<li>
<p>데이터 캐싱:</p>
</li>
</ul>
<p>네트워크 요청 횟수를 줄이고, 오프라인 상태에서도 위젯이 유용한 정보를 표시할 수 있도록 데이터를 기기 내에 일시적으로 저장하는 것은 매우 중요하다.</p>
<ul>
<li>
<p><strong>간단한 캐싱</strong>: 소량의 키-값 데이터를 저장하는 데에는 <code>SharedPreferences</code>(Android), <code>UserDefaults</code>(iOS), <code>localStorage</code>(Web)가 적합하다.</p>
</li>
<li>
<p><strong>고급 캐싱</strong>: 복잡한 구조의 데이터를 저장하거나 쿼리가 필요한 경우에는 Room(Android), Core Data/SwiftData(iOS), IndexedDB(Web)와 같은 로컬 데이터베이스를 사용하는 것이 효과적이다. 캐시된 데이터와 함께 마지막 업데이트 시간을 저장해두면, 일정 시간이 지나기 전까지는 네트워크 요청 없이 캐시된 데이터를 우선적으로 사용하도록 구현하여 데이터 사용량과 배터리 소모를 줄일 수 있다.</p>
</li>
</ul>
<h2>5.  위젯 스타일링 및 UI/UX 최적화 전략</h2>
<p>기능적으로 완벽한 위젯이라도 시각적으로 매력적이지 않거나 사용하기 불편하다면 사용자의 선택을 받기 어렵다. 성공적인 위젯은 기능과 디자인, 그리고 성능이 조화를 이룰 때 탄생한다. 특히 위젯의 UI/UX는 ’정보의 밀도’와 ‘즉시성’ 사이의 정교한 균형에 달려있다. 사용자는 위젯을 1~2초의 짧은 시간 동안 빠르게 훑어본다. 이 짧은 순간에 너무 많은 정보를 전달하려 하면 오히려 인지적 과부하를 유발하여 위젯의 가치를 떨어뜨린다. 따라서 위젯 디자인은 ’제거의 미학’이 필요하다. 어떤 정보를 보여줄지 결정하는 것보다 어떤 정보를 ’보여주지 않을지’를 결정하는 것이 더 중요하다.12 “사용자가 이 위젯을 통해 1초 안에 얻고자 하는 핵심 가치는 무엇인가?“라는 질문에 대한 명확한 답이 위젯의 정보 구조, 레이아웃, 업데이트 빈도 등 모든 기술적 결정을 이끌어가는 나침반이 되어야 한다.</p>
<h3>5.1  플랫폼별 스타일링 기법</h3>
<ul>
<li>
<p><strong>Android</strong>: Android의 스타일링 시스템은 XML 기반으로 체계화되어 있다.</p>
</li>
<li>
<p><strong><code>styles.xml</code></strong>: 뷰의 속성(색상, 크기, 패딩 등) 집합을 하나의 스타일로 정의하여 재사용할 수 있다. 이는 웹의 CSS 클래스와 유사한 역할을 한다.</p>
</li>
<li>
<p><strong><code>themes.xml</code></strong>: 앱이나 액티비티 전체에 일관된 스타일을 적용하는 데 사용된다. 스타일을 상속하여 기존 스타일을 확장하거나 일부 속성만 변경할 수도 있다.</p>
</li>
<li>
<p><strong><code>attrs.xml</code></strong>: 사용자 정의 뷰나 위젯을 만들 때, XML 레이아웃에서 직접 설정할 수 있는 커스텀 속성을 정의하는 데 사용된다. 이를 통해 위젯의 스타일을 더욱 유연하게 제어할 수 있다.58</p>
</li>
<li>
<p><strong>iOS (SwiftUI)</strong>: SwiftUI는 ’View Modifier’라는 강력하고 직관적인 스타일링 메커니즘을 제공한다.</p>
</li>
<li>
<p><strong>View Modifier</strong>: <code>.font()</code>, <code>.foregroundColor()</code>, <code>.padding()</code>, <code>.background()</code> 등과 같은 메소드를 뷰에 연쇄적으로 적용하여 모양을 선언적으로 꾸민다.</p>
</li>
<li>
<p><strong>위젯 전용 Modifier</strong>: <code>.containerBackground(_:for:)</code>와 같은 Modifier는 위젯의 배경을 시스템 정책에 맞게 안전하게 설정하는 데 사용된다. 이를 사용하면 위젯이 다양한 컨텍스트(예: 잠금 화면, 스탠바이 모드)에서 적절하게 표시되도록 보장할 수 있다.7</p>
</li>
<li>
<p><strong>Web (CSS)</strong>: 웹 위젯은 표준 CSS의 모든 기능을 활용할 수 있어 가장 높은 스타일링 자유도를 가진다.</p>
</li>
<li>
<p><strong>적용 방식</strong>: 인라인 스타일, <code>&lt;style&gt;</code> 태그를 이용한 내부 스타일시트, 별도 <code>.css</code> 파일을 링크하는 외부 스타일시트 등 다양한 방식으로 스타일을 적용할 수 있다.</p>
</li>
<li>
<p><strong>CSS-in-JS</strong>: Styled Components, Emotion과 같은 라이브러리를 사용하면 JavaScript 코드 내에서 컴포넌트 단위로 스타일을 정의하고 동적으로 제어할 수 있어, 대규모 프로젝트에서 스타일 관리의 복잡성을 줄여준다.</p>
</li>
<li>
<p><strong>스타일 격리</strong>: 앞서 언급한 Shadow DOM을 사용하면 위젯의 스타일이 외부의 영향을 받지 않도록 완벽하게 격리할 수 있다.60</p>
</li>
</ul>
<h3>5.2  반응형 레이아웃 및 다양한 위젯 크기 지원</h3>
<p>사용자는 다양한 크기의 화면을 가진 기기에서 위젯을 사용하며, 홈 스크린에서 직접 위젯의 크기를 조절할 수도 있다. 따라서 위젯의 레이아웃은 어떤 크기에서도 콘텐츠가 깨지거나 잘리지 않고 최적으로 표시되도록 반응형으로 설계되어야 한다.</p>
<ul>
<li>
<p><strong>Android</strong>: <code>ConstraintLayout</code>은 복잡한 반응형 레이아웃을 유연하게 구성하는 데 가장 효과적인 도구다. 화면 크기나 방향에 따라 다른 레이아웃을 적용해야 할 경우, <code>res/layout-large</code>, <code>res/layout-land</code>와 같은 한정자(qualifier)를 사용하여 다양한 레이아웃 리소스를 제공할 수 있다.</p>
</li>
<li>
<p><strong>iOS</strong>: SwiftUI는 기본적으로 유연한 레이아웃 시스템을 갖추고 있다. <code>GeometryReader</code>를 사용하면 부모 뷰의 크기와 좌표 정보를 얻어와 자식 뷰의 크기나 위치를 동적으로 계산할 수 있다. iOS 16부터 도입된 <code>ViewThatFits</code>는 사용 가능한 공간에 가장 적합한 뷰를 여러 후보 중에서 자동으로 선택해주어 반응형 UI 구현을 더욱 간소화한다.</p>
</li>
</ul>
<h3>5.3  성능 최적화: 배터리 소모와 데이터 사용량 최소화</h3>
<p>위젯은 주로 백그라운드에서 동작하므로, 시스템 리소스, 특히 배터리와 네트워크 데이터 사용을 최소화하도록 최적화하는 것이 매우 중요하다.</p>
<ul>
<li><strong>효율적인 업데이트 주기 설정</strong>: 위젯이 표시하는 데이터의 중요도와 실시간성 요구 수준을 신중하게 고려하여 최적의 업데이트 주기를 설정해야 한다. 주식 시세와 같이 실시간성이 중요한 데이터가 아니라면, 업데이트 주기는 가능한 길게(예: 1시간 이상) 설정하는 것이 좋다. 불필요하게 잦은 업데이트는 배터리를 빠르게 소모시키는 주된 원인이다.12 iOS의 경우, 한 번의</li>
</ul>
<p><code>getTimeline</code> 호출에서 가능한 한 긴 미래의 타임라인을 제공하여 백그라운드 실행 횟수 자체를 줄이는 것이 핵심 최적화 전략이다.</p>
<ul>
<li>
<p><strong>가벼운 페이로드(Payload)</strong>: 위젯을 업데이트하기 위해 백엔드 API를 호출할 때, 필요한 최소한의 데이터만 요청하고 응답받도록 API를 설계해야 한다. 이미지와 같은 큰 데이터는 필요한 해상도에 맞게 리사이징하여 전송하고, 텍스트 데이터는 불필요한 메타데이터를 제거하여 페이로드 크기를 줄여야 한다. 이는 네트워크 사용량을 절약하고 데이터 처리 시간을 단축하여 전반적인 성능을 향상시킨다.</p>
</li>
<li>
<p><strong>콘텐츠 미리보기(Placeholder)와 스켈레톤 UI</strong>: 네트워크 지연 등으로 인해 데이터를 즉시 로드할 수 없는 경우, 사용자에게 빈 화면을 보여주는 대신 의미 있는 UI를 제공해야 한다.</p>
</li>
<li>
<p><strong>플레이스홀더</strong>: 위젯의 실제 데이터가 로드되기 전에 보여주는 정적인 기본 UI다. 위젯의 레이아웃 구조를 미리 보여주어 사용자가 어떤 내용이 표시될지 예측할 수 있게 한다.13</p>
</li>
<li>
<p><strong>스켈레톤 UI</strong>: 데이터가 로드될 영역을 회색 상자나 반짝이는 애니메이션으로 표시하여, 시스템이 활발하게 작업 중임을 시각적으로 알려주는 기법이다. 이는 사용자가 느끼는 대기 시간을 줄여주고 더 나은 사용자 경험을 제공한다.</p>
</li>
</ul>
<h2>6.  배포 및 유지보수</h2>
<p>사용자 정의 위젯 개발의 마지막 단계는 사용자가 실제로 사용할 수 있도록 배포하고, 지속적으로 관리하는 것이다. 이 과정은 플랫폼별 정책을 준수하고, 장기적인 관점에서 안정성을 확보하는 전략을 포함한다.</p>
<h3>6.1  플랫폼별 위젯 배포 가이드라인</h3>
<ul>
<li>
<p><strong>Android (Google Play)</strong>: Google Play는 위젯 기능 자체에 대해 엄격한 제한을 두지는 않지만, 위젯이 백그라운드에서 과도한 리소스(배터리, 데이터)를 사용하지 않도록 주의해야 한다. 특히 백그라운드 실행 제한 정책을 준수하고, 효율적인 업데이트 로직을 구현하는 것이 중요하다. 위젯의 미리보기 이미지를 명확하게 제공하여 사용자가 위젯을 선택하기 전에 그 기능을 쉽게 파악할 수 있도록 해야 한다.</p>
</li>
<li>
<p><strong>iOS (Apple App Store)</strong>: Apple은 위젯의 디자인과 기능에 대해 비교적 상세한 가이드라인(Human Interface Guidelines)을 제시하며, 앱 심사 과정에서 이를 준수하는지 검토한다. 위젯은 광고를 표시해서는 안 되며, 앱의 핵심 기능을 보조하는 명확한 목적을 가져야 한다. 또한, 모든 지원 크기에서 올바르게 렌더링되어야 하며, 데이터 로딩 시 적절한 플레이스홀더를 제공해야 한다.12</p>
</li>
<li>
<p><strong>Web</strong>: 웹 위젯은 특정 스토어의 심사를 거치지 않으므로 배포가 자유롭지만, 그만큼 개발자의 책임이 크다.</p>
</li>
<li>
<p><strong>설치 가이드</strong>: 다른 웹사이트 개발자들이 위젯을 쉽게 자신의 사이트에 통합할 수 있도록, 복사-붙여넣기만으로 가능한 간단한 <code>&lt;script&gt;</code> 태그와 명확한 설정 옵션 문서를 제공해야 한다.</p>
</li>
<li>
<p><strong>CDN 배포</strong>: 위젯의 JavaScript 및 CSS 파일을 Amazon S3, Cloudflare와 같은 콘텐츠 전송 네트워크(CDN)를 통해 배포하면 전 세계 사용자들이 더 빠르고 안정적으로 위젯을 로드할 수 있다.24</p>
</li>
<li>
<p><strong>보안</strong>: 외부 사이트에서 실행되는 만큼, 크로스 사이트 스크립팅(XSS)과 같은 보안 위협에 대비해야 한다. 사용자 입력을 항상 검증하고, 민감한 데이터를 안전하게 처리하는 것이 필수적이다.</p>
</li>
</ul>
<h3>6.2  버전 관리 및 하위 호환성 유지 전략</h3>
<p>위젯은 한번 배포되면 수많은 사용자의 기기에서 동작하므로, 업데이트 시 기존 사용자의 경험을 해치지 않도록 신중하게 접근해야 한다.</p>
<ul>
<li>
<p><strong>버전 관리</strong>: 웹 위젯의 경우, SemVer(Semantic Versioning) 규칙에 따라 버전을 관리하고, API 변경과 같은 파괴적인(breaking) 업데이트가 있을 경우 메이저 버전을 올려 기존 사용자에게 영향을 주지 않도록 해야 한다.</p>
</li>
<li>
<p><strong>하위 호환성</strong>: 새로운 버전의 운영체제에서 제공하는 API를 사용하더라도, 이전 버전의 OS를 사용하는 사용자들이 위젯을 계속 사용할 수 있도록 분기 처리를 해야 한다. Android에서는 SDK 버전 코드를 확인하고, iOS에서는 <code>@available</code> 속성을 사용하여 특정 OS 버전 이상에서만 코드가 실행되도록 할 수 있다.</p>
</li>
<li>
<p><strong>안정적인 데이터 마이그레이션</strong>: 위젯이 사용하는 데이터 구조(예: <code>SharedPreferences</code>나 <code>UserDefaults</code>에 저장된 데이터)가 변경될 경우, 기존 데이터를 새로운 구조로 안전하게 마이그레이션하는 로직을 포함해야 한다. 이를 통해 앱 업데이트 후에도 사용자의 설정이 유지되고 위젯이 정상적으로 동작하도록 보장할 수 있다.</p>
</li>
</ul>
<h2>7.  결론: 성공적인 사용자 정의 위젯 구현을 위한 제언</h2>
<h3>7.1  핵심 원칙 요약 및 기술적 트레이드오프 분석</h3>
<p>본 안내서에서 다룬 사용자 정의 위젯 개발의 전 과정을 통해, 성공적인 위젯 구현을 위한 몇 가지 핵심 원칙을 도출할 수 있다.</p>
<ol>
<li>
<p><strong>플랫폼 철학의 이해</strong>: 각 플랫폼(Android, iOS, Web)이 위젯을 바라보는 근본적인 철학과 아키텍처 설계 사상을 이해하는 것이 기술 습득보다 선행되어야 한다. 이는 업데이트 메커니즘, UI 제약, 상호작용 모델 등 기술적 선택의 배경을 이해하고 최적의 솔루션을 찾는 데 결정적인 역할을 한다.</p>
</li>
<li>
<p><strong>선언형 패러다임의 채택</strong>: 데이터 바인딩과 선언적 UI 프레임워크(SwiftUI, React 등)를 적극적으로 활용해야 한다. 이는 복잡한 UI 상태 관리를 프레임워크에 위임하여 코드의 안정성과 유지보수성을 극적으로 향상시키는 현대적인 위젯 개발의 표준이다.</p>
</li>
<li>
<p><strong>’Glanceability’의 추구</strong>: 위젯은 앱의 축소판이 아니다. 사용자가 1~2초 내에 핵심 정보를 파악할 수 있도록 ‘한눈에 보기 좋은(glanceable)’ 경험을 제공하는 데 집중해야 한다. 정보의 밀도와 즉시성 사이의 균형을 맞추는 것이 UI/UX 설계의 핵심이다.</p>
</li>
<li>
<p><strong>성능 최우선주의</strong>: 위젯은 시스템 리소스에 민감한 백그라운드 환경에서 동작한다. 배터리 소모, 네트워크 사용량, 메모리 점유율을 최소화하기 위한 최적화는 선택이 아닌 필수 사항이다.</p>
</li>
</ol>
<p>이러한 원칙을 적용하는 과정에서 개발자는 필연적으로 여러 기술적 트레이드오프(Trade-off)에 직면하게 된다.</p>
<ul>
<li>
<p><strong>기능의 풍부함 vs. 성능</strong>: 위젯에 더 많은 기능과 화려한 애니메이션을 추가할수록 배터리 소모와 시스템 부하는 증가한다. 사용자의 만족도를 높이는 핵심 기능과 성능 저하를 유발하는 부가 기능 사이에서 신중한 선택이 필요하다.</p>
</li>
<li>
<p><strong>업데이트 빈도 vs. 데이터 실시간성</strong>: 데이터를 더 자주 업데이트하면 사용자에게 최신 정보를 제공할 수 있지만, 배터리와 데이터 사용량이 급증한다. 데이터의 성격(예: 실시간 주가 vs. 일일 날씨 예보)을 고려하여 최적의 업데이트 주기를 결정해야 한다.</p>
</li>
<li>
<p><strong>개발 자유도 vs. 플랫폼 일관성</strong>: 플랫폼 가이드라인을 벗어난 독창적인 디자인은 앱의 브랜딩을 강화할 수 있지만, 사용자에게 혼란을 주고 플랫폼의 전반적인 사용자 경험을 해칠 수 있다. 혁신과 일관성 사이의 균형점을 찾는 것이 중요하다.</p>
</li>
</ul>
<h3>7.2  미래 위젯 기술 동향 전망</h3>
<p>사용자 정의 위젯 기술은 계속해서 진화하고 있으며, 앞으로 몇 가지 주요한 방향으로 발전할 것으로 예상된다.</p>
<ul>
<li>
<p><strong>지능화 및 개인화</strong>: 인공지능(AI)과 머신러닝(ML) 기술이 위젯에 접목되면서, 사용자의 현재 상황, 위치, 시간, 과거 행동 패턴 등을 분석하여 가장 필요할 것으로 예측되는 정보와 기능을 능동적으로 제공하는 ’지능형 위젯’이 보편화될 것이다. Apple의 스마트 스택(Smart Stack)은 이러한 방향성의 초기 단계라 할 수 있으며, 앞으로는 더욱 정교한 개인화 및 추천 기능이 위젯의 핵심 경쟁력이 될 것이다.63</p>
</li>
<li>
<p><strong>확장된 현실과의 융합</strong>: 증강 현실(AR) 글래스나 새로운 폼팩터(폴더블폰, 웨어러블 기기)가 대중화됨에 따라 위젯의 역할과 형태도 변화할 것이다. AR 환경에서는 물리적 공간에 오버레이되는 컨텍스트 기반 정보 위젯이 등장할 수 있으며, 폴더블폰의 커버 스크린이나 스마트워치 페이스는 위젯이 주된 인터페이스로 활약할 새로운 무대가 될 것이다.</p>
</li>
<li>
<p><strong>플랫폼 간 경계의 약화</strong>: 현재는 각 플랫폼에 맞춰 위젯을 별도로 개발해야 하지만, Flutter나 React Native와 같은 크로스플랫폼 프레임워크에서 위젯 개발을 통합적으로 지원하려는 시도가 계속될 것이다. 기술이 성숙하면, 단일 코드베이스로 여러 플랫폼에 일관된 경험의 위젯을 배포하는 것이 가능해져 개발 생산성이 크게 향상될 수 있다.</p>
</li>
</ul>
<p>결론적으로, 사용자 정의 위젯은 단순한 앱의 부가 기능을 넘어, 사용자와 앱을 연결하는 가장 즉각적이고 개인화된 접점으로서 그 중요성이 날로 커지고 있다. 개발자는 본 안내서에서 제시한 아키텍처 원리, 플랫폼별 구현 전략, 그리고 최적화 기법을 깊이 이해하고 적용함으로써, 사용자에게 진정한 가치를 제공하고 빠르게 변화하는 기술 생태계에서 경쟁력을 확보할 수 있을 것이다.</p>
<h2>8. 참고 자료</h2>
<ol>
<li>SDK란 무엇인가요? - SDK 설명 - AWS, https://aws.amazon.com/ko/what-is/sdk/</li>
<li>SDK란? 소프트웨어 개발 키트 뜻, 플랫폼, 차이점, 종류 탐험 - Red Hat, https://www.redhat.com/ko/topics/cloud-native-apps/what-is-SDK</li>
<li>SDK란 무엇인가요? SDK는 어떤 역할을 하나요? - Adjust, https://www.adjust.com/ko/glossary/sdk/</li>
<li>Add apps, shortcuts &amp; widgets to your Home screens - Android Help, https://support.google.com/android/answer/9450271?hl=en</li>
<li>간단한 위젯 만들기 | Views - Android Developers, https://developer.android.com/develop/ui/views/appwidgets?hl=ko</li>
<li>How to build Modern Android App Widgets in Android 12 - YouTube, https://www.youtube.com/watch?v=15Q7xqxBGG0</li>
<li>iOS Mastery: Building Your Interactive To-Do List Widget - Medium, https://medium.com/@PavelRydvanskiy/ios-mastery-building-your-interactive-to-do-list-widget-a6e1369a3b0e</li>
<li>표준 위젯, https://support.ptc.com/help/thingworx/platform/r9.6/ko/ThingWorx/Help/Mashup_Builder/Widgets/StandardWidgets.html</li>
<li>표준 위젯 툴킷 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%EC%9C%84%EC%A0%AF_%ED%88%B4%ED%82%B7">https://ko.wikipedia.org/wiki/%ED%91%9C%EC%A4%80_%EC%9C%84%EC%A0%AF_%ED%88%B4%ED%82%B7</a></li>
<li>앱 위젯 개요 | Views - Android Developers, https://developer.android.com/develop/ui/views/appwidgets/overview?hl=ko</li>
<li>App quality - 위젯 품질 - Android Developers, https://developer.android.com/docs/quality-guidelines/widget-quality?hl=ko</li>
<li>위젯 | Apple Developer Documentation, https://developer.apple.com/kr/design/human-interface-guidelines/widgets</li>
<li>Widgets | Apple Developer Documentation, https://developer.apple.com/design/human-interface-guidelines/widgets</li>
<li>Create a simple widget | Views - Android Developers, https://developer.android.com/develop/ui/views/appwidgets</li>
<li>Create custom widget JavaScript - Oracle Help Center, https://docs.oracle.com/en/cloud/saas/cx-commerce/widge/create-custom-widget-javascript.html</li>
<li>Wix 에디터: 사이트 또는 위젯 삽입하기 | 도움말 센터, <a href="https://support.wix.com/ko/article/wix-%EC%97%90%EB%94%94%ED%84%B0-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%98%90%EB%8A%94-%EC%9C%84%EC%A0%AF-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0">https://support.wix.com/ko/article/wix-%EC%97%90%EB%94%94%ED%84%B0-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%98%90%EB%8A%94-%EC%9C%84%EC%A0%AF-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0</a></li>
<li>How to Create a Basic Widget of an Android App? - GeeksforGeeks, https://www.geeksforgeeks.org/android/how-to-create-a-basic-widget-of-an-android-app/</li>
<li>Creating a widget extension | Apple Developer Documentation, https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension</li>
<li>Exploring WidgetKit: Enhancing iOS Experience with Widgets - Velotio Technologies, https://www.velotio.com/engineering-blog/exploring-widgetkit-enhancing-ios-experience-with-widgets</li>
<li>Widget Tutorial - Homepage.dev, https://gethomepage.dev/widgets/authoring/tutorial/</li>
<li>SwiftUI views for widgets | Apple Developer Documentation, https://developer.apple.com/documentation/widgetkit/swiftui-views</li>
<li>Creating custom widgets - IBM, https://www.ibm.com/docs/pt/SS8NLW_12.0.0/com.ibm.watson.wex.ee.doc/c_onewex_appbuilder_customwidgets.html?view=kc</li>
<li>2.1: App widgets · GitBook - GitHub Pages, https://google-developer-training.github.io/android-developer-advanced-course-concepts/unit-1-expand-the-user-experience/lesson-2-app-widgets/2-1-c-app-widgets/2-1-c-app-widgets.html</li>
<li>Custom Widget Development | Staffbase Developer Portal, https://developers.staffbase.com/frameworks/customwidget-development/</li>
<li>Making a configurable widget | Apple Developer Documentation, https://developer.apple.com/documentation/widgetkit/making-a-configurable-widget</li>
<li>Build a widget host | Views - Android Developers, https://developer.android.com/develop/ui/views/appwidgets/host</li>
<li>android-widget · GitHub Topics, https://github.com/topics/android-widget?l=java&amp;o=desc&amp;s=updated</li>
<li>android-widget · GitHub Topics, https://github.com/topics/android-widget</li>
<li>android-widgets · GitHub Topics, <a href="https://github.com/topics/android-widgets?u=http://github.com/sponsors/harryjph">https://github.com/topics/android-widgets?u=http%3A%2F%2Fgithub.com%2Fsponsors%2Fharryjph</a></li>
<li>Multiple samples showing the best practices in views-widgets on Android. - GitHub, https://github.com/android/views-widgets-samples</li>
<li>Create a Widget - SwiftUI Handbook - Design+Code, https://designcode.io/swiftui-handbook-create-a-widget/</li>
<li>tigi44/WidgetKitExample: iOS WidgetKit Example (+ iOS16 WidgetKit) - GitHub, https://github.com/tigi44/WidgetKitExample</li>
<li>wojciech-kulik/WidgetKit-Demo: Sample iOS project with iOS 14 widgets - GitHub, https://github.com/wojciech-kulik/WidgetKit-Demo</li>
<li>widgetkit · GitHub Topics, https://github.com/topics/widgetkit</li>
<li>ios14-widget · GitHub Topics, https://github.com/topics/ios14-widget?o=desc&amp;s=stars</li>
<li>pawello2222/WidgetExamples: A demo project showing different types of Widgets created with SwiftUI and WidgetKit. - GitHub, https://github.com/pawello2222/WidgetExamples</li>
<li>Create your first widget | React-chatbot-kit - GitHub Pages, https://fredrikoseberg.github.io/react-chatbot-kit-docs/docs/create-a-widget/</li>
<li>웹페이지에 검색 위젯 추가 | AI Applications - Google Cloud, https://cloud.google.com/generative-ai-app-builder/docs/add-widget?hl=ko</li>
<li>makerkit/react-embeddable-widget: A Starter for building and deploying Javascript embeddable widgets using React and Tailwind CSS - GitHub, https://github.com/makerkit/react-embeddable-widget</li>
<li>IndeemaSoftware/react-component-widget: Component for resizing and repositioning charts, parsing transferred data when working with Recharts library. - GitHub, https://github.com/IndeemaSoftware/react-component-widget</li>
<li>happeo/custom-widget-templates - GitHub, https://github.com/happeo/custom-widget-templates</li>
<li>brillout/awesome-react-components: Curated List of React Components &amp; Libraries. - GitHub, https://github.com/brillout/awesome-react-components</li>
<li>jmquigley/gadgets: Reusable React UI widgets - This is my widget library. There are many like it, but this one is mine… - GitHub, https://github.com/jmquigley/gadgets</li>
<li>Create a UI widget with custom JavaScript - amp.dev, https://amp.dev/documentation/guides-and-tutorials/develop/custom-javascript-tutorial/</li>
<li>Handling UI Events | Android Developers, https://www.dre.vanderbilt.edu/~schmidt/android/android-4.0/out/target/common/docs/doc-comment-check/guide/topics/ui/ui-events.html</li>
<li>Event Handling in Android - GeeksforGeeks, https://www.geeksforgeeks.org/android/event-handling-in-android/</li>
<li>Android Event Handling - Manage the Action of Users Interaction - DataFlair, https://data-flair.training/blogs/android-event-handling/</li>
<li>Best Ways to Do Event Handling in Android - Hackajob, https://hackajob.com/talent/blog/event-handling-in-android</li>
<li>Mastering Data Binding in Android: A Complete Guide | by Manish Kumar | Medium, https://medium.com/@manishkumar_75473/mastering-data-binding-in-android-a-complete-guide-4464f8899585</li>
<li>Data Binding in Android with Example - GeeksforGeeks, https://www.geeksforgeeks.org/android/data-binding-in-android-with-example/</li>
<li>Data Binding in Android: Activities, Views, and Fragments - GeeksforGeeks, https://www.geeksforgeeks.org/android/data-binding-in-android-activities-views-and-fragments/</li>
<li>Data Binding Library | App architecture - Android Developers, https://developer.android.com/topic/libraries/data-binding</li>
<li>Layouts and binding expressions | App architecture - Android Developers, https://developer.android.com/topic/libraries/data-binding/expressions</li>
<li>Binding | Apple Developer Documentation, https://developer.apple.com/documentation/swiftui/binding</li>
<li>Explain to me like I’m 5: what is a @binding and @state : r/swift - Reddit, https://www.reddit.com/r/swift/comments/woiwpd/explain_to_me_like_im_5_what_is_a_binding_and/</li>
<li>Understanding Data Binding in SwiftUI | by Gokhan Kaya - Medium, https://medium.com/@GkhKaya00/understanding-data-binding-in-swiftui-a-comprehensive-guide-2be202e705</li>
<li>Working with @Binding in SwiftUI - LearnAppMaking - Appy Pie Vibe, https://www.appypievibe.ai/blog/working-with-binding-in-swiftui</li>
<li>Styles and themes | Views - Android Developers, https://developer.android.com/develop/ui/views/theming/themes</li>
<li>Apply built-in Android widget styles in a custom view - Stack Overflow, https://stackoverflow.com/questions/17165197/apply-built-in-android-widget-styles-in-a-custom-view</li>
<li>Enhance Widget Styling Using Custom CSS Code - Rebuy Help Center, https://help.rebuyengine.com/en/articles/8681953-enhance-widget-styling-using-custom-css-code</li>
<li>Styling widgets with custom CSS - Simplesat help center, https://help.simplesat.io/en/articles/5652151-styling-widgets-with-custom-css</li>
<li>CSS, JS and Embed - UTMB Health, The University of Texas Medical Branch, https://www.utmb.edu/web/components/css-js-and-embed</li>
<li>Add, edit, and remove widgets on iPhone - Apple Support, https://support.apple.com/guide/iphone/add-edit-and-remove-widgets-iphb8f1bf206/ios</li>
<li>How to add and edit widgets on your iPhone - Apple Support, https://support.apple.com/en-us/118610</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>