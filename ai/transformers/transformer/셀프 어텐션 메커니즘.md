---
layout: page
title: 셀프 어텐션 메커니즘에 대한 심층 고찰
permalink: /ai/transformers/transformer/셀프 어텐션 메커니즘
---


셀프 어텐션(Self-Attention) 메커니즘은 현대 인공지능, 특히 자연어 처리(NLP) 분야에서 가장 혁신적인 개념 중 하나로 자리매김했다. 이는 기존의 순차 데이터 처리 방식이 가진 근본적인 한계를 극복하고, 모델이 데이터 내의 복잡한 관계를 보다 효과적으로 학습할 수 있는 새로운 길을 열었다. 셀프 어텐션의 등장은 필연적이었으며, 그 배경을 이해하기 위해서는 순환 신경망(Recurrent Neural Network, RNN)의 시대부터 거슬러 올라가야 한다.


RNN은 순차적인 정보를 처리하기 위해 설계된 신경망 구조다.1 이전 시간 단계(time step)의 은닉 상태(hidden state)를 현재 시간 단계의 입력으로 재귀적으로 사용하는 구조를 통해, 문장에서 단어의 순서와 같은 맥락 정보를 모델링하는 데 효과적인 도구로 사용되었다.1 인간이 대화할 때 이전 단어에 대한 이해를 바탕으로 다음 단어를 이해하는 것처럼, RNN은 루프 구조를 통해 정보가 지속되도록 설계되었다.3

그러나 RNN은 구조적인 한계로 인해 시퀀스가 길어질수록 초기의 중요한 정보가 여러 시간 단계를 거치며 희석되거나 왜곡되는 **장기 의존성 문제(Long-Term Dependency Problem)**에 직면했다.2 이 문제는 주로 역전파 과정에서 기울기(gradient)가 반복적인 행렬 곱셈을 거치며 0에 가깝게 소실되거나(기울기 소실, Vanishing Gradient) 기하급수적으로 커지는(기울기 폭주, Exploding Gradient) 현상 때문에 발생한다.1 결과적으로 모델은 현재 예측에 필요한 먼 과거의 정보를 효과적으로 학습하지 못하게 된다.

이러한 문제를 완화하기 위해 1997년 Hochreiter와 Schmidhuber에 의해 **Long Short-Term Memory (LSTM)**가 제안되었다.1 LSTM은 RNN의 단순한 은닉 상태 대신, 정보의 흐름을 정교하게 제어하는 내부 메커니즘을 도입했다. 핵심은 **셀 상태(cell state)**라는 별도의 정보 흐름 경로로, 마치 컨베이어 벨트처럼 중요한 정보를 거의 변형 없이 장기간 전달할 수 있다.3 이 셀 상태는 세 개의 **게이트(gate)**에 의해 제어된다. **망각 게이트(forget gate)**는 과거 정보 중 어떤 것을 버릴지, **입력 게이트(input gate)**는 새로운 정보 중 어떤 것을 셀 상태에 저장할지, 그리고 **출력 게이트(output gate)**는 셀 상태의 어떤 정보를 현재의 은닉 상태로 내보낼지를 결정한다.2 이 게이트 구조 덕분에 LSTM은 RNN보다 장기 의존성을 훨씬 효과적으로 포착할 수 있었고, 기계 번역, 음성 인식 등 여러 분야에서 큰 성공을 거두었다.2


LSTM은 장기 의존성 문제를 상당 부분 해결했지만, 특히 인코더-디코더(Encoder-Decoder) 구조에서 또 다른 본질적인 한계에 부딪혔다. 이 구조에서 인코더는 입력 시퀀스 전체의 정보를 고정된 크기의 단일 벡터, 즉 **문맥 벡터(context vector)**로 압축해야만 했다.6 디코더는 오직 이 문맥 벡터에만 의존하여 출력 시퀀스를 생성해야 했다. 입력 시퀀스가 길어질수록, 모든 정보를 하나의 벡터에 압축하는 과정에서 필연적으로 정보 손실이 발생하는 **정보 병목(information bottleneck)** 현상이 발생했다.7

이 문제를 해결하기 위해 2014년 Bahdanau 등이 제안한 **어텐션 메커니즘(Attention Mechanism)**은 획기적인 돌파구를 마련했다.9 어텐션의 핵심 아이디어는 디코더가 매 시간 단계마다 고정된 문맥 벡터 하나에만 의존하는 대신, 인코더의 **모든 시간 단계의 은닉 상태**를 직접 참조할 수 있도록 하는 것이다.9 디코더는 현재 생성하려는 출력과 가장 관련이 높은 입력 부분에 더 많은 "주의(attention)"를 기울여, 동적으로 계산된 가중합(weighted sum) 형태의 문맥 벡터를 매번 새로 생성한다.8 이 방식은 정보 병목 현상을 효과적으로 해소하고, 특히 긴 문장의 번역 품질을 크게 향상시켰다.

초기 어텐션 메커니즘은 RNN 구조 위에서 동작했지만, 그 근본 철학은 순차 처리의 제약을 넘어설 수 있는 가능성을 내포하고 있었다. 즉, "입력 시퀀스의 모든 부분에 직접 접근할 수 있다"는 아이디어는 순환 구조 자체를 제거할 수 있다는 혁신적인 발상으로 이어졌다. 이는 순차 데이터를 처리하는 패러다임을 근본적으로 바꾸는 계기가 되었다. RNN과 LSTM이 정보를 시간 순서에 따라 '기억'하고 순차적으로 전달하는 방식이었다면, 어텐션은 시퀀스를 시간의 흐름이 아닌, 요소들 간의 '관계망(relational network)'으로 재정의했다. 특정 요소를 이해하기 위해 다른 모든 요소와의 관계를 직접 계산하고, 그 중요도에 따라 정보를 동적으로 조합하는 것이다. 이러한 관점의 전환은 순차 처리의 제약을 벗어나 대규모 병렬 처리가 가능한 트랜스포머(Transformer) 아키텍처를 탄생시키는 철학적 기반이 되었으며, 그 중심에는 셀프 어텐션이 있었다.


셀프 어텐션은 시퀀스 내의 각 요소가 다른 모든 요소와의 관계를 직접적으로 계산하여 문맥적 표현을 생성하는 메커니즘이다. 이 과정은 정보 검색 시스템의 원리를 차용하여 쿼리(Query), 키(Key), 밸류(Value)라는 세 가지 핵심 요소로 구성된다. 이들의 상호작용을 통해 계산되는 스케일드 닷-프로덕트 어텐션과 이를 확장한 멀티-헤드 어텐션은 트랜스포머 아키텍처의 근간을 이룬다.


셀프 어텐션의 작동 방식을 직관적으로 이해하기 위해 정보 검색 시스템에 비유할 수 있다.12 시퀀스 내의 한 단어가 문맥 속에서 자신의 의미를 명확히 하기 위해, 다른 모든 단어에게 "나는 이런 정보가 필요하다"는 질의를 던지는 과정으로 볼 수 있다.6

- **쿼리 (Query, Q):** 현재 처리 중인 단어가 다른 단어들로부터 어떤 정보를 얻고 싶은지를 나타내는 벡터다. 즉, "내가 찾고 있는 정보"에 해당한다.12
- **키 (Key, K):** 시퀀스 내의 각 단어가 자신을 식별하기 위해 제시하는 일종의 "레이블" 또는 "색인"과 같은 벡터다. 쿼리와의 유사도를 계산하는 데 사용되며, "내가 가진 정보는 이런 종류다"라고 알려주는 역할을 한다.12
- **밸류 (Value, V):** 각 단어가 실제로 담고 있는 의미론적 정보 벡터다. 쿼리와 키의 유사도(어텐션 가중치)에 따라 가중합되어 최종 문맥 벡터를 형성하는 데 기여한다. 즉, "실제로 전달될 정보"다.12

이 개념은 **유튜브 검색**에 비유하면 더욱 명확해진다. 사용자가 검색창에 입력하는 검색어는 `쿼리`에 해당한다. 유튜브의 각 영상 제목은 `키` 역할을 하며, 실제 영상 데이터는 `밸류`에 해당한다. 유튜브 시스템은 사용자의 `쿼리`를 모든 영상의 `키`(제목)와 비교하여 유사도가 높은 순서대로 관련 영상(`밸류`)을 추천한다.12

셀프 어텐션에서는 입력 단어 임베딩 행렬 $X$에 각각 다른 학습 가능한 가중치 행렬 $W^Q, W^K, W^V$를 곱하여 쿼리, 키, 밸류 행렬을 생성한다.6
$$
Q = XW^Q, \quad K = XW^K, \quad V = XW^V
$$
즉, $Q$, $K$, $V$는 모두 동일한 입력 시퀀스에서 파생되지만, 서로 다른 선형 변환을 통해 각각 질의, 식별, 정보 전달이라는 다른 역할을 수행하게 된다.


"Attention Is All You Need" 논문에서 제안된 스케일드 닷-프로덕트 어텐션은 셀프 어텐션의 핵심 연산이다.12 그 공식은 다음과 같다.16
$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$
이 연산은 네 단계로 나누어 분석할 수 있다.

1. **유사도 계산 ($QK^T$):** 쿼리 행렬 $Q$와 키 행렬의 전치 $K^T$를 행렬 곱한다. 이 결과로 나오는 어텐션 스코어 행렬의 각 원소 $(i, j)$는 $i$번째 쿼리 벡터와 $j$번째 키 벡터의 내적(dot product) 값이다. 이 값은 두 단어 간의 의미적, 문맥적 유사도를 나타낸다.16
2. **스케일링 ($/\sqrt{d_k}$):** 계산된 유사도 행렬의 모든 원소를 키 벡터의 차원 $d_k$의 제곱근으로 나눈다. 키 벡터의 차원 $d_k$가 커질수록 내적 값의 분산도 커지는 경향이 있다. 이 값이 너무 커지면 소프트맥스 함수를 통과할 때 기울기가 0에 가까워져 학습이 불안정해지는 **기울기 소실 문제**가 발생할 수 있다. 스케일링은 내적 값의 분산을 1로 유지시켜 소프트맥스 함수의 입력을 안정화하고, 결과적으로 모델 학습을 원활하게 만드는 매우 중요한 역할을 한다.12
3. **가중치 정규화 (softmax):** 스케일링된 유사도 행렬에 소프트맥스 함수를 행(row) 단위로 적용한다. 이를 통해 각 행의 합이 1이 되는 확률 분포, 즉 **어텐션 가중치(attention weights)**를 얻는다. $i$번째 행의 $j$번째 가중치는 $i$번째 단어가 자신의 문맥적 표현을 계산할 때 $j$번째 단어의 정보에 얼마나 "집중"해야 하는지를 나타낸다.16
4. **문맥 벡터 생성 ($...V$):** 마지막으로, 계산된 어텐션 가중치 행렬을 밸류 행렬 $V$와 곱한다. 이는 각 밸류 벡터에 해당 어텐션 가중치를 곱하여 가중합을 구하는 것과 같다. 이 과정을 통해 각 단어는 시퀀스 내 모든 단어의 정보가 자신과의 관련도에 따라 가중합된 새로운 문맥적 표현(contextual representation) 벡터를 얻게 된다.16


단일 어텐션 메커니즘만으로는 문장 내에 존재하는 다양한 종류의 관계(예: 구문적 관계, 의미적 관계, 장거리 참조 관계 등)를 동시에 포착하기 어렵다. 멀티-헤드 어텐션은 어텐션 연산을 여러 개의 "헤드(head)"로 나누어 병렬적으로 수행함으로써 이 문제를 해결한다.14 이는 모델이 입력 정보의 서로 다른 측면을 동시에 학습할 수 있게 한다.

멀티-헤드 어텐션의 핵심 아이디어는 $d_{\text{model}}$ 차원의 $Q$, $K$, $V$ 벡터를 한 번에 사용하는 대신, 이를 $h$개의 더 작은 차원($d_k = d_v = d_{\text{model}} / h$)을 가진 $Q$, $K$, $V$로 각각 선형 투영(linear projection)한 뒤, 이들을 병렬적으로 스케일드 닷-프로덕트 어텐션에 입력하는 것이다.13

수학적 정의는 다음과 같다.
$$
\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h)W^O
$$

$$
\text{where head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)
$$

계산 과정은 다음과 같다.

1. **선형 투영:** 입력 $Q, K, V$는 각각 $h$개의 서로 다른 학습 가능한 가중치 행렬($W_i^Q, W_i^K, W_i^V$)에 의해 서로 다른 표현 부분 공간(representation subspace)으로 투영된다.13
2. **병렬 어텐션 계산:** $h$개의 헤드는 각각 독립적으로 스케일드 닷-프로덕트 어텐션을 계산한다. 이를 통해 각 헤드는 입력 시퀀스의 서로 다른 측면(예: 어떤 헤드는 동사와 목적어의 관계, 다른 헤드는 인접 단어의 관계)에 집중하여 학습할 수 있다.23
3. **결합(Concatenation):** $h$개의 헤드에서 나온 출력 벡터들을 모두 하나의 긴 벡터로 연결(concatenate)한다.13
4. **최종 선형 변환:** 연결된 벡터에 또 다른 가중치 행렬 $W^O$를 곱하여 최종 출력 벡터를 생성한다. 이 과정은 여러 헤드에서 병렬적으로 추출된 다양한 정보를 통합하고 융합하는 역할을 한다.14

멀티-헤드 어텐션은 단순히 계산을 병렬화하는 기술을 넘어, 모델 내부에 일종의 **앙상블(ensemble) 학습** 메커니즘을 구현한 것으로 해석될 수 있다. 각 헤드는 독립적인 파라미터를 통해 서로 다른 종류의 언어적, 구조적 패턴을 포착하는 '전문가'로 성장한다. 예를 들어, BERT에 대한 분석 연구에 따르면 특정 헤드는 동사와 그 목적어의 관계를, 다른 헤드는 인접한 토큰의 관계를, 또 다른 헤드는 문장 구분 기호에 집중하는 등 전문화된 역할을 수행하는 것으로 나타났다.25 마지막 선형 변환 단계는 이 다양한 전문가들의 '의견'을 종합하여 단일 어텐션으로는 얻기 힘든 풍부하고 강건한 표현을 만들어내는 과정이다. 이는 단일 관점에 매몰될 수 있는 위험을 줄이고 모델의 표현력을 기하급수적으로 향상시키는 핵심적인 장치다.


셀프 어텐션은 트랜스포머 모델의 인코더와 디코더에서 각기 다른 목적과 형태로 활용된다. 순서 정보가 부재한 셀프 어텐션의 한계를 극복하기 위한 위치 인코딩부터 시작하여, 인코더의 양방향 문맥 이해, 디코더의 인과적 생성, 그리고 둘을 잇는 정보의 교량 역할까지, 어텐션은 트랜스포머의 각 구성 요소에서 핵심적인 역할을 수행한다.


셀프 어텐션은 시퀀스 내 모든 토큰 쌍의 관계를 직접 계산하는 방식으로, 토큰의 순서 정보를 내재적으로 처리하지 못한다. 즉, "고양이가 개를 쫓는다"와 "개가 고양이를 쫓는다"라는 두 문장의 단어 집합이 동일하기 때문에, 셀프 어텐션은 이 둘을 구분하지 못하는 **순열 불변성(permutation invariance)**을 가진다.26

이러한 근본적인 문제를 해결하기 위해, 트랜스포머는 각 토큰의 절대적 또는 상대적 위치 정보를 담은 **위치 인코딩(Positional Encoding)** 벡터를 입력 임베딩에 더해준다.28 이를 통해 모델은 단어의 의미뿐만 아니라 문장 내 위치 정보까지 함께 고려할 수 있게 된다.

"Attention Is All You Need" 논문에서는 주기 함수인 사인(sine)과 코사인(cosine) 함수를 사용하여 고정된 위치 인코딩을 구현했다.26
$$
PE_{(pos, 2i)} = \sin(pos / 10000^{2i/d_{\text{model}}})
$$

$$
PE_{(pos, 2i+1)} = \cos(pos / 10000^{2i/d_{\text{model}}})
$$

여기서 $pos$는 시퀀스 내 토큰의 위치, $i$는 임베딩 벡터 내의 차원 인덱스, $d_{\text{model}}$은 임베딩 차원을 의미한다. 이 방식은 몇 가지 중요한 장점을 가진다. 첫째, 각 위치에 대해 고유한 인코딩을 생성한다. 둘째, 주기 함수를 사용하기 때문에 모델이 훈련 중에 보지 못했던 더 긴 시퀀스에 대해서도 위치 정보를 일반화하여 추론할 수 있다. 셋째, 특정 위치 $pos+k$의 위치 인코딩은 $pos$의 위치 인코딩의 선형 변환으로 표현될 수 있어, 모델이 상대적 위치 정보를 쉽게 학습할 수 있게 한다.27


트랜스포머의 인코더는 입력 시퀀스의 깊은 문맥적 표현을 생성하는 역할을 한다. 인코더의 셀프 어텐션은 입력 시퀀스 내의 모든 토큰이 다른 모든 토큰을 아무런 제한 없이 참조할 수 있도록 설계되었다. 이는 완전한 **양방향(bidirectional)** 문맥 정보를 포착하게 한다.7

예를 들어, "I arrived at the bank after crossing the river."라는 문장에서 'bank'의 의미를 파악하기 위해, 인코더의 셀프 어텐션은 문장 전체('arrived', 'river' 등)를 동시에 고려한다. 이를 통해 'bank'가 금융 기관인 '은행'이 아니라 지형적 의미의 '강둑'이라는 것을 높은 확률로 추론할 수 있다. RNN이 순차적으로 정보를 처리하며 과거 정보가 희석될 수 있는 반면, 인코더의 셀프 어텐션은 모든 단어 간의 직접적인 연결을 통해 이러한 문맥적 모호성을 효과적으로 해결한다. 인코더는 이러한 셀프 어텐션 레이어와 위치별 피드포워드 신경망(Position-wise Feed-Forward Network) 레이어를 하나의 블록으로 구성하며, 이를 여러 층(원 논문에서는 N=6)으로 쌓아 점진적으로 더 깊고 추상적인 문맥 표현을 학습한다.31


디코더는 주로 기계 번역이나 텍스트 생성과 같이 순차적으로 결과를 만들어내는 **자기회귀적(autoregressive)** 작업을 수행한다.33 즉, 시간 단계 $t$의 단어를 예측할 때, $t$ 시점 이후의 미래 정보(정답)를 참조해서는 안 된다. 이러한 **인과 관계(causality)**를 보장하기 위해 디코더의 셀프 어텐션에는 특별한 장치가 적용되는데, 이것이 바로 **마스킹(masking)**이다.

마스크드 셀프 어텐션에서는 어텐션 스코어 행렬($QK^T$)을 계산한 후, 소프트맥스 함수를 적용하기 전에 현재 위치보다 미래에 있는 위치들의 스코어 값을 음의 무한대($-\infty$)에 가까운 매우 작은 값으로 설정한다.7 소프트맥스 함수를 통과하면 이 값들은 0이 되므로, 미래 토큰에 대한 어텐션 가중치가 효과적으로 0이 된다. 결과적으로, 디코더의 각 위치는 오직 자신과 그 이전 위치의 정보에만 의존하여 다음 토큰을 예측하게 된다.30 이 메커니즘은 모델이 훈련 중에 정답을 "엿보는" 것을 방지하고, 추론 시에도 일관된 순차적 생성을 가능하게 하는 핵심적인 역할을 한다.


디코더 블록에는 마스크드 셀프 어텐션 외에 두 번째 어텐션 레이어가 존재하는데, 이것이 바로 **인코더-디코더 어텐션(Encoder-Decoder Attention)**이다.7 이 어텐션 레이어는 인코더와 디코더를 연결하는 정보의 다리 역할을 한다.

이 어텐션 메커니즘의 독특한 점은 쿼리, 키, 밸류의 출처가 다르다는 것이다. **쿼리($Q$)는 디코더의 이전 레이어 출력**에서 가져오고, **키($K$)와 밸류($V$)는 인코더의 최종 출력**에서 가져온다.37 이를 통해 디코더는 출력 시퀀스의 각 토큰을 생성할 때마다, 입력 시퀀스 전체에서 현재 생성할 토큰과 가장 관련이 깊은 부분이 어디인지를 파악하고 해당 정보를 집중적으로 활용할 수 있다. 예를 들어, 영어 문장을 한국어로 번역할 때, 특정 한국어 단어를 생성하기 위해 영어 문장의 어떤 단어에 집중해야 할지를 결정하는 과정이 바로 이 어텐션을 통해 이루어진다.10 이 메커니즘은 인코더가 압축한 소스 언어의 풍부한 문맥 정보와 디코더가 생성 중인 타겟 언어의 정보 사이의 **정렬(alignment)**을 학습하는 핵심적인 장치다.30

결국, BERT(인코더-온리), GPT(디코더-온리), 그리고 T5와 같은 원조 트랜스포머(인코더-디코더) 모델 아키텍처의 근본적인 차이는 셀프 어텐션 메커니즘 자체의 변형이 아니라, 이 세 가지 기본 어텐션 모듈(양방향 셀프 어텐션, 마스크드 셀프 어텐션, 인코더-디코더 어텐션)을 어떻게 선택하고 조합하여 특정 과업에 맞는 정보 흐름 파이프라인을 설계했는가에 있다. 인코더의 양방향 어텐션은 '이해'에, 디코더의 마스크드 어텐션은 '생성'에, 그리고 인코더-디코더 어텐션은 한 정보 공간에서 다른 정보 공간으로의 '변환'에 최적화된 구조다. 현대의 다양한 트랜스포머 변종 모델들은 이 기본 모듈들의 조합을 통해 특정 목적을 달성하는 결과물로 볼 수 있다.


셀프 어텐션은 순차 데이터 처리의 패러다임을 바꾸었지만, 그 본질적인 특성으로 인해 명확한 장점과 함께 극복해야 할 과제를 동시에 안고 있다. 병렬 처리를 통한 계산 효율성, 장거리 의존성 포착 능력과 같은 혁신적인 장점은 모델의 규모와 성능을 비약적으로 발전시켰지만, 시퀀스 길이에 따른 이차적 복잡도라는 치명적인 단점은 모델의 적용 범위를 제한하는 주요 요인이 되었다.


셀프 어텐션이 기존의 순차 모델(RNN, LSTM)에 비해 갖는 주요 장점은 다음과 같다.

- **병렬화(Parallelization):** RNN이 이전 시간 단계의 계산이 끝나야 다음 단계 계산을 시작할 수 있는 순차적 구조인 반면, 셀프 어텐션은 시퀀스 내 모든 토큰에 대한 계산을 한 번의 행렬 연산으로 동시에 처리할 수 있다. 이는 GPU와 같은 병렬 컴퓨팅 하드웨어의 이점을 최대한 활용하여, 이전 모델들과 비교할 수 없을 정도로 학습 시간을 획기적으로 단축시킨다.7
- **장거리 의존성 포착(Long-Range Dependencies):** 셀프 어텐션에서는 시퀀스 내 어떤 두 토큰 사이의 정보 전달 경로 길이가 1로 고정된다. 즉, 문장의 시작과 끝에 있는 단어 간의 관계도 직접적으로 모델링할 수 있다. 이는 RNN이 여러 시간 단계를 거치며 정보가 희석되거나 소실되는 문제를 근본적으로 해결한다. 이 덕분에 모델은 복잡한 문법 구조나 장거리 의미적 관계를 훨씬 효과적으로 학습할 수 있다.7
- **해석 가능성(Interpretability):** 어텐션 가중치를 시각화함으로써 모델이 특정 단어의 표현을 계산할 때 문장의 어떤 다른 부분에 집중했는지 직관적으로 파악할 수 있다. 이는 모델의 의사결정 과정을 분석하고 디버깅하는 데 유용한 단서를 제공한다.7 예를 들어, BERT의 어텐션 헤드를 분석한 연구에서는 특정 헤드가 동사의 목적어, 명사의 한정사, 대명사의 선행사 등 특정 통사적 관계를 뚜렷하게 학습하는 경향이 있음을 발견했다.25


셀프 어텐션의 가장 큰, 그리고 가장 근본적인 단점은 시퀀스 길이 $n$에 대해 시간 및 메모리 복잡도가 제곱에 비례하여 증가한다는 점이다.7

이 복잡도는 $n \times n$ 크기의 어텐션 스코어 행렬($QK^T$)을 계산하고 저장하는 과정에서 발생한다. 구체적으로, $(n, d_k)$ 크기의 쿼리 행렬 $Q$와 $(d_k, n)$ 크기의 전치된 키 행렬 $K^T$를 곱하는 데 $O(n^2 \cdot d_k)$의 연산이 필요하다.19 시퀀스 길이가 두 배로 늘어나면, 필요한 계산량과 메모리는 네 배로 증가한다.

이러한 이차적 복잡도는 셀프 어텐션의 적용 범위를 심각하게 제한한다. BERT나 GPT-2와 같은 초기 모델들은 이 문제로 인해 최대 시퀀스 길이가 512 또는 1024로 제한되었다.19 문서 요약, 고해상도 이미지 처리(ViT), 유전체 서열 분석, 장편 소설 분석 등 긴 시퀀스를 다루어야 하는 작업에서 이는 심각한 병목 현상을 유발하며, 모델의 확장을 가로막는 주요 장애물이 되었다.40

이러한 장단점을 다른 어텐션 기법들과 비교하면 셀프 어텐션의 특성을 더욱 명확히 이해할 수 있다.

**표 1: 주요 어텐션 메커니즘 비교** 43

| 메커니즘          | 설명                                                        | 장점                                           | 단점                                                |
| ----------------- | ----------------------------------------------------------- | ---------------------------------------------- | --------------------------------------------------- |
| **셀프 어텐션**   | 입력 시퀀스 내의 모든 위치가 다른 모든 위치를 참조함        | 병렬화 가능, 유연성, 우수한 장거리 의존성 포착 | 시퀀스 길이에 대한 $O(n^2)$의 계산 및 메모리 복잡도 |
| **계층적 어텐션** | 단어 수준과 문장 수준 등 계층적 구조에 따라 어텐션을 적용함 | 문서의 계층적 구조 포착에 용이                 | 모델 구조가 복잡해짐                                |
| **지역 어텐션**   | 입력 시퀀스의 일부 로컬 윈도우 내에서만 어텐션을 계산함     | 계산 비용 감소                                 | 문맥 범위가 제한됨                                  |

셀프 어텐션의 장점과 단점은 사실상 동전의 양면과 같다. 모든 토큰 쌍 간의 직접적인 상호작용을 허용하는 **완전한 연결성(full connectivity)**은 장거리 의존성을 포착하는 강력한 능력을 부여하지만, 동시에 $O(n^2)$라는 엄청난 계산 비용을 초래한다. 즉, 모델의 '능력'과 '비용'이 동일한 설계 원칙에서 비롯되는 근본적인 딜레마에 빠져 있는 것이다. 이 딜레마는 이후 어텐션 연구의 핵심 주제가 되었다. 연구자들은 "완전한 연결성을 유지하면서 비용을 줄일 수 있는가?" 또는 "성능 저하를 최소화하면서 연결성을 얼마나 희생할 수 있는가?"라는 질문에 답하기 위해, 전체 어텐션을 효과적으로 근사(approximation)하는 다양한 기법을 탐구하게 된다.


셀프 어텐션의 $O(n^2)$ 계산 복잡도 문제는 긴 시퀀스를 처리하는 데 있어 가장 큰 걸림돌이다. 이 문제를 해결하기 위해, 전체(dense) 어텐션 행렬을 계산하지 않고도 그 효과를 근사하려는 다양한 효율적 어텐션(Efficient Attention) 기법들이 제안되었다. 이러한 기법들은 "과연 모든 토큰 쌍의 상호작용이 동등하게 중요한가?"라는 근본적인 질문에서 출발하며, 복잡도를 $O(n \log n)$ 또는 $O(n)$ 수준으로 낮추는 것을 목표로 한다.


실제 자연어 문장에서 대부분의 단어는 소수의 다른 단어들과 강한 구문적 또는 의미적 연관성을 가지며, 나머지 대다수 단어와는 약한 관계를 맺는다. 또한, 어텐션 가중치를 계산하는 소프트맥스 함수는 입력값 중 가장 큰 값들에 의해 결과가 지배되는 특성이 있다.44 이는 어텐션 스코어 행렬의 대부분의 값이 0에 가까우며, 소수의 높은 값들만이 최종 문맥 벡터에 실질적인 영향을 미친다는 것을 시사한다.

이러한 관찰에 기반하여, 전체 $n \times n$ 어텐션 행렬을 명시적으로 계산하는 대신, 중요할 것으로 예상되는 일부 상호작용만을 선택적으로 계산하여 전체 어텐션을 근사하려는 시도들이 등장했다. 대표적인 기법으로는 희소 어텐션, 린포머, 리포머 등이 있다.


희소 어텐션은 전체(dense) 어텐션 대신, 미리 정의된 희소한(sparse) 패턴에 따라 일부 토큰 쌍에 대해서만 어텐션을 계산하는 방식이다.45 이는 모든 토큰이 모든 다른 토큰을 참조할 필요는 없다는 가정에 기반한다. 주요 희소화 패턴은 다음과 같다.

- **슬라이딩 윈도우 어텐션(Sliding Window Attention):** 각 토큰이 자신의 주변에 있는 고정된 크기($w$)의 윈도우 내 토큰들만 참조하도록 제한한다. 이는 지역적 문맥을 포착하는 데 효과적이다.
- **전역 어텐션(Global Attention):** 일부 특별한 토큰(예: BERT의 `` 토큰)은 시퀀스 내 모든 토큰을 참조할 수 있도록 허용한다. 이를 통해 모델 전체에 중요한 전역적 정보를 취합하고 전파할 수 있다.
- **랜덤 어텐션(Random Attention):** 각 토큰이 무작위로 선택된 일부 토큰들을 참조하도록 한다. 이는 윈도우 패턴이 놓칠 수 있는 장거리 의존성을 포착하는 데 도움을 줄 수 있다.

Google에서 제안한 **BigBird** 모델은 이 세 가지 패턴(슬라이딩 윈도우, 전역, 랜덤)을 결합하여 지역적 정보와 전역적 정보를 모두 효율적으로 포착하는 방식을 제안했다.42 이와 같은 희소 어텐션 기법들은 어텐션 계산량을 $O(n \cdot w)$ 또는 $O(n)$ 수준으로 낮출 수 있다.


린포머는 $n \times n$ 크기의 셀프 어텐션 행렬이 실제로는 정보적으로 중복성이 높아 **저차원(low-rank)** 특성을 가진다는 경험적 관찰에 기반한다.47 즉, 행렬의 정보 대부분이 소수의 주요 특이값(singular value)에 집중되어 있어, 더 작은 행렬로 근사할 수 있다는 것이다.

린포머의 핵심 아이디어는 키($K$)와 밸류($V$) 행렬을 저차원으로 투영(projection)하는 것이다. 기존의 $(n, d)$ 크기의 $K$와 $V$ 행렬에 학습 가능한 $(k, n)$ 크기의 선형 투영 행렬 $E_i, F_i$를 곱하여, $(k, d)$ 크기의 더 작은 행렬 $K', V'$를 만든다 (여기서 $k \ll n$). 그 후, 쿼리 $Q$와 이 저차원 키 $K'$ 사이의 어텐션을 계산한다.
$$
\text{Attention}(Q, K, V) \approx \text{softmax}\left(\frac{Q(E_i K)^T}{\sqrt{d_k}}\right)(F_i V)
$$
이 방식은 $n \times n$ 크기의 어텐션 행렬을 명시적으로 만들지 않고, $n \times k$ 크기의 행렬을 통해 계산을 수행하므로 시간 및 공간 복잡도가 $O(nk)$, 즉 $k$를 상수로 간주하면 $O(n)$으로 감소한다.49


리포머는 유사한 벡터들이 높은 확률로 동일한 해시 값(버킷)에 할당되는 **지역 민감 해싱(Locality-Sensitive Hashing, LSH)** 기법을 어텐션에 적용한다.44 이는 유사도가 높은 토큰들끼리만 어텐션을 계산하도록 유도하는 방식이다.

리포머의 핵심 아이디어는 다음과 같다.

1. 모든 쿼리 벡터들을 LSH를 사용해 여러 버킷으로 그룹화한다. (리포머에서는 계산 효율성을 위해 $Q=K$를 가정한다).44
2. 어텐션 계산을 전체 시퀀스에 대해 수행하는 대신, **동일한 버킷 내에 속한 토큰들 사이에서만** 수행한다.51

LSH는 근사적으로 최근접 이웃을 찾는 알고리즘으로, 모든 쌍을 비교하지 않고도 유사한 벡터들을 효율적으로 찾을 수 있게 해준다. 이를 통해 리포머는 어텐션의 계산 복잡도를 평균적으로 $O(n \log n)$으로 낮춘다.51 또한, 리포머는 가역 잔차 신경망(Reversible Residual Networks)과 같은 기술을 함께 사용하여 메모리 사용량을 획기적으로 줄였다.

이러한 효율적 어텐션 기법들은 각각 다른 철학을 바탕으로 $O(n^2)$ 문제를 해결하며, 그 특성은 다음 표와 같이 요약할 수 있다.

**표 2: 효율적 어텐션 기법 비교**

| 기법            | 핵심 아이디어                                                | 시간 복잡도   | 공간 복잡도   | 주요 특징                                                    |
| --------------- | ------------------------------------------------------------ | ------------- | ------------- | ------------------------------------------------------------ |
| **희소 어텐션** | 미리 정의된 희소 패턴(윈도우, 전역 등)에 따라 어텐션 계산    | $O(n)$        | $O(n)$        | 지역적/전역적 의존성을 명시적으로 모델링. BigBird가 대표적. 42 |
| **린포머**      | 어텐션 행렬의 저차원(Low-Rank) 특성을 활용하여 K, V를 저차원으로 투영 | $O(n)$        | $O(n)$        | 이론적으로 증명된 근사 성능. $k \ll n$일 때 효과적. 49       |
| **리포머**      | LSH를 사용해 유사한 Q, K를 같은 버킷으로 그룹화하고 버킷 내에서만 어텐션 계산 | $O(n \log n)$ | $O(n \log n)$ | 근사적 최근접 이웃 탐색 기반. 가역 신경망과 결합하여 메모리 효율 극대화. 51 |

이러한 효율적 어텐션 기법들은 단순히 계산량을 줄이는 공학적 트릭을 넘어, 각각 고유한 **귀납적 편향(inductive bias)**을 모델에 주입한다. 희소 어텐션은 '정보는 주로 지역적이거나 특정 허브를 통해 전파될 것'이라는 편향을, 린포머는 '문맥 정보는 저차원 부분 공간으로 압축될 수 있다'는 편향을, 리포머는 '유사한 것들끼리만 상호작용하는 것이 중요하다'는 편향을 도입한다. 표준 셀프 어텐션이 아무런 편향 없이 모든 가능성을 열어두는 대신 $O(n^2)$의 비용을 치렀다면, 효율적 어텐션들은 특정 편향을 가정함으로써 $O(n)$ 또는 $O(n \log n)$의 효율성을 얻는다. 따라서, 특정 과업에 가장 적합한 효율적 어텐션을 선택하는 것은 그 과업의 데이터가 어떤 종류의 관계 패턴을 따를 것인지에 대한 이해와 직결된다.


셀프 어텐션은 트랜스포머라는 강력한 아키텍처의 핵심 부품으로서, 이를 기반으로 NLP 및 컴퓨터 비전 분야에서 혁신을 이룬 수많은 모델이 탄생했다. 그중에서도 BERT, GPT, 그리고 Vision Transformer(ViT)는 각기 다른 방식으로 트랜스포머의 구성 요소를 채택하고 변형하여 특정 목적을 달성한 대표적인 사례다. 이 모델들은 셀프 어텐션이 어떻게 다양한 과업에 맞춰 변주될 수 있는지를 명확히 보여준다.


BERT는 **트랜스포머의 인코더 부분만을 사용**하여 언어의 깊은 양방향 문맥을 이해하는 데 초점을 맞춘 모델이다.53

- **핵심 특징:** BERT의 가장 큰 특징은 인코더의 양방향 셀프 어텐션을 통해 문장 내 모든 단어의 왼쪽과 오른쪽 문맥을 **동시에** 고려하여 문맥적 표현을 학습한다는 점이다.15 이는 이전의 언어 모델들이 주로 단방향(왼쪽에서 오른쪽)으로 문맥을 학습했던 것과 근본적인 차이를 만든다.
- **사전 학습(Pre-training) 방식:**
  - **마스크드 언어 모델(Masked Language Model, MLM):** 입력 문장의 일부 토큰을 무작위로 `토큰으로 가리고, 주변의 양방향 문맥을 이용하여 원래 토큰을 예측하도록 학습한다. 예를 들어, "고양이가 위에 앉았다"에서`가 "매트"임을 예측하는 과업이다. 이 과정은 모델이 단어의 피상적인 패턴이 아닌, 문맥 속에서의 깊은 의미를 학습하도록 강제한다.53
  - **다음 문장 예측(Next Sentence Prediction, NSP):** 두 문장을 입력으로 받아 두 번째 문장이 첫 번째 문장 바로 다음에 오는 문장인지 여부를 예측하도록 학습한다. 이를 통해 문장 간의 관계를 이해하는 능력을 기른다.53
- **셀프 어텐션의 역할:** BERT의 강력한 언어 이해 능력은 전적으로 여러 층으로 쌓인 인코더의 셀프 어텐션에 기반한다. 각 단어의 표현은 여러 층의 인코더를 통과하면서 문장 전체의 다른 모든 단어들과의 관계 속에서 점진적으로 정교화된다. 연구에 따르면, BERT의 각 멀티-헤드 어텐션 헤드는 특정 통사론적 또는 의미론적 관계(예: 동사-목적어, 명사-수식어, 대명사-선행사)를 포착하는 방향으로 전문화되는 경향을 보인다.25


GPT 계열 모델은 BERT와 반대로 **트랜스포머의 디코더 부분만을 사용**하여, 창의적이고 일관성 있는 텍스트 생성에 특화된 모델이다.30

- **핵심 특징:** GPT의 핵심은 **마스크드 셀프 어텐션**을 사용하여 이전 토큰들만을 바탕으로 다음 토큰을 예측하는 **자기회귀적(autoregressive)** 언어 모델이라는 점이다.33
- **작동 방식:** 주어진 프롬프트(문맥)에 이어질 다음 단어의 확률 분포를 예측한다. 예측된 단어는 다시 입력 시퀀스에 추가되어 그 다음 단어를 예측하는 데 사용된다. 이 과정을 반복함으로써 소설, 기사, 코드 등 긴 텍스트를 생성할 수 있다.34
- **마스크드 셀프 어텐션의 역할:** 생성 과정에서 모델이 아직 생성되지 않은 미래의 정보를 "엿보는" 것을 방지하는 것이 GPT의 핵심이다. 각 위치의 토큰은 오직 자신과 자신보다 앞에 있는 토큰들에만 어텐션을 적용할 수 있다. 이러한 엄격한 **단방향(unidirectional) 정보 흐름**은 모델이 인과 관계를 학습하고, 문법적으로나 의미적으로 일관성 있는 문장을 순차적으로 생성할 수 있는 근간이 된다.35


ViT는 트랜스포머 아키텍처를 컴퓨터 비전 분야, 특히 이미지 분류에 성공적으로 적용하여 NLP를 넘어선 범용성을 입증한 모델이다.58

- **핵심 아이디어:** ViT의 혁신은 이미지를 텍스트 문장처럼 취급하는 발상의 전환에 있다.

  1. **이미지 패치화:** 이미지를 고정된 크기(예: 16x16 픽셀)의 여러 **패치(patch)**로 분할한다. 각 패치는 문장에서의 단어(token)와 같은 역할을 한다.60
  2. **선형 임베딩:** 각 패치를 평탄화(flatten)하고 선형 투영(linear projection)하여 NLP의 단어 임베딩과 유사한 **패치 임베딩** 벡터 시퀀스를 생성한다.60
  3. **트랜스포머 인코더 입력:** 이 벡터 시퀀스에 위치 인코딩을 더한 후, 표준 **트랜스포머 인코더**에 입력한다.60

- **셀프 어텐션의 역할:** ViT의 셀프 어텐션은 이미지 내 모든 패치들 간의 관계를 학습한다. 이를 통해 모델은 전통적인 CNN(Convolutional Neural Network)의 지역적 수용장(local receptive field)의 한계를 넘어, 이미지의 **전역적인(global) 문맥**과 장거리 의존성(예: 이미지의 왼쪽 끝에 있는 객체와 오른쪽 끝에 있는 객체 간의 관계)을 효과적으로 포착할 수 있다.59 분류를 위해, BERT와 유사하게 시퀀스 앞에 특별한 

  `[class]` 토큰을 추가하고, 트랜스포머 인코더를 통과한 후 이 토큰에 해당하는 최종 출력 벡터를 분류 헤드에 입력하여 이미지의 클래스를 예측한다.60

BERT, GPT, ViT의 성공은 셀프 어텐션이 특정 데이터 양식(modality)에 국한되지 않는 매우 **보편적인(universal)** 연산 메커니즘임을 증명한다. 핵심은 어떤 데이터든(텍스트, 이미지, 음성 등) **이산적인 토큰의 시퀀스(a sequence of discrete tokens)**로 표현할 수만 있다면, 셀프 어텐션이 그 요소들 간의 복잡한 관계를 학습하여 유의미한 표현을 추출할 수 있다는 점이다. ViT가 이미지를 '패치의 시퀀스'로 재해석한 것이 결정적이었다. 이는 딥러닝 연구의 방향을 '각 데이터 양식에 맞는 특화된 아키텍처(예: 텍스트용 RNN, 이미지용 CNN) 개발'에서 '어떻게 다양한 데이터를 범용적인 시퀀스 형태로 변환하여 거대한 단일 아키텍처(트랜스포머)에 입력할 것인가'로 전환시켰다. 이로 인해 멀티모달(multi-modal) 모델의 발전이 가속화되었으며, 셀프 어텐션은 서로 다른 양식의 정보를 통합하는 핵심적인 도구로 자리 잡게 되었다.


셀프 어텐션 메커니즘은 지난 몇 년간 인공지능 분야, 특히 딥러닝의 발전을 이끈 가장 중요한 원동력 중 하나였다. 이는 단순히 기존 모델의 성능을 개선하는 점진적인 발전을 넘어, 순차 데이터 처리의 근본적인 패러다임을 전환시킨 혁명적인 변화였다. 본 보고서는 셀프 어텐션의 이론적 배경과 수학적 원리, 다양한 활용 방식과 한계, 그리고 이를 극복하기 위한 노력들을 종합적으로 고찰했다.


셀프 어텐션과 이를 기반으로 한 트랜스포머 아키텍처는 RNN과 CNN이 지배하던 딥러닝의 지형을 완전히 바꾸었다. 순차적 계산의 굴레에서 벗어나 대규모 병렬 처리를 가능하게 함으로써, 모델의 규모를 전례 없이 확장할 수 있는 길을 열었다. 이는 GPT-3, BERT와 같은 거대 언어 모델(LLM)의 등장을 촉발했으며, 인공지능의 능력을 새로운 차원으로 끌어올렸다.6

더 나아가 셀프 어텐션은 자연어 처리를 넘어 컴퓨터 비전(ViT), 음성 처리 등 다양한 분야로 성공적으로 확장되었다.13 이는 셀프 어텐션이 특정 데이터 양식에 구애받지 않는 범용적인 관계 모델링 메커니즘임을 입증한 것이다. 이제 셀프 어텐션은 현대 딥러닝 모델을 구성하는 가장 기본적인이자 핵심적인 빌딩 블록으로 확고히 자리 잡았다.


셀프 어텐션은 이미 엄청난 성공을 거두었지만, 여전히 활발한 연구가 진행 중이며 앞으로의 발전 가능성 또한 무궁무진하다. 향후 연구는 주로 다음과 같은 방향으로 전개될 것으로 전망된다.

- **효율성 개선:** $O(n^2)$ 계산 복잡도 문제는 여전히 긴 시퀀스를 다루는 데 있어 중요한 과제다. 희소 어텐션, 린포머, 리포머 외에도 커널(kernel) 기반 근사, 상태 공간 모델(State Space Models, SSM) 등 새로운 접근법들이 계속해서 제안되고 있다. 최근에는 Tensor Product Attention(TPA)과 같이 추론 시 메모리 오버헤드를 유발하는 KV 캐시 크기를 줄여 효율성을 높이는 연구도 활발히 진행되고 있다.64
- **아키텍처의 진화:** 셀프 어텐션의 기본 구조를 넘어서는 새로운 아키텍처 탐구가 계속될 것이다. 예를 들어, 고정된 희소 패턴 대신 데이터로부터 어텐션 패턴 자체를 학습하거나 46, 셀프 어텐션을 컨볼루션이나 순환 메커니즘과 같은 다른 연산과 효과적으로 결합하여 각자의 장점을 취하려는 하이브리드 모델 연구가 활발하다.
- **이론적 이해:** 셀프 어텐션이 어떻게 작동하고, 왜 그렇게 효과적인지에 대한 이론적 분석은 아직 초기 단계에 있다. 어텐션 헤드가 학습하는 구체적인 언어적 속성 25, 어텐션 행렬의 스펙트럼 특성과 같은 수학적 성질 47, 그리고 어텐션이 특정 과업을 해결하는 메커니즘에 대한 더 깊은 이해는 더 효율적이고 강건하며 해석 가능한 모델을 설계하는 데 중요한 기반이 될 것이다.

결론적으로, 셀프 어텐션은 현대 인공지능 모델의 심장과도 같은 역할을 하고 있다. 그 효율성과 표현력을 개선하고, 작동 원리를 더 깊이 이해하려는 지속적인 노력은 앞으로도 인공지능 기술 발전의 가장 중요한 동력 중 하나로 남을 것이다. 셀프 어텐션의 이야기는 아직 끝나지 않았으며, 앞으로 펼쳐질 새로운 혁신이 더욱 기대된다.


1. Recurrent Neural Network and Long Term Dependencies | by Infolks Group - Medium, 8월 16, 2025에 액세스, https://infolksgroup.medium.com/recurrent-neural-network-and-long-term-dependencies-e21773defd92
2. What is LSTM - Long Short Term Memory? - GeeksforGeeks, 8월 16, 2025에 액세스, https://www.geeksforgeeks.org/deep-learning/deep-learning-introduction-to-long-short-term-memory/
3. Understanding LSTM Networks -- colah's blog, 8월 16, 2025에 액세스, https://colah.github.io/posts/2015-08-Understanding-LSTMs/
4. What is LSTM? Introduction to Long Short-Term Memory - Analytics Vidhya, 8월 16, 2025에 액세스, https://www.analyticsvidhya.com/blog/2021/03/introduction-to-long-short-term-memory-lstm/
5. What is LSTM (Long Short Term Memory)? - YouTube, 8월 16, 2025에 액세스, https://www.youtube.com/watch?v=b61DPVFX03I
6. Attention Mechanism in Deep Learning - Analytics Vidhya, 8월 16, 2025에 액세스, https://www.analyticsvidhya.com/blog/2019/11/comprehensive-guide-attention-mechanism-deep-learning/
7. Self - Attention in NLP - GeeksforGeeks, 8월 16, 2025에 액세스, https://www.geeksforgeeks.org/nlp/self-attention-in-nlp/
8. Understanding Attention Mechanism: Natural Language Processing | by Nikhil Agrawal | Analytics Vidhya | Medium, 8월 16, 2025에 액세스, https://medium.com/analytics-vidhya/understanding-attention-mechanism-natural-language-processing-9744ab6aed6a
9. What is an attention mechanism? | IBM, 8월 16, 2025에 액세스, https://www.ibm.com/think/topics/attention-mechanism
10. Attention (machine learning) - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Attention_(machine_learning)
11. Attention mechanism in NLP – beginners guide - Int8, 8월 16, 2025에 액세스, https://int8.io/attention-mechanism-in-nlp-beginners-guide/
12. What is Query, Key, and Value (QKV) in the Transformer Architecture ..., 8월 16, 2025에 액세스, https://epichka.com/blog/2023/qkv-transformer/
13. Multi-Head Attention Mechanism - GeeksforGeeks, 8월 16, 2025에 액세스, https://www.geeksforgeeks.org/nlp/multi-head-attention-mechanism/
14. Attention Is All You Need - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need
15. What is self-attention? | IBM, 8월 16, 2025에 액세스, https://www.ibm.com/think/topics/self-attention
16. An Intuition for Attention - Jay Mody, 8월 16, 2025에 액세스, https://jaykmody.com/blog/attention-intuition/
17. Attention is All you Need - NIPS, 8월 16, 2025에 액세스, https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf
18. In Depth Understanding of Attention Mechanism (Part II) - Scaled Dot-Product Attention and Example | by FunCry | Medium, 8월 16, 2025에 액세스, https://medium.com/@funcry/in-depth-understanding-of-attention-mechanism-part-ii-scaled-dot-product-attention-and-its-7743804e610e
19. Attention Mechanism Complexity Analysis | by Mridul Rao - Medium, 8월 16, 2025에 액세스, https://medium.com/@mridulrao674385/attention-mechanism-complexity-analysis-7314063459b1
20. The Annotated Transformer - Harvard NLP, 8월 16, 2025에 액세스, http://nlp.seas.harvard.edu/2018/04/03/attention.html
21. Explained: Multi-head Attention (Part 1) - Erik Storrs, 8월 16, 2025에 액세스, https://storrs.io/attention/
22. Multi-Head Attention and Transformers Architecture | Spring of Realtime LLMs, 8월 16, 2025에 액세스, https://kdag-iit-kharagpur.gitbook.io/realtime-llm/word-vectors-simplified/bonus-section-overview-of-the-transformers-architecture/multi-head-attention-and-transformers-architecture
23. Exploring Multi-Head Attention: Why More Heads Are Better Than One | by Hassaan Idrees, 8월 16, 2025에 액세스, https://medium.com/@hassaanidrees7/exploring-multi-head-attention-why-more-heads-are-better-than-one-006a5823372b
24. Understanding Multi Head Attention in Transformers | by Sachinsoni - Medium, 8월 16, 2025에 액세스, https://medium.com/@sachinsoni600517/multi-head-attention-in-transformers-1dd087e05d41
25. What Does BERT Look At? An Analysis of BERT's Attention - Stanford NLP Group, 8월 16, 2025에 액세스, https://www-nlp.stanford.edu/pubs/clark2019what.pdf
26. What is Positional Encoding? - IBM, 8월 16, 2025에 액세스, https://www.ibm.com/think/topics/positional-encoding
27. A Gentle Introduction to Positional Encoding in Transformer Models ..., 8월 16, 2025에 액세스, https://machinelearningmastery.com/a-gentle-introduction-to-positional-encoding-in-transformer-models-part-1/
28. Positional Encoding in Transformers - GeeksforGeeks, 8월 16, 2025에 액세스, https://www.geeksforgeeks.org/nlp/positional-encoding-in-transformers/
29. Positional Encoding in the Transformer Model | by Sandaruwan Herath - Medium, 8월 16, 2025에 액세스, https://medium.com/image-processing-with-python/positional-encoding-in-the-transformer-model-e8e9979df57f
30. Encoder vs. Decoder in Transformers: Unpacking the Differences ..., 8월 16, 2025에 액세스, https://medium.com/@hassaanidrees7/encoder-vs-decoder-in-transformers-unpacking-the-differences-9e6ddb0ff3c5
31. Introduction to Transformers and Attention Mechanisms | by Rakshit Kalra | Medium, 8월 16, 2025에 액세스, https://medium.com/@kalra.rakshit/introduction-to-transformers-and-attention-mechanisms-c29d252ea2c5
32. The Annotated Transformer - Harvard NLP, 8월 16, 2025에 액세스, https://nlp.seas.harvard.edu/2018/04/03/attention.html
33. What am I missing here in this decoder-only transformer architecture? : r/learnmachinelearning - Reddit, 8월 16, 2025에 액세스, https://www.reddit.com/r/learnmachinelearning/comments/1ez7tjl/what_am_i_missing_here_in_this_decoderonly/
34. How does the (decoder-only) transformer architecture work? - AI Stack Exchange, 8월 16, 2025에 액세스, https://ai.stackexchange.com/questions/40179/how-does-the-decoder-only-transformer-architecture-work
35. Explain Self-Attention, and Masked Self-Attention as used in Transformers - AIML.com, 8월 16, 2025에 액세스, https://aiml.com/explain-self-attention-and-masked-self-attention-as-used-in-transformers/
36. How to understand masked multi-head attention in transformer - Stack Overflow, 8월 16, 2025에 액세스, https://stackoverflow.com/questions/58127059/how-to-understand-masked-multi-head-attention-in-transformer
37. encoder-decoder attention - learnius, 8월 16, 2025에 액세스, https://learnius.com/llms/2+LLMs+and+Transformers/encoder-decoder+attention
38. arxiv.org, 8월 16, 2025에 액세스, https://arxiv.org/html/1706.03762v7
39. 5 Attention Mechanism Insights Every AI Developer Should Know - Shelf.io, 8월 16, 2025에 액세스, https://shelf.io/blog/attention-mechanism/
40. On The Computational Complexity of Self-Attention - Proceedings of Machine Learning Research, 8월 16, 2025에 액세스, https://proceedings.mlr.press/v201/duman-keles23a/duman-keles23a.pdf
41. Complexity of transformer attention network : r/LanguageTechnology - Reddit, 8월 16, 2025에 액세스, https://www.reddit.com/r/LanguageTechnology/comments/9gulm9/complexity_of_transformer_attention_network/
42. Demystifying Sparse Attention: A Comprehensive Guide from Scratch | by VISHAL SINGH, 8월 16, 2025에 액세스, https://medium.com/@vishal09vns/sparse-attention-dad17691478c
43. Self-Attention: A Deep Dive - Number Analytics, 8월 16, 2025에 액세스, https://www.numberanalytics.com/blog/self-attention-deep-dive
44. Reformer - The Efficient Transformer, 8월 16, 2025에 액세스, https://raviteja-ganta.github.io/Reformer-The-efficient-Transformer
45. kyegomez/SparseAttention: Pytorch Implementation of the sparse attention from the paper: "Generating Long Sequences with Sparse Transformers" - GitHub, 8월 16, 2025에 액세스, https://github.com/kyegomez/SparseAttention
46. Generative modeling with sparse transformers - OpenAI, 8월 16, 2025에 액세스, https://openai.com/index/sparse-transformer/
47. Linformer: Self-Attention with Linear Complexity (Paper Explained), 8월 16, 2025에 액세스, https://lilys.ai/notes/200263
48. Linformer: Self-Attention with Linear Complexity (Paper Explained) - YouTube, 8월 16, 2025에 액세스, https://www.youtube.com/watch?v=-_2AF9Lhweo
49. Linformer: Making Transformers Linear, Efficient, and Scalable | by Ruhaan838 | Medium, 8월 16, 2025에 액세스, https://medium.com/@ruhaan838/linformer-making-transformers-linear-efficient-and-scalable-84f21880ea02
50. [2006.04768] Linformer: Self-Attention with Linear Complexity - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2006.04768
51. Reformer: Transformers, Longer Sequences, and More Efficiency - Medium, 8월 16, 2025에 액세스, https://medium.com/@kdk199604/reformer-transformers-longer-sequences-and-more-efficiency-b36d627b8844
52. [2001.04451] Reformer: The Efficient Transformer - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2001.04451
53. BERT (language model) - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/BERT_(language_model)
54. A Deep Dive into BERT's Attention Mechanism - Analytics Vidhya, 8월 16, 2025에 액세스, https://www.analyticsvidhya.com/blog/2023/12/berts-attention-mechanism/
55. Attention Mechanism with BERT for Content Annotation and Categorization of Pregnancy-Related Questions on a Community Q&A Site - PMC, 8월 16, 2025에 액세스, https://pmc.ncbi.nlm.nih.gov/articles/PMC7929090/
56. Transformer (deep learning architecture) - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)
57. How is the GPT's masked-self-attention is utilized on fine-tuning/inference - Stack Overflow, 8월 16, 2025에 액세스, https://stackoverflow.com/questions/64799622/how-is-the-gpts-masked-self-attention-is-utilized-on-fine-tuning-inference
58. Self-attention in vision transformers performs perceptual grouping, not attention - Frontiers, 8월 16, 2025에 액세스, https://www.frontiersin.org/journals/computer-science/articles/10.3389/fcomp.2023.1178450/full
59. Vision Transformers (ViT) in Image Recognition: Full Guide - viso.ai, 8월 16, 2025에 액세스, https://viso.ai/deep-learning/vision-transformer-vit/
60. Vision transformer - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Vision_transformer
61. Vision Transformers (ViT) Explained - Pinecone, 8월 16, 2025에 액세스, https://www.pinecone.io/learn/series/image-search/vision-transformers/
62. ViT : Vision Transformer. An Image is worth 16x16 Words | by Varun Sivamani | Medium, 8월 16, 2025에 액세스, https://medium.com/@varunsivamani/vit-vision-transformer-58dad036ee12
63. "Attention is All You Need" Summary - Medium, 8월 16, 2025에 액세스, https://medium.com/@dminhk/attention-is-all-you-need-summary-6f0437e63a91
64. [2501.06425] Tensor Product Attention Is All You Need - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2501.06425
65. Tensor Product Attention Is All You Need - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/html/2501.06425v2

