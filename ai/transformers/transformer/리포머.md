# 리포머(Reformer)
[트랜스포머 (Transformer)](./index.md)



2017년 "Attention Is All You Need" 논문을 통해 제안된 트랜스포머(Transformer) 아키텍처는 자연어 처리(NLP) 분야에 혁명적인 변화를 가져왔으며, 이후 컴퓨터 비전, 음성 처리 등 인공지능의 다양한 영역으로 확장되어 사실상의 표준 모델로 자리매김하였다.1 트랜스포머의 성공을 이끈 핵심 동력은 재귀적(recurrent) 구조를 완전히 배제하고 오직 셀프 어텐션(self-attention) 메커니즘에만 의존하여 시퀀스 내의 관계를 모델링한다는 점에 있다. 셀프 어텐션은 시퀀스 내 모든 토큰 쌍 간의 상호작용을 직접적으로 계산함으로써, 기존의 RNN이나 LSTM이 겪었던 장거리 의존성(long-range dependency) 포착의 어려움을 효과적으로 해결하였다.

표준 트랜스포머에서 사용하는 스케일드 닷-프로덕트 어텐션(Scaled Dot-Product Attention)은 쿼리(Query, Q), 키(Key, K), 밸류(Value, V)라는 세 가지 행렬을 통해 작동한다. 입력 시퀀스의 각 토큰은 Q, K, V 벡터로 변환되며, 특정 쿼리 토큰은 시퀀스 내 모든 키 토큰과의 유사도(내적)를 계산한다. 이 유사도 점수는 스케일링되고 소프트맥스(softmax) 함수를 거쳐 어텐션 가중치(attention weight)로 변환된다. 최종적으로 이 가중치는 각 키에 해당하는 밸류 벡터에 곱해져 가중합(weighted sum)의 형태로 출력된다. 이 과정은 다음 수식으로 요약된다.5

$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$
이 메커니즘을 통해 모델은 각 토큰을 표현할 때 시퀀스 전체의 문맥 정보를 종합적으로 고려할 수 있으며, 이는 모델의 표현력을 극대화하는 원동력이 되었다.


그러나 셀프 어텐션의 강력한 표현력은 막대한 계산 비용을 수반한다. 핵심적인 병목은 시퀀스 길이 $L$과 임베딩 차원 $d_k$를 갖는 쿼리 행렬 $Q$와 키 행렬 $K$의 전치 $K^T$를 곱하는 $QK^T$ 연산에서 발생한다. 이 행렬 곱셈은 $L x L$ 크기의 어텐션 스코어 행렬을 생성하며, 이는 시퀀스 길이 $L$에 대해 제곱에 비례하는, 즉 $O(L^2)$의 시간 및 메모리 복잡도를 유발한다.5

이 이차적 복잡도는 시퀀스 길이가 길어질수록 치명적인 한계로 작용한다. 예를 들어, 길이가 65,536 (64K)인 시퀀스를 처리할 경우, $64K x 64K$ 크기의 어텐션 행렬은 32비트 부동소수점 기준으로 약 16GB의 메모리를 필요로 한다. 이는 단일 배치(batch size 1)에 대해서도 현대의 고성능 가속기(GPU/TPU)가 감당하기 어려운 수준이다.5 이러한 제약으로 인해 표준 트랜스포머는 보통 512 또는 1024 토큰 정도의 짧은 시퀀스에만 적용될 수 있었다. 이는 책 한 권의 내용 전체, 고해상도 이미지, 긴 오디오 파일과 같은 장문(long-form) 데이터를 하나의 입력으로 처리하는 것을 원천적으로 불가능하게 만들었다.1

결과적으로, $O(L^2)$ 병목은 단순히 계산상의 문제가 아니라, 트랜스포머의 적용 범위를 근본적으로 제한하는 아키텍처적 제약이 되었다. 이 문제를 우회하기 위해 연구자들과 현업 개발자들은 긴 문서를 여러 개의 작은 조각(chunk)으로 나누어 처리하거나, 슬라이딩 윈도우(sliding window) 방식을 사용하는 등 정보를 손실시키는 임시방편에 의존해야만 했다.11 이러한 접근법들은 모델이 전체 문맥을 한 번에 조망하는 트랜스포머의 본질적인 장점을 훼손하는 결과를 낳았다. 따라서, $O(L^2)$ 복잡도를 극복하고 아키텍처의 원래 약속, 즉 손실 없는 전체 문맥 이해를 복원하려는 노력이 절실히 필요했다.


이러한 배경 속에서 트랜스포머의 계산 효율성을 개선하려는 연구가 활발히 진행되었다. 이는 단순히 더 큰 모델을 더 빠르게 훈련시키는 문제를 넘어, 제한된 컴퓨팅 자원을 가진 학계나 소규모 연구 그룹도 최첨단 모델을 활용할 수 있도록 하는 'AI 민주화'의 중요한 일환으로 인식되었다.1 거대 산업 연구소에서만 훈련 가능한 모델이 주류가 되는 현상은 NLP 연구의 발전을 저해할 수 있다는 우려도 제기되었다.9 이와 같은 흐름은 AI 연구의 패러다임이 순수한 성능 확장 경쟁에서 성능과 효율성의 균형을 맞추는 방향으로 성숙하고 있음을 시사한다.13

이러한 문제의식 속에서 2020년 ICLR에 발표된 리포머(Reformer)는 획기적인 해결책을 제시하며 큰 주목을 받았다.1 리포머는 두 가지 핵심 기술을 통해 트랜스포머의 효율성을 극적으로 개선했다. 첫째, 지역성 민감 해싱(Locality-Sensitive Hashing, LSH)을 이용한 어텐션 근사를 통해 계산 복잡도를 $O(L^2)$에서 $O(L \log L)$로 낮추었다. 둘째, 가역 잔차 네트워크(Reversible Residual Networks)를 도입하여 훈련 시 활성화 값 저장에 필요한 메모리 복잡도를 레이어 수 $N$에 비례하던 것에서 $N$과 무관한 상수로 만들었다.5

본 보고서는 트랜스포머 효율화 연구의 중요한 이정표인 리포머를 심층적으로 고찰하고자 한다. 리포머를 구성하는 핵심 기술들의 이론적 배경과 구체적인 메커니즘을 수학적 원리와 함께 분석하고, 실험을 통해 입증된 성능과 의의를 종합적으로 평가할 것이다.


리포머의 첫 번째 핵심 혁신은 표준 닷-프로덕트 어텐션의 $O(L^2)$ 계산 병목을 해결하기 위해 지역성 민감 해싱(LSH)을 도입한 것이다. 이는 어텐션 계산의 본질에 대한 깊은 통찰에서 출발한다.


셀프 어텐션의 계산 과정, 특히 소프트맥스 함수를 적용하는 부분은 본질적으로 각 쿼리 토큰에 대해 의미적으로 가장 유사한, 즉 벡터 공간에서 내적 값이 가장 큰 키 토큰들을 찾는 과정으로 해석될 수 있다. 소프트맥스 함수는 지수적으로 값을 증폭시키므로, 소수의 큰 값들이 최종 어텐션 가중치의 대부분을 결정하고 나머지 작은 값들의 영향력은 거의 0에 가깝게 된다. 이 관찰은 모든 $L$개의 키-쿼리 쌍을 계산하는 대신, 각 쿼리에 대해 가장 관련성이 높은 키들의 부분집합에만 집중해도 전체 어텐션 분포를 매우 효과적으로 근사할 수 있다는 아이디어를 뒷받침한다.5

이 문제는 고차원 벡터 공간에서 주어진 쿼리 벡터와 가장 가까운 이웃 벡터들을 효율적으로 찾는 '최근접 이웃 탐색(Nearest Neighbor Search)' 문제와 맞닿아 있다. 데이터의 차원이 높아질수록 모든 점과의 거리를 계산하는 것이 기하급수적으로 어려워지는 '차원의 저주(curse of dimensionality)' 현상 때문에, 정확한 해를 찾는 것은 비효율적이다.18 이에 대한 실용적인 대안이 바로 '근사 최근접 이웃 탐색(Approximate Nearest Neighbor, ANN)'이며, LSH는 이 ANN 문제를 해결하는 가장 대표적이고 효과적인 기법 중 하나이다.18

LSH의 핵심 원리는 데이터 포인트를 해싱하여 여러 버킷(bucket)에 할당하되, 원래 공간에서 가까웠던(유사했던) 점들은 높은 확률로 같은 버킷에 할당하고, 멀었던(상이했던) 점들은 다른 버킷에 할당하는 특수한 해시 함수군을 사용하는 것이다.5 이를 통해, 쿼리가 주어졌을 때 전체 데이터베이스를 검색하는 대신 쿼리가 속한 버킷 내의 후보군만을 대상으로 유사도를 계산함으로써 검색 공간을 극적으로 줄일 수 있다.


리포머는 이러한 LSH의 원리를 어텐션 메커니즘에 접목하여 계산 효율성을 달성한다. 이는 몇 가지 세부적인 설계 요소들의 유기적인 결합을 통해 구현된다.


LSH를 적용하기 위해서는 유사도를 측정할 대상인 쿼리와 키가 동일한 벡터 공간에 존재해야 한다. 표준 트랜스포머에서는 입력 활성화 $A$로부터 서로 다른 가중치 행렬을 곱해 Q, K, V를 생성하므로 Q와 K는 일반적으로 다른 벡터가 된다. 리포머는 이 문제를 해결하기 위해 Q와 K를 생성할 때 동일한 선형 변환 레이어를 공유하고, V에 대해서만 별도의 레이어를 사용한다. 이를 '공유-QK(shared-QK)' 구조라고 하며, 이 구조적 변경이 모델 성능에 미치는 영향은 미미함을 실험적으로 확인하였다.5 이로써 $q_i$와 $k_j$가 같은 공간에 존재하게 되어 LSH를 통한 유사도 기반 버킷팅이 가능해진다.


리포머는 '무작위 투영(random projections)' 기반의 LSH 방식을 채택한다. 이는 구현이 간단하면서도 각도 거리를 보존하는 데 효과적이다. 구체적으로, $d_k$ 차원의 벡터 $x$에 대해, 크기가 $[d_k, b/2]$인 고정된 무작위 행렬 $R$을 미리 생성한다. 해시 함수 $h(x)$는 $x$와 $R$의 곱, 그리고 $-x$와 $R$의 곱을 연결한 벡터에서 가장 큰 값을 갖는 인덱스로 정의된다.5

$$
h(x) = \text{argmax}()
$$
이 함수는 $x$를 총 $b$개의 해시 버킷 중 하나에 결정론적으로 할당한다. 이 방식의 기하학적 의미는 여러 개의 무작위 초평면으로 공간을 분할하고, $x$가 어떤 영역에 속하는지를 나타내는 것과 같다. 결과적으로, 벡터 공간에서 각도 거리가 가까운 벡터들은 높은 확률로 동일한 해시 값, 즉 동일한 버킷 ID를 부여받게 된다.5


모든 토큰의 공유 QK 벡터를 해싱하여 각 토큰에 버킷 ID를 할당한 후, 리포머는 효율적인 병렬 계산을 위해 독창적인 정렬 및 청킹 기법을 사용한다. 먼저, 시퀀스 내의 모든 토큰을 다음 두 가지 기준에 따라 정렬한다: (1) 해시 버킷 ID를 기준으로 오름차순 정렬, (2) 동일한 버킷 내에서는 원래 시퀀스에서의 위치를 기준으로 오름차순 정렬. 이 정렬 과정을 거치면, 동일한 해시 버킷에 속한 토큰들이 메모리 상에서 연속적으로 위치하게 된다.5

이렇게 정렬된 시퀀스는 고정된 크기 $m$의 여러 청크(chunk)로 분할된다. 어텐션 계산은 이제 전체 $L x L$ 행렬에 대해 수행되는 것이 아니라, 각 쿼리가 속한 청크 내부의 토큰들과, 인과적 마스킹(causal masking)을 고려하여 바로 이전 청크의 토큰들 사이에서만 제한적으로 수행된다.5 이는 실질적으로 전체 어텐션 행렬을 계산하는 대신, 대각선 블록 주변의 희소한 패턴만을 계산하는 것과 같은 효과를 낳는다. 이로써 각 쿼리는 평균적으로 $m$ 또는 $2m$개의 키에 대해서만 어텐션을 계산하게 되어, 계산량이 $L$에 선형적으로 비례하게 된다.


LSH는 확률적 기법이므로, 실제로는 유사하지만 해시 경계에 위치하여 우연히 다른 버킷으로 할당되는 오류(false negative)가 발생할 수 있다. 이러한 가능성을 줄이고 근사의 정확도를 높이기 위해, 리포머는 '다중 라운드 어텐션'을 도입한다. 이는 서로 다른 무작위 행렬 $R$을 사용하여 $n_{rounds}$개의 독립적인 해싱 함수를 만들고, 해싱-정렬-청킹 과정을 여러 번 반복하는 것을 의미한다.5

최종적으로 한 토큰이 어텐션할 수 있는 대상은 각 라운드에서 허용된 모든 토큰들의 합집합이 된다. 해싱 라운드 수($n_{rounds}$)를 늘릴수록 더 많은 잠재적 이웃을 포착할 수 있어 성능은 풀 어텐션에 가까워지지만, 계산 비용도 그에 비례하여 증가한다. 이는 결정론적이고 정확한 계산을 포기하는 대신, 모델 설계자가 정확도와 계산 효율성 사이의 균형을 직접 조절할 수 있는 새로운 하이퍼파라미터 공간을 제공한다는 점에서 중요한 의미를 가진다. 이러한 트레이드오프를 통해 다양한 하드웨어 제약과 태스크 요구사항에 맞춰 모델을 유연하게 조정할 수 있게 된다.12


LSH 어텐션의 도입은 트랜스포머의 복잡도 프로파일을 근본적으로 변화시킨다. 가장 비용이 많이 드는 $O(L^2)$의 행렬 곱셈 연산이 사라지고, 그 자리를 시퀀스 정렬($O(L \log L)$)과 청크 단위의 선형적인 어텐션 계산($O(L)$)이 대체한다. 결과적으로, 전체 어텐션 레이어의 시간 및 메모리 복잡도는 $O(L^2)$에서 $O(L \log L)$로 감소한다.5 이는 시퀀스 길이 $L$이 수천, 수만을 넘어갈 때 기하급수적인 효율성 향상을 가져온다.

다만, LSH 어텐션의 정렬 과정은 중요한 부수적 효과를 낳는다. 원래 시퀀스의 위치적 인접성이 깨지고, 해시 값에 따라 토큰들이 재배열된다. 이는 모델이 시퀀스의 실제 순서를 이해하기 위해 위치 인코딩(positional encoding)에 더 강하게 의존해야 함을 의미한다. 표준 어텐션에서는 모든 토큰 쌍의 상대적 위치가 어텐션 행렬 내에서 암묵적으로 고려되지만, LSH 어텐션에서는 재정렬된 데이터 뷰 위에서 작동하므로 위치 인코딩의 역할이 더욱 중요해진다. 이는 LSH 어텐션의 효과가 위치 인코딩 방식의 표현력과 깊이 결합되어 있음을 시사한다.


리포머의 두 번째 핵심 혁신은 어텐션 계산이 아닌, 훈련 과정에서의 메모리 사용량 문제를 해결하는 데 초점을 맞춘다. LSH 어텐션이 시간 복잡도를 해결했다면, 가역 잔차 네트워크는 모델의 깊이와 관련된 메모리 복잡도를 해결한다.


신경망을 경사 하강법으로 훈련시키기 위해서는 역전파(backpropagation) 알고리즘을 통해 손실 함수의 그래디언트를 계산해야 한다. 체인룰(chain rule)에 기반한 역전파 과정은 특정 레이어의 가중치에 대한 그래디언트를 계산하기 위해 해당 레이어의 입력으로 사용되었던 순방향 패스(forward pass)의 활성화(activation) 값을 필요로 한다.21 이 때문에 딥러닝 프레임워크는 훈련 중 각 레이어의 출력 활성화 텐서를 메모리에 저장해두었다가 역전파 시에 사용한다.

이러한 방식은 모델의 깊이, 즉 레이어의 수 $N$에 비례하여 메모리 사용량이 선형적으로 증가하는 결과를 낳는다. 표준 트랜스포머의 경우, 활성화 저장을 위한 총 메모리 요구량은 대략 $O(L \times d_{model} \times N)$에 달한다. 시퀀스 길이 $L$이 길고 모델의 깊이 $N$이 수십, 수백 개에 이르는 대규모 모델에서는 이 활성화 저장 비용이 모델 파라미터 저장 비용을 초과하며 GPU 메모리를 고갈시키는 주된 원인이 된다.1 이는 매우 깊은 모델의 훈련을 사실상 불가능하게 만드는 심각한 병목 현상이다.


리포머는 이 문제를 해결하기 위해 Gomez 등이 제안한 가역 잔차 네트워크(Reversible Residual Network, RevNet)의 아이디어를 트랜스포머 아키텍처에 도입한다.21 RevNet의 핵심 철학은 각 레이어의 연산을 수학적으로 가역적(invertible)으로 설계하여, 순방향 패스의 출력이 주어졌을 때 입력을 정보 손실 없이 정확하게 복원할 수 있도록 하는 것이다.22

가역 블록의 구조는 다음과 같다. 먼저, 입력 텐서 $x$를 채널(channel) 차원을 따라 동일한 크기의 두 개의 하위 텐서 $x_1$과 $x_2$로 분할한다.21 그리고 

$F$와 $G$라는 두 개의 임의의 함수(잔차 함수)를 정의한다. 리포머에서는 이들이 각각 어텐션 레이어와 피드포워드 네트워크(FFN)에 해당한다.

순방향 계산 (Forward Pass):

순방향 계산은 덧셈 결합(additive coupling)이라는 방식을 따른다. $x_2$가 함수 F를 통과한 결과가 $x_1$에 더해져 첫 번째 출력 $y_1$이 되고, 이 $y_1$이 다시 함수 G를 통과한 결과가 $x_2$에 더해져 두 번째 출력 $y_2$가 된다.21

$$
y_1 = x_1 + F(x_2)
$$

$$
y_2 = x_2 + G(y_1)
$$

역방향 계산 (Reverse/Reconstruction):

이 순방향 계산 과정은 매우 간단한 대수적 조작을 통해 완벽하게 역으로 되돌릴 수 있다. 출력 $y_1$, $y_2$가 주어졌을 때, 원래의 입력 $x_1$, $x_2$는 다음의 역연산을 통해 복원된다.21

$$
x_2 = y_2 - G(y_1)
$$

$$
x_1 = y_1 - F(x_2)
$$

이 가역성 덕분에, 역전파 과정에서 이전 레이어의 활성화 값이 필요할 때마다 메모리에 저장된 값을 불러오는 대신, 현재 레이어의 활성화 값으로부터 위의 역방향 계산을 통해 즉석에서 복원(recompute)하여 사용할 수 있다.22


가역 블록의 도입은 훈련 시 메모리 사용 패턴을 근본적으로 바꾼다. $N$개 레이어 전체에 대한 활성화 값을 모두 저장할 필요 없이, 가장 마지막 레이어의 활성화 값 하나만 저장하면 역전파 과정에서 필요한 모든 중간 활성화 값들을 순차적으로 복원해 나갈 수 있다. 결과적으로, 활성화 저장을 위한 메모리 복잡도는 모델의 깊이 $N$에 비례하던 $O(N)$에서 $N$과 무관한 $O(1)$로 극적으로 감소한다.5

이러한 혁신적인 메모리 절감은 대가를 수반한다. 메모리를 절약하는 대신, 역전파 과정에서 각 레이어의 입력을 복원하기 위해 잔차 함수 $F$와 $G$를 한 번 더 계산해야 하는 추가적인 계산 비용이 발생한다. 이는 전형적인 '메모리-계산 트레이드오프(memory-compute trade-off)'의 사례로, RevNet 논문에 따르면 약 33%에서 50%의 계산 오버헤드를 유발한다.23 그러나 현대의 가속기들이 종종 순수 계산 능력보다 메모리 대역폭이나 용량에 의해 병목이 발생하는 경우가 많다는 점을 고려할 때 6, 이러한 트레이드오프는 매우 유리한 선택이 될 수 있다.

가역 레이어의 도입은 모델의 깊이가 활성화 메모리 측면에서 거의 '공짜' 자원이 되게 함으로써, 이전에는 상상할 수 없었던 수백, 수천 개의 레이어를 가진 극도로 깊은(radically deep) 아키텍처의 탐색을 가능하게 한다. 이는 복잡한 장거리 추론 능력이 요구되는 문제 해결에 새로운 가능성을 열어줄 수 있다. 또한, 가역성을 위한 구조적 제약, 예를 들어 정보를 버리는 다운샘플링(strided convolution, pooling) 연산을 사용할 수 없다는 점 23은, 네트워크가 각 레이어에서 정보를 압축하고 버리는 대신 변환하고 보존하도록 강제한다. 이러한 '정보 보존'의 강제는 모델이 더 풍부한 그래디언트를 학습하도록 돕는 유익한 정규화(regularization) 메커니즘으로 작용할 잠재력을 가진다.


리포머는 LSH 어텐션과 가역 레이어라는 두 가지 핵심 기술을 개별적으로 적용하는 데 그치지 않고, 이들을 하나의 통합된 아키텍처로 결합하고 추가적인 최적화를 통해 효율성을 극대화한다. 이는 시스템 전체의 병목 지점을 체계적으로 분석하고 해결하려는 리포머의 총체적인 최적화 철학을 보여준다.


리포머는 표준 트랜스포머 블록을 가역 블록 구조로 재설계한다. 앞서 설명한 가역 블록의 두 잔차 함수 $F$와 $G$는 리포머에서 각각 LSH 어텐션 레이어와 피드포워드 네트워크(FFN) 레이어에 직접 대응된다.5 즉, $F = \text{Attention}$이고 $G = \text{FFN}$이다.

따라서, 가역 트랜스포머 블록의 순방향 계산은 다음과 같이 이루어진다. 입력 활성화가 $x_1$과 $x_2$로 분할된 후,

1. $y_1 = x_1 + \text{Attention}(x_2)$
2. $y_2 = x_2 + \text{FFN}(y_1)$

이 구조를 통해 어텐션 연산과 FFN 연산이 모두 가역적인 흐름 안에 통합된다. 결과적으로, 전체 트랜스포머 블록의 중간 활성화 값(어텐션 레이어의 출력 등)을 역전파를 위해 저장할 필요가 없어진다. 이는 LSH 어텐션의 시간 효율성과 가역 레이어의 메모리 효율성을 동시에 달성하는 우아한 설계이다.

이러한 통합은 표준 트랜스포머 블록의 순차적이고 분리된 구조와는 다른 학습 동역학을 유발할 수 있다. 표준 블록에서는 FFN이 어텐션으로 완전히 문맥화된 표현을 입력으로 받지만, 리포머의 가역 블록에서는 FFN이 원본 입력의 일부($x_1$)와 어텐션 출력이 혼합된 하이브리드 표현($y_1$)을 입력으로 받는다. 가역성이라는 제약에서 비롯된 이 미묘한 구조적 차이는 모델이 표현을 학습하는 방식에 독특한 귀납적 편향(inductive bias)을 부여할 수 있다.


가역 레이어가 레이어 간 활성화 메모리 문제를 해결하더라도, 단일 레이어 내부의 계산 과정에서 발생하는 메모리 피크는 여전히 문제가 될 수 있다. 특히 트랜스포머의 FFN 레이어는 일반적으로 모델의 은닉 차원 $d_{model}$을 4배 더 큰 중간 차원 $d_{ff}$로 확장했다가 다시 축소하는 구조를 가지는데, 이 과정에서 생성되는 거대한 중간 활성화 텐서(크기: $L \times d_{ff}$)가 긴 시퀀스에 대해 상당한 메모리를 차지할 수 있다.5

리포머는 이 문제를 해결하기 위해 '청킹(chunking)' 기법을 추가로 도입한다. FFN의 계산은 시퀀스 내의 각 위치(토큰)에 대해 완전히 독립적으로 수행될 수 있다는 점에 착안한 것이다. 리포머는 전체 시퀀스에 대한 FFN 계산을 한 번에 수행하는 대신, 시퀀스 차원을 따라 여러 개의 작은 청크 $c$로 분할하여 순차적으로 처리한다.5 예를 들어, 길이 64K의 시퀀스를 64개의 청크로 나누면, 한 번에 1K 길이의 시퀀스에 대해서만 FFN 계산을 수행하게 된다. 이는 한 번에 전체 중간 텐서를 메모리에 올리는 대신, 훨씬 작은 청크 단위의 중간 텐서만을 필요로 하므로, FFN 레이어의 최대 메모리 사용량을 이론적으로 $1/c$로 줄이는 효과를 가져온다.


리포머의 아키텍처는 다각적인 효율화 전략의 집약체이다. 이는 단일 병목 현상에만 집중하는 것이 아니라, 트랜스포머 시스템 전체의 성능 특성을 깊이 이해하고 여러 비효율성의 원인을 체계적으로 해결한 결과물이다.

1. **어텐션 계산 병목 ($O(L^2)$):** LSH 어텐션을 통해 $O(L \log L)$로 해결한다.
2. **레이어 간 활성화 메모리 병목 ($O(N)$):** 가역 레이어를 통해 $O(1)$로 해결한다.
3. **레이어 내 FFN 메모리 병목:** FFN 청킹을 통해 해결한다.

이 세 가지 기술의 유기적인 조합을 통해 리포머는 기존 트랜스포머와 대등한 수준의 성능을 유지하면서도, 이전에는 불가능했던 수만 토큰 길이의 시퀀스를 훨씬 적은 메모리와 훨씬 빠른 속도로 처리하는 능력을 갖추게 되었다.1


리포머의 이론적 효율성은 실제 벤치마크 데이터셋에서의 실험을 통해 엄밀하게 검증되었다. 평가는 주로 모델의 정확도, 메모리 사용량, 그리고 처리 속도라는 세 가지 핵심 지표를 중심으로 이루어졌다.


리포머의 성능은 특히 긴 시퀀스 처리 능력이 중요한 태스크에서 집중적으로 평가되었다. 대표적인 벤치마크는 다음과 같다.

- **enwik8:** 위키피디아 텍스트의 첫 1억 바이트로 구성된 데이터셋으로, 문자 수준 언어 모델링(character-level language modeling) 태스크에 사용된다. 모델은 다음 문자를 예측하도록 훈련되며, 최대 65,536 (64K) 길이의 매우 긴 시퀀스를 처리해야 한다.5 성능은 주로 차원당 비트 수(bits-per-dimension, bpd) 또는 문자당 비트 수(bits-per-character, bpc)로 측정되며, 낮을수록 우수한 성능을 의미한다.
- **imagenet-64:** 64x64 해상도의 ImageNet 데이터셋을 이용한 이미지 생성 태스크이다. 이미지를 12,288개의 픽셀 시퀀스로 취급하여, 모델이 자기회귀적(auto-regressive)으로 다음 픽셀 값을 예측하도록 훈련된다.5 이 역시 긴 시퀀스 모델링 능력을 평가하는 데 사용된다.

주요 평가 지표는 모델의 예측 정확도(bpd), 훈련 및 추론 중 최대 메모리 사용량, 그리고 특정 작업을 완료하는 데 걸리는 실제 시간(wall-clock time)이다.1


실험 결과, 리포머는 효율성을 위해 도입한 근사 기법들이 모델의 표현력을 심각하게 저해하지 않으면서도, 메모리와 속도 측면에서 극적인 개선을 이루었음을 보여주었다.

- **정확도:** 리포머는 표준 트랜스포머와 "동등한(on par)" 성능을 달성했다. 예를 들어, 12개의 레이어를 가진 리포머 모델은 추가적인 하이퍼파라미터 튜닝을 통해 enwik8 테스트셋에서 1.05 bpd라는 우수한 성능을 기록했다. 이는 당시 최첨단(SOTA) 모델들과 비교해도 경쟁력 있는 수치로, LSH 어텐션이 풀 어텐션의 핵심적인 기능을 성공적으로 근사했음을 시사한다.1

- **메모리 효율성:** 메모리 사용량 측면에서 리포머는 압도적인 우위를 보였다. 가역 레이어 덕분에 모델의 깊이가 증가해도 활성화 저장에 필요한 메모리가 거의 늘어나지 않았고, LSH 어텐션은 거대한 $L \times L$ 어텐션 행렬을 메모리에 생성할 필요를 없앴다. 이러한 혁신 덕분에, 이전에는 여러 개의 가속기를 사용한 모델 병렬화가 필수적이었던 수만 토큰 길이의 시퀀스를 단일 GPU/TPU 가속기 상에서 훈련하는 것이 가능해졌다.5

- **속도:** 긴 시퀀스에 대해 리포머는 표준 트랜스포머보다 훨씬 빠른 처리 속도를 보였다. 시퀀스 길이 $L$이 2048을 넘어서면서부터 $O(L \log L)$ 복잡도의 이점이 명확히 드러나기 시작하며, $L$이 수만 단위로 커질수록 속도 격차는 더욱 벌어진다.1 그러나 LSH 어텐션은 해싱, 정렬 등 추가적인 연산 오버헤드를 수반하므로, 시퀀스 길이가 비교적 짧은 경우(예: $L < 1024$)에는 풀 어텐션을 직접 계산하는 표준 트랜스포머보다 오히려 느릴 수 있다.26

이러한 실험 결과는 리포머가 모든 상황에서 표준 트랜스포머를 대체하는 만능 해결책이 아니라, 특히 장거리 시퀀스라는 특정 영역에서 탁월한 성능을 발휘하는 특화된 도구임을 명확히 보여준다. 이는 모델 아키텍처 선택이 해결하고자 하는 문제의 특성(특히 시퀀스 길이)에 따라 달라져야 함을 시사하며, 모델 최적화에는 '공짜 점심은 없다(no free lunch)'는 원칙을 다시 한번 확인시켜 준다.7

다음 표는 enwik8 벤치마크를 기준으로 리포머와 표준 트랜스포머의 성능을 정량적으로 요약하여 비교한 것이다.

| 모델            | 레이어 수 | 시퀀스 길이 | 성능 (bpd)                | 속도 (vs. Transformer)     | 메모리 복잡도 (활성화 + 어텐션) |
| --------------- | --------- | ----------- | ------------------------- | -------------------------- | ------------------------------- |
| 표준 트랜스포머 | 6         | 2048        | ~1.15                     | 1x                         | $O(L^2 + N \cdot L)$            |
| **리포머**      | 12        | 65,536      | 1.05                      | **훨씬 빠름** (L이 클수록) | $O(L \log L + L)$               |
| 표준 트랜스포머 | N/A       | > 4096      | 훈련 불가 (Out of Memory) | N/A                        | N/A                             |

이러한 성능 평가는 리포머가 긴 문서를 조각내지 않고 전체로 처리할 수 있는 능력을 갖추었음을 의미한다. 이는 모델이 이전의 청크 기반 접근법으로는 결코 학습할 수 없었던 질적으로 다른 종류의 장거리 의존성(예: 소설 속 인물의 전체 서사 아크, 긴 논문의 논리적 흐름)을 포착할 수 있는 가능성을 연다. 따라서 리포머의 진정한 가치는 기존 벤치마크에서의 양적 개선을 넘어, 장문 데이터에 대한 새로운 차원의 추론과 이해를 가능하게 하는 데 있을 수 있다.


리포머는 트랜스포머 아키텍처의 실용적 한계를 극복하려는 노력의 중요한 이정표로서, 후속 연구와 현재의 대규모 언어 모델(LLM) 개발에 깊은 영향을 미쳤다.


의의: 리포머의 가장 큰 의의는 LSH 어텐션과 가역 레이어라는 두 가지 강력하고 독창적인 아이디어를 성공적으로 결합하여, 트랜스포머를 장거리 시퀀스 영역으로 이끈 선구적인 연구라는 점에 있다.1 이는 모델의 확장성과 접근성을 크게 향상시켰으며, 트랜스포머의 계산 효율성에 대한 학계와 산업계의 광범위한 연구를 촉발하는 기폭제가 되었다.14 리포머가 제시한 문제 해결 방식은 이후 등장하는 수많은 효율적 트랜스포머 변종들의 이론적 기반과 영감의 원천이 되었다.

한계: 그럼에도 불구하고 리포머는 몇 가지 내재적인 한계를 가지고 있다.

- **근사의 한계:** LSH는 확률적 근사 기법이므로, 이론적으로는 드물지만 의미적으로 매우 중요한 장거리 토큰 쌍이 서로 다른 버킷에 할당되어 어텐션 계산에서 누락될 수 있는 가능성이 존재한다. 이는 매우 정밀한 토큰 간 상호작용이 요구되는 태스크에서 성능 저하의 원인이 될 수 있다.29
- **짧은 시퀀스에서의 비효율성:** 앞서 분석했듯이, LSH의 해싱 및 정렬 연산에 따르는 오버헤드로 인해 짧은 시퀀스에서는 풀 어텐션보다 느릴 수 있다. 이로 인해 리포머는 범용적인 트랜스포머 대체재라기보다는 장거리 시퀀스에 특화된 모델로 자리매김하게 되었다.26
- **구현 복잡성:** 표준 트랜스포머에 비해 정렬, 청킹, 가역 블록의 역연산 등 추가적인 로직이 필요하여 구현이 상대적으로 복잡하고 최적화가 어렵다는 단점이 있다.27


리포머의 등장을 전후하여, 다양한 철학을 바탕으로 $O(L^2)$ 복잡도 문제를 해결하려는 여러 효율적 트랜스포머 모델들이 제안되었다. 이들과의 비교를 통해 리포머의 기술적 위치와 장단점을 더욱 명확히 파악할 수 있다.14

다음 표는 리포머와 다른 주요 효율적 트랜스포머 모델들을 핵심 아이디어, 복잡도, 장단점 측면에서 비교한 것이다.

| 모델              | 핵심 아이디어                                | 복잡도        | 장점                                               | 단점                                                         |
| ----------------- | -------------------------------------------- | ------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **Reformer**      | LSH 기반 어텐션 근사, 가역 레이어            | $O(L \log L)$ | 매우 긴 시퀀스 처리 가능, 메모리 효율 극대화       | 확률적 근사, 짧은 시퀀스에서 비효율적                        |
| **Longformer** 11 | 슬라이딩 윈도우(지역) + 전역(Global) 어텐션  | $O(L)$        | 구현이 직관적이고 많은 NLP 태스크에 효과적         | 전역 어텐션 토큰을 수동으로 지정해야 함, 모든 토큰 쌍을 고려하지 않음 |
| **Linformer** 26  | 어텐션 행렬의 저계급(Low-rank) 근사          | $O(L)$        | 이론적으로 견고하며, 짧은 시퀀스에서도 효율적      | 저계급 가정이 모든 태스크에 유효하지 않을 수 있음            |
| **Performer** 33  | 커널(Kernel)을 통한 소프트맥스 근사 (FAVOR+) | $O(L)$        | 강력한 이론적 보장, 풀 어텐션을 정확하게 근사 가능 | 근사를 위한 무작위 특징(random features)의 품질에 의존       |

이 비교는 각 모델이 서로 다른 가정과 트레이드오프 위에서 효율성을 달성하고 있음을 보여준다. Longformer는 지역적 문맥의 중요성을 가정하고, Linformer는 어텐션 행렬의 정보량이 저계급 공간에 압축될 수 있다고 가정한다. Performer는 커널 트릭을 통해 수학적으로 풀 어텐션을 근사하려 시도한다. 반면 리포머는 LSH를 통해 '유사한 토큰은 서로 어텐션해야 한다'는 보다 일반적인 원칙에 기반하여 확률적으로 계산을 줄인다. 이러한 다양한 접근법들은 트랜스포머 효율화라는 공동의 목표를 향한 풍부한 연구 생태계를 형성하였다.


리포머와 같은 초기 효율적 트랜스포머들이 제시한 아이디어들은 현대 AI 기술의 발전에 지대한 공헌을 했다. LSH 어텐션의 근사적 접근, 가역 레이어의 메모리-계산 트레이드오프, 그리고 다양한 희소화 및 저계급 근사 기법들은 오늘날의 대규모 언어 모델(LLM)을 가능하게 한 기반 기술들에 직간접적으로 흡수되거나 영감을 주었다. 예를 들어, 현대 LLM의 핵심 최적화 기법인 FlashAttention은 단순히 계산 복잡도를 줄이는 것을 넘어, GPU의 메모리 계층 구조(SRAM, HBM)에 대한 깊은 이해를 바탕으로 I/O를 최소화하여 실제 처리 속도를 극대화하는데, 이는 리포머가 추구했던 시스템 수준의 최적화 철학과 맥을 같이 한다.

미래의 효율적 어텐션 연구는 단순한 점근적 복잡도 감소를 넘어, 실제 하드웨어 아키텍처에 최적화된 연산을 설계하는 방향, 데이터의 특성에 따라 동적으로 희소성 패턴을 학습하는 방향, 그리고 양자화 및 하드웨어 가속기와 결합하는 방향으로 더욱 정교하게 발전할 것이다.

결론적으로, 리포머는 트랜스포머 아키텍처의 실용적 한계를 극복하고 그 적용 범위를 획기적으로 넓힌 중요한 학문적 성취이다. 이는 모델의 성능과 효율성 사이의 균형을 맞추는 것이 AI 연구의 핵심 과제임을 명확히 하였으며, 이후 지속 가능한 고성능 AI 시스템을 구축하려는 현대 연구의 중요한 흐름을 형성하는 데 결정적인 기여를 했다. 리포머는 단순한 하나의 모델을 넘어, 효율적 딥러닝이라는 거대한 담론을 이끈 이정표로 기억될 것이다.


1. Reformer: The Efficient Transformer | OpenReview, 8월 16, 2025에 액세스, https://openreview.net/forum?id=rkgNKkHtvB
2. Reformer: The Efficient Transformer - ResearchGate, 8월 16, 2025에 액세스, https://www.researchgate.net/publication/338569863_Reformer_The_Efficient_Transformer
3. Attention Is All You Need - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Attention_Is_All_You_Need
4. Transformer (deep learning architecture) - Wikipedia, 8월 16, 2025에 액세스, https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)
5. Reformer: The Efficient Transformer, 8월 16, 2025에 액세스, https://arxiv.org/pdf/2001.04451
6. SELF-ATTENTION DOES NOT NEED O(n2) MEMORY - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/pdf/2112.05682
7. On The Computational Complexity of Self-Attention - Proceedings of Machine Learning Research, 8월 16, 2025에 액세스, https://proceedings.mlr.press/v201/duman-keles23a/duman-keles23a.pdf
8. Why does attention need to be fully quadratic? : r/LocalLLaMA - Reddit, 8월 16, 2025에 액세스, https://www.reddit.com/r/LocalLLaMA/comments/150owmj/why_does_attention_need_to_be_fully_quadratic/
9. REFORMER: THE EFFICIENT TRANSFORMER - OpenReview, 8월 16, 2025에 액세스, https://openreview.net/pdf?id=xW4kmYrORTE
10. Reformer: The Efficient Transformer - Google Research, 8월 16, 2025에 액세스, https://research.google/blog/reformer-the-efficient-transformer/
11. [2004.05150] Longformer: The Long-Document Transformer, 8월 16, 2025에 액세스, https://ar5iv.labs.arxiv.org/html/2004.05150
12. Reformer: The Efficient Transformer | reformer-fastai – Weights & Biases - Wandb, 8월 16, 2025에 액세스, https://wandb.ai/fastai_community/reformer-fastai/reports/Reformer-The-Efficient-Transformer--Vmlldzo0MzQ1OTg
13. [2406.16893] A Survey on Transformers in NLP with Focus on Efficiency - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2406.16893
14. [2009.06732] Efficient Transformers: A Survey - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2009.06732
15. [2001.04451] Reformer: The Efficient Transformer - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2001.04451
16. Reformer: The Efficient Transformer - BibSonomy, 8월 16, 2025에 액세스, https://www.bibsonomy.org/bibtex/2afcb7d1d8971f1dc55e2816c8b3235e6/stdiff
17. Locality Sensitive Hashing - Jake Tae, 8월 16, 2025에 액세스, https://jaketae.github.io/study/lsh/
18. Locality-Sensitive Hashing (LSH) - CelerData, 8월 16, 2025에 액세스, https://celerdata.com/glossary/locality-sensitive-hashing-lsh
19. Locality Sensitive Hashing (LSH): The Illustrated Guide - Pinecone, 8월 16, 2025에 액세스, https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/
20. Understanding Locality Sensitive Hashing(LSH): A Powerful Technique for Similarity Search. | by Sarthak Joshi | Medium, 8월 16, 2025에 액세스, https://medium.com/@sarthakjoshi_9398/understanding-locality-sensitive-hashing-lsh-a-powerful-technique-for-similarity-search-a95b090bdc4a
21. The Reversible Residual Network: Backpropagation Without ... - NIPS, 8월 16, 2025에 액세스, http://papers.neurips.cc/paper/6816-the-reversible-residual-network-backpropagation-without-storing-activations.pdf
22. Building Reversible Residual Networks for Memory-Efficient Backprop, 8월 16, 2025에 액세스, https://dev.co/ai/reversible-residual-networks
23. Unlocking GPU Efficiency: Reversible Residual Networks Explained - OpenCV.ai, 8월 16, 2025에 액세스, https://www.opencv.ai/blog/train-neural-network-reversible-residual-networks
24. Review - The Reversible Residual Network: Backpropagation Without Storing Activations, 8월 16, 2025에 액세스, https://sh-tsang.medium.com/review-the-reversible-residual-network-backpropagation-without-storing-activations-526e6d5c60f4
25. The Reversible Residual Network: Backpropagation Without Storing Activations, 8월 16, 2025에 액세스, https://ameroyer.github.io/architectures/the_reversible_residual_network/
26. Linformer: Self-Attention with Linear Complexity, 8월 16, 2025에 액세스, https://arxiv.org/pdf/2006.04768
27. Reproducibility Challenge 2020 - fastai folks interested - #48 by morgan - Deep Learning, 8월 16, 2025에 액세스, https://forums.fast.ai/t/reproducibility-challenge-2020-fastai-folks-interested/80336/48
28. REFORMER: THE EFFICIENT TRANSFORMER - YouTube, 8월 16, 2025에 액세스, https://www.youtube.com/watch?v=F9UEIukzKG8
29. Day:30 Reformer: Efficient Transformer for Large Scale Models - DEV Community, 8월 16, 2025에 액세스, https://dev.to/nareshnishad/day30-reformer-efficient-transformer-for-large-scale-models-3fh9
30. A Practical Survey on Faster and Lighter Transformers - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/pdf/2103.14636
31. Paper page - Longformer: The Long-Document Transformer - Hugging Face, 8월 16, 2025에 액세스, https://huggingface.co/papers/2004.05150
32. Linformer: Self-Attention with Linear Complexity - BibSonomy, 8월 16, 2025에 액세스, https://www.bibsonomy.org/bibtex/4413c1dbf74e4224b819965aca6a77b9
33. [D] Paper Explained - Rethinking Attention with Performers (Full Video Analysis) - Reddit, 8월 16, 2025에 액세스, https://www.reddit.com/r/MachineLearning/comments/jiich1/d_paper_explained_rethinking_attention_with/
34. [2009.14794] Rethinking Attention with Performers - ar5iv - arXiv, 8월 16, 2025에 액세스, https://ar5iv.labs.arxiv.org/html/2009.14794

