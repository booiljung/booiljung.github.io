# LV-XAttn (Long Visual 분산 교차-어텐션)

## I. 서론: 멀티모달 AI와 긴 시퀀스 처리의 장벽

### 0.1  멀티모달 대규모 언어 모델(MLLM)의 부상과 새로운 과제

인공지능 연구의 패러다임은 대규모 언어 모델(Large Language Models, LLMs)의 등장을 기점으로 근본적인 변화를 맞이했다. LLM이 보여준 탁월한 언어 이해 및 생성 능력은 이제 텍스트의 영역을 넘어, 시각, 청각 등 인간의 감각과 유사한 다중 모달리티(Multi-modality)를 포괄하는 방향으로 확장되고 있다. 이러한 흐름의 중심에 멀티모달 대규모 언어 모델(Multimodal Large Language Models, MLLMs)이 자리 잡고 있으며, 이는 AI가 세상을 보다 총체적으로 이해하고 상호작용하기 위한 핵심적인 기술로 부상했다.1

초기 MLLM은 주로 정적인 단일 이미지에 대한 질의응답이나 캡션 생성을 목표로 했다. 그러나 기술이 성숙함에 따라, 이제는 장시간 비디오의 내용을 요약하고 특정 장면을 질의하는 비디오 이해(Video Understanding), 수백 장의 의료 영상 이미지를 분석하여 진단을 보조하는 대규모 이미지 세트 분석 등 훨씬 더 복잡하고 긴 시각적 시퀀스(Long Visual Sequence)를 처리해야 하는 고차원적인 과제에 직면하게 되었다.3

이러한 고차원적 과제를 해결하기 위해 다양한 MLLM 아키텍처가 제안되었으며, 그중에서도 교차-어텐션(Cross-Attention) 메커니즘을 활용하는 방식은 시각 정보와 언어 정보를 융합하는 강력하고 효과적인 접근법으로 인정받고 있다. Flamingo, mPLUG-Owl3, Llama 3-V와 같은 선도적인 모델들은 시각 인코더(Vision Encoder)가 추출한 시각적 특징(Visual Features)을 언어 모델의 중간 레이어에 주입하는 방식으로 교차-어텐션을 활용한다.5 이 구조에서 언어 모델의 은닉 상태(Hidden States)는 쿼리(Query, Q) 역할을 수행하며, 시각적 특징은 키(Key, K)와 값(Value, V)으로 변환되어 언어 모델이 '참조'해야 할 시각적 맥락을 제공한다. 이 방식은 두 모달리티 간의 세밀하고 동적인 상호작용을 가능하게 하여 뛰어난 성능을 보인다.

### 0.2  교차-어텐션의 병목: 메모리와 통신

그러나 교차-어텐션 기반 아키텍처의 강력한 성능은 긴 시각적 시퀀스를 처리할 때 심각한 기술적 병목 현상이라는 대가를 치른다. 이 문제의 근원은 트랜스포머 아키텍처의 핵심인 어텐션 메커니즘의 본질적인 계산 특성에 있다. 표준 어텐션 연산의 계산량과 메모리 요구량은 입력 시퀀스 길이의 제곱에 비례하여, 즉 시간 및 공간 복잡도가 $O(N^2)$로 증가한다.7

MLLM의 교차-어텐션에서는 이 문제가 더욱 극적으로 증폭된다. 텍스트에서 파생되는 쿼리(Q) 토큰의 시퀀스 길이($S_Q$)는 일반적으로 수천 개 수준으로 제한되는 반면, 비디오의 모든 프레임이나 고해상도 이미지의 패치에서 추출되는 키(K)와 값(V) 토큰의 시퀀스 길이($S_{KV}$)는 수십만, 심지어 수백만 개에 이를 수 있기 때문이다.1 예를 들어, 1fps로 샘플링된 20분 길이의 비디오는 1200개의 프레임을 가지며, 각 프레임이 수백 개의 시각 토큰으로 변환될 경우 $S_{KV}$는 수십만 단위에 이르게 된다.

이러한 극심한 비대칭성($S_{KV} \gg S_Q$)은 어텐션 스코어 행렬($S_Q \times S_{KV}$)과 중간 활성화 값(K, V 텐서)의 크기를 폭발적으로 증가시킨다. Llama 3-V 모델을 예로 들면, 20분 길이의 비디오와 2048 토큰 길이의 텍스트를 처리하는 단일 교차-어텐션 레이어는 메모리 효율적인 FlashAttention 구현을 사용하더라도 234 GB 이상의 GPU 메모리를 요구한다.6 이는 현존하는 가장 큰 단일 GPU의 메모리 용량을 아득히 초과하는 수치이며, 따라서 긴 시각적 시퀀스를 처리하기 위해서는 다수의 GPU를 활용한 분산 컴퓨팅(Distributed Computing)이 선택이 아닌 필수가 된다.9

### 0.3  분산 환경의 새로운 장벽: 통신 오버헤드

다중 GPU를 활용하여 메모리 용량의 한계를 극복하려는 시도는 필연적으로 또 다른 거대한 장벽, 즉 통신 오버헤드(Communication Overhead)를 마주하게 된다. 어텐션 메커니즘은 본질적으로 '전역적(global)' 연산이다. 즉, 하나의 쿼리 토큰은 모든 키 토큰과 상호작용하여 어텐션 가중치를 계산해야 한다. 시퀀스를 여러 GPU에 분산(sharding)시킨 환경에서 이를 구현하려면, 각 GPU는 자신이 가지고 있지 않은 다른 GPU의 키와 값 텐서 조각들을 네트워크를 통해 전송받아야만 한다.

기존의 대표적인 분산 어텐션 기법인 Ring Attention은 이러한 데이터 교환을 위해 각 GPU가 거대한 K, V 텐서 블록을 링(ring) 위상으로 이웃 GPU에게 순차적으로 전달하는 방식을 사용한다.8 그러나 MLLM의 교차-어텐션에서는 바로 이 K, V 텐서가 엄청난 크기를 가지기 때문에, GPU 간 통신량이 폭발적으로 증가하여 심각한 통신 병목을 유발한다. 결과적으로, 강력한 연산 능력을 갖춘 GPU 코어들은 대부분의 시간을 데이터가 도착하기를 기다리며 유휴 상태(idle)로 보내게 되고, 이는 분산 처리의 이점을 심각하게 저해하며 전체 시스템의 처리 속도를 현저히 떨어뜨린다.6

이처럼 긴 시각적 시퀀스 처리는 메모리 용량의 한계와 분산 환경에서의 통신 병목이라는 이중고에 직면해 있다. 이는 단순히 더 많은 GPU를 투입하는 것만으로는 해결할 수 없는 근본적인 시스템 수준의 문제이다. 문제의 본질은 알고리즘의 계산 복잡도뿐만 아니라, 현대 AI 시스템에서 데이터 이동(data movement)이 성능을 좌우하는 핵심 요소가 되었음을 시사한다. 즉, 연산 최적화를 넘어 데이터의 물류(logistics)를 어떻게 효율적으로 관리할 것인가가 관건이 된 것이다.

본 보고서는 이러한 다중적 병목 현상을 정면으로 돌파하기 위해 제안된 LV-XAttn(Long Visual inputs Cross-Attention)에 대한 심층적인 분석을 제공하는 것을 목표로 한다. LV-XAttn은 기존의 접근법을 답습하는 대신, 문제의 근원인 데이터의 비대칭성에 주목하여 통신 패러다임을 근본적으로 전환시킨다. 본 보고서는 LV-XAttn의 핵심 원리, 아키텍처, 수학적 기반을 상세히 해부하고, 객관적인 성능 평가 결과를 분석하며, 나아가 기술적 한계와 향후 연구 방향까지 포괄적으로 고찰할 것이다.

## 1. II. 기존 분산 어텐션 메커니즘의 원리와 한계

긴 시퀀스 트랜스포머 모델의 학습 및 추론을 가능하게 하기 위해 다양한 병렬화 기법이 연구되어 왔다. 그러나 각 기법은 서로 다른 측면을 최적화하기에, 긴 시퀀스로 인해 발생하는 메모리 문제를 해결하는 데에는 저마다의 한계를 가진다. LV-XAttn의 혁신성을 이해하기 위해서는 먼저 기존 분산 어텐션, 특히 시퀀스 병렬 처리가 어떻게 작동하며 어떤 근본적인 문제에 직면했는지 살펴볼 필요가 있다.

### 1.1  시퀀스 병렬 처리(Sequence Parallelism)의 개념

대규모 모델 병렬화에는 주로 데이터 병렬 처리(Data Parallelism), 텐서 병렬 처리(Tensor Parallelism), 파이프라인 병렬 처리(Pipeline Parallelism)가 사용된다. 데이터 병렬 처리는 모델 전체를 각 GPU에 복제하고 데이터 배치를 나누어 처리하는 방식으로, 모델 자체의 메모리 요구량을 줄이지는 못한다. 텐서 병렬 처리는 모델의 가중치 행렬 자체를 분할하여 여러 GPU에 나누지만, 각 GPU는 여전히 전체 시퀀스에 대한 활성화 값을 저장해야 하므로 긴 시퀀스의 메모리 문제를 해결할 수 없다. 파이프라인 병렬 처리는 모델의 레이어를 여러 GPU에 나누어 배치하지만, 마찬가지로 단일 레이어 내에서 발생하는 메모리 병목은 해결하지 못한다.

이러한 한계를 극복하기 위해 등장한 것이 바로 시퀀스 병렬 처리(Sequence Parallelism, SP)이다.8 시퀀스 병렬 처리의 핵심 아이디어는 모델이나 가중치가 아닌, 입력 시퀀스 자체를 분할하는 것이다. 예를 들어, 길이가 128k인 시퀀스를 8개의 GPU를 사용하여 처리한다면, 각 GPU는 16k 길이의 시퀀스 조각(shard)만을 담당하게 된다. 이를 통해 각 GPU가 저장해야 하는 활성화 값의 크기를 $1/P$ ($P$는 GPU 수)로 줄일 수 있어, 이론적으로는 GPU 수에 비례하여 처리 가능한 시퀀스 길이를 늘릴 수 있다. 따라서 시퀀스 병렬 처리는 긴 컨텍스트를 처리하기 위한 가장 직접적이고 필수적인 전략으로 간주된다.

### 1.2  Ring Attention 심층 분석

시퀀스 병렬 처리를 구현하는 가장 대표적인 알고리즘이 바로 Ring Attention이다.8 Ring Attention은 시퀀스를 분할하면서도 수학적으로는 분할하지 않은 것과 동일한, 즉 정확한(exact) 어텐션 결과를 계산하는 것을 목표로 한다. 그 작동 원리는 다음과 같은 단계로 이루어진다.

1. **분할 및 초기화 (Sharding & Initialization):** 전체 입력 시퀀스에서 파생된 Q, K, V 텐서를 시퀀스 차원을 따라 $P$개의 블록으로 분할한다. 각 GPU $p$는 $Q_p, K_p, V_p$ 블록을 로컬 메모리에 보유한다.
2. **순방향 통신 및 계산 (Forward Pass):**
   - **스텝 0:** 각 GPU $p$는 자신의 로컬 블록인 $Q_p$와 $K_p$를 사용하여 부분 스코어 행렬 $S_{p,p} = Q_p K_p^T$를 계산한다.
   - **스텝 1 ~ P-1:** 링 통신이 시작된다. 각 GPU $p$는 자신의 $K_p, V_p$ 블록을 링 상의 다음 GPU $(p+1) \pmod P$로 전송한다. 동시에 이전 GPU $(p-1) \pmod P$로부터 $K_{(p-1) \pmod P}, V_{(p-1) \pmod P}$ 블록을 수신한다. 수신한 키 블록을 사용하여 추가적인 부분 스코어 행렬 $S_{p, (p-1) \pmod P} = Q_p K_{(p-1) \pmod P}^T$를 계산하고 누적한다.
   - 이 과정을 $P-1$번 반복한다. 모든 반복이 끝나면 각 GPU $p$는 모든 다른 GPU의 키 블록($K_0,..., K_{P-1}$)을 한 번씩 수신하여 전체 스코어 행렬의 일부($Q_p$에 해당하는 행)를 완성하게 된다.
   - 이후 각 GPU는 로컬에서 Softmax를 계산하고, 다시 링 통신을 통해 V 블록을 순환시키며 가중 합을 계산하여 최종 출력의 일부($O_p$)를 얻는다.
3. **역방향 통신 및 계산 (Backward Pass):** 역전파 과정에서도 순방향과 유사한 링 통신 패턴을 사용하여 그래디언트를 계산하고 전파한다.

이처럼 Ring Attention은 영리한 통신 스케줄링을 통해 모든 쿼리가 모든 키와 상호작용하도록 보장하여 정확한 어텐션을 분산 환경에서 구현한다.

### 1.3  기존 방식의 근본적 한계

Ring Attention의 설계는 그 자체로 완결성이 있지만, MLLM의 교차-어텐션이라는 특정 응용 분야에 적용될 때 치명적인 비효율성을 드러낸다. 그 한계는 다음 두 가지로 요약할 수 있다.

첫째, **데이터 비대칭성에 대한 무지(Agnosticism to Data Asymmetry)**이다. Ring Attention의 알고리즘은 Q, K, V 텐서의 크기가 비슷하다고 암묵적으로 가정한다. 이는 모든 토큰이 서로에게 쿼리, 키, 값이 되는 셀프-어텐션(Self-Attention)의 경우에는 합리적인 가정이다. 그러나 MLLM의 교차-어텐션에서는 $S_{KV} \gg S_Q$라는 극심한 비대칭성이 존재한다. Ring Attention은 이러한 구조적 특성을 전혀 활용하지 않고, 셀프-어텐션의 분산 방식을 그대로 적용하여 거대한 K와 V 텐서를 GPU 간에 무심하게 전송한다. 이는 마치 아주 작은 화물(Q)을 옮기기 위해 거대한 트럭(K, V) 전체를 도시 곳곳으로 보내는 것과 같은 비효율을 야기한다.

둘째, **통신 병목의 심화(Exacerbation of Communication Bottleneck)**이다. 앞서 언급한 비효율은 곧바로 극심한 통신 병목으로 이어진다. Ring Attention의 총 통신량은 대략 $O(S_{KV} \cdot d)$에 비례한다.6 긴 비디오를 처리할 때 $S_{KV}$가 수십만에 이르면, 매 어텐션 레이어의 매 반복마다 수십~수백 기가바이트의 데이터가 GPU 간 네트워크를 통해 전송되어야 한다. 현대의 GPU 상호연결 기술(예: NVLink)이 아무리 빠르다 하더라도, 이 정도 규모의 데이터 전송은 GPU의 연산 속도를 따라잡을 수 없다. 결국, 전체 시스템의 성능은 가장 느린 구성 요소인 네트워크 통신 속도에 의해 제약을 받게 되며, GPU는 대부분의 시간을 데이터 전송이 완료되기를 기다리며 낭비하게 된다.8

결론적으로, Ring Attention과 같은 기존의 시퀀스 병렬 처리 기법들은 '어떻게 분산시킬 것인가'에 대한 해답은 제시했지만, '무엇을 통신할 것인가'에 대한 최적화에는 실패했다. 이는 특정 문제 영역(MLLM 교차-어텐션)의 고유한 데이터 구조를 고려하지 않은 범용적인(one-size-fits-all) 분산 전략의 명백한 한계를 보여준다. 이러한 배경 속에서, 통신의 대상을 근본적으로 재정의하려는 시도, 즉 LV-XAttn의 등장은 필연적이었다.

## 2. III. LV-XAttn: 비대칭적 데이터 교환을 통한 패러다임 전환

기존 분산 어텐션 메커니즘이 직면한 통신 병목의 근본 원인은 문제의 구조적 특성을 간과했다는 점에 있다. LV-XAttn은 바로 이 지점에서 출발하여, MLLM 교차-어텐션의 고유한 데이터 비대칭성을 시스템 최적화의 핵심 기회로 전환시키는 혁신적인 접근법을 제시한다.

### 2.1  핵심 관찰: 쿼리(Query)와 키-값(Key-Value)의 비대칭성

LV-XAttn의 모든 설계는 단 하나의 강력하고 명료한 관찰에 기반한다: **멀티모달 대규모 언어 모델의 교차-어텐션에서, 시각 정보로부터 파생되는 키(Key)와 값(Value) 텐서는 텍스트 정보로부터 파생되는 쿼리(Query) 텐서보다 압도적으로 크다**.1

이 비대칭성은 각 텐서의 근원이 되는 데이터의 특성에서 비롯된다.

- **쿼리 (Query, Q):** 언어 모델의 내부 상태로부터 생성된다. 일반적으로 LLM이 처리하는 텍스트 시퀀스의 길이는 수천 토큰($S_Q \approx 10^3$) 단위이다. 예를 들어, 일반적인 프롬프트는 2048 또는 4096 토큰 길이를 갖는다.
- **키-값 (Key-Value, K/V):** 시각 인코더를 통과한 시각 정보로부터 생성된다. 예를 들어, 20분 길이의 비디오를 초당 1프레임(1fps)으로 샘플링하면 1200개의 프레임이 생성된다. 각 프레임이 ViT(Vision Transformer)와 같은 인코더를 통해 256개의 시각 토큰으로 변환된다고 가정하면, 총 시각 토큰의 수, 즉 $S_{KV}$는 $1200 \times 256 = 307,200$에 달한다.

이 경우, 시각 시퀀스의 길이 $S_{KV}$는 텍스트 시퀀스 길이 $S_Q$보다 100배 이상 길다. 텐서의 전체 크기는 시퀀스 길이에 비례하므로, K와 V 텐서의 메모리 점유량 역시 Q 텐서보다 수백, 수천 배 더 커지게 된다. 실제로 Video-MME 벤치마크 데이터셋의 한 예시에서는 K/V 텐서의 크기가 Q 텐서의 약 2500배에 달하는 것으로 분석되었다.6 기존의 Ring Attention은 바로 이 거대한 K/V 텐서를 GPU 간에 통신시키는 우를 범하고 있었던 것이다.

### 2.2  새로운 통신 전략: K/V 지역화와 Q 순환

LV-XAttn은 이러한 극심한 데이터 비대칭성을 문제점이 아닌 해결의 실마리로 삼아, 데이터 교환의 패러다임을 180도 전환한다. 그 전략은 '무거운 것은 묶어두고, 가벼운 것만 움직인다'는 단순하고 강력한 원칙으로 요약할 수 있다.

- **K/V 지역화 (Key-Value Localization):** 가장 큰 데이터 덩어리인 K와 V 텐서는 시퀀스 차원에서 분할되어 각 GPU에 영구적으로 상주한다. 즉, 각 GPU는 전체 K, V 텐서의 일부를 '소유'하며, 이 데이터는 학습 또는 추론 과정 동안 해당 GPU의 로컬 메모리 밖으로 절대 나가지 않는다. 이를 통해 가장 비용이 많이 드는 데이터 전송을 원천적으로 차단한다.9
- **Q 순환 (Query Circulation):** 반면, 크기가 훨씬 작은 Q 텐서만을 GPU들 사이에서 링(ring) 형태로 순환시킨다. 각 GPU는 순차적으로 모든 Q 텐서 블록을 전달받아, 자신이 소유한 K/V 블록과 어텐션 연산을 수행한다. 이 방식은 통신해야 할 데이터의 총량을 극적으로 감소시킨다.11

이러한 비대칭적 통신 전략은 GPU 간 통신량을 기존 Ring Attention의 $O(S_{KV} \cdot d)$에서 $O(S_Q \cdot d)$ 수준으로 획기적으로 줄인다. 앞서 언급된 Video-MME 예시에서, 이 전략은 총 통신량을 Ring Attention 방식의 **0.04%** 수준으로 감소시키는 놀라운 결과를 가져왔다.6 이는 단순히 점진적인 개선이 아닌, 통신 병목의 규모를 질적으로 변화시키는 패러다임의 전환이라 할 수 있다.

이러한 접근법은 분산 컴퓨팅 분야의 고전적인 최적화 원리인 '데이터를 연산으로 가져오는(data-passing)' 방식에서 '연산을 데이터가 있는 곳으로 보내는(function-shipping)' 방식으로의 전환과 맥을 같이 한다. Ring Attention은 거대한 K/V 데이터를 각 GPU의 Q 연산 코어로 가져오는 데이터-패싱 모델이다. 반면, LV-XAttn은 어텐션 연산을 수행하라는 '명령' 또는 '함수'에 해당하는 작은 Q를 분산된 K/V 데이터가 저장된 곳으로 보내는 함수-쉬핑 모델로 볼 수 있다. 이는 분산 데이터베이스 시스템에서 쿼리 최적화를 위해 오랫동안 사용되어 온 원리를 AI 시스템에 성공적으로 적용한 사례로, 서로 다른 컴퓨터 과학 분야 간의 아이디어 융합이 혁신을 이끌어낼 수 있음을 보여준다.

### 2.3  통신-계산 중첩(Communication-Computation Overlap)

LV-XAttn의 통신량 감소는 그 자체로도 의미가 크지만, 그 진정한 위력은 '통신-계산 중첩'을 통해 발현된다. 통신-계산 중첩이란, 네트워크를 통해 데이터를 전송하는 시간 동안 GPU의 연산 유닛이 다른 계산 작업을 수행하도록 하여, 통신으로 인한 유휴 시간을 최소화하는 기술이다.

Ring Attention에서는 전송해야 할 K/V 데이터의 양이 너무 커서 통신 시간이 계산 시간을 압도하므로, 효과적인 중첩이 거의 불가능했다. 그러나 LV-XAttn에서는 전송되는 Q 데이터의 양이 매우 작아졌기 때문에, Q를 다음 GPU로 전송하는 데 걸리는 시간이 현재 GPU에서 수신한 Q와 로컬 K/V로 어텐션을 계산하는 시간보다 훨씬 짧아진다. 이로 인해 통신 과정을 계산 과정 뒤에 완벽하게 숨기는(overlap) 것이 가능해진다.

그 결과, 분산 교차-어텐션 연산은 마치 통신이 전혀 없는 환경에서 수행되는 것처럼, 즉 이론적인 '무통신(no-communication)' 기준선에 매우 근접한 성능을 달성할 수 있게 된다. 실제로 LV-XAttn 논문에서는 통신-계산 중첩을 통해 무통신 기준선 대비 불과 0.42%의 오버헤드만을 발생시켰다고 보고했다.6 이는 분산 시스템에서 달성할 수 있는 거의 이상적인 성능에 해당하며, LV-XAttn이 단순한 통신량 감소를 넘어 시스템 전체의 효율을 극대화하는 정교한 설계임을 입증한다.

## 3. IV. LV-XAttn의 아키텍처 및 알고리즘 심층 분석

LV-XAttn의 핵심 아이디어는 비대칭적 데이터 교환이지만, 이를 실제로 구현하기 위해서는 순방향 및 역방향 전파 과정에서의 정교한 알고리즘 설계와 추가적인 메모리 최적화 기법이 요구된다. 이 장에서는 LV-XAttn의 구체적인 작동 방식과 구현 세부사항을 심층적으로 분석한다.

### 3.1  분산 교차-어텐션 알고리즘 (Forward & Backward Pass)

LV-XAttn은 시퀀스 병렬 처리를 기반으로 하되, 통신의 대상을 Q로 한정하여 블록-단위(block-wise)로 어텐션을 계산한다. $P$개의 GPU가 참여하는 분산 환경을 가정하고 알고리즘을 단계별로 살펴보자.

#### 3.1.1 순방향 전파 (Forward Pass)

1. **초기 상태 (Initialization):** 전체 K, V 텐서는 시퀀스 차원을 따라 $P$개의 블록으로 분할된다. 각 GPU $p$ ($p \in \{0,..., P-1\}$)는 $p$번째 블록인 $K_p$와 $V_p$를 자신의 로컬 HBM(High Bandwidth Memory)에 고정적으로 저장한다. 또한, 각 GPU $p$는 자신의 쿼리 블록 $Q_p$를 계산하여 보유한다.

2. **링 순환 및 로컬 계산 (Ring Circulation & Local Computation):** 순방향 전파는 총 $P$개의 스텝으로 구성된다.

   - **스텝 0:** 통신 없이, 각 GPU $p$는 자신의 로컬 쿼리 블록 $Q_p$와 로컬 키 블록 $K_p$를 사용하여 부분 어텐션 스코어를 계산한다. 이 계산은 I/O 병목을 최소화하도록 설계된 FlashAttention 커널을 활용하여 효율적으로 수행된다.1 이 과정에서 안정적인 Softmax 계산을 위해 온라인 방식을 사용하여 로컬 최댓값(local max)과 로컬 합계(local sum) 같은 통계량을 계산하고, 이를 바탕으로 부분 어텐션 출력(

     $O_{p, \text{local}}$)을 계산하여 누적한다.

   - **스텝 1 ~ P-1:** 링 통신이 시작된다. 각 스텝 $s$에서, 모든 GPU $p$는 현재 자신이 보유한 쿼리 블록을 링 상의 다음 GPU $(p+1) \pmod P$로 전송한다. 동시에, 이전 GPU $(p-1) \pmod P$로부터 새로운 쿼리 블록을 수신한다.

   - 새로운 쿼리 블록을 수신한 각 GPU $p$는 이 쿼리 블록과 자신의 고정된 로컬 키-값 블록($K_p, V_p$)을 사용하여 다시 부분 어텐션 스코어와 출력을 계산한다. 계산된 결과는 이전 스텝의 결과에 온라인 Softmax 방식으로 안전하게 누적된다.

3. **결과 취합 및 최종 출력 (Aggregation & Final Output):** $P-1$번의 통신 및 계산 스텝이 완료되면, 각 GPU $p$는 자신의 쿼리 블록 $Q_p$가 모든 키 블록($K_0,..., K_{P-1}$)과 상호작용을 마친 상태가 된다. 각 GPU는 누적된 부분 출력들과 전역 Softmax 통계량을 사용하여 최종 어텐션 출력 블록 $O_p$를 완성한다.

#### 3.1.2 역방향 전파 (Backward Pass)

역방향 전파 과정은 순방향 전파와 유사한 통신 패턴을 따르지만, 데이터의 흐름과 계산 내용이 다르다.

1. **초기 상태:** 각 GPU $p$는 최종 출력에 대한 그래디언트 블록 $dO_p$를 가지고 있다.
2. **링 순환 및 그래디언트 계산:** 순방향과 마찬가지로 $P-1$번의 링 통신이 발생한다.
   - 각 스텝에서, GPU들은 $dO$ 블록과 순방향 전파 과정에서 사용되었던 $Q$ 블록(이 역시 링을 따라 순환됨)을 주고받는다.
   - 각 GPU $p$는 수신한 $dO$와 $Q$, 그리고 로컬에 저장된 $K_p, V_p$ 및 순방향에서 계산된 어텐션 스코어를 사용하여 로컬 그래디언트 $dQ_p, dK_p, dV_p$를 계산하고 누적한다.
3. **최종 그래디언트:** 모든 스텝이 완료되면 각 GPU는 최종적으로 $dQ_p, dK_p, dV_p$를 얻게 되며, 이는 모델의 가중치를 업데이트하는 데 사용된다.

### 3.2  활성화 재계산(Activation Recomputation)을 통한 메모리 최적화

분산 어텐션의 통신 병목을 해결했더라도, 여전히 메모리 용량이라는 근본적인 제약이 남는다. 표준적인 역전파 알고리즘은 그래디언트 계산을 위해 순방향 전파 과정에서 계산된 중간 활성화 값(activations)들을 메모리에 저장해두어야 한다. MLLM의 교차-어텐션에서는 이 중간 활성화 값, 특히 거대한 K와 V 텐서가 엄청난 메모리를 차지한다. 더군다나 모델은 여러 개의 교차-어텐션 레이어를 포함하므로, 각 레이어마다 K, V 텐서를 저장하는 것은 메모리 사용량을 몇 배로 증폭시켜 처리 가능한 시퀀스 길이를 심각하게 제한한다.6

LV-XAttn은 이 문제를 해결하기 위해 MLLM 아키텍처의 구조적 특성을 영리하게 활용하는 **효율적인 활성화 재계산(Activation Recomputation)** 기법을 도입한다. 핵심 관찰은 **대부분의 MLLM에서 모든 교차-어텐션 레이어는 동일한 초기 시각적 토큰 입력을 공유한다**는 점이다.6 즉, 비전 인코더와 프로젝션 레이어를 한 번 통과하여 생성된 시각적 특징 텐서는 모든 교차-어텐션 레이어에 공통적으로 입력된다.

이를 바탕으로 LV-XAttn은 다음과 같은 전략을 사용한다.

1. **공유 텐서 저장:** 순방향 전파 시, 각 교차-어텐션 레이어에서 생성되는 거대한 K, V 텐서를 저장하는 대신, 모든 레이어의 입력이 되는 최초의 시각적 특징 텐서의 단일 복사본만을 GPU 메모리에 유지한다.
2. **역전파 시 재계산:** 역전파 과정에서 특정 교차-어텐션 레이어의 그래디언트를 계산해야 할 때, 저장해 둔 공유 시각적 특징 텐서를 가져와 해당 레이어의 K, V 생성에 필요한 연산(주로 선형 변환)을 즉석에서 다시 수행(recompute)한다.
3. **메모리 절약:** 이 방식을 통해, 레이어 수에 비례하여 증가하던 K, V 텐서 저장 공간을 상수(constant) 수준으로 줄일 수 있다. 절약된 메모리는 더 긴 시각적 시퀀스를 처리하는 데 할당될 수 있어, 모델의 컨텍스트 길이를 실질적으로 확장하는 효과를 가져온다.6

이 기법은 메모리 절약을 위해 추가적인 연산(recomputation)을 수행하는 전형적인 공간-시간 트레이드오프(space-time tradeoff)에 해당한다. 그러나 현대 GPU는 연산 능력에 비해 메모리 대역폭과 용량이 상대적으로 부족한 경우가 많으므로, 이러한 트레이드오프는 대부분의 시나리오에서 매우 효과적인 최적화 전략이 된다.

### 3.3  구현 세부사항

LV-XAttn의 실제 구현은 고성능 컴퓨팅 기술과 최신 딥러닝 프레임워크의 긴밀한 결합을 통해 이루어졌다.

- **기반 프레임워크:** 전체적인 코드 베이스는 PyTorch를 기반으로 작성되었다. 분산 환경에서의 GPU 간 통신은 PyTorch에 내장된 `torch.distributed` 라이브러리의 집합 통신(collective communication) 연산(예: `all_to_all`, `all_gather`)을 활용하여 구현되었다.13
- **고성능 커널:** 어텐션 연산의 핵심이 되는 부분, 즉 각 GPU 내에서 수행되는 블록-단위 행렬 곱셈과 온라인 Softmax 계산은 단순한 PyTorch 연산으로는 최적의 성능을 내기 어렵다. 이를 위해 LV-XAttn은 NVIDIA의 CUDA에 대한 파이썬 기반 인터페이스인 Triton 언어를 사용하여 고도로 최적화된 커스텀 커널을 구현했다. 이 커널은 FlashAttention의 아이디어를 기반으로 하되, 분산 계산에 필요한 온라인 Softmax 통계량의 재조정(rescaling)과 같은 추가적인 로직을 포함하도록 수정되었다.13
- **오픈소스 공개:** LV-XAttn의 연구 결과와 구현 코드는 재현성과 추가 연구를 위해 GitHub 저장소를 통해 공개되었다. 이 저장소에는 LV-XAttn의 핵심 로직뿐만 아니라, 기존 모델(예: Llama-3)의 어텐션 레이어를 LV-XAttn으로 교체(patching)하는 방법과 정확성을 검증하는 테스트 코드 등이 포함되어 있다.6

### 3.4 핵심 테이블 1: 어텐션 및 융합 메커니즘 비교 분석

LV-XAttn의 독창성과 MLLM 아키텍처 내에서의 위치를 명확히 이해하기 위해, 다른 주요 어텐션 및 모달리티 융합 방식들과의 비교는 필수적이다. 아래 표는 각 메커니즘의 핵심 원리와 장단점을 다각도로 분석하여 LV-XAttn의 차별점을 부각시킨다.

| 기준 (Criteria)  | LV-XAttn (분산 교차-어텐션)               | Ring Attention (분산 셀프/교차-어텐션) | ViT Self-Attention (단일 모달리티)              | LLaVA-style Concatenation (융합 방식)         |
| ---------------- | ----------------------------------------- | -------------------------------------- | ----------------------------------------------- | --------------------------------------------- |
| **주요 목적**    | 시각(K, V)과 언어(Q) 정보의 효율적 융합   | 긴 시퀀스에 대한 일반적인 분산 어텐션  | 단일 모달리티(예: 이미지 패치) 내의 관계 모델링 | 시각 토큰을 언어 토큰 시퀀스에 직접 통합      |
| **핵심 원리**    | Q/KV 비대칭성 활용, K/V 지역화, Q 순환    | 시퀀스 샤딩, K/V 텐서 순환             | 모든 토큰이 서로를 Q, K, V로 참조               | 시각 특징을 텍스트 임베딩 공간에 투영 후 연결 |
| **통신 비용**    | $O(S_Q \cdot d)$ (매우 낮음)              | $O(S_{KV} \cdot d)$ (매우 높음)        | 해당 없음 (단일 GPU 가정)                       | 해당 없음 (융합 방식)                         |
| **계산 복잡도**  | $O(S_Q \cdot S_{KV} \cdot d)$ (정확)      | $O(S_Q \cdot S_{KV} \cdot d)$ (정확)   | $O(S_{\text{patch}}^2 \cdot d)$                 | $O((S_Q + S_{\text{vis}})^2 \cdot d)$         |
| **주 적용 모델** | Flamingo, mPLUG-Owl3, Llama 3-V 1         | 긴 시퀀스 LLM, MLLM                    | Vision Transformer (ViT), Swin                  | LLaVA, InternVL 2                             |
| **장점**         | 최소한의 통신 오버헤드, 긴 시각 입력 처리 | 범용성, 정확한 어텐션                  | 전역적 관계 포착                                | 단순성, 강력한 성능                           |
| **단점**         | 교차-어텐션 구조에만 적용 가능 13         | 극심한 통신 병목 현상                  | 시퀀스 길이에 따른 이차 복잡도                  | 시퀀스 길이 증가 시 메모리/계산 부담 큼       |

이 표는 LV-XAttn이 범용 분산 알고리즘이 아니라, MLLM 교차-어텐션이라는 특정 문제에 고도로 특화된 시스템 최적화 기법임을 명확히 보여준다. 이는 다른 융합 방식인 Concatenation과는 근본적으로 다른 접근법이며, 기존 분산 방식인 Ring Attention의 치명적인 약점을 정확히 파고든 해결책이다.

## 4. V. 수학적 원리 및 공식 해설

LV-XAttn의 알고리즘적 우수성은 탄탄한 수학적 원리에 기반한다. 이 장에서는 표준 교차-어텐션의 공식에서 시작하여, LV-XAttn이 이를 어떻게 분산 환경에 맞게 블록-단위 연산으로 재구성했는지, 그리고 이로 인한 통신 비용의 이론적 이점을 수식으로 증명한다.

### 4.1  표준 스케일드 닷-프로덕트 교차-어텐션 (Standard Scaled Dot-Product Cross-Attention)

모든 어텐션 메커니즘의 기초는 스케일드 닷-프로덕트 어텐션(Scaled Dot-Product Attention)이다. 교차-어텐션의 맥락에서, 두 개의 다른 소스에서 온 입력이 사용된다. 하나는 쿼리($Q$)를 생성하고, 다른 하나는 키($K$)와 값($V$)을 생성한다. MLLM에서는 일반적으로 텍스트 임베딩이 $Q$를, 시각적 특징이 $K$와 $V$를 생성한다.

쿼리 행렬 $Q \in \mathbb{R}^{S_Q \times d_k}$, 키 행렬 $K \in \mathbb{R}^{S_{KV} \times d_k}$, 값 행렬 $V \in \mathbb{R}^{S_{KV} \times d_v}$가 주어졌을 때, 어텐션의 출력 $O \in \mathbb{R}^{S_Q \times d_v}$는 다음과 같은 단일 행렬 연산으로 정의된다.17
$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$
이 공식의 각 구성 요소는 다음과 같은 의미를 가진다.

1. **$QK^T$**: $Q$와 $K$의 행렬 곱은 각 쿼리 벡터와 모든 키 벡터 간의 내적(dot product)을 계산하여 유사도(similarity) 스코어 행렬($\in \mathbb{R}^{S_Q \times S_{KV}}$)을 생성한다.
2. **$/\sqrt{d_k}$**: 스케일링(Scaling). 키 벡터의 차원 $d_k$가 클 경우 내적 값이 너무 커져 Softmax 함수의 그래디언트가 매우 작아지는 문제를 방지하기 위해, 스코어를 $d_k$의 제곱근으로 나누어준다.
3. **softmax(...)**: 스코어 행렬의 각 행에 대해 Softmax 함수를 적용하여, 합이 1이 되는 확률 분포, 즉 어텐션 가중치(attention weights)로 변환한다. $i$번째 쿼리에 대한 어텐션 가중치는 $i$번째 쿼리가 각 키(및 해당 값)에 얼마나 '집중'해야 하는지를 나타낸다.
4. **(...)V**: 계산된 어텐션 가중치 행렬과 값 행렬 $V$를 곱한다. 이는 값 벡터들의 가중 합(weighted sum)을 계산하는 과정으로, 어텐션 가중치가 높은 값 벡터의 정보가 최종 출력에 더 많이 반영된다.

### 4.2  LV-XAttn의 분산 블록-단위(Block-wise) 연산

단일 GPU 환경에서는 위 공식을 직접 계산할 수 있지만, $K$와 $V$가 너무 커서 여러 GPU에 분산 저장된 경우, 이 연산을 수학적으로 동일하게 유지하면서 분산 수행해야 한다. LV-XAttn은 이를 위해 온라인 Softmax(또는 로그-합-지수 트릭, log-sum-exp trick)를 활용한 블록-단위 연산을 수행한다.

$P$개의 GPU가 있는 환경을 가정하자. 키와 값 텐서는 시퀀스 차원을 따라 $P$개의 블록으로 분할되어, GPU $p$는 $K_p \in \mathbb{R}^{(S_{KV}/P) \times d_k}$와 $V_p \in \mathbb{R}^{(S_{KV}/P) \times d_v}$를 로컬에 저장한다. 쿼리 텐서 $Q$ 또한 $P$개의 블록 $Q_0,..., Q_{P-1}$로 나뉜다.

LV-XAttn의 순방향 전파는 각 쿼리 블록 $Q_i$에 대해 독립적으로 수행될 수 있다. $Q_i$에 대한 최종 출력 $O_i$를 계산하는 과정을 살펴보자. 이 과정은 $P$개의 스텝으로 구성되며, 각 스텝에서 $Q_i$는 하나의 키-값 블록 쌍($K_j, V_j$)과 상호작용한다.

$j$번째 블록과의 상호작용에서, 먼저 스코어 블록 $S_{i,j}$를 계산한다.
$$
S_{i,j} = \frac{Q_i K_j^T}{\sqrt{d_k}}
$$
전체 스코어 행렬 $S_i$는 이 블록들을 행 방향으로 이어 붙인 것과 같다: $S_i =$.

전체 Softmax를 직접 계산하는 대신, 각 블록에 대해 로컬 통계량을 계산하고 이를 결합한다. $S_i$의 각 행 $k$에 대해, 전역 최댓값 $m_k$와 정규화 상수 $l_k$는 다음과 같이 계산될 수 있다.
$$
m_k = \max_{j \in \{0,..,P-1\}} (\max(S_{i,j}[k,:]))
$$

$$
l_k = \sum_{j=0}^{P-1} \sum_{c} \exp(S_{i,j}[k,c] - m_k)
$$

최종 출력 $O_i$의 $k$번째 행은 다음과 같이 표현된다.
$$
O_i[k,:] = \frac{1}{l_k} \sum_{j=0}^{P-1} \sum_{c} \exp(S_{i,j}[k,c] - m_k) V_j[c,:]
$$
LV-XAttn은 이 계산을 온라인 방식으로 수행한다. 쿼리 블록 $Q_i$가 각 GPU $j$를 순회하면서, GPU $j$는 로컬 스코어 $S_{i,j}$를 계산한다. 그리고 현재까지의 전역 최댓값과 합계를 업데이트하고, 부분 출력에 새로운 가중치를 적용하여 더한다. 이 과정에서 쿼리 블록 $Q_i$와 함께 현재까지의 전역 통계량(최댓값, 합계)에 해당하는 작은 크기의 텐서도 함께 전송된다.12 모든 블록 순회가 끝나면 최종적으로 정확한 어텐션 출력을 얻게 된다. 이 방식은 수치적으로 안정적이면서도 분산 환경에 최적화되어 있다.

### 4.3  통신 비용 이론적 분석

LV-XAttn의 가장 큰 장점은 통신 비용의 극적인 감소이며, 이는 수학적으로 명확히 증명될 수 있다. 순방향 전파 과정에서 한 번의 완전한 어텐션 계산에 필요한 총 통신량을 비교해 보자. (단, $P$는 GPU 수, $H$는 어텐션 헤드 수, $d$는 헤드 당 차원, 데이터 타입은 2바이트(bfloat16)로 가정한다.)

#### 4.3.1 Ring Attention의 통신 비용

Ring Attention에서는 각 GPU가 $P-1$번의 통신 스텝 동안 K 텐서 블록과 V 텐서 블록을 전송하고 수신한다.

- 한 스텝 당 전송량: $(|K_p| + |V_p|) \times 2 \text{ bytes} = (\frac{S_{KV}}{P} \cdot H \cdot d + \frac{S_{KV}}{P} \cdot H \cdot d) \times 2 \text{ bytes}$

- 총 통신량 $C_{\text{Ring}}$:
  $$
  C_{\text{Ring}} \approx (P-1) \cdot \left( \frac{S_{KV}}{P} \cdot H \cdot d \cdot 2 \right) \cdot 2 \approx 4 \frac{P-1}{P} S_{KV} H d \text{ bytes}
  $$
  여기서 $S_{KV}$가 매우 크기 때문에 통신량은 $S_{KV}$에 거의 정비례하여 폭발적으로 증가한다.

#### 4.3.2 LV-XAttn의 통신 비용

LV-XAttn에서는 각 GPU가 $P-1$번의 통신 스텝 동안 Q 텐서 블록과 작은 크기의 Softmax 통계량 텐서를 전송하고 수신한다.

- 한 스텝 당 전송량: $(|Q_p| + |\text{stats}_p|) \times 2 \text{ bytes} = (\frac{S_Q}{P} \cdot H \cdot d + \frac{S_Q}{P} \cdot H \cdot 2) \times 2 \text{ bytes}$

  (통계량은 각 쿼리 토큰 당 최댓값과 합계, 2개의 float)

- 총 통신량 $C_{\text{LV-XAttn}}$:
  $$
  C_{\text{LV-XAttn}} \approx (P-1) \cdot \left( \frac{S_Q}{P} \cdot H \cdot (d+2) \right) \cdot 2 \approx 2 \frac{P-1}{P} S_Q H (d+2) \text{ bytes}
  $$

#### 4.3.3 비용 비교

두 방식의 통신량 비율은 다음과 같다.
$$
\frac{C_{\text{LV-XAttn}}}{C_{\text{Ring}}} \approx \frac{2 S_Q H (d+2)}{4 S_{KV} H d} = \frac{S_Q (d+2)}{2 S_{KV} d} \approx \frac{S_Q}{2 S_{KV}}
$$
앞서 살펴본 예시처럼 $S_{KV}$가 $S_Q$보다 수백, 수천 배 크기 때문에($S_{KV} \gg S_Q$), 이 비율은 1보다 훨씬 작은 값이 된다. 이는 LV-XAttn이 Ring Attention에 비해 이론적으로 수백에서 수천 배 적은 데이터를 통신함을 의미하며, 실제 성능 향상의 핵심적인 수학적 근거가 된다.

## 5. VI. 성능 벤치마크 및 실증 분석

이론적 우수성은 실제 시스템에서의 성능 향상으로 입증되어야 한다. LV-XAttn은 Llama 3-V, mPLUG-Owl3, OpenFlamingo 등 여러 대표적인 MLLM을 대상으로 한 광범위한 실험을 통해 그 효과를 실증적으로 증명했다. 이 장에서는 보고된 벤치마크 결과를 종합하고, 성능 향상의 이면에 있는 요인들을 심층적으로 분석한다.

### 5.1  엔드-투-엔드 성능 향상

엔드-투-엔드(End-to-End) 성능은 모델의 전체 학습 또는 추론 반복(iteration)에 걸리는 시간을 측정하는 가장 중요한 지표이다. LV-XAttn은 기존의 대표적인 분산 어텐션 기법인 Ring Attention 및 DeepSpeed-Ulysses와 비교하여 모든 실험 환경에서 일관되게 뛰어난 속도 향상을 보여주었다.1

- **최신 결과 (Llama 3-V):** 가장 주목할 만한 결과는 최신 버전의 논문(v3)과 공식 GitHub 저장소에서 보고된 Llama 3-V 모델에 대한 실험이다. 16개의 NVIDIA A100 80GB GPU로 구성된 클러스터에서, LV-XAttn은 Ring Attention 대비 **최대 10.62배**의 엔드-투-엔드 속도 향상을 달성했다.9 이는 교차-어텐션의 최적화가 모델 전체 성능에 지대한 영향을 미칠 수 있음을 보여주는 강력한 증거이다.
- **초기 결과 (mPLUG-Owl3, OpenFlamingo):** 논문의 초기 버전에서는 mPLUG-Owl3와 OpenFlamingo 모델을 사용하여 8개의 A100 GPU 환경에서 실험이 진행되었다. 이 환경에서 LV-XAttn은 mPLUG-Owl3에서 최대 5.58배, OpenFlamingo에서 최대 3.47배의 엔드-투-엔드 속도 향상을 기록했다.3

이러한 결과의 차이는 평가에 사용된 모델의 아키텍처(예: 교차-어텐션 레이어의 수와 위치), 하드웨어 구성(GPU 수 및 네트워크 토폴로지), 그리고 소프트웨어 스택의 최적화 수준 등 여러 요인에 기인하는 것으로 분석된다. 특히, 더 많은 GPU를 사용하는 환경일수록 통신 병목이 더욱 심화되므로, LV-XAttn의 통신량 감소 효과가 더 크게 나타나 더 높은 가속 비율을 보일 수 있다.

### 5.2  성능 병목 분석 (Time Breakdown)

엔드-투-엔드 속도 향상 수치만으로는 성능 개선이 어느 부분에서 비롯되었는지 정확히 알 수 없다. LV-XAttn 연구팀은 모델 반복 시간(iteration time)을 여러 구성 요소로 나누어 분석함으로써 성능 병목의 변화를 명확하게 보여주었다.

- **교차-어텐션(CA) 자체의 극적인 가속:** LV-XAttn의 직접적인 최적화 대상인 교차-어텐션(Cross-Attention) 연산 자체는 가장 극적인 속도 향상을 보였다. mPLUG-Owl3 모델 실험에서, 교차-어텐션의 순방향 및 역방향 전파("FWD CA", "BWD CA")에 걸리는 시간은 Ring Attention 대비 **최대 45.85배**까지 단축되었다.1 이는 LV-XAttn이 통신 오버헤드를 거의 제거하는 데 성공했음을 의미한다.
- **암달의 법칙 (Amdahl's Law)과 새로운 병목:** 그러나 교차-어텐션 자체의 45.85배 가속이 전체 모델의 5.58배 가속으로 이어진 것은 암달의 법칙으로 설명할 수 있다. 시스템의 한 부분을 최적화하면, 전체 성능은 최적화되지 않은 다른 부분들에 의해 제한된다. LV-XAttn을 통해 교차-어텐션이 더 이상 병목이 아니게 되자, 이전에는 그 시간에 가려져 있던 다른 연산들이 상대적으로 전체 실행 시간에서 차지하는 비중이 커지며 새로운 병목으로 부상했다. 논문의 시간 분석에 따르면, 비전 인코더의 순방향 연산("FWD Vision")과 교차-어텐션이 아닌 일반적인 언어 모델 블록의 연산("FWD/BWD Non-CA")이 이제 전체 성능을 좌우하는 주요 요인이 되었다.6 이는 향후 MLLM 성능 최적화가 교차-어텐션을 넘어 모델의 다른 구성 요소로 확장되어야 함을 시사한다.

### 5.3  시퀀스 길이에 따른 확장성

LV-XAttn의 진정한 가치는 단순히 특정 조건에서의 속도 향상을 넘어, 입력 시퀀스 길이가 증가할 때 얼마나 안정적으로 성능을 유지할 수 있는지, 즉 확장성(scalability)에 있다.

- **시각적 시퀀스 길이($S_{KV}$)에 대한 확장성:** LV-XAttn의 가장 큰 장점은 시각적 시퀀스 길이가 길어져도 성능 저하가 거의 없다는 점이다. K와 V 텐서는 로컬에 고정되어 통신되지 않으므로, $S_{KV}$가 아무리 커져도 통신 시간에는 영향을 미치지 않는다. 반면, Ring Attention은 $S_{KV}$에 비례하여 통신 시간이 급격히 증가하므로, 시각적 시퀀스가 길어질수록 성능이 현저히 저하된다.
- **텍스트 시퀀스 길이($S_Q$)에 대한 확장성:** LV-XAttn은 텍스트에서 파생된 Q 텐서를 통신하므로, 텍스트 시퀀스 길이 $S_Q$가 증가하면 통신 비용도 선형적으로 증가한다. 그러나 MLLM의 일반적인 사용 사례에서 $S_Q$는 $S_{KV}$에 비해 훨씬 작고, 그 증가율 또한 제한적이다. 따라서 $S_Q$ 증가로 인한 성능 저하는 Ring Attention이 $S_{KV}$ 증가로 겪는 성능 저하에 비해 훨씬 완만하다. 실험 결과, LV-XAttn은 텍스트 길이가 길어지는 상황에서도 Ring Attention 대비 월등한 성능 우위를 일관되게 유지했다.1

### 핵심 테이블 2: LV-XAttn 성능 벤치마크 요약

아래 표는 LV-XAttn 논문에서 보고된 핵심적인 성능 측정 결과를 종합하여, 그 효과를 정량적으로 요약한다. 이 표를 통해 독자는 다양한 조건 하에서 LV-XAttn이 달성한 성능 개선의 규모를 직관적으로 파악할 수 있다.

| 모델 (Model)     | GPU 수    | 시퀀스 길이 (비전/텍스트) | 베이스라인 (Baseline) | 교차-어텐션 가속 (CA Speedup) | 엔드-투-엔드 가속 (Total Speedup) | 소스 (Source) |
| ---------------- | --------- | ------------------------- | --------------------- | ----------------------------- | --------------------------------- | ------------- |
| **Llama 3-V**    | 16 x A100 | 1200 / 2048               | Ring Attention        | -                             | **최대 10.62x**                   | 9             |
| **mPLUG-Owl3**   | 8 x A100  | 250k / 2048               | Ring Attention        | 45.85x                        | 5.58x                             | 1             |
| **OpenFlamingo** | 8 x A100  | 250k / 2048               | Ring Attention        | 27.15x                        | 3.47x                             | 6             |
| **이론적 성능**  | -         | -                         | 무통신(No-comm)       | -                             | 0.42% 오버헤드                    | 6             |

이 벤치마크 결과는 LV-XAttn이 이론적 분석에 그치지 않고, 실제 MLLM 구동 환경에서 통신 병목을 효과적으로 해결하여 상당한 성능 향상을 이끌어냈음을 명백히 보여준다. 특히, 교차-어텐션 가속과 엔드-투-엔드 가속 간의 차이는 시스템 성능 최적화가 전체 파이프라인을 고려해야 하는 복합적인 과제임을 상기시킨다.

## 6. VII. 비판적 고찰 및 한계 분석

LV-XAttn은 긴 시각 입력을 처리하는 MLLM의 성능을 획기적으로 개선한 중요한 기술이지만, 모든 문제를 해결하는 만능 해결책은 아니다. 기술의 효용성을 객관적으로 평가하기 위해서는 그 한계와 잠재적인 단점을 명확히 인지하는 것이 필수적이다. 이 장에서는 LV-XAttn이 가진 내재적 한계와 동료 심사(peer review) 과정에서 제기된 비판점들을 심도 있게 고찰한다.

### 6.1  적용 가능한 아키텍처의 제한성

LV-XAttn의 가장 근본적이고 명백한 한계는 **적용 가능한 MLLM 아키텍처가 제한적**이라는 점이다. LV-XAttn의 모든 최적화는 시각 정보(K, V)와 언어 정보(Q)가 명시적으로 분리되어 상호작용하는 **교차-어텐션(Cross-Attention) 레이어**의 존재를 전제로 한다. 따라서 Flamingo, mPLUG-Owl3, Llama 3-V와 같이 이러한 구조를 채택한 모델에서는 매우 효과적이다.13

그러나 MLLM의 또 다른 주요 흐름인 **연결(Concatenation) 기반 아키텍처**에는 LV-XAttn을 직접 적용할 수 없다. LLaVA, InternVL 2.5와 같은 모델들은 시각 인코더가 추출한 시각 토큰들을 언어 모델의 입력 임베딩 시퀀스에 단순히 이어 붙이는 방식을 사용한다.2 그 후, 확장된 전체 시퀀스(시각 토큰 + 텍스트 토큰)에 표준적인 셀프-어텐션(Self-Attention)을 적용하여 두 모달리티 간의 융합을 수행한다. 이 구조에서는 쿼리, 키, 값이 모두 동일한 확장 시퀀스에서 파생되므로, LV-XAttn의 핵심 전제인 Q와 K/V의 비대칭성이 존재하지 않는다.

이러한 제한점은 MLLM 아키텍처 설계자들에게 중요한 트레이드오프를 제시한다. 연결 기반 아키텍처는 구현이 단순하고 다양한 사전 학습된 언어 모델에 쉽게 적용할 수 있다는 장점이 있다. 반면, 교차-어텐션 기반 아키텍처는 LV-XAttn과 같은 시스템 수준의 최적화를 통해 극단적으로 긴 시퀀스를 처리하는 데 있어 압도적인 성능 우위를 가질 수 있다. 따라서 모델 설계의 선택은 단순히 이론적인 성능뿐만 아니라, 목표 응용 분야(예: 단일 이미지 질의응답 vs. 장시간 비디오 분석)와 가용한 시스템 최적화 기술까지 고려해야 하는 복합적인 결정이 되었다. 이는 모델 아키텍처와 시스템 설계가 서로 영향을 미치며 함께 진화해야 함을 보여주는 대표적인 사례이다.

### 6.2  리뷰어들이 지적한 약점 (Weaknesses Highlighted by Peer Review)

LV-XAttn 논문이 ICML 2025와 같은 최상위 학회에 제출되고 심사받는 과정에서, 여러 연구자로부터 다음과 같은 건설적인 비판과 약점이 지적되었다.13

- **정확도-성능 트레이드오프 분석 부재:** LV-XAttn은 수학적으로는 원래의 어텐션과 동일한 결과를 내는 '정확한(exact)' 알고리즘이라고 주장한다. 그러나 실제 분산 컴퓨팅 환경에서는 GPU 간 연산 순서의 미세한 차이나 부동소수점 연산의 누적 오차(floating-point error)로 인해 결과값이 미세하게 달라질 수 있다. 이러한 미세한 차이가 모델의 학습 동역학(training dynamics)이나 최종 수렴 정확도에 어떤 영향을 미치는지에 대한 분석이 부족하다는 지적이 있었다.
- **통계적 유의성 검증 부재:** 논문에서 제시된 10.62배와 같은 인상적인 속도 향상 수치는 특정 하드웨어, 소프트웨어, 데이터셋 조합에서 얻어진 결과이다. 이러한 결과가 얼마나 일반화될 수 있는지, 그리고 측정 오차의 범위를 넘어 통계적으로 유의미한 개선인지를 보이기 위한 반복 측정이나 통계적 유의성 테스트가 제공되지 않았다는 점이 약점으로 꼽혔다.13
- **단일 이미지 및 작은 시각 입력 평가 부재:** LV-XAttn은 이름에서 알 수 있듯이 '긴(Long)' 시각 입력에 최적화되어 있다. 하지만 MLLM의 가장 흔한 사용 사례 중 하나는 여전히 단일 이미지를 입력으로 받는 것이다. 단일 이미지의 경우 시각 토큰의 수($S_{KV}$)가 텍스트 토큰의 수($S_Q$)와 비슷하거나 오히려 더 적을 수 있다. 이러한 시나리오에서 LV-XAttn은 상대적으로 큰 Q를 통신시켜야 하므로, 오히려 K/V를 통신하는 Ring Attention보다 성능이 저하될 수 있다. 논문은 이러한 '역전' 현상이 발생할 수 있는 조건에 대한 이론적, 실험적 분석을 충분히 제공하지 않았다.10
- **제한된 모델 범위:** 성능 평과가 Llama 3-V, mPLUG-Owl3, OpenFlamingo라는 소수의 모델에 집중되어 있다. LV-XAttn의 효과가 이 모델들의 특정 구조에 의존하는 것인지, 아니면 더 넓은 범위의 교차-어텐션 기반 MLLM에 보편적으로 적용될 수 있는지를 입증하기 위해서는 더 다양한 아키텍처에서의 검증이 필요하다는 의견이 있었다.13

### 6.3  잠재적 트레이드오프: 재계산 비용

활성화 재계산(Activation Recomputation) 기법은 메모리 사용량을 획기적으로 줄여주지만, 이는 공짜로 얻어지는 것이 아니다. 메모리를 절약하는 대신, 역전파 과정에서 추가적인 연산(computation)을 수행해야 하는 명백한 시간-공간 트레이드오프(time-space tradeoff)를 내포하고 있다.13

대부분의 현대 AI 워크로드는 메모리 대역폭이나 용량에 의해 병목이 발생하는 '메모리 바운드(memory-bound)' 특성을 가지므로, 연산 시간을 조금 희생하여 메모리를 절약하는 것이 전체 처리량을 높이는 데 유리하다. 그러나 모든 상황에서 그런 것은 아니다.

- GPU 메모리 용량은 매우 크지만 상대적으로 연산 성능이 낮은 시스템의 경우, 재계산으로 인한 시간 손실이 더 크게 느껴질 수 있다.
- 미래에 GPU 간 통신 속도가 극도로 빨라지거나, 메모리 용량이 비약적으로 증가하는 등 하드웨어 환경이 변한다면, 재계산의 효용성이 감소할 수도 있다.

따라서 활성화 재계산 기법의 적용 여부는 사용자의 하드웨어 사양, 모델의 크기, 그리고 처리하고자 하는 시퀀스의 길이를 종합적으로 고려하여 결정해야 할 문제이다. LV-XAttn 논문은 이러한 트레이드오프에 대한 정량적인 가이드라인이나 분석을 상세히 제공하지는 않았다는 점에서 비판의 여지가 있다.

## 7. VIII. 결론: LV-XAttn의 의의와 향후 연구 방향

### 8.1. LV-XAttn의 기술적 기여 요약

LV-XAttn은 멀티모달 대규모 언어 모델, 특히 긴 시각적 시퀀스를 처리하는 분야에서 중요한 기술적 진보를 이루었다. 그 의의와 기여는 다음과 같이 요약할 수 있다.

첫째, **문제의 본질을 꿰뚫는 새로운 패러다임을 제시했다.** LV-XAttn은 단순히 기존 분산 알고리즘을 개선하는 데 그치지 않고, MLLM 교차-어텐션에서 발생하는 '데이터 비대칭성'이라는 근본적인 구조적 특성을 간파했다. 그리고 이를 활용하여 통신 병목이라는 시스템 수준의 문제를 해결하는 혁신적인 접근법, 즉 'K/V 지역화 및 Q 순환'을 제안했다. 이는 문제 자체를 재정의함으로써 해결책을 찾은 중요한 사례이다.

둘째, **알고리즘과 시스템의 공동 설계(Co-design)의 중요성을 입증했다.** LV-XAttn은 어텐션 알고리즘을 근사(approximation)하거나 변경하지 않고도, 데이터의 흐름과 분산 처리 방식을 재설계하는 것만으로 엄청난 성능 향상을 이끌어낼 수 있음을 보여주었다. 이는 순수 알고리즘 연구와 시스템 최적화 연구가 분리될 수 없으며, 두 분야의 긴밀한 협력을 통해 진정한 돌파구를 마련할 수 있음을 시사한다.

셋째, **장시간 비디오 이해의 실용성을 한 단계 끌어올렸다.** 이전까지는 엄청난 메모리 요구량과 통신 비용으로 인해 사실상 비실용적이거나 학술적 연구에 머물렀던, 수십 분 길이의 비디오에 대한 MLLM의 학습 및 추론을 현실적으로 가능한 영역으로 가져왔다.4 이는 감시, 미디어 콘텐츠 분석, 자율주행 등 다양한 산업 분야에서 MLLM의 응용 가능성을 크게 확장시키는 잠재력을 가진다.

결론적으로 LV-XAttn은 긴 시퀀스 MLLM이 직면한 핵심적인 시스템 병목을 해결하기 위한 매우 효과적이고 독창적인 솔루션이다. 이는 향후 대규모 AI 모델의 분산 및 최적화 연구에 중요한 방향성을 제시하며, 더 복잡하고 거대한 멀티모달 데이터를 처리하는 AI 시스템의 발전을 가속화할 것이다.

### 7.1  향후 연구 방향

LV-XAttn이 제시한 가능성과 남겨진 한계들은 다음과 같은 흥미로운 후속 연구 방향으로 이어진다.

- **하이브리드 분산 처리 전략 연구:** LV-XAttn은 교차-어텐션에, Ring Attention은 셀프-어텐션에 강점을 보인다. 하나의 MLLM 내에는 두 종류의 어텐션이 모두 존재하므로, 각 레이어의 특성에 맞게 두 전략을 동적으로 결합하는 하이브리드 분산 처리 프레임워크를 개발할 수 있다. 더 나아가, LV-XAttn의 아이디어를 연결(Concatenation) 기반 모델에 부분적으로 적용하거나 변형하여, 아키텍처의 경계를 넘나드는 새로운 최적화 기법을 모색할 수 있다.
- **자동화된 병렬화 전략 컴파일러 개발:** 최적의 병렬화 전략은 모델 아키텍처, 입력 데이터의 특성(예: $S_Q$와 $S_{KV}$의 비율), 그리고 하드웨어 사양(GPU 연산 능력, 메모리 용량, 네트워크 대역폭 등)에 따라 달라진다. 이러한 모든 요소를 종합적으로 고려하여, LV-XAttn, Ring Attention, 텐서 병렬 처리 등 다양한 병렬화 기법 중 최적의 조합을 자동으로 찾아 모델 코드를 변환해주는 지능형 컴파일러 또는 런타임 시스템을 개발하는 연구는 매우 가치가 있을 것이다.
- **정확도 및 학습 동역학에 대한 심층 분석:** 분산 처리가 부동소수점 연산 순서에 미치는 영향과 이것이 모델의 최종 정확도 및 수렴 속도에 미치는 영향에 대한 심도 있는 이론적, 실험적 분석이 필요하다. 이는 대규모 분산 학습의 안정성과 재현성을 보장하기 위한 필수적인 연구이다.
- **다양한 모달리티로의 원리 확장:** 데이터 비대칭성은 시각-언어 융합에만 국한되지 않는다. 예를 들어, 긴 오디오 시퀀스에 대한 짧은 텍스트 질의, 고해상도 3D 포인트 클라우드 데이터에 대한 분석 등, 하나의 모달리티가 다른 모달리티보다 훨씬 큰 정보를 가지는 경우는 다양하게 존재한다. LV-XAttn의 핵심 원리인 '비대칭적 데이터 교환'을 이러한 다양한 멀티모달 융합 문제에 확장하여 적용하는 연구는 새로운 응용 분야를 개척할 수 있을 것이다.

이러한 후속 연구들은 LV-XAttn이 연 길을 더욱 넓히고, 미래의 AI 시스템이 더욱 거대하고 복잡한 데이터를 효율적으로 처리할 수 있도록 하는 데 기여할 것이다.

#### **참고 자료**

1. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models | alphaXiv, 8월 16, 2025에 액세스, https://www.alphaxiv.org/overview/2502.02406v1
2. gokayfem/awesome-vlm-architectures: Famous Vision Language Models and Their Architectures - GitHub, 8월 16, 2025에 액세스, https://github.com/gokayfem/awesome-vlm-architectures
3. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - Bohrium, 8월 16, 2025에 액세스, https://www.bohrium.com/paper-details/lv-xattn-distributed-cross-attention-for-long-visual-inputs-in-multimodal-large-language-models/1094129133031522373-108597
4. Scaling Visual Attention Across GPUs - Zerna.io GmbH, 8월 16, 2025에 액세스, https://zerna.io/page/engineering/presentation_set/engineering-llm-research/presentation/engineering-computer-vision-perception/slide/engineering-paper-2502_02406
5. Papers Explained 82: Flamingo - Ritvik Rastogi - Medium, 8월 16, 2025에 액세스, https://ritvik19.medium.com/papers-explained-82-flamingo-8c124c394cdb
6. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/pdf/2502.02406
7. PLG-ViT: Vision Transformer with Parallel Local and Global Self-Attention - PMC, 8월 16, 2025에 액세스, https://pmc.ncbi.nlm.nih.gov/articles/PMC10098752/
8. System Optimizations for Enabling Training of Extreme Long Sequence Transformer Models | Request PDF - ResearchGate, 8월 16, 2025에 액세스, https://www.researchgate.net/publication/381481541_System_Optimizations_for_Enabling_Training_of_Extreme_Long_Sequence_Transformer_Models
9. [2502.02406] LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/abs/2502.02406
10. (PDF) LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - ResearchGate, 8월 16, 2025에 액세스, https://www.researchgate.net/publication/388685509_LV-XAttn_Distributed_Cross-Attention_for_Long_Visual_Inputs_in_Multimodal_Large_Language_Models
11. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/html/2502.02406v1
12. MachineLearningSystem/25ICML-LV-XAttn - GitHub, 8월 16, 2025에 액세스, https://github.com/MachineLearningSystem/25ICML-LV-XAttn
13. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models | OpenReview, 8월 16, 2025에 액세스, https://openreview.net/forum?id=kuIwMEHXMT
14. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/html/2502.02406v2
15. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - ICML 2025, 8월 16, 2025에 액세스, https://icml.cc/virtual/2025/poster/44230
16. uw-mad-dash/LV-XAttn - GitHub, 8월 16, 2025에 액세스, https://github.com/uw-mad-dash/LV-XAttn
17. A Mathematical View of Attention Models in Deep Learning - Texas A&M University, 8월 16, 2025에 액세스, https://people.tamu.edu/~sji/classes/attn.pdf
18. Demystifying the Attention Formula | by Dagang Wei - Medium, 8월 16, 2025에 액세스, https://medium.com/@weidagang/demystifying-the-attention-formula-8f5ad602546f
19. Understanding and Coding the Self-Attention Mechanism of Large Language Models From Scratch - Sebastian Raschka, 8월 16, 2025에 액세스, https://sebastianraschka.com/blog/2023/self-attention-from-scratch.html
20. LV-XAttn: Distributed Cross-Attention for Long Visual Inputs in Multimodal Large Language Models - arXiv, 8월 16, 2025에 액세스, https://arxiv.org/html/2502.02406

