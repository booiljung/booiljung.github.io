# 어텐션 메커니즘에 대한 심층 분석

## 1. 어텐션의 필요성과 등장

### 1.1 순차 데이터 처리와 Sequence-to-Sequence (Seq2Seq) 모델의 부상

자연어 처리, 음성 인식, 시계열 예측 등 현대 인공지능의 여러 핵심 분야는 순차적(sequential) 데이터 처리를 기반으로 한다. 이러한 태스크를 해결하기 위해 제안된 Sequence-to-Sequence(Seq2Seq) 모델은 입력 시퀀스를 받아 출력 시퀀스를 생성하는 강력한 프레임워크로 자리 잡았다. 초기 Seq2Seq 모델은 주로 순환 신경망(Recurrent Neural Network, RNN)에 기반한 인코더-디코더(Encoder-Decoder) 구조를 채택했다.1 이 구조에서 인코더는 입력 문장과 같은 시퀀스를 단계적으로 읽어들이며 정보를 압축하고, 디코더는 인코더가 생성한 정보를 바탕으로 번역된 문장과 같은 출력 시퀀스를 하나씩 생성하는 역할을 수행한다.

### 1.2 고정 길이 컨텍스트 벡터의 근본적 한계: 정보 병목 현상

RNN 기반 Seq2Seq 모델의 구조적 핵심에는 '컨텍스트 벡터(Context Vector)'가 존재한다. 인코더는 입력 시퀀스의 모든 정보를 마지막 은닉 상태(hidden state)인 고정된 크기의 벡터 하나에 모두 압축해야만 했다.2 이 컨텍스트 벡터는 입력 시퀀스의 '요약본'으로서 디코더에 전달되어 출력 생성의 유일한 정보원으로 사용되었다.

그러나 이러한 설계는 근본적인 한계를 내포하고 있었다. 입력 시퀀스의 길이가 길어질수록, 문장 초반부의 중요한 정보가 여러 계산 단계를 거치면서 희석되거나 소실되는 '장기 의존성 문제(Long-Range Dependency Problem)'가 발생했다.2 Bahdanau et al. (2014)은 이 현상을 정보가 하나의 벡터를 통과해야만 하는 '병목(bottleneck)' 현상으로 규정하며, 이로 인해 디코더가 입력 정보에 매우 제한적으로만 접근할 수 있다고 지적했다.4

예를 들어, "the soccer ball is on the field"라는 문장을 번역한다고 가정해 보자. 인간은 "ball", "on", "field"와 같은 핵심 단어에 더 큰 중요도를 부여하며 의미를 파악한다. 하지만 고정 길이 컨텍스트 벡터는 모든 단어의 정보를 동등하게 취급하여 하나의 벡터로 압축하므로, 이러한 차등적 중요도를 반영할 수 없었다.3 결과적으로, 모델은 길고 복잡한 문장을 처리하는 데 심각한 성능 저하를 보였다.

### 1.3  동적 컨텍스트의 필요성과 어텐션의 탄생

정보 병목 현상을 해결하기 위한 대안으로, 디코더가 매 출력 단어를 생성하는 시점(time step)마다 입력 시퀀스의 특정 부분에 선택적으로 '집중(attend)'할 수 있는 동적인 메커니즘의 필요성이 대두되었다.1 이것이 바로 어텐션(Attention) 메커니즘의 시작이었다.

어텐션 메커니즘은 고정된 요약본에 의존하는 대신, 디코더가 출력 단어를 생성할 때마다 입력 시퀀스 전체를 다시 참조하여 현재 시점에서 가장 관련성 높은 정보에 높은 가중치를 부여하는 방식으로 작동한다.3 이를 통해 매번 다른 내용으로 구성된 '동적 컨텍스트 벡터'를 생성하여 디코더에 제공함으로써, 길이에 상관없이 중요한 정보를 효과적으로 활용할 수 있게 되었다.

이러한 접근 방식은 단순히 RNN 모델의 성능을 개선하는 기술을 넘어, 시퀀스 정보를 처리하는 방식에 대한 근본적인 패러다임 전환을 의미했다. 기존의 '압축적 표현(compressive representation)' 방식에서 벗어나, 필요한 정보에 '선택적 접근(selective access)'하는 방식으로의 전환은 훗날 트랜스포머 아키텍처의 핵심 철학으로 이어진다. 이는 인간이 복잡한 환경에서 모든 것을 기억하려 하기보다, 특정 과업 수행에 필요한 정보에 '집중'하는 인지 과정과도 유사하다.1 이 '집중' 메커니즘은 어떤 입력에 높은 가중치가 부여되었는지 시각화함으로써 모델의 결정 과정을 추론할 수 있게 하는 해석 가능성(interpretability)이라는 부수적인 장점도 제공한다.3

## 2.  초기 어텐션 메커니즘: 바다나우와 루옹

### 2.1  쿼리(Query), 키(Key), 값(Value) 개념의 정립

어텐션 메커니즘의 작동 원리는 종종 정보 검색 시스템에 비유된다. 이 시스템은 세 가지 핵심 요소, 즉 쿼리(Query), 키(Key), 값(Value)으로 구성된다.1

- **쿼리(Query):** 현재 찾고자 하는 정보에 대한 표현이다.
- **키(Key):** 검색 대상이 되는 각 정보 항목을 식별하는 데 사용되는 식별자이다.
- **값(Value):** 키와 연결된 실제 정보의 내용이다.

어텐션의 과정은 주어진 쿼리와 모든 키의 유사도(similarity)를 계산하고, 이 유사도를 정규화하여 각 키에 대한 가중치(weight)를 얻은 다음, 이 가중치를 해당 값에 곱하여 가중합(weighted sum)을 구하는 방식으로 이루어진다. 이 가중합이 바로 어텐션의 출력, 즉 동적인 컨텍스트 벡터가 된다.1

Seq2Seq 모델의 맥락에서 이 개념은 다음과 같이 적용된다. 디코더의 특정 시점 은닉 상태가 '쿼리'($q$)의 역할을 하고, 인코더의 모든 시점에서의 은닉 상태들이 '키'($k_i$)와 '값'($v_i$)의 역할을 동시에 수행한다.3 이 경우, 컨텍스트 벡터 $c$는 다음과 같은 수식으로 표현된다. 여기서 $\alpha_i$는 어텐션 가중치이며, 모든 가중치의 합은 1이 되는 볼록 조합(convex combination)을 형성한다.5
$$
c = \sum_{i} \alpha_{i} v_{i} \quad \text{where} \quad \sum_{i} \alpha_{i} = 1, \alpha_{i} \ge 0
$$

### 2.2  바다나우(Bahdanau) 어텐션: 가법(Additive) 어텐션

Dzmitry Bahdanau 연구팀이 2014년 논문 "Neural Machine Translation by Jointly Learning to Align and Translate"에서 제안한 어텐션 메커니즘은 최초의 성공적인 모델 중 하나로 평가받는다.4 이 방식의 핵심은 쿼리와 키 간의 유사도 점수, 즉 정렬 점수(alignment score)를 계산하기 위해 작은 피드포워드 신경망(feed-forward neural network)을 공동으로 학습시킨다는 점이다.

바다나우 어텐션은 점수를 계산할 때 디코더의 **이전 시점($t-1$)** 은닉 상태 $s_{t-1}$과 인코더의 각 은닉 상태 $h_i$를 사용한다.3 두 벡터를 각각 선형 변환한 후 더하고, 하이퍼볼릭 탄젠트($\tanh$) 활성화 함수를 통과시킨 뒤, 다시 한번 선형 변환하여 최종 점수를 계산한다. 이 과정에서 덧셈 연산이 포함되기 때문에 '가법(Additive) 어텐션' 또는 두 벡터를 결합(concatenate)하는 형태로 구현되기도 하여 '결합(Concat) 어텐션'이라고도 불린다.3

점수 함수 $e_{t,i}$는 다음과 같이 정의된다. 여기서 $v_a$, $W_a$, $U_a$는 학습 가능한 가중치 행렬이다.
$$
e_{t,i} = \text{score}(s_{t-1}, h_i) = v_a^T \tanh(W_a s_{t-1} + U_a h_i)
$$
이렇게 계산된 모든 점수 $e_t$에 소프트맥스(softmax) 함수를 적용하여 합이 1이 되는 어텐션 가중치 벡터 $\alpha_t$를 얻는다.3
$$
\alpha_t = \text{softmax}(e_t)
$$

### 2.3  루옹(Luong) 어텐션: 곱셈(Multiplicative) 어텐션

Minh-Thang Luong 연구팀은 2015년 논문 "Effective Approaches to Attention-based Neural Machine Translation"에서 바다나우 어텐션을 단순화하고 효율성을 높인 새로운 방식을 제안했다.6 루옹 어텐션은 점수 계산을 위해 별도의 신경망 대신 내적(dot product)과 같은 간단한 행렬 곱셈 연산을 사용한다. 이 때문에 '곱셈(Multiplicative) 어텐션'이라고 불린다.6

구조적으로 가장 큰 차이점은 점수 계산 시 디코더의 **현재 시점($t$)** 은닉 상태 $s_t$를 사용한다는 것이다.3 이는 디코더가 현재 자신의 상태를 기준으로 입력 시퀀스와의 관련성을 평가하게 하므로 더 직관적이고 최신 정보를 반영할 수 있다.9 루옹은 다음과 같은 여러 점수 함수를 제안했다.6

- **Dot:** $s_t$와 $h_i$의 단순 내적을 사용한다. 가장 간단한 형태이다.
  $$
  \text{score}(s_t, h_i) = s_t^T h_i
  $$

- **General:** 학습 가능한 가중치 행렬 $W_a$를 중간에 추가하여 표현력을 높인다.
  $$
  \text{score}(s_t, h_i) = s_t^T W_a h_i
  $$

- **Concat:** 바다나우 방식과 유사하게 두 벡터를 결합하지만, $s_t$를 사용하고 연산이 더 단순하다.
  $$
  \text{score}(s_t, h_i) = v_a^T \tanh(W_a [s_t; h_i])
  $$

### 2.4  비교 분석

바다나우와 루옹 어텐션은 동적 컨텍스트 벡터를 생성한다는 공통된 목표를 공유하지만, 점수 계산 방식의 복잡성과 디코더 은닉 상태 사용 시점에서 명확한 차이를 보인다.7 바다나우 방식은 학습 가능한 신경망을 통해 더 복잡하고 미묘한 정렬 관계를 학습할 잠재력이 있지만, 더 많은 파라미터와 계산 비용을 요구한다.8 반면 루옹 방식은 더 간단하고 계산적으로 효율적이어서 구현과 학습이 용이하다.9

이러한 초기 어텐션 메커니즘의 발전은 '더 복잡하고 표현력 있는' 방향보다는, '충분히 효과적이면서도 극도로 효율적인' 방향으로 진행되었음을 보여준다. 바다나우의 학습 기반 정렬 모델에서 루옹의 간결한 곱셈 기반 점수 계산으로의 전환은, 이후 트랜스포머의 스케일드 닷-프로덕트 어텐션에서 정점에 달하는 연구 흐름의 시작점이었다.

| 특징 (Feature)                                             | 바다나우(Bahdanau) 어텐션                                    | 루옹(Luong) 어텐션                                           |
| ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **별칭 (Alias)**                                           | Additive Attention                                           | Multiplicative Attention                                     |
| **점수 계산 함수 (Score Function)**                        | 학습 가능한 신경망 사용 <br />$score(s_{t-1}, h_i) = v_a^T \tanh(W_a s_{t-1} + U_a h_i)$ | 주로 내적 기반 연산 사용<br />• Dot: $s_t^T h_i$<br />• General: $s_t^T W_a h_i$ |
| **디코더 은닉 상태 (Decoder Hidden State)**                | 이전 시점의 은닉 상태 $s_{t-1}$ 사용                         | 현재 시점의 은닉 상태 $s_t$ 사용                             |
| **계산 복잡도 (Computational Complexity)**                 | 상대적으로 높음 (신경망 연산)                                | 상대적으로 낮음 (행렬 곱)                                    |
| **컨텍스트 벡터와 결합 (Integration with Context Vector)** | 컨텍스트 벡터 $c_t$가 다음 은닉 상태 $s_t$ 계산의 입력으로 사용됨 | 컨텍스트 벡터 $c_t$가 $s_t$와 결합되어 최종 예측에 사용됨    |
| **핵심 아이디어 (Core Idea)**                              | 정렬(alignment)을 공동으로 학습                              | 효율적인 점수 계산 함수 제공                                 |

## 3.  트랜스포머: 어텐션만으로 구성된 아키텍처

### 3.1  순환 구조의 탈피와 셀프 어텐션

2017년, Vaswani 연구팀은 "Attention Is All You Need"라는 기념비적인 논문을 통해 RNN이나 CNN과 같은 순환적이거나 합성곱적인 구조 없이, 오직 어텐션 메커니즘만으로 최첨단 성능의 Seq2Seq 모델을 구현할 수 있음을 증명했다.6 이 모델이 바로 트랜스포머(Transformer)이다.

기존 RNN 모델의 가장 큰 한계 중 하나는 순차적인 계산 방식이었다. 각 시점의 계산은 이전 시점의 계산이 완료되어야만 시작될 수 있었기 때문에, GPU와 같은 병렬 연산 장치의 이점을 온전히 활용하기 어려웠다.11 트랜스포머는 이러한 순환 구조를 완전히 제거하고, 대신 '셀프 어텐션(Self-Attention)'이라는 메커니즘을 도입하여 모든 입력 토큰을 동시에 병렬적으로 처리할 수 있게 했다.10

셀프 어텐션은 하나의 시퀀스 내에서 각 단어가 다른 모든 단어들과의 관계를 직접 계산하여 해당 단어의 문맥적 표현을 업데이트하는 메커니즘이다. 즉, 쿼리, 키, 값이 모두 동일한 입력 시퀀스로부터 파생된다.4 예를 들어, "The animal didn't cross the street because **it** was too tired"라는 문장에서 셀프 어텐션은 대명사 'it'이 'animal'을 참조한다는 사실을 직접적인 연결을 통해 학습할 수 있다.

이러한 구조는 시퀀스를 선형 체인(RNN)이나 지역적 그리드(CNN)가 아닌, 모든 노드가 서로 연결된 완전 그래프(fully connected graph)로 간주하는 것과 같다. 이로 인해 두 토큰 간의 정보 전달 경로 길이가 항상 1이 되어, RNN이 고질적으로 겪었던 장거리 의존성 문제를 효과적으로 해결할 수 있었다.

### 3.2  스케일드 닷-프로덕트 어텐션

트랜스포머에서 사용하는 셀프 어텐션의 구체적인 형태를 '스케일드 닷-프로덕트 어텐션(Scaled Dot-Product Attention)'이라 한다. 이는 루옹 어텐션의 'Dot' 방식과 기본적으로 동일하지만, 안정적인 학습을 위한 스케일링(scaling) 요소가 추가된 것이 특징이다.10

수식은 다음과 같다. 여기서 $Q$, $K$, $V$는 각각 쿼리, 키, 값 행렬을 의미하며, $d_k$는 키(그리고 쿼리) 벡터의 차원이다.14
$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$
여기서 스케일링 팩터 $\sqrt{d_k}$는 매우 중요한 역할을 한다. 키 벡터의 차원 $d_k$가 커질수록 내적 연산 $QK^T$의 결과값의 분산도 $d_k$에 비례하여 커지는 경향이 있다. 이 값이 너무 커지면 소프트맥스 함수의 입력으로 전달되었을 때, 함수가 포화(saturate)되어 그래디언트가 거의 0에 가까워지는 문제가 발생한다. 이는 학습을 매우 불안정하게 만들거나 사실상 멈추게 할 수 있다. 따라서 내적값을 $\sqrt{d_k}$로 나누어 줌으로써 분산을 1 근처로 안정화시키고, 그래디언트가 원활하게 흐르도록 하여 안정적인 모델 학습을 가능하게 한다.10

### 3.3  멀티-헤드 어텐션

트랜스포머는 단일 어텐션을 한 번 수행하는 대신, '멀티-헤드 어텐션(Multi-Head Attention)'이라는 기법을 사용하여 모델의 표현력을 극대화한다. 이는 $h$개의 어텐션 '헤드(head)'를 병렬적으로 사용하여, 서로 다른 관점에서 정보의 관계를 학습하도록 하는 방식이다.10

멀티-헤드 어텐션은 먼저 입력되는 쿼리, 키, 값 행렬을 각각 서로 다른 $h$개의 학습 가능한 선형 변환(linear projection)을 통해 저차원의 부분 공간(subspace)으로 투영한다. 그 후, 각 헤드는 이 투영된 $Q, K, V$를 사용하여 독립적으로 스케일드 닷-프로덕트 어텐션을 수행한다.16 각 헤드의 출력 결과들은 모두 연결(concatenate)된 후, 마지막으로 다시 한번 선형 변환을 거쳐 최종 출력을 생성한다.

이러한 구조는 모델이 다양한 위치의 다양한 표현 부분 공간으로부터 정보를 동시에 주목할 수 있게 하는 강력한 장점을 제공한다.10 예를 들어, 어떤 헤드는 문장 내에서 주어-동사 관계와 같은 구문적 관계에 집중하고, 다른 헤드는 동의어 관계와 같은 의미적 유사성에 집중하는 등 전문화된 역할을 학습할 수 있다. 단일 어텐션이 모든 관계를 하나의 가중치 집합으로 평균내어 표현하려는 시도에서 놓칠 수 있는 다채로운 정보를 포착하는 것이다.10 이는 마치 여러 전문가가 각자의 전문 분야에서 데이터를 분석하고 그 결과를 종합하는 것과 같은 일종의 모델 내 앙상블(internal ensemble) 효과를 낳아, 더 풍부하고 강건한 표현 학습을 가능하게 한다.

## 4.  위치 정보의 보존: 위치 인코딩

### 4.1  비순환적 모델의 순서 정보 부재 문제

트랜스포머는 RNN과 달리 순환 구조를 사용하지 않고 입력 토큰들을 병렬적으로 처리한다. 이러한 설계는 엄청난 계산 효율성을 가져왔지만, 동시에 모델이 토큰의 순서 정보를 내재적으로 처리하지 못하는 문제를 야기했다.11 셀프 어텐션 메커니즘은 입력 시퀀스를 순서가 없는 '집합(set)'으로 취급하기 때문에, "Allen walks dog"와 "dog walks Allen"이라는 두 문장을 동일하게 인식하게 된다.11 문장의 의미는 단어의 순서에 크게 의존하므로, 모델에 각 토큰의 절대적 또는 상대적 위치 정보를 명시적으로 주입해줄 필요가 있다. 이 역할을 수행하는 것이 바로 '위치 인코딩(Positional Encoding)'이다.11

### 4.2  사인(Sinusoidal) 함수 기반 위치 인코딩

"Attention Is All You Need" 논문에서 제안된 위치 인코딩 방식은 주기 함수인 사인(sine)과 코사인(cosine) 함수를 사용한다.11 이 방법은 각 위치($\text{pos}$)와 임베딩 벡터의 각 차원($i$)에 대해 고유한 인코딩 값을 생성한다. 구체적으로, 임베딩 벡터의 짝수 차원에는 사인 함수를, 홀수 차원에는 코사인 함수를 적용하여 위치 벡터를 만든다.11
$$
PE_{(\text{pos}, 2i)} = \sin\left(\frac{\text{pos}}{10000^{2i/d_{\text{model}}}}\right)
$$

$$
PE_{(\text{pos}, 2i+1)} = \cos\left(\frac{\text{pos}}{10000^{2i/d_{\text{model}}}}\right)
$$

여기서 $d_{\text{model}}$은 모델의 임베딩 차원이다. 이렇게 생성된 위치 인코딩 벡터는 단어의 의미 정보를 담고 있는 입력 임베딩 벡터에 그대로 더해진다. 이 과정을 통해 최종적으로 모델에 입력되는 벡터는 단어의 의미 정보와 위치 정보를 모두 포함하게 된다.12

### 4.3  사인 함수를 사용하는 이유

사인 함수 기반 위치 인코딩은 여러 가지 유용한 특성을 지닌다. 첫째, 각 위치마다 고유한 인코딩 벡터가 생성되어 절대 위치를 표현할 수 있다.12 둘째, 특정 위치 

$\text{pos}+k$의 위치 인코딩은 $\text{pos}$ 위치의 인코딩에 대한 선형 변환으로 표현될 수 있다는 중요한 성질이 있다. 이는 모델이 토큰 간의 상대적인 거리 관계를 쉽게 학습할 수 있도록 돕는다.19 셋째, 이 방식은 학습 중에 보지 못했던 더 긴 시퀀스에 대해서도 위치 값을 생성하여 외삽(extrapolation)할 수 있는 능력을 제공한다.12

이러한 특성은 위치 인코딩이 단순한 인덱스가 아니라, 시퀀스 내에 일종의 '좌표계'를 부여하는 역할을 함을 시사한다. 임베딩의 저차원(i가 작을 때)에서는 주기가 긴 파동을 사용하여 전반적인 위치(coarse position)를 인코딩하고, 고차원(i가 클 때)에서는 주기가 짧은 파동을 사용하여 미세한 위치(fine position)를 인코딩한다. 이는 마치 지도에서 광역 주소와 상세 주소를 함께 사용하는 것과 같은 다중 해상도(multi-resolution) 표현 방식으로, 모델이 다양한 스케일의 위치 관계를 효과적으로 학습하도록 돕는다.11

## 5.  효율적 어텐션: 계산 복잡도 극복을 위한 접근법

### 5.1  셀프 어텐션의 이차 복잡도 문제 ($O(n^2)$)

트랜스포머의 셀프 어텐션은 강력한 성능을 제공하지만, 시퀀스 길이 $n$에 대해 $n \times n$ 크기의 어텐션 행렬을 계산해야 하므로 시간 및 메모리 복잡도가 $O(n^2)$에 달한다.20 이 이차 복잡도 문제는 시퀀스 길이가 수천 개 이상으로 길어지는 긴 문서 처리, 고해상도 이미지 생성, 장시간 비디오 분석 등의 태스크에서 심각한 계산 병목 현상을 유발한다.20 이 한계를 극복하기 위해 어텐션의 계산 효율성을 높이려는 다양한 연구가 진행되었으며, 크게 희소 어텐션과 선형 어텐션이라는 두 가지 방향으로 나뉜다.

### 5.2  희소 어텐션 (Sparse Attention): 계산 대상을 줄이는 접근

희소 어텐션은 모든 토큰 쌍 간의 관계를 계산하는 대신, 일부 '중요한' 토큰 쌍에 대해서만 어텐션을 계산하는 방식이다. 이는 어텐션 행렬을 대부분 0으로 채워진 희소(sparse) 행렬로 만드는 것과 같다.23 이 접근법은 "모든 정보가 동등하게 중요하지는 않다"는 강한 가정을 기반으로 하며, '선택과 집중' 전략으로 볼 수 있다.

대표적인 희소 어텐션 모델인 **롱포머(Longformer)**는 두 가지 어텐션 패턴을 결합하여 효율성을 달성한다.21

- **슬라이딩 윈도우 어텐션 (Sliding Window / Local Attention):** 대부분의 토큰은 자신의 주변에 위치한 고정된 크기($w$)의 윈도우 내 토큰들에만 어텐션을 수행한다. 이는 언어와 같은 데이터에서 대부분의 중요한 상호작용이 지역적으로 발생한다는 가정에 기반한다.26
- **글로벌 어텐션 (Global Attention):** `<s>` 토큰과 같이 문장 전체의 정보를 요약해야 하거나, 질의응답 태스크에서 질문에 해당하는 토큰처럼 일부 중요한 토큰들은 시퀀스 전체에 대해 어텐션을 수행하도록 지정한다. 이를 통해 지역적 정보와 전역적 정보를 모두 효과적으로 포착할 수 있다.25

이 두 가지 패턴을 결합함으로써, 롱포머는 전체 계산 복잡도를 $O(n \cdot w)$로 줄여 사실상 시퀀스 길이에 대한 선형 복잡도 $O(n)$을 달성한다.21 이 외에도 일정 간격으로 떨어진 토큰에 주목하는 스트라이드 어텐션(Strided Attention)이나 간격을 점차 넓혀가며 어텐션을 수행하는 확장 어텐션(Dilated Attention) 등 다양한 희소 패턴이 제안되었다.22

### 5.3  선형 어텐션 (Linear Attention): 계산 방식을 바꾸는 접근

선형 어텐션은 어텐션 행렬 자체를 직접 계산하는 대신, 수학적 근사(approximation)를 통해 계산 과정을 변형하여 복잡도를 줄이는 방식이다. 이 접근법은 "모든 정보가 어느 정도는 관련이 있지만, 그 전체적인 상호작용 패턴은 더 단순하게 표현될 수 있다"는 가정을 기반으로 하며, '전체와 근사' 전략으로 볼 수 있다.

대표적인 모델인 **린포머(Linformer)**는 $n \times n$ 크기의 어텐션 행렬이 실제로는 저계급(low-rank) 행렬로 근사될 수 있다는 이론적 관찰에서 출발한다.30 기존 어텐션 계산식 $\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V$에서 병목은 $QK^T$ 연산이다. 린포머는 키($K$)와 값($V$) 행렬에 $n \times k$ 크기의 공유된 선형 투영(linear projection) 행렬을 곱하여, 이들을 $k \times d$ 차원으로 축소한다 (단, $k \ll n$). 그 후, 이 축소된 차원에서 어텐션을 계산함으로써 전체 복잡도를 $O(n \cdot k)$, 즉 선형 복잡도 $O(n)$으로 줄인다.31

이 외에도 소프트맥스 함수를 커널 함수로 근사하여 선형 복잡도를 달성하는 Performer나 RFA(Random Feature Attention)와 같은 기법들도 선형 어텐션의 범주에 속한다.23

| 특징 (Feature)                        | 희소 어텐션 (Sparse Attention)                               | 선형 어텐션 (Linear Attention)                               |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **핵심 철학 (Core Philosophy)**       | 계산 대상을 선별적으로 **제한** (Pruning)                    | 계산 방식을 효율적으로 **근사** (Approximation)              |
| **기본 가정 (Underlying Assumption)** | 대부분의 토큰 쌍은 상호작용이 미미하다.                      | 전체 어텐션 행렬은 저계급(low-rank)이다.                     |
| **복잡도 (Complexity)**               | $O(n \log n)$ 또는 $O(n)$ (패턴에 따라 다름)                 | $O(n)$                                                       |
| **대표 모델 (Key Models)**            | Longformer, Sparse Transformer, BigBird                      | Linformer, Performer, RFA                                    |
| **장점 (Advantages)**                 | 중요한 토큰 쌍에 대해서는 정확한 어텐션 계산. 지역성 등 사전 지식 활용 가능. | 모든 토큰 쌍 간의 정보를 (근사적으로) 고려.                  |
| **단점 (Disadvantages)**              | 희소 패턴 설계가 태스크에 의존적일 수 있음. 하드웨어 최적화가 어려울 수 있음. | 근사 과정에서 정보 손실 가능성. 미세한 상호작용 포착에 불리할 수 있음. |

이 두 가지 상반된 철학은 근본적인 트레이드오프를 가진다. 희소 어텐션은 중요한 정보를 놓칠 위험이 있고, 선형 어텐션은 모든 정보의 정밀도를 조금씩 잃을 위험이 있다. 따라서 특정 태스크에 어떤 방식이 더 적합한지는 데이터의 특성과 요구되는 정밀도 수준에 따라 달라지며, 최신 연구는 이 둘을 결합하는 하이브리드 모델로 나아가고 있다.23

## 6.  어텐션의 확장: 자연어 처리를 넘어

### 6.1  비전 트랜스포머 (Vision Transformer, ViT)의 등장

어텐션 메커니즘, 특히 트랜스포머 아키텍처의 성공은 자연어 처리(NLP) 분야에만 국한되지 않았다. 2020년, 구글 연구팀은 트랜스포머를 컴퓨터 비전 분야에 성공적으로 적용한 '비전 트랜스포머(Vision Transformer, ViT)'를 발표하며, 어텐션의 범용성을 입증했다. 이는 기존에 합성곱 신경망(CNN)이 지배적이던 비전 분야에 새로운 패러다임을 제시한 중요한 사건이었다.

### 6.2  ViT의 핵심 아이디어: 이미지를 패치 시퀀스로

ViT의 핵심 아이디어는 이미지를 NLP의 '문장'처럼, 즉 토큰의 시퀀스로 취급하는 것이다. 이를 위해 ViT는 다음과 같은 과정을 거친다.35

1. **이미지 패치화(Patchification):** 입력 이미지를 겹치지 않는 고정된 크기(예: $16 \times 16$ 픽셀)의 여러 '패치(patch)'로 분할한다.
2. **패치 임베딩(Patch Embedding):** 각 패치를 평탄화(flatten)하여 1차원 벡터로 만들고, 학습 가능한 선형 변환을 통해 모델의 차원에 맞는 벡터로 투영한다. 이는 NLP에서 단어를 워드 임베딩으로 변환하는 과정과 유사하다.35
3. **위치 임베딩 추가:** 패치의 순서 정보를 제공하기 위해, 각 패치 임베딩에 학습 가능한 위치 임베딩(positional embedding)을 더해준다. 이는 트랜스포머의 위치 인코딩과 동일한 역할을 한다.36
4. **트랜스포머 인코더 입력:** 이렇게 처리된 패치 임베딩 시퀀스를 표준 트랜스포머 인코더에 입력한다. 인코더 내의 셀프 어텐션은 이미지 내 모든 패치들 간의 전역적인 관계를 학습한다.
5. **분류:** 최종적으로, NLP의 `<s>` 토큰과 유사한 역할을 하는 별도의 학습 가능한 토큰의 출력 표현을 사용하여 이미지 분류와 같은 다운스트림 태스크를 수행한다.35

### 6.3  ViT의 함의

ViT의 성공은 어텐션 메커니즘이 특정 데이터 도메인에 국한되지 않는 매우 일반적인 학습 메커니즘임을 입증했다. CNN은 이미지 데이터에 내재된 '지역적 공간 구조(local spatial structure)'라는 강한 사전 지식(inductive bias)을 활용하여 효율적으로 학습한다. 반면, ViT는 이미지를 단순히 패치의 집합으로 간주함으로써 이러한 강한 가정을 최소화했다. 모델은 셀프 어텐션을 통해 데이터 자체로부터 어떤 패치가 서로 관련 있는지, 즉 이미지의 내재적 구조를 처음부터 학습한다.

이는 어텐션이 데이터의 종류나 형태에 구애받지 않고, 구성 요소들 간의 관계를 학습하는 매우 유연하고 강력한 도구임을 시사한다. 대규모 데이터셋으로 사전 학습할 경우, CNN의 사전 지식 없이도 뛰어난 성능을 보일 수 있다는 점은 이러한 유연성의 강력한 증거이다.36 결과적으로, ViT는 데이터를 적절한 '시퀀스' 형태로만 변환할 수 있다면 트랜스포머 아키텍처를 음성, 비디오, 유전체 등 다양한 분야에 적용할 수 있는 길을 열었다.27

## 7.  결론: 어텐션 메커니즘의 현재와 미래 전망

### 7.1. 어텐션 메커니즘의 발전 과정 요약

어텐션 메커니즘은 RNN 기반 Seq2Seq 모델의 정보 병목 문제를 해결하기 위한 보조적인 장치로 처음 등장했다. 그러나 그 잠재력은 곧바로 입증되었고, "Attention Is All You Need" 논문을 통해 순환 구조를 완전히 대체하며 트랜스포머 아키텍처의 핵심 구성 요소로 자리 잡았다. 이후 셀프 어텐션의 $O(n^2)$ 계산 복잡도 문제를 해결하기 위한 희소 어텐션과 선형 어텐션 연구가 활발히 진행되었으며, 이는 모델이 처리할 수 있는 데이터의 규모와 길이를 극적으로 확장시켰다. 나아가 ViT의 등장은 어텐션이 NLP를 넘어 컴퓨터 비전 등 다양한 도메인으로 성공적으로 확장될 수 있는 범용적인 메커니즘임을 증명했다.

### 7.1  현재 연구 동향과 미래 전망

어텐션 메커니즘은 오늘날 대규모 언어 모델(LLM)을 비롯한 최첨단 인공지능 모델의 근간을 이루고 있으며, 그 진화는 현재도 계속되고 있다. 미래의 어텐션 메커니즘은 다음과 같은 방향으로 발전할 것으로 전망된다.

- **효율성의 극대화:** 더 긴 컨텍스트를 더 빠르고 적은 메모리로 처리하기 위한 효율화 연구는 계속될 것이다. SparseK Attention, Tensorized Attention과 같이 하드웨어 친화적이면서도 성능을 유지하는 새로운 어텐션 변종들이 지속적으로 제안되고 있다.37
- **하이브리드 아키텍처:** 순수 어텐션 모델이 갖는 이차 복잡도나 특정 데이터 패턴에 대한 약점을 보완하기 위해, 어텐션과 다른 메커니즘(예: 상태 공간 모델(SSM), 순환 구조)을 결합하려는 시도가 주목받고 있다.20 이는 각 메커니즘의 장점을 취하여 더 강건하고 효율적인 모델을 만들려는 노력이다.
- **동적 아키텍처:** 모든 토큰에 동일한 양의 계산을 고정적으로 적용하는 대신, 입력 데이터의 복잡도나 중요도에 따라 계산량을 동적으로 조절하는 아키텍처가 부상하고 있다. 각 토큰이 필요한 어텐션 헤드를 선택적으로 활성화하는 Mixture-of-Head Attention과 같은 기법은 모델의 추론 효율성을 크게 향상시킬 잠재력을 가진다.17

결론적으로, 어텐션 메커니즘은 지난 10년간 딥러닝 분야, 특히 순차 데이터 처리 방식에 혁명을 일으켰다. 앞으로도 어텐션은 대규모 모델 아키텍처의 핵심 원리로 남을 것이며, 더 효율적이고, 더 일반적이며, 더 동적인 형태로 끊임없이 진화하며 인공지능 기술의 발전을 이끌어 나갈 것이다.

#### 참고 자료

1. ML - Attention mechanism - GeeksforGeeks, accessed August 15, 2025, https://www.geeksforgeeks.org/artificial-intelligence/ml-attention-mechanism/
2. Attention Mechanism in Deep Learning - Analytics Vidhya, accessed August 15, 2025, https://www.analyticsvidhya.com/blog/2019/11/comprehensive-guide-attention-mechanism-deep-learning/
3. Attention in RNN-based NMT - Engineering AI Agents, accessed August 15, 2025, https://pantelis.github.io/aiml-common/lectures/nlp/nmt/rnn-nmt-attention/
4. The Attention Mechanism from Scratch - MachineLearningMastery ..., accessed August 15, 2025, https://machinelearningmastery.com/the-attention-mechanism-from-scratch/
5. 11.1. Queries, Keys, and Values - Dive into Deep Learning 1.0.3 documentation, accessed August 15, 2025, https://d2l.ai/chapter_attention-mechanisms-and-transformers/queries-keys-values.html
6. Introduction to Attention Mechanism: Bahdanau and Luong Attention | by Ching (Chingis) | Artificial Intelligence in Plain English, accessed August 15, 2025, https://ai.plainenglish.io/introduction-to-attention-mechanism-bahdanau-and-luong-attention-e2efd6ce22da
7. What is the difference between Luong attention and Bahdanau attention? - Stack Overflow, accessed August 15, 2025, https://stackoverflow.com/questions/44238154/what-is-the-difference-between-luong-attention-and-bahdanau-attention
8. Differences Between Luong Attention and Bahdanau Attention ..., accessed August 15, 2025, https://www.baeldung.com/cs/attention-luong-vs-bahdanau
9. Everything about Attention mechanism (Bahdanau Attention and Luong Attention) | by Abhishek Jain | Medium, accessed August 15, 2025, https://medium.com/@abhishekjainindore24/everything-about-attention-mechanism-bahdanau-attention-and-luong-attention-f76e63b702ca
10. Attention is All you Need - NIPS, accessed August 15, 2025, https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf
11. What is Positional Encoding? | IBM, accessed August 15, 2025, https://www.ibm.com/think/topics/positional-encoding
12. Positional Encoding in Transformers - GeeksforGeeks, accessed August 15, 2025, https://www.geeksforgeeks.org/nlp/positional-encoding-in-transformers/
13. Understanding Scaled Dot-Product Attention in Transformer Models - Medium, accessed August 15, 2025, https://medium.com/@saraswatp/understanding-scaled-dot-product-attention-in-transformer-models-5fe02b0f150c
14. Multiscaled Multi-Head Attention-based Video Transformer Network for Hand Gesture Recognition - arXiv, accessed August 15, 2025, https://arxiv.org/html/2501.00935v1
15. Tensor Product Attention Is All You Need - arXiv, accessed August 15, 2025, https://arxiv.org/html/2501.06425v2
16. LLM Chronicles #4.7: Attention Mechanism for Neural Networks - YouTube, accessed August 15, 2025, https://www.youtube.com/watch?v=PaP_DKuZTBc
17. MoH: Multi-Head Attention as Mixture-of-Head Attention - arXiv, accessed August 15, 2025, https://arxiv.org/html/2410.11842v1
18. A Gentle Introduction to Positional Encoding in Transformer Models, Part 1, accessed August 15, 2025, https://www.cs.bu.edu/fac/snyder/cs505/PositionalEncodings.pdf
19. Positional Encoding in the Transformer Model | by Sandaruwan Herath - Medium, accessed August 15, 2025, https://medium.com/image-processing-with-python/positional-encoding-in-the-transformer-model-e8e9979df57f
20. Efficient Attention Mechanisms for Large Language Models: A Survey - ResearchGate, accessed August 15, 2025, https://www.researchgate.net/publication/394081373_Efficient_Attention_Mechanisms_for_Large_Language_Models_A_Survey
21. Longformer - transformers 3.0.2 documentation - Hugging Face, accessed August 15, 2025, https://huggingface.co/transformers/v3.0.2/model_doc/longformer.html
22. Day 29: Sparse Transformers: Efficient Scaling for Large Language ..., accessed August 15, 2025, https://dev.to/nareshnishad/day-29-sparse-transformers-efficient-scaling-for-large-language-models-59j5
23. Efficient Attention Mechanisms for Large Language Models ... - arXiv, accessed August 15, 2025, https://arxiv.org/pdf/2507.19595
24. Sparse Attention in Transformers: Step-by-Step Implementation - LLM Directory, accessed August 15, 2025, https://llmmodels.org/blog/sparse-attention-in-transformers-step-by-step-implementation/
25. Day 31: Longformer - Efficient Attention Mechanism for Long Documents - DEV Community, accessed August 15, 2025, https://dev.to/nareshnishad/day-31-longformer-efficient-attention-mechanism-for-long-documents-475j
26. Exploring Longformer - Scaler Topics, accessed August 15, 2025, https://www.scaler.com/topics/nlp/longformer/
27. Longformer: Long Sequence Transformer - Ultralytics, accessed August 15, 2025, https://www.ultralytics.com/glossary/longformer
28. Longformer - Hugging Face, accessed August 15, 2025, https://huggingface.co/docs/transformers/model_doc/longformer
29. Sparse Transformer: Stride and Fixed Factorized Attention - GeeksforGeeks, accessed August 15, 2025, https://www.geeksforgeeks.org/machine-learning/sparse-transformer-stride-and-fixed-factorized-attention/
30. [PDF] Linformer: Self-Attention with Linear Complexity | Semantic ..., accessed August 15, 2025, https://www.semanticscholar.org/paper/Linformer%3A-Self-Attention-with-Linear-Complexity-Wang-Li/c0b79e6a5fd88ef13aa4780df5aae0aaa6b2be87
31. lucidrains/linformer: Implementation of Linformer for Pytorch - GitHub, accessed August 15, 2025, https://github.com/lucidrains/linformer
32. Linformer: Making Transformers Linear, Efficient, and Scalable | by Ruhaan838 | Medium, accessed August 15, 2025, https://medium.com/@ruhaan838/linformer-making-transformers-linear-efficient-and-scalable-84f21880ea02
33. Linear Complexity Randomized Self-attention Mechanism - Proceedings of Machine Learning Research, accessed August 15, 2025, https://proceedings.mlr.press/v162/zheng22b/zheng22b.pdf
34. Efficient Attention Mechanisms for Large Language Models: A Survey - arXiv, accessed August 15, 2025, https://arxiv.org/html/2507.19595v1
35. Vision Transformer(ViT) Architecture Explained | Deep Learning Clips - YouTube, accessed August 15, 2025, https://www.youtube.com/watch?v=pYfCSkETYNI
36. Vision Transformer (ViT) Architecture Explained - YouTube, accessed August 15, 2025, https://www.youtube.com/watch?v=G2nUsjMrcuw
37. Long Sequence Modeling with Attention Tensorization - arXiv, accessed August 15, 2025, https://arxiv.org/html/2410.20926v1
38. Sparser is Faster and Less is More: Efficient Sparse Attention for Long-Range Transformers, accessed August 15, 2025, https://arxiv.org/html/2406.16747v1
