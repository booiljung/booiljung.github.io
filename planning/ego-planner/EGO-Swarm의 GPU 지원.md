# EGO-Swarm의 GPU 지원

## 서론

### 0.1 문제 제기: 다개체 로봇 시스템의 자율 비행 과제

쿼드로터 스웜(quadrotor swarm)과 같은 다개체 로봇 시스템이 외부의 도움 없이 미지의 복잡한 환경에서 자율적으로 임무를 수행하는 것은 현대 로봇 공학의 가장 도전적인 과제 중 하나로 남아있다. 이러한 시스템은 제한된 온보드(onboard) 연산 자원과 통신 대역폭 하에서 실시간으로 주변 환경을 인식하고, 동적으로 변화하는 상황에 맞춰 안전하고 효율적인 경로를 생성해야 한다. 특히, 다수의 에이전트가 밀집하여 비행할 경우, 정적 장애물 회피뿐만 아니라 개체 간의 상호 충돌을 방지하기 위한 정교한 협력 메커니즘이 필수적이다.

기존의 궤적 계획 시스템들은 이러한 복합적인 요구사항을 완전히 만족시키는 데 한계를 보여왔다. 중앙 집중식(centralized) 접근법은 모든 에이전트의 정보를 단일 주체가 처리하여 전역적으로 최적화된 해를 구할 수 있다는 장점이 있지만, 에이전트의 수가 증가함에 따라 연산량과 통신 부하가 기하급수적으로 증가하여 실시간성과 확장성에 심각한 제약을 받는다. 반면, 각 에이전트가 독립적으로 의사결정을 내리는 분산(decentralized) 접근법은 확장성이 뛰어나고 개별 에이전트의 빠른 반응을 가능하게 하지만, 에이전트 간의 효과적인 협력이 부족하여 전역적인 최적성을 보장하기 어렵거나 교착 상태(deadlock)에 빠질 위험이 있다. 이처럼 실시간성, 안전성, 확장성, 그리고 최적성 사이의 상충 관계(trade-off)는 다개체 자율 비행 기술 발전의 핵심적인 난제로 작용해왔다.

### 0.2 EGO-Swarm의 등장과 연구 동향

이러한 기술적 난제를 해결하기 위한 노력의 일환으로, Zhejiang University의 FAST Lab은 EGO-Swarm이라는 획기적인 프레임워크를 제안하였다. EGO-Swarm은 완전한 분산 및 비동기 방식으로 작동하는 쿼드로터 스웜 시스템으로, 외부의 위치 측정 시스템이나 사전 제작된 지도 없이 오직 온보드 센서와 연산 자원만을 사용하여 복잡하고 장애물이 많은 미지의 환경에서 자율 비행을 가능하게 한다.

이 시스템은 연구팀이 이전에 발표하여 그 성능을 입증한 단일 에이전트 플래너인 EGO-Planner(ESDF-free Gradient-based lOcal planner)를 다개체 환경으로 성공적으로 확장한 것이다. EGO-Swarm의 핵심은 경사 하강법(gradient-based) 기반의 지역 궤적 최적화와 경량화된 위상학적 경로 생성 기법을 결합하여, 각 에이전트가 단 몇 밀리초(milliseconds) 만에 안전하고 부드러우며 동역학적으로 실행 가능한 궤적을 생성할 수 있도록 한 데 있다. 2021년 국제 로봇 자동화 학회(ICRA)에 발표된 이 연구는, 불안정한 통신 환경에서도 강건하게 작동하는 분산형 스웜 시스템의 새로운 가능성을 제시하며 학계와 산업계의 큰 주목을 받았다.

### 0.3 보고서의 목적 및 구성

본 보고서는 EGO-Swarm 프레임워크 내에서 그래픽 처리 장치(GPU), 특히 NVIDIA의 CUDA(Compute Unified Device Architecture) 기술이 구체적으로 어떻게 활용되고 있는지를 기술적으로 심층 분석하는 것을 목표로 한다. 이 분석은 단순히 소스 코드에 존재하는 GPU 관련 기능의 유무를 확인하는 수준을 넘어선다. EGO-Swarm 개발팀이 왜 현재와 같은 방식으로 GPU를 활용하도록 설계했는지, 이러한 설계적 선택이 시스템 전체의 성능, 개발 과정, 그리고 이식성에 어떠한 실질적인 영향을 미치는지 그 이면에 숨겨진 공학적 철학과 트레이드오프를 고찰하고자 한다.

나아가, 본 보고서는 EGO-Swarm의 현재 GPU 활용 방식을 로봇 공학 분야, 특히 다개체 궤적 최적화 분야에서 활발히 연구되고 있는 광범위한 GPU 가속 기술 동향과 비교 분석할 것이다. 이를 통해 EGO-Swarm이 현재 지닌 잠재적 성능 한계를 명확히 하고, 향후 GPU의 막대한 병렬 처리 능력을 보다 적극적으로 활용하여 시스템의 성능을 한 차원 더 높은 수준으로 끌어올리기 위한 구체적인 확장 가능성과 미래 연구 방향을 제시한다. 보고서는 서론에 이어 EGO-Swarm의 핵심 아키텍처, GPU 활용에 대한 기술적 분석, 성능 및 실효성 고찰, 관련 분야의 GPU 가속 동향 비교, 그리고 결론 및 제언의 순서로 구성된다.

## 1. EGO-Swarm의 아키텍처 및 핵심 원리

EGO-Swarm의 혁신적인 성능은 세 가지 핵심적인 설계 원리의 유기적인 결합에 기반한다: ESDF-Free 경사 하강법, B-스플라인 기반 궤적 표현, 그리고 분산 및 비동기 스웜 협력. 이 원리들은 상호 보완적으로 작동하며 시스템의 연산 효율성과 강건성을 극대화한다.

### 1.1 경사 하강법 기반의 지역 궤적 계획

#### 1.1.1 ESDF-Free 접근법

전통적인 경사 하강법 기반의 궤적 플래너들은 주변 환경의 장애물로부터의 거리를 나타내는 ESDF(Euclidean Signed Distance Field) 맵에 크게 의존해왔다. ESDF는 궤적상의 특정 지점에서 장애물까지의 최단 거리와 그 방향(경사도)을 즉시 제공하여 충돌 비용과 그 기울기를 계산하는 데 매우 유용하다. 그러나 ESDF를 생성하고 유지하는 과정은 상당한 연산 비용을 수반한다. 특히, 맵의 전체 또는 넓은 영역에 대해 거리 값을 계산해야 하므로, 실제 궤적 최적화 과정에서 사용되는 영역이 전체 맵의 극히 일부에 불과함에도 불구하고 과도한 연산 자원이 낭비되는 비효율성이 존재했다.

EGO-Planner와 이를 계승한 EGO-Swarm은 이러한 병목 현상을 해결하기 위해 'ESDF-Free'라는 과감한 접근법을 채택했다. 이 접근법은 ESDF 맵을 사전에 구축하는 대신, 최적화 과정에서 궤적이 실제로 장애물과 충돌하는 경우에만 해당 지점의 장애물 정보를 동적으로 추출하여 활용한다. 구체적으로, 현재 최적화 중인 궤적이 장애물과 충돌하면, 그 충돌 지점 정보를 바탕으로 충돌을 회피하는 방향으로 궤적을 밀어내는 패널티를 계산한다. 이 방식은 최적화에 반드시 필요한 정보만을 최소한으로 계산함으로써, ESDF 생성에 소요되던 막대한 연산 시간을 절약하고 전체 계획 시간을 수 밀리초 단위로 단축시키는 데 결정적인 역할을 했다.

#### 1.1.2 비선형 최적화 문제 공식화

EGO-Swarm은 궤적 계획 문제를 수학적으로 잘 정의된 비선형 최적화(Nonlinear Optimization) 문제로 공식화한다. 이는 목표 지점으로 향하면서 궤적의 평활성(smoothness), 안전성(safety), 그리고 동역학적 실행 가능성(dynamic feasibility)을 종합적으로 고려하는 비용 함수($J$)를 정의하고, 이 비용을 최소화하는 궤적을 찾는 과정이다. 비용 함수는 일반적으로 다음과 같은 항들의 가중치 합으로 구성된다.
$$
J = w_{smooth}J_{smooth} + w_{collision}J_{collision} + w_{feasibility}J_{feasibility} + \dots
$$
여기서 $J_{smooth}$는 궤적의 부드러움을, $J_{collision}$은 장애물 및 다른 에이전트와의 충돌 위험을, $J_{feasibility}$는 드론의 물리적 한계(최대 속도, 가속도 등) 준수 여부를 나타낸다. 각 항의 가중치 $w$를 조절하여 계획의 우선순위를 결정할 수 있다.

#### 1.1.3 패널티 함수 기반 충돌 회피

EGO-Swarm의 충돌 회피 메커니즘의 핵심은 충돌 위험을 비용 함수 내의 패널티 항($J_{collision}$)으로 공식화하는 것이다. 궤도가 장애물이나 다른 에이전트의 안전 반경을 침범할 경우, 침범 깊이에 비례하는 높은 패널티 값을 비용 함수에 더한다. 경사 하강법 기반의 최적화기는 이 패널티 값을 줄이는 방향, 즉 충돌 지점에서 멀어지는 방향으로 기울기(gradient)를 계산하고 궤적을 수정한다. 이 '부드러운(soft)' 제약 조건 방식은 충돌을 명시적인 '단단한(hard)' 제약 조건으로 다루는 것보다 최적화 문제를 더 용이하게 만들며, 최적화 과정에서 자연스럽게 안전한 회피 경로를 탐색하도록 유도한다.

### 1.2 B-스플라인 기반 궤적 표현

#### 1.2.1 궤적의 수학적 표현

EGO-Swarm은 쿼드로터의 4차원(3차원 공간 + 시간) 궤적을 표현하기 위해 균일 B-스플라인(Uniform B-spline)을 사용한다. B-스플라인 곡선은 일련의 제어점(control points) $Q_0, Q_1, \dots, Q_n$과 기저 함수(basis functions) $B_{i,p}(t)$의 선형 결합으로 정의된다.
$$
\mathbf{p}(t) = \sum_{i=0}^{n} \mathbf{Q}_i B_{i,p}(t)
$$
여기서 $\mathbf{p}(t)$는 시간 $t$에서의 궤적 위치이며, $p$는 B-스플라인의 차수(degree)를 의미한다. B-스플라인은 몇 가지 중요한 수학적 특성을 지닌다. 첫째, 궤적 전체의 평활성이 제어점의 위치만으로 결정되며, 특정 차수 이상의 B-스플라인은 고계 도함수(속도, 가속도, 저크 등)의 연속성을 보장한다. 이는 급격한 움직임 변화 없이 부드러운 비행을 요구하는 쿼드로터의 동역학적 제약을 만족시키는 데 매우 유리하다.

#### 1.2.2 최적화 변수

B-스플라인 표현을 사용하면 궤적 전체를 기술하는 복잡한 함수 대신, 유한한 개수의 제어점 $Q_i$들의 위치만을 최적화 변수로 삼을 수 있다. 이는 최적화 문제의 차원을 크게 줄여 계산 효율성을 높이는 핵심적인 요인이다. 최적화기는 비용 함수 $J$를 최소화하는 제어점들의 새로운 위치를 찾고, 이로부터 새로운 B-스플라인 궤적이 생성된다.

#### 1.2.3 볼록 포 특성

B-스플라인 곡선의 또 다른 중요한 성질은 '볼록 포(Convex Hull)' 특성이다. 이는 곡선의 각 구간이 해당 구간에 영향을 미치는 제어점들이 형성하는 볼록 다각형(볼록 포) 내부에 반드시 존재한다는 것을 의미한다. 이 특성은 충돌 검사를 매우 효율적으로 만든다. 궤적 전체에 대해 충돌 검사를 수행하는 대신, 제어점들의 볼록 포가 장애물과 겹치는지 여부만 확인하면 되기 때문이다. 따라서 충돌 회피 제약 조건을 제어점의 위치에 대한 제약 조건으로 단순화하여 최적화 과정에 쉽게 통합할 수 있다.

### 1.3 분산 및 비동기적 스웜 협력

#### 1.3.1 탈중앙화 (Decentralization)

EGO-Swarm은 중앙 관제 서버 없이 각 에이전트가 완전히 독립적으로 작동하는 탈중앙화 아키텍처를 채택했다. 각 드론은 자신의 온보드 컴퓨터를 사용하여 주변 환경을 감지하고, 자신의 궤적을 계획하며, 다른 에이전트와 직접 통신한다. 이러한 설계는 시스템의 강건성을 크게 향상시킨다. 만약 중앙 서버가 존재한다면, 서버의 고장은 전체 스웜의 마비로 이어지는 단일 실패 지점(single point of failure)이 될 수 있다. 탈중앙화 시스템에서는 일부 에이전트가 고장 나더라도 나머지 에이전트들이 임무를 계속 수행할 수 있다. 또한, 에이전트 수가 늘어나도 중앙 서버의 부하가 증가하지 않으므로 시스템의 확장성이 뛰어나다.

#### 1.3.2 비동기 (Asynchronicity)

EGO-Swarm의 또 다른 핵심 특징은 비동기적 통신 및 계획 메커니즘이다. 실제 무선 통신 환경은 신호 지연, 데이터 손실, 비일관적인 전송률 등 예측 불가능한 요소로 가득하다. 모든 에이전트가 동일한 시간에 정보를 교환하고 동시에 계획을 수립하는 동기식 시스템은 이러한 현실적인 통신 제약 하에서 구현하기가 매우 어렵다. EGO-Swarm은 이러한 문제를 해결하기 위해 비동기 방식을 도입했다. 각 에이전트는 다른 에이전트의 미래 궤적 정보를 수신하는 즉시, 동기화를 기다리지 않고 자신의 궤적 재계획(replanning)을 시작한다. 이 방식은 불안정하고 신뢰할 수 없는 통신 네트워크(unreliable trajectory sharing network) 환경에서도 스웜이 안정적으로 협력하며 비행할 수 있도록 보장하는 결정적인 요소이다.

EGO-Swarm의 성공은 이러한 세 가지 핵심 원리가 서로 맞물려 시너지를 창출한 결과로 볼 수 있다. 그 근간에는 연산 효율성과 시스템 강건성 사이의 긴밀한 인과관계가 자리 잡고 있다. 첫째, ESDF-free 접근법은 온보드 CPU의 연산 부담을 극적으로 줄여, 각 에이전트가 제한된 자원만으로도 실시간 궤적 최적화를 수행할 수 있는 기반을 마련했다. 둘째, 이렇게 확보된 귀중한 CPU 자원은 각 에이전트가 독립적으로, 그리고 매우 빠르게 B-스플라인 기반의 비선형 최적화를 수행할 수 있게 하는 원동력이 된다. 마지막으로, 개별 에이전트의 빠른 연산 능력은 다른 에이전트로부터의 정보가 예측 불가능한 시점에 비동기적으로 도착하더라도 즉각적으로 반응하여 수 밀리초 내에 재계획을 완료할 수 있게 한다. 이는 시스템 전체의 강건성과 반응성을 담보하는 핵심적인 능력이다. 결국, EGO-Swarm의 설계 철학은 '최소한의 필수 정보만을 사용한 초고속 지역 계획'이라는 아이디어를 분산 시스템 아키텍처에 효과적으로 접목시킨 것으로 요약할 수 있다. 이는 연산 효율성이라는 요소가 분산 및 비동기라는 시스템 아키텍처의 실현 가능성을 직접적으로 결정짓는 중요한 사례를 보여준다.

## 2. EGO-Swarm 내 GPU(CUDA) 활용의 기술적 분석

EGO-Swarm의 GPU 지원은 시스템의 핵심 기능보다는 특정 목적을 위해 설계된 보조적인 기능에 가깝다. 그 역할과 메커니즘을 이해하기 위해서는 소스 코드 구조, 특히 `local_sensing` 패키지와 `ENABLE_CUDA` 플래그의 상호작용을 면밀히 분석할 필요가 있다.

### 2.1 `local_sensing` 패키지와 `ENABLE_CUDA` 플래그의 역할

EGO-Swarm의 공식 GitHub 저장소와 그 전신인 EGO-Planner의 소스 코드를 분석하면, `local_sensing`이라는 ROS 패키지를 발견할 수 있다. 이 패키지의 주된 역할은 시뮬레이션 환경에서 가상의 센서 데이터를 생성하는 것이다. 이 패키지 내의 `CMakeLists.txt` 파일을 살펴보면, 다음과 같은 라인이 존재한다.

```CMake
set(ENABLE_CUDA false)
```

이 `ENABLE_CUDA` 플래그는 EGO-Swarm의 GPU 가속 기능 사용 여부를 결정하는 핵심적인 스위치 역할을 한다. 기본적으로 이 값은 `false`로 설정되어 있어, 대부분의 사용자는 별도의 설정 없이 CPU 기반으로 시뮬레이션을 실행하게 된다. 사용자가 이 플래그 값을 `true`로 변경하고 `catkin_make`를 통해 전체 프로젝트를 재컴파일하면, 비로소 CUDA를 활용한 GPU 가속 기능이 활성화된다.1 이는 EGO-Swarm의 GPU 지원이 선택적 기능이며, 사용자의 하드웨어 환경(Nvidia GPU 탑재 여부)과 시뮬레이션의 목적에 따라 유연하게 조절될 수 있도록 설계되었음을 보여준다.

### 2.2 GPU 기반 깊이 이미지 생성 메커니즘

`ENABLE_CUDA` 플래그가 `true`로 설정되었을 때, `local_sensing` 패키지는 시뮬레이션 환경 내에서 가상의 깊이 카메라(depth camera)처럼 동작한다. 이 모드에서 패키지는 GPU의 강력한 병렬 처리 능력을 활용하여 레이캐스팅(ray-casting) 연산을 수행한다. 즉, 가상의 카메라 위치에서부터 다수의 광선을 쏘아 시뮬레이션 맵의 장애물과 부딪히는 지점까지의 거리를 계산하고, 이 정보를 바탕으로 픽셀 단위의 깊이 값을 가진 깊이 이미지(depth image)를 렌더링한다.

이 기능의 주된 목적은 실제 드론에 탑재되는 스테레오 카메라나 ToF(Time-of-Flight) 센서가 물리적 세계를 인식하는 방식을 시뮬레이션 상에서 최대한 유사하게 모방하는 것이다. 이렇게 생성된 고충실도의 센서 데이터는 EGO-Swarm의 인식(perception) 및 매핑(mapping) 모듈을 보다 현실적인 조건에서 테스트하고 검증하는 데 사용된다.

이 기능은 하드웨어에 대한 종속성을 가진다. `CMakeLists.txt` 파일 내에는 `CUDA_NVCC_FLAGS`를 설정하는 부분이 있으며, 사용자는 자신이 사용하는 Nvidia 그래픽 카드의 컴퓨팅 아키텍처에 맞는 `arch`와 `code` 플래그(예: Pascal 아키텍처의 경우 `compute_61,code=sm_61`)를 명시해야 한다. 이는 컴파일된 CUDA 코드가 특정 GPU 하드웨어의 명령어 셋에 최적화되어 최대의 성능으로 실행되도록 보장하기 위한 필수적인 과정이다.

### 2.3 CPU 버전과의 비교: 포인트 클라우드 발행

반대로, `ENABLE_CUDA` 플래그가 `false`로 설정된 기본 상태에서는 `local_sensing` 패키지가 GPU를 전혀 사용하지 않는다. 이 CPU 모드에서 패키지는 레이캐스팅과 같은 복잡한 렌더링 과정 없이, 시뮬레이션 환경 내의 장애물 정보를 담은 포인트 클라우드(`sensor_msgs/PointCloud2` 타입) 데이터를 ROS 토픽으로 직접 발행(publish)한다.1

GPU 버전과 CPU 버전의 가장 근본적인 차이는 생성되는 데이터의 형태와 그 과정에 있다. GPU 버전은 고밀도의 픽셀 구조를 가진 2D '이미지'를 생성하는 반면, CPU 버전은 상대적으로 저밀도의 3D '점들의 집합'을 생성한다. 이는 연산 복잡도뿐만 아니라 후속 처리 모듈의 입력 데이터 형식에도 영향을 미친다.

EGO-Swarm은 이러한 차이에 유연하게 대응하도록 설계되었다. 시스템의 로컬 매핑 모듈은 `local_sensing` 패키지로부터 수신되는 데이터가 깊이 이미지(`sensor_msgs/Image`)인지 포인트 클라우드(`sensor_msgs/PointCloud2`)인지를 자동으로 감지하고, 그에 맞는 데이터 처리 파이프라인을 내부적으로 선택한다. 이러한 설계 덕분에 사용자는 CUDA 사용 여부를 변경하더라도 매핑 모듈을 포함한 다른 코드들을 수정할 필요가 없어, 시스템의 모듈성과 사용 편의성이 크게 향상된다.

### 2.4 Table 1: EGO-Swarm `local_sensing` 패키지의 CPU vs. GPU 모드 비교

| 항목 (Feature)                         | CPU 모드 (`ENABLE_CUDA false`)                  | GPU 모드 (`ENABLE_CUDA true`)                                |
| -------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| **주요 기능 (Primary Function)**       | 포인트 클라우드(Point Cloud) 발행               | 깊이 이미지(Depth Image) 렌더링                              |
| **핵심 기술 (Core Technology)**        | 시뮬레이션 환경 내 장애물 좌표 직접 생성        | GPU 가속 레이캐스팅(Ray-casting)                             |
| **데이터 형태 (Data Format)**          | `sensor_msgs/PointCloud2`                       | `sensor_msgs/Image` (depth)                                  |
| **주요 목적 (Primary Purpose)**        | 경량 시뮬레이션, 핵심 플래닝 알고리즘 기능 검증 | 고충실도(High-fidelity) 시뮬레이션, 실제 센서 모방           |
| **연산 자원 (Computational Resource)** | CPU                                             | Nvidia GPU                                                   |
| **호환성 (Compatibility)**             | 모든 시스템에서 작동 (범용성 높음)              | Nvidia GPU 및 CUDA Toolkit 설치 필요 (특정 하드웨어 의존)    |
| **설정 (Configuration)**               | 기본값 (별도 설정 불필요)                       | `CMakeLists.txt`에서 `ENABLE_CUDA`를 `true`로 변경 및 재컴파일 필요 |

이러한 기술적 분석을 종합해 볼 때, EGO-Swarm의 GPU 지원에 대한 중요한 결론에 도달할 수 있다. EGO-Swarm의 GPU 관련 코드는 `local_sensing`이라는 시뮬레이션용 패키지에 국한되어 있다. 실제 드론을 물리적 환경에서 운용할 때는 이 `local_sensing` 패키지 대신 실제 카메라 하드웨어와 그 드라이버가 작동하게 된다. 이는 `ENABLE_CUDA` 플래그가 실제 비행 상황이 아닌, 시뮬레이션 환경에서만 의미를 가진다는 것을 명확히 보여준다. 따라서, EGO-Swarm의 GPU 지원은 드론의 실시간 비행 성능, 즉 궤적 최적화의 실행 시간(runtime)을 직접적으로 가속하기 위한 목적이 아니다. 대신, GPU의 강력한 3D 렌더링 성능을 활용하여 실제 환경과 매우 유사한 고품질의 센서 데이터를 시뮬레이션 상에서 생성하는 데 그 목적이 있다. 이를 통해 개발 단계에서 알고리즘의 인식 및 매핑 파이프라인의 강건성을 더욱 철저하게 검증하고 디버깅할 수 있게 된다. 결론적으로 EGO-Swarm의 GPU 지원은 '실행 시간 가속'의 문제가 아니라, '개발 및 검증 환경의 고도화'라는 문제에 대한 실용적인 해결책으로 설계된 것이다. 이는 "GPU 지원"이라는 용어가 일반적으로 연상시키는 '단순 성능 향상'과는 다른, 더 미묘하고 실용적인 공학적 트레이드오프와 설계 철학을 반영한다.

## 3. GPU 지원의 성능 및 실효성 고찰

EGO-Swarm의 GPU 지원은 직접적인 궤적 최적화 가속을 목표로 하지 않지만, 시스템 개발 및 검증 과정에서 간접적으로 중요한 성능상 이점과 실효성을 제공한다. 이는 연산 부하 분산 전략과 고충실도 시뮬레이션의 가치 측면에서 분석할 수 있다.

### 3.1 연산 부하 분산(Offloading) 전략

고충실도 시뮬레이션 환경에서 실제와 유사한 깊이 이미지를 생성하는 작업은 상당한 연산 부하를 유발한다. 수많은 광선을 쏘고 3D 모델과의 교차점을 계산하는 레이캐스팅 과정은 본질적으로 CPU에 큰 부담을 준다. 만약 이 작업을 CPU가 전담하게 되면, EGO-Swarm의 핵심 로직인 궤적 최적화, 다중 에이전트 간 충돌 비용 계산, 통신 데이터 처리 등 더 중요하고 시간 민감적인(time-critical) 작업에 할당될 CPU 자원이 잠식될 수 있다.

EGO-Swarm의 `ENABLE_CUDA` 옵션은 이러한 깊이 이미지 생성 연산을 전적으로 GPU로 오프로딩(offloading)하는 효과적인 '자원 분할(resource partitioning)' 전략을 제공한다. GPU가 센서 데이터 생성을 전담하는 동안, CPU는 본연의 임무인 고속 궤적 계획에 자원을 집중할 수 있게 된다. 이는 시뮬레이션 환경임에도 불구하고, 실제 온보드 컴퓨터와 유사한 연산 부하 조건 하에서 플래너의 실시간 성능을 정확하게 테스트하고 평가할 수 있게 해주는 중요한 역할을 한다.

더 나아가, 고충실도 시뮬레이션은 그 자체로 큰 가치를 지닌다. GPU를 통해 생성된 사실적인 깊이 이미지는 실제 센서가 겪을 수 있는 측정 노이즈, 특정 각도에서의 데이터 소실, 반사면에 의한 왜곡 등 다양한 비이상적인 현상을 어느 정도 모방할 수 있다. 이러한 데이터를 사용하여 알고리즘을 테스트하면, 깨끗하고 이상적인 데이터 환경에서는 발견하기 어려운 잠재적인 문제점들을 사전에 식별하고 알고리즘의 강건성을 크게 향상시킬 수 있다. 특히 충돌과 직결될 수 있는 드론 시스템의 안전성을 확보하는 데 있어, 이러한 철저한 사전 검증 과정은 필수적이다.

### 3.2 EGO-Swarm의 현재 한계와 잠재적 확장성

EGO-Swarm의 GPU 활용 전략은 명확한 장점과 동시에 뚜렷한 한계점을 내포하고 있다. 현재 GPU의 역할은 '센서 시뮬레이션'이라는 보조적인 기능에 엄격하게 국한되어 있으며, 시스템의 핵심 연산 부하를 차지하는 궤적 최적화 알고리즘 자체는 전혀 가속하지 않는다. 즉, B-스플라인 제어점의 최적 위치를 찾기 위한 반복적인 경사 하강법 계산, 에이전트 간 또는 장애물과의 충돌 비용 및 기울기 계산 등 알고리즘의 심장부에 해당하는 모든 연산은 여전히 온보드 CPU에서 순차적으로 수행된다.

이는 EGO-Swarm의 성능이 근본적으로 CPU의 연산 능력에 의해 제약을 받는다는 것을 의미한다. 소수의 드론이 비행하는 환경에서는 ESDF-free 접근법 덕분에 CPU만으로도 충분히 빠른 성능을 보이지만, 스웜의 규모가 커지고 에이전트들이 밀집하는 복잡한 시나리오에서는 성능 한계에 직면할 수 있다. 특히, 에이전트 간 상호 충돌을 회피하기 위한 비용 계산은 스웜의 크기가 $N$일 때, 약 $O(N^2)$에 비례하여 증가하는 경향이 있다. 수십, 수백 대의 드론으로 구성된 대규모 스웜을 가정하면 이 부분은 심각한 연산 병목이 될 것이 자명하다.

바로 이 지점에서 EGO-Swarm의 성능 확장을 위한 거대한 기회가 존재한다. 다수의 에이전트 간 충돌 검사와 같이, 수많은 독립적이고 유사한 연산을 반복적으로 수행해야 하는 작업은 GPU의 대규모 병렬 처리(massive parallelism) 아키텍처를 활용하기에 가장 이상적인 후보다. 만약 이 핵심 연산을 GPU로 가속할 수 있다면, EGO-Swarm은 현재의 성능을 뛰어넘어 훨씬 더 크고 밀집된 스웜을 실시간으로 제어할 수 있는 잠재력을 갖게 될 것이다.

EGO-Swarm 개발팀의 GPU 활용 전략은 '보수적 실용주의'의 산물로 해석될 수 있다. EGO-Swarm의 핵심 개발 목표는 미지의 복잡한 환경에서 온보드 자원만으로 안정적으로 작동하는 완전 자율 분산 시스템을 구축하는 것이었다. 이는 알고리즘의 '강건성'과 '경량성'을 다른 어떤 가치보다 우선시했음을 시사한다. 이러한 관점에서 볼 때, 궤적 최적화와 같은 핵심 로직에 GPU 가속을 도입하는 것은 양날의 검이 될 수 있다. GPU를 사용하면 잠재적으로 엄청난 성능 향상을 꾀할 수 있지만, 동시에 코드의 복잡성을 크게 증가시키고, 특정 하드웨어(Nvidia GPU)에 대한 강한 의존성을 만들며, CPU와 GPU 간의 데이터 전송 오버헤드라는 새로운 기술적 난제를 야기한다.

따라서 개발팀은 보다 실용적인 길을 택한 것으로 보인다. 즉, 시스템의 심장부인 핵심 알고리즘은 CPU 상에서 최대한 효율적으로(ESDF-free) 구현하여 안정성과 이식성을 확보하고, GPU는 핵심 로직과 분리 가능한 보조 기능(센서 시뮬레이션)에만 제한적으로 사용하여 개발 과정의 신뢰도를 높이는 전략을 채택한 것이다. 이는 최첨단 성능을 추구하되, 학술적 실험을 넘어 실제 시스템으로의 적용 가능성과 안정성을 결코 놓치지 않으려는 성숙한 공학적 설계 철학을 보여준다.

## 4. 로봇 공학에서의 GPU 가속 궤적 최적화 동향

EGO-Swarm의 현재 GPU 활용법을 더 넓은 시각에서 평가하기 위해서는, 로봇 공학 분야에서 진행되고 있는 GPU 가속 궤적 최적화 연구 동향을 살펴볼 필요가 있다. 최신 연구들은 EGO-Swarm이 현재 직면한 연산 병목 문제를 해결할 수 있는 강력한 해법들을 제시하고 있다.

### 4.1 병렬 충돌 검출 및 최적화 기법

#### 4.1.1 문제 분해 (Problem Decomposition)

다개체 궤적 최적화의 가장 큰 난제는 에이전트 수가 증가함에 따라 충돌 회피를 위한 제약 조건의 수가 기하급수적으로 증가하여 문제가 다루기 힘들어지는(intractable) 것이다. 예를 들어, $N$개의 에이전트가 있다면, 고려해야 할 에이전트 쌍의 수는 $(N \times (N-1)) / 2$에 달한다. 최신 연구들은 이 거대한 공동 최적화(joint optimization) 문제를 여러 개의 작은 부문제(sub-problems)로 분해하는 전략을 적극적으로 채택하고 있다. 예를 들어, 전체 스웜의 궤적을 한 번에 최적화하는 대신, 각 에이전트의 궤적을 개별적으로 최적화하거나, 각 에이전트 쌍 사이의 충돌 회피 문제만을 따로 떼어내어 푸는 방식이다.

#### 4.1.2 GPU 기반 병렬 처리

이렇게 분해된 수많은 부문제들은 종종 구조적으로 매우 유사한 형태를 띤다. GPU는 수천 개에 달하는 코어를 활용하여, 이처럼 구조가 동일하거나 유사한 연산들을 동시에(in parallel) 처리하는 데 극도로 특화된 아키텍처를 가지고 있다. 연구자들은 이 특성을 활용하여 궤적 최적화의 다양한 단계를 가속한다. 예를 들어, 모든 에이전트 쌍에 대한 충돌 가능성을 동시에 검사하거나, 최적화 과정에서 반복적으로 수행되는 거대한 행렬-벡터 곱셈 연산을 GPU의 수많은 스레드에 분산하여 처리함으로써 전체 계산 시간을 획기적으로 단축시킨다.

구체적인 사례로, 한 연구에서는 공동 최적화 문제를 다수의 분리된 QP(Quadratic Programming) 문제로 변환한 뒤, 이를 GPU에서 병렬로 해결하여 32대의 로봇으로 구성된 스웜의 궤적을 불과 0.15초 이내에 계산하는 놀라운 성과를 보였다. 또 다른 연구에서는 뉴턴 방법(Newton's method)과 같은 고전적인 최적화 알고리즘의 내부 연산, 특히 헤시안(Hessian) 행렬 계산과 인수분해 과정을 GPU 아키텍처에 맞게 재설계하여 병렬화함으로써, 멀티코어 CPU 기반 구현에 비해 30배 이상의 압도적인 속도 향상을 달성하기도 했다.

### 4.2 Table 2: 다중 에이전트 궤적 최적화에서의 GPU 가속 연구 비교

| 연구/방법론 (Study/Method)                                 | 핵심 아이디어 (Core Idea)                                    | 가속 대상 연산 (Accelerated Operation)               | 주요 성과 (Key Results)                            | 참고 자료 (Reference) |
| ---------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- | -------------------------------------------------- | --------------------- |
| **Fast Joint Multi-Robot Trajectory Optimization**         | 공동 최적화 문제를 분산된 QP 부문제로 분해 후 GPU로 병렬 해결 | QP 문제 풀이 (행렬-벡터 곱셈 등)                     | 32개 에이전트 궤적을 수십 ms 내에 계산             |                       |
| **GPU-Based Contact-Aware Trajectory Optimization**        | 미분 가능한 평활 힘 모델(smooth force model) 사용 및 뉴턴 타입 최적화기 병렬화 | 해석적 헤시안 행렬 계산 및 병렬 인수분해             | 멀티코어 CPU 구현 대비 30배 이상 속도 향상         |                       |
| **Parallel Conflict Detection for Airspace Deconfliction** | 항공 교통 관제를 위한 충돌 예측 알고리즘을 데이터 병렬 특성을 이용해 가속 | 충돌 예측(Conflict Detection) 및 해결(Deconfliction) | 순차적(sequential) 버전에 비해 실행 시간 대폭 개선 |                       |
| **Parallel ACO on CUDA**                                   | Ant Colony Optimization(ACO) 경로 탐색 알고리즘의 각 개미(agent) 연산을 병렬화 | 페로몬 업데이트 및 경로 생성                         | 복잡한 대규모 UAV 경로 계획 문제 가속              |                       |

### 4.3 EGO-Swarm에의 적용 가능성 모색

이러한 선행 연구들은 EGO-Swarm의 성능을 한 단계 끌어올릴 수 있는 구체적인 청사진을 제공한다.

#### 4.3.1 가속 대상 식별

EGO-Swarm의 비용 함수는 앞서 언급했듯이 주로 궤적의 평활성($J_{smooth}$), 충돌($J_{collision}$), 동역학적 실행 가능성($J_{feasibility}$)의 합으로 구성된다. 이 중에서 GPU 가속의 효과를 가장 크게 볼 수 있는 부분은 단연 충돌 비용 $J_{collision}$이다. 이 비용을 계산하기 위해서는 최적화의 각 반복 단계마다, 궤적상의 모든 시간 샘플에 대해, 모든 에이전트 쌍과 모든 장애물에 대한 거리를 계산해야 한다. 이는 본질적으로 대규모 병렬 처리에 매우 적합한 구조를 가지고 있다. 각 거리 계산은 서로 독립적이기 때문에 수천 개의 GPU 코어에 작업을 분배하여 동시에 처리할 수 있다. 또한, 비용 함수의 기울기(gradient)를 계산하는 과정 역시 각 B-스플라인 제어점에 대해 독립적으로 수행될 수 있는 부분이 많아 GPU 가속을 통해 큰 성능 향상을 기대할 수 있다.

#### 4.3.2 아키텍처 통합 과제

그러나 EGO-Swarm에 GPU 가속을 도입하는 것은 단순히 특정 연산을 CUDA 커널로 작성하는 것 이상의 복잡한 과제를 수반한다. 가장 큰 도전은 EGO-Swarm의 핵심 철학인 '비동기 분산' 특성을 훼손하지 않으면서 GPU 가속을 통합하는 것이다. GPU는 일반적으로 많은 양의 데이터를 한 번에 모아 처리하는 배치(batch) 방식에서 최고의 효율을 보인다. 하지만 EGO-Swarm에서는 다른 에이전트의 궤적 정보가 언제, 어떤 순서로 도착할지 예측할 수 없다. 모든 정보가 모일 때까지 기다렸다가 GPU에 작업을 전달하는 방식은 시스템의 즉각적인 반응성을 저해하고 심각한 지연을 유발할 수 있다.

따라서, 비동기적으로 수신되는 데이터를 효율적으로 버퍼링하고 관리하며, 새로운 데이터가 도착할 때마다 GPU 커널을 유연하게 호출하고, CPU와 GPU 메모리 간의 데이터 전송으로 인한 오버헤드를 최소화하는 정교한 하이브리드 아키텍처 설계가 필수적이다.

EGO-Swarm의 미래 진화 방향은 '분산 지능'과 '중앙 집중식 병렬 처리'라는 두 패러다임 사이의 선택이 아니라, 이 둘의 창의적인 융합에 있을 것이다. 현재 EGO-Swarm은 각 에이전트가 독립적으로 생각하고 행동하는 '분산 지능'의 전형적인 모델을 따른다. 반면, 앞서 살펴본 최첨단 GPU 가속 기법들은 여러 에이전트의 문제를 한곳(GPU)에 모아 한 번에 처리하는 '중앙 집중식 병렬 처리' 패러다임에 가깝다. 이 두 가지는 언뜻 보기에 서로 상충하는 것처럼 보인다.

그러나 진정한 기술적 돌파구는 이 두 패러다임을 결합하는 데서 찾을 수 있다. 미래의 EGO-Swarm 에이전트는 여전히 독립적인 의사결정 주체로서 '분산 지능'의 강점을 유지하되, 자신의 연산 과정 중 가장 계산량이 많고 병렬화가 용이한 부분(예: 주변의 모든 에이전트 궤적들과의 미래 충돌 가능성 전수조사)만을 자신의 온보드 GPU에 '쿼리'하는 형태로 '중앙 집중식 병렬 처리'의 이점을 취할 수 있다. 이는 각 에이전트가 CPU(고수준 의사결정 및 제어)와 GPU(대규모 데이터 병렬 연산)를 모두 갖춘 이기종 컴퓨팅(heterogeneous computing) 노드로서 기능하는 모델이다. 이 모델은 EGO-Swarm이 자랑하는 분산 시스템의 강건성과 확장성을 그대로 유지하면서, 스웜의 밀도가 높아질수록 기하급수적으로 심해지는 연산 병목 현상을 효과적으로 해결할 수 있는 가장 현실적이고 강력한 진화 경로를 제시한다.

## 5. 결론 및 제언

본 보고서는 EGO-Swarm 프레임워크의 GPU 지원 현황을 기술적으로 심층 분석하고, 이를 로봇 공학 분야의 최신 GPU 가속 동향과 비교하여 미래 확장 가능성을 고찰하였다. 분석 결과를 바탕으로 다음과 같은 결론 및 제언을 도출하였다.

### EGO-Swarm GPU 지원 현황 요약

EGO-Swarm의 현재 GPU 지원은 시스템의 핵심인 궤적 계획 알고리즘의 실시간 성능을 직접 가속하는 것이 아니다. 그 역할은 시뮬레이션 환경에 국한되며, GPU의 렌더링 파이프라인을 활용하여 실제와 유사한 고충실도의 센서 데이터(깊이 이미지)를 생성하는 '개발 및 검증 지원 도구'로서 기능한다.

이러한 설계는 의도적인 선택의 결과로 평가된다. 개발팀은 궤적 최적화와 같은 핵심 로직에 GPU를 도입할 경우 발생할 수 있는 코드 복잡성 증가, 특정 하드웨어에 대한 의존성, 그리고 CPU-GPU 간 데이터 전송 오버헤드와 같은 잠재적 위험을 피하고자 했다. 대신, 핵심 알고리즘은 CPU에서 최대한 경량화하고(ESDF-free), GPU는 시스템의 안정성에 영향을 주지 않는 분리된 보조 기능에만 제한적으로 사용하여 시스템 전체의 강건성과 이식성을 높였다. 이는 학술적 성능 지표뿐만 아니라 실제 시스템으로서의 안정성과 적용 가능성을 깊이 고려한 실용적이고 현명한 공학적 결정이라 할 수 있다.

### 5.1 핵심 제언: 코어 알고리즘의 GPU 가속

EGO-Swarm이 현재의 뛰어난 성능을 넘어, 미래의 대규모 군집 비행(large-scale swarm flight) 시대를 선도하는 표준 프레임워크로 자리매김하기 위해서는 보다 과감한 기술적 도약이 필요하다. 이를 위해, 현재 전적으로 CPU에서 처리되고 있는 핵심 궤적 최적화 알고리즘에 GPU 가속을 직접 적용하는 방향으로의 연구가 필수적으로 수행되어야 한다.

가장 시급하고 효과적인 과제는 '다중 에이전트 간 충돌 비용 계산' 부분을 GPU로 이관하여 병렬 처리하는 것이다. 이 연산은 에이전트 수가 증가함에 따라 계산량이 비선형적으로 폭증하여 시스템의 확장성을 저해하는 가장 큰 병목 지점이다. 이 부분을 GPU로 가속함으로써 EGO-Swarm은 훨씬 더 많고 밀집된 드론 스웜을 실시간으로 제어할 수 있는 능력을 확보하게 될 것이다. 또한, 비용 함수의 기울기 계산 등 최적화 과정의 다른 병렬화 가능한 부분들에 대해서도 GPU 가속을 점진적으로 확대 적용하는 연구가 병행되어야 한다.

### 5.2 미래 비전: 이기종 컴퓨팅 기반의 차세대 스웜 인텔리전스

궁극적으로 EGO-Swarm이 나아가야 할 방향은 각 드론이 단순한 연산 노드를 넘어, 고성능 이기종 컴퓨팅(heterogeneous computing) 플랫폼으로 진화하는 것이다. 이러한 차세대 스웜 아키텍처에서 각 에이전트는 다음과 같이 역할을 분담한다.

- **CPU:** 고수준의 의사결정, 비동기 통신 처리, 최종 제어 명령 생성 등 순차적이고 논리적인 작업을 담당하며 분산 시스템의 지능적 주체로서 기능한다.
- **GPU:** 수많은 에이전트 및 장애물과의 충돌 가능성 검사, 대규모 행렬 연산 등 데이터 병렬성이 높은 계산 집약적 작업을 전담하는 강력한 연산 가속기로서 기능한다.

이러한 아키텍처는 EGO-Swarm이 가진 분산 시스템의 강건성과 유연성이라는 고유의 장점을 그대로 유지하면서, GPU가 제공하는 압도적인 연산 능력을 결합하는 이상적인 융합 모델이다. 이는 이전에는 계산적으로 불가능했던 규모와 복잡도를 가진 임무를 수행할 수 있게 하여, 진정한 의미의 실시간 '스웜 인텔리전스(Swarm Intelligence)'를 구현하는 핵심 기반이 될 것이다. EGO-Swarm의 GPU 지원에 대한 본 고찰이 이러한 미래 비전을 향한 의미 있는 첫걸음이 되기를 기대한다.

#### 5.2.1 Works cited

1. ZJU-FAST-Lab/ego-planner-swarm: An efficient single/multi ... - GitHub, accessed August 12, 2025, https://github.com/ZJU-FAST-Lab/ego-planner-swarm

