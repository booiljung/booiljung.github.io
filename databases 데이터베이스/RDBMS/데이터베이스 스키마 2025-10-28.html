<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:데이터베이스 스키마</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>데이터베이스 스키마</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">데이터베이스 관리 시스템 (Database Management System)</a> / <a href="index.html">관계형 데이터베이스</a> / <span>데이터베이스 스키마</span></nav>
                </div>
            </header>
            <article>
                <h1>데이터베이스 스키마</h1>
<p>2025-10-28, G25DR</p>
<h2>1. 서론: 데이터베이스의 청사진, 스키마</h2>
<p>데이터베이스 스키마(Database Schema)는 데이터베이스의 구조와 구성을 정의하는 핵심적인 설계도, 즉 ’청사진(blueprint)’이다.1 이는 단순히 데이터가 저장되는 테이블의 형태를 넘어, 데이터베이스를 구성하는 모든 요소—테이블, 필드(열), 데이터 유형, 그리고 이들 간의 복잡한 관계와 제약 조건—를 포괄적으로 명세한다.1 스키마는 시각적 다이어그램을 통해 데이터베이스의 아키텍처를 전달하며, 조직의 데이터 관리 체계의 근간을 이룬다.2</p>
<p>이러한 설계도는 데이터베이스 관리 시스템(DBMS) 내에서 매우 중요한 공식 문서 역할을 한다. 개발자, 데이터베이스 관리자(DBA), 데이터 분석가 등 다양한 이해관계자들은 스키마를 통해 데이터 구조를 통일된 관점에서 이해하고, 이를 바탕으로 원활하게 소통하고 협업할 수 있다.2 즉, 스키마는 데이터에 대한 ’공통의 신뢰할 수 있는 소스(common source of truth)’를 제공하는 것이다.4</p>
<p>잘 설계된 스키마의 가치는 아무리 강조해도 지나치지 않는다. 견고한 스키마는 데이터의 중복을 체계적으로 제거하거나 최소화하여 저장 공간의 낭비를 막고, 데이터 불일치의 가능성을 원천적으로 차단한다.6 또한, 다양한 제약 조건을 통해 데이터의 무결성(Integrity)과 일관성(Consistency)을 보장하며, 이는 데이터의 정확성과 신뢰도를 높이는 데 결정적인 역할을 한다.6 나아가, 효율적인 데이터 조회를 지원하여 애플리케이션의 성능을 향상시키고, 접근 권한 제어를 통해 민감한 데이터를 보호하는 보안의 첫걸음이 된다.6 이처럼 스키마는 단순히 기술적 효율성을 넘어서, 비즈니스 의사결정의 신뢰도를 높이고 애플리케이션의 장기적인 확장성과 유지보수성을 결정하는 핵심적인 아키텍처 자산이다.8</p>
<h2>2.  데이터베이스 스키마의 기초</h2>
<h3>2.1  스키마의 정의와 역할</h3>
<p>데이터베이스 스키마는 데이터베이스에 저장될 데이터의 구조(structure), 데이터 간의 관계(relationships), 그리고 데이터가 준수해야 할 제약 조건(constraints)을 전반적으로 명세하는 설계도이다.8 구체적으로 스키마는 테이블(Table), 뷰(View), 인덱스(Index), 저장 프로시저(Stored Procedure)와 같은 데이터베이스를 구성하는 객체들의 논리적인 집합체를 정의한다.5 이러한 정보는 DBMS 내의 특별한 저장소인 ’데이터 사전(Data Dictionary)’에 저장되는데, 이는 ’데이터에 관한 데이터’라는 의미에서 ’메타데이터(Metadata)’라고도 불린다.10 데이터 사전은 시스템 전체의 데이터 항목에 대한 정보를 관리하는 중앙 저장소 역할을 수행한다.13</p>
<p>여기서 ’스키마’라는 용어가 사용되는 문맥을 명확히 이해하는 것이 중요하다. 이 용어는 여러 가지 의미로 사용될 수 있기 때문이다. 첫째, 가장 보편적인 의미는 본 안내서에서 주로 다루는 것처럼, 데이터베이스의 전반적인 논리적, 물리적 구조를 총칭하는 ’청사진’이다.1 둘째, MySQL과 같은 특정 DBMS에서는 데이터베이스 자체와 거의 동일한 의미로 사용되기도 한다. 예를 들어, <code>CREATE SCHEMA</code> 명령어는 <code>CREATE DATABASE</code> 명령어와 동일한 기능을 수행한다.15 셋째, Oracle 데이터베이스 환경에서는 특정 사용자 계정이 소유하는 테이블, 뷰, 인덱스 등 데이터베이스 객체들의 컬렉션을 지칭하는 용어로 사용된다.5 넷째, 스키마의 개념은 관계형 데이터베이스(RDBMS)에만 국한되지 않는다. XML 문서의 구조를 정의하는 XSD(XML Schema Definition)나 JSON 데이터의 유효성을 검사하는 JSON Schema처럼, 데이터를 형식화하고 구조를 정의하는 다양한 기술 분야에서 ’스키마’라는 용어가 폭넓게 사용된다.15 이처럼 용어의 다의성이 존재하므로, 스키마에 대한 논의를 접할 때는 그것이 어떤 문맥에서 사용되고 있는지를 파악하는 것이 필수적이다.</p>
<h3>2.2  스키마와 인스턴스의 차이</h3>
<p>스키마와 인스턴스는 데이터베이스를 이해하는 데 있어 반드시 구분해야 할 핵심 개념이다. 이 둘의 관계는 종종 건물의 ’설계도’와 ’실제 건물’에 비유된다.</p>
<ul>
<li>
<p><strong>스키마(Schema):</strong> 데이터베이스의 구조와 제약 조건을 정의한 정적인(static) 설계도이다. 스키마는 데이터베이스에 어떤 테이블이 있고, 각 테이블은 어떤 컬럼으로 구성되며, 데이터 타입은 무엇인지, 테이블 간의 관계는 어떻게 설정되는지 등을 명시한다. 한번 정의된 스키마는 데이터가 변경된다고 해서 함께 변하지 않으며, 시간에 따라 불변하는(time-invariant) 특성을 가진다.8</p>
</li>
<li>
<p><strong>인스턴스(Instance):</strong> 특정 시점(a particular moment in time)에 데이터베이스에 실제로 저장되어 있는 데이터의 집합, 즉 스냅샷(snapshot)이다.2 스키마라는 ’틀’에 실제 데이터 값들이 채워진 상태를 의미한다. 사용자가 데이터를 추가, 수정, 삭제함에 따라 인스턴스는 끊임없이 변하며, 동적인(dynamic) 성격을 띤다.2</p>
</li>
</ul>
<p>이 둘의 관계는 명확한 인과관계를 가진다. 스키마는 인스턴스가 가져야 할 구조와 규칙을 ’규정’하는 역할을 한다.12 예를 들어, 스키마에서 특정 컬럼에 <code>NOT NULL</code> 제약 조건을 정의하면, 해당 데이터베이스의 어떤 인스턴스에서도 그 컬럼은 빈 값을 가질 수 없다. 이처럼 스키마는 데이터베이스의 상태를 제어하고 예측 가능하게 만드는 근본적인 틀을 제공한다.</p>
<h3>2.3  스키마의 핵심 기능</h3>
<p>잘 설계된 스키마는 데이터베이스 시스템 전반에 걸쳐 다양한 핵심 기능을 수행한다.</p>
<ul>
<li>
<p><strong>데이터 무결성(Data Integrity):</strong> 스키마는 기본 키, 외래 키, 고유 제약 조건, <code>CHECK</code> 제약 조건 등 다양한 제약(constraints)을 정의함으로써 데이터의 정확성, 일관성, 유효성을 보장하는 가장 기본적인 수단을 제공한다.2 이는 데이터베이스 트랜잭션이 준수해야 할 ACID 속성(원자성 Atomicity, 일관성 Consistency, 격리성 Isolation, 내구성 Durability)을 지키는 데 필수적인 기반이 된다.2</p>
</li>
<li>
<p><strong>일관성 및 조직화(Consistency &amp; Organization):</strong> 스키마는 모든 데이터가 명확하고 일관된 형식으로 저장되도록 강제한다.6 예를 들어, 날짜는 ‘YYYY-MM-DD’ 형식으로, 전화번호는 특정 숫자 형식으로 통일할 수 있다. 또한, 모든 레코드(행)가 고유한 기본 키(Primary Key)를 갖도록 보장하여 데이터의 식별성을 명확히 한다.6</p>
</li>
<li>
<p><strong>보안(Security):</strong> 스키마는 데이터 보안의 중요한 계층을 제공한다. 관리자는 스키마 단위, 혹은 더 세부적으로 테이블이나 컬럼 단위로 사용자의 접근 권한(읽기, 쓰기, 수정 등)을 제어할 수 있다.2 이는 민감한 개인정보나 중요한 비즈니스 데이터에 대한 비인가 접근을 차단하는 데 효과적이다. 특히 여러 고객(tenant)이 하나의 데이터베이스를 공유하는 멀티 테넌시(multi-tenancy) 아키텍처에서 스키마를 이용한 데이터 격리 및 보안은 매우 중요한 역할을 한다.8</p>
</li>
<li>
<p><strong>소통 및 문서화(Communication &amp; Documentation):</strong> 스키마, 특히 개체-관계 다이어그램(ERD)과 같은 시각적 표현은 그 자체로 훌륭한 기술 문서가 된다.2 이는 프로젝트에 참여하는 개발자, 데이터베이스 관리자, 기획자, 데이터 분석가 등 다양한 배경을 가진 이해관계자들이 데이터베이스 구조에 대해 공통의 이해를 형성하고 원활하게 소통할 수 있도록 돕는 매개체 역할을 한다.5</p>
</li>
</ul>
<h2>3.  스키마의 3계층 아키텍처와 데이터 독립성</h2>
<h3>3.1  ANSI/SPARC 3계층 스키마</h3>
<p>1975년, 미국 표준 협회(ANSI)의 SPARC(Standards Planning and Requirements Committee) 그룹은 데이터베이스 시스템을 개념적으로 구조화하기 위한 프레임워크를 제안했다. 이 아키텍처는 데이터베이스를 바라보는 관점을 세 가지 추상화 수준으로 분리하는데, 이를 ’3계층 스키마 아키텍처’라고 한다.17 이 구조의 핵심 목표는 사용자 애플리케이션과 물리적인 데이터베이스를 서로 분리하여, 한쪽의 변경이 다른 쪽에 미치는 영향을 최소화하는 ’데이터 독립성’을 확보하는 것이다.8</p>
<ul>
<li>
<p><strong>외부 스키마(External Schema):</strong> 이 계층은 개별 사용자나 응용 프로그램의 관점에서 데이터베이스를 바라본다.10 전체 데이터베이스 중에서 특정 사용자에게 필요하거나 허용된 부분만을 보여주는 일종의 ’창문’과 같다. 이 때문에 ‘사용자 뷰(User View)’ 또는 전체 스키마의 일부라는 의미에서 ’서브 스키마(Sub-schema)’라고도 불린다.8 예를 들어, 학생 관리 시스템에서 교수는 학생의 성적 정보를 볼 수 있지만, 학생은 자신의 성적만 볼 수 있도록 각기 다른 외부 스키마를 정의할 수 있다.20 이처럼 하나의 데이터베이스 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며, 각 사용자의 요구에 맞게 데이터를 다르게 표현하고 불필요한 복잡성은 숨긴다.8</p>
</li>
<li>
<p><strong>개념 스키마(Conceptual Schema):</strong> 이 계층은 특정 사용자나 기술에 종속되지 않고, 조직 전체의 관점에서 데이터베이스의 전체적인 논리적 구조를 통합하여 정의한다.12 데이터베이스에 저장되는 모든 데이터 개체(Entity), 그들의 속성(Attribute), 그리고 개체들 간의 관계(Relationship)를 명세한다.10 또한 데이터 무결성 규칙, 보안 정책, 접근 권한과 같은 중요한 제약 조건들도 이 단계에서 정의된다.14 개념 스키마는 물리적 저장 방식과는 독립적이며, 데이터베이스 당 단 하나만 존재한다.10 일반적으로 특별한 수식어 없이 ’스키마’라고 하면 바로 이 개념 스키마를 지칭하는 경우가 많다.8</p>
</li>
<li>
<p><strong>내부 스키마(Internal Schema):</strong> 이 계층은 데이터가 물리적 저장 장치에 실제로 어떻게 저장되는지를 기술한다.12 데이터의 물리적 구조, 레코드의 배치 방법, 인덱스의 생성 여부 및 구조, 데이터 압축 방식, 파일 구성 등 하드웨어와 밀접한 관련이 있는 세부 사항을 다룬다.15 이 때문에 ‘물리적 스키마(Physical Schema)’ 또는 ’저장 스키마(Storage Schema)’라고도 불린다.1 내부 스키마 역시 데이터베이스 당 하나만 존재하며, 시스템의 성능과 효율성에 직접적인 영향을 미친다.19</p>
</li>
</ul>
<h3>3.2  각 계층의 역할과 관점</h3>
<p>3계층 스키마는 데이터베이스와 상호작용하는 주체의 역할에 따라 각기 다른 관점을 제공한다.</p>
<ul>
<li>
<p><strong>외부 스키마</strong>는 최종 사용자나 응용 프로그래머가 직접적으로 상호작용하는 계층이다. 이들은 전체 데이터베이스의 복잡한 구조를 알 필요 없이, 자신의 업무에 필요한 데이터에만 집중할 수 있다.10</p>
</li>
<li>
<p><strong>개념 스키마</strong>는 데이터베이스 관리자(DBA)나 데이터 설계자의 영역이다. 이들은 조직의 데이터 자산을 전체적인 시각에서 모델링하고, 데이터의 일관성과 무결성을 유지하는 책임을 진다.15</p>
</li>
<li>
<p><strong>내부 스키마</strong>는 시스템 프로그래머나 하드웨어 설계자가 다루는 계층으로, 어떻게 하면 데이터를 가장 효율적으로 저장하고 접근할 수 있을지에 대한 물리적 구현을 담당한다.12</p>
</li>
</ul>
<p>이러한 각 계층의 특징을 요약하면 다음 표와 같다.</p>
<p><strong>Table 1: 스키마 3계층 비교</strong></p>
<table><thead><tr><th><strong>구분</strong></th><th><strong>외부 스키마 (External Schema)</strong></th><th><strong>개념 스키마 (Conceptual Schema)</strong></th><th><strong>내부 스키마 (Internal Schema)</strong></th></tr></thead><tbody>
<tr><td><strong>관점</strong></td><td>사용자/응용 프로그램</td><td>조직 전체 (통합적)</td><td>물리적 저장 장치</td></tr>
<tr><td><strong>목적</strong></td><td>사용자 편의성, 데이터 은닉</td><td>데이터의 논리적 구조 정의</td><td>데이터의 물리적 저장 방식 정의</td></tr>
<tr><td><strong>표현 내용</strong></td><td>특정 사용자가 보는 데이터의 뷰</td><td>모든 데이터 개체, 관계, 제약 조건</td><td>인덱스, 파일 구조, 데이터 압축</td></tr>
<tr><td><strong>주요 사용자</strong></td><td>최종 사용자, 응용 프로그래머</td><td>데이터베이스 관리자(DBA), 설계자</td><td>시스템 프로그래머</td></tr>
<tr><td><strong>개수</strong></td><td>다수 존재 가능</td><td>데이터베이스 당 1개</td><td>데이터베이스 당 1개</td></tr>
<tr><td><strong>별칭</strong></td><td>서브 스키마, 사용자 뷰</td><td>스키마, 논리 스키마</td><td>저장 스키마, 물리 스키마</td></tr>
</tbody></table>
<h3>3.3  데이터 독립성: 3계층 아키텍처의 핵심 가치</h3>
<p>3계층 스키마 아키텍처를 채택하는 가장 근본적인 이유는 ’데이터 독립성(Data Independence)’을 확보하기 위함이다.13 데이터 독립성이란, 특정 계층의 스키마를 변경하더라도 그 상위 계층의 스키마나 응용 프로그램에 영향을 주지 않는 성질을 의미한다. 이는 시스템의 유연성, 확장성, 그리고 유지보수성을 획기적으로 향상시킨다. 데이터 독립성은 논리적 독립성과 물리적 독립성으로 나뉜다.</p>
<ul>
<li>
<p><strong>논리적 데이터 독립성(Logical Data Independence):</strong> 개념 스키마의 변경이 외부 스키마에 영향을 주지 않는 것을 의미한다.17 예를 들어, DBA가 조직의 요구사항 변화에 따라 데이터베이스에 새로운 테이블을 추가하거나 기존 테이블에 새로운 컬럼을 추가하는 등 개념 스키마를 변경하더라도, 이와 관련 없는 기존 응용 프로그램들은 코드를 수정할 필요가 없다. 이 독립성은 외부 스키마와 개념 스키마 사이의 ‘사상(Mapping)’ 또는 ’대응 관계’를 통해 보장된다.17 DBMS는 이 사상 정보를 이용해 개념 스키마의 변경 사항을 흡수하고, 외부 스키마에는 일관된 뷰를 제공한다.</p>
</li>
<li>
<p><strong>물리적 데이터 독립성(Physical Data Independence):</strong> 내부 스키마의 변경이 개념 스키마와 외부 스키마에 영향을 주지 않는 것을 의미한다.17 예를 들어, 데이터베이스의 성능 향상을 위해 파일 저장 구조를 변경하거나, 특정 인덱스를 추가 또는 삭제하거나, 데이터 저장 장치를 하드 디스크 드라이브(HDD)에서 솔리드 스테이트 드라이브(SSD)로 교체하는 등의 물리적 변경이 발생하더라도, 응용 프로그램이나 데이터베이스의 논리적 구조는 전혀 영향을 받지 않는다. 이 독립성은 개념 스키마와 내부 스키마 사이의 사상을 통해 구현된다.17</p>
</li>
</ul>
<p>이처럼 데이터 독립성은 시스템의 장기적인 생명주기 동안 발생하는 수많은 변화에 유연하게 대처할 수 있는 강력한 기반을 제공한다. 하지만 이러한 유연성은 대가 없이 얻어지는 것이 아니다. 외부 스키마에 대한 사용자 요청은 외부/개념 사상, 개념/내부 사상이라는 여러 변환 단계를 거쳐야만 물리적 데이터에 도달할 수 있다.19 각 사상 단계는 요청을 해석하고 변환하는 데 컴퓨팅 자원을 소모하므로, 시스템에 일정한 오버헤드를 발생시킨다. 이 때문에 규모가 작고 단순한 시스템에서는 3계층 아키텍처를 엄격하게 분리하는 것이 오히려 불필요한 성능 저하를 유발할 수도 있다.19 반면, 수많은 사용자와 애플리케이션이 복잡하게 얽혀 있는 대규모 엔터프라이즈 시스템에서는 이러한 성능 오버헤드를 감수하더라도, 장기적인 유지보수 비용 절감과 변화에 대한 대응 능력 확보라는 더 큰 가치를 얻을 수 있다. 결국 데이터 독립성의 확보 여부는 ’현재의 실행 성능’과 ‘미래의 변경 유연성’ 사이의 중요한 설계적 트레이드오프(trade-off) 관계에 있으며, 설계자는 시스템의 특성과 요구사항을 고려하여 이 균형점을 찾아야 한다.</p>
<h2>4.  효과적인 데이터베이스 스키마 설계 원칙과 절차</h2>
<h3>4.1  스키마 설계 4단계 프로세스</h3>
<p>견고하고 효율적인 데이터베이스 스키마는 즉흥적으로 만들어지지 않는다. 이는 잘 정립된 공학적 절차를 따르는 체계적인 과정의 산물이다. 일반적으로 데이터베이스 설계는 요구사항 분석, 개념적 설계, 논리적 설계, 물리적 설계의 4단계로 진행된다.25</p>
<ul>
<li>
<p><strong>1단계: 요구사항 분석(Requirements Analysis):</strong> 모든 설계의 출발점은 ’무엇을 만들 것인가’를 명확히 하는 것이다. 이 단계에서는 데이터베이스를 사용할 사람들과의 인터뷰, 설문조사, 기존 업무 양식(송장, 보고서 등) 분석 등을 통해 시스템의 목적과 필요한 기능을 파악한다.27 데이터베이스에 저장해야 할 정보의 종류, 데이터의 처리 흐름, 사용자별 요구사항, 각종 제약 조건 등을 수집하고 종합하여 ’요구사항 명세서’라는 공식 문서로 정리한다.29 이 문서는 이후 모든 설계 단계의 기준점이 된다.</p>
</li>
<li>
<p><strong>2단계: 개념적 설계(Conceptual Design):</strong> 요구사항 분석을 통해 얻은 추상적인 정보를 바탕으로, 데이터베이스의 핵심적인 구조를 시각적으로 모델링하는 단계이다. 이 과정은 특정 데이터베이스 관리 시스템(DBMS)에 종속되지 않는 독립적인 모델을 만드는 것을 목표로 한다.26 이 단계의 가장 중요한 산출물은 ’개체-관계 다이어그램(Entity-Relationship Diagram, ERD)’이다.29 ERD는 시스템에 필요한 데이터의 묶음인 ‘개체(Entity)’, 각 개체의 속성인 ‘속성(Attribute)’, 그리고 개체들 간의 연관성인 ’관계(Relationship)’를 표준화된 기호로 표현하여 데이터의 전체적인 구조를 한눈에 파악할 수 있게 해준다.34</p>
</li>
<li>
<p><strong>3단계: 논리적 설계(Logical Design):</strong> 개념적 설계 단계에서 만들어진 추상적인 ERD를 특정 DBMS가 이해하고 구현할 수 있는 논리적인 데이터 구조로 변환하는 과정이다.25 만약 관계형 데이터베이스(RDBMS)를 사용하기로 결정했다면, ERD의 개체는 테이블(릴레이션)로, 속성은 컬럼으로, 관계는 외래 키(Foreign Key) 등으로 변환된다.31 이 단계에서 가장 중요한 활동 중 하나는 ‘정규화(Normalization)’ 과정이다. 정규화는 데이터의 중복을 최소화하고 데이터 간의 종속성을 분석하여 테이블을 효율적으로 분리함으로써, 데이터 불일치나 이상 현상이 발생할 가능성을 줄이는 체계적인 절차이다.25</p>
</li>
<li>
<p><strong>4.단계: 물리적 설계(Physical Design):</strong> 논리적 설계를 통해 정의된 테이블 구조를 실제 저장 장치에 어떻게 구현할지를 결정하는 마지막 단계이다.26 이 단계에서는 각 컬럼의 구체적인 데이터 타입(예: <code>VARCHAR(255)</code>, <code>INT</code>), 저장 공간 할당, 데이터 검색 성능을 향상시키기 위한 인덱스(Index) 생성 전략, 대용량 테이블을 관리하기 위한 파티셔닝(Partitioning) 기법, 데이터 파일의 물리적 저장 위치 및 구조 등을 결정한다.25 이 단계의 결정은 데이터베이스의 실제 성능에 직접적인 영향을 미친다.</p>
</li>
</ul>
<h3>4.2  핵심 설계 원칙</h3>
<p>효과적인 스키마를 설계하기 위해 공통적으로 지켜야 할 몇 가지 핵심 원칙이 있다.</p>
<ul>
<li>
<p><strong>명확한 명명 규칙(Naming Conventions):</strong> 일관성 있는 명명 규칙은 스키마의 가독성을 높여 다른 개발자들이나 미래의 자신이 코드를 쉽게 이해하고 유지보수할 수 있도록 돕는다.6 일반적인 규칙은 다음과 같다.</p>
</li>
<li>
<p>테이블 이름은 해당 테이블이 여러 개의 데이터를 담는 집합이므로 복수형(<code>Users</code>)을 사용하거나, 개체 자체를 나타내는 단수형(<code>User</code>)을 일관되게 사용한다.6</p>
</li>
<li>
<p>컬럼, 테이블 등의 이름에는 <code>snake_case</code> (예: <code>user_name</code>) 또는 <code>camelCase</code> (예: <code>userName</code>)를 일관되게 적용한다.37</p>
</li>
<li>
<p><code>SELECT</code>, <code>FROM</code>, <code>WHERE</code> 등 SQL 예약어는 이름으로 사용하지 않는다.38</p>
</li>
<li>
<p>이름에 공백이나 하이픈(-), 특수문자를 사용하지 않는다.6</p>
</li>
<li>
<p><strong>데이터 무결성 보장(Ensuring Data Integrity):</strong> 데이터의 정확성과 일관성을 유지하는 것은 데이터베이스의 가장 중요한 역할 중 하나이다. 스키마 설계 시 DBMS가 제공하는 제약 조건을 적극적으로 활용하여 데이터 무결성을 강제해야 한다.6</p>
</li>
<li>
<p><strong>개체 무결성(Entity Integrity):</strong> 테이블의 각 행은 고유하게 식별될 수 있어야 한다. 이는 기본 키(Primary Key)를 통해 보장되며, 기본 키 컬럼은 <code>NULL</code> 값을 가질 수 없고, 테이블 내에서 항상 유일한 값을 가져야 한다.40</p>
</li>
<li>
<p><strong>참조 무결성(Referential Integrity):</strong> 테이블 간의 관계가 깨지지 않도록 보장한다. 이는 외래 키(Foreign Key)를 통해 구현된다. 외래 키 값은 반드시 참조하는 테이블의 기본 키 값 중 하나이거나, 관계가 선택적인 경우 <code>NULL</code> 값을 가져야 한다.40</p>
</li>
<li>
<p><strong>도메인 무결성(Domain Integrity):</strong> 각 컬럼에 저장될 수 있는 값의 종류와 범위를 제한한다. 이는 적절한 데이터 타입 지정, <code>NOT NULL</code> 제약, <code>DEFAULT</code> 값 설정, <code>CHECK</code> 제약(예: 나이는 0보다 커야 함) 등을 통해 보장된다.41</p>
</li>
<li>
<p><strong>문서화(Documentation):</strong> 잘 작성된 문서는 스키마의 생명력을 연장시킨다. 스키마는 생성된 후에도 오랫동안 여러 사람에 의해 참조되고 수정된다.6 따라서 각 테이블과 컬럼이 무엇을 의미하는지, 왜 특정 데이터 타입이 선택되었는지, 복잡한 제약 조건의 의도는 무엇인지 등을 명시적으로 문서화하는 습관이 매우 중요하다.7</p>
</li>
</ul>
<h3>4.3  정규화(Normalization): 데이터 중복 최소화와 이상 현상 방지</h3>
<p>정규화는 관계형 데이터베이스 설계의 핵심 이론으로, 데이터의 중복성을 줄이고 데이터 무결성을 향상시키기 위해 테이블을 체계적으로 분해하는 과정이다.45 데이터가 중복 저장되면 저장 공간이 낭비될 뿐만 아니라, 데이터를 수정할 때 여러 곳을 동시에 변경해야 하므로 데이터 불일치가 발생할 위험이 커진다. 이러한 문제로 인해 발생하는 데이터 조작의 어려움을 ’이상 현상(Anomaly)’이라고 하며, 정규화는 이러한 이상 현상을 방지하는 것을 주된 목적으로 한다.47</p>
<ul>
<li>
<p><strong>이상 현상(Anomaly)의 종류</strong></p>
</li>
<li>
<p><strong>삽입 이상(Insertion Anomaly):</strong> 불필요한 데이터 없이는 어떤 데이터를 삽입할 수 없는 문제. 예를 들어, ‘수강’ 테이블에 학생 정보와 과목 정보가 함께 있을 때, 아직 아무 과목도 신청하지 않은 신입생 정보를 등록할 수 없다.</p>
</li>
<li>
<p><strong>갱신 이상(Update Anomaly):</strong> 중복된 데이터 중 일부만 수정되어 데이터의 일관성이 깨지는 문제. 예를 들어, 어떤 학생의 주소가 여러 행에 중복 저장되어 있을 때, 주소 변경 시 일부 행만 수정하면 어떤 주소가 올바른지 알 수 없게 된다.46</p>
</li>
<li>
<p><strong>삭제 이상(Deletion Anomaly):</strong> 특정 정보를 삭제하면, 유지되어야 할 다른 정보까지 함께 삭제되는 문제. 예를 들어, 어떤 학생이 신청한 과목이 하나뿐일 때 그 수강 신청을 취소하면, 해당 학생의 정보 자체가 데이터베이스에서 사라져 버릴 수 있다.46</p>
</li>
<li>
<p>정규화 과정</p>
</li>
</ul>
<p>정규화는 여러 단계의 ’정규형(Normal Form)’을 순차적으로 만족시켜 나가는 과정이다. 일반적으로 제3정규형(3NF)까지 만족시키는 것을 목표로 한다.45</p>
<ul>
<li>
<p><strong>제1정규형(1NF):</strong> 테이블의 모든 컬럼 값이 ’원자 값(Atomic Value)’을 가져야 한다는 규칙이다.49 즉, 하나의 셀에 여러 개의 값이 콤마 등으로 구분되어 들어가거나, 반복되는 그룹이 있어서는 안 된다. 예를 들어, 한 명의 학생이 여러 개의 전화번호를 가질 경우, ‘전화번호’ 컬럼에 ’010-1111-1111, 02-222-2222’와 같이 저장하는 대신, 별도의 ‘전화번호’ 테이블을 만들어 학생과 1:N 관계로 분리해야 한다.48</p>
</li>
<li>
<p><strong>제2정규형(2NF):</strong> 테이블이 1NF를 만족하고, 모든 컬럼이 기본 키 전체에 완전하게 종속되어야 한다는 규칙이다. 이는 기본 키가 여러 컬럼으로 구성된 ’복합 키(Composite Key)’일 때 의미가 있다. 기본 키의 일부에만 종속되는 ’부분 함수 종속’이 존재해서는 안 된다.49 예를 들어, <code>(학생ID, 과목ID)</code>가 기본 키인 ‘수강성적’ 테이블에 ‘학생이름’ 컬럼이 있다면, ’학생이름’은 ’학생ID’에만 종속되므로 2NF를 위반한다. 이 경우 ‘학생’ 테이블과 ‘수강성적’ 테이블로 분리해야 한다.45</p>
</li>
<li>
<p><strong>제3정규형(3NF):</strong> 테이블이 2NF를 만족하고, 기본 키가 아닌 컬럼들 간에 종속 관계, 즉 ’이행적 함수 종속’이 없어야 한다는 규칙이다.50 예를 들어, ‘학생’ 테이블에 <code>학생ID (기본키)</code>, ‘학과명’, ‘학과사무실전화번호’ 컬럼이 있다고 가정하자. ’학과사무실전화번호’는 ’학과명’에 의해 결정되고, ’학과명’은 ’학생ID’에 의해 결정된다. 이처럼 기본 키가 아닌 ’학과명’을 거쳐 다른 컬럼이 종속되는 관계를 제거해야 한다. 이 경우 ‘학생’ 테이블과 ‘학과’ 테이블로 분리하여 이행적 종속을 제거한다.45</p>
</li>
<li>
<p><strong>BCNF(Boyce-Codd Normal Form):</strong> 3NF를 더욱 강화한 정규형으로, 모든 결정자(determinant, 다른 컬럼의 값을 유일하게 결정하는 컬럼 또는 컬럼의 집합)가 후보 키(candidate key)여야 한다는 규칙이다.47 3NF를 만족하더라도 드물게 발생할 수 있는 이상 현상을 해결하기 위해 적용된다.</p>
</li>
</ul>
<p>각 정규형의 핵심 목표와 해결하는 문제를 요약하면 아래 표와 같다.</p>
<p><strong>Table 2: 정규형 요약 및 목적</strong></p>
<table><thead><tr><th><strong>정규형</strong></th><th><strong>핵심 목표 (제거 대상)</strong></th><th><strong>주요 해결 문제</strong></th></tr></thead><tbody>
<tr><td><strong>제1정규형 (1NF)</strong></td><td>반복 그룹 및 다중 값 속성</td><td>데이터 구조의 단순화, SQL 쿼리 가능</td></tr>
<tr><td><strong>제2정규형 (2NF)</strong></td><td>부분 함수 종속</td><td>복합 키 사용 시 발생하는 데이터 중복 및 갱신 이상</td></tr>
<tr><td><strong>제3정규형 (3NF)</strong></td><td>이행적 함수 종속</td><td>일반 속성 간의 종속으로 인한 데이터 불일치 및 갱신 이상</td></tr>
<tr><td><strong>BCNF</strong></td><td>후보 키가 아닌 결정자</td><td>제3정규형에서 해결되지 않는 미세한 이상 현상</td></tr>
</tbody></table>
<h3>4.4  비정규화(Denormalization): 성능 최적화를 위한 의도된 중복</h3>
<p>정규화는 데이터의 논리적 무결성을 확보하는 이상적인 방법이지만, 현실 세계의 시스템에서는 항상 최선이 아닐 수 있다. 과도하게 정규화된 스키마는 수많은 테이블로 분리되어, 데이터를 조회할 때마다 여러 테이블을 연결하는 복잡한 조인(JOIN) 연산을 요구하게 된다. 이는 특히 읽기 작업이 매우 빈번한 시스템에서 심각한 성능 저하를 유발할 수 있다.8</p>
<p>이러한 성능 문제를 해결하기 위해 도입된 기법이 ’비정규화(Denormalization)’이다. 비정규화는 조회 성능을 향상시키기 위해, 정규화 원칙에 의도적으로 위배하여 데이터의 중복을 허용하거나 테이블을 병합하는 전략을 말한다.8 예를 들어, 게시글 목록을 보여줄 때 매번 <code>users</code> 테이블을 조인하여 작성자 이름을 가져오는 대신, <code>posts</code> 테이블에 <code>user_name</code> 컬럼을 중복으로 저장해두면 조인 없이 빠르게 목록을 구성할 수 있다. 이러한 방식은 데이터 웨어하우스나 분석 시스템과 같이 대량의 데이터를 빠르게 읽어야 하는 OLAP(Online Analytical Processing) 환경에서 특히 유용하다.54</p>
<p>여기서 중요한 점은 정규화와 비정규화를 서로 대립하는 개념으로 보아서는 안 된다는 것이다. 많은 초심자들이 정규화를 절대적인 선으로, 비정규화를 피해야 할 악으로 오해하지만, 이는 잘못된 접근이다. 효과적인 스키마 설계는 이 두 가지를 상호 보완적인 ‘튜닝’ 도구로 활용하는 과정이다. 이상적인 설계 프로세스는 먼저 정규화 원칙에 따라 데이터 모델의 논리적 무결성과 일관성을 갖춘 스키마를 구축하는 것에서 시작한다. 그 후, 애플리케이션의 주요 쿼리 패턴과 성능 요구사항을 분석하여 병목이 예상되거나 실제로 발생하는 지점을 식별한다. 그리고 바로 그 지점에 한해, 성능 향상을 목적으로 신중하고 제한적으로 비정규화를 적용하는 것이다.54 즉, “먼저 정규화하고, 성능이 요구되는 곳에만 비정규화하라“는 원칙을 따르는 것이 핵심이다.54 이는 데이터베이스 설계가 순수한 이론에만 머무르는 것이 아니라, 실제 운영 환경의 워크로드에 맞춰 최적화되어야 하는 실용적인 공학 활동임을 명확히 보여준다.</p>
<h2>5.  스키마와 데이터베이스 성능 최적화</h2>
<p>잘 설계된 스키마는 그 자체로 성능의 기반이 되지만, 실제 운영 환경의 대규모 데이터와 복잡한 쿼리를 효율적으로 처리하기 위해서는 스키마와 밀접하게 관련된 여러 최적화 기법을 함께 고려해야 한다.</p>
<h3>5.1  인덱싱 전략과 스키마의 관계</h3>
<p>인덱스(Index)는 데이터베이스 테이블에 대한 검색 성능을 비약적으로 향상시키는 핵심적인 자료구조이다.55 책의 맨 뒤에 있는 ’찾아보기’와 같이, 특정 데이터를 찾기 위해 테이블 전체를 스캔하는 대신 인덱스를 통해 데이터의 위치를 빠르게 찾아갈 수 있게 해준다. 특히 <code>WHERE</code> 절의 조건, <code>JOIN</code> 연산의 연결고리, <code>ORDER BY</code> 절의 정렬 기준이 되는 컬럼에 인덱스를 생성하면 쿼리 실행 속도를 크게 개선할 수 있다.8</p>
<p>하지만 인덱스는 만능 해결책이 아니다. 인덱스는 원본 데이터와는 별도의 추가적인 저장 공간을 차지하며, 테이블에 데이터가 삽입(INSERT), 수정(UPDATE), 삭제(DELETE)될 때마다 인덱스 구조도 함께 갱신되어야 한다. 이 과정은 쓰기 작업에 오버헤드를 발생시켜 성능을 저하시키는 요인이 된다.8 따라서 무분별한 인덱스 생성은 오히려 시스템 전체의 성능을 악화시킬 수 있다. 효과적인 인덱싱 전략은 애플리케이션의 쿼리 패턴을 분석하여, 읽기 성능 향상의 이점과 쓰기 성능 저하의 비용 사이에서 최적의 균형점을 찾는 것이다.</p>
<p>스키마 설계 시점부터 자주 사용될 쿼리를 예측하고, 그에 맞는 인덱스 전략을 함께 구상하는 것이 중요하다. 예를 들어, 두 개 이상의 컬럼이 <code>WHERE</code> 절에 함께 자주 사용된다면, 각 컬럼에 개별 인덱스를 만드는 것보다 두 컬럼을 묶어 하나의 ’복합 인덱스(Composite Index)’를 생성하는 것이 더 효율적일 수 있다.57 또한, 쿼리에 필요한 모든 컬럼을 포함하는 ’커버링 인덱스(Covering Index)’를 설계하면, 실제 테이블에 접근할 필요 없이 인덱스만으로 쿼리를 처리할 수 있어 I/O를 크게 줄일 수 있다.57</p>
<h3>5.2  대용량 데이터 관리를 위한 파티셔닝 및 샤딩</h3>
<p>데이터가 수억, 수십억 건으로 증가하면 단일 테이블을 관리하고 쿼리하는 것만으로도 성능 한계에 부딪히게 된다. 이러한 대용량 데이터를 효과적으로 관리하기 위해 스키마 수준에서 적용할 수 있는 기법이 파티셔닝과 샤딩이다.</p>
<ul>
<li>
<p><strong>파티셔닝(Partitioning):</strong> 논리적으로는 하나의 거대한 테이블이지만, 물리적으로는 특정 기준에 따라 여러 개의 작은 조각(파티션)으로 나누어 저장하는 기법이다.55 예를 들어, ‘판매’ 테이블을 ‘판매 연도’ 기준으로 파티셔닝하면, ‘2023년 판매 데이터 조회’ 쿼리는 2023년 파티션만 스캔하면 되므로 전체 테이블을 스캔하는 것보다 훨씬 빠르게 결과를 얻을 수 있다. 이처럼 파티셔닝은 쿼리가 스캔해야 할 데이터의 범위를 줄여 성능을 향상시킨다.</p>
</li>
<li>
<p><strong>샤딩(Sharding):</strong> 파티셔닝과 개념적으로 유사하지만, 데이터를 분할하여 여러 다른 데이터베이스 서버에 물리적으로 분산 저장하는 ‘수평적 확장(Horizontal Scaling)’ 기법이다.57 단일 서버가 감당할 수 있는 저장 공간이나 처리 능력의 한계를 극복하고, 대규모 트래픽과 데이터를 여러 서버로 분산하여 처리할 수 있게 해준다. 예를 들어, 사용자 ID를 기준으로 데이터를 샤딩하여 각 서버가 특정 범위의 사용자 데이터만 담당하도록 구성할 수 있다.</p>
</li>
</ul>
<h3>5.3  쿼리 성능을 고려한 설계 기법</h3>
<p>스키마 설계는 단순히 데이터를 어떻게 저장할 것인가의 문제를 넘어, 데이터가 어떻게 사용될 것인가를 깊이 고려해야 하는 과정이다.</p>
<ul>
<li>
<p><strong>쿼리 패턴 분석 기반 설계:</strong> 애플리케이션에서 가장 빈번하게 실행되는 핵심 쿼리들을 식별하고, 해당 쿼리들이 최소한의 조인과 데이터 스캔으로 실행될 수 있도록 테이블 구조를 설계해야 한다.57 예를 들어, 항상 함께 조회되는 정보들은 비록 다른 개체에 속하더라도 비정규화 기법을 적용하여 같은 테이블에 배치하는 것을 고려할 수 있다.54</p>
</li>
<li>
<p><strong>불필요한 데이터 조회 최소화:</strong> <code>SELECT *</code> 구문은 개발 시에는 편리하지만, 운영 환경에서는 불필요한 컬럼까지 모두 조회하여 네트워크 대역폭과 메모리를 낭비하고 성능을 저하시키는 주된 원인이다.55 애플리케이션 개발 시 필요한 컬럼만 명시적으로 조회하도록 하는 것이 기본 원칙이지만, 스키마 설계 단계에서도 이러한 원칙을 지원하는 구조를 고민해야 한다.</p>
</li>
<li>
<p><strong>적절한 데이터 타입 선택:</strong> 데이터 타입을 신중하게 선택하는 것은 저장 공간 효율성과 연산 성능에 직접적인 영향을 미친다.60 예를 들어, 상태 값을 저장할 때 긴 문자열 대신 <code>ENUM</code> 타입이나 작은 정수(<code>TINYINT</code>)를 사용하면 저장 공간을 크게 절약할 수 있다. 주민등록번호와 같이 연산이 필요 없는 숫자 데이터는 문자열 타입으로 저장하는 것이 더 적절할 수 있다. 또한, 가변 길이 문자열(<code>VARCHAR</code>)을 사용할 때는 예상되는 데이터의 최대 길이를 고려하여 너무 크지 않게, 적절한 크기로 설정하는 것이 효율적이다.57</p>
</li>
</ul>
<h2>6.  현대 데이터베이스 환경과 스키마 패러다임</h2>
<p>과거에는 관계형 데이터베이스와 고정된 스키마가 데이터 관리의 표준이었지만, 빅데이터와 클라우드 컴퓨팅 시대가 도래하면서 데이터의 형태와 처리 방식이 다양해졌고, 이에 따라 새로운 스키마 패러다임이 등장했다.</p>
<h3>6.1  SQL vs. NoSQL: 고정 스키마와 동적 스키마의 비교</h3>
<p>현대 데이터베이스 시스템은 크게 SQL(관계형)과 NoSQL(비관계형)로 양분된다. 이 둘의 가장 근본적인 차이점 중 하나는 스키마를 다루는 방식에 있다.</p>
<ul>
<li>
<p><strong>SQL (관계형 데이터베이스):</strong> 전통적인 SQL 데이터베이스는 ’고정 스키마(Fixed Schema)’를 기반으로 한다.62 이는 데이터를 저장하기 전에 테이블의 구조, 각 컬럼의 데이터 타입, 제약 조건 등을 미리 엄격하게 정의해야 함을 의미한다. 이러한 사전 정의된 구조 덕분에 데이터의 무결성과 일관성을 강력하게 보장할 수 있으며, 이는 금융 거래나 전자상거래와 같이 데이터의 정확성이 매우 중요한 시스템에 적합하다. SQL 데이터베이스는 트랜잭션의 ACID(원자성, 일관성, 격리성, 내구성) 속성을 철저히 준수한다.63</p>
</li>
<li>
<p><strong>NoSQL (비관계형 데이터베이스):</strong> 반면, NoSQL 데이터베이스는 ‘스키마가 없거나(Schemaless)’ 매우 유연한 ’동적 스키마(Dynamic Schema)’를 특징으로 한다.15 이는 정해진 틀 없이 다양한 형태의 데이터를 저장할 수 있음을 의미한다. 정형 데이터뿐만 아니라, 구조가 일정하지 않은 반정형(JSON, XML) 데이터나 비정형(텍스트, 이미지, 비디오) 데이터도 쉽게 저장할 수 있다.66 이러한 유연성은 비즈니스 요구사항이 빠르게 변하거나 데이터 모델을 예측하기 어려운 초기 개발 단계에 큰 장점을 제공한다.68</p>
</li>
</ul>
<p>이러한 스키마 처리 방식의 차이는 데이터를 언제 검증하느냐의 차이로 이어진다.</p>
<ul>
<li>
<p><strong>쓰기 스키마(Schema-on-Write):</strong> SQL 데이터베이스가 사용하는 방식으로, 데이터를 데이터베이스에 쓸 때(write) 미리 정의된 스키마에 맞는지 검증한다.70 스키마에 맞지 않는 데이터는 저장이 거부된다. 이 방식은 쓰기 과정에서 약간의 오버헤드가 발생할 수 있지만, 일단 저장된 데이터는 일관성과 정합성이 보장되므로 데이터를 읽을 때(read) 빠르고 안정적으로 처리할 수 있다.71</p>
</li>
<li>
<p><strong>읽기 스키마(Schema-on-Read):</strong> 많은 NoSQL 데이터베이스가 채택하는 방식으로, 데이터를 쓸 때는 스키마 검증 없이 있는 그대로 빠르게 저장한다.71 그리고 데이터를 읽을 때(read) 애플리케이션이 데이터의 구조를 해석하고 필요한 형태로 가공한다.70 이 방식은 다양한 형태의 데이터를 빠르게 수집(ingestion)하는 데 매우 유리하지만, 읽기 시점에 데이터 처리 부담이 발생하며, 데이터의 일관성을 보장하는 책임이 데이터베이스가 아닌 애플리케이션으로 넘어가게 된다.73</p>
</li>
</ul>
<p>SQL과 NoSQL의 스키마 관련 특성을 비교하면 다음과 같다.</p>
<p><strong>Table 3: SQL vs. NoSQL 스키마 특성 비교</strong></p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>SQL (관계형)</strong></th><th><strong>NoSQL (비관계형)</strong></th></tr></thead><tbody>
<tr><td><strong>스키마 모델</strong></td><td>고정 스키마 (Fixed Schema)</td><td>동적/유연 스키마 (Dynamic/Flexible Schema)</td></tr>
<tr><td><strong>스키마 적용 시점</strong></td><td>쓰기 시점 (Schema-on-Write)</td><td>읽기 시점 (Schema-on-Read)</td></tr>
<tr><td><strong>데이터 구조</strong></td><td>정형 데이터 (테이블, 행, 열)</td><td>비정형, 반정형, 정형 데이터 (문서, 키-값, 그래프)</td></tr>
<tr><td><strong>데이터 무결성</strong></td><td>강력하게 보장 (ACID)</td><td>최종적 일관성 (BASE), 일부 ACID 지원</td></tr>
<tr><td><strong>확장성</strong></td><td>수직적 확장 (Vertical Scaling) 중심</td><td>수평적 확장 (Horizontal Scaling) 용이</td></tr>
<tr><td><strong>주요 사용 사례</strong></td><td>금융, 전자상거래, ERP 등 트랜잭션 무결성이 중요한 시스템</td><td>빅데이터, 소셜 미디어, IoT 등 대용량 데이터 및 빠른 개발 속도가 중요한 시스템</td></tr>
</tbody></table>
<h3>6.2  데이터 웨어하우스를 위한 스키마 모델</h3>
<p>일상적인 트랜잭션을 처리하는 운영 데이터베이스(OLTP)와 달리, 대량의 데이터를 분석하고 비즈니스 인사이트를 도출하기 위한 데이터 웨어하우스(Data Warehouse) 환경에서는 분석 쿼리에 최적화된 특별한 스키마 모델이 사용된다.</p>
<ul>
<li>
<p><strong>스타 스키마(Star Schema):</strong> 가장 널리 사용되는 데이터 웨어하우스 스키마 모델로, 이름처럼 별 모양의 구조를 가진다.4 중심에는 측정 가능한 수치 데이터(예: 매출액, 판매량)를 담고 있는 하나의 ’사실 테이블(Fact Table)’이 위치한다. 그리고 이 사실 테이블을 여러 개의 ’차원 테이블(Dimension Table)’이 둘러싸고 있다. 차원 테이블은 사실 데이터를 분석하는 기준이 되는 정보(예: 시간, 상품, 고객, 지역)를 담고 있으며, 사실 테이블과는 기본 키-외래 키 관계로 연결된다. 스타 스키마는 구조가 단순하고 직관적이어서 사용자가 이해하기 쉽고, 조인 경로가 짧아 분석 쿼리의 성능이 우수하다는 장점이 있다.6</p>
</li>
<li>
<p><strong>눈송이 스키마(Snowflake Schema):</strong> 스타 스키마의 변형된 형태로, 차원 테이블이 추가적으로 정규화되어 여러 개의 하위 차원 테이블로 분리된 구조를 가진다.4 예를 들어, ‘상품’ 차원 테이블이 ‘상품’ 테이블, ‘브랜드’ 테이블, ‘카테고리’ 테이블 등으로 더 세분화되는 식이다. 이 구조는 데이터의 중복을 줄여 저장 공간을 효율적으로 사용할 수 있다는 장점이 있지만, 차원 테이블이 여러 단계로 나뉘면서 조인이 더 복잡해지고, 이로 인해 쿼리 성능이 스타 스키마에 비해 저하될 수 있다.74</p>
</li>
</ul>
<h2>7.  스키마 변경 관리: 진화와 마이그레이션</h2>
<p>소프트웨어는 살아있는 유기체와 같아서, 비즈니스 요구사항의 변화, 새로운 기능 추가, 기술의 발전에 따라 끊임없이 변화하고 성장한다. 애플리케이션의 변화는 필연적으로 그 기반이 되는 데이터베이스 스키마의 변경을 요구한다. 따라서 스키마를 어떻게 안전하고 효율적으로 관리하고 변경하는가는 현대 소프트웨어 개발에서 매우 중요한 과제이다.</p>
<h3>7.1  스키마 진화(Evolution)와 마이그레이션(Migration)의 개념</h3>
<p>스키마 변경 관리를 이해하기 위해 ’진화’와 ’마이그레이션’이라는 두 가지 용어를 명확히 구분할 필요가 있다.</p>
<ul>
<li>
<p><strong>스키마 진화(Schema Evolution):</strong> 비즈니스 또는 애플리케이션의 요구사항 변화에 부응하기 위해 데이터베이스 스키마가 시간이 지남에 따라 점진적으로 수정되고 발전해 나가는 과정 자체를 의미하는 포괄적인 개념이다.76 이는 새로운 컬럼을 추가하거나, 기존 컬럼을 수정하거나, 더 이상 사용되지 않는 테이블을 삭제하는 등의 모든 변경 활동을 포함한다.</p>
</li>
<li>
<p><strong>스키마 마이그레이션(Schema Migration):</strong> 스키마 진화 과정에서 발생하는 각각의 변경 사항을 버전 관리하고, 이를 데이터베이스에 체계적으로 적용하는 구체적인 기술적 행위를 말한다.76 마이그레이션은 일반적으로 버전 번호가 부여된 스크립트 형태로 관리되며, 특정 버전의 스키마로 업데이트하거나 이전 버전으로 되돌리는(revert) 작업을 자동화된 도구를 통해 수행한다.8 즉, 스키마 마이그레이션은 스키마 진화의 이력을 추적하고 관리하는 실질적인 수단이다.79</p>
</li>
</ul>
<h3>7.2  안전한 스키마 변경을 위한 전략</h3>
<p>운영 중인 서비스의 데이터베이스 스키마를 변경하는 것은 매우 위험이 따르는 작업이다. 잘못된 변경은 데이터 손실이나 서비스 중단으로 이어질 수 있다. 따라서 다운타임을 최소화하고 안정성을 확보하기 위한 다양한 전략이 사용된다.</p>
<ul>
<li>
<p><strong>무중단(Zero-Downtime) 마이그레이션:</strong> 사용자가 서비스를 이용하는 중에 서비스 중단 없이 스키마 변경을 완료하는 것을 목표로 하는 전략이다. 이를 위해 여러 고급 기법들이 동원된다.</p>
</li>
<li>
<p><strong>Blue-Green 배포:</strong> 현재 운영 중인 환경(Blue)과 동일한 새로운 환경(Green)을 구축한 뒤, Green 환경에만 새로운 스키마와 애플리케이션을 배포한다. 테스트가 완료되면 트래픽을 Blue에서 Green으로 전환하여 중단 없이 업데이트를 완료한다.80</p>
</li>
<li>
<p><strong>CDC(Change Data Capture):</strong> 마이그레이션 과정 동안 원본 데이터베이스에서 발생하는 변경 사항(INSERT, UPDATE, DELETE)을 로그를 통해 실시간으로 감지하여 새로운 데이터베이스에 지속적으로 반영하는 기술이다. 이를 통해 두 데이터베이스 간의 데이터 동기화를 유지하며, 서비스 전환 시점의 데이터 손실을 최소화할 수 있다.81</p>
</li>
<li>
<p><strong>확장-마이그레이션-축소(Expand-Migrate-Contract) 패턴:</strong> 하위 호환성을 유지하면서 점진적으로 스키마를 변경하는 매우 안정적인 패턴이다.83 이 패턴은 변경 과정을 세 단계로 나눈다.</p>
</li>
<li>
<p><strong>1단계 - 확장(Expand):</strong> 먼저 새로운 컬럼이나 테이블을 추가하는 등 스키마를 ’확장’하는 변경만 적용한다. 이 단계에서는 기존의 어떤 구조도 삭제하거나 수정하지 않으므로, 이전 버전의 애플리케이션 코드는 아무런 영향을 받지 않고 정상적으로 동작한다.</p>
</li>
<li>
<p><strong>2단계 - 마이그레이션(Migrate):</strong> 새로운 애플리케이션 코드를 배포한다. 이 코드는 데이터를 쓸 때 기존 구조와 새로운 구조 모두에 쓰거나, 새로운 구조에만 쓰도록 구현된다. 동시에 기존 데이터를 새로운 구조로 점진적으로 이전(backfill)하는 작업을 수행한다. 데이터 읽기는 상황에 따라 기존 구조, 새로운 구조, 또는 두 곳 모두에서 수행하며 일관성을 검증할 수 있다.</p>
</li>
<li>
<p><strong>3단계 - 축소(Contract):</strong> 모든 애플리케이션이 새로운 구조만을 사용하고, 데이터 이전이 완료되어 시스템이 안정화된 것을 확인한 후에, 더 이상 사용되지 않는 이전 구조(컬럼, 테이블)를 삭제하는 ‘축소’ 작업을 진행한다.</p>
</li>
<li>
<p><strong>하위 호환성(Backward Compatibility) 유지:</strong> 안전한 마이그레이션의 핵심 원칙은 어떤 시점에서든 실행 중인 애플리케이션 코드가 현재 데이터베이스 스키마와 호환되어야 한다는 것이다. 이를 위해 일반적으로 애플리케이션 배포보다 스키마 변경을 먼저 수행한다. 즉, 새로운 스키마가 적용된 후에도 이전 버전의 코드가 문제없이 동작할 수 있도록 변경 사항을 설계해야 한다.84 예를 들어, 컬럼을 삭제하는 대신 일단 사용하지 않도록 두고, 컬럼 이름을 바꾸는 대신 새로운 이름의 컬럼을 추가하는 방식을 사용한다.</p>
</li>
</ul>
<h3>7.3  스키마 버전 관리를 위한 도구</h3>
<p>수동으로 스키마 변경을 관리하는 것은 오류가 발생하기 쉽고, 여러 개발자가 협업하는 환경에서는 일관성을 유지하기 어렵다. 이러한 문제를 해결하기 위해 스키마 변경 이력을 코드로 관리하고 배포를 자동화하는 마이그레이션 도구가 널리 사용된다.8</p>
<ul>
<li>
<p><strong>Flyway:</strong> SQL 스크립트 기반의 마이그레이션 도구로, 단순함과 직관성을 장점으로 한다.86 개발자는 <code>V1__create_table.sql</code>, <code>V2__add_column.sql</code>과 같이 정해진 명명 규칙에 따라 SQL 파일을 작성한다. Flyway는 파일 이름에 포함된 버전 번호를 기준으로 스크립트를 순서대로 실행하고, 실행 이력을 데이터베이스 내의 메타데이터 테이블에 기록하여 중복 실행을 방지한다.78</p>
</li>
<li>
<p><strong>Liquibase:</strong> Flyway보다 더 유연하고 강력한 기능을 제공하는 도구이다.88 SQL뿐만 아니라 XML, YAML, JSON과 같은 선언적 형식으로 변경 사항(Changeset)을 정의할 수 있다. 이 방식은 특정 데이터베이스 문법에 종속되지 않는 변경을 기술할 수 있게 해준다. 또한, 변경 사항의 실행 순서를 명시적으로 제어할 수 있으며, 특정 조건에서만 변경을 실행하는 ‘전제 조건(precondition)’, 변경 사항을 되돌리는 ‘롤백(rollback)’ 기능 등 복잡한 시나리오에 대응할 수 있는 고급 기능을 다수 지원한다.78</p>
</li>
</ul>
<p>과거에 데이터베이스 스키마 변경이 소수의 데이터베이스 관리자(DBA)에 의해 수동으로 이루어지던 것과 달리, 현대 소프트웨어 개발에서는 ’Schema-as-Code’라는 패러다임이 보편화되었다.91 이는 마이그레이션 스크립트를 애플리케이션 소스 코드와 동일하게 취급하여 Git과 같은 버전 관리 시스템에서 함께 관리하는 것을 의미한다.76 더 나아가, 이러한 스키마 변경 과정을 CI/CD(지속적 통합/지속적 배포) 파이프라인에 통합하여, 코드 변경이 있을 때마다 데이터베이스 스키마를 자동으로 테스트하고 배포하는 것이 일반적인 관행이 되었다.88 이는 데이터베이스 관리가 더 이상 개발 프로세스의 병목점이 아니라, 신속하고 반복적인 개발을 지향하는 애자일 및 DevOps 문화의 핵심적인 일부가 되었음을 시사한다. 따라서 현대의 개발자와 운영 엔지니어에게 스키마 마이그레이션 도구의 사용법과 안전한 배포 전략에 대한 이해는 필수적인 역량이 되었다.</p>
<h2>8.  실제 사례로 배우는 스키마 설계</h2>
<p>이론적 개념을 실제 세계에 적용해보는 것은 이해를 심화하는 가장 좋은 방법이다. 여기서는 비교적 단순한 블로그 시스템과 복잡한 전자상거래 시스템의 스키마를 설계하는 과정을 통해 앞서 다룬 원칙들이 어떻게 적용되는지 살펴본다.</p>
<h3>8.1  사례 1: 블로그 시스템 스키마 설계</h3>
<p>블로그 시스템의 핵심 기능은 사용자가 가입하고, 글을 작성하며, 다른 사람의 글에 댓글을 달고, 글을 카테고리나 태그로 분류하는 것이다. 이러한 기능을 지원하기 위한 스키마를 설계해 보자.</p>
<ul>
<li>개체(Entities) 식별:</li>
</ul>
<p>요구사항에서 핵심 명사를 추출하면 다음과 같은 개체를 식별할 수 있다: users (사용자), posts (게시글), comments (댓글), categories (카테고리), tags (태그).93</p>
<ul>
<li>관계(Relationships) 정의:</li>
</ul>
<p>개체들 간의 관계를 정의하면 다음과 같다.</p>
<ul>
<li>
<p>한 명의 사용자는 여러 개의 게시글을 작성할 수 있다 (<code>users</code> 1 : N <code>posts</code>).</p>
</li>
<li>
<p>하나의 게시글에는 여러 개의 댓글이 달릴 수 있다 (<code>posts</code> 1 : N <code>comments</code>).</p>
</li>
<li>
<p>한 명의 사용자는 여러 개의 댓글을 작성할 수 있다 (<code>users</code> 1 : N <code>comments</code>).</p>
</li>
<li>
<p>하나의 게시글은 여러 카테고리에 속할 수 있고, 하나의 카테고리는 여러 게시글을 포함할 수 있다 (<code>posts</code> N : M <code>categories</code>).</p>
</li>
<li>
<p>하나의 게시글에는 여러 태그가 붙을 수 있고, 하나의 태그는 여러 게시글에 사용될 수 있다 (<code>posts</code> N : M <code>tags</code>).</p>
</li>
<li>
<p>논리적 설계 (테이블 구조화):</p>
</li>
</ul>
<p>ERD를 바탕으로 테이블 스키마를 설계한다. 여기서 N:M 관계는 직접 표현할 수 없으므로, 두 테이블의 기본 키를 외래 키로 갖는 ‘연결 테이블(Junction Table)’ 또는 ’연관 테이블(Associative Table)’을 통해 1:N 관계로 분해해야 한다.</p>
<ul>
<li>
<p><code>users</code> 테이블: <code>user_id</code> (PK), <code>username</code>, <code>email</code>, <code>password</code>, <code>created_at</code></p>
</li>
<li>
<p><code>posts</code> 테이블: <code>post_id</code> (PK), <code>title</code>, <code>body</code> (내용), <code>user_id</code> (FK, <code>users</code> 참조), <code>created_at</code>, <code>updated_at</code></p>
</li>
<li>
<p><code>comments</code> 테이블: <code>comment_id</code> (PK), <code>body</code>, <code>post_id</code> (FK, <code>posts</code> 참조), <code>user_id</code> (FK, <code>users</code> 참조), <code>created_at</code></p>
</li>
<li>
<p><code>categories</code> 테이블: <code>category_id</code> (PK), <code>name</code>, <code>slug</code> (URL용 이름)</p>
</li>
<li>
<p><code>tags</code> 테이블: <code>tag_id</code> (PK), <code>name</code></p>
</li>
<li>
<p><code>post_categories</code> 연결 테이블: <code>post_id</code> (FK, PK), <code>category_id</code> (FK, PK) 93</p>
</li>
<li>
<p><code>post_tags</code> 연결 테이블: <code>post_id</code> (FK, PK), <code>tag_id</code> (FK, PK)</p>
</li>
<li>
<p>SQL DDL 예시:</p>
</li>
</ul>
<p>다음은 위 설계를 바탕으로 한 MySQL DDL(Data Definition Language)의 일부 예시이다.</p>
<p>SQL</p>
<pre><code>CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE posts (
    post_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    body TEXT NOT NULL,
    user_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL
);

CREATE TABLE post_categories (
    post_id INT,
    category_id INT,
    PRIMARY KEY (post_id, category_id),
    FOREIGN KEY (post_id) REFERENCES posts(post_id) ON DELETE CASCADE,
    FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE
);
</code></pre>
<h3>8.2  사례 2: 전자상거래 시스템 스키마 설계</h3>
<p>전자상거래 시스템은 블로그보다 훨씬 복잡하며, 회원 관리, 상품 전시, 주문 처리, 결제, 배송 등 다양한 비즈니스 로직을 데이터베이스로 모델링해야 한다.</p>
<ul>
<li>개체(Entities) 식별:</li>
</ul>
<p>핵심 개체로는 customers (고객), products (상품), categories (상품 카테고리), orders (주문), order_items (주문 항목), payments (결제), shipments (배송), addresses (주소) 등이 있다.95</p>
<ul>
<li>
<p><strong>관계(Relationships) 및 주요 설계 고려사항:</strong></p>
</li>
<li>
<p>한 명의 고객은 여러 번 주문할 수 있다 (<code>customers</code> 1 : N <code>orders</code>).</p>
</li>
<li>
<p>하나의 주문은 여러 종류의 상품 항목을 포함할 수 있다 (<code>orders</code> 1 : N <code>order_items</code>).</p>
</li>
<li>
<p>하나의 상품은 여러 주문 항목에 포함될 수 있다 (<code>products</code> 1 : N <code>order_items</code>).</p>
</li>
<li>
<p>하나의 주문에 대해 하나의 결제와 하나의 배송이 이루어진다 (<code>orders</code> 1 : 1 <code>payments</code>, <code>orders</code> 1 : 1 <code>shipments</code>).</p>
</li>
</ul>
<p>이 과정에서 중요한 비즈니스 규칙이 스키마 설계에 직접적인 영향을 미치는 사례를 발견할 수 있다. 바로 ’주문 시점의 데이터’를 보존해야 한다는 점이다. 예를 들어, <code>order_items</code> 테이블을 설계할 때, <code>products</code> 테이블의 <code>product_id</code>만 외래 키로 참조하고 가격 정보는 저장하지 않는다고 가정해 보자. 만약 나중에 <code>products</code> 테이블에서 해당 상품의 가격이 인상되면, 과거의 주문 내역을 조회했을 때 인상된 가격으로 계산되어 총 주문 금액이 달라지는 심각한 데이터 불일치 문제가 발생한다. 마찬가지로, 주문 시 사용된 배송지 주소도 <code>orders</code> 테이블에 직접 저장해야 한다. 고객이 나중에 자신의 기본 배송지 주소를 변경하더라도, 과거 주문의 배송지 정보는 변경되지 않아야 하기 때문이다.97</p>
<p>이처럼 주문 당시의 상품 가격, 배송지 주소, 상품명 등 ’거래가 발생한 시점의 사실’을 해당 트랜잭션 테이블(<code>order_items</code>, <code>orders</code>)에 복사하여 저장하는 것은 매우 중요한 설계 기법이다. 이는 순수한 정규화 이론의 관점에서는 데이터 중복처럼 보일 수 있지만, 비즈니스 트랜잭션의 역사적 사실과 시간적 무결성을 보장하기 위한 필수적인 ’의도된 비정규화’이다. 이는 이론적 원칙보다 실제 비즈니스 요구사항이 스키마 설계에서 우선될 수 있음을 보여주는 강력한 사례이다.</p>
<ul>
<li>SQL DDL 예시:</li>
</ul>
<p>전자상거래 시스템의 일부 테이블에 대한 DDL 예시는 다음과 같다.</p>
<p>SQL</p>
<pre><code>CREATE TABLE customers (
    customer_id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock INT NOT NULL DEFAULT 0
);

CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(50) NOT NULL,
    shipping_address VARCHAR(255) NOT NULL, -- 주문 시점의 배송지 주소
    total_price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE order_items (
    order_item_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL, -- 주문 시점의 상품 가격
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
</code></pre>
<h2>9. 결론: 지속 가능한 데이터 아키텍처의 초석</h2>
<p>본 안내서는 데이터베이스 스키마의 근본적인 개념부터 현대적인 관리 기법에 이르기까지, 그 전반적인 내용을 심도 있게 다루었다. 스키마는 단순히 데이터의 구조를 정의하는 기술적 명세를 넘어, 데이터베이스 시스템의 안정성, 성능, 확장성을 좌우하는 건축물의 ’청사진’과 같은 역할을 수행함을 확인했다.</p>
<p>우리는 스키마가 3계층 아키텍처(외부, 개념, 내부)를 통해 어떻게 다양한 관점을 제공하고, 이를 통해 논리적 및 물리적 데이터 독립성을 확보하여 시스템의 유연성을 증대시키는지를 살펴보았다. 또한, 요구사항 분석에서부터 물리적 구현에 이르는 체계적인 설계 절차의 중요성을 강조했으며, 데이터 무결성을 위한 정규화와 성능 최적화를 위한 비정규화 사이의 균형을 맞추는 것이 효과적인 설계의 핵심임을 논했다.</p>
<p>나아가, 현대 데이터 환경의 주요 패러다임인 SQL의 ’고정 스키마’와 NoSQL의 ’동적 스키마’를 비교 분석함으로써, 각기 다른 비즈니스 요구사항과 데이터 특성에 따라 적합한 기술을 선택해야 함을 명확히 했다. 마지막으로, 애플리케이션이 진화함에 따라 필연적으로 발생하는 스키마 변경을 안전하고 체계적으로 관리하기 위한 ‘Schema-as-Code’ 접근 방식과 마이그레이션 도구의 활용이 DevOps 문화의 필수 요소가 되었음을 확인했다.</p>
<p>결론적으로, 잘 설계된 스키마는 단순히 현재의 요구사항을 만족시키는 데 그치지 않는다. 이는 미래의 예측 불가능한 비즈니스 변화에 유연하게 대응할 수 있는 기반을 마련하고, 시간이 지나도 데이터의 가치를 온전히 보존하며, 시스템 전체의 지속 가능성을 담보하는 가장 중요한 아키텍처 자산이다.37 견고한 스키마 위에 세워진 시스템만이 장기적인 성공을 거둘 수 있으며, 따라서 스키마 설계는 모든 데이터 기반 프로젝트에서 가장 신중하고 전략적으로 접근해야 할 초석이라 할 수 있다.</p>
<h2>10. Works cited</h2>
<ol>
<li>데이터베이스 스키마란 무엇입니까? 예시가 포함된 가이드 - AppMaster, accessed October 28, 2025, https://appmaster.io/ko/blog/yejega-pohamdoen-deiteobeiseu-seukima-gaideu</li>
<li>데이터베이스 스키마란 무엇인가요? - IBM, accessed October 28, 2025, https://www.ibm.com/kr-ko/think/topics/database-schema</li>
<li>en.wikipedia.org, accessed October 28, 2025, https://en.wikipedia.org/wiki/Database_schema</li>
<li>What Is a Database Schema? - IBM, accessed October 28, 2025, https://www.ibm.com/think/topics/database-schema</li>
<li>Database Schema: Definition, Types, and Benefits - Coursera, accessed October 28, 2025, https://www.coursera.org/articles/database-schema</li>
<li>데이터베이스 스키마 설계에 대한 전체 가이드 - Integrate.io, accessed October 28, 2025, https://www.integrate.io/ko/blog/complete-guide-to-database-schema-design-guide-ko/</li>
<li>Complete Guide to Database Schema Design | Integrate.io, accessed October 28, 2025, https://www.integrate.io/blog/complete-guide-to-database-schema-design-guide/</li>
<li>DB 스키마란?(Schema) - Somaz의 IT 공부 일지 - 티스토리, accessed October 28, 2025, https://somaz.tistory.com/208</li>
<li>What is a Database Schema and Why Does it Matter? - ThoughtSpot, accessed October 28, 2025, https://www.thoughtspot.com/data-trends/data-modeling/database-schema</li>
<li>스키마란? (개념스키마, 내부스키마, 외부스키마) - 개발자를 꿈꾸는 프로그래머, accessed October 28, 2025, https://jwprogramming.tistory.com/47</li>
<li>What Is a Database Schema? Benefits, Types &amp; Requirements - CData Software, accessed October 28, 2025, https://www.cdata.com/blog/what-is-database-schema</li>
<li>[DB기초] 스키마란 무엇인가? - 코딩팩토리 - 티스토리, accessed October 28, 2025, https://coding-factory.tistory.com/216</li>
<li>[DB 데이터베이스] 스키마(Schema)의 개념 및 특징 - iinaglow, accessed October 28, 2025, https://iingang.github.io/posts/DB-schema/</li>
<li>[DB] 3단계 데이터베이스 (외부 스키마, 개념 스키마, 내부 스키마) - 솜은 코튼, accessed October 28, 2025, https://sommda.tistory.com/108</li>
<li>스키마란 무엇인가? - monsangter - 티스토리, accessed October 28, 2025, https://monsangter.tistory.com/95</li>
<li>What is a Database Schema? - AWS, accessed October 28, 2025, https://aws.amazon.com/what-is/database-schema/</li>
<li>[DB] 데이터베이스 스키마(Database Schema) (feat. 데이터베이스 사상(Database Mapping)) - 세상, 나 그리고 개발 - 티스토리, accessed October 28, 2025, https://seahahn.tistory.com/93</li>
<li>[개미의 걸음 SQLD 1과목] 데이터베이스 구조② 3층 스키마(3-Level Schema), accessed October 28, 2025, https://2030bigdata.tistory.com/195</li>
<li>Three schema Architecture | 내부, 개념, 외부 스키마란? - 기록으로 채워가는 개발자 이야기, accessed October 28, 2025, https://gaebalsogi.tistory.com/31</li>
<li>데이터베이스 시스템의 3단계 구조 - yoons2owo.log - 티스토리, accessed October 28, 2025, https://yoons2owo.tistory.com/10</li>
<li>데이터베이스 스키마 다이어그램 이드로우맥스로 5분만에 만들기 - Edraw, accessed October 28, 2025, https://www.edrawsoft.com/kr/diagram-tutorial/learn-about-database-schema.html</li>
<li>3단계 데이터베이스 구조(스키마 schema 란? ) _ 간략히 - hyeley, 기록 블로그, accessed October 28, 2025, https://maedorrrrr.tistory.com/38</li>
<li>[데이터베이스] 3단계 데이터베이스 구조 - 외부/개념/내부 스키마 - 갱 - 티스토리, accessed October 28, 2025, https://rud0503.tistory.com/139</li>
<li>[SQLD] 과목 1 | 제 1장 데이터 모델링의 이해, accessed October 28, 2025, https://snowwhite1106.tistory.com/49</li>
<li>데이터베이스 설계 순서와 방법 (백엔드 개발자를 위한 필수 지식) - 코딩추월차선, accessed October 28, 2025, https://www.developerfastlane.com/blog/database-design-sequence-for-backend-developers</li>
<li>스키마 구성과 DB 설계 단계 - 호반반 개발 블로그, accessed October 28, 2025, https://hoban123.tistory.com/148</li>
<li>Database Design Structure - Schema Tutorial - Lucidchart, accessed October 28, 2025, https://www.lucidchart.com/pages/tutorial/database-design-and-structure</li>
<li>Database design basics - Microsoft Support, accessed October 28, 2025, https://support.microsoft.com/en-us/office/database-design-basics-eb2159cf-1e30-401a-8084-bd4f9c9ca1f5</li>
<li>
<ol start="3">
<li>데이터베이스 구축 - 논리 데이터베이스 설계(데이터베이스 설계 ~ 관계형 데이터 모델), accessed October 28, 2025, https://catisstudying.tistory.com/38</li>
</ol>
</li>
<li>요구 사항 분석 - 무궁화 - 티스토리, accessed October 28, 2025, https://namk0326.tistory.com/31</li>
<li>8장 데이터베이스 설계 - dev. 달팽이 - 티스토리, accessed October 28, 2025, https://hoit1302.tistory.com/148</li>
<li>[DB-11] 물리적 데이터베이스 설계 - DevGang - 티스토리, accessed October 28, 2025, https://kkyu-coder.tistory.com/11</li>
<li>[Database] ER Model | ER 모델 - Archive - 티스토리, accessed October 28, 2025, https://dad-rock.tistory.com/373</li>
<li>[DB 이론] 데이터 베이스 개념적 설계 - ER모델 (Entity-Relationship Model), accessed October 28, 2025, https://nirsa.tistory.com/99</li>
<li>[DB 모델링] 데이터베이스 설계 5단계 - Dev Notes - 티스토리, accessed October 28, 2025, https://achieve-dev.tistory.com/16</li>
<li>데이터베이스 설계 - 웹 개발자의 공부 블로그, accessed October 28, 2025, https://seollica.tistory.com/75</li>
<li>Database Schema Design: Principles Every Developer Must Know - Medium, accessed October 28, 2025, https://medium.com/@artemkhrenov/database-schema-design-principles-every-developer-must-know-fee567414f6d</li>
<li>데이터베이스 스키마 설계에 대한 가이드 - DEVELOP06 - 티스토리, accessed October 28, 2025, https://develop06.tistory.com/207</li>
<li>데이터 무결성이란 무엇인가요? - IBM, accessed October 28, 2025, https://www.ibm.com/kr-ko/think/topics/data-integrity</li>
<li>[관계형 데이터베이스] - 무결성 (Integrity) - untitled blog - 티스토리, accessed October 28, 2025, https://untitledtblog.tistory.com/123</li>
<li>[DataBase] 무결성(Integrity)과 정합성(Consistency) - 데이터 엔지니어를 꿈꾸는 Spidy web블로그 - 티스토리, accessed October 28, 2025, https://spidyweb.tistory.com/164</li>
<li>프로그래밍 일기 — 데이터 무결성(Data Integrity) | by 배우는 자(Learner Of Life), accessed October 28, 2025, <a href="https://conanmoon.medium.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%BC%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AC%B4%EA%B2%B0%EC%84%B1-data-integrity-836b873b818d">https://conanmoon.medium.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%BC%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AC%B4%EA%B2%B0%EC%84%B1-data-integrity-836b873b818d</a></li>
<li>관계(Relationship) 톺아보기 (feat. 데이터 무결성) - 데이터리안, accessed October 28, 2025, https://datarian.io/blog/all-about-relationship</li>
<li>Database Schema Design: A Comprehensive Guide 101 - Hevo Data, accessed October 28, 2025, https://hevodata.com/learn/database-schema-design/</li>
<li>Database normalization description - Microsoft 365 Apps, accessed October 28, 2025, https://learn.microsoft.com/en-us/troubleshoot/microsoft-365-apps/access/database-normalization-description</li>
<li>Database normalization - Wikipedia, accessed October 28, 2025, https://en.wikipedia.org/wiki/Database_normalization</li>
<li>[Database] - 정규화(Normalization) - 짜이한 - 티스토리, accessed October 28, 2025, https://jja2han.tistory.com/236</li>
<li>Normalization in SQL (1NF - 5NF): A Beginner’s Guide - DataCamp, accessed October 28, 2025, https://www.datacamp.com/tutorial/normalization-in-sql</li>
<li>데이터베이스 정규화 단계 (각 정규화 별 예시) - seseJeon, accessed October 28, 2025, https://sese-jeon.tistory.com/6</li>
<li>[데이터베이스] 정규화(Normalization) (1NF - 5NF) - webcodur - 티스토리, accessed October 28, 2025, https://webcodur.tistory.com/67</li>
<li>What Is Database Normalization? - IBM, accessed October 28, 2025, https://www.ibm.com/think/topics/database-normalization</li>
<li>Db2 12 - Introduction - Normalization in database design - IBM, accessed October 28, 2025, https://www.ibm.com/docs/en/db2-for-zos/12.0.0?topic=modeling-normalization-in-database-design</li>
<li>[데이터베이스] 9. 정규형과 정규화예제 - velog, accessed October 28, 2025, <a href="https://velog.io/@rg970604/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-9.-%EC%A0%95%EA%B7%9C%ED%98%95%EA%B3%BC-%EC%A0%95%EA%B7%9C%ED%99%94%EC%98%88%EC%A0%9C">https://velog.io/@rg970604/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-9.-%EC%A0%95%EA%B7%9C%ED%98%95%EA%B3%BC-%EC%A0%95%EA%B7%9C%ED%99%94%EC%98%88%EC%A0%9C</a></li>
<li>Database Performance Tuning Techniques - Releem, accessed October 28, 2025, https://releem.com/blog/database-performance-tuning-techniques</li>
<li>데이터베이스 최적화하는 방법 11가지 - Devlog, accessed October 28, 2025, <a href="https://mactto.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-11%EA%B0%80%EC%A7%80-%EA%B8%B0%EC%88%A0">https://mactto.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-11%EA%B0%80%EC%A7%80-%EA%B8%B0%EC%88%A0</a></li>
<li>Architecture strategies for optimizing data performance - Microsoft Azure Well-Architected Framework, accessed October 28, 2025, https://learn.microsoft.com/en-us/azure/well-architected/performance-efficiency/optimize-data-performance</li>
<li>How to Optimize Database Schema to Improve Query Performance for a High-Traffic REST API - Zigpoll, accessed October 28, 2025, https://www.zigpoll.com/content/how-can-i-optimize-the-database-schema-to-improve-query-performance-for-a-hightraffic-rest-api</li>
<li>12 SQL Query Optimization Techniques to Follow - ThoughtSpot, accessed October 28, 2025, https://www.thoughtspot.com/data-trends/data-modeling/optimizing-sql-queries</li>
<li>데이터 성능을 최적화하기 위한 아키텍처 전략 - Microsoft Azure Well-Architected Framework, accessed October 28, 2025, https://learn.microsoft.com/ko-kr/azure/well-architected/performance-efficiency/optimize-data-performance</li>
<li>Strategies for Schema design in DBMS - GeeksforGeeks, accessed October 28, 2025, https://www.geeksforgeeks.org/dbms/strategies-for-schema-design-in-dbms/</li>
<li>스키마 최적화 모범 사례 - Azure Data Explorer - Microsoft Learn, accessed October 28, 2025, https://learn.microsoft.com/ko-kr/azure/data-explorer/schema-best-practice</li>
<li>[SQL] SQL과 NoSQL의 차이 (관계형 데이터베이스 vs 비관계형 데이터베이스) - IT is True, accessed October 28, 2025, https://ittrue.tistory.com/195</li>
<li>SQL vs. NoSQL Databases: What’s the Difference? - IBM, accessed October 28, 2025, https://www.ibm.com/think/topics/sql-vs-nosql</li>
<li>SQL vs NoSQL: Understanding the difference - Multiverse, accessed October 28, 2025, https://www.multiverse.io/en-GB/blog/sql-vs-nosql</li>
<li>SQL vs. NoSQL: The Differences Explained + When to Use Each - Coursera, accessed October 28, 2025, https://www.coursera.org/articles/nosql-vs-sql</li>
<li>Understanding SQL vs NoSQL Databases - MongoDB, accessed October 28, 2025, https://www.mongodb.com/resources/basics/databases/nosql-explained/nosql-vs-sql</li>
<li>SQL, NoSQL 비교(특징, 스키마, 속도, 확장) - Eddy - 티스토리, accessed October 28, 2025, https://node-js.tistory.com/23</li>
<li>Understanding The Different Types Of Databases &amp; When To Use Them - Rivery, accessed October 28, 2025, https://rivery.io/data-learning-center/database-types-guide/</li>
<li>Strict Schema Enforcement vs. Schemaless vs. Dynamic Schema - HarperDB, accessed October 28, 2025, https://www.harper.fast/resources/strict-schema-enforcement-vs-schemaless-vs-dynamic-schema</li>
<li>ELI5: Schema-on-Read vs Schema-on-Write : r/explainlikeimfive - Reddit, accessed October 28, 2025, https://www.reddit.com/r/explainlikeimfive/comments/nz7tjy/eli5_schemaonread_vs_schemaonwrite/</li>
<li>Schema-on-Read vs Schema-on-Write | Dremio, accessed October 28, 2025, https://www.dremio.com/wiki/schema-on-read-vs-schema-on-write/</li>
<li>Big Data SQL Quick Start. Schema on Read and Schema on Write - Part11. - Oracle Blogs, accessed October 28, 2025, https://blogs.oracle.com/datawarehousing/post/big-data-sql-quick-start-schema-on-read-and-schema-on-write-part11</li>
<li>What is Schema On Read and Schema On Write in Hadoop? - GeeksforGeeks, accessed October 28, 2025, https://www.geeksforgeeks.org/sql/what-is-schema-on-read-and-schema-on-write-in-hadoop/</li>
<li>What is a database schema? Types and uses in data integration - Fivetran, accessed October 28, 2025, https://www.fivetran.com/learn/what-is-a-database-schema</li>
<li>6 Database Schema Examples and How to Use Them | Integrate.io, accessed October 28, 2025, https://www.integrate.io/blog/database-schema-examples/</li>
<li>Schema migration - Wikipedia, accessed October 28, 2025, https://en.wikipedia.org/wiki/Schema_migration</li>
<li>Schema Evolution - CelerData, accessed October 28, 2025, https://celerdata.com/glossary/schema-evolution</li>
<li>Database Migrations and Schema Evolution - Code Frosting, accessed October 28, 2025, https://www.codefro.com/2023/10/03/database-migrations-and-schema-evolution/</li>
<li>Database migration vs Schema Evolution · Issue #3742 - GitHub, accessed October 28, 2025, https://github.com/flyway/flyway/issues/3742</li>
<li>Zero Downtime Database Migration: Easy &amp; Effective Guide - Data-Sleek, accessed October 28, 2025, https://data-sleek.com/blog/how-to-accomplish-zero-downtime-database-migration-easily-and-effectively/</li>
<li>3 strategies for zero downtime database migration | New Relic, accessed October 28, 2025, https://newrelic.com/blog/best-practices/migrating-data-to-cloud-avoid-downtime-strategies</li>
<li>무중단 데이터 마이그레이션을 위한 필수 솔루션, CDC(Capture Data Change) | 인사이트리포트 | 삼성SDS, accessed October 28, 2025, https://www.samsungsds.com/kr/insights/migration_cdc.html</li>
<li>How we make database schema migrations safe and robust at Defacto, accessed October 28, 2025, https://www.getdefacto.com/article/database-schema-migrations</li>
<li>Best practices for managing schema updates during deployments (both rollout and rollback) : r/devops - Reddit, accessed October 28, 2025, https://www.reddit.com/r/devops/comments/1iwy2su/best_practices_for_managing_schema_updates_during/</li>
<li>데이터베이스 스키마 진화를 우아하게 관리하기 - Leapcell, accessed October 28, 2025, https://leapcell.io/blog/ko/deiteo-beiseu-seukim-a-jin-hwa-reul-u-a-hage-gwanri-hagi</li>
<li>[Briefing] Flyway로 DB 스키마 형상 관리하기 - 1, accessed October 28, 2025, <a href="https://suddiyo.tistory.com/entry/Briefing-Flyway%EB%A1%9C-DB-%EC%8A%A4%ED%82%A4%EB%A7%88-%ED%98%95%EC%83%81-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-1">https://suddiyo.tistory.com/entry/Briefing-Flyway%EB%A1%9C-DB-%EC%8A%A4%ED%82%A4%EB%A7%88-%ED%98%95%EC%83%81-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-1</a></li>
<li>실제 서비스 운영 중 DB 스키마가 변경되면 어떡하지? - 애송이 개발 블로그, accessed October 28, 2025, https://parkmuhyeun.github.io/woowacourse/2023-08-06-flyway/</li>
<li>Liquibase vs. Flyway (Redgate), accessed October 28, 2025, https://www.liquibase.com/liquibase-vs-flyway</li>
<li>Liquibase vs Flyway | Baeldung, accessed October 28, 2025, https://www.baeldung.com/liquibase-vs-flyway</li>
<li>Schema Migration by Liquibase - Petefolio, accessed October 28, 2025, https://petefolio.dev/articles/schema-migration-by-liquibase</li>
<li>Strategies for Reliable Schema Migrations - Atlas, accessed October 28, 2025, https://atlasgo.io/blog/2024/10/09/strategies-for-reliable-migrations</li>
<li>Database Schema Migration: Understand, Optimize, Automate - Liquibase, accessed October 28, 2025, https://www.liquibase.com/resources/guides/database-schema-migration</li>
<li>Designing a Blog Database Schema (Ultimate Guide) - Dragonfly, accessed October 28, 2025, https://www.dragonflydb.io/databases/schema/blog</li>
<li>How to Design Database for a Blog Website - GeeksforGeeks, accessed October 28, 2025, https://www.geeksforgeeks.org/dbms/how-to-design-database-for-a-blog-website/</li>
<li>Entity Relationship Diagrams | Adobe Commerce - Experience League, accessed October 28, 2025, https://experienceleague.adobe.com/en/docs/commerce-business-intelligence/mbi/analyze/warehouse-manager/entity-rel-diag</li>
<li>Ecommerce Database Design: ER Diagram for Online Shopping - Redgate Software, accessed October 28, 2025, https://www.red-gate.com/blog/er-diagram-for-online-shop</li>
<li>[쇼핑몰 만들기] 쇼핑몰 ERD 설계 - velog, accessed October 28, 2025, <a href="https://velog.io/@1afterwon/%EC%87%BC%ED%95%91%EB%AA%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%87%BC%ED%95%91%EB%AA%B0-ERD-%EC%84%A4%EA%B3%84">https://velog.io/@1afterwon/%EC%87%BC%ED%95%91%EB%AA%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%87%BC%ED%95%91%EB%AA%B0-ERD-%EC%84%A4%EA%B3%84</a></li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>