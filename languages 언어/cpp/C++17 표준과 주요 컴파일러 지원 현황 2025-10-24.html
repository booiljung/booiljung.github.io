<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:C++17 표준과 주요 컴파일러 지원 현황</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>C++17 표준과 주요 컴파일러 지원 현황</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">언어 (Languages)</a> / <a href="index.html">C++ 프로그래밍</a> / <span>C++17 표준과 주요 컴파일러 지원 현황</span></nav>
                </div>
            </header>
            <article>
                <h1>C++17 표준과 주요 컴파일러 지원 현황</h1>
<p>2025-10-24, G25DR</p>
<h2>1.  C++17 표준의 의의와 발전 방향</h2>
<h3>1.1  C++17(ISO/IEC 14882:2017)의 탄생과 철학</h3>
<p>C++17 표준은 2017년 3월 ISO C++ 표준 위원회의 기술적 최종 승인을 거쳐 2017년 12월에 공식적으로 발표되었다.1 이 표준은 C++11과 C++14를 계승하는 중요한 이정표로서, 모던 C++ 패러다임의 확립과 발전에 기여하였다. C++17의 핵심 철학은 새로운 패러다임을 급진적으로 도입하기보다는, C++11과 C++14를 통해 도입된 개념들을 더욱 가다듬고 안정화하는 데 있었다. 주요 목표는 개발자의 생산성을 향상하고, 코드를 더 간결하며 안전하게 작성할 수 있도록 지원하는 것이었다. 이러한 이유로 C++17은 종종 ‘품질 향상(Quality of Life)’ 릴리스로 평가된다.</p>
<p>C++17의 개선 방향은 크게 세 가지 범주로 분류할 수 있다. 첫째, 문법 간소화 및 편의성 증대(Simplification)이다. 구조적 바인딩, <code>if</code> 및 <code>switch</code> 초기화 구문, 중첩 네임스페이스 정의 간소화 등이 여기에 해당한다. 둘째, 언어 명확성 및 안정성 강화(Clarification)이다. 표현식 평가 순서 규칙 강화, 예외 명세의 타입 시스템 편입, 보장된 복사 생략 등이 포함된다. 셋째, 강력한 표준 라이브러리 확장(Library changes)이다. 파일시스템 라이브러리, 병렬 알고리즘, <code>std::optional</code>, <code>std::variant</code>, <code>std::any</code>, <code>std::string_view</code> 등 강력하고 실용적인 도구들이 대거 추가되었다.2</p>
<h3>1.2  C++11/14로부터의 진화</h3>
<p>C++11 표준은 람다 표현식, rvalue 참조 및 이동 의미론, 가변 인자 템플릿 등 언어의 근간을 바꾸는 혁신적인 기능들을 대거 도입한 ’빅뱅’에 가까운 변화였다. 이후 발표된 C++14는 이러한 C++11의 기능들을 안정화하고 일부 편의 기능을 추가하는 마이너 업데이트의 성격이 강했다.</p>
<p>C++17은 이러한 안정화된 기반 위에서 개발자들이 실제 코드를 작성하며 일상적으로 겪는 불편함을 해소하는 데 집중하였다. 예를 들어, 과거에는 템플릿 메타프로그래밍에서 타입의 특성에 따라 다른 코드를 구현하기 위해 SFINAE(Substitution Failure Is Not An Error)나 태그 디스패치(tag dispatching)와 같은 복잡하고 난해한 기법을 사용해야 했다. C++17은 <code>if constexpr</code>라는 직관적인 문법을 도입하여 이러한 패턴을 간결하게 대체할 수 있도록 하였다.2 또한, C++ Core Guidelines에서 지적하는 C++의 고질적인 문제 영역, 가령 타입 안전성이 보장되지 않는 <code>union</code>이나 범위 오류의 위험이 있는 C-스타일 배열 등을 해결하기 위한 노력도 이루어졌다. <code>std::variant</code>나 <code>std::optional</code>과 같은 새로운 라이브러리 유틸리티는 이러한 문제들을 타입 시스템 내에서 안전하게 다룰 수 있는 현대적인 해법을 제시한다.3</p>
<p>이러한 변화의 기저에는 C++17의 전략적 위치가 자리 잡고 있다. C++20에서 도입된 Concepts, Coroutines, Modules와 같은 거대하고 새로운 패러다임 변화와는 달리, C++17의 기능들은 대부분 기존 프로그래밍 방식의 불편함을 직접적으로 해결하는 데 초점을 맞춘다. 구조적 바인딩은 <code>std::tie</code>와 <code>std::get</code>의 번거로움을, <code>std::filesystem</code>은 플랫폼 종속적인 파일 I/O API 사용의 어려움을 해소한다.1 이는 C++11이 열어젖힌 모던 C++의 시대를 ’혁신’하는 것이 아니라 ’완성’하고 다듬으려는 표준 위원회의 의도를 보여준다. 결과적으로 C++17은 개발자 경험(Developer Experience)을 최우선으로 고려한 실용주의적 표준으로 자리매김하였으며, 이는 C++가 복잡하고 어렵다는 인식을 개선하고 더 넓은 개발자층을 포용하려는 전략적 의도로 해석될 수 있다.</p>
<h2>2.  C++17 핵심 언어 기능 심층 분석</h2>
<h3>2.1  구조적 바인딩 (Structured Bindings)</h3>
<p>구조적 바인딩은 <code>std::tuple</code>, <code>std::pair</code>, C-스타일 배열, 그리고 모든 멤버 변수가 <code>public</code>인 집합체(aggregate)의 원소들을 개별 변수로 분해하여 선언하고 초기화하는 기능이다.1 이 기능은 제안 문서 P0217R3을 통해 표준화되었으며, 기존에 <code>std::tie</code>와 <code>std::get</code>을 조합하여 사용하던 번거로운 코드를 효과적으로 대체한다.6</p>
<p>기본 문법은 <code>auto [a, b, c] = get_values();</code>와 같은 형태를 띤다. 여기서 <code>get_values()</code>는 3개의 원소를 가진 튜플이나 구조체를 반환한다. 이 기능의 가장 대표적인 활용 사례는 <code>std::map</code>과 같은 연관 컨테이너를 순회하는 경우이다.</p>
<pre><code class="language-C++">std::map&lt;std::string, int&gt; my_map;
// C++17 이전
for (const auto&amp; pair : my_map) {
    const std::string&amp; key = pair.first;
    int value = pair.second;
    //...
}

// C++17 이후
for (const auto&amp; [key, value] : my_map) {
    //...
}
</code></pre>
<p>위 예시에서 볼 수 있듯, 구조적 바인딩을 사용하면 코드가 훨씬 간결해지고 가독성이 비약적으로 향상된다. <code>auto</code> 키워드와 함께 <code>&amp;</code>, <code>const&amp;</code>, <code>&amp;&amp;</code> 등 다양한 한정사를 사용하여 참조나 상수 참조로 바인딩하는 것도 가능하다.5</p>
<p>구조적 바인딩의 작동 원리는 단순한 문법적 설탕(syntactic sugar)을 넘어선다. 컴파일러는 내부적으로 익명의 변수를 생성하여 초기화 표현식의 결과를 저장한다. 그 후, 선언된 각 식별자(<code>key</code>, <code>value</code> 등)는 이 익명 변수의 멤버에 대한 참조처럼 동작한다. 대상이 튜플 계열이면 <code>std::get</code>을 통해, 구조체면 멤버 변수에 직접 접근하는 방식으로 구현된다. 따라서 구조적 바인딩으로 선언된 식별자들은 실제 변수가 아니라, 내부적으로 생성된 객체의 특정 부분을 가리키는 이름에 가깝다.</p>
<h3>2.2  컴파일 타임 분기문 <code>if constexpr</code></h3>
<p><code>if constexpr</code>는 템플릿 프로그래밍의 패러다임을 바꾼 혁신적인 기능이다. 이는 템플릿 내에서 사용되는 <code>if</code> 문으로, 조건식이 컴파일 타임에 평가될 수 있어야 한다. 만약 조건이 <code>true</code>로 평가되면 <code>if</code> 블록 내부의 코드만 인스턴스화되고, <code>false</code>로 평가되면 <code>else</code> 블록(존재할 경우)의 코드만 인스턴스화된다. 조건이 <code>false</code>인 브랜치는 파싱은 되지만 인스턴스화되지 않으므로, 해당 브랜치 내에 문법적으로 유효하지 않은 코드가 있더라도 컴파일 오류가 발생하지 않는다.1</p>
<p>이 기능은 제안 문서 P0292R2를 통해 도입되었으며, 복잡한 SFINAE 기법이나 태그 디스패치를 대체하여 템플릿 메타프로그래밍을 훨씬 직관적으로 만들어준다.7</p>
<pre><code class="language-C++">// C++17 이전 (SFINAE 사용)
template &lt;typename T, std::enable_if_t&lt;std::is_pointer_v&lt;T&gt;, int&gt; = 0&gt;
void process(T value) {
    // 포인터에 대한 처리
}

template &lt;typename T, std::enable_if_t&lt;!std::is_pointer_v&lt;T&gt;, int&gt; = 0&gt;
void process(T value) {
    // 포인터가 아닌 타입에 대한 처리
}

// C++17 이후 (if constexpr 사용)
template &lt;typename T&gt;
void process(T value) {
    if constexpr (std::is_pointer_v&lt;T&gt;) {
        // 이 코드는 T가 포인터일 때만 인스턴스화된다.
    } else {
        // 이 코드는 T가 포인터가 아닐 때만 인스턴스화된다.
    }
}
</code></pre>
<p>두 번째 예시에서 <code>if constexpr</code>를 사용한 코드는 하나의 함수 템플릿으로 모든 경우를 처리하며, 코드의 의도가 명확하게 드러나 가독성과 유지보수성이 크게 향상된다.</p>
<h3>2.3  인라인 변수 (Inline Variables)</h3>
<p><code>inline</code> 키워드는 본래 함수에 사용되어 여러 번역 단위(translation unit)에서 동일한 함수 정의가 중복으로 존재할 수 있도록 허용하는 역할을 했다. C++17에서는 이 개념이 변수로 확장되어 <code>inline</code> 변수가 도입되었다.1</p>
<p>헤더 파일에 일반적인 전역 변수나 정적 멤버 변수를 정의하면, 해당 헤더를 포함하는 모든 소스 파일에서 변수가 중복으로 정의되어 링킹 시점에 단일 정의 규칙(One Definition Rule, ODR) 위반 오류가 발생한다. <code>inline</code> 변수는 이러한 문제를 해결한다. 헤더 파일에 변수를 <code>inline</code>으로 선언하면, 링커는 여러 번역 단위에 존재하는 동일한 <code>inline</code> 변수 정의들을 하나의 유일한 인스턴스로 병합한다. 이는 제안 문서 P0386R2를 통해 표준화되었다.7</p>
<pre><code class="language-C++">// my_header.h
#pragma once

struct MyConfig {
    inline static bool logging_enabled = true; // C++17 인라인 변수
};
</code></pre>
<p>특히 주목할 점은 <code>static constexpr</code> 데이터 멤버와의 관계이다. C++17부터 클래스 내에 선언된 <code>static constexpr</code> 데이터 멤버는 암묵적으로 <code>inline</code>으로 간주된다. 따라서 C++14까지 필요했던 클래스 외부의 별도 정의문이 더 이상 필요하지 않게 되어 코드가 간결해졌다.5</p>
<h3>2.4  폴드 표현식 (Fold Expressions)</h3>
<p>폴드 표현식은 가변 인자 템플릿(variadic templates)의 파라미터 팩(parameter pack)에 대해 이항 연산자를 반복적으로 적용하는 매우 간결한 문법이다.1 C++11/14에서는 파라미터 팩의 모든 원소에 대해 합산이나 논리 연산 등을 수행하려면 재귀 템플릿 함수나 초기화 리스트 트릭과 같은 복잡한 기법이 필요했다. 폴드 표현식은 이러한 작업을 한 줄로 명료하게 표현할 수 있게 해준다 (N4295).7</p>
<p>폴드 표현식은 연산자와 파라미터 팩의 위치에 따라 네 가지 형태로 나뉜다.</p>
<ul>
<li>
<p>단항 우측 폴드: <code>(pack op...)</code> -&gt; <code>(p1 op (p2 op (p3 op...)))</code></p>
</li>
<li>
<p>단항 좌측 폴드: <code>(... op pack)</code> -&gt; <code>(((... op p3) op p2) op p1)</code></p>
</li>
<li>
<p>이항 우측 폴드: <code>(pack op... op init)</code></p>
</li>
<li>
<p>이항 좌측 폴드: <code>(init op... op pack)</code></p>
</li>
</ul>
<p>예를 들어, 모든 인자를 합산하는 함수는 다음과 같이 작성할 수 있다.</p>
<pre><code class="language-C++">template&lt;typename... Args&gt;
auto sum(Args... args) {
    return (args +...); // 단항 좌측 폴드
}

int total = sum(1, 2, 3, 4, 5); // 결과: 15
</code></pre>
<p>또한, 빈 파라미터 팩이 전달될 경우를 대비해 일부 연산자에 대한 기본값이 정의되어 있다. <code>&amp;&amp;</code>는 <code>true</code>, <code>||</code>는 <code>false</code>, 쉼표 연산자(<code>,</code>)는 <code>void()</code>가 기본값이다.2</p>
<h3>2.5  클래스 템플릿 인자 추론 (Class Template Argument Deduction, CTAD)</h3>
<p>클래스 템플릿 인자 추론, 즉 CTAD는 함수 템플릿처럼 클래스 템플릿의 생성자에 전달된 인자의 타입을 기반으로 컴파일러가 템플릿 인자를 자동으로 추론하는 기능이다.1 이 기능이 도입되기 전에는 클래스 템플릿의 객체를 생성할 때 템플릿 인자를 명시적으로 지정해야 했다.</p>
<pre><code class="language-C++">// C++17 이전
std::pair&lt;int, double&gt; p1(1, 2.0);
std::vector&lt;int&gt; v1 = {1, 2, 3};

// C++17 이후 (CTAD)
std::pair p2(1, 2.0); // pair&lt;int, double&gt;로 추론
std::vector v2 = {1, 2, 3}; // vector&lt;int&gt;로 추론
</code></pre>
<p>CTAD 덕분에 <code>std::make_pair</code>나 <code>std::make_tuple</code>과 같은 헬퍼 함수의 필요성이 크게 줄어들었다. 코드가 간결해지고 가독성이 높아지는 효과가 있다 (P0091R3).6</p>
<p>만약 컴파일러의 기본 추론 규칙이 개발자의 의도와 다르거나, 특정 생성자에 대해 추론이 불가능한 경우, 개발자는 ’사용자 정의 추론 가이드(user-defined deduction guides)’를 제공하여 추론 방식을 직접 명시할 수 있다. 이는 CTAD를 더욱 유연하고 강력하게 만들어주는 보조 기능이다.</p>
<h3>2.6  기타 주요 언어 기능</h3>
<ul>
<li>
<p><strong><code>if</code>, <code>switch</code> 초기화 구문:</strong> <code>if</code>나 <code>switch</code> 문의 조건식 부분에 초기화 구문을 추가할 수 있게 되었다. 이 구문에서 선언된 변수는 <code>if-else</code> 또는 <code>switch</code> 블록 내에서만 유효한 스코프를 가지므로, 변수의 생명주기를 최소화하여 코드의 안정성을 높인다.2</p>
<pre><code class="language-C++">if (auto it = my_map.find(key); it!= my_map.end()) {
    // it은 이 블록 안에서만 유효하다.
}
</code></pre>
</li>
</ul>
<pre><code>
- **보장된 복사 생략 (Guaranteed Copy Elision):** 특정 문맥에서 임시 객체를 생성하여 반환하거나 초기화할 때, 복사 또는 이동 생성자 호출이 일어나지 않음을 언어 차원에서 보장한다. 이전에는 컴파일러의 최적화(RVO/NRVO)에 의존했지만, C++17부터는 prvalue로부터 객체를 초기화하는 경우 복사/이동이 아예 없는 것으로 정의된다.1

- **새로운 속성(Attributes):** 코드의 의도를 명확히 하고 컴파일러 경고를 제어하는 세 가지 표준 속성이 추가되었다.1

- `[[nodiscard]]`: 함수나 타입에 붙여, 해당 함수의 반환 값을 사용하지 않으면 컴파일러가 경고를 생성하도록 한다.

- `[[maybe_unused]]`: 변수, 파라미터, 타입 등에 붙여, 해당 요소가 사용되지 않더라도 컴파일러 경고를 억제한다.

- `[[fallthrough]]`: `switch` 문에서 `case` 라벨 사이에 의도적으로 `break`를 생략했음을 명시하여 관련 경고를 억제한다.

- **람다 개선:** 두 가지 중요한 개선이 이루어졌다. 첫째, `*this`를 값으로 캡처(`[*this]`)할 수 있게 되었다. 이는 비동기 작업에서 람다가 호출될 시점에 원본 객체가 소멸되었을 수 있는 문제를 해결하는 데 유용하다. 둘째, 람다 표현식이 `constexpr` 문맥에서 사용될 수 있도록 허용되어, 컴파일 타임 프로그래밍의 표현력이 크게 향상되었다.2

- **폐지 및 제거된 기능:** 언어를 현대화하고 불필요한 복잡성을 줄이기 위해 일부 오래된 기능들이 제거되었다. 대표적으로 C와의 하위 호환성을 위해 존재했던 삼중자(Trigraphs), 현대 컴파일러에서는 최적화에 거의 영향을 주지 못하는 `register` 키워드, 그리고 `bool` 타입에 대한 증감 연산자(`operator++(bool)`)가 공식적으로 제거되었다.1

## 3.  C++17 표준 라이브러리 확장 분석


C++17은 언어 기능뿐만 아니라 표준 라이브러리에서도 대규모 확장을 이루었다. 특히 이 확장 기능의 상당수가 표준화 이전에 기술 명세(Technical Specification, TS)라는 형태로 먼저 제안되고 구현되었다는 점이 특징이다. 파일시스템 라이브러리(File System TS), 병렬 알고리즘(Parallelism TS), 그리고 `std::optional`, `std::any`, `std::string_view` 등을 포함하는 Library Fundamentals TS가 대표적인 예이다.2 이러한 TS 기반의 점진적 표준화 프로세스는 기능의 완성도를 높이고, 표준 발표와 실제 컴파일러 구현 사이의 간극을 줄이는 성공적인 전략임이 입증되었다. 이는 개발자들이 TS를 통해 미래 표준 기능을 미리 경험하고 대비할 수 있게 하는 긍정적인 효과를 낳았다.

### 3.1  값 관리를 위한 유틸리티 삼총사: `std::optional`, `std::variant`, `std::any`


C++17은 값의 상태를 더 안전하고 명확하게 관리하기 위한 세 가지 핵심 유틸리티 클래스를 도입했다. 이들은 모두 Library Fundamentals TS v1에서 편입되었다.4

- **`std::optional`:** 값을 가지거나 가지지 않을 수 있는 상태, 즉 '유효한 값이 있을 수도 있고 없을 수도 있음'을 표현하는 래퍼 클래스이다. 과거에는 이러한 상태를 표현하기 위해 널 포인터(`nullptr`)나 특정 매직 넘버(예: -1)를 반환 값으로 사용하곤 했다. `std::optional`은 이러한 관행을 타입 안전한 방식으로 대체한다. 값이 없는 상태를 명시적으로 표현함으로써, 함수 사용자는 반환 값이 유효한지 여부를 반드시 확인하도록 유도할 수 있다.1

- **`std::variant`:** 타입 안전 공용체(type-safe union)이다. C-스타일 `union`은 메모리를 절약할 수 있지만, 현재 저장된 타입이 무엇인지 추적할 방법이 없어 타입 시스템의 안전성을 해치는 주범이었다. `std::variant`는 미리 정의된 타입 목록 중 하나의 값만 저장할 수 있으며, `std::get`이나 `std::visit`를 통해 안전하게 값에 접근할 수 있다. 만약 저장되지 않은 타입으로 접근을 시도하면 `std::bad_variant_access` 예외가 발생하여 런타임 오류를 방지한다.1

- **`std::any`:** 임의의 단일 값을 타입 소거(type erasure) 기법을 통해 저장하는 클래스이다. `std::variant`가 정해진 타입 목록 내에서만 값을 저장하는 것과 달리, `std::any`는 복사 생성 가능한 모든 타입의 값을 저장할 수 있다. 이는 동적 타입 언어와 유사한 유연성을 제공하지만, 저장된 값을 사용하기 위해서는 `std::any_cast`를 통해 원래 타입을 정확히 명시해야 한다. 잘못된 타입으로 캐스팅을 시도하면 `std::bad_any_cast` 예외가 발생한다.1

### 3.2  효율적인 문자열 참조: `std::string_view`


`std::string_view`는 문자열 데이터의 소유권을 갖지 않고, 해당 데이터에 대한 읽기 전용 뷰(view)만을 제공하는 매우 효율적인 클래스이다.1 이는 포인터와 길이(length) 쌍으로 구현되며, 원본 문자열 데이터를 복사하지 않고 참조만 한다. 따라서 문자열 리터럴이나 `std::string` 객체의 일부를 함수에 전달할 때 발생하는 불필요한 메모리 할당 및 복사 오버헤드를 제거할 수 있다.4

과거에는 문자열을 받는 함수를 `void func(const std::string&amp; s)`와 같이 설계하는 것이 일반적이었다. 하지만 이 함수에 C-스타일 문자열 리터럴("hello")을 전달하면, 함수 호출 시점에 임시 `std::string` 객체가 생성되어 동적 메모리 할당이 발생한다. 반면, `void func(std::string_view sv)`로 설계하면 문자열 리터럴을 전달해도 아무런 오버헤드가 발생하지 않는다.

다만 `std::string_view` 사용 시에는 치명적인 위험성이 존재한다. `std::string_view`는 원본 데이터의 생명주기를 관리하지 않으므로, 원본 문자열이 소멸된 후에 해당 `string_view`에 접근하면 댕글링(dangling) 참조 문제가 발생하여 미정의 동작(undefined behavior)을 유발할 수 있다. 따라서 `std::string_view`를 클래스의 멤버 변수로 사용하거나 함수에서 반환할 때는 각별한 주의가 필요하다.

### 3.3  플랫폼 독립적 파일 처리: 파일시스템 라이브러리 (`&lt;filesystem&gt;`)


오랫동안 C++ 표준 라이브러리에는 파일시스템을 다루는 표준화된 방법이 부재했다. 이로 인해 개발자들은 운영체제별로 다른 API(POSIX API, Windows API 등)를 사용하거나, Boost.Filesystem과 같은 서드파티 라이브러리에 의존해야 했다. C++17은 Boost.Filesystem 라이브러리를 기반으로 한 파일시스템 라이브러리를 표준에 포함시켜 이러한 문제를 해결했다.1

`&lt;filesystem&gt;` 헤더를 통해 제공되는 이 라이브러리는 플랫폼에 독립적인 방식으로 파일과 디렉터리를 조작하는 강력하고 일관된 인터페이스를 제공한다.

- **`std::filesystem::path`:** 파일 경로를 표현하고 조작하는 핵심 클래스이다. 경로 결합, 분해, 확장자 변경 등 다양한 연산을 지원하며, 운영체제에 맞는 경로 구분자(Windows의 `\`, Linux의 `/`)를 자동으로 처리해준다.

- **디렉터리 및 파일 작업:** `std::filesystem::create_directory`, `std::filesystem::copy`, `std::filesystem::remove` 등의 함수를 통해 파일과 디렉터리를 생성, 복사, 삭제할 수 있다.

- **상태 조회 및 순회:** `std::filesystem::exists`, `std::filesystem::is_directory`, `std::filesystem::file_size` 등으로 파일의 상태를 확인할 수 있다. `std::filesystem::directory_iterator`와 `std::filesystem::recursive_directory_iterator`를 사용하면 디렉터리의 내용을 효율적으로 순회할 수 있다.

### 3.4  병렬 처리의 표준화: 병렬 알고리즘 (Parallel STL)


멀티코어 프로세서가 보편화됨에 따라 병렬 프로그래밍의 중요성은 날로 커지고 있다. C++17은 기존 STL 알고리즘의 상당수에 병렬 실행을 지원하는 오버로드 버전을 추가하여, 개발자가 더 쉽게 병렬 처리를 활용할 수 있도록 하였다. 이 기능은 Parallelism TS v1에서 편입되었다.2

병렬 알고리즘은 첫 번째 인자로 '실행 정책(Execution Policy)'을 받는다. 실행 정책은 알고리즘이 어떻게 실행되어야 하는지를 컴파일러와 라이브러리에 알리는 역할을 한다.

- `std::execution::sequenced_policy` (`seq`): 순차적으로 실행된다. 기존 알고리즘과 동일하다.

- `std::execution::parallel_policy` (`par`): 여러 스레드를 사용하여 병렬로 실행될 수 있다.

- `std::execution::parallel_unsequenced_policy` (`par_unseq`): 여러 스레드에서 병렬로 실행될 수 있으며, 각 스레드 내에서는 벡터화(SIMD) 명령어를 사용하여 인터리빙될 수 있다.

```C++
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;execution&gt;

std::vector&lt;int&gt; v = { /*... */ };

// v의 모든 원소를 병렬로 정렬한다.
std::sort(std::execution::par, v.begin(), v.end());
</code></pre>
<p>병렬 알고리즘을 사용할 때의 핵심적인 책임은 개발자에게 있다. 알고리즘에 전달되는 연산(예: 람다 함수)은 데이터 경쟁(data race)이나 교착 상태(deadlock)를 유발하지 않도록 신중하게 작성되어야 한다. 표준 라이브러리는 병렬 실행 환경을 제공할 뿐, 동기화 문제를 자동으로 해결해주지는 않는다.</p>
<h2>4.  주요 컴파일러별 C++17 지원 현황</h2>
<h3>4.1  C++17 표준 활성화 방법</h3>
<p>주요 컴파일러에서 C++17 표준 기능을 사용하려면 특정 컴파일러 옵션을 설정해야 한다.</p>
<ul>
<li>
<p><strong>GCC / Clang:</strong> 명령줄에서 <code>-std=c++17</code> 옵션을 사용한다. GNU 확장 기능을 포함하려면 <code>-std=gnu++17</code>을 사용한다.8 GCC는 버전 11.1부터 <code>-std=gnu++17</code>을 기본값으로 채택했으며 10, Clang은 버전 16.0.0부터 <code>-std=gnu++17</code>을 기본값으로 사용한다.11</p>
</li>
<li>
<p><strong>MSVC (Microsoft Visual C++):</strong> 명령줄에서 <code>/std:c++17</code> 옵션을 사용한다. 이 옵션은 Visual Studio 2017 버전 15.3부터 지원된다.12 Visual Studio IDE 환경에서는 프로젝트 속성 창의 <code>Configuration Properties</code> -&gt; <code>C/C++</code> -&gt; <code>Language</code> -&gt; <code>C++ Language Standard</code> 항목에서 ’ISO C++17 Standard (/std:c++17)’를 선택하여 설정할 수 있다.13 한 가지 유의할 점은, <code>__cplusplus</code> 매크로가 표준에 맞는 값(<code>201703L</code>)으로 올바르게 정의되게 하려면 <code>/Zc:__cplusplus</code> 옵션을 함께 사용해야 한다는 것이다.1</p>
</li>
</ul>
<h3>4.2  핵심 기능 지원 버전 비교표</h3>
<p>C++17의 주요 기능들이 각 컴파일러에서 언제부터 지원되었는지를 파악하는 것은 프로젝트의 기술 스택과 빌드 환경을 결정하는 데 매우 중요하다. 아래 표는 핵심 언어 및 라이브러리 기능에 대한 최소 지원 버전을 종합한 것이다.</p>
<table><thead><tr><th><strong>기능 (Feature)</strong></th><th><strong>제안 문서 (Paper)</strong></th><th><strong>GCC</strong></th><th><strong>Clang</strong></th><th><strong>MSVC (Visual Studio 버전)</strong></th></tr></thead><tbody>
<tr><td><strong>언어 기능 (Core Language)</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td>구조적 바인딩</td><td>P0217R3</td><td>7</td><td>4.0</td><td>19.11 (VS 2017 15.3)</td></tr>
<tr><td><code>if constexpr</code></td><td>P0292R2</td><td>7</td><td>3.9</td><td>19.11 (VS 2017 15.3)</td></tr>
<tr><td>인라인 변수</td><td>P0386R2</td><td>7</td><td>3.9</td><td>19.14 (VS 2017 15.7)</td></tr>
<tr><td>폴드 표현식</td><td>N4295</td><td>6</td><td>3.6</td><td>19.12 (VS 2017 15.5)</td></tr>
<tr><td>클래스 템플릿 인자 추론 (CTAD)</td><td>P0091R3</td><td>7</td><td>5.0</td><td>19.14 (VS 2017 15.7)</td></tr>
<tr><td>보장된 복사 생략</td><td>P0135R1</td><td>7</td><td>4.0</td><td>19.13 (VS 2017 15.6)</td></tr>
<tr><td><code>[[nodiscard]]</code> 속성</td><td>P0189R1</td><td>7</td><td>3.9</td><td>19.11 (VS 2017 15.3)</td></tr>
<tr><td><strong>라이브러리 기능 (Library)</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td><code>std::optional</code></td><td>P0220R1</td><td>7</td><td>4.0</td><td>19.10 (VS 2017)</td></tr>
<tr><td><code>std::variant</code></td><td>P0088R0</td><td>7</td><td>4.0</td><td>19.10 (VS 2017)</td></tr>
<tr><td><code>std::any</code></td><td>P0220R1</td><td>7</td><td>4.0</td><td>19.10 (VS 2017)</td></tr>
<tr><td><code>std::string_view</code></td><td>P0220R1</td><td>7</td><td>4.0</td><td>19.10 (VS 2017)</td></tr>
<tr><td><code>std::filesystem</code></td><td>P0218R1</td><td>8</td><td>5.0</td><td>19.14 (VS 2017 15.7)</td></tr>
<tr><td>병렬 알고리즘</td><td>P0024R2</td><td>9</td><td>5.0 (부분)</td><td>19.14 (VS 2017 15.7)</td></tr>
<tr><td><code>std::to_chars</code> / <code>from_chars</code></td><td>P0067R5</td><td>8</td><td>6.0</td><td>19.16 (VS 2017 15.8)</td></tr>
</tbody></table>
<p>주: 위 표의 데이터는 cppreference의 컴파일러 지원 현황 자료를 기반으로 재구성하였다.6 MSVC 버전은 내부 컴파일러 버전(19.xx)과 Visual Studio 제품 버전을 병기하여 명확성을 높였다.</p>
<h3>4.3  컴파일러별 지원 동향 및 특이사항 분석</h3>
<p>C++17 표준 지원 과정에서 컴파일러 벤더들은 각기 다른 전략과 속도를 보였다.</p>
<ul>
<li>
<p><strong>초기 지원 속도:</strong> 오픈소스 컴파일러인 GCC와 Clang은 표준화 논의 과정부터 발 빠르게 기능을 구현하는 경향이 있다. 대부분의 핵심 언어 기능은 GCC 7과 Clang 3.9/4.0 버전에서 신속하게 지원되기 시작했다. 반면, 상용 IDE와 긴밀하게 통합된 MSVC는 Visual Studio 2017의 마이너 업데이트(15.3, 15.5, 15.7 등)를 통해 점진적으로 지원을 완성해 나가는 안정적인 릴리스 주기를 따랐다.6 이는 오픈소스 진영의 빠른 표준 추종 경향과 상용 제품의 안정성 중심 릴리스 전략 사이의 차이를 명확히 보여준다.</p>
</li>
<li>
<p><strong>라이브러리 구현:</strong> <code>std::filesystem</code>이나 병렬 알고리즘과 같이 규모가 크고 복잡한 라이브러리 기능들은 언어 기능보다 지원이 다소 늦어지는 경향을 보였다. 특히 GCC의 경우, 초기 버전(GCC 8 미만)에서는 <code>std::filesystem</code>을 사용하기 위해 표준 라이브러리 외에 <code>libstdc++fs</code>를 별도로 링크해야 하는 불편함이 있었다. MSVC는 Visual Studio 2017 15.7에서 대부분의 주요 라이브러리 지원을 완성하며, 통합 개발 환경으로서의 강력한 이점을 보여주었다.7</p>
</li>
<li>
<p><strong>완전한 지원 시점:</strong> GCC는 버전 7.1에서 대부분의 언어 기능을, 버전 9.1에서 라이브러리 기능의 완전한 지원을 마무리하며 C++17 표준을 거의 완성했다.14 Clang은 버전 5.0에서 언어 기능 지원을 완성하고 이후 버전에서 라이브러리를 순차적으로 지원했다.11 MSVC는 Visual Studio 2017 15.7 (컴파일러 버전 19.14)에서 대부분의 C++17 기능을 지원하게 되었다.7</p>
</li>
</ul>
<h2>5.  C++17 실무 적용 및 마이그레이션 가이드</h2>
<h3>5.1  빌드 시스템 설정</h3>
<p>기존 프로젝트를 C++17로 마이그레이션하거나 새로운 C++17 프로젝트를 시작하기 위해서는 빌드 시스템 설정이 선행되어야 한다.</p>
<ul>
<li>
<p><strong>CMake:</strong> 현대적인 C++ 프로젝트에서 가장 널리 사용되는 빌드 시스템인 CMake에서는 <code>target_compile_features</code>나 전역 변수 설정을 통해 C++ 표준을 지정할 수 있다. 가장 일반적인 방법은 <code>CMakeLists.txt</code> 파일에 다음 구문을 추가하는 것이다.</p>
<pre><code class="language-CMake">set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF) # 순수 C++17 표준만 사용
</code></pre>
</li>
</ul>
<pre><code>
- **Visual Studio:** Visual Studio IDE를 직접 사용하는 경우, `.vcxproj` 프로젝트 파일의 속성에서 언어 표준을 설정할 수 있다. `Project Properties` -&gt; `Configuration Properties` -&gt; `C/C++` -&gt; `Language` -&gt; `C++ Language Standard`를 `ISO C++17 Standard (/std:c++17)`로 변경하면 된다.13

### 5.2  코드베이스 현대화 전략


C++17로의 전환은 단순히 컴파일러 플래그를 변경하는 것 이상의 의미를 가진다. 새로운 기능을 활용하여 코드베이스를 적극적으로 현대화하는 과정이 필요하다.

- **폐지된 기능 대체:** C++17에서는 `std::auto_ptr`, `std::random_shuffle`, 오래된 함수 어댑터 등이 공식적으로 제거되었다.1 마이그레이션 과정에서 이러한 기능들은 현대적인 대체재로 반드시 교체해야 한다.

- `std::auto_ptr` -&gt; `std::unique_ptr`

- `std::random_shuffle` -&gt; `&lt;random&gt;` 헤더의 `std::shuffle`

- `std::bind`의 복잡한 사용 -&gt; 람다 표현식

- **점진적 도입 전략:** 모든 C++17 기능을 한 번에 적용하는 것은 비효율적일 수 있다. 코드의 가독성, 안정성, 성능에 가장 큰 영향을 미치는 기능부터 점진적으로 도입하는 것이 바람직하다.

1. **1단계 (구조 개선):** `if` 초기화 구문, 구조적 바인딩, 중첩 네임스페이스(`namespace A::B {}`)와 같이 코드 구조를 즉각적으로 개선하고 가독성을 높이는 기능들을 우선적으로 도입한다.

2. **2단계 (인터페이스 개선):** `std::optional`을 사용하여 값의 부재를 명시적으로 표현하고, `std::string_view`를 함수 인자로 사용하여 불필요한 문자열 복사를 제거한다. 이를 통해 라이브러리나 모듈의 인터페이스를 더 안전하고 효율적으로 개선한다.

3. **3단계 (템플릿 리팩토링):** 기존의 복잡한 SFINAE나 태그 디스패치 코드를 `if constexpr`를 사용하여 리팩토링한다. 이는 템플릿 코드의 유지보수성을 극적으로 향상시킨다.

4. **4단계 (성능 최적화):** 프로파일링을 통해 병목 현상이 확인되는 계산 집약적인 루프에 병렬 알고리즘 적용을 신중하게 검토한다.

## 6.  결론: C++17 도입의 전략적 가치와 권장 사항


### 6.1  C++17의 핵심 가치 요약


C++17은 C++ 언어의 역사에서 '혁명'이 아닌 '진화'를 택한 표준이다. 그러나 그 영향력은 결코 작지 않다. C++17이 제공하는 핵심 가치는 코드의 **표현력(Expressiveness)**, **가독성(Readability)**, 그리고 **안전성(Safety)**의 비약적인 향상에 있다.

구조적 바인딩과 `if constexpr`는 과거에는 여러 줄에 걸쳐 복잡하게 작성해야 했던 로직을 단 몇 줄의 직관적인 코드로 표현할 수 있게 해준다. `std::optional`과 `std::variant`는 널 포인터나 타입 안전성이 없는 공용체 사용으로 인해 발생하던 잠재적인 런타임 오류를 컴파일 타임에 방지하도록 돕는다. 또한, `std::filesystem`과 병렬 STL은 표준 라이브러리의 활용 범위를 시스템 프로그래밍과 고성능 컴퓨팅 영역으로 크게 넓혀, C++의 생태계를 더욱 풍성하게 만들었다.

### 6.2  도입 권장 사항


**현 시점에서의 C++17:** 2024년 현재, 주요 컴파일러인 GCC (9 이상), Clang (5 이상), MSVC (Visual Studio 2017 15.7 이상)에서 C++17 표준은 매우 안정적으로, 그리고 거의 완전하게 지원된다.10 따라서 새로 시작하는 모든 C++ 프로젝트는 최소 C++17을 기본 표준으로 채택하는 것이 강력히 권장된다. 기존 프로젝트 역시 C++17로의 마이그레이션을 통해 코드 품질과 개발 생산성을 크게 향상시킬 수 있다.

**성공적인 도입을 위한 제언:** C++17의 성공적인 도입은 단순히 컴파일러 플래그를 바꾸는 기술적인 행위를 넘어선다. 이는 팀 전체가 새로운 기능과 그에 따른 모범 사례(best practice)를 학습하고 공유하는 문화적 변화와 함께 이루어져야 한다. C++ Core Guidelines와 같은 현대적인 C++ 스타일 가이드를 참고하여 팀의 코딩 컨벤션을 재정립하고 3, 코드 리뷰 과정에서 새로운 기능들을 적극적으로 활용하도록 장려하는 것이 중요하다. C++17은 더 나은 코드를 작성하기 위한 강력한 도구 모음이며, 그 가치를 극대화하는 것은 결국 이를 사용하는 개발 팀의 역량과 노력에 달려 있다.

## 7. 참고 자료


1. C++17 - Wikipedia, https://en.wikipedia.org/wiki/C%2B%2B17
2. All Major C++17 Features You Should Know - C++ Stories, https://www.cppstories.com/2017/01/cpp17features/
3. C++ Core Guidelines - GitHub Pages, https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
4. C++17 - cppreference.com, https://en.cppreference.com/w/cpp/17.html
5. What are the new features in C++17? - Stack Overflow, https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17
6. C++ compiler support - cppreference.com, https://saco-evaluator.org.za/docs/cppreference/en/cpp/compiler_support.html
7. Compiler support for C++17 - cppreference.com, https://en.cppreference.com/w/cpp/compiler_support/17.html
8. Compiler standards support (c++11, c++14, c++17) - Stack Overflow, https://stackoverflow.com/questions/34836775/compiler-standards-support-c11-c14-c17
9. Supported C/C++ standards in Arm C/C++ Compiler - Arm Developer, https://developer.arm.com/documentation/101458/latest/Standards-support/Supported-C-C---standards-in-Arm-C-C---Compiler
10. GNU Compiler Collection - Wikipedia, https://en.wikipedia.org/wiki/GNU_Compiler_Collection
11. Clang - Wikipedia, https://en.wikipedia.org/wiki/Clang
12. /std (Specify Language Standard Version) | Microsoft Learn, https://learn.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=msvc-170
13. How to change the default C++ compiler standard in Visual Studio 2022 properties? - Reddit, https://www.reddit.com/r/VisualStudio/comments/1ivgf3s/how_to_change_the_default_c_compiler_standard_in/
14. cpp/compiler support/vendors - cppreference.com - C++ Reference, https://en.cppreference.com/w/cpp/compiler_support/vendors.html
15. GCC Releases - GNU Project, https://gcc.gnu.org/releases.html
16. MSVC C/C++ compiler reference - Visual Studio - Microsoft Learn, https://learn.microsoft.com/en-us/cpp/build/reference/compiling-a-c-cpp-program?view=msvc-170
17. Visual Studio - Wikipedia, https://en.wikipedia.org/wiki/Visual_Studio
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>