<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Supabase Storage 시스템</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Supabase Storage 시스템</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">SUPABASE</a> / <span>Supabase Storage 시스템</span></nav>
                </div>
            </header>
            <article>
                <h1>Supabase Storage 시스템</h1>
<h2>1. 서론</h2>
<p>Supabase Storage는 단순한 파일 저장 솔루션을 넘어, Supabase 생태계의 핵심적인 축을 담당하는 S3 호환 객체 스토리지 시스템이다.1 이는 데이터베이스(Postgres), 인증(Auth), 엣지 함수(Edge Functions)와 같은 다른 Supabase 서비스들과 유기적으로 결합하여, 개발자에게 통일되고 일관된 백엔드 개발 경험을 제공하는 것을 목표로 한다.</p>
<p>Supabase Storage의 가장 근본적인 차별점이자 핵심 가치는 Postgres 데이터베이스와의 깊은 통합에 있다. 시장의 다른 BaaS(Backend-as-a-Service) 솔루션들이 스토리지 시스템을 독립적인 컴포넌트로 취급하는 것과 대조적으로, Supabase는 파일의 메타데이터를 사용자의 Postgres 데이터베이스 내에 직접 저장한다.3 이러한 아키텍처적 선택은 Postgres가 가진 강력한 기능, 특히 행 수준 보안(Row Level Security, RLS)을 파일 접근 제어에 그대로 적용할 수 있게 만드는 혁신적인 결과를 낳았다.2 결과적으로 개발자는 별도의 접근 제어 언어(DSL)를 학습할 필요 없이, 익숙한 SQL을 사용하여 데이터베이스와 스토리지의 보안 정책을 하나의 일관된 모델 안에서 관리할 수 있다. 본 안내서는 Supabase Storage의 아키텍처, 핵심 기능, 보안 모델, 성능 최적화 전략, 그리고 가격 정책을 심층적으로 분석하고, 주요 경쟁 서비스와의 비교를 통해 그 기술적 가치와 전략적 위상을 평가하고자 한다.</p>
<h2>2.  Supabase Storage 아키텍처 심층 분석</h2>
<p>Supabase Storage의 아키텍처는 메타데이터와 실제 객체 데이터를 분리하고, 이를 강력한 미들웨어와 API 게이트웨이를 통해 통합하는 현대적인 클라우드 네이티브 설계를 채택하고 있다.</p>
<h3>2.1  핵심 구성 요소</h3>
<p>Supabase Storage 시스템은 네 가지 주요 구성 요소의 상호 작용으로 이루어진다.</p>
<ul>
<li><strong>Postgres 메타데이터 저장소</strong>: 시스템의 두뇌 역할을 하는 부분이다. 실제 파일 데이터가 아닌, 해당 파일을 설명하는 모든 메타데이터(파일명, 크기, MIME 타입, 소유자 정보, 생성 시각 등)가 사용자의 Postgres 데이터베이스 내 <code>storage</code> 스키마에 위치한 <code>objects</code>와 <code>buckets</code> 테이블에 저장된다.3 이는 모든 스토리지 관련 정보가 표준 SQL 쿼리를 통해 직접 조회, 조인, 필터링이 가능하다는 것을 의미하며, RLS 정책 적용의 기반이 된다.3</li>
<li><strong>S3 호환 스토리지 백엔드</strong>: 이미지, 비디오, 문서 등 실제 파일 객체는 AWS S3와 같이 내구성과 확장성이 검증된 객체 스토리지에 저장된다.6 Supabase는 이 백엔드를 추상화하여 제공하며, 개발자는 S3의 복잡성을 직접 다룰 필요가 없다. 자체 호스팅(Self-hosting) 환경에서는 로컬 파일 시스템이나 Cloudflare R2와 같은 다른 S3 호환 스토리지를 백엔드로 지정할 수 있는 유연성을 제공한다.4</li>
<li><strong>스토리지 API 서버 (storage-api)</strong>: Node.js와 TypeScript로 구현된 경량 미들웨어 서버로, 클라이언트와 스토리지 백엔드 사이의 중재자 역할을 수행한다.5 클라이언트로부터의 모든 파일 관련 요청(업로드, 다운로드, 삭제 등)을 수신하고, 요청 헤더의 JWT(JSON Web Token)를 기반으로 Postgres 데이터베이스의 RLS 정책을 실행하여 접근 권한을 검증한다. 권한이 확인되면, S3 백엔드로부터 파일을 스트리밍하여 클라이언트에게 전달하거나, 클라이언트로부터 받은 파일을 S3 백엔드에 저장한다.6 이 서버는 RESTful API, TUS(재개 가능한 업로드), S3 호환 API라는 세 가지 주요 프로토콜을 모두 처리하는 핵심 로직을 담고 있다.</li>
<li><strong>API 게이트웨이 (Kong)</strong>: 모든 외부 요청이 가장 먼저 도달하는 관문이다.8 Kong은 오픈소스 API 게이트웨이로, 인증, 요청 라우팅, 속도 제한(Rate Limiting), 부하 분산 등 시스템의 안정성과 보안을 위한 필수적인 기능을 수행한다. 스토리지 요청 역시 Kong을 통과하여 적절한 스토리지 API 서버 인스턴스로 전달된다.6</li>
</ul>
<p>이러한 메타데이터와 객체 데이터의 분리 구조는 Supabase Storage의 핵심적인 설계 철학을 보여준다. 이 구조는 각 구성 요소가 자신의 전문 분야에 집중하도록 한다. Postgres는 트랜잭션, 복잡한 쿼리, 데이터 무결성, 그리고 강력한 보안 모델을 제공하는 데 최적화되어 있다. 반면, S3는 대용량의 비정형 데이터를 저렴하고 안정적으로 저장하는 데 세계 최고 수준의 성능을 보인다. Supabase는 이 두 시스템의 장점을 결합하고 추상화하여, 개발자에게는 단순하고 통합된 인터페이스를 제공하면서도 내부적으로는 매우 강력하고 확장 가능한 시스템을 구현하였다.</p>
<h3>2.2  요청 수명 주기 분석</h3>
<p>사용자의 요청이 Supabase Storage 시스템 내에서 어떻게 처리되는지 이해하는 것은 아키텍처를 파악하는 데 중요하다.</p>
<ul>
<li><strong>업로드 요청</strong>:</li>
</ul>
<ol>
<li>클라이언트가 파일을 업로드하면, 요청은 먼저 API 게이트웨이(Kong)에 도달한다. 게이트웨이는 요청 헤더에 포함된 JWT를 검증하여 사용자의 인증 상태를 확인한다.</li>
<li>검증된 요청은 스토리지 API 서버로 전달된다.</li>
<li>API 서버는 해당 요청을 <code>storage.objects</code> 테이블에 대한 <code>INSERT</code> 작업으로 해석하고, Postgres 데이터베이스에 RLS 정책 실행을 요청한다.</li>
<li>Postgres는 현재 사용자의 <code>auth.uid()</code>와 요청된 파일 경로, 버킷 ID 등의 정보를 바탕으로 정의된 <code>INSERT</code> 정책(<code>WITH CHECK</code> 절)을 평가하여 업로드 권한 여부를 결정한다.</li>
<li>권한이 확인되면, API 서버는 클라이언트로부터 파일 데이터를 스트리밍하여 S3 백엔드에 직접 업로드한다. 동시에 파일의 메타데이터를 <code>storage.objects</code> 테이블에 기록한다.6</li>
</ol>
<ul>
<li><strong>다운로드 요청</strong>:</li>
</ul>
<ol>
<li>업로드와 유사하게, 다운로드 요청 또한 게이트웨이와 API 서버를 순차적으로 거친다.</li>
<li>API 서버는 이 요청을 <code>storage.objects</code> 테이블에 대한 <code>SELECT</code> 작업으로 해석하고, RLS 정책 실행을 요청한다.</li>
<li>Postgres는 <code>SELECT</code> 정책(<code>USING</code> 절)을 평가하여 사용자가 해당 파일 메타데이터 행을 조회할 권한이 있는지 확인한다.</li>
<li>정책을 통과하면, API 서버는 S3 백엔드에서 해당 객체를 스트리밍하여 클라이언트에게 전달한다. 이 과정에서 CDN이 중간에 개입하여 캐시된 데이터를 제공할 수 있다.11</li>
</ol>
<ul>
<li>이미지 변환 요청:</li>
</ul>
<p>이미지 변환은 더 정교한 흐름을 따른다.</p>
<ol>
<li>사용자가 이미지 변환 쿼리 파라미터(예: <code>?width=100</code>)가 포함된 URL을 요청하면, 요청은 API 게이트웨이에 도달한다.</li>
<li>게이트웨이는 전역으로 분산된 KV(Key-Value) 스토어에서 해당 이미지의 메타데이터(특히 ETag)를 조회하여, 이미 변환되어 CDN에 캐시된 버전이 있는지 확인한다.12</li>
<li>캐시된 버전이 없다면(Cache Miss), 요청은 스토리지 서버로 전달된다.</li>
<li>스토리지 서버는 S3에 저장된 원본 파일에 접근할 수 있는 단기 유효 URL을 생성하여 Imgproxy라는 이미지 처리 전문 서비스에 전달한다.</li>
<li>Imgproxy는 URL을 통해 원본 이미지를 가져와 요청된 파라미터에 따라 이미지를 변환한다.</li>
<li>변환된 이미지는 다시 스토리지 서버와 게이트웨이를 거쳐 CDN에 캐시된 후, 최종적으로 클라이언트에게 제공된다.12</li>
</ol>
<p>이러한 아키텍처는 데이터베이스의 보안 모델을 스토리지 시스템에 직접 투영하는 강력한 패러다임을 만들어낸다. 개발자는 <code>storage.objects</code> 테이블에 대한 RLS 정책을 작성함으로써 파일 접근 권한을 제어하는데, 이는 본질적으로 데이터베이스 테이블에 대한 <code>SELECT</code>나 <code>INSERT</code> 권한을 제어하는 것과 동일한 원리다. 이는 Firebase의 Security Rules나 AWS S3의 IAM 정책과 같은 별도의 보안 언어나 시스템을 배울 필요 없이, SQL이라는 단일하고 강력한 언어로 데이터와 파일 보안을 통합 관리할 수 있음을 의미한다. 더 나아가, RLS 정책 내에서 다른 테이블과 <code>JOIN</code>을 수행할 수 있기 때문에, “사용자가 특정 팀(<code>teams</code> 테이블)의 멤버이고, 해당 팀 내에서 ‘편집자’ 역할(<code>team_members</code> 테이블)을 가질 때만 특정 폴더의 파일에 접근할 수 있다“와 같은 매우 동적이고 복잡한 비즈니스 로직 기반의 접근 제어를 손쉽게 구현할 수 있다. 이는 다른 스토리지 솔루션에서는 구현하기 매우 어렵거나 불가능한 수준의 유연성을 제공한다.</p>
<h2>3.  핵심 구성 요소와 개념</h2>
<p>Supabase Storage는 버킷, 폴더, 객체라는 세 가지 단순하고 직관적인 개념으로 구성되어 있다.</p>
<h3>3.1  버킷 (Buckets)</h3>
<p>버킷은 파일과 폴더를 담는 최상위 컨테이너로, 스토리지 시스템의 가장 기본적인 조직 단위다. 각 버킷은 고유한 이름을 가지며, 버킷 수준에서 중요한 보안 및 정책 설정이 이루어진다.13 예를 들어, 파일의 최대 업로드 크기나 허용되는 MIME 타입(예: <code>image/png</code>, <code>application/pdf</code>) 등을 버킷 단위로 제한할 수 있다.11 버킷은 접근 모델에 따라 Public과 Private, 두 가지 유형으로 나뉜다.</p>
<ul>
<li>
<p><strong>Public 버킷</strong>: Public 버킷에 저장된 파일은 다운로드나 조회를 할 때 접근 제어를 사실상 우회한다. 즉, 파일의 URL을 알고 있는 사람이라면 누구나 해당 파일에 접근할 수 있다.11 이는 사용자 프로필 이미지, 블로그 포스트에 포함된 사진, 공개용 제품 이미지 등 인증 여부와 관계없이 누구나 볼 수 있어야 하는 자산을 저장하는 데 이상적이다. 중요한 점은, Public 설정은 오직 읽기(SELECT) 작업에만 적용된다는 것이다. 파일을 새로 업로드(INSERT)하거나, 수정(UPDATE), 삭제(DELETE)하는 작업은 여전히 RLS 정책의 엄격한 통제를 받는다.15 또한, Public 버킷의 객체는 CDN 캐시 효율이 매우 높다. 특정 사용자의 인증 상태를 확인할 필요가 없기 때문에, 한번 캐시된 파일은 모든 사용자에게 엣지 로케이션에서 빠르게 제공될 수 있어 성능상 큰 이점을 가진다.11</p>
</li>
<li>
<p><strong>Private 버킷</strong>: Private 버킷은 기본 설정이며, 모든 작업(읽기, 쓰기, 수정, 삭제)이 RLS 정책에 의해 철저하게 통제된다.11 사용자의 민감한 문서, 구매 영수증, 개인적인 사진 등 허가된 사용자만 접근해야 하는 비공개 자산을 저장하는 데 사용된다. Private 버킷 내의 파일에 접근하기 위한 방법은 두 가지로 제한된다. 첫째, 인증된 사용자의 JWT를 포함하여 Supabase 클라이언트 라이브러리의</p>
</li>
</ul>
<p><code>download()</code> 메소드를 호출하는 방법이다. 이 경우, Supabase는 JWT를 검증하고 RLS 정책을 실행하여 접근 권한을 확인한다. 둘째, <code>createSignedUrl()</code> 메소드를 사용하여 특정 파일에 대한 제한된 시간 동안 유효한 서명된 URL을 생성하는 방법이다. 이 URL에는 접근 권한 정보가 토큰 형태로 포함되어 있어, URL을 가진 사람은 정해진 시간 동안 파일에 접근할 수 있다.11</p>
<p>이 Public/Private 구분은 단순한 보안 설정을 넘어, 성능과 비용, 그리고 아키텍처에 직접적인 영향을 미치는 중요한 결정 사항이다. Private 버킷의 경우, 동일한 파일을 다른 사용자가 같은 지역에서 요청하더라도 각 사용자의 JWT와 RLS 정책을 개별적으로 확인해야 하므로 CDN 캐시 미스(Cache Miss)가 발생한다.16 반면 Public 버킷은 한번 캐시되면 높은 캐시 히트(Cache Hit)율을 보인다. 이는 Public 버킷이 더 낮은 지연 시간과 더 저렴한 데이터 전송(Egress) 비용으로 이어진다는 것을 의미한다.17 따라서 개발자는 자산의 성격에 따라 보안 요구사항과 성능/비용 요구사항 사이의 균형을 고려하여 버킷 유형을 신중하게 선택해야 한다.</p>
<h3>3.2  폴더 (Folders) 및 객체 (Objects)</h3>
<ul>
<li><strong>폴더</strong>: 폴더는 파일을 논리적으로 그룹화하고 정리하기 위한 수단이다.13 컴퓨터의 파일 시스템과 유사한 경험을 제공하지만, 내부적으로는 실제 폴더라는 개체가 존재하는 것이 아니다. 폴더는 객체의 경로(Key)의 일부로 표현되는 가상적인 개념이다. 예를 들어,</li>
</ul>
<p><code>user-avatars/user-123/profile.png</code>라는 경로의 객체는 <code>user-avatars</code>와 <code>user-123</code>이라는 가상의 폴더 구조 안에 있는 것으로 간주된다.14</p>
<ul>
<li><strong>객체</strong>: 객체는 스토리지에 저장되는 개별 파일을 의미한다.14 이미지, 동영상, PDF, 텍스트 파일 등 모든 종류의 디지털 콘텐츠가 객체가 될 수 있다.18 대용량 파일을 데이터베이스에 직접 저장하는 것(예: Base64 인코딩된 문자열이나 BLOB 타입)은 데이터베이스의 성능을 저하시키고 백업 및 관리를 어렵게 만들기 때문에, 이러한 파일들은 객체 스토리지에 객체로 저장하는 것이 일반적인 모범 사례다.13</li>
</ul>
<h2>4.  파일 관리 및 API 활용</h2>
<p>Supabase Storage는 다양한 사용 사례와 네트워크 환경에 대응하기 위해 세 가지 주요 업로드 프로토콜을 제공하며, 이 모든 기능은 직관적인 JavaScript/TypeScript SDK를 통해 쉽게 활용할 수 있다.</p>
<h3>4.1  업로드 프로토콜</h3>
<ul>
<li>
<p><strong>표준 업로드 (Standard Uploads)</strong>: HTTP <code>multipart/form-data</code> 형식을 사용하는 가장 기본적인 업로드 방식이다. 구현이 매우 간단하여, 6MB 미만의 작은 파일을 업로드하는 데 가장 적합하다. 안정적인 네트워크 환경에서 간단한 파일 업로드 기능을 구현할 때 주로 사용된다.20</p>
</li>
<li>
<p><strong>재개 가능한 업로드 (Resumable Uploads - TUS)</strong>: TUS(The Upload Server)라는 개방형 프로토콜을 기반으로 한다. 이 방식은 대용량 파일(6MB 이상 권장, 유료 플랜에서는 최대 500GB까지 가능)을 업로드하거나 네트워크 연결이 불안정한 환경에서 필수적이다.21 파일은 6MB 크기의 청크(chunk)로 나뉘어 순차적으로 전송된다. 만약 업로드 도중 네트워크 연결이 끊기거나 브라우저가 종료되더라도, 나중에 중단된 청크부터 이어서 전송을 재개할 수 있어 안정성과 효율성이 매우 높다.22</p>
</li>
</ul>
<p><code>tus-js-client</code>나 Uppy와 같은 TUS 프로토콜을 지원하는 클라이언트 라이브러리를 통해 구현할 수 있다.18</p>
<ul>
<li><strong>S3 멀티파트 업로드 (S3 Multipart Uploads)</strong>: S3 호환 API를 통해 제공되는 기능으로, 대용량 파일을 여러 부분으로 분할하여 병렬로 동시에 업로드한다.25 이는 네트워크 대역폭을 최대한 활용하여 업로드 속도를 극대화하는 데 목적이 있다. TUS와 달리 업로드 재개 기능은 없지만, 빠른 네트워크를 갖춘 서버 환경에서 대용량 파일을 최대한 빠르게 업로드해야 할 때 가장 효과적인 방법이다.26</li>
</ul>
<h3>4.2  JavaScript/TypeScript SDK 활용 예제</h3>
<p>Supabase는 <code>supabase-js</code> 라이브러리를 통해 스토리지의 모든 기능을 프로그래밍 방식으로 제어할 수 있는 강력한 API를 제공한다. TypeScript와 함께 사용하면 타입 안정성까지 확보할 수 있다.</p>
<ul>
<li>
<p><strong>파일 업로드 (<code>upload</code>)</strong>:</p>
<pre><code class="language-TypeScript">import { createClient } from '@supabase/supabase-js';
import { Database } from './database.types'; // Supabase CLI로 생성된 타입

const supabase = createClient&lt;Database&gt;('YOUR_URL', 'YOUR_ANON_KEY');

async function uploadProfilePicture(userId: string, file: File) {
  const { data, error } = await supabase
  .storage
  .from('avatars')
  .upload(`${userId}/avatar.png`, file, {
      cacheControl: '3600',
      upsert: true, // 파일이 존재하면 덮어쓰기
    });

  if (error) {
    console.error('Error uploading file:', error);
  } else {
    console.log('File uploaded successfully:', data.path);
  }
}
</code></pre>
</li>
</ul>
<pre><code>
`upsert: true` 옵션은 동일한 경로에 파일이 이미 존재할 경우, 별도의 삭제 과정 없이 새로운 파일로 덮어쓰도록 한다. 이는 프로필 사진 업데이트와 같은 시나리오에서 매우 유용하다.20

- 파일 다운로드 (download):

Private 버킷에 저장된 파일을 다운로드할 때 사용한다. 이 API를 호출하는 사용자는 해당 파일에 대한 RLS select 권한을 가지고 있어야 한다.11

  ```TypeScript
  async function downloadInvoice(userId: string, invoiceId: string) {
    const { data, error } = await supabase
    .storage
    .from('invoices')
    .download(`${userId}/${invoiceId}.pdf`);
  
    if (data) {
      // 다운로드된 Blob 데이터를 처리 (예: 파일로 저장 또는 화면에 표시)
    }
  }
</code></pre>
<ul>
<li>파일 목록 조회 (list):</li>
</ul>
<p>특정 폴더 내의 파일 및 하위 폴더 목록을 조회한다. 페이지네이션(limit, offset), 정렬(sortBy), 검색(search) 기능을 지원하여 효율적인 파일 탐색이 가능하다.30</p>
<pre><code class="language-TypeScript">async function listUserFiles(userId: string) {
  const { data, error } = await supabase
  .storage
  .from('documents')
  .list(userId, {
      limit: 100,
      offset: 0,
      sortBy: { column: 'name', order: 'asc' },
    });
}
</code></pre>
<ul>
<li>파일 삭제 (remove):</li>
</ul>
<p>배열을 인자로 받아 하나 이상의 파일을 동시에 삭제할 수 있다.32</p>
<pre><code class="language-TypeScript">async function deleteFiles(filePaths: string) {
  const { data, error } = await supabase
  .storage
  .from('media')
  .remove(filePaths);
}
</code></pre>
<ul>
<li>파일 이동 및 복사 (move, copy):</li>
</ul>
<p>파일의 경로를 변경(이동)하거나 새로운 경로에 복제할 수 있다. 이 기능은 이제 버킷 간 이동 및 복사도 지원하여 데이터 관리의 유연성을 높였다.18</p>
<pre><code class="language-TypeScript">async function moveFileToArchive(filePath: string) {
  const { data, error } = await supabase
  .storage
  .from('active-projects')
  .move(filePath, `archive/${filePath}`);
}
</code></pre>
<h2>5.  고급 기능 탐구</h2>
<p>Supabase Storage는 단순한 파일 저장을 넘어, 현대적인 애플리케이션 개발에 필요한 강력한 고급 기능들을 내장하고 있다. 이미지 변환, 스마트 CDN, S3 호환성은 Supabase Storage를 단순한 스토리지 솔루션에서 포괄적인 미디어 처리 및 전송 플랫폼으로 격상시키는 핵심 요소들이다.</p>
<h3>5.1  이미지 변환 시스템 (Image Transformation System)</h3>
<p>Pro 플랜 이상에서 제공되는 이 기능은, 원본 이미지를 한 번만 업로드하면 URL 쿼리 파라미터를 통해 실시간으로 다양한 버전의 이미지를 생성하고 제공할 수 있게 한다.33</p>
<ul>
<li><strong>주요 변환 기능</strong>:</li>
<li><strong>리사이징</strong>: <code>width</code>와 <code>height</code> 파라미터로 이미지 크기를 조절한다. <code>resize</code> 모드(<code>cover</code>, <code>contain</code>, <code>fill</code>)를 통해 원본 이미지의 종횡비를 어떻게 처리할지 결정할 수 있다. <code>cover</code>가 기본값이며, CSS의 <code>object-fit</code> 속성과 유사하게 작동하여 직관적이다.33</li>
<li><strong>품질 조절</strong>: <code>quality</code> 파라미터(20-100)를 사용하여 이미지의 압축률을 조절, 파일 크기와 시각적 품질 사이의 균형을 맞출 수 있다. 기본값은 80이다.33</li>
<li><strong>자동 포맷 최적화</strong>: Supabase는 요청을 보낸 클라이언트(브라우저)의 <code>Accept</code> 헤더를 분석하여, 해당 브라우저가 지원하는 가장 효율적인 이미지 포맷으로 자동으로 변환하여 응답한다. 예를 들어, 최신 브라우저는 대부분 WebP 포맷을 지원하므로, 원본이 JPEG나 PNG이더라도 더 작은 크기의 WebP 이미지로 변환되어 전송된다. 이는 데이터 전송량(Egress)을 크게 줄이고 웹 페이지 로딩 속도를 향상시키는 데 결정적인 역할을 한다. <code>format=origin</code> 쿼리 파라미터를 추가하여 이 기능을 비활성화하고 원본 포맷을 유지할 수도 있다.33</li>
<li><strong>이미지 변환 요청 처리 흐름</strong>: 이 기능의 강력함은 분산 아키텍처에서 비롯된다. 요청이 발생하면, API 게이트웨이는 먼저 글로벌 KV 스토어와 CDN을 확인하여 이미 변환된 이미지가 캐시되어 있는지 검사한다. 캐시가 없는 경우에만 스토리지 서버가 이미지 처리 전문 서비스인 Imgproxy를 호출하여 S3 백엔드의 원본 이미지를 변환한다. 변환된 결과는 CDN에 캐시된 후 사용자에게 전달된다.12 이 방식은 반복적인 변환 작업을 방지하고 전 세계 사용자에게 빠른 응답 속도를 보장한다.12</li>
</ul>
<table><thead><tr><th>파라미터</th><th>설명</th><th>허용 값</th><th>기본값</th><th>제한 사항</th></tr></thead><tbody>
<tr><td><code>width</code></td><td>변환될 이미지의 너비</td><td><code>1</code> - <code>2500</code> 사이의 정수</td><td>원본 너비</td><td>이미지 해상도 50MP 이하</td></tr>
<tr><td><code>height</code></td><td>변환될 이미지의 높이</td><td><code>1</code> - <code>2500</code> 사이의 정수</td><td>원본 높이</td><td>이미지 크기 25MB 이하</td></tr>
<tr><td><code>resize</code></td><td>리사이징 방식</td><td><code>cover</code>, <code>contain</code>, <code>fill</code></td><td><code>cover</code></td><td>-</td></tr>
<tr><td><code>quality</code></td><td>이미지 품질 (압축률)</td><td><code>20</code> - <code>100</code> 사이의 정수</td><td><code>80</code></td><td>-</td></tr>
<tr><td><code>format</code></td><td>자동 포맷 최적화 비활성화</td><td><code>origin</code></td><td>자동 감지</td><td>-</td></tr>
</tbody></table>
<h3>5.2  콘텐츠 전송 네트워크 (Content Delivery Network - CDN)</h3>
<p>Supabase는 모든 프로젝트에 전 세계 285개 이상의 도시에 분산된 글로벌 CDN을 기본으로 제공한다.18 CDN은 사용자와 지리적으로 가장 가까운 엣지 서버에 파일(자산)을 캐싱하여, 물리적 거리에 따른 지연 시간을 최소화하고 데이터 전송 속도를 극적으로 향상시킨다.16</p>
<ul>
<li><strong>Smart CDN</strong>: Pro 플랜 이상에서 제공되는 Smart CDN은 기존 CDN의 한계를 극복한다.38 전통적인 CDN 환경에서는 파일이 업데이트되거나 삭제되어도 캐시가 만료(TTL)될 때까지 이전 버전의 파일이 계속 제공되는 ‘stale content’ 문제가 발생할 수 있다. Smart CDN은 Supabase 데이터베이스의 메타데이터 변경 사항을 실시간으로 감지한다. 파일이 업데이트되거나 삭제되면, 이 변경 사항이 60초 이내에 전 세계 모든 CDN 엣지 노드로 전파되어 해당 파일의 캐시를 자동으로 무효화(invalidate)시킨다.12 이로 인해 개발자는 복잡한 캐시 무효화 로직을 직접 구현할 필요 없이 항상 최신 콘텐츠를 사용자에게 제공할 수 있다.38</li>
<li><strong>캐시 제어</strong>: Smart CDN이 서버 측 캐시를 자동으로 관리하는 동안, 개발자는 파일 업로드 시 <code>cacheControl</code> 옵션을 통해 브라우저 측 캐시의 동작을 제어할 수 있다. 예를 들어, <code>cacheControl: 'public, max-age=31536000'</code>과 같이 설정하면 브라우저가 해당 파일을 1년 동안 캐시에 저장하도록 지시하여 반복적인 다운로드를 줄이고 Egress 비용을 절감할 수 있다.38</li>
</ul>
<h3>5.3  S3 호환성 (S3 Compatibility)</h3>
<p>Supabase Storage는 표준 S3 API와 호환성을 제공하며, 이는 Supabase를 단순한 BaaS를 넘어 범용적인 스토리지 인프라로 활용할 수 있게 하는 매우 중요한 기능이다.41</p>
<ul>
<li><strong>의의 및 활용</strong>: S3 API는 사실상 객체 스토리지의 산업 표준이다. Supabase가 이를 지원함으로써, 개발자들은 AWS CLI, rclone, Cyberduck, 각종 데이터 엔지니어링 도구(DuckDB, Spark 등)와 같은 방대한 S3 생태계의 도구와 라이브러리를 Supabase Storage에 직접 연결하여 사용할 수 있다.26 이는 기존 워크플로우를 그대로 유지하면서 데이터를 마이그레이션하거나, 정교한 백업 스크립트를 실행하고, 데이터 분석 파이프라인을 구축하는 등의 작업을 가능하게 한다.</li>
<li><strong>인증 및 상호 운용성</strong>: S3 호환 API는 두 가지 인증 방식을 지원한다. 첫째는 서버 측에서 사용하는 <code>Access Key</code>와 <code>Secret Key</code>로, 이는 RLS를 우회하여 모든 스토리지에 대한 관리자 권한을 가진다. 둘째는 클라이언트 측이나 사용자별 권한이 필요한 서버 환경에서 사용하는 방식으로, 사용자의 JWT를 S3의 <code>Session Token</code>으로 전달하여 RLS 정책을 그대로 적용받게 한다.26 이 두 가지 방식을 통해 다양한 환경에서 유연하고 안전한 접근이 가능하다. 또한, TUS 프로토콜로 업로드한 파일을 S3 API로 관리하고, REST API를 통해 서빙하는 등 모든 프로토콜이 완벽하게 상호 운용되어 동일한 객체를 일관되게 다룰 수 있다.41</li>
</ul>
<p>이 고급 기능들의 조합은 강력한 시너지를 창출한다. 예를 들어, Smart CDN과 RLS의 상호작용을 깊이 이해하는 것은 성능 최적화에 매우 중요하다. Public 버킷의 파일은 사용자 인증이 필요 없으므로 CDN에 한번 캐시되면 높은 히트율을 보장하며 Smart CDN의 자동 무효화 혜택을 최대로 누릴 수 있다. 반면, Private 버킷의 파일은 접근 시마다 사용자별 RLS 정책을 확인해야 하므로, 다른 사용자가 동일 파일을 요청해도 CDN 캐시 미스가 발생하기 쉽다.16 이 문제를 해결하는 최적의 디자인 패턴은 Private 버킷의 파일에 접근할 때 직접 <code>download()</code>를 호출하는 대신, 백엔드(예: 엣지 함수)에서 해당 사용자를 위한 단기 서명된 URL(<code>Signed URL</code>)을 생성하여 클라이언트에 전달하는 것이다. 이 서명된 URL 자체는 인증 정보를 포함하고 있어 독립적이고 캐시가 가능한 단위가 된다. 따라서 CDN은 이 고유한 URL을 키로 하여 객체를 캐시할 수 있게 되어, RLS의 강력한 보안과 CDN의 높은 성능을 모두 달성할 수 있다.</p>
<h2>6.  보안 모델: RLS와 서명된 URL</h2>
<p>Supabase Storage의 보안 모델은 Postgres 데이터베이스의 행 수준 보안(Row Level Security, RLS)을 핵심 기반으로 삼고, 서명된 URL(Signed URL)을 통해 유연성을 더하는 강력하고 일관된 구조를 가지고 있다.</p>
<h3>6.1  Row Level Security (RLS) 심층 분석</h3>
<p>RLS는 Supabase Storage 보안의 심장부다. 모든 스토리지 접근 요청(읽기, 쓰기, 수정, 삭제)은 내부적으로 <code>storage.objects</code>라는 Postgres 테이블에 대한 SQL 쿼리로 변환되어 실행된다.2 RLS 정책은 이 쿼리가 실행되기 직전에 적용되는 필터, 즉 동적인 <code>WHERE</code> 절이라고 생각할 수 있다. 이 정책은 요청을 보낸 사용자의 인증 정보(JWT에 담긴 <code>uid</code>, <code>role</code> 등)를 기반으로 해당 사용자가 특정 파일(테이블의 행)에 접근할 수 있는지를 결정한다.44</p>
<ul>
<li><strong><code>USING</code>과 <code>WITH CHECK</code> 절의 역할</strong>: RLS 정책은 <code>USING</code>과 <code>WITH CHECK</code>라는 두 가지 핵심 절을 사용하여 정의된다. 이 둘의 차이를 명확히 이해하는 것이 중요하다.44</li>
<li><strong><code>USING (expression)</code></strong>: 이 절은 <strong>기존에 존재하는 행</strong>에 대한 접근 권한을 제어한다. <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>와 같은 작업에 적용된다. <code>USING</code> 절의 <code>expression</code>이 <code>true</code>로 평가되는 행에만 해당 작업을 수행할 수 있다. 예를 들어, <code>SELECT</code> 정책에서 <code>USING (auth.uid() = owner_id)</code>는 <code>owner_id</code>가 현재 사용자의 ID와 일치하는 파일만 볼 수 있도록 필터링하는 역할을 한다.</li>
<li><strong><code>WITH CHECK (expression)</code></strong>: 이 절은 <strong>새로 생성되거나 수정될 행</strong>이 특정 조건을 만족하는지 검사한다. <code>INSERT</code>와 <code>UPDATE</code> 작업에 적용된다. <code>WITH CHECK</code> 절의 <code>expression</code>이 <code>true</code>로 평가되어야만 데이터의 변경이 허용된다. 예를 들어, <code>INSERT</code> 정책에서 <code>WITH CHECK (bucket_id = 'avatars')</code>는 ‘avatars’ 버킷에만 파일을 업로드할 수 있도록 강제한다. <code>UPDATE</code> 시에는 수정된 후의 행이 이 조건을 만족해야 한다.</li>
<li><strong>헬퍼 함수 활용</strong>: Supabase는 RLS 정책 작성을 돕기 위해 유용한 SQL 헬퍼 함수를 제공한다.</li>
<li><code>auth.uid()</code>: 요청 헤더의 JWT에서 추출한 현재 인증된 사용자의 고유 ID(UUID)를 반환한다. “사용자는 자신의 파일에만 접근할 수 있다“와 같은 소유권 기반 정책을 구현하는 데 필수적이다.44</li>
<li><code>storage.foldername(name)</code>: 파일의 전체 경로(<code>name</code> 컬럼)에서 폴더 경로 부분만 추출하여 텍스트 배열로 반환한다. 예를 들어, 파일 경로가 <code>user123/docs/report.pdf</code>일 경우, <code>storage.foldername(name)</code>은 <code>{'user123', 'docs'}</code>를 반환한다. 이를 통해 <code>(storage.foldername(name)) = auth.uid()::text</code>와 같은 조건을 사용하여 사용자가 자신의 ID와 동일한 이름의 최상위 폴더에만 파일을 업로드하도록 강제하는 일반적인 패턴을 구현할 수 있다.45</li>
</ul>
<table><thead><tr><th>사용 사례</th><th>적용 작업</th><th>RLS 정책 예시 (SQL)</th><th>핵심 개념</th></tr></thead><tbody>
<tr><td><strong>Public 버킷 설정</strong></td><td>SELECT, INSERT</td><td><code>CREATE POLICY "Public Read" ON storage.objects FOR SELECT USING (bucket_id = 'public_avatars');</code> <code>CREATE POLICY "Auth Insert" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'public_avatars');</code></td><td><code>USING</code>으로 모든 읽기 허용, <code>WITH CHECK</code>로 인증된 사용자만 쓰기 허용</td></tr>
<tr><td><strong>사용자별 폴더 격리</strong></td><td>ALL</td><td><code>CREATE POLICY "User Folder Isolation" ON storage.objects FOR ALL USING (bucket_id = 'user_files' AND auth.uid()::text = (storage.foldername(name))) WITH CHECK (bucket_id = 'user_files' AND auth.uid()::text = (storage.foldername(name)));</code></td><td><code>auth.uid()</code>와 <code>storage.foldername()</code>을 결합하여 파일 경로 기반으로 완벽한 사용자 데이터 격리 구현</td></tr>
<tr><td><strong>팀 기반 접근 제어</strong></td><td>SELECT</td><td><code>CREATE POLICY "Team Member Access" ON storage.objects FOR SELECT USING (bucket_id = 'team_documents' AND EXISTS (SELECT 1 FROM team_members WHERE team_id = (storage.foldername(name))::uuid AND user_id = auth.uid()));</code></td><td><code>EXISTS</code>와 서브쿼리를 사용하여 다른 테이블(<code>team_members</code>)과 <code>JOIN</code>하여 복잡한 권한 로직 구현</td></tr>
<tr><td><strong>특정 파일 타입만 업로드 허용</strong></td><td>INSERT</td><td><code>CREATE POLICY "Image Upload Only" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'images' AND storage.extension(name) IN ('png', 'jpg', 'jpeg'));</code></td><td><code>storage.extension()</code> 헬퍼 함수를 사용하여 파일 확장자 기반으로 업로드 제한</td></tr>
</tbody></table>
<h3>6.2  서명된 URL (Signed URLs)</h3>
<p>서명된 URL은 Private 버킷에 저장된 파일에 대해 안전하고 시간 제한적인 접근을 제공하는 메커니즘이다. RLS가 영구적인 규칙 기반의 접근 제어라면, 서명된 URL은 특정 파일에 대한 일회성 또는 단기적인 접근 권한을 동적으로 생성하는 방법이다.</p>
<ul>
<li><strong>다운로드용 서명된 URL (<code>createSignedUrl</code>)</strong>: 이 함수는 Private 버킷의 특정 파일에 대한 다운로드 URL을 생성한다.47</li>
</ul>
<p><code>expiresIn</code> 파라미터를 통해 URL의 유효 시간을 초 단위로 지정할 수 있다(예: <code>60</code>은 1분). 이 URL에는 인증 정보가 포함된 토큰이 포함되어 있어, URL을 가진 사람은 별도의 로그인 없이도 지정된 시간 동안 파일에 접근할 수 있다. 이미지 변환 옵션을 함께 적용하여 서명된 URL을 생성하는 것도 가능하다.48</p>
<ul>
<li><strong>업로드용 서명된 URL (<code>createSignedUploadUrl</code>)</strong>: 이 함수는 특정 경로에 파일을 업로드할 수 있는 권한을 가진 URL을 생성한다.50 이 URL은 2시간 동안 유효하며, 추가적인 인증 헤더 없이도 파일을 업로드할 수 있게 해준다. 이 기능은 클라이언트가 직접 파일을 업로드해야 하지만, 업로드 권한 부여 로직(예: 파일 크기, 유형 검사, 사용자 결제 상태 확인 등)은 안전한 서버 환경(예: Supabase Edge Function)에서 실행하고 싶을 때 매우 유용하다. 서버는 모든 검증을 마친 후, 안전하게 업로드할 수 있는 URL만 클라이언트에 전달한다.23</li>
</ul>
<h3>6.3  접근 제어 모범 사례</h3>
<p>Supabase Storage의 강력한 보안 기능을 올바르게 활용하기 위한 몇 가지 핵심적인 모범 사례는 다음과 같다.</p>
<ol>
<li><strong>최소 권한의 원칙</strong>: 기본적으로 모든 버킷을 Private으로 생성하고, 반드시 공개되어야 하는 자산만 Public 버킷에 저장한다.52</li>
<li><strong>기본 거부 정책</strong>: RLS를 활성화하면 기본적으로 모든 접근이 차단된다. 이 상태에서 시작하여, 필요한 작업(SELECT, INSERT 등)에 대해서만 명시적으로 허용하는 정책을 추가하는 것이 안전하다.</li>
<li><strong>사용자 데이터 격리</strong>: <code>auth.uid()</code>를 폴더 이름이나 파일 메타데이터와 결합하여 사용자가 자신의 데이터에만 접근할 수 있도록 하는 정책을 최우선으로 적용한다.28</li>
<li><strong>서명된 URL의 현명한 사용</strong>: Private 파일에 대한 외부 공유가 필요할 때는 항상 서명된 URL을 사용하고, 가능한 한 짧은 유효 기간을 설정하여 노출 위험을 최소화한다.52</li>
<li><strong>서버 전용 키 보호</strong>: <code>service_role_key</code>는 RLS를 포함한 모든 보안 정책을 우회하는 마스터 키다. 이 키는 절대로 프론트엔드 코드나 클라이언트에 노출되어서는 안 되며, 오직 통제된 서버 환경에서만 사용해야 한다.52</li>
</ol>
<h2>7.  성능 최적화 및 확장성</h2>
<p>애플리케이션이 성장함에 따라 스토리지의 성능과 비용 효율성을 유지하는 것은 매우 중요하다. Supabase Storage는 대용량 파일 처리, 데이터 전송(Egress) 비용 절감, 그리고 RLS 정책 성능 향상을 위한 다양한 최적화 방안을 제공한다.</p>
<h3>7.1  대용량 파일 처리</h3>
<p>유료 플랜 사용자는 최대 500GB 크기의 개별 파일을 업로드할 수 있다.17 이러한 대용량 파일을 안정적으로 처리하기 위해서는 적절한 업로드 방식을 선택하는 것이 필수적이다.</p>
<ul>
<li><strong>클라이언트 측 업로드</strong>: 사용자의 브라우저나 모바일 앱에서 직접 대용량 파일을 업로드할 때는 네트워크 불안정성에 대비할 수 있는 <strong>TUS 기반의 재개 가능한 업로드</strong>를 사용하는 것이 모범 사례다. 이는 업로드 실패 시 처음부터 다시 시작할 필요 없이 중단된 지점부터 이어갈 수 있게 해준다.17</li>
<li><strong>서버 측 업로드</strong>: 서버 환경과 같이 안정적이고 빠른 네트워크가 보장되는 곳에서는 <strong>S3 멀티파트 업로드</strong>를 사용하는 것이 업로드 속도를 극대화하는 데 더 유리할 수 있다.17</li>
<li><strong>스토리지 전용 엔드포인트 사용</strong>: 대용량 파일 업로드 시에는 일반적인 Supabase API 엔드포인트(<code>project-ref.supabase.co</code>) 대신, 스토리지 전용 엔드포인트(<code>project-ref.storage.supabase.co</code>)를 사용해야 한다. 이 엔드포인트는 대용량 파일 처리에 최적화되어 있어 성능 향상을 기대할 수 있다.17</li>
</ul>
<h3>7.2  Egress 비용 절감을 위한 전략</h3>
<p>Egress는 스토리지 비용에서 상당 부분을 차지할 수 있으므로, 이를 최적화하는 것은 비용 관리에 매우 중요하다.54</p>
<ul>
<li><strong>이미지 최적화</strong>: 애플리케이션 트래픽에서 이미지가 차지하는 비중은 매우 높다. Supabase의 이미지 변환 기능을 적극적으로 활용하여 이미지 크기를 줄이고, WebP와 같은 현대적인 포맷으로 자동 변환하여 제공하는 것이 Egress를 줄이는 가장 효과적인 방법 중 하나다.40</li>
<li><strong>적극적인 캐싱 활용</strong>:</li>
<li><strong>Smart CDN</strong>: Smart CDN은 높은 캐시 히트율을 제공하여 오리진 서버로부터의 데이터 전송을 최소화한다. Supabase는 캐시된 Egress에 대해 더 저렴한 요금을 부과하므로, CDN을 최대한 활용하는 것이 비용 절감에 직접적으로 기여한다.17</li>
<li><strong>브라우저 캐시</strong>: 파일 업로드 시 <code>cache-control</code> 헤더 값을 높게 설정하여(예: <code>max-age=31536000</code>), 사용자의 브라우저가 파일을 오랫동안 캐싱하도록 유도할 수 있다. 이를 통해 반복적인 다운로드를 방지하고 Egress를 줄일 수 있다.40</li>
<li><strong>업로드 크기 제한</strong>: 버킷 설정에서 최대 파일 업로드 크기를 합리적인 수준으로 제한하면, 사용자가 불필요하게 큰 파일을 업로드하고 다운로드하여 발생하는 과도한 Egress를 사전에 방지할 수 있다.40</li>
</ul>
<h3>7.3  RLS 정책 및 목록 조회 성능 향상</h3>
<ul>
<li>
<p><strong>RLS 정책 최적화</strong>: <code>storage.objects</code> 테이블에 대한 RLS 정책은 모든 스토리지 접근 시마다 실행되는 SQL 쿼리다. 만약 정책 내에서 다른 테이블과 <code>JOIN</code>을 하거나 복잡한 조건을 검사한다면, 이것이 성능 병목의 원인이 될 수 있다. 정책의 <code>USING</code> 또는 <code>WITH CHECK</code> 절에서 필터링 조건으로 자주 사용되는 컬럼(예: <code>owner_id</code> 또는 <code>metadata</code> JSONB 필드의 특정 키)에 Postgres 인덱스를 생성하면, RLS 정책 실행 속도를 크게 향상시킬 수 있다.3</p>
</li>
<li>
<p><strong>목록 조회 최적화</strong>: 한 버킷이나 폴더 내에 수만 개 이상의 객체가 존재할 경우, Supabase SDK의 기본 <code>list()</code> 메소드 성능이 저하될 수 있다. 이는 <code>list()</code> 메소드가 파일과 폴더 계층 구조를 함께 계산하는 범용적인 쿼리를 실행하기 때문이다.40 만약 애플리케이션이 단순히 파일 목록만 필요하다면, 이 계층 구조 계산을 생략하는 최적화된 Postgres 함수를 직접 생성하고, SDK의 <code>rpc()</code> 메소드를 통해 이 함수를 호출하는 것이 훨씬 빠르다.</p>
<pre><code class="language-SQL">-- 목록 조회를 위한 최적화된 Postgres 함수 예시
create or replace function list_objects(
  bucketid text,
  prefix text,
  limits int default 100,
  offsets int default 0
) returns table (
  name text,
  id uuid,
  updated_at timestamptz,
  created_at timestamptz,
  last_accessed_at timestamptz,
  metadata jsonb
) as $$
begin
  return query
    SELECT
      o.name, o.id, o.updated_at, o.created_at, o.last_accessed_at, o.metadata
    FROM
      storage.objects as o
    WHERE
      o.name like prefix || '%' AND o.bucket_id = bucketid
	ORDER BY
	  o.name ASC
	LIMIT
      limits
    OFFSET
      offsets;
    end;
$$ language plpgsql stable;
</code></pre>
</li>
</ul>
<pre><code>
이 함수를 사용하면 대량의 객체가 있는 경우에도 빠르고 효율적인 페이지네이션 구현이 가능하다.40

## 8.  가격 정책 분석


Supabase Storage의 가격 정책은 예측 가능성과 사용량 기반의 유연성을 결합한 하이브리드 모델을 채택하고 있다. 주요 과금 요소는 스토리지 크기, 데이터 전송량(Egress), 그리고 이미지 변환 횟수다.

### 8.1  과금 요소 상세 분석


- **스토리지 크기 (Storage Size)**: 버킷에 저장된 모든 파일의 총량을 기준으로 과금된다. Supabase는 GB-시간(GB-Hrs)이라는 단위를 사용하는데, 이는 1GB의 데이터를 1시간 동안 저장했을 때 1 GB-Hr가 되는 방식이다.57 월 단위로 환산하면 Pro 플랜 기준으로 월 100GB의 저장 공간이 기본 제공되며, 이를 초과하는 사용량에 대해서는 GB당 약 $0.021의 요금이 부과된다.57

- **데이터 전송량 (Egress)**: Supabase 서버에서 클라이언트로 데이터가 전송될 때 발생하는 트래픽 양을 의미한다. Supabase는 이를 **캐시된(Cached) Egress**와 **캐시되지 않은(Uncached) Egress**로 구분하여 차등 과금하는 것이 특징이다.17

- **Cached Egress**: CDN 엣지 로케이션에서 사용자에게 직접 전달된 데이터에 해당한다. 이는 오리진 서버를 거치지 않으므로 더 저렴하게 책정된다. Pro 플랜 기준으로 월 250GB가 포함되며, 초과 시 GB당 $0.03이다.17
- **Uncached Egress**: CDN에 캐시된 데이터가 없거나 Private 버킷 접근 등으로 인해 오리진 서버에서 직접 사용자에게 전달된 데이터다. Pro 플랜 기준으로 월 250GB가 포함되며, 초과 시 GB당 $0.09로 캐시된 Egress보다 3배 비싸다.17 이 가격 정책은 개발자가 CDN을 적극적으로 활용하도록 유도하는 강력한 동기가 된다.

- **이미지 변환 (Image Transformations)**: 이 과금 방식은 매우 독특하다. 변환 요청 횟수가 아닌, 해당 월에 변환 작업이 한 번이라도 적용된 **고유한 원본 이미지(origin images)의 수**를 기준으로 과금된다.60 예를 들어, 하나의 이미지(

`cat.jpg`)를 가지고 100가지 다른 크기로 변환 요청을 보내도, 과금 대상이 되는 원본 이미지는 1개로 계산된다. Pro 플랜은 월 100개의 고유 원본 이미지 변환을 무료로 제공하며, 이를 초과할 경우 1,000개의 원본 이미지당 $5의 요금이 패키지 단위로 부과된다.33

### 8.2  플랜별 스토리지 가격 정책 비교


| 항목 (Item)                       | Free 플랜 | Pro 플랜               | Team 플랜              |
| --------------------------------- | --------- | ---------------------- | ---------------------- |
| **월 기본료**                     | $0        | $25부터                | $599부터               |
| **스토리지 크기 (포함)**          | 1 GB      | 100 GB                 | 100 GB                 |
| **스토리지 크기 (초과 요금)**     | -         | $0.021 / GB            | $0.021 / GB            |
| **Egress (Uncached) (포함)**      | 5 GB      | 250 GB                 | 250 GB                 |
| **Egress (Uncached) (초과 요금)** | -         | $0.09 / GB             | $0.09 / GB             |
| **Egress (Cached) (포함)**        | 5 GB      | 250 GB                 | 250 GB                 |
| **Egress (Cached) (초과 요금)**   | -         | $0.03 / GB             | $0.03 / GB             |
| **이미지 변환 (포함)**            | 사용 불가 | 100 원본 이미지        | 100 원본 이미지        |
| **이미지 변환 (초과 요금)**       | -         | $5 / 1,000 원본 이미지 | $5 / 1,000 원본 이미지 |
| **최대 파일 크기**                | 50 MB     | 500 GB                 | 500 GB                 |

자료: 58

## 9.  경쟁 서비스 비교 분석


Supabase Storage의 시장 내 위치와 경쟁력을 이해하기 위해, 대표적인 경쟁 서비스인 Firebase Storage와 AWS S3와의 다각적인 비교 분석을 수행한다.

### 9.1  Supabase Storage vs. Firebase Storage


Supabase는 '오픈소스 Firebase 대안'을 표방하며 등장했기 때문에, Firebase Storage와의 비교는 특히 중요하다.

- **아키텍처 및 데이터 모델**: 가장 근본적인 차이점이다. Supabase는 관계형 데이터베이스인 PostgreSQL을 기반으로 하며, 스토리지 메타데이터를 SQL로 직접 다룰 수 있다.65 반면, Firebase Storage는 Google Cloud Storage(GCS)를 기반으로 하는 독립 시스템이며, 데이터베이스로는 NoSQL인 Firestore를 사용한다. 이로 인해 Supabase는 데이터베이스의 다른 테이블과 스토리지 객체 간의 관계를 설정하고

`JOIN`을 통한 복잡한 권한 조회를 수행하는 데 매우 강력하다. Firebase는 이러한 관계형 데이터 처리가 상대적으로 복잡하다.

- **보안 모델**: Supabase의 RLS는 표준 SQL을 사용하여 데이터베이스와 완전히 통합된 보안 정책을 정의한다. 이는 SQL에 익숙한 개발자에게 매우 직관적이고 강력한 제어 기능을 제공한다.66 Firebase Security Rules는 자체적인 JSON과 유사한 문법을 사용하는 별도의 규칙 시스템이다. Firestore 규칙과 Storage 규칙이 분리되어 있으며, 간단한 규칙은 쉽게 작성할 수 있지만 복잡한 비즈니스 로직을 구현할 때는 가독성과 유지보수성이 떨어질 수 있다.67

- **기능 및 가격**: 두 서비스 모두 파일 업로드, 다운로드, CDN, 재개 가능한 업로드 등 핵심 기능을 제공한다. 그러나 Supabase는 이미지 변환 기능을 내장하고 있는 반면, Firebase는 이를 위해 별도의 확장 프로그램(Firebase Extensions)을 설치해야 한다.65 가격 모델에서도 차이가 크다. Supabase는 예측 가능한 월정액 기반의 계층형 요금제를 제공하여 비용 관리가 용이하다.69 Firebase는 저장 공간, 데이터 전송량, 그리고 **작업 횟수(읽기, 쓰기)**에 따라 과금하는 순수 사용량 기반 모델을 채택하고 있어, 트래픽이 급증할 경우 비용이 예기치 않게 크게 증가할 수 있다.65

### 9.2  Supabase Storage vs. AWS S3


AWS S3는 객체 스토리지 시장의 절대 강자이며, Supabase Storage 역시 내부적으로 S3 호환 기술을 사용한다. 둘의 비교는 BaaS와 IaaS의 철학적 차이를 보여준다.

- **추상화 및 개발자 경험**: Supabase는 BaaS(Backend-as-a-Service)로서, 개발자가 인프라를 직접 관리할 필요 없이 빠르게 애플리케이션을 개발할 수 있도록 높은 수준의 추상화를 제공한다. 인증, 데이터베이스 연동, CDN, 이미지 변환 등이 모두 사전 통합되어 있다.71 반면, AWS S3는 IaaS(Infrastructure-as-a-Service)로서, 스토리지 자체의 기능은 매우 강력하고 유연하지만, CDN(CloudFront), 인증(Cognito/IAM), 데이터베이스 연동(RDS/DynamoDB) 등 필요한 모든 주변 서비스를 개발자가 직접 조합하고 구성해야 하는 책임이 따른다.71
- **보안 모델**: Supabase RLS는 애플리케이션의 '사용자' 컨텍스트(예: `auth.uid()`)에 초점을 맞춘다. 이는 웹 및 모바일 앱 개발 시나리오에 매우 직관적이다. AWS S3는 IAM 정책과 버킷 정책을 사용하는데, 이는 AWS의 '리소스'와 '서비스 주체(Principal)'에 대한 저수준의 포괄적인 접근 제어 모델이다.71 IAM은 매우 강력하지만, 애플리케이션 사용자별로 세밀한 권한을 동적으로 제어하기 위해서는 별도의 애플리케이션 로직이나 AWS Cognito와 같은 서비스와의 복잡한 연동이 필요하다.71
- **비용 구조 및 유연성**: 순수한 GB당 저장 비용만 비교하면 AWS S3가 더 저렴할 수 있다. 특히 S3는 Glacier와 같은 다양한 스토리지 클래스와 정교한 수명 주기 정책을 제공하여, 대규모 데이터 아카이빙 등에서 비용을 최적화할 수 있는 유연성이 매우 높다.72 하지만 Supabase는 CDN, API 호출, 이미지 변환, 데이터베이스 연동 등의 가치를 포함한 통합 패키지를 제공하므로, 개발 및 운영 리소스를 포함한 총 소유 비용(TCO) 관점에서 접근해야 한다. 소규모 팀이나 빠른 개발이 중요한 프로젝트에서는 Supabase의 통합된 비용 모델이 더 효율적일 수 있다.

| 구분               | Supabase Storage                                             | Firebase Storage                                  | AWS S3                                                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------------------------------ |
| **기반 기술**      | Postgres (메타데이터) + S3 호환 객체 저장소                  | Google Cloud Storage (GCS)                        | 자체 객체 저장소 인프라                                      |
| **보안 모델**      | Postgres RLS (SQL 기반)                                      | Firebase Security Rules (자체 DSL)                | IAM 정책 &amp; 버킷 정책 (JSON 기반)                             |
| **핵심 장점**      | DB-스토리지 통합 보안, SQL의 강력함, 오픈소스                | 쉬운 시작, Google 생태계 통합, 성숙한 실시간 기능 | 극강의 확장성/내구성, 다양한 스토리지 클래스, 비용 최적화 유연성 |
| **핵심 단점**      | S3 대비 세분화된 관리 기능 부족                              | NoSQL의 한계, 예측 어려운 가격, 벤더 종속성       | 높은 학습 곡선, 복잡한 인프라 구성 필요                      |
| **주요 사용 사례** | 관계형 데이터 기반 앱, 빠른 프로토타이핑, Postgres 중심 백엔드 | 모바일 우선 앱, 실시간 협업 도구, 간단한 CRUD 앱  | 엔터프라이즈 데이터 레이크, 대규모 백업/아카이브, 정적 웹 호스팅 |

## 10.  결론 및 제언


Supabase Storage는 현대적인 애플리케이션 개발 패러다임에 부응하는 강력하고 잘 설계된 객체 스토리지 시스템이다. 단순한 파일 저장소를 넘어, Postgres 데이터베이스와의 심층적인 통합을 통해 독보적인 가치를 창출한다.

### 10.1  핵심 강점 및 약점 요약


- **강점**:
1. **통합된 보안 모델**: Postgres RLS를 스토리지 접근 제어에 직접 활용함으로써, 데이터와 파일에 대한 보안 정책을 하나의 일관된 SQL 기반 모델로 통합 관리할 수 있다. 이는 개발 복잡성을 크게 낮추고 보안성을 강화하는 가장 큰 장점이다.
2. **높은 개발자 생산성**: 인증, CDN, 실시간 이미지 변환 등 필수 기능이 사전 통합된 BaaS 형태로 제공되어, 개발자가 인프라 구성 대신 비즈니스 로직 개발에 집중할 수 있게 한다.
3. **오픈소스 기반의 유연성**: 오픈소스라는 특성은 벤더 종속성을 피하고, 필요 시 자체 호스팅(self-hosting)을 통해 인프라에 대한 완전한 통제권을 가질 수 있는 유연성을 제공한다.
4. **예측 가능한 가격**: 작업 횟수에 따라 과금하지 않고, 저장 공간과 데이터 전송량을 기반으로 한 계층형 요금제는 비용 예측을 용이하게 하여 예산 관리에 유리하다.
- **약점**:
1. **세분화된 관리 기능 부족**: AWS S3가 제공하는 다양한 스토리지 클래스(Glacier, Infrequent Access 등)나 정교한 데이터 수명 주기 관리 정책과 같은 엔터프라이즈급 고급 기능은 아직 부족하다.
2. **성장 중인 생태계**: Firebase나 AWS에 비해 상대적으로 역사가 짧아, 커뮤니티 지원이나 서드파티 통합 도구의 생태계가 아직 성장하는 단계에 있다.

### 10.2  프로젝트 유형 및 요구사항에 따른 활용 전략 제언


- **적극 추천하는 경우**:
- **Postgres 중심의 애플리케이션**: 프로젝트의 주 데이터베이스가 Postgres이며, 데이터베이스의 정보(예: 사용자 역할, 팀 소속, 구독 상태)와 파일 접근 권한이 긴밀하게 연동되어야 하는 경우, Supabase Storage는 타의 추종을 불허하는 시너지를 제공한다.
- **빠른 개발 속도가 중요한 프로젝트**: 스타트업, MVP(최소 기능 제품) 개발, 프로토타이핑 등에서 복잡한 백엔드 인프라 구축 없이 빠르게 스토리지 기능을 구현하고자 할 때 최적의 선택이다.
- **Firebase 대안을 찾는 경우**: Firebase의 NoSQL 데이터 모델이나 예측 불가능한 비용 모델에 한계를 느끼고, 관계형 데이터베이스의 안정성과 SQL의 강력함을 선호하는 팀에게 이상적인 대안이 될 수 있다.
- **신중한 고려가 필요한 경우**:
- **대규모 데이터 아카이빙**: 수 페타바이트(PB) 규모의 데이터를 장기간 저비용으로 보관해야 하는 데이터 아카이빙이나 백업 워크로드의 경우, 다양한 저비용 스토리지 클래스를 제공하는 AWS S3 Glacier가 더 경제적일 수 있다.
- **기존 AWS 인프라 의존도가 높은 경우**: 이미 대부분의 인프라가 AWS에 깊숙이 통합되어 있고, 모든 리소스 접근을 AWS IAM을 통해 중앙에서 엄격하게 관리해야 하는 대규모 엔터프라이즈 환경에서는 기존 생태계와의 일관성을 위해 AWS S3를 유지하는 것이 더 효율적일 수 있다.

### 10.3  최종 제언


결론적으로, Supabase Storage는 **'데이터베이스의 자연스러운 확장'**이라는 관점에서 접근해야 그 진정한 가치를 이해할 수 있다. 이는 단순히 파일을 저장하는 서비스를 넘어, 데이터베이스의 보안과 쿼리 능력을 파일 시스템으로 확장하는 혁신적인 시도다. 따라서 관계형 데이터 모델을 기반으로 하는 현대적인 웹 및 모바일 애플리케이션의 백엔드를 구축하려는 개발자 및 팀에게 Supabase Storage는 생산성, 보안, 그리고 개발 경험 측면에서 매우 강력하고 매력적인 선택지가 될 것이다.

## 11. 참고 자료


1. Supabase Docs, https://supabase.com/docs
2. Storage | Store any digital content - Supabase, https://supabase.com/storage
3. The Storage Schema | Supabase Docs, https://supabase.com/docs/guides/storage/schema/design
4. Self-Hosting Storage - Supabase Docs, https://supabase.com/docs/reference/self-hosting-storage/introduction
5. supabase/storage: S3 compatible object storage service that stores metadata in Postgres, https://github.com/supabase/storage
6. Storage is now available in Supabase, https://supabase.com/blog/supabase-storage
7. Supabase Storage v2: Image Resizing and Smart CDN | Hacker News, https://news.ycombinator.com/item?id=33969076
8. Architecture | Supabase Docs, https://supabase.com/docs/guides/getting-started/architecture
9. Self-Hosting with Docker | Supabase Docs, https://supabase.com/docs/guides/self-hosting/docker
10. Supabase Edge Functions: Introducing Background Tasks, Ephemeral Storage, and WebSockets, https://supabase.com/blog/edge-functions-background-tasks-websockets
11. Storage Buckets | Supabase Docs, https://supabase.com/docs/guides/storage/buckets/fundamentals
12. Supabase Storage v2: Image resizing and Smart CDN, https://supabase.com/blog/storage-image-resizing-smart-cdn
13. Storage | Supabase - Vercel, https://zone-www-dot-9obe9a1tk-supabase.vercel.app/docs/guides/storage
14. Storage Quickstart | Supabase Docs, https://supabase.com/docs/guides/storage/quickstart
15. Supabase storage - Upload a file - WeWeb | Documentation, https://docs.weweb.io/workflows/actions/supabase/storage-upload-file.html
16. Storage CDN | Supabase Docs, https://supabase.com/docs/guides/storage/cdn/fundamentals
17. Storage: 10x Larger Uploads, 3x Cheaper Cached Egress, and 2x Egress Quota - Supabase, https://supabase.com/blog/storage-500gb-uploads-cheaper-egress-pricing
18. Storage | Supabase Docs, https://supabase.com/docs/guides/storage
19. Purpose of Storage : r/Supabase - Reddit, https://www.reddit.com/r/Supabase/comments/1br35x2/purpose_of_storage/
20. Standard Uploads | Supabase Docs, https://supabase.com/docs/guides/storage/uploads/standard-uploads
21. Resumable uploads | Supabase Features, https://supabase.com/features/resumable-uploads
22. Resumable Uploads | Supabase Docs, https://supabase.com/docs/guides/storage/uploads/resumable-uploads
23. Supabase Storage v3: Resumable Uploads with support for 50GB files, https://supabase.com/blog/storage-v3-resumable-uploads
24. Resumable Uploads with Storage v3 - Supabase - YouTube, https://www.youtube.com/watch?v=pT2PcZFq_M0
25. S3 Uploads | Supabase Docs, https://supabase.com/docs/guides/storage/uploads/s3-uploads
26. Supabase Storage: now supports the S3 protocol, https://supabase.com/blog/s3-compatible-storage
27. JavaScript: Upload a file | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-upload
28. Supabase Storage: How to Implement File Upload Properly, https://nikofischer.com/supabase-storage-file-upload-guide
29. JavaScript: Download a file | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-download
30. JavaScript: List all files in a bucket | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-list
31. Supabase select fields from storage file list - javascript - Stack Overflow, https://stackoverflow.com/questions/77113872/supabase-select-fields-from-storage-file-list
32. @supabase/storage-js CDN by jsDelivr - A CDN for npm and GitHub, https://www.jsdelivr.com/package/npm/@supabase/storage-js
33. Storage Image Transformations | Supabase Docs, https://supabase.com/docs/guides/storage/serving/image-transformations
34. Image transformations | Supabase Features, https://supabase.com/features/image-transformations
35. How to resize images on the fly with Supabase - SupabaseTips - YouTube, https://www.youtube.com/watch?v=dLqSmxX3r7I
36. File storage | Supabase Features, https://supabase.com/features/file-storage
37. Content Delivery Network | Supabase Features, https://supabase.com/features/cdn
38. Smart CDN | Supabase Docs, https://supabase.com/docs/guides/storage/cdn/smart-cdn
39. Supabase Storage - Image resizing and Smart CDN - YouTube, https://www.youtube.com/watch?v=NpEl20iuOtg
40. Storage Optimizations | Supabase Docs, https://supabase.com/docs/guides/storage/production/scaling
41. S3 compatibility | Supabase Features, https://supabase.com/features/s3-compatibility
42. A new way to use Supabase Storage - YouTube, https://www.youtube.com/watch?v=WvvGhcNeSPk
43. S3 Authentication | Supabase Docs, https://supabase.com/docs/guides/storage/s3/authentication
44. Row Level Security | Supabase Docs, https://supabase.com/docs/guides/database/postgres/row-level-security
45. Mastering Supabase RLS - "Row Level Security" as a Beginner ..., https://dev.to/asheeshh/mastering-supabase-rls-row-level-security-as-a-beginner-5175
46. [HELP] How do I set up RLS policy for file upload in storage buckets without using Supabase Auth? - Reddit, https://www.reddit.com/r/Supabase/comments/1dlqksf/help_how_do_i_set_up_rls_policy_for_file_upload/
47. JavaScript: Create a signed URL | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-createsignedurl
48. JavaScript: Create signed URLs | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-createsignedurls
49. efficiently get signed urls from buckets - Supabase - Reddit, https://www.reddit.com/r/Supabase/comments/1gv63m0/efficiently_get_signed_urls_from_buckets/
50. JavaScript: Create signed upload URL | Supabase Docs, https://supabase.com/docs/reference/javascript/storage-from-createsigneduploadurl
51. Signed URL file uploads with NextJs and Supabase | by Ollie ..., https://medium.com/@olliedoesdev/signed-url-file-uploads-with-nextjs-and-supabase-74ba91b65fe0
52. Best Security Practices in Supabase: A Comprehensive Guide ..., https://www.supadex.app/blog/best-security-practices-in-supabase-a-comprehensive-guide
53. Securing your data | Supabase Docs, https://supabase.com/docs/guides/database/secure-data
54. Bandwidth &amp; Storage Egress | Supabase Docs, https://supabase.com/docs/guides/storage/serving/bandwidth
55. How should I cache images from supabase buckets to minimize loading times on the front end : r/sveltejs - Reddit, https://www.reddit.com/r/sveltejs/comments/1b53f8l/how_should_i_cache_images_from_supabase_buckets/
56. Query Optimization | Supabase Docs, https://supabase.com/docs/guides/database/query-optimization
57. Manage Storage size usage | Supabase Docs, https://supabase.com/docs/guides/platform/manage-your-usage/storage-size
58. Pricing | Supabase Docs, https://supabase.com/docs/guides/storage/management/pricing
59. Pricing &amp; Fees | Supabase, https://supabase.com/pricing
60. Manage Storage Image Transformations usage | Supabase Docs, https://supabase.com/docs/guides/platform/manage-your-usage/storage-image-transformations
61. Supabase Pricing vs Codehooks: Complete Comparison Guide 2025 - Automations, integrations, and backend APIs made easy, https://codehooks.io/docs/alternatives/supabase-pricing-comparison
62. About billing on Supabase, https://supabase.com/docs/guides/platform/billing-on-supabase
63. Pricing &amp; fees | Supabase - Vercel, https://zone-www-dot-90iilti8a-supabase.vercel.app/pricing
64. Limits | Supabase Docs, https://supabase.com/docs/guides/storage/uploads/file-limits
65. Supabase vs Firebase, https://supabase.com/alternatives/supabase-vs-firebase
66. Firebase vs Supabase: Choosing the Right Backend for Your Web App | UI Bakery Blog, https://uibakery.io/blog/firebase-vs-supabase
67. Supabase vs Firebase in 2025: The Ultimate BaaS Comparison - AnotherWrapper, https://anotherwrapper.com/blog/supabase-vs-firebase
68. Firebase vs Supabase: What are your NEGATIVE experiences or frustrations only? - Reddit, https://www.reddit.com/r/FlutterDev/comments/1mtnr84/firebase_vs_supabase_what_are_your_negative/
69. The Complete Guide to Supabase Pricing Models and Cost Optimization - Flexprice, https://flexprice.io/blog/supabase-pricing-breakdown
70. Firebase Pricing, https://firebase.google.com/pricing
71. Supabase vs AWS: Feature and Pricing Comparison (2025), https://www.bytebase.com/blog/supabase-vs-aws-pricing/
72. S3 Pricing - AWS, https://aws.amazon.com/s3/pricing/
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>