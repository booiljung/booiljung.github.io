<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Supabase와 Python의 통합</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Supabase와 Python의 통합</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">SUPABASE</a> / <span>Supabase와 Python의 통합</span></nav>
                </div>
            </header>
            <article>
                <h1>Supabase와 Python의 통합</h1>
<h2>1.  Supabase와 파이썬 생태계의 통합</h2>
<p>본 안내서는 Supabase 플랫폼을 파이썬 개발 환경에서 활용하는 방안에 대한 심층적 분석을 제공한다. Supabase를 단순한 ’Firebase 대체재’가 아닌, PostgreSQL을 중심으로 한 포괄적인 개발 플랫폼으로 정의하고, 파이썬 생태계와의 기술적 접점을 탐색한다.</p>
<h3>1.1  Supabase 아키텍처 개요: PostgreSQL 기반의 BaaS(Backend-as-a-Service)</h3>
<p>Supabase는 호스팅된 PostgreSQL 데이터베이스를 기반으로 인증, 자동 생성 API, 저장소, 엣지 함수 등 엔터프라이즈급 오픈소스 도구들의 조합으로 구성된 개발 플랫폼이다.1 이는 단순한 데이터베이스 호스팅을 넘어 완전한 백엔드 솔루션을 제공하는 BaaS(Backend-as-a-Service) 모델을 지향한다.</p>
<p>핵심 구성 요소는 다음과 같다.</p>
<ul>
<li>
<p><strong>PostgREST</strong>: PostgreSQL 데이터베이스를 RESTful API로 자동 변환하는 웹 서버이다. <code>supabase-py</code>와 같은 클라이언트 라이브러리가 데이터베이스와 상호작용하는 근간이 된다.1</p>
</li>
<li>
<p><strong>GoTrue</strong>: JWT(JSON Web Token) 기반 인증 API로, 사용자 가입, 로그인, 세션 관리 등 인증 관련 기능을 전담한다.1</p>
</li>
<li>
<p><strong>Realtime</strong>: Elixir로 구축된 서버로, 웹소켓을 통해 PostgreSQL의 내장 복제(replication) 기능을 활용한다. 이를 통해 데이터베이스의 변경 사항(INSERT, UPDATE, DELETE)을 실시간으로 클라이언트에 브로드캐스팅할 수 있다.1</p>
</li>
<li>
<p><strong>Storage</strong>: S3와 호환되는 파일 저장소 API를 제공하여, 파일 업로드, 다운로드, 관리 기능을 담당한다.1</p>
</li>
</ul>
<p>이러한 모듈식 아키텍처는 각 기능이 독립적인 마이크로서비스로 동작함을 의미한다. 파이썬 클라이언트 라이브러리인 <code>supabase-py</code>는 PostgreSQL에 직접 연결되는 데이터베이스 드라이버가 아니라, 이들 마이크로서비스와 HTTP 또는 웹소켓 프로토콜을 통해 통신하는 추상화 계층이다. 이 구조는 개발 편의성을 극대화하고 행 수준 보안(RLS)과 같은 강력한 기능을 자동으로 통합하는 장점을 제공하지만, 동시에 네트워크 통신으로 인한 오버헤드를 내포한다. 이 아키텍처적 특성은 <code>psycopg2</code>와 같은 직접 데이터베이스 드라이버와의 근본적인 차이점을 형성하며, 본 안내서 전체를 관통하는 비교 분석의 핵심 기준점이 된다.</p>
<h3>1.2  <code>supabase-py</code>: 공식 파이썬 클라이언트 라이브러리</h3>
<p><code>supabase-py</code>는 Supabase의 다양한 서비스를 파이썬 애플리케이션에 쉽게 통합하기 위해 제공되는 공식 클라이언트 라이브러리다.4 현재 베타(Beta) 단계에 있으며, 지속적으로 기능이 개선되고 있다.4</p>
<p>이 라이브러리는 단일 패키지가 아닌, 여러 하위 라이브러리를 포함하는 모노레포(monorepo) 구조로 설계되었다.5 주요 구성 요소는 다음과 같다.</p>
<ul>
<li>
<p><code>supabase</code>: 핵심 클라이언트</p>
</li>
<li>
<p><code>supabase_auth</code>: 인증 기능 담당</p>
</li>
<li>
<p><code>storage3</code>: 파일 저장소 기능 담당</p>
</li>
<li>
<p><code>supabase_functions</code>: 엣지 함수 호출 담당</p>
</li>
<li>
<p><code>realtime</code>: 실시간 기능 담당</p>
</li>
</ul>
<p>이러한 구조는 Supabase의 클라이언트 라이브러리 설계 철학이 모듈성에 기반하고 있음을 보여준다. 각 기능이 독립적인 컴포넌트로 개발되어, 전체 패키지를 사용하지 않고 특정 기능만 선택적으로 활용할 수 있는 잠재적 유연성을 제공한다. <code>supabase-py</code>는 PostgreSQL 쿼리, 사용자 인증, 실시간 데이터 스트리밍, 엣지 함수 호출, 파일 저장소 관리 등 Supabase 플랫폼의 거의 모든 기능을 파이썬 환경에서 제어할 수 있도록 지원한다.5</p>
<h3>1.3  초기 설정: 설치, 환경 변수 구성 및 클라이언트 초기화</h3>
<p>Supabase를 파이썬 프로젝트에서 사용하기 위한 초기 설정 과정은 표준적인 파이썬 라이브러리 사용법을 따른다.</p>
<p><strong>설치</strong>: <code>pip</code> 또는 <code>conda</code>와 같은 패키지 관리자를 통해 설치할 수 있다. Python 3.7 이상의 버전이 요구된다.2</p>
<pre><code class="language-Bash">pip install supabase
</code></pre>
<p><strong>환경 변수</strong>: 보안 강화를 위해 Supabase 프로젝트 URL과 API 키(anon public key)를 코드에 직접 하드코딩하는 대신, 환경 변수로 설정하는 것이 강력히 권장된다.2</p>
<pre><code class="language-Bash">export SUPABASE_URL="your-supabase-instance-url"
export SUPABASE_KEY="your-supabase-api-key"
</code></pre>
<p><strong>클라이언트 초기화</strong>: <code>create_client()</code> 메서드를 사용하여 Supabase 클라이언트 인스턴스를 생성한다. 이 인스턴스는 Supabase의 모든 기능에 접근하는 진입점(entrypoint) 역할을 한다.9</p>
<pre><code class="language-Python">import os
from supabase import create_client, Client

url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")
supabase: Client = create_client(url, key)
</code></pre>
<p>또한, <code>ClientOptions</code> 객체를 통해 <code>postgrest_client_timeout</code>, <code>schema</code> 지정 등 클라이언트의 세부 동작을 제어할 수 있는 고급 초기화 옵션도 제공된다.7</p>
<h2>2.  데이터베이스 상호작용: PostgREST API 활용</h2>
<p><code>supabase-py</code>를 통한 데이터베이스 상호작용은 PostgREST API를 파이썬에 최적화된 형태로 추상화한 것이다. 이는 단순한 SQL 실행을 넘어, API 기반 접근법의 특성을 이해하고 활용하는 데 중점을 둔다.</p>
<h3>2.1  기본 CRUD 연산: <code>insert</code>, <code>select</code>, <code>update</code>, <code>delete</code></h3>
<p><code>supabase-py</code>는 직관적인 메서드 체이닝(method chaining) 문법을 제공하여 코드의 가독성과 개발 생산성을 높인다.7 모든 데이터베이스 연산은 <code>.execute()</code> 메서드를 호출하는 시점에 실제 네트워크 요청으로 변환되어 서버로 전송된다.6</p>
<ul>
<li>
<p><strong><code>select()</code></strong>: 테이블의 데이터를 조회한다. 모든 컬럼을 조회하려면 <code>"*"</code>를, 특정 컬럼만 조회하려면 컬럼명을 문자열로 전달한다. Supabase 프로젝트의 기본 설정에 따라 API 요청당 최대 1,000개의 행을 반환하므로, 이보다 많은 데이터를 처리하기 위해서는 <code>range()</code> 메서드를 이용한 페이지네이션 구현이 필수적이다.6</p>
</li>
<li>
<p><strong><code>insert()</code></strong>: 새로운 데이터를 테이블에 삽입한다. 단일 행을 삽입할 때는 딕셔너리(<code>dict</code>)를, 여러 행을 한 번에 삽입(bulk insert)할 때는 딕셔너리의 리스트(<code>list[dict]</code>)를 전달한다.6</p>
</li>
<li>
<p><strong><code>update()</code></strong>: 기존 데이터를 수정한다. 데이터 무결성을 위해 반드시 <code>eq()</code>와 같은 필터 메서드와 함께 사용하여 수정할 행을 명시적으로 지정해야 한다.6</p>
</li>
<li>
<p><strong><code>delete()</code></strong>: 테이블에서 데이터를 삭제한다. <code>update()</code>와 마찬가지로, 필터와 결합하여 특정 행을 지정해야 한다. 만약 테이블에 행 수준 보안(RLS) 정책이 활성화되어 있다면, 현재 사용자가 <code>SELECT</code> 권한을 가진 행에 대해서만 삭제 작업이 허용된다.6</p>
</li>
</ul>
<h3>2.2  고급 쿼리 기법</h3>
<p><code>supabase-py</code>는 PostgREST의 강력한 쿼리 기능을 활용하여 복잡한 데이터 조회를 간결하게 표현할 수 있도록 지원한다.</p>
<ul>
<li>
<p><strong>조인(Join) 및 중첩 쿼리</strong>: 데이터베이스에 외래 키 관계가 설정된 경우, 관련 테이블의 데이터를 중첩된 JSON 형태로 한 번의 요청으로 가져올 수 있다. 예를 들어, <code>select("name, instruments(name)")</code>와 같은 문법을 사용하여 <code>orchestral_sections</code> 테이블과 연관된 <code>instruments</code> 테이블의 <code>name</code>을 함께 조회할 수 있다.6 이는 여러 번의 데이터베이스 쿼리를 단일 API 호출로 대체하여 네트워크 효율성을 높이는 중요한 기능이다.</p>
</li>
<li>
<p><strong>필터링</strong>: <code>eq</code> (equals), <code>gt</code> (greater than), <code>lt</code> (less than), <code>in_</code> (in a list) 등 SQL의 <code>WHERE</code> 절에 해당하는 다양한 필터 메서드를 제공하여 정교한 데이터 필터링을 지원한다.6</p>
</li>
<li>
<p><strong>JSON 데이터 처리</strong>: PostgreSQL의 <code>JSONB</code> 타입 컬럼을 효율적으로 다룰 수 있다. <code>-&gt;</code> 연산자를 문자열 내에 사용하여 JSON 객체 내부의 특정 키 값에 직접 접근하고 조회할 수 있다.6</p>
</li>
</ul>
<p><code>supabase-py</code>의 데이터베이스 관련 메서드들은 PostgREST API의 엔드포인트 및 쿼리 파라미터와 직접적으로 매핑된다. 예를 들어, <code>select('author:author_id(name)')</code>와 같은 별칭(aliasing) 문법은 PostgREST의 리소스 임베딩(resource embedding) 기능을 그대로 활용한 것이다.6 이는 <code>supabase-py</code>가 전통적인 ORM(Object-Relational Mapper)이 아니라, 잘 정의된 REST API를 파이썬 개발자가 쉽게 사용하도록 추상화한 ’API 래퍼(Wrapper)’에 가깝다는 것을 의미한다. 이 관계를 이해하면, <code>supabase-py</code>의 기능적 범위와 한계가 PostgREST에 의해 결정된다는 점을 명확히 알 수 있으며, PostgREST가 지원하지 않는 복잡한 쿼리나 성능 튜닝이 필요할 때 왜 <code>psycopg2</code>와 같은 직접 접근법이 대안으로 고려되어야 하는지에 대한 기술적 근거를 제공한다.</p>
<h3>2.3  PostgreSQL 함수 원격 호출 (RPC)</h3>
<p>데이터베이스에 사전 정의된 PostgreSQL 함수를 <code>rpc()</code> 메서드를 통해 직접 호출할 수 있다.13 이는 복잡한 비즈니스 로직이나 데이터 처리 과정을 데이터베이스 계층에 캡슐화하고, 이를 마치 하나의 API 엔드포인트처럼 애플리케이션에서 호출할 수 있게 해준다. 이 방식은 애플리케이션 코드의 복잡성을 줄이고 데이터베이스의 성능을 최대한 활용하는 데 유용하다.</p>
<pre><code class="language-Python"># 'add_one_each' 라는 PostgreSQL 함수를 배열 인자와 함께 호출
response = supabase.rpc("add_one_each", {"arr": }).execute()
</code></pre>
<h2>3.  사용자 인증 및 권한 관리</h2>
<p>Supabase의 핵심 가치 중 하나는 PostgreSQL의 강력한 행 수준 보안(RLS) 기능과 통합된 사용자 인증 시스템이다. 파이썬 환경에서 이 두 기능을 어떻게 연동하고 활용하는지 분석한다.</p>
<h3>3.1  인증 흐름 구현: 가입, 로그인, 로그아웃</h3>
<p><code>supabase.auth</code> 객체를 통해 Supabase의 모든 인증 기능을 사용할 수 있다.</p>
<ul>
<li>
<p><strong>가입 (<code>sign_up</code>)</strong>: 이메일과 패스워드를 사용하여 새로운 사용자를 생성한다. Supabase 프로젝트 설정에서 ‘이메일 확인(Confirm email)’ 기능이 활성화된 경우, 가입 성공 시 <code>user</code> 객체는 반환되지만 <code>session</code> 객체는 <code>null</code>이 된다. 사용자가 이메일 링크를 클릭하여 인증을 완료해야만 로그인이 가능하다. 비활성화된 경우에는 가입 즉시 <code>session</code> 객체가 반환된다.14</p>
</li>
<li>
<p><strong>로그인 (<code>sign_in_with_password</code>)</strong>: 이메일과 패스워드(또는 전화번호와 패스워드)를 사용하여 기존 사용자를 인증한다. 인증에 성공하면 <code>user</code> 정보와 함께 <code>access_token</code> 및 <code>refresh_token</code>이 포함된 <code>session</code> 객체를 반환한다.15</p>
</li>
<li>
<p><strong>로그아웃 (<code>sign_out</code>)</strong>: 클라이언트 측에 저장된 세션 정보를 무효화하고 JWT를 제거한다. 기본적으로 <code>global</code> 범위로 동작하여, 해당 사용자가 로그인한 모든 기기 및 브라우저 세션을 동시에 종료시킨다.17</p>
</li>
</ul>
<pre><code class="language-Python"># 가입 예시
res = supabase.auth.sign_up({
    "email": "user@example.com",
    "password": "secure-password-123"
})

# 로그인 예시
res = supabase.auth.sign_in_with_password({
    "email": "user@example.com",
    "password": "secure-password-123"
})

# 로그아웃 예시
res = supabase.auth.sign_out()
</code></pre>
<h3>3.2  Row Level Security (RLS)와 <code>supabase-py</code>의 연동 원리</h3>
<p><code>supabase-py</code>의 가장 강력한 특징은 RLS와의 자동화된 연동에 있다. 이 과정은 여러 구성 요소의 상호작용을 통해 투명하게 이루어진다.</p>
<ol>
<li>
<p>사용자가 <code>sign_in_with_password</code>를 통해 로그인하면, <code>supabase-py</code> 클라이언트는 JWT(<code>access_token</code>)를 받아 내부적으로 저장한다.</p>
</li>
<li>
<p>이후 <code>supabase.table(...).select(...)</code>와 같은 데이터베이스 요청이 발생하면, 클라이언트는 자동으로 HTTP <code>Authorization</code> 헤더에 <code>Bearer</code> 형태로 토큰을 포함하여 PostgREST API 서버로 전송한다.19</p>
</li>
<li>
<p>PostgREST 서버는 수신된 JWT의 서명을 Supabase 프로젝트의 비밀 키를 사용해 검증한다.</p>
</li>
<li>
<p>검증이 성공하면, PostgREST는 토큰의 페이로드(payload)에 포함된 사용자 정보(예: <code>sub</code> 클레임의 user ID)를 추출하여 데이터베이스 세션의 특정 변수(예: <code>request.jwt.claims.sub</code>)에 설정한다.</p>
</li>
<li>
<p>PostgreSQL 데이터베이스는 쿼리를 실행하기 전에, 해당 테이블에 정의된 RLS 정책을 평가한다. 이 정책들은 <code>auth.uid()</code>와 같은 Supabase 헬퍼 함수를 사용하여 현재 세션의 사용자 ID에 접근할 수 있다. 예를 들어, <code>CREATE POLICY "..." ON posts FOR SELECT USING (auth.uid() = author_id);</code>와 같은 정책은 현재 요청을 보낸 사용자가 해당 게시물의 작성자인 경우에만 조회를 허용한다.</p>
</li>
</ol>
<p>이러한 메커니즘은 <code>psycopg2</code>와 같은 직접 데이터베이스 드라이버를 사용할 때와 근본적인 차이를 만든다. <code>psycopg2</code>를 사용하면 개발자가 모든 쿼리에 <code>WHERE user_id = %s</code>와 같은 조건을 수동으로 추가하여 데이터 접근을 제어해야 하며, 이는 오류 발생 가능성이 높고 유지보수가 어렵다. 반면, <code>supabase-py</code>를 사용하면 인증과 데이터 접근 제어가 자동화된 파이프라인을 통해 이루어진다. 개발자는 애플리케이션 코드에서 사용자 권한을 일일이 신경 쓸 필요 없이, 데이터베이스에 선언적으로 RLS 정책을 정의하는 데만 집중하면 된다. 이는 단순한 편의성을 넘어, 데이터베이스 엔진 자체가 보안 경계(security boundary) 역할을 하도록 만들어 애플리케이션의 보안 아키텍처를 근본적으로 강화하는 효과를 가져온다.3</p>
<h3>3.3  JWT(JSON Web Tokens) 처리 및 보안 고려사항</h3>
<p>로그인 성공 시 반환되는 <code>access_token</code>은 상태 비저장(stateless) 인증을 위한 핵심 요소인 JWT이다. 이 토큰은 만료 시간(expiry)을 가지며, 만료된 후에는 함께 발급된 <code>refresh_token</code>을 사용하여 새로운 <code>access_token</code>을 발급받아야 한다.7</p>
<p><code>supabase-py</code> 클라이언트는 <code>auto_refresh_token</code> 옵션(기본값 <code>True</code>)을 통해 이 갱신 과정을 자동으로 처리하여 개발자의 부담을 줄여준다.7</p>
<p>JWT의 페이로드는 Base64로 인코딩되어 있을 뿐 암호화되어 있지 않으므로, 주민등록번호와 같은 민감한 개인 정보를 페이로드에 포함해서는 안 된다. JWT의 서명(signature)은 데이터의 기밀성이 아닌, 토큰이 전송 중에 변조되지 않았다는 무결성을 보장하는 역할을 한다.19</p>
<h2>4.  파일 저장소 및 엣지 함수</h2>
<p>데이터베이스 외에 Supabase가 제공하는 핵심 백엔드 기능인 Storage와 Edge Functions를 파이썬 환경에서 활용하는 방법을 탐구한다.</p>
<h3>4.1  Supabase Storage 활용: 버킷(Bucket) 및 객체(Object) 관리</h3>
<p><code>supabase.storage</code> 객체를 통해 파일 저장소 기능에 접근할 수 있다. 먼저 <code>.from_('bucket_name')</code> 메서드를 호출하여 작업할 대상 버킷을 지정한 후, 파일 연산을 수행한다.20</p>
<ul>
<li>
<p><strong>업로드 (<code>upload</code>)</strong>: 로컬 파일을 바이너리 읽기 모드(<code>'rb'</code>)로 열어 Supabase Storage에 업로드한다. <code>file_options</code> 파라미터를 통해 <code>cache-control</code> 헤더를 설정하거나, <code>upsert</code> 옵션을 <code>True</code>로 설정하여 동일한 경로에 파일이 존재할 경우 덮어쓰도록 지정할 수 있다.20</p>
</li>
<li>
<p><strong>다운로드 (<code>download</code>)</strong>: 비공개(private) 버킷에 저장된 파일의 내용을 바이트 형태로 다운로드하여 로컬 파일 시스템에 저장한다. 공개(public) 버킷의 경우, <code>get_public_url</code>로 URL을 받아 직접 요청하는 것이 더 효율적이다. 또한, 이미지 파일의 경우 <code>transform</code> 옵션을 통해 다운로드 시점에 실시간으로 리사이징이나 품질 조정을 적용할 수 있다.20</p>
</li>
<li>
<p><strong>목록 조회 (<code>list</code>)</strong>: 특정 폴더 경로에 있는 파일 및 하위 폴더의 목록을 조회한다. <code>limit</code>, <code>offset</code>, <code>sortBy</code>와 같은 옵션을 사용하여 결과를 정렬하거나 페이지네이션을 구현할 수 있다.20</p>
</li>
</ul>
<h3>4.2  Edge Function 호출(<code>invoke</code>): 파이썬 백엔드와 Deno 런타임의 연동</h3>
<p>Supabase Edge Functions는 Deno/TypeScript 기반의 서버리스 함수로, 전 세계 엣지 로케이션에 분산 배포되어 사용자에게 가까운 곳에서 실행됨으로써 낮은 지연 시간을 제공한다.21</p>
<p>파이썬 애플리케이션에서는 <code>supabase.functions.invoke()</code> 메서드를 사용하여 이러한 엣지 함수를 원격으로 호출할 수 있다.23</p>
<pre><code class="language-Python">response = supabase.functions.invoke(
    "hello-world",  # 호출할 엣지 함수의 이름
    invoke_options={
        "body": {"name": "Functions"},
        "headers": {"my-custom-header": "my-custom-value"}
    }
)
</code></pre>
<p><code>invoke_options</code> 파라미터를 통해 함수에 전달할 <code>body</code> 데이터, 사용자 정의 <code>headers</code>, 그리고 HTTP <code>method</code> 등을 지정할 수 있다. <code>body</code>의 타입에 따라 <code>Content-Type</code> 헤더가 자동으로 추론되어 설정되지만, 필요시 헤더를 직접 명시하여 이 동작을 재정의할 수 있다.23</p>
<p>여기서 중요한 아키텍처적 분리를 인지해야 한다. 파이썬은 엣지 함수의 ’실행 환경(runtime)’이 아니라, Deno 런타임에서 실행되는 함수를 원격으로 ’호출(invoke)’하는 ‘오케스트레이터(orchestrator)’ 역할을 수행한다. 이 구조는 하이브리드 아키텍처 설계를 가능하게 한다. 예를 들어, 파이썬으로 구현된 메인 백엔드 서버가 복잡한 비즈니스 로직을 처리하면서, 지리적으로 분산된 사용자에게 낮은 지연 시간으로 응답해야 하는 특정 작업(예: 이미지 썸네일 생성, 실시간 데이터 처리)은 엣지 함수에 위임할 수 있다. 이처럼 파이썬 백엔드와 Deno 엣지 함수가 각자의 강점을 발휘하며 협력하는 모델을 구축할 수 있다.</p>
<h2>5.  실시간 기능 및 AI/벡터 데이터베이스</h2>
<p>최신 애플리케이션의 핵심 요구사항인 실시간 데이터 동기화와 AI 기반 검색 기능을 파이썬으로 구현하는 방법을 다룬다.</p>
<h3>5.1  실시간 구독: 데이터베이스 변경 사항 리스닝</h3>
<p>Supabase의 실시간 기능은 웹소켓을 기반으로 동작하며, 데이터베이스의 변경 사항을 클라이언트에 즉시 푸시한다.</p>
<ul>
<li><strong>비동기 클라이언트 필수</strong>: 이 기능을 파이썬에서 사용하기 위해서는 반드시 비동기(asynchronous) 방식으로 구현해야 한다. <code>create_client</code> 대신 <code>acreate_client</code>를 사용하여 비동기 클라이언트를 생성하고, <code>asyncio</code> 라이브러리와 함께 <code>async</code>/<code>await</code> 문법을 사용해야 한다.25 이는 동기 방식의 웹 프레임워크(예: Flask, Django의 기본 모드)를 사용 중인 프로젝트에 실시간 기능을 통합하는 것이 아키텍처적으로 큰 변화를 요구함을 의미한다. 실시간 구독을 위해서는 애플리케이션 전체 또는 일부가</li>
</ul>
<p><code>asyncio</code> 이벤트 루프 위에서 동작해야 하며, 이는 FastAPI, Quart, 또는 Django-channels와 같은 비동기 프레임워크 채택을 사실상 강제하는 강력한 기술적 제약 조건이 된다.</p>
<ul>
<li>
<p><strong>구독 메커니즘</strong>: <code>channel()</code> 메서드로 특정 채널에 연결한 후, <code>on_postgres_changes()</code> 메서드를 통해 구독을 설정한다. 이 메서드에서는 감지할 이벤트 타입(INSERT, UPDATE, DELETE, 또는 모든 변경을 의미하는 <code>*</code>), 대상 스키마와 테이블, 그리고 특정 조건을 만족하는 변경 사항만 수신하기 위한 필터(예: <code>id=eq.1</code>)를 지정할 수 있다. 변경 사항이 감지되었을 때 실행될 콜백 함수를 등록하고, 마지막으로 <code>.subscribe()</code>를 호출하여 리스닝을 시작한다.26</p>
<pre><code class="language-Python"># 이 코드는 반드시 비동기 함수 내에서 실행되어야 한다.
import asyncio
from supabase import acreate_client

async def listen_to_changes():
    supabase = await acreate_client(url, key)
    channel = supabase.channel("db-changes")

    def callback(payload):
        print("Change received:", payload)

    await channel.on_postgres_changes(
        event="*", schema="public", table="countries", callback=callback
    ).subscribe()

    # 실제 애플리케이션에서는 무한 루프 등으로 리스닝 상태를 유지해야 한다.
    while True:
        await asyncio.sleep(1)
</code></pre>
</li>
</ul>
<pre><code>
- **Broadcast vs. Postgres Changes**: Supabase는 두 가지 실시간 메커니즘을 제공한다. 'Postgres Changes'는 설정이 간단하여 빠르게 구현할 수 있지만, 데이터베이스 부하가 증가할 수 있어 확장성에 한계가 있다. 반면, 'Broadcast'는 데이터베이스 트리거를 사용하여 명시적으로 메시지를 보내는 방식으로, 더 높은 확장성과 정교한 보안 제어가 가능하다.28

### 5.2  `vecs` 라이브러리를 이용한 벡터 임베딩 관리 (`pgvector` 연동)


Supabase는 `pgvector` PostgreSQL 확장을 통해 벡터 데이터의 저장 및 유사도 검색 기능을 네이티브하게 지원한다. 파이썬에서는 이를 쉽게 사용하기 위한 `vecs`라는 별도의 특화된 클라이언트를 제공한다.29

- **설치**: `pip install vecs`

- **연결**: `vecs` 클라이언트는 PostgREST API를 통하지 않고 데이터베이스에 직접 연결된다. 따라서 `vecs.create_client()`에 Supabase 프로젝트의 PostgreSQL 직접 연결 문자열을 전달하여 클라이언트를 생성해야 한다.29

- **워크플로우**:

1. `get_or_create_collection()`: 벡터를 저장할 컬렉션(내부적으로는 테이블)을 생성한다. 벡터의 차원(dimension) 수를 반드시 지정해야 한다.

2. `upsert()`: `(ID, 벡터, 메타데이터)` 형태의 튜플 리스트를 컬렉션에 삽입하거나 업데이트한다.

3. `query()`: 기준이 되는 쿼리 벡터를 전달하여 코사인 유사도(cosine similarity) 또는 다른 거리 측정법을 기준으로 가장 유사한 벡터들을 검색한다. `limit`으로 반환 개수를 제한하고, `filters`로 메타데이터를 기준으로 사전 필터링할 수 있다.


```Python
import vecs

# Supabase 프로젝트의 DB 직접 연결 문자열 사용
DB_CONNECTION = "postgresql://postgres:@..."
vx = vecs.create_client(DB_CONNECTION)

# 1536 차원의 벡터 컬렉션 생성 (예: OpenAI의 text-embedding-ada-002)
docs = vx.get_or_create_collection(name="documents", dimension=1536)

# 데이터 삽입
docs.upsert(
    vectors=[
        ("doc1", [0.1, 0.2,..., 0.9], {"source": "report.pdf"}),
        ("doc2", [0.4, 0.5,..., 0.6], {"source": "manual.txt"})
    ]
)

# 유사도 검색
results = docs.query(
    data=[0.1, 0.2,..., 0.8], # 쿼리 벡터
    limit=5,
    filters={"source": {"$eq": "report.pdf"}}
)
</code></pre>
<p>이처럼 Supabase의 AI/벡터 기능은 두 개의 다른 클라이언트(<code>supabase-py</code>와 <code>vecs</code>)를 통해 접근하는 이원적 구조를 가진다. 일반적인 데이터베이스 작업은 PostgREST API를 통하는 <code>supabase-py</code>를 사용하고, 벡터 연산은 데이터베이스에 직접 연결하는 <code>vecs</code>를 사용한다. 이는 벡터 연산의 성능을 최적화하기 위한 의도적인 설계 결정으로 보이지만, 개발자에게는 두 종류의 클라이언트와 두 가지 연결 방식을 관리해야 하는 추가적인 복잡성을 부여한다. 따라서 AI 기반 애플리케이션을 구축할 때는 이 두 클라이언트를 어떻게 조화롭게 통합할 것인지에 대한 아키텍처적 고려가 선행되어야 한다.</p>
<h2>6.  직접 연결 방식과 클라이언트 라이브러리 비교 분석</h2>
<p>Supabase의 PostgreSQL 데이터베이스에 접근하는 두 가지 주요 방법론, 즉 <code>supabase-py</code> 클라이언트 라이브러리와 <code>psycopg2</code>와 같은 표준 데이터베이스 드라이버를 사용하는 방식을 심층적으로 비교 분석하여, 각 접근법의 장단점과 기술적 트레이드오프를 명확히 한다.</p>
<h3>6.1  <code>psycopg2</code>를 이용한 직접 PostgreSQL 연결</h3>
<p><code>psycopg2</code>는 파이썬 생태계에서 가장 널리 사용되는 성숙하고 안정적인 PostgreSQL 데이터베이스 어댑터다.31 Supabase는 표준 PostgreSQL이므로,</p>
<p><code>psycopg2</code>를 사용하여 직접 연결하고 모든 SQL 기능을 제약 없이 사용할 수 있다.</p>
<ul>
<li>
<p><strong>연결</strong>: Supabase 프로젝트 대시보드의 ‘Database’ 설정 페이지에서 제공하는 연결 문자열(Connection String)을 사용하여 연결 객체를 생성한다.33</p>
<pre><code class="language-Python">import psycopg2

# Supabase 대시보드에서 제공하는 연결 풀러(Session)의 연결 문자열 사용
CONNECTION_STRING = "postgres://postgres.[project_ref]:@aws-0-[region].pooler.supabase.com:5432/postgres"

try:
    conn = psycopg2.connect(CONNECTION_STRING)
    cur = conn.cursor()
    cur.execute("SELECT version();")
    db_version = cur.fetchone()
    print(f"Database version: {db_version}")
    cur.close()
except (Exception, psycopg2.DatabaseError) as error:
    print(error)
finally:
    if conn is not None:
        conn.close()
</code></pre>
</li>
</ul>
<pre><code>
- **주요 고려사항**:

- **연결 풀러(Connection Pooler)**: 서버리스 함수와 같이 수많은 단기 연결이 빈번하게 발생하는 환경에서는 데이터베이스에 직접 연결(`Direct connection`)하는 것이 비효율적이다. PostgreSQL의 연결 생성 비용은 상대적으로 높기 때문이다.33 Supabase는 이를 해결하기 위해

`Supavisor`라는 고성능 연결 풀러를 제공하며, 대부분의 사용 사례에서 직접 연결 대신 연결 풀러를 사용하는 것이 필수적이다.33 특히 Google Colab과 같이 IPv6를 지원하지 않는 클라이언트 환경에서는 IPv4를 지원하는 세션 풀러(Session pooler) 사용이 강제된다.30

- **연결 문제**: 일부 사용자 보고에 따르면, 데이터베이스 암호에 `@`와 같은 특정 특수문자가 포함될 경우 인증 오류가 발생할 수 있다.35 또한, 클라이언트의 네트워크 환경이 IPv6를 우선적으로 시도할 경우, IPv4만 지원하는 직접 연결 엔드포인트에 접속하지 못하는 문제가 발생할 수 있다.36

### 6.2  `supabase-py` vs. `psycopg2`: 심층 비교


어떤 연결 방식을 선택하는지는 단순한 코딩 스타일의 문제가 아니라, 프로젝트의 아키텍처, 보안 모델, 개발 속도, 그리고 확장성에 직접적인 영향을 미치는 중요한 결정이다.

두 접근법의 선택은 '보안 경계(Security Boundary)'를 어디에 둘 것인가에 대한 근본적인 아키텍처적 결정과 맞닿아 있다. `supabase-py`를 사용한다는 것은 보안의 책임을 Supabase 플랫폼(GoTrue 인증, PostgREST API 게이트웨이, RLS 정책 엔진)에 위임하는 것을 의미한다. JWT와 RLS의 자동 연동 덕분에 데이터베이스 자체가 강력한 보안 경계가 된다. 반면, `psycopg2`를 사용하면 보안 경계가 애플리케이션 서버로 이동한다. 즉, 파이썬 코드가 사용자를 인증하고, 해당 사용자의 권한에 맞는 SQL 쿼리를 '안전하게' 생성하고 실행할 책임을 모두 져야 한다. 이는 프로젝트의 보안 요구사항과 팀의 전문성에 따라 신중하게 결정해야 할 가장 중요한 트레이드오프다.

다음 표는 두 접근법의 핵심적인 차이점을 요약한다.

| 평가 기준        | `supabase-py` (클라이언트 라이브러리)                                    | `psycopg2` (직접 연결)                                                     |
| ------------ | -------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **추상화 수준**   | 높음 (Supabase 서비스에 최적화된 HTTP API 제공)                            | 낮음 (PostgreSQL 프로토콜을 통한 표준 SQL 실행)                                     |
| **주요 기능**    | CRUD, Auth, Storage, Realtime, Edge Functions 등 플랫폼 전체 기능 통합 5 | 순수 데이터베이스 연산 (모든 SQL 기능 지원) 31                                         |
| **보안 (RLS)** | 인증된 사용자의 JWT를 통해 **자동으로 RLS 정책 적용** 3                          | RLS 정책을 활용하려면 `SET ROLE` 등 **수동 설정이 필요**하며, 애플리케이션 레벨에서 보안 로직 구현 책임이 큼 |
| **사용 편의성**   | 높음 (직관적인 메서드 체이닝, SQL 비전문가도 사용 용이) 7                           | 중간 (SQL 구문, 커넥션 및 트랜잭션 관리에 대한 명시적 이해 필요) 39                            |
| **성능**       | PostgREST API를 통한 **HTTP 오버헤드** 존재. 네트워크 지연 시간에 영향 받음 41       | 데이터베이스에 직접 TCP 연결. 잠재적으로 **더 낮은 지연 시간**과 높은 처리량                        |
| **유연성**      | PostgREST가 노출하는 API 기능 내에서 높은 유연성.                             | 모든 종류의 SQL 쿼리, 데이터베이스 관리 명령어 등 **최고 수준의 유연성** 제공 35                    |
| **플랫폼 종속성**  | Supabase 생태계에 강하게 결합됨.                                         | 표준 PostgreSQL이므로 다른 PostgreSQL 호스팅으로 이전 용이.                            |

## 7.  결론: 아키텍처 설계 및 최적화 전략


지금까지의 분석을 종합하여, 실제 파이썬 프로젝트에서 Supabase를 활용할 때 어떤 접근법을 선택하고 어떻게 최적화할지에 대한 구체적이고 실행 가능한 가이드라인을 제시한다.

### 7.1  사용 사례별 최적 접근법 선택 가이드


**`supabase-py`가 적합한 경우**:

- 사용자 인증, 소셜 로그인, 권한 관리가 핵심 기능인 웹/모바일 애플리케이션의 백엔드를 구축할 때.

- 빠른 프로토타이핑 및 MVP(Minimum Viable Product) 개발을 통해 시장 검증 속도를 높이고자 할 때.

- 프론트엔드 개발자가 백엔드 인프라 관리 부담 없이 풀스택 애플리케이션을 구축하고자 할 때.

- 행 수준 보안(RLS)을 핵심 보안 모델로 채택하여 데이터 접근 제어 로직을 애플리케이션 코드에서 분리하고 데이터베이스 계층에서 중앙 관리하고 싶을 때.

**`psycopg2` (또는 SQLAlchemy 등)가 적합한 경우**:

- 사용자 인증과 무관한 내부 데이터 처리 파이프라인, ETL(Extract, Transform, Load) 배치 작업을 구현할 때.

- 대규모 데이터 마이그레이션 또는 고성능 벌크 연산이 필요할 때.

- PostgREST API로는 표현하기 어려운 복잡한 분석 쿼리, CTE(Common Table Expressions), 윈도우 함수 등을 실행해야 할 때.

- 데이터베이스 스키마 마이그레이션, 인덱스 관리, 역할(role) 관리 등 데이터베이스 관리 스크립트를 실행할 때.

- Supabase를 순수 관리형 PostgreSQL 데이터베이스로만 사용하고, 인증 및 API 로직은 FastAPI나 Django 등을 통해 자체적으로 완전히 구축하는 아키텍처를 선택할 때.3

### 7.2  하이브리드 접근법: 두 방식의 공존


실제 복잡한 애플리케이션에서는 하나의 접근법만을 고수하기보다, 두 방식의 장점을 모두 활용하는 하이브리드 접근법이 가장 현실적이고 효율적인 전략일 수 있다.

예를 들어, 사용자 요청을 직접 처리하는 API 서버는 `supabase-py`를 사용하여 RLS의 이점을 통한 안전하고 빠른 개발을 지향한다. 동시에, 백그라운드에서 주기적으로 실행되는 데이터 집계 및 분석 작업이나, 외부 데이터 소스와의 동기화 파이프라인은 `psycopg2`를 사용하여 데이터베이스에 직접 연결함으로써 높은 성능과 SQL의 완전한 유연성을 확보할 수 있다. 이처럼 각 컴포넌트의 요구사항에 맞춰 최적의 도구를 선택하는 것이 성숙한 아키텍처 설계의 핵심이다.

### 7.3  최종 권고 사항


- **보안 우선 원칙**: 사용자 데이터를 다루는 모든 애플리케이션에서는 특별한 이유가 없는 한, RLS의 강력한 보안 모델을 자동으로 활용할 수 있는 `supabase-py`를 기본 접근법으로 채택할 것을 권장한다. 보안은 나중에 추가하는 기능이 아니라, 설계 단계에서부터 고려되어야 할 최우선 과제이다.

- **성능 병목 식별**: `supabase-py` 사용 중 성능 문제가 발생했다면, 무조건 `psycopg2`로 전환하기 전에 병목의 원인을 정확히 진단해야 한다. 문제의 원인이 비효율적인 쿼리라면 데이터베이스 인덱싱을 통해 해결할 수 있고, 복잡한 로직이 문제라면 해당 로직을 PostgreSQL 함수로 이전하여 RPC로 호출하는 것이 더 나은 해결책일 수 있다. HTTP 오버헤드 자체가 병목의 명확한 원인일 때 직접 연결로의 전환을 고려해야 한다.

- **플랫폼에 대한 깊은 이해**: Supabase는 단순한 도구 모음이 아닌, 각 구성 요소가 유기적으로 연결된 통합 플랫폼이다. `supabase-py`를 효과적으로 사용하기 위해서는 그 기저에 있는 PostgREST, GoTrue, Realtime 서버의 동작 원리와 제약 사항을 이해하는 것이 필수적이다. 플랫폼에 대한 깊은 이해는 문제 해결 능력을 향상시키고, Supabase의 잠재력을 최대한으로 이끌어내는 데 도움이 될 것이다.

## 8. 참고 자료


1. The Postgres development platform. Supabase gives you a dedicated Postgres database to build your web, mobile, and AI applications. - GitHub, https://github.com/supabase/supabase
2. Harnessing the Power of Supabase in Python with supabase-py | by Rohit Verma - Medium, https://medium.com/@rohitverma_69543/harnessing-the-power-of-supabase-in-python-with-supabase-py-03f36a97c482
3. Are some of you using Supabase just for the managed postgres DB + Auth ? What's your experience - Reddit, https://www.reddit.com/r/Supabase/comments/165aju1/are_some_of_you_using_supabase_just_for_the/
4. Client Library - Python | Supabase Features, https://supabase.com/features/client-library-python
5. Python Client for Supabase. Query Postgres from Flask, Django, FastAPI. Python user authentication, security policies, edge functions, file storage, and realtime data streaming. Good first issue. - GitHub, https://github.com/supabase/supabase-py
6. Python: Introduction | Supabase Docs, https://supabase.com/docs/reference/python/introduction
7. Supabase Python Client - Introduction - Vercel, https://docs-hhahn5n6u-supabase.vercel.app/docs/reference/python/introduction
8. Python data loading with Supabase, https://supabase.com/blog/loading-data-supabase-python
9. Python: Initializing | Supabase Docs, https://supabase.com/docs/reference/python/initializing
10. Introduction to Supabase: Postgres Database using Python - Analytics Vidhya, https://www.analyticsvidhya.com/blog/2022/07/introduction-to-supabase-postgres-database-using-python/
11. Supabase(Postgresql) journey with Python | by Summer - Medium, https://medium.com/@summer12126/supabase-postgres-journey-with-python-1789e8bbb53c
12. Client Libraries | Supabase Docs, https://supabase.com/docs/guides/api/rest/client-libs
13. Python: Call a Postgres function | Supabase Docs, https://supabase.com/docs/reference/python/rpc
14. Python: Create a new user | Supabase Docs, https://supabase.com/docs/reference/python/auth-signup
15. Password-based Auth | Supabase Docs, https://supabase.com/docs/guides/auth/passwords
16. Python: Sign in a user | Supabase Docs, https://supabase.com/docs/reference/python/auth-signinwithpassword
17. Python: Sign out a user | Supabase Docs, https://supabase.com/docs/reference/python/auth-signout
18. Signing out | Supabase Docs, https://supabase.com/docs/guides/auth/signout
19. A guide to using Python with Supabase securely - Zohaib, https://zohaib.me/using-python-edge-functions-with-supabase-securely/
20. Python: Create a bucket | Supabase Docs, https://supabase.com/docs/reference/python/storage-createbucket
21. Edge Functions | Supabase Docs, https://supabase.com/docs/guides/functions
22. Getting Started with Edge Functions | Supabase Docs, https://supabase.com/docs/guides/functions/quickstart
23. Python: Invokes a Supabase Edge Function. | Supabase Docs, https://supabase.com/docs/reference/python/functions-invoke
24. JavaScript: Invokes a Supabase Edge Function., https://supabase.com/docs/reference/javascript/functions-invoke
25. Python: Overview | Supabase Docs, https://supabase.com/docs/reference/python/realtime-api
26. Python: Subscribe to channel | Supabase Docs, https://supabase.com/docs/reference/python/subscribe
27. supabase/realtime-py: A Python Client for Phoenix Channels - GitHub, https://github.com/supabase-community/realtime-py
28. Subscribing to Database Changes | Supabase Docs, https://supabase.com/docs/guides/realtime/subscribing-to-database-changes
29. Python client | Supabase Docs, https://supabase.com/docs/guides/ai/vecs-python-client
30. Creating and managing collections | Supabase Docs, https://supabase.com/docs/guides/ai/quickstarts/hello-world
31. psycopg2 - PyPI, https://pypi.org/project/psycopg2/
32. Using psycopg2 with PostgreSQL, https://wiki.postgresql.org/wiki/Using_psycopg2_with_PostgreSQL
33. Connect to your database | Supabase Docs, https://supabase.com/docs/guides/database/connecting-to-postgres
34. Postgres Connection Setup Help? (supabase) - Getting Started - Make Community, https://community.make.com/t/postgres-connection-setup-help-supabase/41171
35. Could not connect to Supabase from Python with psycopg2 · Issue #33519 - GitHub, https://github.com/supabase/supabase/issues/33519
36. supabase postgres accepting TCP/IP connections error - Reddit, https://www.reddit.com/r/Supabase/comments/1ii85pe/supabase_postgres_accepting_tcpip_connections/
37. My Database Conundrum: MongoDB vs Supabase for a Pure Python App - DEV Community, https://dev.to/lfariaus/my-database-conundrum-mongodb-vs-supabase-for-a-pure-python-app-3cfn
38. SQLAlchemy or psycopg2? - python - Stack Overflow, https://stackoverflow.com/questions/8588126/sqlalchemy-or-psycopg2
39. Managing PostgreSQL Databases in Python with psycopg2 - DataCamp, https://www.datacamp.com/tutorial/tutorial-postgresql-python
40. PostgreSQL in Python Using Psycopg2 - Earthly Blog, https://earthly.dev/blog/psycopg2-postgres-python/
41. Supabase Python, https://supabase.com/blog/python-support
42. Connecting to Supabase vs directly to Postgres - Reddit, https://www.reddit.com/r/Supabase/comments/14tdzpk/connecting_to_supabase_vs_directly_to_postgres/
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>