<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Flutter와 Supabase를 활용한 사용자 인증 시스템 구축</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Flutter와 Supabase를 활용한 사용자 인증 시스템 구축</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">SUPABASE</a> / <span>Flutter와 Supabase를 활용한 사용자 인증 시스템 구축</span></nav>
                </div>
            </header>
            <article>
                <h1>Flutter와 Supabase를 활용한 사용자 인증 시스템 구축</h1>
<h2>1. 서론</h2>
<p>Flutter는 단일 코드베이스로 미려한 크로스플랫폼 애플리케이션을 제작할 수 있는 강력한 UI 툴킷이며, Supabase는 PostgreSQL 데이터베이스를 중심으로 인증, 스토리지, 엣지 함수 등 엔터프라이즈급 기능을 제공하는 오픈소스 BaaS(Backend-as-a-Service) 플랫폼이다.1 이 두 기술의 결합은 개발자에게 놀라운 개발 효율성과 확장성을 제공하며, 현대적인 애플리케이션 개발의 새로운 표준을 제시한다.</p>
<p>애플리케이션의 핵심 기능 중 하나는 사용자 인증 시스템이다. 인증(Authentication)은 사용자가 자신이 누구라고 주장하는 바를 증명하는 과정이며, 인가(Authorization)는 인증된 사용자가 특정 리소스나 데이터에 접근할 권한이 있는지를 확인하는 과정이다.3 이 안내서는 사용자 인증의 가장 기본적이면서도 필수적인 형태인 이메일과 비밀번호 기반의 계정 등록 및 로그인 기능 구현에 초점을 맞춘다.</p>
<p>본 안내서의 목표는 Supabase 프로젝트 설정부터 Flutter 클라이언트 연동, 핵심 인증 로직의 상세 분석, 반응형 상태 관리를 통한 UI 구현, 그리고 데이터베이스 보안과의 연계에 이르기까지, 실제 프로덕션 환경에 적용 가능한 수준의 심층적인 기술 가이드를 제공하는 것이다. 이를 통해 개발자는 단순히 기능을 구현하는 것을 넘어, 견고하고 안전하며 유지보수 가능한 인증 아키텍처를 설계하는 능력을 갖추게 될 것이다.</p>
<h2>2. 부: 환경 설정 및 초기화</h2>
<p>견고한 인증 시스템을 구축하기 위한 첫 단계는 백엔드와 클라이언트 양쪽의 환경을 정확하게 설정하고 초기화하는 것이다. 이 과정은 애플리케이션의 안정성과 보안의 기초를 다진다.</p>
<h3>2.1  Supabase 프로젝트 생성 및 구성</h3>
<p>모든 Supabase 연동은 Supabase 대시보드에서 프로젝트를 생성하는 것으로 시작한다.</p>
<ol>
<li>
<p><strong>프로젝트 생성</strong>: Supabase 공식 웹사이트에 로그인한 후, ‘New Project’ 버튼을 클릭하여 새 프로젝트를 생성한다. 프로젝트 이름, 데이터베이스 비밀번호, 리전 등을 설정하면 몇 분 내에 전용 PostgreSQL 데이터베이스와 API 엔드포인트가 준비된다.4</p>
</li>
<li>
<p><strong>API 키 확인</strong>: 프로젝트 생성이 완료되면, 대시보드의 <code>Project Settings</code> &gt; <code>API</code> 탭으로 이동한다. 이곳에서 Flutter 애플리케이션 연동에 필요한 두 가지 핵심 정보인 <code>Project URL</code>과 <code>anon key</code>를 확인할 수 있다.4</p>
</li>
</ol>
<ul>
<li>
<p><code>Project URL</code>: Supabase 백엔드의 고유한 API 엔드포인트 주소다.</p>
</li>
<li>
<p><code>anon key</code>: ’anonymous key’의 약자로, 클라이언트 측 코드에 안전하게 노출될 수 있는 공개 키다. 이 키 자체는 데이터에 대한 어떠한 권한도 부여하지 않는다. 실제 데이터 접근 권한은 후술할 RLS(Row Level Security) 정책과 사용자가 로그인 후 발급받는 JWT(JSON Web Token)에 의해 결정된다.</p>
</li>
</ul>
<ol start="3">
<li><strong>개발 편의성을 위한 초기 설정</strong>: 개발 초기 단계에서는 빠른 테스트와 반복을 위해 이메일 확인 절차를 생략하는 것이 효율적일 수 있다. Supabase 대시보드의 <code>Authentication</code> &gt; <code>Providers</code> &gt; <code>Email</code> 섹션으로 이동하여 ‘Confirm email’ 옵션을 비활성화한다. 이렇게 설정하면 사용자가 회원가입을 하는 즉시 별도의 이메일 인증 없이 로그인 상태가 되어 개발 흐름을 가속화할 수 있다.5 단, 이는 개발 단계에서만 권장되며, 프로덕션 환경으로 전환하기 전에는 보안을 위해 반드시 다시 활성화해야 한다.</li>
</ol>
<h3>2.2  Flutter 프로젝트 설정 및 <code>supabase_flutter</code> 연동</h3>
<p>Supabase 백엔드가 준비되었다면, 이제 Flutter 클라이언트를 설정하고 연동할 차례다.</p>
<ol>
<li>
<p><strong>Flutter 프로젝트 생성</strong>: 터미널에서 다음 명령어를 실행하여 새로운 Flutter 프로젝트를 생성한다.</p>
<pre><code class="language-Bash">flutter create my_auth_app
</code></pre>
</li>
</ol>
<pre><code>
2. **`supabase_flutter` 패키지 추가**: Supabase와의 통신을 용이하게 해주는 공식 패키지 `supabase_flutter`를 프로젝트에 추가한다.

   ```Bash
   flutter pub add supabase_flutter
</code></pre>
<p>이 명령어는 <code>pubspec.yaml</code> 파일에 해당 의존성을 자동으로 추가하고 패키지를 다운로드한다.4</p>
<ol start="3">
<li>
<p><strong>Supabase 클라이언트 초기화</strong>: 애플리케이션의 진입점인 <code>main.dart</code> 파일에서 <code>runApp()</code> 함수가 호출되기 전에 Supabase 클라이언트를 비동기적으로 초기화해야 한다. 이 과정은 앱의 전체 생명주기 동안 단 한 번만 수행되어야 한다.2</p>
<pre><code class="language-Dart">// main.dart
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

Future&lt;void&gt; main() async {
 // Flutter 엔진과 위젯 트리를 바인딩한다. 비동기 메소드를 main에서 호출하기 위해 필수적이다.
 WidgetsFlutterBinding.ensureInitialized();

 // Supabase 클라이언트를 초기화한다.
 await Supabase.initialize(
   url: 'YOUR_SUPABASE_URL',       // 1.1 단계에서 확인한 Project URL
   anonKey: 'YOUR_SUPABASE_ANON_KEY', // 1.1 단계에서 확인한 anon key
 );

 runApp(const MyApp());
}

//... MyApp 위젯 정의...
</code></pre>
</li>
</ol>
<pre><code>
4. **클라이언트 인스턴스 접근**: 초기화가 완료되면, 앱의 어느 곳에서든 `Supabase.instance.client`를 통해 싱글톤(Singleton)으로 관리되는 Supabase 클라이언트 인스턴스에 접근할 수 있다. 이는 API 호출의 일관성을 보장하고 상태 관리를 단순화한다.2

이 `main()` 함수에서의 초기화 과정은 단순히 API 키를 설정하는 행위를 넘어선다. `Supabase.initialize()`가 호출될 때, `supabase_flutter` 패키지는 내부적으로 로컬 스토리지(예: `shared_preferences`)에서 이전에 저장된 사용자 세션 정보를 불러오려고 시도한다. 또한, 인증 상태의 변화를 감지하는 핵심 스트림인 `onAuthStateChange`를 활성화할 준비를 마친다. 따라서 이 초기화 코드가 앱의 위젯 렌더링 이전에 반드시 실행되어야만, 앱의 첫 화면(주로 스플래시 스크린)이 사용자의 로그인 상태를 정확하게 파악하고 그에 따라 홈 화면이나 로그인 화면으로 올바르게 리디렉션하는 로직이 안정적으로 동작할 수 있다. 즉, 이 초기화 단계는 앱 전체의 인증 상태 관리 시스템을 부트스트래핑하는 핵심적인 과정이며, 이후에 이어질 모든 인증 관련 로직의 신뢰성을 담보하는 기반이 된다.

## 3. 부: 핵심 인증 로직 구현


환경 설정이 완료되었으므로, 이제 사용자 인증의 핵심 기능인 계정 등록과 로그인을 구현할 차례다. Supabase는 직관적인 API를 제공하여 이 과정을 간소화한다.

### 3.1  계정 등록 (`signUp`) 기능 상세 분석


`supabase.auth.signUp()` 메소드는 새로운 사용자를 시스템에 등록하는 역할을 한다.

- **기본 사용법**: 이 메소드는 `email`과 `password`를 필수 파라미터로 요구한다.2

- **메타데이터 추가**: `data` 파라미터를 사용하면 회원가입 시점에 추가적인 사용자 정보를 함께 저장할 수 있다. 이 정보는 `auth.users` 테이블의 `raw_user_meta_data`라는 `JSONB` 타입의 컬럼에 저장된다. 이는 사용자 이름, 프로필 사진 URL 등 확장된 프로필 정보를 관리하는 데 매우 유용하다.2

  ```Dart
  // supabase 클라이언트 인스턴스
  final supabase = Supabase.instance.client;
  
  Future&lt;void&gt; signUpUser({
    required String email,
    required String password,
    required String username,
  }) async {
    final AuthResponse response = await supabase.auth.signUp(
      email: email,
      password: password,
      data: {'username': username}, // 사용자 메타데이터 전달
    );
    // 응답 처리 로직 (후술)
  }
</code></pre>
<ul>
<li>
<p><strong><code>AuthResponse</code> 객체 분석</strong>: <code>signUp</code> 메소드는 <code>AuthResponse</code> 객체를 반환한다. 이 객체의 내용은 Supabase 프로젝트의 이메일 확인 설정에 따라 달라진다.</p>
</li>
<li>
<p><strong>이메일 확인 비활성화 시</strong>: <code>response.user</code>와 <code>response.session</code>이 모두 유효한 값을 가지게 된다. 즉, 사용자는 가입 즉시 로그인 상태가 된다.</p>
</li>
<li>
<p><strong>이메일 확인 활성화 시</strong>: <code>response.user</code> 객체는 생성되지만, <code>response.session</code>은 <code>null</code>이 된다. 이는 사용자가 생성되었으나, 이메일의 확인 링크를 클릭하기 전까지는 유효한 세션이 발급되지 않음을 의미한다. 이 차이점을 명확히 인지하고 UI/UX 흐름을 설계해야 한다.2</p>
</li>
</ul>
<h3>3.2  로그인 (<code>signInWithPassword</code>) 기능 상세 분석</h3>
<p><code>supabase.auth.signInWithPassword()</code> 메소드는 이미 등록된 사용자의 자격 증명을 확인하여 인증을 수행한다.</p>
<ul>
<li>
<p><strong>사용법</strong>: 이메일과 비밀번호를 파라미터로 전달하여 호출한다.6</p>
<pre><code class="language-Dart">Future&lt;void&gt; signInUser({
  required String email,
  required String password,
}) async {
  final AuthResponse response = await supabase.auth.signInWithPassword(
    email: email,
    password: password,
  );
  // 응답 처리 로직
}
</code></pre>
</li>
</ul>
<pre><code>
- **성공 응답 분석**: 로그인이 성공하면, 반환된 `AuthResponse` 객체는 유효한 `Session`과 `User` 정보를 포함한다. `Session` 객체는 인증 시스템의 핵심 요소들을 담고 있다.9

- `access_token`: 실제 API 요청 시 사용자를 식별하는 데 사용되는 JWT다. `supabase_flutter` 클라이언트는 이 토큰을 자동으로 관리하여 모든 후속 API 요청의 `Authorization` 헤더에 포함시킨다.3

- `refresh_token`: `access_token`이 만료되었을 때, 새로운 `access_token`을 발급받기 위해 사용되는 토큰이다. 이 또한 클라이언트 라이브러리가 자동으로 처리하므로 개발자가 직접 관리할 필요는 거의 없다.

### 3.3  오류 처리 아키텍처 (`AuthException`)


네트워크 통신과 인증 로직은 항상 예외 상황이 발생할 가능성이 있다. 따라서 견고한 오류 처리는 필수적이다. Supabase 클라이언트 라이브러리는 인증 관련 오류를 `AuthException`이라는 특화된 예외 클래스로 던져준다.

`try-catch` 블록을 사용하여 이 예외를 포착하고, 사용자에게 적절한 피드백을 제공해야 한다.2

```Dart
// signInUser 메소드 내 오류 처리 예제
Future&lt;String?&gt; signInUser({
  required String email,
  required String password,
}) async {
  try {
    await supabase.auth.signInWithPassword(
      email: email,
      password: password,
    );
    return null; // 성공 시 null 반환
  } on AuthException catch (error) {
    // AuthException은 사용자에게 보여줄 수 있는 친절한 메시지를 포함한다.
    return error.message;
  } catch (error) {
    // 네트워크 오류 등 기타 예외 처리
    return 'An unexpected error occurred.';
  }
}
</code></pre>
<p><code>AuthException</code> 객체는 <code>message</code>와 <code>statusCode</code> 같은 유용한 속성을 포함한다. 예를 들어, 이미 가입된 이메일로 회원가입을 시도하면 “User already registered“라는 메시지가 담긴 <code>AuthException</code>이 발생한다. 이를 활용하면 “이미 사용 중인 이메일입니다.” 또는 “이메일 또는 비밀번호가 올바르지 않습니다.“와 같이 사용자에게 구체적이고 명확한 피드백을 제공할 수 있다.</p>
<p>이러한 <code>AuthResponse</code>와 <code>AuthException</code>은 단순한 성공/실패의 결과값이 아니다. 이들은 인증 흐름의 다양한 상태를 나타내는 핵심적인 ’상태 객체’로서 기능한다. <code>AuthResponse</code> 객체 내부의 <code>session</code>과 <code>user</code> 필드가 <code>null</code>인지 아닌지에 따라 “회원가입은 성공했으나 이메일 확인이 필요함”, “로그인에 성공하여 세션이 발급됨” 등 여러 구체적인 상태를 구분할 수 있다. 마찬가지로, <code>AuthException</code>의 <code>message</code> 속성은 서버 측의 비즈니스 로직(예: 중복 이메일 검사, 비밀번호 정책 위반)의 결과를 클라이언트에 전달하는 통로 역할을 한다. 따라서 개발자는 이 두 객체의 내부 구조를 면밀히 분석하여, 인증 과정에서 발생할 수 있는 다양한 분기(성공, 부분 성공, 특정 원인에 의한 실패)에 정교하게 대응하는 UI/UX 흐름을 설계해야 하며, 이는 애플리케이션의 전반적인 완성도를 결정짓는 중요한 요소가 된다.</p>
<h2>4. 부: 사용자 인터페이스(UI) 및 상태 관리</h2>
<p>백엔드 로직이 준비되었으므로, 이제 사용자가 직접 상호작용할 프론트엔드 UI를 구축하고, 인증 상태 변화에 따라 앱이 동적으로 반응하도록 상태를 관리해야 한다.</p>
<h3>4.1  인증 화면 UI 제작</h3>
<p>Flutter의 <code>Form</code> 위젯과 <code>TextFormField</code>를 사용하면 효율적으로 입력 폼을 구성하고 유효성을 검사할 수 있다.</p>
<ul>
<li>
<p><strong>폼 구성</strong>: <code>StatefulWidget</code> 내부에 <code>GlobalKey&lt;FormState&gt;</code>를 선언하여 폼의 상태를 관리한다. 이메일과 비밀번호 입력을 위한 <code>TextEditingController</code>도 함께 선언한다.5</p>
</li>
<li>
<p><strong>유효성 검사</strong>: <code>TextFormField</code>의 <code>validator</code> 속성을 사용하여 입력값에 대한 규칙을 정의할 수 있다. 예를 들어, 이메일 필드에는 ‘@’ 문자가 포함되어 있는지, 비밀번호 필드는 비어있지 않은지 등을 검사하고, 유효하지 않을 경우 에러 메시지를 반환하여 사용자에게 즉각적인 피드백을 제공한다.5</p>
</li>
<li>
<p><strong>비밀번호 필드 보안</strong>: 비밀번호를 입력하는 <code>TextFormField</code>에는 <code>obscureText: true</code> 속성을 설정하여 사용자가 입력하는 내용이 화면에 노출되지 않도록 해야 한다.11</p>
</li>
</ul>
<p>아래는 회원가입 화면의 UI 코드 예시다.</p>
<pre><code class="language-Dart">// signup_page.dart
class SignUpPage extends StatefulWidget {
  const SignUpPage({super.key});

  @override
  State&lt;SignUpPage&gt; createState() =&gt; _SignUpPageState();
}

class _SignUpPageState extends State&lt;SignUpPage&gt; {
  final _formKey = GlobalKey&lt;FormState&gt;();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _usernameController = TextEditingController();

  //... signUpUser 로직...

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _usernameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Sign Up')),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children:,
        ),
      ),
    );
  }
}
</code></pre>
<h3>4.2  인증 상태 관리 및 화면 전환 (Splash Screen 아키텍처)</h3>
<p>견고한 모바일 앱은 실행 시 사용자의 로그인 상태를 확인하여 적절한 화면으로 안내해야 한다. 이를 위해 ‘스플래시 스크린’ 아키텍처 패턴을 사용한다.</p>
<ul>
<li>
<p><strong>초기 세션 확인</strong>: 스플래시 스크린 위젯이 로드될 때, <code>supabase.auth.currentSession</code>을 확인하여 현재 유효한 세션이 있는지 동기적으로 검사할 수 있다. 세션이 존재하면 홈 화면으로, 존재하지 않으면 로그인 화면으로 즉시 이동시킨다.5</p>
</li>
<li>
<p><strong><code>onAuthStateChange</code> 스트림 활용</strong>: Supabase 인증 상태 관리의 핵심은 <code>onAuthStateChange</code> 스트림이다. 이 스트림은 로그인(<code>signedIn</code>), 로그아웃(<code>signedOut</code>), 토큰 갱신(<code>tokenRefreshed</code>) 등 인증 상태와 관련된 모든 변화를 실시간으로 감지하여 이벤트를 발생시킨다. 이 스트림을 구독(<code>listen</code>)하면, 앱의 상태 변화에 반응적으로 대응하는 강력한 아키텍처를 구축할 수 있다.2</p>
<pre><code class="language-Dart">// splash_page.dart
class SplashPage extends StatefulWidget {
  const SplashPage({super.key});

  @override
  State&lt;SplashPage&gt; createState() =&gt; _SplashPageState();
}

class _SplashPageState extends State&lt;SplashPage&gt; {
  @override
  void initState() {
    super.initState();
    _redirect();
  }

  Future&lt;void&gt; _redirect() async {
    // 위젯 트리가 완전히 빌드될 때까지 잠시 기다린다.
    await Future.delayed(Duration.zero);

    final session = Supabase.instance.client.auth.currentSession;
    if (!mounted) return;

    if (session!= null) {
      Navigator.of(context).pushReplacementNamed('/home');
    } else {
      Navigator.of(context).pushReplacementNamed('/login');
    }
  }

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(child: CircularProgressIndicator()),
    );
  }
}
</code></pre>
</li>
</ul>
<pre><code>
더 나아가, 이 스트림을 앱의 최상위 위젯(예: `MaterialApp`을 감싸는 위젯)에서 구독하고, 라우팅 로직 전체를 제어하는 것이 이상적이다.

사용자 인증은 `signIn`이나 `signOut`을 호출하는 특정 시점에만 확인되는 단발성 이벤트가 아니다. 사용자가 앱을 사용하는 동안 세션은 만료될 수 있고, 백그라운드에서 자동으로 갱신될 수 있으며(`tokenRefreshed` 이벤트), 심지어 다른 기기에서 비밀번호를 변경하여 현재 세션이 무효화될 수도 있다. 이러한 동적인 변화에 대응하기 위해, `onAuthStateChange` 스트림은 인증 상태에 대한 '단일 진실 공급원(Single Source of Truth)' 역할을 수행한다.2 견고한 Flutter 아키텍처는 이 스트림을 기반으로 구축되어야 한다.

`StreamBuilder`나 Riverpod, BLoC과 같은 상태 관리 라이브러리를 사용하여 이 스트림의 상태를 앱 전역에서 관리하고, 이 상태 변화에 따라 UI(특히 라우팅)가 선언적이고 반응적으로 업데이트되도록 설계하는 것이 현대적인 Flutter 앱 개발의 핵심 원리다.13

### 4.3  로그인 후 사용자 정보 접근 및 표시


로그인에 성공하면, `supabase.auth.currentUser` 게터(getter)를 통해 현재 인증된 사용자의 `User` 객체에 언제든지 접근할 수 있다.2

`User` 객체는 다음과 같은 유용한 정보를 포함한다.

- `id`: 사용자의 고유 식별자 (UUID).

- `email`: 사용자의 이메일 주소.

- `userMetadata`: 회원가입 시 `data` 파라미터로 저장한 추가 정보가 담긴 `Map`.

이 정보를 사용하여 프로필 화면을 구성할 수 있다.2

```Dart
// profile_page.dart
final user = Supabase.instance.client.auth.currentUser;

//... 위젯 빌드 메소드 내에서...
if (user!= null) {
  Text('Email: ${user.email}');
  Text('Username: ${user.userMetadata?['username']}');
}
</code></pre>
<h3>4.4  로그아웃 기능 구현</h3>
<p>로그아웃은 <code>supabase.auth.signOut()</code> 메소드를 호출하여 간단하게 구현할 수 있다. 이 메소드는 로컬에 저장된 세션 정보를 삭제하고, Supabase 서버에 세션 무효화를 요청한다.5</p>
<p>중요한 점은 <code>signOut()</code> 호출이 성공하면 <code>onAuthStateChange</code> 스트림에서 <code>signedOut</code> 이벤트가 발생한다는 것이다. 따라서 3.2절에서 설명한 것처럼 이 스트림을 제대로 구독하고 있다면, 별도의 화면 전환 코드 없이도 앱이 자동으로 로그인 화면으로 리디렉션된다.12</p>
<pre><code class="language-Dart">// 홈 화면의 AppBar 등에서 사용
IconButton(
  icon: const Icon(Icons.logout),
  onPressed: () async {
    await Supabase.instance.client.auth.signOut();
    // onAuthStateChange 리스너가 화면 전환을 처리한다.
  },
)
</code></pre>
<h2>5. 부: 고급 주제 및 아키텍처 패턴</h2>
<p>기본적인 인증 흐름을 구현했다면, 이제 생산성을 높이고 시스템의 보안을 강화하는 고급 주제들을 살펴볼 차례다.</p>
<h3>5.1  UI 개발 가속화: <code>supabase_auth_ui</code> 패키지</h3>
<p>Supabase는 인증 UI 개발을 더욱 가속화하기 위해 <code>supabase_auth_ui</code>라는 공식 UI 라이브러리를 제공한다. 이 패키지는 일반적인 인증 화면을 위한 사전 빌드된 위젯들을 포함하고 있어, 특히 프로토타이핑이나 내부 관리 도구 개발 시 매우 유용하다.15</p>
<ul>
<li>
<p><strong><code>SupaEmailAuth</code> 위젯</strong>: 이메일/비밀번호 기반의 로그인, 회원가입, 비밀번호 재설정 UI를 단 몇 줄의 코드로 생성할 수 있다. <code>onSignInComplete</code>, <code>onSignUpComplete</code> 콜백을 통해 인증 성공 후의 동작을 정의할 수 있으며, <code>metadataFields</code> 속성을 통해 사용자 이름과 같은 추가적인 입력 필드를 동적으로 추가할 수도 있다.15</p>
<pre><code class="language-Dart">import 'package:supabase_auth_ui/supabase_auth_ui.dart';

//... 위젯 빌드 메소드 내에서...
SupaEmailAuth(
  onSignInComplete: (response) {
    // 로그인 성공 후 홈 화면으로 이동
  },
  onSignUpComplete: (response) {
    // 회원가입 성공 후 처리
  },
  metadataFields:,
)
</code></pre>
</li>
</ul>
<pre><code>
이 외에도 소셜 로그인을 위한 `SupaSocialsAuth`, 매직 링크 로그인을 위한 `SupaMagicAuth` 등 다양한 인증 방식을 지원하는 위젯들을 제공하여 개발자가 비즈니스 로직에 더 집중할 수 있도록 돕는다.15

### 5.2  비교 분석: 직접 구현 방식 vs. `supabase_auth_ui` 패키지


프로젝트의 요구사항에 따라 두 가지 접근 방식 중 적절한 것을 선택해야 한다. 다음 표는 각 방식의 장단점을 비교하여 기술적 의사결정을 돕는다.

| 특징 (Feature)                           | 직접 구현 (Manual Implementation)    | `supabase_auth_ui` 패키지                      |
| -------------------------------------- | -------------------------------- | ------------------------------------------- |
| **개발 속도 (Development Speed)**          | 느림 (Slow)                        | 매우 빠름 (Very Fast)                           |
| **UI/UX 커스터마이징 (UI/UX Customization)** | 완전한 자유도 (Full Control)           | 제한적 (Limited)                               |
| **코드 복잡성 (Code Complexity)**           | 높음 (High)                        | 매우 낮음 (Very Low)                            |
| **유지보수 (Maintenance)**                 | 직접 관리 (Direct Management)        | 패키지 업데이트에 의존 (Dependent on Package Updates) |
| **학습 곡선 (Learning Curve)**             | `Form`, 상태 관리 등 Flutter 기본 지식 필요 | 패키지 API만 학습하면 됨                             |
| **적합한 프로젝트 (Best For)**                | 맞춤형 디자인 시스템, 복잡한 UX 흐름           | MVP, 내부 툴, 빠른 프로토타입                         |

이 비교는 개발자가 단순히 '편리함'이라는 추상적인 가치 대신, '개발 속도', '커스터마이징 자유도'와 같은 구체적인 기준을 바탕으로 자신의 프로젝트 상황에 맞는 합리적인 선택을 내릴 수 있는 프레임워크를 제공한다. 이는 성공적인 프로젝트를 위한 중요한 기술적 의사결정 과정이다.

### 5.3  인증과 데이터베이스 보안의 연결고리: RLS (Row Level Security)


Supabase의 가장 강력하고 차별화된 기능 중 하나는 인증 시스템과 PostgreSQL 데이터베이스가 긴밀하게 통합되어 있다는 점이다. 이 통합의 핵심이 바로 RLS(Row Level Security)다.3

RLS는 데이터베이스의 각 행(row)에 대해 특정 사용자의 읽기, 쓰기, 수정, 삭제 권한을 정책(policy) 기반으로 제어하는 PostgreSQL의 기능이다. Supabase는 이 기능을 활용하여, 인증된 사용자의 JWT에 포함된 고유 ID(`user.id`)를 기반으로 데이터 접근을 데이터베이스 레벨에서 강제할 수 있다.

예를 들어, 사용자가 작성한 노트를 저장하는 `notes` 테이블이 있고, 각 노트는 작성자의 `user_id`를 가지고 있다고 가정하자. 이때, "사용자는 오직 자신이 작성한 노트만 조회하고 수정할 수 있다"는 정책을 다음과 같은 SQL로 정의할 수 있다.8

```SQL
-- notes 테이블에 RLS 활성화
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;

-- SELECT (읽기) 정책: auth.uid()가 현재 로그인된 사용자의 UUID와 일치하는 행만 허용
CREATE POLICY "Users can view their own notes."
ON notes FOR SELECT
USING (auth.uid() = user_id);

-- INSERT (쓰기) 정책: 새로운 노트를 생성할 때 user_id를 현재 사용자의 UUID로 설정
CREATE POLICY "Users can insert their own notes."
ON notes FOR INSERT
WITH CHECK (auth.uid() = user_id);
</code></pre>
<p>이러한 정책이 설정되면, 클라이언트 측 코드(<code>supabase.from('notes').select()</code>)가 아무리 모든 노트를 가져오려고 시도해도, 데이터베이스는 현재 요청의 JWT를 검증하여 해당 사용자의 <code>user_id</code>와 일치하는 노트만을 반환한다. 이는 클라이언트 코드의 실수나 잠재적인 보안 허점으로부터 데이터를 원천적으로 보호하는 매우 강력한 보안 패러다임이다.</p>
<p>결론적으로, Supabase의 인증 시스템은 단순히 사용자를 식별하는 독립된 기능이 아니다. 그것은 Supabase 생태계 전체, 특히 데이터베이스를 위한 ’보안 게이트웨이’로서 작동한다. 사용자가 로그인에 성공하여 JWT를 발급받는 행위는 곧 데이터베이스의 RLS 정책을 활성화하는 트리거가 된다. 이 유기적인 연동이야말로 Supabase 아키텍처의 핵심 철학이며, 개발자는 단순히 로그인 기능을 구현하는 것을 넘어, ‘인증된 세션을 기반으로 안전하게 데이터에 접근하는’ 전체 데이터 흐름을 설계하고 이해해야 한다.</p>
<h2>6. 결론</h2>
<p>본 안내서는 Flutter와 Supabase를 사용하여 이메일/비밀번호 기반의 사용자 인증 시스템을 구축하는 전 과정을 심층적으로 다루었다. Supabase 프로젝트 설정 및 Flutter 클라이언트 초기화부터 시작하여, <code>signUp</code>과 <code>signInWithPassword</code>를 사용한 핵심 인증 로직 구현, <code>AuthException</code>을 통한 체계적인 오류 처리 방법을 분석했다. 또한, <code>onAuthStateChange</code> 스트림을 활용한 반응형 상태 관리와 스플래시 스크린 아키텍처를 통해 견고한 사용자 경험을 구축하는 방법을 제시했다. 마지막으로, <code>supabase_auth_ui</code> 패키지를 통한 개발 가속화와 Supabase의 핵심 기능인 RLS를 통해 인증과 데이터베이스 보안을 유기적으로 연결하는 고급 아키텍처 패턴까지 살펴보았다.</p>
<p>여기서 제시된 코드는 안정적인 인증 시스템의 견고한 기반이 된다. 이 기반 위에서 개발자는 소셜 로그인(Google, GitHub 등) 17, 비밀번호 없는 로그인(Magic Link, OTP) 10, 그리고 사용자의 프로필 정보를 수정하고 프로필 사진을 업로드하는 기능 8 등 더욱 풍부한 사용자 경험을 제공하는 기능으로 시스템을 확장해 나갈 수 있다.</p>
<p>최종적으로 강조하고 싶은 바는 Supabase의 진정한 잠재력은 개별 기능의 성능이 아닌, 각 기능들이 매끄럽게 통합되어 있다는 점에서 발현된다는 것이다. 따라서 개발자는 인증, 데이터베이스, 스토리지를 각각 별개의 서비스로 취급하기보다, 하나의 통합된 백엔드 시스템으로 이해하고 접근해야 한다. 이러한 통합적 관점을 가질 때, 개발자는 Supabase가 제공하는 모든 기능을 활용하여 안전하고 확장 가능하며 효율적인 애플리케이션을 구축할 수 있을 것이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>The Postgres development platform. Supabase gives you a dedicated Postgres database to build your web, mobile, and AI applications. - GitHub, https://github.com/supabase/supabase</li>
<li>heyhey1028/flutter_supabase_auth: sample for supabase … - GitHub, https://github.com/heyhey1028/flutter_supabase_auth</li>
<li>Auth | Supabase Docs, https://supabase.com/docs/guides/auth</li>
<li>Build a User Management App with Flutter | Supabase Docs, https://supabase.com/docs/guides/getting-started/tutorials/with-flutter</li>
<li>dwyl/supabase-flutter-demo: A SPIKE showcasing the use … - GitHub, https://github.com/dwyl/supabase-flutter-demo</li>
<li>Getting Started with Supabase and Flutter: An Overview - Monterail, https://www.monterail.com/blog/getting-started-with-supabase-and-flutter</li>
<li>Password-based Auth | Supabase Docs, https://supabase.com/docs/guides/auth/passwords</li>
<li>Building a Flutter App with Supabase: Authentication and CRUD Functionality - Medium, https://medium.com/@muhammad.fathy/building-a-flutter-app-with-supabase-authentication-and-crud-functionality-3afffb589b1b</li>
<li>Flutter: Sign in a user | Supabase Docs, https://supabase.com/docs/reference/dart/auth-signinwithpassword</li>
<li>Passwordless email logins | Supabase Docs, https://supabase.com/docs/guides/auth/auth-email-passwordless</li>
<li>Authentication with Supabase • Flutter Tutorial - YouTube, https://www.youtube.com/watch?v=njeo_g-3tPw</li>
<li>Flutter Supabase Authentication - Complete tutorial - Sandro Maglione, https://www.sandromaglione.com/articles/flutter-supabase-authentication-complete-tutorial</li>
<li>Supabase Authentication Made EASY for Flutter App Developers | Riverpod x GoRouter, https://www.youtube.com/watch?v=Regyx9wME-k</li>
<li>miljepetrovic/flutter_supabase_starter_template: Represents the starter template for mobile apps in Flutter and Supabase. Provided authentication with magic link. - GitHub, https://github.com/miljepetrovic/flutter_supabase_starter_template</li>
<li>Flutter Auth UI | Supabase Docs, https://supabase.com/docs/guides/auth/auth-helpers/flutter-auth-ui</li>
<li>Supabase Auth UI library for Flutter - GitHub, https://github.com/supabase-community/flutter-auth-ui</li>
<li>Login with GitHub | Supabase Docs, https://supabase.com/docs/guides/auth/social-login/auth-github</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>