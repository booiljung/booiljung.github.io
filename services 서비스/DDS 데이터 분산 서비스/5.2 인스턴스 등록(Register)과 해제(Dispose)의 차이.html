<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:5.2 인스턴스 등록(Register)과 해제(Dispose)의 차이</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>5.2 인스턴스 등록(Register)과 해제(Dispose)의 차이</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">데이터 분산 서비스 DDS</a> / <span>5.2 인스턴스 등록(Register)과 해제(Dispose)의 차이</span></nav>
                </div>
            </header>
            <article>
                <h1>5.2 인스턴스 등록(Register)과 해제(Dispose)의 차이</h1>
<p>데이터 분산 서비스(DDS, Data Distribution Service) 아키텍처는 단순한 메시지 전달 미들웨어를 넘어, 네트워크상에 분산된 거대한 ’가상 데이터베이스’를 구축하는 기술이다. 이 가상 데이터베이스, 즉 글로벌 데이터 공간(Global Data Space)을 이해하는 데 있어 가장 중요한 단위는 토픽(Topic) 자체가 아니라, 토픽 내부에서 키(Key)에 의해 식별되는 개별 데이터 객체인 ’인스턴스(Instance)’이다.1</p>
<p>많은 개발자가 DDS를 처음 도입할 때, <code>write()</code> 함수만을 사용하여 데이터를 전송하는 데 집중하곤 한다. 그러나 실시간 시스템의 복잡도가 증가하고 데이터의 생명주기(Lifecycle) 관리가 중요해질수록, <code>DataWriter</code>가 제공하는 세 가지 핵심 연산인 <code>register_instance</code>, <code>unregister_instance</code>, <code>dispose</code>의 명확한 구분과 적절한 활용이 시스템의 성능과 정합성을 결정짓는 핵심 요소로 부상한다. 이 세 연산은 겉보기에는 유사하게 데이터를 관리하는 것처럼 보이지만, 미들웨어 내부에서 작동하는 메커니즘과 네트워크를 통해 전파되는 의미론적(Semantic) 메시지는 근본적으로 다르다.3</p>
<p>본 절에서는 이 세 가지 연산의 기술적 정의와 내부 동작 원리, 그리고 이들이 QoS 정책 및 시스템 리소스와 어떻게 상호작용하는지를 심층적으로 분석한다. 특히, 인스턴스의 상태 전이(State Transition)와 관련하여 개발자가 반드시 숙지해야 할 데이터 무결성 이슈와 성능 최적화 전략을 상세히 기술한다.</p>
<h2>1.  인스턴스 관리의 철학적 배경: 글로벌 데이터 공간</h2>
<p>DDS의 데이터 중심(Data-Centric) 철학에서 ’인스턴스’는 관계형 데이터베이스의 ’행(Row)’이나 객체지향 프로그래밍의 ’객체(Object)’와 유사한 지위를 갖는다. 예를 들어 ’항공기 트랙(Flight Track)’이라는 토픽이 존재할 때, ‘KE081’, ’OZ101’과 같은 개별 항공편 식별자(Flight ID)는 각 인스턴스를 구분하는 키(Key)가 된다.1</p>
<p>이때 시스템은 단순히 항공기의 위치 좌표를 갱신하는 것을 넘어, 특정 항공기가 ‘탐지되기 시작했다(Creation)’, ‘위치가 변경되었다(Update)’, ’착륙하여 추적 대상에서 사라졌다(Deletion)’라는 생명주기 이벤트를 인지해야 한다. DDS 표준은 이러한 생명주기 관리를 위해 명시적인 API를 제공하며, 각 API는 글로벌 데이터 공간에 대한 서로 다른 ’의도(Intent)’를 표명한다.</p>
<ul>
<li><strong>Register (등록):</strong> 로컬 자원을 예약하고 데이터 갱신을 준비하겠다는 ‘성능 최적화’ 및 ’선언’의 의도.</li>
<li><strong>Unregister (등록 취소):</strong> 해당 인스턴스에 대한 업데이트 책임을 더 이상 지지 않겠다는 ’역할 포기’의 의도.</li>
<li><strong>Dispose (폐기):</strong> 해당 인스턴스가 물리적 또는 논리적으로 소멸하였음을 알리는 ’삭제’의 의도.3</li>
</ul>
<p>이러한 의도의 차이는 네트워크 트래픽, 메모리 관리, 그리고 구독자(Subscriber) 측의 데이터 해석에 지대한 영향을 미친다.</p>
<h2>2.  인스턴스 등록(Register Instance): 성능과 리소스의 최적화</h2>
<p><code>register_instance</code> 연산은 DDS 미들웨어에게 “내가 곧 특정 키(Key)를 가진 인스턴스의 데이터를 쓸(Write) 예정이니, 필요한 리소스를 미리 할당하고 관리 핸들을 달라“고 요청하는 과정이다.3</p>
<h3>2.1  명시적 등록과 암시적 등록의 알고리즘적 차이</h3>
<p>DDS 표준에 따르면, 인스턴스 등록은 필수 사항이 아니다. 사용자가 <code>register_instance</code>를 호출하지 않고 <code>write()</code>를 호출하더라도, 미들웨어는 내부적으로 **암시적 등록(Implicit Registration)**을 수행한다. 그러나 고성능 시스템에서는 **명시적 등록(Explicit Registration)**이 강력히 권장되는데, 이는 데이터 경로(Data Path) 상의 알고리즘 복잡도 때문이다.5</p>
<table><thead><tr><th><strong>등록 방식</strong></th><th><strong>동작 메커니즘</strong></th><th><strong>시간 복잡도</strong></th><th><strong>사용 사례</strong></th></tr></thead><tbody>
<tr><td><strong>암시적 등록</strong> (Implicit)</td><td><code>write()</code> 호출 시마다 샘플의 키 필드를 직렬화하고, 해시(Hash)를 계산한 후, 내부 맵(Map)을 검색하여 인스턴스 컨텍스트를 찾는다. 존재하지 않으면 생성한다.</td><td><span class="math math-inline">O(\log n)</span> 또는 해시 충돌 시 그 이상</td><td>낮은 빈도의 데이터 전송, 키 개수가 적은 경우, 편의성이 중요한 경우</td></tr>
<tr><td><strong>명시적 등록</strong> (Explicit)</td><td>사전에 <code>register_instance()</code>를 호출하여 <code>InstanceHandle_t</code>를 발급받는다. <code>write()</code> 호출 시 이 핸들을 전달하면 검색 과정을 생략하고 메모리 주소로 직접 접근한다.</td><td><span class="math math-inline">O(1)</span></td><td>레이더 추적, 고빈도 거래(HFT) 등 수천 개 이상의 인스턴스를 고속으로 갱신해야 하는 경우</td></tr>
</tbody></table>
<p>암시적 등록을 사용할 경우, <code>DataWriter</code>는 매 <code>write</code> 호출마다 키 값을 검사해야 한다. 만약 키 필드가 문자열(String)과 같이 가변 길이를 가지거나 복잡한 구조체라면, 이를 직렬화하고 해시를 계산하는 비용은 CPU 사이클을 상당히 소모하게 된다. 반면, <code>register_instance</code>는 이 비용을 최초 1회만 지불하게 한다. 반환된 <code>InstanceHandle_t</code>는 미들웨어 내부의 인스턴스 관리 구조체를 가리키는 포인터이거나 배열의 인덱스 역할을 하므로, 이후의 <code>write</code> 연산은 단순히 해당 메모리 위치에 데이터를 복사하는 작업으로 단축된다.6</p>
<h3>2.2  로컬 리소스 예약과 전파 범위</h3>
<p><code>register_instance</code>의 가장 중요한 특징 중 하나는 이 연산이 **로컬 전용(Local-only)**이라는 점이다.5 <code>DataWriter</code>가 인스턴스를 등록하더라도, 이 사실은 네트워크를 통해 <code>DataReader</code>에게 전파되지 않는다. 즉, <code>register</code>만 수행하고 <code>write</code>를 하지 않은 상태에서는 구독자 측에서 새로운 인스턴스가 생성되었음을 알 수 없다.</p>
<p>이는 등록 행위가 데이터의 가용성(Availability)을 알리는 것이 아니라, <code>DataWriter</code> 내부의 **리소스 예약(Resource Reservation)**에 초점을 맞추고 있기 때문이다. <code>DataWriter</code>는 등록된 인스턴스를 관리하기 위해 <code>RESOURCE_LIMITS</code> QoS 정책의 <code>max_instances</code> 한도 내에서 메모리 슬롯을 할당한다.5 만약 <code>max_instances</code> 한도에 도달한 상태에서 새로운 인스턴스를 등록하려고 시도하면, 설정된 <code>RELIABILITY</code> 및 <code>HISTORY</code> QoS 정책에 따라 연산이 차단(Block)되거나 에러를 반환할 수 있다.7</p>
<p>따라서 <code>register_instance</code>는 시스템의 예측 가능성을 높이는 데 기여한다. 시스템 초기화 단계에서 필요한 모든 주요 인스턴스를 미리 등록해 둠으로써, 런타임 중에 메모리 할당 실패나 리소스 부족으로 인한 지연이 발생할 가능성을 사전에 차단할 수 있다.</p>
<h2>3.  인스턴스 해제(Unregister)와 폐기(Dispose)의 심층 비교</h2>
<p>DDS를 처음 접하는 개발자가 가장 혼란스러워하는 부분이 바로 <code>unregister_instance</code>와 <code>dispose</code>의 차이이다. 두 연산 모두 인스턴스와의 상호작용을 끝내는 것처럼 보이지만, 그 대상과 범위, 그리고 시스템에 미치는 영향은 완전히 다르다. 이 둘의 차이를 명확히 구분하는 것은 데이터 무결성을 유지하는 데 필수적이다.</p>
<h3>3.1  등록 취소(Unregister): 책임의 이양과 역할의 종료</h3>
<p><code>unregister_instance</code>는 **“작성자(Writer)의 관점”**에서 수행되는 연산이다. 이는 “나는 더 이상 이 인스턴스에 대한 정보를 갱신하지 않겠다“라고 선언하는 것이다.3</p>
<ul>
<li><strong>의미론적 해석:</strong> 다수의 센서가 하나의 대상을 추적하는 상황을 가정해보자. 특정 센서의 시야에서 대상이 사라졌다면, 해당 센서(Writer)는 대상을 더 이상 볼 수 없으므로 <code>unregister</code>를 수행한다. 하지만 대상 자체가 사라진 것인지, 아니면 단지 이 센서의 범위만 벗어난 것인지는 확신할 수 없다. 따라서 <code>unregister</code>는 데이터 자체의 존재 여부에는 판단을 유보하고, 오직 Writer 자신의 역할 종료만을 알린다.</li>
<li><strong>인스턴스 상태 변화:</strong> <code>unregister</code>가 호출되면, 미들웨어는 해당 인스턴스를 관리하던 Writer 목록에서 호출한 Writer를 제거한다. 만약 이 Writer가 해당 인스턴스를 담당하던 <strong>유일한</strong> Writer였다면, 인스턴스의 상태는 <code>NOT_ALIVE_NO_WRITERS</code>로 전이된다.9 그러나 다른 Writer가 여전히 해당 인스턴스를 등록하고 있다면, 인스턴스 상태는 여전히 <code>ALIVE</code>로 유지된다.</li>
<li><strong>리소스 관리:</strong> <code>unregister</code>를 호출한 <code>DataWriter</code>는 해당 인스턴스에 할당했던 로컬 리소스를 해제할 수 있는 권한을 얻는다. 이는 제한된 메모리 자원(<code>max_instances</code>)을 효율적으로 재사용하기 위해 필수적이다.11</li>
</ul>
<h3>3.2  폐기(Dispose): 데이터의 소멸과 글로벌 삭제</h3>
<p>반면, <code>dispose</code>는 **“데이터(Data)의 관점”**에서 수행되는 연산이다. 이는 “이 인스턴스는 더 이상 유효하지 않으며, 시스템에서 논리적으로 삭제되었다“라고 선언하는 것이다.3</p>
<ul>
<li><strong>의미론적 해석:</strong> 항공기가 착륙하여 엔진을 껐거나, 시뮬레이션 상에서 탱크가 파괴되었다면, 이 객체는 더 이상 추적할 필요가 없다. 이때는 <code>dispose</code>를 호출하여 시스템 전체에 “이 데이터는 소멸했다“는 사실을 공표해야 한다.</li>
<li><strong>인스턴스 상태 변화:</strong> <code>dispose</code>가 호출되면, 해당 정보는 네트워크를 타고 모든 연관된 <code>DataReader</code>에게 전파된다. 이를 수신한 Reader 측에서는 인스턴스의 상태를 <code>NOT_ALIVE_DISPOSED</code>로 변경한다.9 이는 단순히 업데이트가 멈춘 것이 아니라, 데이터 자체가 ’죽었음(Dead)’을 의미한다.</li>
<li><strong>데이터 무결성:</strong> <code>dispose</code>는 글로벌 데이터 공간에서의 삭제를 의미하므로 매우 강력한 연산이다. 따라서 <code>OWNERSHIP</code> QoS 정책이 <code>EXCLUSIVE</code>로 설정된 경우, 아무 Writer나 <code>dispose</code>를 할 수 없으며, 오직 현재 인스턴스의 소유권(Ownership)을 가진 Writer만이 이 연산을 수행할 수 있다.14</li>
</ul>
<h3>3.3  비교 요약 테이블</h3>
<p>다음 표는 두 연산의 차이를 다각도에서 비교 분석한 것이다.</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Unregister Instance (등록 취소)</strong></th><th><strong>Dispose (폐기)</strong></th></tr></thead><tbody>
<tr><td><strong>핵심 의미</strong></td><td><strong>작성자(Writer)의 퇴장</strong>: “나는 더 이상 관여하지 않겠다.”</td><td><strong>데이터(Data)의 소멸</strong>: “이 객체는 삭제되었다.”</td></tr>
<tr><td><strong>Instance State</strong></td><td><code>NOT_ALIVE_NO_WRITERS</code> (활성 Writer가 없을 때)</td><td><code>NOT_ALIVE_DISPOSED</code></td></tr>
<tr><td><strong>영향 범위</strong></td><td>로컬 Writer 및 매칭된 Reader의 Writer 목록 갱신</td><td>글로벌 데이터 공간 전체 (모든 참여자에게 전파)</td></tr>
<tr><td><strong>QoS 제약</strong></td><td>소유권과 무관하게 누구나 자신의 등록 취소 가능</td><td><code>EXCLUSIVE</code> 소유권일 경우 Owner만 호출 가능</td></tr>
<tr><td><strong>리소스 해제</strong></td><td>Writer 측 리소스 즉시/지연 회수 가능</td><td>인스턴스 자체는 삭제되지만, 메타데이터는 유지될 수 있음</td></tr>
<tr><td><strong>SampleInfo</strong></td><td><code>valid_data</code> = <code>FALSE</code> (상태 변경 알림 샘플)</td><td><code>valid_data</code> = <code>FALSE</code> (상태 변경 알림 샘플)</td></tr>
<tr><td><strong>부활(Resurrection)</strong></td><td>다시 <code>write</code>하면 새로운 등록으로 간주</td><td>다시 <code>write</code>하면 <code>ALIVE</code> 상태로 복귀</td></tr>
</tbody></table>
<h2>4.  인스턴스 상태 머신과 Valid Data 플래그의 해석</h2>
<p>DDS 애플리케이션 개발에서 버그가 가장 많이 발생하는 지점은 구독자(Subscriber)가 데이터를 수신하고 처리하는 부분이다. <code>dispose</code>나 <code>unregister</code>가 발생하면 DDS는 상태 변경을 알리기 위해 샘플을 전달하는데, 이때 데이터 페이로드(Payload)의 유효성을 정확히 판단하지 않으면 심각한 오류를 초래할 수 있다.</p>
<h3>4.1  Valid Data 플래그의 중요성</h3>
<p><code>DataReader</code>가 <code>read()</code>나 <code>take()</code>를 통해 샘플을 꺼낼 때, 함께 전달되는 <code>SampleInfo</code> 구조체에는 <code>valid_data</code>라는 불리언(Boolean) 플래그가 존재한다.2</p>
<ul>
<li><strong>valid_data = TRUE:</strong> 정상적인 데이터 업데이트이다. 페이로드(사용자 정의 구조체)에 유의미한 값이 들어있다.</li>
<li><strong>valid_data = FALSE:</strong> 이는 데이터 업데이트가 아니라, <strong>인스턴스의 상태(State)가 변경되었음</strong>을 알리는 메타데이터 샘플이다. 이때 페이로드 영역의 값은 쓰레기 값이거나, 키(Key) 필드만 유효하고 나머지 필드는 초기화되지 않은 상태일 수 있다.</li>
</ul>
<p>만약 개발자가 <code>valid_data</code> 플래그를 확인하지 않고 무조건 페이로드에 접근하여 로직을 수행하려 한다면, 이미 삭제된(<code>NOT_ALIVE_DISPOSED</code>) 객체의 좌표를 지도에 그리려 하거나, 널 포인터 역참조와 유사한 논리적 오류를 범하게 된다. 따라서 모든 데이터 수신 로직은 다음과 같은 패턴을 따라야 한다.</p>
<pre><code class="language-C++">// DDS 데이터 수신 처리의 정석적 패턴 (개념 코드)
for (int i = 0; i &lt; samples.length(); ++i) {
    if (info[i].valid_data) {
        // [ALIVE] 정상 데이터 처리: 객체 위치 업데이트, 값 갱신 등
        ProcessUserData(samples[i]);
    } else {
        // 상태 변경 처리: 데이터는 없고 상태 정보만 있음
        if (info[i].instance_state == NOT_ALIVE_DISPOSED) {
            // 객체가 삭제됨 -&gt; UI 목록에서 제거, 내부 Map에서 삭제
            RemoveObject(samples[i].key);
        } else if (info[i].instance_state == NOT_ALIVE_NO_WRITERS) {
            // 연결 끊김/센서 오프라인 -&gt; 아이콘을 회색으로 변경하거나 경고 표시
            MarkObjectAsOffline(samples[i].key);
        }
    }
}
</code></pre>
<h3>4.2  인스턴스 부활 (Resurrection)</h3>
<p>흥미로운 점은 <code>NOT_ALIVE_DISPOSED</code> 상태가 영구적이지 않다는 것이다. DDS는 이미 <code>dispose</code> 된 인스턴스라 하더라도, 어떤 <code>DataWriter</code>가 동일한 키(Key)를 사용하여 다시 <code>write()</code>를 호출하면 그 즉시 해당 인스턴스를 <code>ALIVE</code> 상태로 복구시킨다.2 이를 **인스턴스 부활(Resurrection)**이라 부른다.</p>
<p>이 과정에서 <code>SampleInfo</code> 내의 <code>disposed_generation_count</code>가 증가한다. 구독자는 이 카운터를 통해 “아, 이 객체는 과거에 3번 삭제되었다가 다시 나타난 객체구나“라는 사실을 인지할 수 있다. 이는 일시적으로 사라졌다가 다시 나타나는 추적 대상(예: 터널을 통과한 차량)을 처리할 때 유용한 메타데이터가 된다.</p>
<h2>5.  QoS 정책에 의한 생명주기 자동화</h2>
<p>DDS는 개발자가 일일이 <code>unregister</code>와 <code>dispose</code>를 호출하는 번거로움을 줄이고, 실수를 방지하기 위해 QoS 정책을 통한 자동화 기능을 제공한다. 그중 가장 핵심적인 것이 <code>WRITER_DATA_LIFECYCLE</code> 정책이다.</p>
<h3>5.1  autodispose_unregistered_instances</h3>
<p>이 설정은 <code>DataWriter</code>가 인스턴스 등록을 취소(<code>unregister</code>)할 때, 자동으로 <code>dispose</code>를 함께 수행할지 여부를 결정한다.12</p>
<ul>
<li><strong>TRUE (기본값):</strong> <code>unregister_instance</code>를 호출하거나 <code>DataWriter</code>가 삭제되면, 미들웨어는 먼저 <code>dispose</code> 메시지를 보내 인스턴스를 소멸시킨 후, <code>unregister</code> 처리를 한다.</li>
<li><em>장점:</em> Writer가 종료되면(예: 애플리케이션 종료) 자동으로 생성했던 모든 데이터가 정리되므로 깔끔한 시스템 상태를 유지할 수 있다.</li>
<li><em>위험성:</em> 여러 Writer가 동일한 인스턴스를 공유하는 분산 환경에서, 하나의 애플리케이션이 종료될 때 의도치 않게 공유 데이터를 삭제(<code>dispose</code>)해버려 다른 참여자들에게 데이터가 사라진 것으로 오인하게 만들 수 있다.7</li>
<li><strong>FALSE:</strong> <code>unregister</code> 시 <code>dispose</code>를 수행하지 않는다. 인스턴스는 <code>NOT_ALIVE_NO_WRITERS</code> 상태로 남는다. 공유 데이터 환경이나, 데이터의 지속성(Persistence)이 Writer의 생명주기보다 길어야 하는 경우(예: <code>DURABILITY</code>가 <code>TRANSIENT</code> 이상인 경우)에는 반드시 이 값을 <code>FALSE</code>로 설정해야 한다.</li>
</ul>
<h3>5.2  자동 퍼지(Auto Purge)와 메모리 관리</h3>
<p>인스턴스가 <code>NOT_ALIVE</code> 상태가 되었다고 해서 메모리에서 즉시 삭제되는 것은 아니다. DDS는 나중에 늦게 합류하는 참여자(Late Joiner)를 위해, 또는 인스턴스가 부활할 가능성을 대비해 일정 기간 동안 메타데이터를 유지한다. 이를 제어하는 것이 <code>READER_DATA_LIFECYCLE</code>의 <code>autopurge_nowriter_samples_delay</code> 및 <code>autopurge_disposed_samples_delay</code> QoS이다.4</p>
<ul>
<li><strong>INFINITE (기본값):</strong> 명시적으로 메모리 제한(<code>max_instances</code>)에 도달하거나 애플리케이션이 종료될 때까지 정보를 유지한다. 이는 메모리 누수처럼 보일 수 있으나, DDS의 빠른 재검색을 위한 의도된 동작이다.</li>
<li><strong>시간 설정:</strong> 설정된 시간이 지나면 미들웨어는 비로소 인스턴스 정보를 내부 맵에서 완전히 삭제(Purge)한다. 이때 인스턴스 핸들(Handle)은 무효화되며, 이후 다시 데이터가 들어오면 새로운 인스턴스로 취급되어 핸들이 새로 발급된다.</li>
</ul>
<h2>6.  종합적 고찰 및 권고 사항</h2>
<p>인스턴스 생명주기 관리(<code>Register</code>, <code>Unregister</code>, <code>Dispose</code>)는 DDS를 단순한 통신 파이프라인이 아닌, 분산 상태 관리 도구로 활용하게 하는 핵심 메커니즘이다. 성공적인 DDS 시스템 설계를 위해 다음의 권고 사항을 준수할 것을 제안한다.</p>
<ol>
<li><strong>명시적 등록의 습관화:</strong> 시스템 성능 예측 가능성을 높이기 위해, 가능한 한 <code>register_instance</code>를 사용하여 핸들을 미리 확보하고 이를 <code>write</code>에 활용하라. 이는 특히 CPU 부하가 높은 임베디드 환경에서 <span class="math math-inline">O(\log n)</span>을 <span class="math math-inline">O(1)</span>로 줄이는 중요한 최적화 기법이다.</li>
<li><strong>Dispose의 신중한 사용:</strong> <code>dispose</code>는 “삭제“다. 단순히 센서가 꺼진 것인지, 객체가 정말 소멸한 것인지 구분하여 사용해야 한다. 센서가 꺼진 경우에는 <code>unregister</code>가 적합하며, 객체가 소멸한 경우에만 <code>dispose</code>를 사용하라.</li>
<li><strong>QoS 기본값의 함정 탈피:</strong> <code>autodispose_unregistered_instances</code>가 기본적으로 <code>TRUE</code>임에 유의하라. 다중 Writer 환경에서는 이로 인해 예기치 않은 데이터 삭제가 발생할 수 있으므로, 시스템 아키텍처에 맞게 명시적으로 <code>FALSE</code>로 설정하는 것을 고려해야 한다.</li>
<li><strong>구독자 로직의 견고성 확보:</strong> <code>valid_data</code> 플래그 확인은 선택이 아닌 필수다. 상태 변경 알림(<code>NOT_ALIVE</code>)을 적절히 처리하지 않으면, 화면에 삭제된 유령 데이터가 계속 남아있거나 잘못된 메모리 접근으로 프로그램이 비정상 종료될 수 있다.</li>
</ol>
<p>결론적으로, <code>register</code>는 성능을 위한 준비이고, <code>dispose</code>는 데이터의 논리적 종결이며, <code>unregister</code>는 참여자의 퇴장이다. 이 세 가지 개념을 명확히 구분하고 적절히 조합하여 사용하는 것이야말로 견고하고 효율적인 데이터 중심 시스템을 구축하는 지름길이다.</p>
<h2>7. 참고 자료</h2>
<ol>
<li>Tutorial on the OMG Data Distribution Service, http://www.dre.vanderbilt.edu/~gokhale/OMG_RTWS06/00-T1-1_Giddings.pdf</li>
<li>Data Distribution Service (DDS) - Object Management Group (OMG), https://www.omg.org/spec/DDS/1.4/PDF</li>
<li>Data Distribution Service for Real-Time Systems Specification - Object Management Group (OMG), https://www.omg.org/spec/DDS/1.1/PDF/</li>
<li>Instance Resources, Dispose, and Unregister | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/content/forum-topic/instance-resources-dispose-and-unregister</li>
<li>34.14 Managing Instances (Working with Keyed Data Types) - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/connext_dds_professional/users_manual/users_manual/Managing_Data_Instances__Working_with_Ke.htm</li>
<li>Register the Instance and Use the InstanceHandle When Writing for Better Performance | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/best-practices/register-instance-and-use-instancehandle-when-writing-better-performance</li>
<li>CoreDX DDS Sample and Instance Management - Twin Oaks Computing, Inc, https://www.twinoakscomputing.com/wp/CoreDX_DDS_Instance_Management.pdf</li>
<li>Configuring Resource Limits in Connext DDS Micro - RTI Community, https://community.rti.com/kb/configuring-resource-limits-connext-dds-micro</li>
<li>
<ol start="3">
<li>Reading and Writing Data — The Data Distribution Service Tutorial, https://download.zettascale.online/www/docs/Vortex/html/ospl/DDSTutorial/readandwrite.html</li>
</ol>
</li>
<li>RTI Connext Modern C++ API: dds::sub::status::InstanceState Class Reference, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_cpp2/classdds_1_1sub_1_1status_1_1InstanceState.html</li>
<li>RTI Connext DDS Micro C API: max_instances, https://community.rti.com/static/documentation/connext-micro/2.4.14/doc/api_c/html/group__DDSUserManuals__ResourceModule__dwqos__max__instances.html</li>
<li>Understanding Instance States | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/kb/understanding-instance-states</li>
<li>3.4.7. SampleInfo - 3.4.1 - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/3.x/fastdds/dds_layer/subscriber/sampleInfo/sampleInfo.html</li>
<li>43.8 Accessing and Managing Instances (Working with Keyed Data Types) - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/connext_dds_professional/users_manual/users_manual/AccessingManagingInstances.htm</li>
<li>20.1.4.4. InstanceStateKind - 3.4.1 - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/3.x/fastdds/api_reference/dds_pim/subscriber/instancestatekind.html</li>
<li>RTI Connext Traditional C++ API: DDS_SampleInfo Struct Reference - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_cpp/structDDS__SampleInfo.html</li>
<li>WRITER_DATA_LIFECYCLE QoS Parameter [DDS Foundation Wiki], https://www.omgwiki.org/ddsf/doku.php?id=ddsf:public:guidebook:06_append:02_quality_of_service:writer_data_lifecycle</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>