<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:4.1 토픽의 이름 짓기 및 구조화</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>4.1 토픽의 이름 짓기 및 구조화</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">데이터 분산 서비스 DDS</a> / <span>4.1 토픽의 이름 짓기 및 구조화</span></nav>
                </div>
            </header>
            <article>
                <h1>4.1 토픽의 이름 짓기 및 구조화</h1>
<p>DDS(Data Distribution Service) 미들웨어를 기반으로 하는 분산 시스템 아키텍처에서 ’토픽(Topic)’은 단순한 메시지 전달 경로의 이름을 넘어선다. 데이터 중심(Data-Centric) 설계 철학에서 토픽은 전역 데이터 공간(Global Data Space) 내에 존재하는 정보의 본질적 식별자이자, 데이터의 생산자(DataWriter)와 소비자(DataReader) 간의 강력한 계약(Contract)을 형성하는 핵심 매개체이다.1 시스템의 규모가 커지고 복잡도가 증가함에 따라 초기에 결정된 토픽의 명명 규칙(Naming Convention)과 구조화 전략은 시스템의 성능, 확장성(Scalability), 그리고 상호운용성(Interoperability)을 좌우하는 결정적인 기술 부채(Technical Debt) 혹은 자산이 된다.</p>
<p>본 장에서는 DDS 표준 명세와 다양한 산업 현장의 베스트 프랙티스, 그리고 RTPS(Real-time Publish-Subscribe) 와이어 프로토콜의 기술적 제약 사항을 종합적으로 분석하여, 견고하고 확장 가능한 토픽 설계 전략을 상세히 기술한다.</p>
<h2>1.  데이터 중심 아키텍처와 토픽의 본질</h2>
<p>DDS가 다른 메시지 지향 미들웨어(MOM)와 구분되는 가장 큰 특징은 데이터 중심성이다. MQTT나 AMQP와 같은 프로토콜이 “메시지를 어디로 보낼 것인가(Destination)“에 집중한다면, DDS는 “공유되는 데이터가 무엇인가(What)“에 집중한다.1 이러한 철학적 차이는 토픽의 이름 짓기 방식에 근본적인 변화를 요구한다.</p>
<h3>1.1  토픽의 구성 요소와 식별</h3>
<p>DDS 명세에 따르면, 데이터 리더와 데이터 라이터가 성공적으로 연결(Matching)되기 위해서는 다음 세 가지 요소가 반드시 일치하거나 호환되어야 한다.</p>
<ol>
<li><strong>토픽 이름(Topic Name):</strong> 도메인(Domain) 내에서 유일한 문자열 식별자.</li>
<li><strong>데이터 타입 이름(Type Name) 및 구조:</strong> 데이터의 스키마(Schema)를 정의하는 IDL(Interface Definition Language) 구조체.</li>
<li><strong>QoS(Quality of Service):</strong> 데이터 전달의 신뢰성, 지속성 등을 정의하는 정책.4</li>
</ol>
<p>이 중에서 토픽 이름은 가장 먼저 확인되는 식별 키이다. 개발자는 토픽 이름을 지을 때 이것이 RPC(Remote Procedure Call)의 함수 이름이나 파일 시스템의 경로가 아니라, 관계형 데이터베이스(RDBMS)의 <strong>테이블 이름</strong>과 유사한 역할을 한다는 점을 인지해야 한다. 즉, 토픽은 특정 행위(Action)가 아닌 상태(State)를 저장하고 공유하는 공간을 의미한다.</p>
<h3>1.2  상태(State) 기반 명명 철학</h3>
<p>잘못된 토픽 설계의 대표적인 예는 동사(Verb)를 사용하는 것이다. 예를 들어 <code>SendCameraImage</code>나 <code>UpdatePosition</code>과 같은 이름은 명령형 프로그래밍의 잔재이다. DDS 환경에서는 <code>CameraImage</code>나 <code>VehiclePosition</code>과 같은 명사(Noun) 형태의 이름이 권장된다.6 이는 데이터가 시스템의 현재 상태를 나타내는 ’진실의 원천(Source of Truth)’임을 강조하며, 데이터가 언제, 누가 보냈는지와 무관하게 그 자체로 의미를 갖도록 한다.</p>
<h2>2.  물리적 제약 사항과 표준 준수</h2>
<p>이상적인 설계 원칙을 적용하기 전에, 현실적인 기술적 제약 사항을 이해해야 한다. OMG DDS API 표준과 실제 통신을 담당하는 RTPS 프로토콜 표준 사이에는 토픽 이름에 대한 미묘한 차이가 존재하며, 이는 이기종 시스템 간의 상호운용성 문제로 직결될 수 있다.</p>
<h3>2.1  길이 제한의 진실: 256자의 벽</h3>
<p>DDS API 표준(v1.4) 자체는 토픽 이름의 길이에 대해 명시적인 제한을 두지 않고 있다. 이론적으로는 메모리가 허용하는 한 무제한의 길이를 가질 수 있는 것처럼 보인다.4 그러나 시스템 간의 상호운용성을 보장하는 와이어 프로토콜인 RTPS(Real-time Publish-Subscribe) 명세는 이야기가 다르다.</p>
<p>RTPS 프로토콜은 패킷 헤더의 효율성과 임베디드 장치에서의 메모리 관리를 위해 토픽 이름 필드를 제한하는 경우가 많다. 특히 RTI Connext DDS, OpenDDS 등 주요 벤더의 구현체들은 RTPS 표준의 상호운용성 테이블(Table 9.12)을 준수하여 <strong>최대 256자</strong>의 길이 제한을 두고 있다.4</p>
<ul>
<li><strong>상호운용성 위험:</strong> 한 구현체가 256자를 초과하는 토픽 이름을 허용하더라도, 이를 다른 벤더의 구현체나 분석 도구(Analyzer), 혹은 제한된 메모리를 가진 임베디드 노드로 전송할 때 데이터가 잘리거나(Truncation) 통신 오류가 발생할 수 있다.</li>
<li><strong>ROS 2 연동 시의 주의점:</strong> ROS 2(Robot Operating System)는 DDS를 하부 미들웨어로 사용하며, 긴 네임스페이스 경로를 사용하는 경향이 있다(예: <code>/robot1/left_arm/joint3/position_controller/command</code>). 이러한 경로가 DDS로 매핑될 때 <code>rt/</code>와 같은 접두어가 추가되면서 256자 제한을 초과할 위험이 있으므로, 설계 단계에서 이름의 길이를 엄격히 관리해야 한다.8</li>
</ul>
<h3>2.2  문자셋(Character Set)과 인코딩</h3>
<p>토픽 이름은 기본적으로 ASCII 문자셋을 기반으로 한다. OMG DDS X-Types 명세 등은 문자 데이터에 대해 ISO-8859-1 (Latin-1) 또는 UTF-8을 언급하지만, 식별자로서의 토픽 이름은 POSIX 파일 시스템 경로 규칙이나 C++ 식별자 규칙을 따르는 것이 안전하다.9</p>
<ul>
<li><strong>권장 문자:</strong> 영문 대소문자(<code>A-Z</code>, <code>a-z</code>), 숫자(<code>0-9</code>), 그리고 구분자로서의 슬래시(<code>/</code>), 언더스코어(<code>_</code>), 하이픈(<code>-</code>).</li>
<li><strong>금지 및 주의 문자:</strong> 공백(Space)은 절대 사용해서는 안 되며, 일부 구현체나 툴에서 파싱 오류를 일으킬 수 있다. 또한 <code>*</code>, <code>?</code>, <code>[</code>, <code>]</code>와 같은 문자는 와일드카드 필터링 시 메타 문자(Meta-character)로 해석될 수 있으므로, 토픽 이름 자체에 포함하는 것은 지양해야 한다.10 유니코드(한글 등) 사용은 로컬 시스템 내에서는 작동할 수 있으나, 이기종 간 직렬화(Serialization) 과정에서 인코딩 불일치로 인한 예기치 않은 동작을 유발할 수 있으므로 피하는 것이 원칙이다.</li>
</ul>
<h2>3.  의미론적 구조화 전략</h2>
<p>토픽 이름은 시스템의 논리적 구조를 반영해야 한다. DDS의 평면적(Flat)인 토픽 공간을 인간이 인지하기 쉬운 계층적 구조로 조직화하는 전략이 필요하다.</p>
<h3>3.1  계층적 명명 규칙 (Hierarchical Naming)</h3>
<p>파일 시스템처럼 계층을 나누어 관리하는 것이 표준적인 관례이다. 구분자로는 슬래시(<code>/</code>)가 가장 널리 사용되며, 이는 POSIX 경로와 유사하여 개발자에게 익숙함을 제공한다.6</p>
<p>권장 패턴:</p>
<table><thead><tr><th><strong>계층 (Level)</strong></th><th><strong>설명</strong></th><th><strong>예시</strong></th></tr></thead><tbody>
<tr><td><strong>Domain/Scope</strong></td><td>전체 시스템 내의 대분류</td><td><code>Avionics</code>, <code>FactoryA</code>, <code>HospitalZone1</code></td></tr>
<tr><td><strong>Subsystem</strong></td><td>하드웨어 또는 논리적 모듈 단위</td><td><code>Navigation</code>, <code>Conveyor</code>, <code>ICU_Monitors</code></td></tr>
<tr><td><strong>Function/Category</strong></td><td>기능적 분류</td><td><code>GPS</code>, <code>Motor</code>, <code>Vitals</code></td></tr>
<tr><td><strong>Data Name</strong></td><td>구체적인 데이터의 의미 (명사)</td><td><code>Position</code>, <code>RPM</code>, <code>HeartRate</code></td></tr>
</tbody></table>
<p>이러한 계층 구조는 관리자가 시스템 전체의 데이터 흐름을 시각화하기 쉽게 만들고, 향후 설명할 파티션(Partition)이나 필터링 기능을 사용할 때 강력한 패턴 매칭을 가능하게 한다.6</p>
<h3>3.2  데이터 타입과 토픽 이름의 분리 (Decoupling)</h3>
<p>초보 개발자가 가장 흔히 범하는 안티 패턴 중 하나는 데이터 타입(Type)의 이름과 토픽(Topic)의 이름을 동일하게 강제하는 것이다. 예를 들어, <code>VideoFrame</code>이라는 IDL 구조체를 정의하고, 이를 전송하는 토픽 이름도 <code>VideoFrame</code>으로 고정하는 경우이다. 이는 DDS의 재사용성을 심각하게 저해한다.11</p>
<ul>
<li><strong>설계 원칙:</strong> 타입은 데이터의 **구조(Structure)**를 정의하고, 토픽은 데이터의 **문맥(Context)**을 정의한다.</li>
<li><strong>사례:</strong> <code>Temperature</code>라는 하나의 데이터 타입(float 값과 단위를 포함하는 구조체)은 <code>EngineTemperature</code>, <code>CabinTemperature</code>, <code>AmbientTemperature</code>라는 세 개의 서로 다른 토픽에서 재사용되어야 한다. 만약 토픽 이름을 타입 이름과 동일하게 한다면, 엔진 온도와 실내 온도를 구분하기 위해 <code>EngineTemperatureType</code>, <code>CabinTemperatureType</code>이라는 불필요한 중복 타입을 정의해야 하는 모순에 빠진다.</li>
</ul>
<p>따라서 토픽 이름은 해당 데이터가 시스템 내에서 수행하는 ’역할’을 반영해야 하며, 그 데이터가 어떤 ’형태’를 띠는지는 타입 정보에 맡겨야 한다.</p>
<h2>4.  논리적 격리: 파티션(Partition) 대 토픽 계층</h2>
<p>토픽 이름을 통한 계층화는 직관적이지만, 런타임에 구조를 변경하기 어렵다는 단점이 있다. 예를 들어, <code>RoomA/Sensor</code>라는 토픽을 <code>RoomB/Sensor</code>로 변경하려면, 퍼블리셔와 서브스크라이버의 코드를 수정하거나 재설정 후 엔드포인트를 다시 생성해야 한다. DDS는 이를 보완하기 위해 **파티션(Partition)**이라는 강력한 논리적 격리 메커니즘을 QoS 정책으로 제공한다.12</p>
<h3>4.1  파티션의 개념과 매커니즘</h3>
<p>파티션은 도메인 참여자(DomainParticipant), 퍼블리셔(Publisher), 서브스크라이버(Subscriber) 레벨에서 설정할 수 있는 문자열 리스트이다. 데이터가 전달되기 위해서는 토픽 이름이 일치해야 할 뿐만 아니라, 퍼블리셔와 서브스크라이버가 소속된 파티션 문자열 중 **하나라도 일치(Intersection)**해야 한다.10</p>
<ul>
<li><strong>유연성:</strong> 파티션 QoS는 런타임에 동적으로 변경 가능하다. 이는 엔드포인트를 삭제하고 다시 생성하는 무거운 작업 없이, 데이터의 흐름을 즉시 제어할 수 있음을 의미한다.12</li>
<li><strong>와일드카드 지원:</strong> 파티션 이름에는 <code>*</code>, <code>?</code>와 같은 와일드카드나 POSIX <code>fnmatch</code> 스타일의 정규 표현식을 사용할 수 있다. 예를 들어, 서브스크라이버가 <code>ZoneA/*</code> 파티션에 가입하면, <code>ZoneA/Section1</code>, <code>ZoneA/Section2</code> 등 해당 패턴에 매칭되는 모든 퍼블리셔로부터 데이터를 수신할 수 있다.10</li>
</ul>
<h3>4.2  설계 트레이드오프: 언제 무엇을 사용할까?</h3>
<p><strong>표 4.1-1: 토픽 이름 내 구분과 파티션 QoS 비교</strong></p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>토픽 이름에 계층 포함 (예: RoomA/Temp)</strong></th><th><strong>파티션 QoS 사용 (예: Topic: Temp, Partition: RoomA)</strong></th></tr></thead><tbody>
<tr><td><strong>주요 목적</strong></td><td>데이터의 <strong>종류(Type/Meaning)</strong> 구분</td><td>데이터의 <strong>범위(Scope/Location)</strong> 구분</td></tr>
<tr><td><strong>통신 매칭</strong></td><td>이름이 정확히 일치해야 함</td><td>토픽 이름 일치 AND 파티션 교집합 존재</td></tr>
<tr><td><strong>런타임 변경</strong></td><td>불가능 (엔드포인트 재생성 필요 - 비용 높음)</td><td>가능 (메타데이터 업데이트 - 비용 낮음)</td></tr>
<tr><td><strong>와일드카드</strong></td><td>DDS 표준 구독 시 지원 미비 (별도 기능 필요)</td><td>파티션 매칭 시 강력한 와일드카드 지원</td></tr>
<tr><td><strong>메모리 사용</strong></td><td>각 토픽 이름별로 별도 리소스/히스토리 관리</td><td>동일 토픽 공유, 논리적 그룹만 분리</td></tr>
<tr><td><strong>권장 사례</strong></td><td><code>CameraImage</code>, <code>LidarScan</code> 등 데이터 성격이 다를 때</td><td><code>Floor1</code>, <code>Floor2</code> 등 같은 데이터를 구역별로 나눌 때</td></tr>
</tbody></table>
<p>결론적으로, 데이터의 **‘내용(Content)’**이 다르면 다른 토픽 이름을 사용하고, 데이터의 **‘배치(Deployment)’**나 **‘논리적 그룹(Logical Group)’**만 다르다면 동일한 토픽 이름을 사용하되 파티션으로 구분하는 것이 최적의 설계이다.14</p>
<h2>5.  데이터 입도(Granularity)와 검색(Discovery) 성능</h2>
<p>토픽 구조화에서 가장 까다로운 결정은 “얼마나 잘게 쪼갤 것인가”, 즉 입도(Granularity)의 문제이다. 이는 시스템의 성능, 특히 초기 기동 시의 검색(Discovery) 트래픽과 직결된다.</p>
<h3>5.1  세립도(Fine-grained) vs. 조립도(Coarse-grained)</h3>
<ul>
<li><strong>세립도 (Fine-grained):</strong> 각 데이터 항목마다 개별 토픽을 할당한다. (예: <code>Sensor/1/Voltage</code>, <code>Sensor/1/Current</code>)</li>
<li><em>장점:</em> 구독자가 필요한 데이터만 정확히 선택할 수 있어 대역폭 효율이 높다. 접근 제어(Security)를 정밀하게 설정할 수 있다.16</li>
<li><em>단점:</em> 토픽 수가 수천, 수만 개로 늘어날 수 있다.</li>
<li><strong>조립도 (Coarse-grained):</strong> 연관된 데이터를 하나의 구조체로 묶어 단일 토픽으로 발행한다. (예: <code>Sensor/1/Status</code> 토픽 내에 전압, 전류, 온도를 모두 포함)</li>
<li><em>장점:</em> 토픽 수가 줄어들어 관리가 용이하다. 데이터 간의 시간적 동기화(Atomicity)가 보장된다.18</li>
<li><em>단점:</em> 일부 데이터만 필요한 경우에도 전체 구조체를 수신해야 하므로 대역폭 낭비가 발생할 수 있다.</li>
</ul>
<h3>5.2  검색 포화(Discovery Saturation)와 성능 한계</h3>
<p>DDS의 표준 검색 프로토콜(SPDP/SEDP)은 모든 참여자가 자신이 가진 엔드포인트(DataWriter/DataReader) 정보를 네트워크상의 모든 참여자와 교환한다. 교환해야 할 메타데이터의 양은 대략 <span class="math math-inline">N_{participants} \times N_{endpoints}</span>에 비례한다.</p>
<p>토픽 수가 수천 개 이상으로 증가하면 ’Discovery Storm’이라 불리는 현상이 발생한다. RTI 등의 벤치마크 결과에 따르면, 토픽 수가 적을 때는 검색이 밀리초(ms) 단위로 완료되지만, 수천 개 단위가 되면 초(s) 단위로 지연되거나, 네트워크 버퍼 오버플로우로 인한 패킷 손실 및 재전송이 발생하여 CPU 사용률이 급증한다.20 특히, 각 토픽 이름 문자열이 모든 알림 패킷에 포함되므로, 긴 토픽 이름은 이 문제를 악화시킨다.23</p>
<h3>5.3  해결책: 토픽 키(Key)와 인스턴스(Instance)의 활용</h3>
<p>DDS는 이 딜레마를 해결하기 위해 <strong>키(Key)</strong> 개념을 제공한다. 수천 개의 센서에 대해 각각 <code>Sensor/1</code>, <code>Sensor/2</code>… 와 같이 별도의 토픽을 만드는 대신, <code>SensorReadings</code>라는 단일 토픽을 생성하고 데이터 구조체 내에 <code>sensor_id</code> 필드를 <code>@key</code>로 지정한다.</p>
<ul>
<li><strong>동작 원리:</strong> DDS는 동일한 토픽 내에서 키 값이 다른 데이터를 별도의 **인스턴스(Instance)**로 관리한다. 논리적으로는 수천 개의 채널이 존재하지만, 물리적인 토픽(및 검색 엔드포인트)은 하나뿐이므로 검색 트래픽이 획기적으로 감소한다.1</li>
<li><strong>구독 필터링:</strong> 특정 센서 데이터만 필요한 구독자는 <code>ContentFilteredTopic</code>을 사용하여 <code>sensor_id = 5</code>와 같은 필터 조건을 걸면, 미들웨어 레벨에서 필터링되어 네트워크 부하 없이 원하는 인스턴스만 수신할 수 있다.25</li>
</ul>
<p>따라서 대규모 시스템에서는 **“토픽은 데이터의 종류(Class)를 정의하고, 키(Key)는 데이터의 개체(Object)를 식별한다”**는 원칙을 따르는 것이 성능 최적화의 지름길이다.</p>
<h2>6.  고급 구독 패턴과 와일드카드 한계 극복</h2>
<p>많은 개발자가 MQTT의 <code>sports/tennis/#</code>와 같은 와일드카드 토픽 구독 기능을 DDS에서 기대한다. 그러나 DDS 표준은 기본적으로 토픽 이름에 대한 와일드카드 구독을 직접적으로 지원하지 않는다(즉, <code>create_datareader("Sensor/*")</code>와 같은 호출은 표준 API에 없다).27</p>
<h3>6.1  왜 지원하지 않는가?</h3>
<p>DDS는 정적 타입 강제(Static Type Safety)를 중시한다. <code>Sensor/*</code>에 매칭되는 토픽들이 서로 다른 데이터 타입을 가질 경우, 데이터 리더가 이를 처리할 방법이 모호해지기 때문이다. 또한, 모든 매칭되는 토픽에 대해 리더를 내부적으로 동적 생성하는 것은 실시간성(Real-time)을 저해할 수 있다.28</p>
<h3>6.2  대안: MultiTopic과 Built-in Topic 활용</h3>
<ul>
<li><strong>MultiTopic:</strong> 표준에 정의된 <code>MultiTopic</code> 기능은 여러 토픽의 데이터를 SQL 구문과 유사한 방식으로 결합하거나 선택할 수 있게 해주지만, 구현의 복잡성 때문에 모든 벤더가 이를 완벽하게 지원하지는 않는다.25</li>
<li><strong>Built-in Discovery Topics:</strong> 시스템 내의 모든 토픽 목록을 동적으로 알고 싶다면, DDS가 내부적으로 발행하는 <code>DCPSPublication</code>이나 <code>DCPSSubscription</code> 빌트인 토픽을 구독하여 메타데이터를 모니터링할 수 있다. 이를 통해 현재 존재하는 토픽 이름을 파악하고, 필요한 토픽에 대해 동적으로 리더를 생성하는 애플리케이션 로직을 구현할 수 있다.27</li>
</ul>
<p>하지만 가장 실용적인 해결책은 앞서 언급한 <strong>파티션 QoS</strong> 또는 **X-Types(Extensible Types)**의 상속 기능을 활용하여 타입 호환성을 유지하면서 유연성을 확보하는 것이다.9</p>
<h2>7.  상호운용성을 위한 토픽 명명 (ROS 2 및 FACE 표준)</h2>
<p>최근 DDS는 독립적으로 사용되기보다 ROS 2나 FACE와 같은 상위 프레임워크의 통신 계층으로 사용되는 경우가 많다. 이때는 해당 프레임워크의 명명 규칙을 DDS 토픽 이름에 매핑하는 규칙을 엄격히 준수해야 한다.</p>
<h3>7.1  ROS 2 (Robot Operating System) 매핑 규칙</h3>
<p>ROS 2는 DDS 토픽 이름 앞에 접두어(Prefix)를 붙여 네임스페이스를 관리한다.8</p>
<ul>
<li><strong>Topics:</strong> <code>rt/</code> 접두어 사용 (예: <code>rt/chatter</code>)</li>
<li><strong>Services:</strong> 요청은 <code>rq/</code>, 응답은 <code>rr/</code> 접두어 사용</li>
<li><strong>Parameters:</strong> <code>rp/</code> 접두어 사용</li>
</ul>
<p>DDS 툴을 사용하여 ROS 2 네트워크를 모니터링하거나, 비(非) ROS DDS 애플리케이션이 ROS 2 노드와 통신하려면, 반드시 이 접두어를 포함한 정확한 토픽 이름을 사용해야 한다. 또한 ROS 2의 노드 이름과 네임스페이스가 길어질 경우 DDS의 256자 제한에 걸리지 않도록 주의해야 한다.8</p>
<h3>7.2  FACE (Future Airborne Capability Environment) 표준</h3>
<p>국방 항공 소프트웨어 표준인 FACE는 TSS(Transport Services Segment) 계층을 통해 통신을 추상화한다. FACE 데이터 아키텍처는 개념적(Conceptual), 논리적(Logical), 플랫폼(Platform) 모델로 변환되는데, 최종적으로 DDS 토픽 이름은 FACE 설정 파일(Configuration)에 정의된 View나 Connection의 식별자와 매핑된다.32</p>
<p>FACE 환경에서는 개발자가 임의로 토픽 이름을 짓기보다, 시스템 통합(System Integration) 단계에서 정의된 구성 파일(DDS XML Configuration 등)을 통해 생성된 코드를 따르는 것이 일반적이다. 이 경우 토픽 이름은 FACE 인터페이스의 유니크 ID나 메시지 타입 이름을 포함하는 경우가 많다.34</p>
<h2>8.  안티 패턴(Anti-Patterns)과 설계 체크리스트</h2>
<p>마지막으로, 토픽 설계 시 반드시 피해야 할 안티 패턴들을 정리한다.11</p>
<ol>
<li><strong>God Topic (신 토픽):</strong> 시스템의 모든 데이터를 <code>GlobalData</code>라는 하나의 거대한 토픽과 Union 타입으로 처리하려는 시도. 이는 DDS의 필터링 효율성을 떨어뜨리고, 불필요한 직렬화/역직렬화 비용을 발생시킨다.</li>
<li><strong>동적 이름 생성 (Ephemeral Topics):</strong> <code>Log_20231027_120001</code>과 같이 시간에 따라 이름이 바뀌는 토픽을 지속적으로 생성하는 것. 이는 엔드포인트 생성/삭제의 반복으로 인한 CPU 부하와 검색 트래픽 폭주를 유발하여 시스템을 불안정하게 만든다. 시간 정보는 토픽 이름이 아닌 데이터 페이로드(Payload) 내에 포함되어야 한다.</li>
<li><strong>암호 같은 약어 사용:</strong> 대역폭 절약을 위해 <code>Avionics/GPS/Position</code> 대신 <code>A/G/P</code>와 같이 극단적인 약어를 사용하는 것. RTPS 프로토콜은 토픽 이름을 정수로 매핑하는 최적화를 수행하므로, 초기 검색 단계 이후에는 긴 이름이 대역폭에 영향을 주지 않는다. 가독성을 희생하면서 이름을 줄일 필요는 없다.</li>
</ol>
<p><strong>설계 체크리스트:</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
토픽 이름이 데이터의 ’상태(State)’를 명사형으로 표현하는가?</li>
<li><input disabled="" type="checkbox"/>
토픽 이름이 데이터 타입 이름과 분리되어 있는가?</li>
<li><input disabled="" type="checkbox"/>
전체 이름 길이가 256자를 넘지 않는가 (ROS 2 접두어 포함)?</li>
<li><input disabled="" type="checkbox"/>
유사한 데이터가 수천 개일 경우, 별도 토픽 대신 ’키(Key)’를 사용했는가?</li>
<li><input disabled="" type="checkbox"/>
논리적 격리를 위해 토픽 이름 변경 대신 파티션 QoS를 고려했는가?</li>
<li><input disabled="" type="checkbox"/>
이름에 공백이나 특수문자(와일드카드용 문자)가 포함되지 않았는가?</li>
</ul>
<p>성공적인 DDS 시스템은 코드를 작성하기 전, 칠판 위에서의 토픽 설계에서 시작된다. 4.1절에서 다룬 원칙들은 단순한 이름 짓기가 아니라, 시스템의 데이터 모델을 정의하고 효율적인 통신 구조를 수립하는 아키텍처링의 핵심 과정임을 기억해야 한다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>OMG Data-Distribution Service: Architectural Overview, https://d2vkrkwbbxbylk.cloudfront.net/sites/default/files/DDS_Architectural_Overview.pdf</li>
<li>Data-Centric Programming Best Practices: - RTI, https://www.rti.com/hubfs/docs/DDS_Best_Practices_WP.pdf</li>
<li>What Is DDS? - MATLAB &amp; Simulink - MathWorks, https://www.mathworks.com/help/dds/gs/dds-conceptual-overview.html</li>
<li>Limit on DDS topic names - Stack Overflow, https://stackoverflow.com/questions/27970321/limit-on-dds-topic-names</li>
<li>Data Distribution Service for Real-Time Systems Specification - Object Management Group (OMG), https://www.omg.org/spec/DDS/1.1/PDF/</li>
<li>Topic Hierarchy and Topic Architecture Best Practices - Solace, https://solace.com/blog/topic-hierarchy-best-practices/</li>
<li>Topic Name [DDS Foundation Wiki], https://www.omgwiki.org/ddsf/doku.php?id=ddsf:public:guidebook:06_append:glossary:t:topicname</li>
<li>Topic and Service name mapping to DDS - ROS2 Design, https://design.ros2.org/articles/topic_and_service_names.html</li>
<li>Extensible and Dynamic Topic Types for DDS - Object Management Group (OMG), https://www.omg.org/spec/DDS-XTypes/1.1/PDF</li>
<li>PARTITION QoS Parameter [DDS Foundation Wiki] - OMG Wiki, https://www.omgwiki.org/ddsf/doku.php?id=ddsf:public:guidebook:06_append:02_quality_of_service:partition</li>
<li>Don’t Force Topic Names to be the Same as Type Names | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/best-practices/dont-force-topic-names-be-same-type-names</li>
<li>3.2.5. Partitions — Fast DDS 2.14.5 documentation, https://fast-dds.docs.eprosima.com/en/2.14.x/fastdds/dds_layer/domain/domainParticipant/partition.html</li>
<li>RTI Connext Modern C++ API: dds::core::policy::Partition Class Reference - RTI Community, https://community.rti.com/static/documentation/connext-dds/7.4.0/doc/api/connext_dds/api_cpp2/classdds_1_1core_1_1policy_1_1Partition.html</li>
<li>
<ol start="2">
<li>Topics, Domains and Partitions — The Data Distribution Service Tutorial, https://download.zettascale.online/www/docs/OpenSplice/v6/html/ospl/DDSTutorial/topics-etc.html</li>
</ol>
</li>
<li>Advanced Tutorial Using QoS to Solve Real-World Problems - DDS Foundation, https://www.dds-foundation.org/sites/default/files/DDS_Advanced_Ttutorial_00-T5_Hunt-revised.pdf</li>
<li>Difference between Fine-Grained and Coarse-Grained SIMD Architecture - GeeksforGeeks, https://www.geeksforgeeks.org/computer-organization-architecture/difference-between-fine-grained-and-coarse-grained-simd-architecture/</li>
<li>Difference between Fine-Grained and Coarse-Grained SIMD Architecture - Tutorials Point, https://www.tutorialspoint.com/difference-between-fine-grained-and-coarse-grained-simd-architecture</li>
<li>Finding the Right Data Granularity in Data Modeling and Data Warehousing - Medium, https://medium.com/@sathishdba/finding-the-right-data-granularity-in-data-modeling-and-data-warehousing-19e4644c418a</li>
<li>Coarse-grained vs fine-grained [closed] - Stack Overflow, https://stackoverflow.com/questions/3766845/coarse-grained-vs-fine-grained</li>
<li>Maximum number of DDS Topics that may be created in a single DDS Domain, https://stackoverflow.com/questions/15005702/maximum-number-of-dds-topics-that-may-be-created-in-a-single-dds-domain</li>
<li>1.1.3. Discovery Performance — RTI Connext Performance Benchmarks 6.1.0 documentation - RTI Community, https://community.rti.com/static/documentation/performance/benchmarks/srcDoc/pro/6.1.0/core/discovery/discovery_performance.html</li>
<li>DDS Discovery very slow | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/content/forum-topic/dds-discovery-very-slow</li>
<li>Configuring Resource Limits in Connext DDS Micro - RTI Community, https://community.rti.com/kb/configuring-resource-limits-connext-dds-micro</li>
<li>What is the max. number of octets I can put into the topic_data for builtin topics? | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/kb/what-max-number-octets-i-can-put-topicdata-builtin-topics</li>
<li>Content-Subscription Profile - OpenDDS 3.34.0-dev, https://opendds.readthedocs.io/en/master/devguide/content_subscription_profile.html</li>
<li>Question about Content Filtered Topic | Data Distribution Service (DDS) Community RTI Connext Users, https://community.rti.com/forum-topic/question-about-content-filtered-topic</li>
<li>Subscribing to the built-in topic “DCPSTopic” in DDS - Stack Overflow, https://stackoverflow.com/questions/15295220/subscribing-to-the-built-in-topic-dcpstopic-in-dds</li>
<li>How to subscibe to group of similar DDS topics using wildcard - Stack Overflow, https://stackoverflow.com/questions/34370274/how-to-subscibe-to-group-of-similar-dds-topics-using-wildcard</li>
<li>Data Distribution Service (DDS) - Object Management Group (OMG), https://www.omg.org/spec/DDS/1.4/PDF</li>
<li>ROS2 + DDS: A Field Guide to Interoperability - RTI, https://www.rti.com/blog/ros2-dds-a-field-guide-to-interoperability</li>
<li>Doubt in ROS-2 design document about topics - Robotics Stack Exchange, https://robotics.stackexchange.com/questions/97927/doubt-in-ros-2-design-document-about-topics</li>
<li>FACE Standard for Avionics Software | Ansys, https://www.ansys.com/industries/face-standard-aviation-software</li>
<li>(PDF) Model-based Code Generation for the FACE™ Technical Standard FACE Transport Service Segment (TSS) Type Specific Code and Configuration File A rmy FA CE™ TIM Paper - ResearchGate, https://www.researchgate.net/publication/327346918_Model-based_Code_Generation_for_the_FACE_Technical_Standard_FACE_Transport_Service_Segment_TSS_Type_Specific_Code_and_Configuration_File_A_rmy_FA_CE_TIM_Paper</li>
<li>Applying Transport Services Segment (TSS) Concepts, https://www.omgwiki.org/face/lib/exe/fetch.php?media=wiki:interop-wg:applying_tss_concepts_rev_b_no_comments.pdf</li>
<li>Anti-Patterns vs. Patterns: What Is the Difference? – BMC Software | Blogs, https://www.bmc.com/blogs/anti-patterns-vs-patterns/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>