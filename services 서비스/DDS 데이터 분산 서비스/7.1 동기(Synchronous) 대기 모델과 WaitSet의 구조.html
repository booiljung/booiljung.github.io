<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:7.1 동기(Synchronous) 대기 모델과 WaitSet의 구조</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>7.1 동기(Synchronous) 대기 모델과 WaitSet의 구조</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">데이터 분산 서비스 DDS</a> / <span>7.1 동기(Synchronous) 대기 모델과 WaitSet의 구조</span></nav>
                </div>
            </header>
            <article>
                <h1>7.1 동기(Synchronous) 대기 모델과 WaitSet의 구조</h1>
<p>데이터 분산 서비스(DDS, Data Distribution Service) 미들웨어는 물리적으로 분산된 노드 간의 비동기적 데이터 교환을 전제로 한다. 네트워크를 통해 데이터가 언제 도착할지, 시스템의 상태가 언제 변화할지는 예측 불가능한 영역에 속한다. 그러나 실시간 시스템(Real-Time System) 애플리케이션은 이러한 비동기적 사건들을 결정론적(Deterministic)인 제어 흐름 내에서 처리해야 하는 요구사항을 갖는다. DDS 표준은 이러한 비동기적 이벤트를 동기적 실행 흐름으로 변환하여 애플리케이션이 주도권을 가지고 데이터를 처리할 수 있도록 돕는 강력한 메커니즘을 제공하는데, 이것이 바로 <strong>WaitSet</strong>과 <strong>Condition</strong> 모델이다.1</p>
<p>본 7.1절에서는 DDS 사양(Specification)이 정의하는 동기 대기 모델의 철학적 배경부터, <code>WaitSet</code> 클래스의 내부 아키텍처, 다양한 <code>Condition</code> 객체들의 상호작용, 그리고 리스너(Listener) 모델과의 심층적인 비교 분석을 통해 고성능 분산 시스템에서의 이벤트 처리 전략을 상세히 기술한다.</p>
<h2>1.  비동기 통신과 동기적 제어의 딜레마</h2>
<p>분산 시스템 설계에 있어 가장 근본적인 난제는 ’시간(Time)’과 ’공간(Space)’의 분리다. 발행자(Publisher)는 구독자(Subscriber)가 언제 데이터를 소비할지 알 수 없으며, 구독자는 데이터가 언제 도착할지 알 수 없다. 이러한 불확실성 속에서 애플리케이션이 데이터를 인지하는 방식은 크게 두 가지로 대별된다.</p>
<ol>
<li><strong>비동기 알림(Asynchronous Notification):</strong> 미들웨어가 데이터 도착 즉시 애플리케이션의 코드를 호출(Callback)하는 방식. DDS의 <code>Listener</code>가 이에 해당한다.</li>
<li><strong>동기 대기(Synchronous Wait):</strong> 애플리케이션이 자신의 실행 흐름을 멈추고 특정 사건이 발생할 때까지 대기하는 방식. DDS의 <code>WaitSet</code>이 이에 해당한다.2</li>
</ol>
<p>리스너 방식은 반응성(Responsiveness) 측면에서 우수해 보일 수 있으나, 미들웨어의 내부 스레드 컨텍스트에서 애플리케이션 로직이 실행된다는 위험성을 내포한다. 이는 데드락(Deadlock)이나 자원 경합(Race Condition)을 유발할 수 있는 치명적인 요인이 된다.3 반면, 동기 대기 모델은 운영체제의 입출력 다중화(I/O Multiplexing) 모델인 <code>select()</code>나 <code>poll()</code>과 유사한 철학을 공유하며, 애플리케이션이 명시적으로 제어권을 행사할 수 있는 안전한 환경을 제공한다. <code>WaitSet</code>은 단순한 대기 도구가 아니라, 비동기적인 네트워크 이벤트를 동기적인 애플리케이션 로직으로 변환해 주는 **임피던스 매처(Impedance Matcher)**로서 기능한다.5</p>
<h2>2.  WaitSet 클래스의 아키텍처 및 위상</h2>
<p>OMG DDS 표준 명세(Specification)에서 <code>WaitSet</code>은 애플리케이션과 미들웨어 간의 상호작용을 중재하는 독립적인 인터페이스로 정의된다. 구조적으로 <code>WaitSet</code>은 <code>Condition</code> 객체들을 담는 컨테이너이자, 이들의 상태 변화를 감지하여 스레드의 블로킹(Blocking)을 해제하는 신호기 역할을 수행한다.</p>
<h3>2.1  클래스 상속 계층과 독립성</h3>
<p>DDS의 대부분의 주요 객체들(<code>Topic</code>, <code>DataReader</code>, <code>DataWriter</code> 등)은 <code>Entity</code> 클래스를 상속받아 QoS(Quality of Service) 정책과 <code>Listener</code>, <code>StatusCondition</code>을 포함하는 구조를 가진다. 그러나 <code>WaitSet</code>은 <code>Entity</code>를 상속받지 않는 독립적인 객체다.1 이는 <code>WaitSet</code>이 도메인 참여자(<code>DomainParticipant</code>)나 데이터 통신 자체에 종속된 존재가 아니라, 애플리케이션의 실행 흐름을 제어하기 위한 별도의 유틸리티임을 시사한다.</p>
<p>하지만 구현 관점(Platform Specific Model, PSM)에서 <code>WaitSet</code>은 일반적으로 팩토리 패턴이 아닌 직접적인 할당(예: <code>new WaitSet()</code>)을 통해 생성되며, 이는 <code>WaitSet</code>이 특정 도메인에 묶이지 않고 여러 도메인 참여자 간의 이벤트를 통합 관리할 수 있음을 의미한다.7</p>
<h3>2.2  WaitSet과 Condition의 관계성 (Association)</h3>
<p><code>WaitSet</code>과 <code>Condition</code>은 <strong>N:M (다대다)</strong> 관계를 맺을 수 있는 구조를 가진다.</p>
<ul>
<li><strong>1개의 WaitSet에 N개의 Condition:</strong> 애플리케이션은 하나의 스레드에서 ‘데이터 도착(ReadCondition)’, ‘네트워크 단절(StatusCondition)’, ‘종료 신호(GuardCondition)’ 등 서로 다른 성격의 이벤트를 동시에 감시할 수 있다.</li>
<li><strong>1개의 Condition을 M개의 WaitSet에 부착:</strong> 이론적으로는 가능하나, 실제 구현 및 스레드 안전성 문제로 인해 권장되지 않거나 제한될 수 있다. 특히 동일한 <code>WaitSet</code>에 대해 여러 스레드가 동시에 <code>wait()</code>를 호출하는 것은 금지되어 있다(Not allowable).9</li>
</ul>
<h3>2.3  블로킹(Blocking)과 언블로킹(Unblocking) 메커니즘</h3>
<p><code>WaitSet</code>의 핵심 연산인 <code>wait()</code>는 호출한 스레드를 <strong>블로킹(BLOCKED)</strong> 상태로 전환시킨다. 블로킹은 CPU 사이클을 소모하지 않는 대기 상태(Sleep)를 의미하며, 이는 OS 레벨의 동기화 원시(Primitive)인 세마포어(Semaphore)나 조건 변수(Condition Variable)를 통해 구현된다.10</p>
<p>스레드가 <code>WaitSet</code>의 장벽(Barrier)을 넘어 <strong>언블로킹(UNBLOCKED)</strong> 되는 조건은 다음과 같다.</p>
<ol>
<li><strong>조건 충족(Triggered):</strong> 부착된 <code>Condition</code> 중 하나 이상의 <code>trigger_value</code>가 <code>TRUE</code>로 전이되었을 때.</li>
<li><strong>타임아웃(Timeout):</strong> <code>wait()</code> 호출 시 인자로 전달한 <code>Duration_t</code> 시간이 경과했을 때.</li>
<li><strong>수동 해제:</strong> 다른 스레드에서 <code>GuardCondition</code> 등을 통해 강제로 <code>trigger_value</code>를 변경했을 때.9</li>
</ol>
<p>이러한 메커니즘은 **리액터 패턴(Reactor Pattern)**의 전형적인 구현이다. <code>WaitSet</code>은 여러 이벤트 소스를 디멀티플렉싱(Demultiplexing)하여, 이벤트가 발생한 구체적인 <code>Condition</code> 객체들의 목록(<code>active_conditions</code>)을 반환하고, 애플리케이션은 이 목록을 순회하며 적절한 핸들러를 실행한다.11</p>
<h2>3.  Condition 클래스 계층 구조와 트리거 원리</h2>
<p><code>Condition</code>은 모든 대기 가능한 조건들의 최상위 추상 인터페이스(Root Interface)이다. 모든 <code>Condition</code> 객체는 <code>get_trigger_value()</code>라는 연산을 가지며, 이는 현재 조건이 충족되었는지 여부를 <code>Boolean</code> 값으로 반환한다.1 DDS 표준은 이를 상속하는 구체적인 조건 클래스들을 정의하여 다양한 유형의 이벤트를 처리한다.</p>
<h3>3.1  StatusCondition: 통신 상태 변화의 감지</h3>
<p><code>StatusCondition</code>은 <code>Entity</code>(<code>DataReader</code>, <code>DataWriter</code>, <code>Topic</code>, <code>DomainParticipant</code>)와 1:1로 결합된 조건 객체다. 각 <code>Entity</code>는 통신과 관련된 다양한 상태(Status)를 가지며, <code>StatusCondition</code>은 이러한 상태 변화를 감지하여 <code>WaitSet</code>을 깨운다.15</p>
<ul>
<li><strong>동작 원리:</strong> <code>StatusCondition</code>의 <code>trigger_value</code>는 엔티티의 **변경된 상태 플래그(ChangedStatusFlag)**들과 사용자가 설정한 **활성화 마스크(EnabledStatuses)**의 논리적 AND 연산 결과에 의존한다. 즉, 사용자가 관심을 가진 상태(Mask)에 변화가 생겼을 때만 트리거된다.</li>
<li><strong>레벨 트리거(Level-Triggered) 특성:</strong> <code>StatusCondition</code>은 상태가 변경된 사실이 해소(Reset)되지 않는 한 <code>TRUE</code> 상태를 유지한다. 예를 들어, <code>DATA_AVAILABLE_STATUS</code>가 트리거 되어 <code>WaitSet</code>이 반환되었으나 애플리케이션이 데이터를 읽지 않고 다시 <code>wait()</code>를 호출하면, 조건이 여전히 참이므로 즉시 반환된다(Busy Loop 발생). 따라서 개발자는 반드시 데이터를 읽거나(Read/Take), <code>get_status_changes()</code> 등을 호출하여 상태를 명시적으로 초기화해야 한다.9</li>
<li><strong>설정 API:</strong> <code>set_enabled_statuses()</code> 연산을 통해 감시하고자 하는 상태(예: 데이터 도착, 데드라인 위반, 구독자 매칭 등)를 선택적으로 활성화할 수 있다.18</li>
</ul>
<h3>3.2  ReadCondition: 데이터 중심의 정교한 제어</h3>
<p><code>StatusCondition</code>의 <code>DATA_AVAILABLE_STATUS</code>가 단순히 “데이터가 도착했다“는 사실만을 알려준다면, <code>ReadCondition</code>은 **“어떤 상태의 데이터가 있는가”**를 구체적으로 필터링하여 대기할 수 있게 해준다. <code>ReadCondition</code>은 <code>DataReader</code>에 특화된 조건으로, 데이터의 생명주기 상태를 기반으로 트리거 여부를 결정한다.12</p>
<p><code>ReadCondition</code>은 다음 세 가지 상태 마스크(Mask)의 조합으로 정의된다:</p>
<ol>
<li><strong>SampleState:</strong> 데이터가 이전에 읽혔는가? (<code>READ</code>, <code>NOT_READ</code>)</li>
<li><strong>ViewState:</strong> 이 인스턴스에 대한 첫 번째 갱신인가? (<code>NEW</code>, <code>NOT_NEW</code>)</li>
<li><strong>InstanceState:</strong> 데이터 인스턴스가 유효한가? (<code>ALIVE</code>, <code>NOT_ALIVE_DISPOSED</code>, <code>NOT_ALIVE_NO_WRITERS</code>)</li>
</ol>
<p><strong>활용 예시:</strong></p>
<blockquote>
<p><code>NOT_READ_SAMPLE_STATE</code> + <code>NEW_VIEW_STATE</code> + <code>ALIVE_INSTANCE_STATE</code></p>
<p>위 조합으로 <code>ReadCondition</code>을 생성하면, “아직 읽지 않았고, 이 리더가 처음 보는 인스턴스이며, 살아있는 상태“의 데이터가 도착했을 때만 <code>WaitSet</code>을 깨운다. 이미 읽은 데이터나 종료된 인스턴스 정보는 무시하므로 불필요한 웨이크업(Wake-up)을 방지하고 CPU 효율을 극대화한다.20</p>
</blockquote>
<h3>3.3  QueryCondition: 콘텐츠 기반 필터링 (Content-Based Filtering)</h3>
<p><code>QueryCondition</code>은 <code>ReadCondition</code>을 상속받는 특수 형태로, 데이터의 메타데이터(상태)뿐만 아니라 **데이터의 내용(Content/Payload)**까지 검사하여 트리거 여부를 결정한다.19 이는 SQL의 <code>WHERE</code> 절과 유사한 문법을 사용하여 필터 표현식(Filter Expression)을 정의한다.</p>
<ul>
<li><strong>필터링 메커니즘:</strong> 수신된 데이터가 역직렬화되어 캐시에 저장된 후, <code>QueryCondition</code>에 정의된 표현식(Expression)을 평가한다. 표현식이 <code>TRUE</code>일 때만 해당 조건의 <code>trigger_value</code>가 <code>TRUE</code>로 전환된다.</li>
<li><strong>동적 파라미터:</strong> 쿼리 표현식은 <code>%0</code>, <code>%1</code>과 같은 위치 지정 파라미터를 포함할 수 있으며, <code>set_query_parameters()</code>를 통해 런타임에 동적으로 필터 기준을 변경할 수 있다. 이는 재컴파일 없이 필터 로직을 변경할 수 있는 유연성을 제공한다.23</li>
<li><strong>ContentFilteredTopic과의 차이:</strong></li>
<li><strong>ContentFilteredTopic:</strong> 송신 측(Writer) 또는 네트워크 레벨에서 데이터를 필터링하여 수신 측으로 전송되는 데이터 양 자체를 줄인다(Network Bandwidth 절약).</li>
<li><strong>QueryCondition:</strong> 수신 측(Reader) 캐시에 이미 도착한 데이터 중, 애플리케이션이 지금 당장 처리하고 싶은 데이터만 선별하여 접근(View)한다(Application Logic 제어). <code>WaitSet</code>은 <code>QueryCondition</code>을 통해 데이터의 내용에 따라 선택적으로 깨어날 수 있다.25</li>
</ul>
<p><strong>[표 7.1-1] DDS 쿼리 및 필터 표현식 지원 연산자 요약</strong> 26</p>
<table><thead><tr><th><strong>카테고리</strong></th><th><strong>연산자</strong></th><th><strong>예시</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>비교 연산자</strong></td><td><code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td><code>x &gt; 100</code>, <code>id &lt;&gt; 5</code></td><td>기본 수치 및 문자열 비교</td></tr>
<tr><td><strong>논리 연산자</strong></td><td><code>AND</code>, <code>OR</code>, <code>NOT</code></td><td><code>a &lt; 10 AND b &gt; 5</code></td><td>조건 결합</td></tr>
<tr><td><strong>범위/집합</strong></td><td><code>BETWEEN</code>, <code>IN</code></td><td><code>x BETWEEN 1 AND 10</code></td><td><code>IN ('RED', 'BLUE')</code></td></tr>
<tr><td><strong>문자열 매칭</strong></td><td><code>LIKE</code></td><td><code>name LIKE 'M%'</code></td><td>와일드카드(%, _) 지원</td></tr>
<tr><td><strong>파라미터</strong></td><td><code>%0</code>, <code>%1</code>,…</td><td><code>val &gt; %0</code></td><td>런타임 동적 바인딩</td></tr>
</tbody></table>
<h3>3.4  GuardCondition: 사용자 정의 이벤트 및 흐름 제어</h3>
<p><code>GuardCondition</code>은 미들웨어의 내부 상태나 데이터 통신과 무관하게, 애플리케이션이 직접 제어할 수 있는 유일한 조건 객체다. 이는 주로 멀티스레드 환경에서 <code>WaitSet</code>에 대기 중인 스레드를 외부에서 깨워야 할 때 사용된다.18</p>
<ul>
<li><strong>주요 용도:</strong></li>
</ul>
<ol>
<li><strong>애플리케이션 종료:</strong> 대기 중인 스레드에게 종료 신호를 보내 안전하게 루프를 탈출시킬 때.</li>
<li><strong>설정 변경 알림:</strong> 런타임에 QoS가 변경되거나 모드 스위칭이 필요할 때.</li>
<li><strong>이벤트 통합:</strong> DDS 이외의 이벤트(예: 하드웨어 인터럽트, 타이머)를 DDS 이벤트 루프 안으로 통합하고자 할 때.</li>
</ol>
<ul>
<li><strong>동작:</strong> <code>set_trigger_value(TRUE)</code>를 호출하면 해당 조건이 부착된 모든 <code>WaitSet</code>이 즉시 언블로킹된다. 이는 유닉스의 파이프(Pipe)나 이벤트FD(eventfd)를 통한 시그널링과 유사한 역할을 수행한다.11</li>
</ul>
<h2>4.  WaitSet의 내부 동작 메커니즘과 상태 전이</h2>
<p><code>WaitSet</code>의 내부 동작은 운영체제 커널의 스케줄링 메커니즘과 밀접하게 연관되어 있다. 시스템 수준에서 보았을 때 <code>WaitSet</code>은 **이벤트 디스패처(Event Dispatcher)**이자 <strong>스레드 장벽(Thread Barrier)</strong> 역할을 동시에 수행한다.</p>
<h3>4.1  블로킹과 시그널링의 원자성 (Atomicity)</h3>
<p><code>WaitSet</code>은 스레드를 블로킹 상태로 만들 때 경쟁 상태(Race Condition)를 방지하기 위해 정교한 원자적 연산을 수행한다.</p>
<ol>
<li><strong>Wait 진입:</strong> <code>wait()</code>가 호출되면 먼저 현재 부착된 모든 조건들의 <code>trigger_value</code>를 검사한다.</li>
<li><strong>즉시 반환:</strong> 만약 이미 <code>TRUE</code>인 조건이 하나라도 있다면 블로킹 없이 즉시 반환된다.</li>
<li><strong>블로킹:</strong> 모든 조건이 <code>FALSE</code>라면, 스레드는 대기 큐(Wait Queue)에 등록되고 커널에 의해 재워진다(Sleep).</li>
<li><strong>시그널링:</strong> 데이터 도착 등으로 인해 미들웨어 스레드가 조건의 상태를 변경하면, 해당 조건이 부착된 <code>WaitSet</code>에 시그널을 보내 스레드를 깨운다. 이때, 여러 조건이 동시에 만족되더라도 스레드는 단 한 번만 깨어난다.1</li>
</ol>
<p>일부 문헌에서는 <code>WaitSet</code>을 “객체지향적인 <code>select()</code>“라고 표현하지만, 실제 구현(RTI Connext 등)에서는 <code>select()</code> 시스템 콜보다는 **바이너리 세마포어(Binary Semaphore)**나 **조건 변수(Condition Variable)**를 사용하여 더 가볍고 빠른 동기화를 구현하는 경우가 많다.11 이는 파일 디스크립터 제한(File Descriptor Limit)에 구애받지 않고 수천 개의 조건을 감시할 수 있게 한다.</p>
<h3>4.2  상태 전이 시나리오 (Trigger Propagation)</h3>
<p>DDS 구현체는 데이터가 네트워크로부터 도착하여 역직렬화(Deserialization)되고 <code>DataReader</code>의 캐시에 저장되는 순간, 관련된 <code>Condition</code>들의 <code>trigger_value</code>를 갱신한다.</p>
<ul>
<li><strong>전파 순서:</strong></li>
</ul>
<ol>
<li>데이터 수신 -&gt; <code>DataReader</code> 캐시 업데이트.</li>
<li><code>ReadCondition</code> / <code>QueryCondition</code> 평가 및 플래그 설정.</li>
<li><code>StatusCondition</code> (<code>DATA_AVAILABLE</code>) 플래그 설정.</li>
<li>연관된 <code>WaitSet</code>에 시그널 전송.</li>
<li><code>WaitSet</code> 대기 스레드 기상 (Wake-up).</li>
<li><code>wait()</code> 함수 반환 및 <code>active_conditions</code> 목록 전달.</li>
</ol>
<p>이 과정에서 중요한 점은 <strong>상태의 일관성</strong>이다. 스레드가 깨어난 직후 다른 스레드가 데이터를 가로채서(Take) 가져가 버릴 경우, <code>ReadCondition</code>은 다시 <code>FALSE</code>가 될 수 있다. 따라서 <code>WaitSet</code>이 반환한 <code>active_conditions</code> 목록에 있는 조건이라 할지라도, 실제 처리 시점에는 더 이상 유효하지 않을 수 있음을(예: 데이터 없음) 감안하고 로직을 작성해야 한다.12</p>
<h2>5.  동기 대기 모델의 구현 패턴 및 모범 사례</h2>
<p><code>WaitSet</code>을 올바르게 사용하는 것은 단순히 API를 호출하는 것을 넘어, 효율적이고 안전한 이벤트 루프를 설계하는 것이다. 실무에서 권장되는 주요 구현 패턴과 주의사항을 살펴본다.</p>
<h3>5.1  기본 대기 루프 (The Basic Wait Loop)</h3>
<p>가장 전형적인 사용 패턴은 무한 루프 내에서 <code>wait()</code>를 호출하고, 반환된 조건을 검사하여 데이터를 처리하는 방식이다.</p>
<p>C++</p>
<pre><code>// [코드 7.1-1] WaitSet을 이용한 기본 이벤트 루프 구조 (C++ 예시)
DDS::WaitSet* ws = new DDS::WaitSet();
ws-&gt;attach_condition(status_cond);
ws-&gt;attach_condition(read_cond);
DDS::ConditionSeq active_conditions;
DDS::Duration_t timeout = {1, 0}; // 1초 타임아웃

while (running) {
    DDS::ReturnCode_t ret = ws-&gt;wait(active_conditions, timeout);
    
    if (ret == DDS::RETCODE_OK) {
        for (int i = 0; i &lt; active_conditions.length(); ++i) {
            if (active_conditions[i] == status_cond) {
                // 상태 변경 처리 (예: Liveliness Lost)
                process_status_change();
            } else if (active_conditions[i] == read_cond) {
                // 데이터 처리: take_w_condition 사용 권장
                // ReadCondition에 부합하는 데이터만 효율적으로 인출
                reader-&gt;take_w_condition(data_seq, info_seq, DDS::LENGTH_UNLIMITED, read_cond);
                process_data(data_seq);
                reader-&gt;return_loan(data_seq, info_seq);
            }
        }
    } else if (ret == DDS::RETCODE_TIMEOUT) {
        // 주기적인 헬스 체크나 유지보수 작업 수행
        perform_maintenance();
    }
}
</code></pre>
<p>이 패턴에서 <code>take_w_condition()</code>을 사용하는 것이 중요하다. 일반적인 <code>take()</code>는 큐의 모든 데이터를 가져오지만, <code>take_w_condition()</code>은 해당 조건을 만족시킨(트리거한) 데이터만을 정확히 가져오므로 탐색 비용을 줄여준다.21</p>
<h3>5.2  다중 조건의 결합 논리 (AND vs OR)</h3>
<p>기본적으로 <code>WaitSet</code>에 부착된 조건들은 <strong>논리적 OR</strong> 관계로 동작한다. 즉, “조건 A 또는 조건 B가 참이면 깨어난다”. 그러나 특정 시나리오에서는 “조건 A와 조건 B가 모두 참일 때(AND)“만 처리하고 싶을 수 있다.</p>
<p>DDS 표준 API 자체는 <code>WaitSet</code> 레벨에서 AND 논리를 직접 지원하지 않는다. 이를 구현하기 위해서는 애플리케이션 레벨의 로직이 필요하다.8</p>
<ol>
<li><code>wait()</code>는 어느 하나라도 만족하면 반환된다.</li>
<li>반환 후 애플리케이션은 필요한 모든 조건이 <code>active_conditions</code> 목록에 포함되어 있는지, 또는 각 조건의 <code>get_trigger_value()</code>가 모두 <code>TRUE</code>인지 확인한다.</li>
<li>만족하지 않으면 다시 <code>wait()</code>를 호출한다. 이 경우 타임아웃을 짧게 주거나 폴링 방식으로 전환하는 전략이 필요할 수 있다.</li>
</ol>
<h3>5.3  GUI 및 메인 루프와의 통합 (Integration with Main Loops)</h3>
<p>GUI 애플리케이션(Qt, MFC, C# WPF 등)이나 게임 엔진은 자체적인 메인 이벤트 루프를 가지고 있다. 이 루프 내에서 블로킹 함수인 <code>wait()</code>를 호출하면 화면이 멈추는 현상(Freezing)이 발생한다. 따라서 <code>WaitSet</code>을 메인 스레드에서 직접 사용하는 것은 지양해야 한다.29</p>
<ul>
<li><strong>전용 스레드 전략(Worker Thread):</strong> 별도의 스레드를 생성하여 <code>WaitSet</code> 루프를 돌리고, 데이터가 수신되면 스레드 안전한 큐(Thread-safe Queue)나 시그널/슬롯(Qt의 경우) 메커니즘을 통해 GUI 스레드로 데이터를 전달해야 한다.</li>
<li><strong>0 타임아웃 폴링:</strong> <code>wait()</code>의 타임아웃을 0으로 설정하여 폴링(Polling) 방식으로 GUI 루프 내에 삽입할 수도 있다. 예를 들어 게임 루프의 <code>update()</code> 함수 내에서 체크하는 방식이다. 그러나 이는 빈번한 컨텍스트 스위칭과 시스템 콜을 유발하여 CPU 사용량을 증가시킬 수 있으므로 주의해야 한다.30</li>
</ul>
<h2>6.  WaitSet vs Listener: 심층 비교 및 선택 가이드</h2>
<p>개발자는 언제 <code>WaitSet</code>을 쓰고 언제 <code>Listener</code>를 써야 하는가? 이 질문은 시스템의 성능 요구사항, 안전성, 그리고 아키텍처의 복잡도에 따라 결정된다.</p>
<p><strong>[표 7.1-2] WaitSet 모델과 Listener 모델의 상세 비교 분석</strong> 3</p>
<table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Listener (비동기, Push)</strong></th><th><strong>WaitSet (동기, Pull)</strong></th></tr></thead><tbody>
<tr><td><strong>실행 주체</strong></td><td>미들웨어 내부 스레드</td><td>애플리케이션 소유 스레드</td></tr>
<tr><td><strong>알림 방식</strong></td><td>이벤트 발생 시 즉시 콜백 호출</td><td>애플리케이션이 준비되었을 때 수신</td></tr>
<tr><td><strong>반응 속도(Latency)</strong></td><td><strong>최저 (Lowest Latency)</strong>   컨텍스트 스위칭 없음</td><td>약간 높음   스레드 스케줄링 및 깨어남 비용 발생</td></tr>
<tr><td><strong>처리량(Throughput)</strong></td><td>높을 수 있으나 병목 위험 존재</td><td><strong>높음</strong>   데이터 배치(Batch) 처리에 유리</td></tr>
<tr><td><strong>안전성(Safety)</strong></td><td>낮음 (데드락 위험 높음)</td><td><strong>높음</strong> (스레드 분리 및 제어 용이)</td></tr>
<tr><td><strong>흐름 제어</strong></td><td>어려움 (Data Flood 시 오버헤드)</td><td>용이함 (Back-pressure 자연 발생)</td></tr>
<tr><td><strong>복잡도</strong></td><td>상대적으로 낮음 (단순 이벤트)</td><td>상대적으로 높음 (루프 및 조건 관리)</td></tr>
<tr><td><strong>주 사용처</strong></td><td>단순 로깅, 알람, 초저지연 반응</td><td>복잡한 데이터 처리, UI 연동, 다중 센서 융합</td></tr>
</tbody></table>
<p><strong>핵심 인사이트:</strong> 리스너 내부에서는 파일 I/O, 무거운 연산, 또는 다른 DDS 호출(특히 Write)을 수행해서는 안 된다. 이는 미들웨어의 수신 스레드를 차단하여 전체 통신 마비를 일으킬 수 있기 때문이다. 또한 리스너에서 뮤텍스(Mutex)를 잘못 사용하면 미들웨어 내부 락(Lock)과 얽혀 데드락이 발생할 확률이 매우 높다.4 반면 <code>WaitSet</code>은 애플리케이션 스레드에서 동작하므로 긴 연산을 수행하거나 블로킹 I/O를 수행해도 전체 통신 시스템에 영향을 주지 않는다. 따라서 복잡한 데이터 처리가 필요한 대부분의 실제 응용 프로그램에서는 <strong>WaitSet 모델이 아키텍처적으로 훨씬 견고하고 안전한 선택</strong>이다.</p>
<h2>7.  성능 최적화 및 고급 활용 전략</h2>
<p><code>WaitSet</code>을 활용하여 시스템의 성능을 극대화하기 위한 전략들은 다음과 같다.</p>
<h3>7.1  제로 카피(Zero-Copy)와 WaitSet</h3>
<p>대용량 데이터(예: 영상, 라이다 포인트 클라우드)를 처리할 때, <code>WaitSet</code>과 <code>take()</code> 연산을 결합하면 메모리 복사를 최소화할 수 있다. 일부 고성능 DDS 구현체(Iceoryx 기반 등)는 공유 메모리(Shared Memory)를 활용하며, <code>WaitSet</code>을 통해 데이터 포인터만을 전달받아 처리 후 반환(Return Loan)하는 방식을 지원한다. 이는 데이터 복사 오버헤드를 제거하여 처리량을 획기적으로 높인다.14</p>
<h3>7.2  배치 처리(Batch Processing)</h3>
<p>데이터가 매우 빈번하게 도착하는 경우, 매번 <code>WaitSet</code>이 깨어나는 것은 비효율적이다. QoS 설정을 통해 데이터를 배치(Batch)로 묶어 전송받거나, 애플리케이션 로직에서 <code>WaitSet</code>이 깨어난 후 <code>active_conditions</code>를 처리할 때 루프를 돌며 쌓여있는 데이터를 한꺼번에 가져오는(Take All) 전략을 사용하여 시스템 콜 호출 빈도를 줄여야 한다.</p>
<h2>8.  결론 및 제언</h2>
<p>7.1절에서 살펴본 바와 같이, 동기 대기 모델과 <code>WaitSet</code>은 DDS를 단순한 메시지 패싱 도구에서 고성능 이벤트 구동형 아키텍처(Event-Driven Architecture)의 핵심 컴포넌트로 격상시킨다. 리스너가 제공하는 즉각성에 현혹되기 쉽지만, 시스템의 규모가 커지고 로직이 복잡해질수록 <code>WaitSet</code>이 제공하는 **제어권의 명확성(Control Clarity)**과 **스레드 안전성(Thread Safety)**은 대체 불가능한 가치를 지닌다.</p>
<p>성공적인 DDS 시스템 설계를 위해 개발자는 다음 세 가지 원칙을 견지해야 한다.</p>
<ol>
<li><strong>역할의 분리:</strong> 단순 알림은 리스너로, 데이터 처리는 <code>WaitSet</code>으로 분리하여 설계하라.</li>
<li><strong>조건의 정교화:</strong> <code>ReadCondition</code>과 <code>QueryCondition</code>을 적극 활용하여 불필요한 웨이크업을 최소화하라.</li>
<li><strong>자원 관리의 철저함:</strong> <code>WaitSet</code>과 <code>Condition</code> 객체의 생명주기를 명확히 하고, 특히 멀티스레드 환경에서의 부착/탈착 시점을 엄격히 통제하라.</li>
</ol>
<p>이어지는 7.2절에서는 이러한 <code>WaitSet</code>을 활용하여 실제로 데이터를 읽고 처리하는 다양한 데이터 접근 패턴(<code>take</code> vs <code>read</code>, <code>Zero-Copy</code> 등)에 대해 구체적으로 다룰 것이다.</p>
<h2>9. 참고 자료</h2>
<ol>
<li>Data Distribution Service (DDS) - Object Management Group (OMG), https://www.omg.org/spec/DDS/1.4/PDF</li>
<li>OMG Data-Distribution Service: Architectural Overview, https://d2vkrkwbbxbylk.cloudfront.net/sites/default/files/DDS_Architectural_Overview.pdf</li>
<li>Use WaitSets, Except When You Need Extreme Latency, https://community.rti.com/best-practices/use-waitsets-except-when-you-need-extreme-latency</li>
<li>Package: DDS.Listener - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_ada/dds-listener.ads.html</li>
<li>NDDS Latency and Throughput - DDS Foundation, https://www.dds-foundation.org/sites/default/files/Evaluating_Performance_Publish_Subscribe_Platforms.pdf</li>
<li>DDS — Open Issues - OMG Issue Tracker, https://issues.omg.org/issues/spec/DDS</li>
<li>RTI Connext C API: Waitset Use Cases, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_c/group__DDSWaitsetExampleModule.html</li>
<li>WaitSet with Status Condition | Data Distribution Service (DDS …, https://community.rti.com/examples/waitset-status-condition</li>
<li>Package: DDS.WaitSet - RTI Community, https://community.rti.com/static/documentation/connext-dds/7.3.0/doc/api/connext_dds/api_ada/dds-waitset.ads.html</li>
<li>Waiting for Conditions - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/connext_dds_professional/users_manual/users_manual/Waiting_for_Conditions.htm</li>
<li>waiting on multiple filedescriptor/objects - RTI Community, https://community.rti.com/forum-topic/waiting-multiple-filedescriptorobjects</li>
<li>3.1.4. Conditions and Wait-sets - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/v2.6.10/fastdds/dds_layer/core/waitsets/waitsets.html</li>
<li>WaitSets and Conditions — Eclipse Cyclone DDS, 0.11.0, https://cyclonedds.io/docs/cyclonedds/latest/api/waitset.html</li>
<li>Overview - iceoryx.io, https://iceoryx.io/v1.0.2/getting-started/overview/</li>
<li>Tutorial on the OMG Data Distribution Service, http://www.dre.vanderbilt.edu/~gokhale/OMG_RTWS06/00-T1-1_Giddings.pdf</li>
<li>RTI Connext Java API: WaitSet Class Reference - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_java/classcom_1_1rti_1_1dds_1_1infrastructure_1_1WaitSet.html</li>
<li>Package: DDS.WaitSet - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_ada/dds-waitset.ads.html</li>
<li>RTI Connext C API: Conditions and WaitSets - RTI Community, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_c/group__DDSConditionsModule.html</li>
<li>Introduction to DDS - OpenDDS 3.27.0, https://opendds.readthedocs.io/en/dds-3.27/devguide/introduction_to_dds.html</li>
<li>3.1.4. Conditions and Wait-sets - 3.4.1 - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/3.x/fastdds/dds_layer/core/waitsets/waitsets.html</li>
<li>44.3 Accessing DDS Data Samples with Read or Take, https://community.rti.com/static/documentation/connext-dds/current/doc/manuals/connext_dds_professional/users_manual/users_manual/AccessingData_Samples_ReadTake.htm</li>
<li>20.1.4.1. DataReader - 3.4.1 - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/3.x/fastdds/api_reference/dds_pim/subscriber/datareader.html</li>
<li>How to Filter Topic Content : Query Conditions and Content Filtering, https://kbase.zettascale.tech/article/how-can-i-filter-my-topic-content/</li>
<li>DDS::QueryCondition Class Reference - Twin Oaks Computing, Inc, https://www.twinoakscomputing.com/documents/refman_html_4.0.10/CoreDX_DDS_CPP_Reference_4.0.10/classDDS_1_1QueryCondition.html</li>
<li>What is the difference between QueryConditions … - RTI Community, https://community.rti.com/kb/what-difference-between-queryconditions-and-contentfilteredtopics</li>
<li>3.5.9. The default SQL-like filter - 3.4.1 - eProsima Fast DDS, https://fast-dds.docs.eprosima.com/en/3.x/fastdds/dds_layer/topic/contentFilteredTopic/defaultFilter.html</li>
<li>RTI Connext Modern C++ API: Queries and Filters Syntax, https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_cpp2/group__DDSQueryAndFilterSyntaxModule.html</li>
<li>CoreDX Data Distribution Service: DDS::DataReader Class Reference, https://www.twinoakscomputing.com/documents/refman_html_3.6.8/CoreDX_DDS_CPP_Reference_3.6.8/classDDS_1_1DataReader.html</li>
<li>Qt and RTI DDS interaction—Need some guidance - Stack Overflow, https://stackoverflow.com/questions/17834696/qt-and-rti-dds-interaction-need-some-guidance</li>
<li>DDS Reader not dropping messages - java - Stack Overflow, https://stackoverflow.com/questions/60537723/dds-reader-not-dropping-messages</li>
<li>iceoryx2/ROADMAP.md at main - GitHub, https://github.com/eclipse-iceoryx/iceoryx2/blob/main/ROADMAP.md</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>