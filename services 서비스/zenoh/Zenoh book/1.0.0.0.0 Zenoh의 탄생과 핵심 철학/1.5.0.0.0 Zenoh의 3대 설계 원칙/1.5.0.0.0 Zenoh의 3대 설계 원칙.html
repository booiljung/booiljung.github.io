<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:1.5 Zenoh의 3대 설계 원칙</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>1.5 Zenoh의 3대 설계 원칙</h1>
                    <nav class="breadcrumbs"><a href="../../../../../index.html">Home</a> / <a href="../../../../index.html">서비스 (Services)</a> / <a href="../../../index.html">Zenoh</a> / <a href="../../index.html">제목:Zenoh</a> / <a href="../index.html">Chapter 1. Zenoh의 탄생과 핵심 철학</a> / <a href="index.html">1.5 Zenoh의 3대 설계 원칙</a> / <span>1.5 Zenoh의 3대 설계 원칙</span></nav>
                </div>
            </header>
            <article>
                <h1>1.5 Zenoh의 3대 설계 원칙</h1>
<p>사물인터넷(IoT), 에지 컴퓨팅(Edge Computing), 그리고 클라우드 네이티브 아키텍처가 융합되는 현대의 거대 분산 시스템은 과거의 통신 미들웨어가 감당하기 어려운 수준의 이질성과 복잡성을 띠고 있다. 수십 킬로바이트의 메모리만을 가진 초소형 마이크로컨트롤러부터 거대한 클라우드 데이터센터에 이르기까지, 컴퓨팅 자원은 그 어느 때보다 넓고 불규칙하게 분포되어 있다. 이러한 이른바 에지-투-클라우드(Edge-to-Cloud) 연속체(Continuum) 패러다임에서 데이터는 끊임없이 생성되고, 이동하며, 분산 저장되고, 실시간으로 연산된다. 기존의 시스템 설계자들은 이러한 데이터의 다차원적인 생애 주기를 처리하기 위해 MQTT, DDS(Data Distribution Service), 관계형 및 시계열 데이터베이스, 그리고 RPC(Remote Procedure Call) 등 목적이 각기 다른 수많은 프로토콜과 미들웨어를 복잡하게 엮어 사용해야만 했다. 이는 곧 전체 시스템 아키텍처의 복잡도 증가, 이기종 간 변환 과정에서의 네트워크 대역폭 및 컴퓨팅 자원 낭비, 그리고 개발 및 유지보수 비용의 기하급수적인 상승을 초래하는 근본적인 원인이 되었다.</p>
<p>이러한 시대적, 기술적 한계를 극복하기 위해 이클립스 재단(Eclipse Foundation) 산하에서 탄생한 차세대 통신 프로토콜이 바로 Zenoh(제노)다. Zenoh는 단순히 기존의 발행/구독(Publish/Subscribe) 메시징 큐의 성능을 소폭 개선한 파생 기술이 아니다. 이는 분산 시스템 내에서 데이터가 어떻게 존재하고, 어떻게 식별되며, 어떻게 소비되어야 하는지에 대한 근본적인 철학적 재해석이자 아키텍처의 혁신이다. 지능형 로봇의 자율 주행, 스마트 팩토리의 실시간 모션 제어, 거대한 산업용 디지털 트윈(Digital Twin)의 초정밀 동기화, 그리고 차세대 자율주행 차량의 데이터 플로우 프로그래밍에 이르기까지, 현대의 분산 애플리케이션이 공통적으로 요구하는 실시간성, 데이터 무결성, 신뢰성, 그리고 수평적/수직적 확장성을 단일 프레임워크 내에서 완벽하게 해결하기 위해 Zenoh는 세 가지 핵심 설계 원칙(3 Core Design Principles)을 기반으로 구축되었다.</p>
<p>본 절에서는 Zenoh의 전체 아키텍처와 글로벌 생태계를 관통하는 이 3대 설계 원칙을 심도 있게 해부한다. 이 세 가지 원칙은 첫째, 데이터의 물리적 위치와 상태에 무관하게 통일된 상호작용 인터페이스를 제공하는 <strong>‘우아한 데이터 추상화(Eloquent)’</strong>, 둘째, 초소형 제어 센서부터 글로벌 광대역 네트워크(WAN)까지 아우르는 <strong>‘극단적인 양방향 확장성(Scalable)’</strong>, 셋째, 대역폭과 컴퓨팅 자원의 물리적 한계에 도전하는 **‘제로 오버헤드와 예측 가능한 고성능(Fast &amp; Efficient)’**으로 요약된다.</p>
<hr />
<h2>1.  우아한 데이터 추상화 (Eloquent): 이동, 저장, 연산의 직교적 통합</h2>
<p>과거의 미들웨어 설계자들은 분산 시스템의 기능을 물리적 행위에 따라 엄격하게 분리하는 데 집중했다. 데이터가 네트워크를 타고 연속적으로 흐를 때는 메시지 브로커(MQTT, AMQP)나 실시간 데이터 분배 서비스(DDS)를 사용했고, 데이터를 영구적 또는 일시적으로 보관할 때는 관계형 데이터베이스나 분산 인메모리 캐시를 도입했으며, 원격의 함수를 실행하거나 특정 조건의 결과를 반환받을 때는 RPC나 RESTful HTTP API를 혼용했다. 그러나 Zenoh의 핵심 설계자들은 이러한 인위적인 프로토콜의 분리가 시스템의 본질적인 유연성을 심각하게 해치고, 에지 컴퓨팅 환경의 잠재력을 억압한다고 판단했다. 특히 네트워크 단절이 빈번하고, 연산 노드의 위치가 동적으로 변할 수 있는 멀티 홉 무선 에지 환경에서는 특정 프로토콜에 종속된 아키텍처가 치명적인 단일 장애점(SPOF)으로 작용할 수 있기 때문이다.</p>
<p>따라서 Zenoh의 첫 번째이자 가장 강력한 설계 원칙은 <strong>데이터 인 모션(Data in Motion, 이동 중인 데이터)</strong>, <strong>데이터 앳 레스트(Data at Rest, 저장된 데이터)</strong>, 그리고 **데이터 인 유즈(Data in Use, 연산 중인 데이터)**를 단일한 데이터 중심(Data-centric) 추상화 계층으로 완벽하게 통합하는 것이다.</p>
<h3>1.1  위치 투명성과 계층적 이름 기반의 데이터 접근</h3>
<p>이러한 통합의 출발점은 데이터를 어떻게 식별할 것인가에 대한 근본적인 접근 방식의 변화다. Zenoh는 데이터를 물리적인 네트워크 주소(IP 주소나 포트 번호)나 특정 서버의 위치로 식별하지 않는다. 대신, 계층적 리소스 이름인 키 표현식(URI-like Key Expression)을 통해 전역적으로 데이터를 식별한다. 예를 들어, 공장 내 특정 자율 이동 로봇(AMR)의 온도 센서 데이터는 <code>/bot-1/sensor/temperature</code>와 같은 명확한 문자열 경로를 가지며, 모든 데이터는 이 키(Key)와 그에 해당하는 값(Value), 즉 페이로드(Payload)의 쌍으로 표현된다.</p>
<p>이 단순명료한 <code>(이름, 값)</code> 쌍의 논리적 구조는 Zenoh가 데이터의 물리적 위치를 시스템 개발자로부터 완전히 추상화(Location-Transparent Abstraction)할 수 있게 하는 핵심 기제다. 데이터를 구독하거나 질의하는 클라이언트 애플리케이션은 해당 데이터가 현재 센서에서 실시간으로 스트리밍되고 있는지(Data in Motion), 원격의 클라우드 스토리지 플러그인에 안전하게 저장되어 있는지(Data at Rest), 혹은 요청이 도달한 시점에 특정 에지 노드에서 동적으로 계산되어 반환되는지(Data in Use) 전혀 알 필요가 없다. 오직 데이터의 ’이름’만을 통해 상호작용하며, 나머지는 Zenoh의 지능형 라우팅 계층이 투명하게 처리한다.</p>
<h3>1.2  Pub/Sub과 Query/Reply의 직교적 융합 메커니즘</h3>
<p>단일한 데이터 뷰(Unified Data View)를 제공하기 위해 Zenoh는 통신 패러다임의 두 가지 큰 축인 발행/구독과 질의/응답 프리미티브를 논리적 충돌 없이 우아하게(Eloquent) 융합했다.</p>
<ol>
<li><strong>Publish/Subscribe (발행/구독 모델):</strong> 데이터를 능동적으로 생산하여 해당 주제(Topic)에 관심이 있는 다수의 구독자에게 지연 시간 없이 효율적으로 밀어내는(Push) 이벤트 기반 메커니즘이다. 이는 센서의 텔레메트리 데이터, 차량의 주행 상태 업데이트, 드론의 실시간 영상 스트림 등 이동 중인 데이터(Data in Motion)를 다루는 데 최적화되어 있다. 동적 디스커버리 기능과 와이어 레벨의 배치(Batching)를 통해 수천 개의 노드에 동시에 데이터를 전파할 수 있다.</li>
<li><strong>Query/Reply (질의/응답 모델):</strong> 구독하지 않고 있던 과거의 데이터나 특정 시점의 상태가 필요할 때 명시적으로 데이터를 당겨오는(Pull) 메커니즘이다. 사용자는 와일드카드가 포함된 강력한 키 표현식(예: <code>/bot-*/sensor/*</code> 또는 <code>/building/1/**</code>)을 사용하여 분산된 네트워크 전체에 단일 질의를 던질 수 있다.</li>
</ol>
<p>특기할 만한 혁신은 Zenoh의 **<code>Queryable(질의 가능 객체)</code>**이라는 개념의 도입이다. 기존의 통신 프로토콜에서는 질의의 대상이 반드시 고정된 데이터베이스 서버여야 했다. 그러나 Zenoh에서는 네트워크 상의 어떤 노드든 특정 키 표현식에 대해 자신을 <code>Queryable</code>로 등록할 수 있다. 특정 키로 질의가 라우팅되어 들어왔을 때, 이 <code>Queryable</code>은 백엔드의 데이터베이스에서 과거의 데이터를 꺼내어 응답할 수도 있고(스토리지 기능), 센서 값을 즉시 읽어 복잡한 필터링 연산을 수행한 뒤 그 결과를 반환할 수도 있다(분산 연산 기능).</p>
<p>즉, 데이터의 저장(Storage) 및 조회 기능과 분산 컴퓨팅(RPC, 분산 Map-Reduce 패턴 등)이 모두 하나의 ’질의(Query)’라는 우아한 인터페이스로 흡수되는 것이다. 질의를 던지는 주체(Querier)는 대상의 수가 몇 개인지, 그것이 데이터베이스인지 연산 노드인지 알 필요가 없으며, Zenoh 라우터가 최적의 매칭 대상을 찾아 결과를 취합해 반환한다.</p>
<p><strong>단일 추상화 기반의 3대 데이터 생애주기 통합</strong></p>
<p><img src="/home/bijung/.config/Typora/typora-user-images/image-20260225144954224.jpg" alt="image-20260225144954224" /></p>
<p>Zenoh는 물리적 위치를 은닉한 키 표현식(Key Expression)을 사용하여 실시간 메시징, 스토리지 접근, 분산 연산을 단일 인터페이스로 융합한다.</p>
<h3>1.3  데이터 플로우 프로그래밍과 자율주행 아키텍처에의 응용</h3>
<p>이러한 고도의 데이터 추상화는 극도로 복잡한 시스템의 결합도를 획기적으로 낮춘다. 자율주행 시스템과 같이 안전성(Safety-critical)이 최우선시되는 애플리케이션에서는 센서 융합, 장애물 인식, 경로 계획 등의 연산이 파이프라인 형태로 끊임없이 이어져야 한다. 논문 <em>Facilitating distributed data-flow programming with Eclipse Zenoh: the ERDOS case</em>에서 상세히 기술하듯, 이러한 데이터 플로우 프로그래밍(Data-flow Programming) 패러다임을 에지 환경에 적용할 때 Zenoh의 통일된 추상화 모델은 눈부신 진가를 발휘한다.</p>
<p>ERDOS와 같은 자율주행 컴퓨팅 그래프 프레임워크에 Zenoh를 결합하면, 마이크로서비스(Operator) 간의 제어 메시지(Control Message)와 대용량 데이터 스트림(Data Stream)이 단일한 Zenoh 세션을 통해 완벽하게 라우팅된다. 과거에는 로컬 프로세스 간 통신(IPC)과 네트워크 원격 통신을 구분하여 개발해야 했으나, Zenoh 환경에서는 모든 연산 노드가 인프라의 복잡성으로부터 해방된다. 애플리케이션의 로직과 기반 네트워크의 물리적 토폴로지가 완전히 디커플링(Decoupling)됨으로써, 데이터 플로우의 선언적 정의, 클라우드 및 마이크로컨트롤러로의 유연한 배포, 그리고 실행 제어가 논리적으로 명확하게 분리될 수 있는 것이다. 이는 결과적으로 코드의 재사용성을 극대화하고 단일 책임 원칙(Single Responsibility Principle)을 인프라 레벨에서 구현할 수 있게 한다.</p>
<hr />
<h2>2.  극단적인 양방향 확장성 (Scalable): 스케일 다운과 스케일 아웃의 조화</h2>
<p>Zenoh의 두 번째 설계 원칙은 인프라의 규모나 하드웨어 성능, 네트워크 환경의 제약에 구애받지 않고 어디서나 일관되게 동작할 수 있는 ’극단적인 확장성(Extreme Scalability)’이다. 보통 IT 산업에서 미들웨어의 확장성이라 하면 수백만 대의 기기가 동시에 접속하여 엄청난 양의 메시지를 쏟아내는 클라우드 데이터센터 인프라의 ‘스케일 아웃(Scale-out)’ 기능만을 떠올리기 쉽다. 하지만 자율주행, 스마트 시티, 인더스트리얼 4.0으로 대변되는 완벽한 에지-투-클라우드 연속체를 구현하기 위해서는 성능이 극도로 제한된 말단의 딥 에지(Deep Edge) 센서 계층까지 제어권이 내려갈 수 있는 극단적인 ‘스케일 다운(Scale-down)’ 능력이 필수적으로 동반되어야 한다.</p>
<h3>2.1  초경량 풋프린트와 네트워크 레이어의 파괴</h3>
<p>Zenoh는 설계 초기부터 8비트 마이크로컨트롤러에서부터 거대한 멀티코어 서버 팜까지 모두를 단일 프로토콜 생태계로 포괄하도록 수학적으로 정밀하게 설계되었다. 최소 기능 구현체인 Zenoh-Pico(제노 피코)의 경우, 메모리 제약이 극심한 Atmel 8비트 마이크로컨트롤러(예: Arduino Uno 계열) 상에서 구동할 때 불과 300바이트(Bytes) 수준의 초경량 메모리 풋프린트만으로 온전한 퍼블리셔 및 서브스크라이버 동작을 수행할 수 있다. 이는 기존의 그 어떤 상용 분산 메시징 프로토콜(MQTT-SN, CoAP 등)도 쉽게 달성하지 못했던 극한의 경량화 수준이다.</p>
<p>또한, 하위 네트워크 레이어(OSI Layer)에 대한 의존성을 과감히 탈피했다. TCP/IP, UDP/IP, QUIC과 같은 인터넷 표준 전송 계층 위에서 동작하는 것은 기본이며, IP 스택조차 올리기 버거운 Serial 포트, Bluetooth Low Energy (BLE), OpenThread, 심지어 동일 기기 내의 초고속 프로세스 간 통신을 위한 Shared Memory(공유 메모리)와 Unix Domain Sockets에 이르기까지 OSI 2계층(Data Link)부터 4계층(Transport)을 모두 아우르는 다양한 환경에서 네이티브하게 구동된다. 특히 대역폭이 극도로 제한되고 연결 상태가 불안정한 LPWAN(Low-Power Wide-Area Network)이나 공장 내 음영 지역이 많은 멀티 홉 무선 네트워크, 다중 NAT를 거쳐야 하는 5G 셀룰러 링크 등 멀티캐스트(Multicast) 전송이 원천적으로 불가능하거나 패킷 손실률이 높은 네트워크에서도 강력한 회복성(Resilience)을 발휘한다.</p>
<h3>2.2  위상(Topology)의 자유: 라우터, 피어, 클라이언트의 유기적 결합</h3>
<p>네트워크 구조 측면에서 확장성의 또 다른 축은 네트워크 위상(Topology) 구성의 절대적인 자유도이다. 중앙 집중형 메시지 브로커(Broker)에 모든 데이터 트래픽이 집중되어 병목과 단일 장애점이 발생하는 기존 MQTT 아키텍처와 달리, Zenoh는 분산형 스마트 라우팅 엔진을 내장하고 있다. 물리적 노드는 네트워크 상에서의 역할과 컴퓨팅 자원의 여력에 따라 <code>Router</code>, <code>Peer</code>, <code>Client</code>의 세 가지 모드 중 하나로 동작하며 유기적인 위상을 형성한다.</p>
<table><thead><tr><th><strong>구성 모드 (Node Role)</strong></th><th><strong>주요 특징 및 기능</strong></th><th><strong>적용 시나리오</strong></th></tr></thead><tbody>
<tr><td><strong>Client (클라이언트)</strong></td><td>가장 경량화된 모드로, 다른 노드로 데이터를 라우팅하지 않음. 연결된 부모 라우터나 피어에게 통신을 전적으로 위임.</td><td>배터리로 구동되는 초경량 센서, 엔드포인트 IoT 기기, 스마트폰 앱</td></tr>
<tr><td><strong>Peer (피어)</strong></td><td>중앙 라우터 없이 서로 직접 연결되어 통신. 로컬 네트워크 내에서 최단 경로로 데이터를 교환하며 트래픽을 분산.</td><td>로봇 군집 통신, 동일 차량 내 다중 ECU 간 통신, 에지 서버 클러스터</td></tr>
<tr><td><strong>Router (라우터)</strong></td><td>다수의 클라이언트, 피어, 그리고 다른 라우터들을 연결하는 네트워크의 허브. 광역 네트워크 라우팅 및 스토리지 플러그인 호스팅을 수행.</td><td>클라우드 게이트웨이, 공장 중앙 관제 서버, 서로 다른 서브넷 간의 브릿지</td></tr>
</tbody></table>
<p>이러한 유연한 노드 역할을 바탕으로 Zenoh는 다음과 같은 복잡한 네트워크 토폴로지를 단일 시스템 내에 혼합하여 구축할 수 있다.</p>
<ul>
<li><strong>Mesh 및 Peer-to-Peer:</strong> 브로커 없이 에지 노드 간에 직접 1:1 세션을 맺어 통신함으로써 불필요한 네트워크 홉(Hop)을 줄이고 데이터 전송 지연(Latency)을 최소화한다.</li>
<li><strong>Routed 및 Brokered:</strong> 거대한 엔터프라이즈 환경이나 복잡한 NAT, 엄격한 방화벽 규정을 우회하여 클라우드와 에지를 연결해야 하는 경우, 계층적인 라우터를 트리(Tree) 형태로 배치하여 트래픽을 중앙 집중적으로 제어한다.</li>
<li><strong>Clique (완전 그래프):</strong> 특정 로컬 서브넷 내의 모든 노드가 서로 N:N으로 직접 연결되는 완전 그래프 형태를 지원하여, 단 하나의 노드만 살아남아도 통신이 유지되는 무결점 수준의 고가용성을 보장한다.</li>
</ul>
<p>이러한 위상 구성의 자유 덕분에, 인프라의 일부 라우터에 하드웨어 장애가 발생하더라도 Zenoh 네트워크 프로토콜은 백그라운드에서 신속하게 새로운 우회 경로를 탐색하여 동적으로 토폴로지를 재구성함으로써 전체 시스템의 통신 신뢰성을 굳건히 유지한다.</p>
<h3>2.3  다국어 생태계와 도메인 융합을 통한 아키텍처 확장</h3>
<p>Zenoh의 극단적 확장성은 단순히 하드웨어 스펙이나 네트워크 구조에만 국한되지 않고, 소프트웨어 개발 생태계 전반으로 폭넓게 뻗어나간다. Zenoh 프로토콜의 코어(Core)는 압도적인 런타임 성능과 메모리 안전성을 동시에 달성하기 위해 현대적인 시스템 프로그래밍 언어인 Rust로 작성되었다. 그러나 다양한 도메인의 수많은 개발자들이 각기 다른 이질적인 레거시 시스템을 하나의 거대한 네트워크로 매끄럽게 묶을 수 있도록 풍부한 다국어 바인딩(Native Language Bindings)을 공식적으로 제공한다. 이는 단순히 언어를 번역해 놓은 수준을 넘어, 각 기술 스택이 가지는 고유한 생태계를 Zenoh라는 단일 신경망으로 통합하는 아키텍처 확장의 핵심 기제로 작동한다.</p>
<ul>
<li><strong>Rust에서 Zenoh:</strong> Zenoh 아키텍처의 본질이자 심장이다. C/C++ 언어 수준의 극한의 속도를 내면서도, 컴파일 타임에 엄격한 소유권(Ownership) 및 대여(Borrowing) 모델을 적용하여 런타임 메모리 누수와 데이터 레이스(Data Race)를 원천 차단하는 Rust의 특성은, 미션 크리티컬한 자율주행 시스템이나 산업용 원자력 제어 시스템 등에 완벽히 부합한다. 특히 Rust 환경에서 Zenoh는 운영체제 커널 계층을 우회하는 제로 카피(Zero-Copy) 메모리 접근을 완벽히 지원한다. 이를 통해 4K 해상도의 대용량 비디오 스트림이나 고정밀 라이다(LiDAR) 포인트 클라우드 데이터를 로컬에서 전송할 때, 데이터 복사로 인해 발생하는 CPU 캐시 미스와 메모리 버스 오버헤드를 물리적 한계치까지 낮출 수 있다.</li>
<li><strong>C++에서 Zenoh:</strong> 자원 제약이 극심한 구형 임베디드 장비, 혹은 이미 수십 년간 C/C++로 방대하게 구축되어 수정이 불가능한 고성능 영상 처리 알고리즘 베이스라인과의 원활한 통합을 가능하게 한다. 전통적인 방위 산업체, 초정밀 로보틱스 모션 제어, 그리고 밀리초 단위의 지연이 수십억 원의 손실을 낳는 초고속 금융 트레이딩 시스템 등은 쓰레드 스케줄링부터 메모리 할당까지 예측 가능한 완벽한 제어권을 필요로 하며, Zenoh의 C++ 바인딩은 이러한 폐쇄적인 기존 시스템이 현대적인 클라우드 인프라와 단절 없이 소통할 수 있는 튼튼한 교량 역할을 수행한다.</li>
<li><strong>TypeScript에서 Zenoh:</strong> 에지 인프라에서 수집된 데이터가 최종 사용자(Human)에게 도달하는 가장 중요한 접점인 웹 대시보드 및 원격 관제 시스템의 아키텍처를 혁신한다. 과거에는 센서에서 발생한 MQTT 데이터를 웹 브라우저 화면에 띄우기 위해, 중간에 Node.js나 Python 서버를 두고 MQTT에서 WebSockets로 프로토콜을 변환하는 복잡한 백엔드 프록시(Proxy) 계층이 강제되었다. 그러나 비동기(Async) 이벤트 루프 통신에 최적화된 TypeScript 환경에서 Zenoh를 브라우저나 Node 런타임에서 직접 구동함으로써, 프론트엔드 개발자는 별도의 미들웨어 브릿지 서버 없이도 글로벌 분산 네트워크의 Pub/Sub 데이터를 네이티브하게 직접 구독하거나, 수만 킬로미터 밖의 에지 데이터베이스 노드에 직접 Query를 던져 응답을 받을 수 있다. 이는 진정한 의미의 엔드-투-엔드(End-to-End) 풀스택 인프라 확장을 의미한다.</li>
<li><strong>ROS2에서 Zenoh:</strong> 이 극단적인 확장성 원칙이 가장 눈부시게 활약하고 업계의 찬사를 받는 실전 무대다. 로보틱스 분야의 사실상 표준 운영체제인 ROS2(Robot Operating System 2)의 기본 통신 미들웨어로 채택된 DDS는 유선 이더넷 환경이나 엄격히 통제된 로컬 서브넷 네트워크에서는 훌륭하게 동작한다. 그러나 드론, 자율 배달 로봇, 농업용 자율 트랙터가 활동하는 Wi-Fi, 5G 셀룰러, 혹은 다중 서브넷이 얽힌 복잡한 무선 현장에서는 빈번한 멀티캐스트 탐색 패킷(Discovery Traffic Storm)의 폭주로 인해 네트워크가 마비되고 통신 단절이 발생하는 치명적 한계를 노출했다. Zenoh는 이 고질적인 문제를 해결하기 위해 ROS2의 RMW(ROS Middleware) 계층 하단에 직접 위치하거나 <code>Zenoh-Bridge-DDS</code> 플러그인을 제공하여, 불필요한 멀티캐스트 탐색 트래픽을 완벽히 억제하는 유니캐스트 기반의 스마트 라우팅과 레거시 연동을 동시에 제공한다. 그 결과 로봇 군집은 통제된 공장 내부를 벗어나 패킷 손실이 심한 광대역 네트워크(WAN)나 해수면 너머의 원격 텔레오퍼레이션(Tele-operation) 상황에서도 안정적이고 민첩하게 자율 주행과 협력 제어를 수행할 수 있게 되었다.</li>
</ul>
<hr />
<h2>3.  제로 오버헤드와 예측 가능한 고성능 (Fast &amp; Efficient): 시간과 공간의 극한 최적화</h2>
<p>분산 시스템에서 생성된 데이터를 패킷으로 캡슐화하고 네트워크의 여러 홉을 거쳐 라우팅하는 과정에는 필연적으로 데이터의 직렬화(Serialization), 프로토콜 헤더 부착, 운영체제 커널의 컨텍스트 스위칭, 그리고 버퍼 복사 등 부수적인 비용이 발생한다. Zenoh의 세 번째 핵심 설계 원칙인 ’제로 오버헤드와 예측 가능한 고성능(Zero Overhead &amp; High Performance)’은 이러한 부수적인 지연(Latency) 요소와 컴퓨팅 자원의 낭비를 현대 컴퓨터 과학이 허용하는 극한의 수준까지 제거하겠다는 Zenoh 설계진의 강력하고 선언적인 목표다.</p>
<h3>3.1  프로토콜 헤더 최적화의 한계 돌파와 대역폭 보존</h3>
<p>표준 이더넷이나 고속 Wi-Fi 환경을 넘어, LoRaWAN이나 BLE와 같이 대역폭이 극도로 협소한 협대역 네트워크 환경까지 아우르기 위해서는 네트워크 상에 실제로 전송되는 바이트(Byte) 수를 티끌 하나까지 최소화해야 한다. 전통적인 경량 IoT 메시징 프로토콜로 널리 쓰이는 MQTT만 하더라도, 패킷을 구성하기 위한 기본적인 제어 헤더에만 수 바이트가 소요되고 주제(Topic)를 나타내는 긴 문자열이 통신마다 반복적으로 전송되어야 한다. 그러나 Zenoh는 혁신적인 설계 기법을 동원하여 데이터 메시지 하나당 발생하는 최소 와이어 오버헤드(Minimal Wire Overhead)를 단 4~5바이트(Bytes) 수준으로 무자비하게 압축해 냈다.</p>
<p>이러한 경이로운 오버헤드 감소는 단순히 우수한 압축 알고리즘을 사용해서 얻은 결과가 아니다. 토폴로지 내부의 라우터와 피어 간에 초기 세션이 맺어질 때 긴 문자열 형태의 키 표현식(Key Expression)을 짧은 정수형 식별자(ID)로 동적으로 매핑하여 로컬에 캐싱하는 영리한 세션 프로토콜(Session Protocol) 설계의 결실이다.</p>
<p><strong>네트워크 통신 프로토콜별 최소 와이어 오버헤드 비교</strong></p>
<p><img src="/home/bijung/.config/Typora/typora-user-images/image-20260225145136820.jpg" alt="image-20260225145136820" /></p>
<p>Zenoh는 동적 데이터 압축과 식별자 매핑을 통해 최소4바이트의 통신 오버헤드만을 발생시킨다. 이는 현대적 무선네트워크나  배터리 구동형 센서의 수명 연장에 결정적인 역할을 한다.</p>
<h3>3.2  일괄 처리(Batching)와 무제한 크기를 위한 단편화(Fragmentation)</h3>
<p>네트워크의 물리적 처리량(Throughput)을 한계치까지 이끌어내기 위해 Zenoh 세션 레이어는 프로그래머의 개입 없이도 지능적인 와이어 레벨 일괄 처리(Wire-level Batching) 기능을 자동으로 수행한다. 초당 수천 번 발생하는 작은 센서의 온도 갱신 데이터 스트림을 패킷 단위로 개별 전송하게 되면 인터럽트 오버헤드로 인해 시스템이 마비될 수 있다. Zenoh는 이를 방지하기 위해 송신 큐(Buffer)에 쌓인 데이터를 하나의 최적화된 네트워크 프레임으로 영리하게 묶어 전송함으로써, 와이어 상의 실제 페이로드 대비 오버헤드 비율을 급격히 떨어뜨리고 전송 효율을 극대화한다.</p>
<p>반대로, 자율주행차의 전방 카메라가 생성하는 대용량 비디오 프레임이나, 수백만 개의 점으로 이루어진 라이다(LiDAR) 맵 데이터처럼 네트워크 인터페이스의 MTU(Maximum Transmission Unit)를 훌쩍 초과하는 거대한 데이터에 대해서는, 애플리케이션 계층에서의 복잡한 데이터 분할 작업 없이 프로토콜 하부에서 자체적으로 투명한 단편화 및 재조립(Fragmentation &amp; Reassembly) 메커니즘을 지원한다. 개발자는 마치 무제한 크기의 MTU를 가진 네트워크에 연결된 것처럼(Illusion of an unlimited MTU) 단 하나의 <code>put</code> 명령어로 거대한 데이터를 안전하게 전송할 수 있다.</p>
<h3>3.3  극단적 저지연 통신과 지능적인 혼잡 제어</h3>
<p>이러한 설계의 결과로, 속도 측면에서 Zenoh는 최적의 조건에서 최저 13마이크로초(13 <span class="math math-inline">\mu</span>s) 수준의 경이로운 종단 간 지연 시간(End-to-End Latency)을 기록하며, 단일 연결에서 최대 50Gbps에 달하는 엄청난 처리량을 거뜬히 감당해 낸다. 이는 고성능 컴퓨팅(HPC) 클러스터나 초를 다투는 금융권의 로우 레이턴시 고빈도 매매(HFT) 아키텍처에서나 볼 수 있는 경이로운 성능 수치로, 자율주행차의 긴급 제동 시스템(AEB) 제어나 다관절 로봇의 모션 제어, 그리고 디지털 트윈의 마이크로초 단위 상태 동기화 요구사항을 여유롭게 충족한다.</p>
<p>더욱 중요한 것은, 이러한 고성능이 시스템에 부하가 걸렸을 때도 일관되게 유지되어야 한다는 점이다. 이질적인 기기들이 혼재된 에지 환경에서는 고성능 서버(빠른 생산자)가 저성능 마이크로컨트롤러(느린 소비자)에게 막대한 데이터를 쏟아부을 때 메모리 고갈과 네트워크 붕괴가 발생할 수 있다. Zenoh는 이 문제를 해결하기 위해 ’신뢰성(Reliability)’과 ’혼잡 제어(Congestion Control)’의 개념을 철저히 분리하고 세밀한 제어권을 제공한다.</p>
<table><thead><tr><th><strong>제어 계층</strong></th><th><strong>기능 설명 및 제어 주체</strong></th><th><strong>Zenoh의 동작 방식</strong></th></tr></thead><tbody>
<tr><td><strong>신뢰성 (Reliability)</strong></td><td>메시지 유실 방지 및 재전송 요구</td><td>수신자(Receiver)가 결정. 데이터 특성에 따라 손실 허용 여부 설정. 홉-투-홉(Hop-to-hop) 또는 종단 간(End-to-end) 신뢰성 선택 가능.</td></tr>
<tr><td><strong>메모리 버퍼링 (Buffering)</strong></td><td>신뢰성을 유지하기 위한 큐 할당</td><td>중간 라우터 및 송신자가 기기의 가용 메모리에 맞춰 개별적으로 버퍼 크기를 할당하여 자원 고갈 방지.</td></tr>
<tr><td><strong>혼잡 제어 (Congestion Control)</strong></td><td>버퍼가 가득 찼을 때의 대응 전략</td><td>송신자(Sender)가 결정. 신규 메시지를 버릴 것인지(Drop), 아니면 송신 스레드를 차단할 것인지(Block) 동적으로 제어.</td></tr>
</tbody></table>
<p>이처럼 각 노드가 자신의 물리적 자원 한계에 맞춰 신뢰성 대기열의 크기를 조절하고 전략을 능동적으로 선택할 수 있기 때문에, Zenoh 네트워크 전체는 소수의 느린 노드에 의해 발목이 잡히는 현상(Head-of-Line Blocking) 없이 쾌적한 처리량을 일관되게 유지할 수 있다.</p>
<hr />
<h2>4.  지속 가능성을 위한 보완: 관측성 및 모니터링 생태계</h2>
<p>앞서 상세히 다룬 3대 핵심 설계 원칙(통일된 데이터 추상화, 극단적인 확장성, 제로 오버헤드와 고성능)이 완벽하게 작동하는 이상적인 프로토콜이라 할지라도, 실제 산업 현장에서 노드의 수가 수천, 수만 개 이상으로 확장되고 동적으로 생성 및 소멸을 반복하게 되면 전체 시스템은 관리자의 시야를 완전히 벗어난 거대한 블랙박스(Blackbox)가 될 위험을 내포하고 있다. 분산된 에지 노드의 건강 상태를 실시간으로 파악하고 네트워크 병목이나 하드웨어 장애를 선제적으로 대응하여 트러블슈팅(Troubleshooting)하기 위해서는 고도화된 텔레메트리(Telemetry) 및 관측성(Observability) 기능이 필수적이다.</p>
<p>여기서 Zenoh 설계자들에게 부여된 가장 큰 과제이자 딜레마는, ’관측성을 위한 모니터링 메커니즘 자체가 Zenoh의 가장 중요한 원칙인 제로 오버헤드(Zero Overhead) 원칙을 위배하거나 네트워크 대역폭을 낭비해서는 안 된다’는 점이었다.</p>
<h3>4.1  통신을 방해하지 않는 수동적 관측: Zenoh 모니터링</h3>
<p>일반적으로 클라우드 네이티브 시스템의 모니터링 아키텍처는 각 컴퓨팅 노드가 중앙의 무거운 모니터링 서버(예: Prometheus, Datadog 등)를 향해 수 초 단위로 지속적인 하트비트(Heartbeat) 신호와 무거운 메트릭 텍스트를 쏘아보내는 폴링(Polling) 또는 푸시(Push) 방식으로 이루어진다. 하지만 대역폭이 금보다 귀한 에지 무선 네트워크 환경에서 이러한 방식은 통신 채널을 심각하게 잠식하여 정작 중요한 비즈니스 데이터 전송을 지연시키는 주범이 된다.</p>
<p>Zenoh는 이러한 한계를 극복하기 위해 프로토콜 스택 자체에 내장된 극도로 가벼운 스카우팅(Scouting) 알고리즘과 라이브니스(Liveliness) 모니터링 기능을 제공한다.</p>
<ul>
<li><strong>스카우팅(Scouting):</strong> Zenoh 노드들은 중앙의 고정된 디스커버리 서버나 레지스트리(Registry) 없이도 멀티캐스트 핑(Multicast Ping)이나 영리한 유니캐스트 가십(Gossip) 프로토콜을 이용해 백그라운드에서 네트워크 내에 존재하는 다른 이웃 Zenoh 노드들을 능동적으로 발견한다. 이 과정은 지속적인 브로드캐스팅이 아니라 비동기적이고 간헐적으로 발생하도록 최적화되어 있어 디스커버리 트래픽 부하를 최소화한다.</li>
<li><strong>라이브니스 토큰(Liveliness Tokens):</strong> 모니터링의 대상을 노드 단위에서 더 잘게 쪼개어 ‘애플리케이션 리소스’ 단위로 세밀화했다. 특정 기능(예: 특정 로봇 팔의 제어 모듈)이 네트워크에 진입하거나 크래시로 인해 비정상적으로 이탈할 때, 전체 네트워크에 브로드캐스팅하는 대신 해당 리소스의 생존 상태에 명시적인 관심(Interest)을 등록해 둔 노드들에게만 상태 변화 이벤트가 즉시 통보된다.</li>
</ul>
<p>또한, 구독자와 발행자 간의 스마트 매칭(Matching) API를 통해, 실제로 데이터를 받을 상대방(구독자 또는 Queryable)이 라우팅 경로 상에 활성화되어 존재할 때만 데이터를 직렬화하여 네트워크 스택으로 내려보낸다. 만약 목적지에 도달할 수 없다면 데이터를 생성하는 순간 즉시 폐기하여 불필요한 CPU 사이클 낭비와 네트워크 대역폭 점유를 원천적으로 차단한다. 이와 함께 앞서 언급한 혼잡 제어(Congestion Control) 로직이 모니터링과 결합되어, 신뢰성 대기열이 꽉 차서 메시지가 드롭(Drop)되는 빈도 등을 실시간으로 추적함으로써 전체 시스템의 보이지 않는 체력 지표(Health Metric)로 활용하게 된다.</p>
<h3>4.2  복잡성을 직관적으로 통제하는 Zenoh 시각화</h3>
<p>네트워크 하부에서 수집된 방대한 모니터링 메트릭과 복잡하게 얽힌 위상 구조를 인간 운영자가 한눈에 이해하고 대응할 수 있도록 직관적으로 변환하는 것은 시스템의 안정적 운영과 장애 대응의 성패를 가르는 핵심이다. <strong>Zenoh 시각화(Zenoh Visualization)</strong> 도구는 단순한 숫자 나열의 대시보드를 넘어, 에지 네트워크의 생동감 넘치는 구조를 시각적으로 투영하는 가상 관제 센터의 역할을 제공한다.</p>
<ol>
<li><strong>토폴로지 맵핑(Topology Mapping):</strong> 수십 센티미터 크기의 드론에 탑재된 에지 디바이스부터 지구 반대편의 클라우드 데이터센터 라우터까지, 현재 형성된 동적인 라우팅 트리(Routing Tree)를 화면상에 시각적 노드와 엣지(Edge)로 표출한다. 어느 경로의 회선 품질이 떨어져 병목이 발생하고 있는지, 핵심 라우터가 다운되었을 때 메시지가 어떤 우회 백업 경로(Failover Path)를 찾아 동적으로 흘러가는지 직관적으로 추적하고 시뮬레이션할 수 있다.</li>
<li><strong>데이터 플로우 관제(Data Flow Tracing):</strong> <code>Zenoh-Flow</code>와 같은 분산 데이터 컴퓨팅 연산 환경에서, 센서에서 시작된 데이터가 여러 오퍼레이터(Operator) 노드를 거쳐 최종 추론 결과로 나오기까지 초당 몇 개의 메시지 배치가 전송되고 있는지 논리적인 데이터 파이프라인의 건전성을 히트맵(Heatmap)이나 스트림 다이어그램 형태로 시각화하여 검증한다.</li>
<li><strong>성능 프로파일링(Performance Profiling):</strong> 종단 간 지연 시간(End-to-end Latency)의 분포도, 구간별 메시지 드롭률, 그리고 스토리지 플러그인의 응답 소요 시간 등을 실시간 차트로 구성하여, 초기에 설정된 QoS(Quality of Service) 규칙과 혼잡 제어 전략이 물리적 한계 상황에서도 제대로 동작하고 있는지 정밀하게 진단한다. 앞서 언급한 <em>TypeScript에서 Zenoh</em> 기반의 웹 바인딩 기술을 활용하면, 무거운 외부 서드파티 모니터링 도구의 설치나 연동 없이도 웹 브라우저만으로 전체 네트워크의 심장 박동을 시각적으로 디버깅할 수 있는 환경이 열린다.</li>
</ol>
<p>결과적으로, Zenoh의 시스템 설계에 깊숙이 내재된 이러한 관측성과 시각화 체계는 3대 설계 원칙을 저해하는 무거운 짐이 아니라, 오히려 이 위대한 원칙들이 거칠고 혹독한 현실의 물리적 네트워크 환경 속에서도 조금의 타협 없이 굳건하게 지켜지고 있음을 운영자에게 수학적, 시각적으로 명백히 증명해 내는 가장 강력한 확신 체계이자 방패로 작용한다.</p>
<hr />
<h2>5. 결론: 지능형 자율 시스템 시대를 위한 신경망의 완성</h2>
<p>데이터가 폭발적으로 증가하고 컴퓨팅의 중심이 클라우드에서 에지 단말을 향해 무서운 속도로 전진하는 현대 기술 지형에서, 단순히 A지점에서 B지점으로 바이트 뭉치를 옮기는 파이프라인 역할에 머물던 전통적인 통신 미들웨어 모델은 그 수명을 다했다. 이질적인 하드웨어, 제각각인 네트워크 프로토콜, 그리고 물리적 위치의 파편화를 투명하게 극복하여 애플리케이션 개발자가 인프라의 늪에 빠지지 않고 오직 핵심 비즈니스 로직에만 몰입할 수 있도록 돕는 진보된 추상화 계층의 존재는 이제 선택이 아닌 필수불가결한 요소가 되었다.</p>
<p>Zenoh가 야심 차게 제시한 <strong>우아한 데이터 추상화(Eloquent)</strong>, <strong>극단적인 양방향 확장성(Scalable)</strong>, 그리고 **제로 오버헤드와 예측 가능한 고성능(Fast &amp; Efficient)**이라는 3대 설계 원칙은, 이동하는 데이터(Pub/Sub), 정지된 데이터(Storage), 융합되는 데이터(Computation) 간의 길고 높았던 장벽을 마침내 허물어뜨렸다. 수백 바이트의 메모리만을 가진 초소형 임베디드 디바이스부터 무한한 자원을 가진 클라우드 네이티브 서버까지 끊김 없는 완벽한 데이터 연속체(Data Continuum)를 제공하며, Rust의 안전성, C++의 제어력, TypeScript의 웹 유연성, 그리고 ROS2 로보틱스 생태계를 단 하나의 네트워크 공간으로 유려하게 결합하는 혁신적인 기술적 토대를 인류에게 선사했다. 또한 이를 묵묵히 뒷받침하는 효율적인 내장 모니터링과 직관적인 시각화 체계는, 거대하고 복잡한 분산 시스템을 운영하는 엔지니어들에게 잃어버렸던 시스템의 투명성을 되찾아 주었다.</p>
<p>물리 세계와 가상 세계가 완벽히 동기화되는 <em>Digital Twin</em>의 고도화, 수천 대의 자율주행 차량이 교차로에서 충돌 없이 교차하는 대규모 군집 제어, 그리고 수백 개의 센서와 로봇 팔이 유기적으로 살아 숨 쉬는 스마트 팩토리의 실시간 관제에 이르기까지, 현대의 거대한 지능형 시스템은 방대한 감각 기관(센서)과 근육(액추에이터), 그리고 두뇌(AI 추론 노드)를 단 1밀리초의 오차도 없이 정교하게 이어줄 극도로 효율적이고 지능적인 ’신경망(Nervous System)’을 오랫동안 갈구해 왔다.</p>
<p>Zenoh는 타협 없는 이 3대 설계 원칙을 통해 단순한 통신 소프트웨어를 넘어 바로 그 지능형 로봇과 분산 AI 시대를 위한 진정한 ’신경망’으로 눈부시게 진화하였으며, 분산 컴퓨터 아키텍처 역사의 완전히 새로운 패러다임을 지금 이 순간 열어가고 있다.</p>
<h2>6. Works cited</h2>
<ol>
<li>Zenoh-based Dataflow Framework for Autonomous Vehicles - Zenodo, accessed February 25, 2026, https://zenodo.org/records/5734287/files/AVS_21___Final___Zenoh_based_data_flow_framework_for_autonomous_vehicles.pdf</li>
<li>Facilitating distributed data-flow programming with Eclipse Zenoh, accessed February 25, 2026, https://www.researchgate.net/publication/352931336_Facilitating_distributed_data-flow_programming_with_Eclipse_Zenoh_the_ERDOS_case</li>
<li>Build scalable communication systems with Eclipse Zenoh, accessed February 25, 2026, https://learn.arm.com/learning-paths/cross-platform/zenoh-multinode-ros2/1_intro-zenoh/</li>
<li>Eclipse Zenoh Zero-overhead middleware - ADLINK Tech, accessed February 25, 2026, https://www.adlinktech.com/en/zenoh</li>
<li>Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute, accessed February 25, 2026, https://zenoh.io/</li>
<li>Digital Twin Synchronization: towards a data-centric architecture, accessed February 25, 2026, https://www.arxiv.org/pdf/2601.23051</li>
<li>Advanced Zenoh Tutorial – Part I - Speaker Deck, accessed February 25, 2026, https://speakerdeck.com/kydos/advanced-zenoh-tutorial-part-i</li>
<li>zenoh - Rust - Docs.rs, accessed February 25, 2026, https://docs.rs/zenoh/latest/zenoh/</li>
<li>How does the Zenoh protocol enhance edge device operation?, accessed February 25, 2026, https://www.eeworldonline.com/how-does-the-zenoh-protocol-enhance-edge-device-operation/</li>
<li>ADLINK Tech | Eclipse Zenoh Zero-overhead middleware, accessed February 25, 2026, https://www.adlinktech.com.cn/fr/zenoh</li>
<li>Eclipse Zenoh-Flow | projects.eclipse.org, accessed February 25, 2026, https://projects.eclipse.org/proposals/eclipse-zenoh-flow</li>
<li>Creation Review | projects.eclipse.org, accessed February 25, 2026, https://projects.eclipse.org/projects/iot.zenoh/reviews/creation-review-0</li>
<li>Zenoh Reliability, Scalability and Congestion Control, accessed February 25, 2026, https://zenoh.io/blog/2021-06-14-zenoh-reliability/</li>
<li>319 Best Information Technology Jobs in Cambridge (December, accessed February 25, 2026, https://jobtoday.com/gb/jobs-information-technology/cambridge</li>
<li>Remote Tele-Operation of Robots with Zenoh | ROS 2 - eInfochips, accessed February 25, 2026, https://www.einfochips.com/blog/remote-tele-operation-of-robots-with-zenoh/</li>
<li>(PDF) Utilizing the VITAL-5G platform to advance 5G standalone, accessed February 25, 2026, https://www.researchgate.net/publication/390980840_Utilizing_the_VITAL-5G_platform_to_advance_5G_standalone_integration_with_vertical_industries</li>
<li>awesome-observability/README.md at master - GitHub, accessed February 25, 2026, https://github.com/adriannovegil/awesome-observability/blob/master/README.md</li>
<li>Schedule Day 1 - GOSIM AI Paris 2025, accessed February 25, 2026, https://paris2025.gosim.org/schedule/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>