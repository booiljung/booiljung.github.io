<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:# 1.  Zenoh의 개요와 등장 배경</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../../../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1># 1.  Zenoh의 개요와 등장 배경</h1>
                    <nav class="breadcrumbs"><a href="../../../../../index.html">Home</a> / <a href="../../../../index.html">서비스 (Services)</a> / <a href="../../../index.html">Zenoh</a> / <a href="../../index.html">제목:Zenoh</a> / <a href="../index.html">Chapter 1. Zenoh의 탄생과 핵심 철학</a> / <a href="index.html">1.1 Zenoh의 개요와 등장 배경</a> / <span># 1.  Zenoh의 개요와 등장 배경</span></nav>
                </div>
            </header>
            <article>
                <h1># 1.  Zenoh의 개요와 등장 배경</h1>
<p>현대의 컴퓨팅 환경은 중앙 집중형 클라우드 데이터 센터에서 벗어나, 네트워크의 가장자리에 위치한 디바이스들이 실시간으로 데이터를 생성하고 처리하는 에지 컴퓨팅(Edge Computing)과 만물 인터넷(IoT) 시대로 급격히 전환되었다. 모바일 로봇, 자율주행 차량, 드론, 스마트 팩토리의 센서 네트워크 등 사이버 물리 시스템(Cyber Physical Systems, CPS)의 폭발적인 성장은 네트워크에 연결되는 디바이스의 수를 기하급수적으로 증가시켰다. 이러한 시스템들은 단순히 데이터의 양적 증가만을 가져온 것이 아니며, 연산 능력, 저장 용량, 통신 대역폭 측면에서 극도로 이질적인(Heterogeneous) 특성을 지니는 복잡한 생태계를 형성하게 되었다. 전력 공급이 원활하고 고속 광통신망이 연결된 클라우드 서버부터, 배터리로 구동되며 킬로바이트(KB) 단위의 메모리를 가지고 저전력 장거리 통신망(LPWAN)을 사용하는 마이크로컨트롤러(MCU)에 이르기까지, 하나의 애플리케이션이 포괄해야 하는 하드웨어와 네트워크의 스펙트럼은 전례 없이 넓어졌다.</p>
<p>과거의 컴퓨팅 모델이 클라우드 중심의 중앙 처리와 데이터 저장을 기본 전제로 삼았다면, 오늘날의 에지 투 클라우드 컨티뉴엄(Edge-to-Cloud Continuum)은 성능, 에너지 효율성, 보안, 그리고 지연 시간(Latency)의 최적화를 위해 데이터가 생성되는 가장 가까운 곳에서 데이터를 처리하고 보관할 것을 요구한다. 자율주행 차량의 충돌 회피 알고리즘이나 원격 수술(Remote Surgery)용 로봇팔 제어와 같이 인간의 생명과 직결되거나 밀리초(ms) 단위의 반응성이 필요한 시스템에서, 데이터를 클라우드까지 전송한 후 응답을 기다리는 구조는 치명적인 물리적 한계를 지닌다. 결과적으로, 극도로 이질적인 하드웨어 및 네트워크 환경 전반에 걸쳐 데이터를 원활하고 효율적으로 검색, 이동, 연산, 저장할 수 있는 새롭고 강력한 통신 프로토콜의 필요성이 대두되었다. Zenoh는 바로 이러한 시대적 요구와 기존 기술의 근본적인 한계를 극복하기 위해 탄생한 차세대 데이터 중심 통신 미들웨어이다.</p>
<h2>2. 제논의 역설(Zeno’s Paradoxes)과 통신망의 철학적 기원</h2>
<p>프로토콜의 명칭인 ’Zenoh(제노)’는 고대 그리스 엘레아 학파의 철학자인 제논(Zeno of Elea, 기원전 490~430년경)과 그의 유명한 역설(Zeno’s paradoxes)에서 영감을 받아 명명되었다. 제논의 역설을 이해하는 것은 이 프로토콜이 어떠한 철학적, 공학적 장벽을 허물기 위해 탄생했는지를 파악하는 가장 핵심적인 열쇠이다. 제논은 그의 스승인 파르메니데스(Parmenides)의 일원론(Monism), 즉 현실은 단일하고 변하지 않으며 다원성(Plurality)과 운동(Motion)은 감각이 만들어낸 환상에 불과하다는 철학을 방어하기 위해 일련의 수학적, 논리적 역설을 고안했다.</p>
<p>그중 가장 대표적인 이분법 역설(Dichotomy paradox)과 아킬레스와 거북이의 역설(Achilles and the tortoise)에 따르면, 목적지에 도달하기 위해서는 먼저 남은 거리의 절반을 통과해야 하고, 그 남은 거리의 절반을 다시 통과해야 하므로, 공간과 시간이 무한히 분할되는 한 운동은 결코 완료될 수 없다는 논리적 모순을 제시한다. 무한한 단계를 거쳐야만 유한한 거리를 이동할 수 있다는 이 주장은 연속성과 이산성에 대한 인류의 직관적 이해에 깊은 도전을 던졌으며, 수천 년이 지나 아이작 뉴턴과 라이프니츠의 미적분학이 도입되어 무한급수의 합이 유한한 값으로 수렴할 수 있음을 증명하고 나서야 비로소 논리적으로 해결되었다.</p>
<p>ADLINK와 ZettaScale Technology의 창립자이자 Zenoh 프로젝트를 이끄는 안젤로 코르사로(Angelo Corsaro) 박사와 그의 연구팀은 현대의 분산 통신 시스템이 마주한 물리적, 논리적 제약을 이 제논의 역설에 정교하게 비유했다. 거대한 데이터 센터에서부터 자원 제약이 극심한 에지 디바이스에 이르는 통신 경로는 결코 매끄러운 단일 고속도로가 아니다. 현대의 극도로 분산된 에지 네트워크는 디바이스 간의 잦은 물리적 단절, 배터리 절약을 위한 수면 모드(Sleep mode)로 인한 시간적 분절, 패킷을 잘게 쪼개야 하는 최대 전송 단위(MTU)의 제약, 그리고 서로 다른 네트워크 스택과 프로토콜 번역 계층 간의 끝없는 장벽으로 이루어져 있다. 데이터를 목적지까지 전송하기 위해 패킷은 라우터와 브릿지를 거치며 수없이 분할되고 지연되며, 이는 마치 제논의 역설에서 목적지에 영원히 도달하지 못하고 거리가 무한히 분할되는 현상과 완벽하게 겹쳐진다.</p>
<p>특히 통신 프로토콜 설계의 관점에서, 서로 다른 미들웨어 간의 변환 작업과 네트워크의 오버헤드가 누적될수록 데이터가 적시에 도달하는 것은 수학적 불가능에 가까워진다. 연구팀은 이러한 무한한 단절과 제약을 돌파하기 위해, 네트워크 오버헤드를 이론적 한계에 가깝게 소거한 제로 네트워크 오버헤드(Zero Network Overhead) 프로토콜을 창안하였으며, 그 명칭을 Zeno의 이름에 착안하여 Zenoh로 정명하였다. 이는 수학계가 미적분학을 통해 제논의 역설을 타파했듯이, 단절되고 분할된 극단적 통신 환경(예: 지하 갱도의 센서, 심해의 무인 잠수정, 우주 공간 등)에서도 네트워크의 물리적 한계를 뛰어넘어 데이터를 매끄럽게 전달하겠다는 확고한 철학적 의지와 공학적 도전 정신을 담고 있는 것이다.</p>
<h2>3. ’연결의 섬(Connectivity Islands)’과 패치워크 설계의 한계</h2>
<p>Zenoh의 등장 배경을 더욱 명확히 이해하기 위해서는 지난 수십 년간 산업계를 지배해 온 주류 통신 프로토콜들의 구조적 한계와 이로 인해 파생된 ‘연결의 섬(Connectivity Islands)’ 현상을 심도 있게 분석해야 한다. 특정 도메인이나 네트워크 환경에 맞춰 최적화되도록 설계된 기존의 프로토콜들은 각자의 고유한 영역 내에서는 훌륭하게 작동하지만, 마이크로컨트롤러에서 클라우드에 이르는 에지 투 클라우드 컨티뉴엄 전체를 아우르는 확장성과 유연성을 제공하는 데에는 근본적으로 실패했다.</p>
<p>대표적으로 MQTT(Message Queuing Telemetry Transport)는 저전력 IoT 디바이스와 WAN(Wide Area Network) 환경에서 원격 측정 데이터를 전송하기 위해 널리 사용되는 발행/구독(Pub/Sub) 프로토콜이다. 그러나 MQTT는 태생적으로 클라이언트-브로커(Client-to-Broker) 모델을 강제하는 중앙 집중형 허브 앤 스포크(Hub-and-spoke) 아키텍처를 가진다. 이는 네트워크 상의 모든 데이터가 반드시 중앙의 브로커를 거쳐야만 목적지로 전달될 수 있음을 의미한다. 이러한 구조는 브로커 자체가 단일 장애점(Single Point of Failure)이 될 치명적인 위험을 내포하고 있으며, 데이터를 인접한 디바이스로 보낼 때조차 중앙을 거쳐야 하므로 불필요한 네트워크 홉(Hop)을 추가하여 시스템 전체의 지연 시간을 크게 증가시키는 원인이 된다. 더욱이 MQTT는 신뢰성 있는 전송을 위해 TCP/IP 스택 위에서만 동작하도록 견고하게 결합되어 있다. 이는 IP 스택 자체를 메모리에 올리기조차 버거운 초소형 마이크로컨트롤러나, TCP 특유의 연결 지향성(Connection-oriented) 및 HoL(Head-of-Line) 블로킹 문제가 네트워크 전체의 성능을 저하시키는 동적인 모바일 및 무선 네트워크(예: 차량 간 V2X 통신)에서는 매우 심각한 제약으로 작용한다.</p>
<p>또 다른 축을 담당하는 DDS(Data Distribution Service)는 로보틱스, 항공우주, 국방 등 실시간(Real-time) 통신과 결정론적 데이터 전달이 필수적인 분야에서 사실상의 국제 표준으로 자리 잡은 미들웨어이다. 초기 자율주행 차량이나 로봇 제어 시스템에서 DDS는 수십 가지의 강력한 QoS(Quality of Service) 프로파일과 중앙 브로커가 필요 없는 분산 P2P(Peer-to-Peer) 아키텍처를 제공하여 학계와 산업계 양측에서 큰 성공을 거두었다. 하지만 DDS는 본질적으로 대역폭이 풍부하고 멀티캐스트(Multicast) 기능이 하드웨어 수준에서 완벽하게 지원되는 유선 LAN(Local Area Network) 환경을 염두에 두고 설계되었다는 태생적 한계를 지닌다.</p>
<p>DDS의 핵심 기능 중 하나인 동적 디스커버리(Dynamic Discovery) 메커니즘은 네트워크 상의 모든 노드가 서로의 존재와 데이터 관심사를 인지하기 위해 막대한 양의 메타데이터를 멀티캐스트로 브로드캐스트하는 방식을 취한다. 이는 유선 이더넷 환경에서는 훌륭하게 작동하지만, 와이파이(Wi-Fi)나 4G/5G 통신망과 같이 멀티캐스트 지원이 빈약하거나 패킷 손실률이 높은 무선 네트워크 환경에서는 치명적인 디스커버리 스톰(Discovery Storm)을 유발하여 네트워크 대역폭을 포화시키고 시스템 전체를 마비시키는 주된 원인이 된다. 즉, 로봇 내부의 통신망을 넘어 대규모 WAN 환경이나 클라우드로 확장하려 할 때 DDS는 극심한 성능 저하와 아키텍처의 구조적 한계를 여실히 드러내게 된다.</p>
<p>이러한 기존 프로토콜(MQTT, DDS, CoAP, HTTP 등)들은 각자가 탄생한 환경에 국한된 문제만을 부분적으로 해결했기 때문에, 시스템 아키텍트와 소프트웨어 개발자들은 복잡한 에지 시스템을 구축할 때 어쩔 수 없이 여러 프로토콜을 기형적으로 이어 붙이는 ’패치워크 설계(Patchwork Design)’를 강요받게 되었다. 과거 시스템 아키텍트들은 하나의 거대한 서비스를 구성하기 위해, 로봇 내부의 하드웨어 센서 제어와 프로세스 간 통신을 위해서는 DDS를 사용하고, 로봇에서 외부의 에지 서버로 데이터를 전송하기 위해서는 MQTT 프로토콜 브릿지를 거치며, 브로커에서 최종적으로 클라우드 데이터베이스로 연동하기 위해서는 또다시 HTTP나 gRPC와 같은 RESTful 브릿지를 통과하도록 시스템을 구성해야만 했다.</p>
<p>이러한 다중 프로토콜 브릿지 구조는 데이터가 변환되는 매 지점마다 심각한 네트워크 병목 현상을 유발하고, 메시지 포맷의 직렬화 및 역직렬화에 따른 막대한 컴퓨팅 자원 낭비와 지연 시간의 폭발적인 증가를 초래했다. 더욱 심각한 것은 프로토콜마다 지원하는 데이터 의미론(Semantics)과 QoS 수준이 다르기 때문에, 엔드투엔드(End-to-End) 수준에서의 데이터 일관성, 무결성 보장, 그리고 통합된 보안 정책의 적용이 사실상 불가능해진다는 점이다. 반면 Zenoh는 이러한 파편화를 근본적으로 해결하기 위해 프로토콜 번역이나 브릿지 없이 마이크로컨트롤러부터 클라우드까지 단일 프로토콜 메시(Mesh) 네트워크로 매끄럽게 연결하는 혁신적인 아키텍처를 제시한다.</p>
<table><thead><tr><th><strong>주요 비교 항목</strong></th><th><strong>DDS (Data Distribution Service)</strong></th><th><strong>MQTT (Message Queuing Telemetry Transport)</strong></th><th><strong>HTTP / REST</strong></th><th><strong>Zenoh</strong></th></tr></thead><tbody>
<tr><td><strong>주 목적 및 최적화 환경</strong></td><td>실시간 로컬 제어, 자원 풍부 유선 LAN</td><td>원격 원격측정 통신, WAN</td><td>클라이언트-서버 기반 웹 서비스</td><td>제약된 에지 디바이스부터 클라우드까지의 컨티뉴엄 전체</td></tr>
<tr><td><strong>네트워크 통신 토폴로지</strong></td><td>P2P (멀티캐스트 기반 브로드캐스트)</td><td>Hub-and-spoke (중앙 브로커 전적 의존)</td><td>Point-to-Point (서버 전적 의존)</td><td>P2P, 브로커, 임의 그래프 라우팅, 메시 등 완전 결합</td></tr>
<tr><td><strong>하위 의존 네트워크 계층</strong></td><td>주로 UDP/IP 기반</td><td>TCP/IP 기반</td><td>TCP/IP 기반</td><td>IP 스택 독립적 (OSI Layer 2 데이터 링크 직접 지원)</td></tr>
<tr><td><strong>공간적 투명성 보장 수준</strong></td><td>높음 (단, 로컬 서브넷 내로 극히 제한됨)</td><td>중앙 브로커의 네트워크 위치에 종속됨</td><td>매우 낮음 (특정 IP 주소 및 DNS 의존)</td><td>매우 높음 (네트워크 토폴로지 무관, 이름 기반 라우팅)</td></tr>
<tr><td><strong>데이터 패킷 오버헤드 구조</strong></td><td><span class="math math-inline">Size = Payload + \vert RTPS Header \vert</span> (수십~수백 바이트 요구)</td><td><span class="math math-inline">Size = Payload + \vert TCP Header \vert + \vert MQTT Header \vert</span></td><td><span class="math math-inline">Size = Payload + \vert HTTP Headers \vert</span> (매우 큼)</td><td><span class="math math-inline">Size = Payload + \vert Minimal 4 \sim 5 Bytes \vert</span></td></tr>
</tbody></table>
<p>(표 1: 주요 통신 미들웨어 및 프로토콜의 아키텍처 특성과 오버헤드 수학적 모델 비교 )</p>
<h2>4. 데이터 이동, 보관, 연산의 대통합 (Unified Abstractions)</h2>
<p>안젤로 코르사로 박사 및 ZettaScale 연구팀이 집필한 논문 원문 “Zenoh: Unifying Communication, Storage and Computation from the Cloud to the Microcontroller“에 상술된 바와 같이, 전통적인 분산 소프트웨어 아키텍처는 데이터의 상태에 따라 기술적 스택이 완전히 단절되는 고질적인 문제로 고통받아 왔다.</p>
<p>첫째, ’움직이는 데이터(Data in Motion)’는 주로 MQTT, DDS, Kafka와 같은 Pub/Sub 패러다임을 사용하여 처리되어 왔다. 데이터가 한 노드에서 발행되면 네트워크를 타고 관심 있는 다수의 구독자에게 실시간으로 푸시(Push)된다. 이 모델은 발행자가 구독자의 위치를 알 필요가 없는 공간적 투명성을 훌륭하게 제공하지만, 통신 순간이 지나가면 데이터가 공중으로 흩어지며 시스템에 영속적으로 저장되지 않는다는 한계가 있다. 둘째, ’머무는 데이터(Data at Rest)’는 주로 SQL, NoSQL, Time-series DB와 같은 데이터베이스 기술을 통해 풀(Pull) 방식으로 조회된다. 데이터의 상태 영속성은 완벽히 보장되지만, 클라이언트가 쿼리를 던지기 위해서는 특정 데이터베이스 서버의 정확한 네트워크 주소(IP, Port)와 스키마를 미리 알고 있어야 하므로, 클라우드 컴퓨팅 환경의 근간인 위치 투명성이 완전히 파괴된다. 셋째, ’연산(Computations)’은 특정 데이터를 기반으로 원격에서 동작을 수행하거나 복잡한 결과를 도출하는 과정으로, 전통적으로 gRPC나 REST API와 같은 동기식 요청/응답(Request/Reply) 프레임워크에 전적으로 의존해 왔다. 이 방식 역시 철저하게 호스트 중심적(Host-centric)이며, 서버 인스턴스의 증설이나 네트워크 파티셔닝에 대비한 고장 허용성(Fault-tolerance), 그리고 에지 노드 간의 동적 로드 밸런싱을 우아하게 구축하기가 극도로 까다롭다.</p>
<p>Zenoh의 가장 위대한 아키텍처적 성취는 이처럼 파편화되고 분절된 세 가지 세계를 ’위치 투명성(Location Transparency)’과 ’이름 기반 라우팅(Name-based Routing)’이라는 단일화된 추상화 철학으로 완벽하게 융합해 낸 것이다. 미래 인터넷 아키텍처로 연구되어 온 NDN(Named Data Networking) 아키텍처의 사상에서 강한 영감을 받은 Zenoh는 네트워크 상에 존재하는 모든 종류의 자원과 데이터를 물리적인 IP 주소가 아닌, 디렉토리 경로 형태의 직관적이고 계층적인 키 표현식(Key Expression, 예: <code>robot/1/sensor/temp</code>)으로 식별한다.</p>
<p>Zenoh의 통합된 API 체계 내에서 Pub/Sub 모델은 가장 기본적으로 동작한다. 센서가 특정 키(Key)에 데이터를 Put(발행)하면, 라우팅 토폴로지에 관계없이 해당 키의 데이터를 수신하기 위해 네트워크 어딘가에서 대기 중인 모든 구독자(Subscriber)에게 최소 지연으로 데이터가 전달된다. 더 나아가, Zenoh는 지리적 분산 스토리지(Geo-distributed Storage)를 이 과정에 자연스럽게 개입시킨다. Zenoh 라우터에 스토리지 플러그인을 활성화하면 특정 키 표현식(예: <code>robot/1/**</code>)으로 네트워크에 흘러다니는 실시간 데이터들을 별도의 브릿지 애플리케이션 없이도 인플럭스DB(InfluxDB), 락스DB(RocksDB), 포스트그레스QL(PostgreSQL), SQLite 등 다양한 백엔드에 자동으로 영속화(Persist)할 수 있다. 구독자는 Get(조회) 쿼리라는 단일한 인터페이스를 통해 네트워크 어딘가에 저장된 이 과거의 이력 데이터들을, 해당 데이터베이스 서버의 물리적 위치나 종류를 전혀 모르는 상태에서도 마치 로컬 캐시를 읽어 들이듯 손쉽게 불러올 수 있다.</p>
<p>여기에 더해, Zenoh는 연산 가능 객체(Queryables)라는 혁신적인 개념을 통합했다. 이는 시스템 내의 데이터를 단순히 데이터베이스에서 정적으로 조회하는 것을 넘어, 특정 쿼리가 발생했을 때 분산된 에지 컴퓨팅 노드에서 동적이고 실시간으로 연산을 수행한 후 그 결과값을 반환(Reply)하는 매커니즘을 프로토콜 자체에 내장한 것이다. 이를 통해 개발자는 무거운 원격 프로시저 호출(RPC) 스택을 별도로 구성하지 않고도 복잡한 Map-Reduce 분산 처리 패턴을 Zenoh의 단일 통신 API 안에서 우아하게 구현할 수 있다. 이러한 세 가지 추상화의 완벽한 통합은 마이크로서비스 아키텍처나 자율주행 차량을 위한 분산 데이터 플로우 프레임워크(예: ERDOS, Zenoh-Flow)의 구축을 전례 없이 단순화시켰으며, 개발자가 “데이터가 어느 IP 주소의 어느 포트에 있는가?“를 고민하는 대신 오직 “나는 지금 어떤 데이터에 관심이 있는가?“에만 집중할 수 있도록 돕는 진정한 데이터 중심(Data-centric) 패러다임을 완성했다.</p>
<p><strong>Zenoh의 단일화된 데이터 추상화 모델</strong></p>
<p>Data in Motion, Data at Rest, Computations 통합 아키텍처</p>
<p><img src="/home/bijung/.config/Typora/typora-user-images/image-20260225141345113.jpg" alt="image-20260225141345113" /></p>
<p>네트워크의 물리적 위치에 구애받지 않고, 키 표현식(Key Expression) 하나로 데이터의 발행/구독, 분산 저장, 동적 연산 요청을 모두 처리하는 Zenoh의 핵심 원리.</p>
<h2>5. 클라우드부터 마이크로컨트롤러까지: 진정한 컨티뉴엄의 달성</h2>
<p>통합된 추상화 모델 외에도, Zenoh의 가장 독보적인 공학적 성취 중 하나는 와이어(Wire) 상에서 교환되는 메타데이터 패킷의 크기를 물리적인 한계치까지 극단적으로 최소화한 프로토콜 스택의 설계에 있다. 방대한 규모의 IoT 환경과 잦은 단절이 일어나는 에지 네트워크에서의 통신 실패율을 극복하기 위해 Zenoh는 밑바닥부터 완전히 새롭게 설계되었으며, 그 결과 데이터 메시지의 최소 와이어 오버헤드(Wire Overhead)를 단 4~5바이트 수준으로 억제하는 경이로운 기록을 달성했다.</p>
<p>이러한 극단적인 경량화는 TCP/IP의 무거운 헤더나 MQTT, DDS의 복잡한 메타데이터 구조로 인해 사실상 통신이 불가능했던 초소형, 저전력, 초저대역폭 환경에서의 원활한 구동을 가능하게 한다. 일례로, 8비트 아키텍처를 사용하는 초소형 마이크로컨트롤러인 아두이노(Arduino Uno)와 같은 지극히 제한적인 하드웨어 환경에서 구동되는 Zenoh 애플리케이션의 메모리 풋프린트(Footprint)는 불과 300바이트 남짓에 지나지 않는다. 이는 배터리 수명이 운영의 핵심이며 듀티 사이클(Duty Cycle)이 매우 낮아 하루 중 대부분의 시간을 전력 보존을 위한 수면 모드(Disconnected or Sleeping mode)로 보내는 무선 센서 노드들에게 생명줄과도 같은 유연성과 생존력을 제공한다. 이러한 수면 디바이스가 간헐적으로 깨어날 때, Zenoh 네트워크의 인접 라우터는 대기 중이던 큐(Queue) 데이터를 압축된 형태로 순식간에 푸시함으로써 배터리 소모를 극소화한다.</p>
<p>동시에 Zenoh는 마이크로컨트롤러를 위한 가벼운 무게에만 집착한 기술이 결코 아니다. 멀티 코어 CPU와 방대한 메모리, 고대역폭 광통신이 뒷받침되는 최상위 데이터 센터 서버나 고성능 자율주행 차량의 메인 컴퓨팅 노드에서는 소프트웨어 아키텍처의 유연성을 발휘하여 최대 50Gbps에 달하는 엄청난 데이터 처리량(Throughput)과 13µs(마이크로초) 이하의 극단적인 저지연(Low Latency) 수치를 기록한다. 이는 와이어 레벨에서의 고도화된 동적 데이터 배치(Batching) 처리, 하위 네트워크 기술의 가변적인 MTU(Maximum Transmission Unit) 한계에 실시간으로 적응하는 자동 단편화(Automatic Fragmentation) 알고리즘, 그리고 여러 데이터 스트림이 단일 링크를 공유할 때 발생하는 치명적인 헤드 오브 라인 블로킹(Head-of-Line Blocking)을 원천적으로 방지하기 위한 정교한 7단계 우선순위 기반의 네트워크 스케줄링 메커니즘이 하나의 프로토콜 내에 빈틈없이 결합된 결과이다.</p>
<p>ISO/OSI 7계층 참조 모델의 관점에서 평가할 때, Zenoh가 지니는 또 다른 강력한 무기는 특정 전송 계층(Transport Layer)이나 네트워크 계층(Network Layer)의 기술에 절대적으로 종속되지 않는 독립성과 유연성이다. 전통적인 프로토콜들이 전제하는 TCP/IP 또는 UDP/IP 스택 위에서 완벽하게 구동될 수 있을 뿐만 아니라, 완전한 IP 스택 구현 자체가 시스템 자원에 심각한 부담이 되는 제약된 임베디드 장비 환경에서는 IP 계층을 완전히 생략하고 데이터 링크 계층(OSI Layer 2) 위에서 직접 페이로드를 교환하도록 구성할 수 있다. 현재 Zenoh 프로토콜 생태계는 일반적인 이더넷(Ethernet)과 와이파이(Wi-Fi), 이동통신망인 4G/5G를 넘어서, 시리얼 통신(Serial), 블루투스(Bluetooth Low Energy), 저전력 광역망인 로라(LoRa), 자동차 전장용 CAN 버스(CANbus), 내부 프로세스 통신을 위한 유닉스 소켓(Unix Sockets 및 Pipes), 그리고 마이크로초 단위의 성능이 요구되는 내부 스레드 간의 공유 메모리(Shared Memory) 통신에 이르기까지 현존하는 사실상 모든 형태의 물리 및 논리적 통신 매체를 완벽하게 아우르며 지원한다.</p>
<h2>6. 다국어 생태계 전개의 당위성과 언어별 결합</h2>
<p>Zenoh는 모든 이질적인 에지 디바이스와 개발 환경의 컨티뉴엄에서 구동되는 범용적인 데이터 패브릭(Data Fabric)을 지향하기에, 단순히 연구실 환경에서 사용되는 단일 프로그래밍 언어의 미들웨어에 머무르지 않는다. 현대 소프트웨어 공학 산업 전반을 주도하는 거의 모든 주류 언어에 대하여, 타 프로토콜의 래퍼(Wrapper) 수준이 아닌 퍼스트 파티(First-party) 수준의 강력한 API와 생태계를 공식적으로 제공한다. 개발 생태계의 범용성을 증명하는 이 다국어 환경들은 단순히 편의성 제공을 넘어 Zenoh가 추구하는 각 산업 영역의 구체적인 문제를 어떻게 해결하는지 보여주는 지표이다.</p>
<p>첫째, 시스템의 가장 깊숙한 기반이 되는 <strong>Rust에서 Zenoh</strong>를 활용하는 것은 단순한 프로그래밍 언어의 선택을 넘어 Zenoh 프로토콜의 근간을 이루는 핵심 철학이자 가장 강력한 기술적 해자이다. 미국 국가안보국(NSA)이 사이버 보안의 근본적인 강화를 위해 메모리 안전성을 완벽히 갖춘 프로그래밍 언어의 채택을 전 세계 소프트웨어 산업계에 강력히 권고한 바와 같이, C나 C++ 등 과거의 시스템 프로그래밍 언어에서 빈번하게 발생하는 버퍼 오버플로우나 댕글링 포인터(Dangling Pointer)로 인한 메모리 누수 취약점을 구조적으로 차단하기 위해 Zenoh의 코어 라우터와 네트워크 스택 엔진은 러스트(Rust)로 철저히 작성되었다. 러스트 컴파일러가 제공하는 제로 코스트 추상화(Zero-cost Abstraction) 기법과 엄격하고 정교한 데이터 소유권(Ownership 및 Borrowing) 모델은, 수만 개의 커넥션이 동시에 발생하는 극단적인 고도의 병행성(Concurrency) 라우팅 환경에서도 스레드 안전성(Thread safety)을 수학적으로 보장하는 동시에, 가비지 컬렉터(Garbage Collector)의 간섭 없는 예측 가능한 극강의 비동기 입출력(Async I/O) 성능을 이끌어낸다. Zenoh의 진정한 극한의 성능과 결함 없는 라우팅 토폴로지의 유지는 바로 이 Rust 생태계 위에서 완성된다.</p>
<p>둘째, 신규 언어의 도입이 제한적인 로보틱스의 하위 모터 제어 보드나 자율주행 차량의 구형 임베디드 장비, 혹은 레거시 인더스트리얼 자동화(FA) 시스템에는 이미 수십 년간 C 또는 C++로 굳건히 짜인 고부가가치의 소프트웨어 자산들이 방대하게 축적되어 있다. <strong>C++에서 Zenoh</strong> (또는 C API)를 도입하는 과정은 이러한 보수적인 산업계의 레거시 자산들을 폐기하지 않고 현대적인 에지 투 클라우드 데이터 생태계로 편입시키는 중대한 가교 역할을 수행한다. 이 C/C++ API 라이브러리를 통해 시스템 개발자들은 복잡한 러스트 코어 네트워크 로직을 안전하게 블랙박스화하여 컴파일 타임에 분리하면서도, C++ 특유의 객체 지향적이고 메모리 직접 제어 성능이 중시되는 네이티브 애플리케이션 환경 내에서 Zenoh의 모든 Pub/Sub 및 Query 통신 프리미티브를 손쉽게 호출할 수 있다. 특히 FFI(Foreign Function Interface)를 거치면서도 성능의 희생을 최소화하고 제로 카피(Zero-copy) 기술을 적극 활용하여 거대한 비전 센서 데이터를 C++ 비전 알고리즘 모듈과 지연 없이 교환하는 데 필수적인 기반을 제공한다.</p>
<p>셋째, 수집된 거대한 분산 데이터를 엔드 유저에게 의미 있는 대시보드로 시각화하거나 브라우저 환경 기반의 중앙 관제 패널을 구축하는 영역에서는 <strong>TypeScript에서 Zenoh</strong>의 역할이 매우 치명적으로 작용한다. 과거에는 에지 디바이스의 센서 데이터가 클라우드 백엔드를 거쳐 다시 웹 소켓 API로 래핑(Wrapping)되어 브라우저로 전달되는 복잡한 경로를 거쳤다. 그러나 웹 소켓(WebSockets) 트랜스포트를 통해 브라우저 스레드에서 직접 Zenoh 라우터망에 안전하게 연결하거나, WASM(WebAssembly)으로 고속 빌드된 라이브러리를 통해 클라이언트 사이드에서 즉각적으로 로컬 및 분산 네트워크의 Pub/Sub 트래픽을 처리하는 타입스크립트 기반의 클라이언트는, 풀스택 웹 애플리케이션 개발자들에게 웹과 물리적 에지 디바이스의 경계를 완전히 허무는 혁신적인 연결 패러다임을 부여한다. 자바스크립트 생태계의 동적 타이핑이 야기하는 런타임 오류를 차단하고 대규모 에지 UI 개발 시 강력한 타입 안정성을 보장하기 위해, 이 API는 현대 프론트엔드 개발의 표준이 된 타입스크립트를 철저히 지원하여 복잡한 산업용 관제 시스템의 신뢰성을 담보한다.</p>
<h2>7. 로보틱스와 오토모티브 산업의 미들웨어 패러다임 혁신</h2>
<p>Zenoh가 단순한 학술적 개념 검증(PoC) 단계를 넘어 전 세계 산업계, 특히 이동체 제어 분야에서 폭발적이고 압도적인 지지를 얻게 된 결정적인 계기는 <strong>ROS2에서 Zenoh</strong> 미들웨어의 전면적인 채택과 깊이 연관되어 있다. 로봇 애플리케이션 개발의 사실상 유일한 국제 표준으로 자리 잡은 ROS2(Robot Operating System 2)는 초기 아키텍처 설계 당시 로컬 분산 통신을 위한 기반 미들웨어 계층(RMW: ROS Middleware)으로 앞서 언급된 DDS를 채택하였다. 그러나 최근 로보틱스 산업의 배포 환경이 통제되고 안정된 연구실의 유선 LAN 환경을 벗어나기 시작했다. 로봇이 제조 공장의 전파 간섭이 극심한 Wi-Fi 환경, 스마트 농업용 야외 자율주행 트랙터의 LTE/5G 환경, 그리고 대륙을 횡단하는 공용 인터넷망을 통한 실시간 원격 조작(Teleoperation)으로 진화함에 따라, DDS가 내포한 구조적 한계가 로보틱스 산업 확장의 치명적인 목덜미를 잡기 시작했다.</p>
<p>ROS2 시스템이 자율주행을 위해 필수적으로 생산해 내는 거대한 페이로드를 지닌 라이다(LiDAR) 포인트 클라우드 데이터나 고해상도의 다중 카메라 비디오 스트리밍 데이터를 대역폭이 불안정한 무선망 환경에서 손실 없이 전달하거나 , 인터넷 망 건너편에 위치한 수백 대의 군집 로봇(Swarm Robots)의 이동 궤적을 수 밀리초 단위의 오차로 동기화해야 하는 가혹한 환경에서, DDS 기반의 ROS2 시스템은 극심한 디스커버리 스톰으로 인한 잦은 세션 끊김과 막대한 대역폭의 낭비를 지속적으로 겪어왔다.</p>
<p>이러한 산업적 한계를 타파하기 위해 OSRF(Open Source Robotics Foundation)와 알파벳 산하의 Intrinsic, 그리고 전 세계 주요 자율주행 및 로봇 하드웨어 제조사들은 복잡한 DDS를 완벽히 대체할 수 있는 새로운 RMW의 강력한 대안으로 Zenoh를 지목하게 되었다. 단일 로봇 하드웨어 내부의 컴퓨팅 노드(CPU 코어 간) 간의 극단적인 고속 통신은 공유 메모리(Shared Memory) 프로토콜을 백엔드로 활용하여 시스템 부하가 0에 수렴하는 제로 카피(Zero-copy) 속도로 처리하고, 동시에 로봇 외부의 통합 기지국 및 클라우드 관제 서버와의 원거리 통신은 Zenoh 특유의 고효율 저오버헤드 와이어 프로토콜로 지능적으로 라우팅하여 처리하는 ROS2의 새로운 미들웨어 구현체(rmw_zenoh)의 등장은, 로보틱스 미들웨어 역사에 있어 거대한 패러다임 전환을 상징하는 기념비적인 사건이다.</p>
<p>더불어, 차량 내 수십 개의 ECU가 통합되는 최신 V2X(Vehicle to Everything), V2I(Vehicle to Infrastructure), V2C(Vehicle to Cloud) 이기종 통신망 환경에서 분산된 존 컨트롤러(Zone Controller) 간의 데이터 전송의 무결성과 신뢰성을 극한으로 끌어올리며, 초당 수 기가바이트의 센서 퓨전 데이터를 안정적으로 처리하는 자동차 분야(Automotive)의 적용 검증 연구들 역시 차세대 차량용 OS의 통신 중추로서 Zenoh의 위상을 더욱 굳건히 다져나가고 있다.</p>
<h2>8. 네트워크 가시성 확보와 지능형 시스템 관리</h2>
<p>디바이스 수준의 효율적 통신망을 구축하는 것만으로 거대한 에지 투 클라우드 시스템이 스스로 유지보수되지는 않는다. 전 세계적으로 지리적으로 분산된 수만 대의 에지 노드와 이기종 클라우드 서버가 수십만 개의 링크로 복잡하게 얽힌 거대한 Zenoh 토폴로지 네트워크 내부에서는, 단순히 통신 프로토콜의 작동 여부를 파악하는 것을 넘어 네트워크 깊숙한 곳의 상태를 들여다볼 수 있는 고도화된 관측성(Observability)이 절대적으로 필요하다. 특정 노드의 예기치 않은 전력 차단, 무선 링크의 간헐적 끊김에 따른 동적인 토폴로지 변경, 통신 단절 후 대체 경로 확보를 통한 자동 복구 과정, 그리고 세분화된 보안 제어 속에서 복잡한 시스템 트러블슈팅을 완벽히 수행하기 위해서는 고도로 자동화되고 정밀한 <strong>Zenoh 모니터링</strong> 체계의 수립이 필수적이다.</p>
<p>Zenoh의 인프라스트럭처를 구성하는 각 라우터 소프트웨어 노드는 그 자체로 표준화된 REST 기반의 관리 API를 외부로 지속적으로 노출하여, 각 라우터의 현재 네트워크 접속 상태, 메모리에 적재된 메시지 큐(Queue)의 지연 현황, 실시간 우선순위 할당 및 패킷 처리 현황, 대역폭 점유율, 그리고 호스트의 기본 자원(CPU, Memory) 사용량에 대한 풍부하고 다차원적인 수치화된 메트릭(Metrics) 시스템을 외부에 뿜어낸다. Datadog(데이터독)과 같은 세계 최고 수준의 상용 클라우드 모니터링 플랫폼과의 직접적이고 심도 있는 플러그인 통합을 통해, 운영자는 Autodiscovery(자동 탐지) 기능으로 네트워크에 새롭게 진입하거나 이탈하는 Zenoh 라우터들의 생명 주기와 성능 지표를 중앙에서 즉각적으로 수집할 수 있다. 이러한 관측성의 확보는 거대한 분산 메시 네트워크의 건전성을 유지하고, 네트워크 운영자가 데이터 트래픽의 병목 지점을 수 분 전에 선제적으로 예측하며, 치명적인 장애 발생 시 복잡한 데이터 경로를 역추적하여 신속히 원인을 규명할 수 있는 견고한 기술적 기반이 된다.</p>
<p>수집된 방대한 텍스트와 수치적 메트릭의 나열만으로는 직관적인 문제 파악에 한계가 존재하기에, 이를 인간의 인지 영역에서 즉각적으로 해석하고 아키텍처 개선을 위한 의사결정에 반영하기 위한 <strong>Zenoh 시각화</strong> 솔루션의 접목 또한 시스템 관리의 매우 주요한 흐름을 형성하고 있다. 모니터링 플랫폼 내부의 대시보드 인터페이스나 오픈소스 커뮤니티에서 다양하게 제공되는 웹 기반의 시각화 도구들은, 눈에 보이지 않는 복잡한 Zenoh 라우팅의 연결 경로와 P2P 매시 토폴로지 맵, 그리고 1초에도 수만 번씩 발생하는 실시간 데이터 퍼블리싱 트래픽의 흐름을 마치 거대한 도시의 교통 상황을 지도로 그리듯 명확하고 동적인 그래프로 시각화해 낸다. 이는 개발자와 시스템 아키텍트가 단순히 텍스트 스크립트로 네트워크를 구축하고 방치하는 정적인 수준에 그치지 않고, 센서가 위치한 최전방 에지 지점부터 데이터베이스가 잠들어 있는 클라우드의 깊숙한 곳까지 유기적으로 숨 쉬는 데이터의 생명 주기를 한눈에 조망하며, 네트워크 전체의 데이터 흐름을 자유롭게 통제하고 조율할 수 있는 강력한 마에스트로의 지휘봉을 제공하는 것과 같다.</p>
<p>결론적으로, 통신 미들웨어 생태계에 혜성처럼 등장한 Zenoh는 단순한 네트워크 프레임워크나 바이트 크기를 깎아낸 최적화된 프로토콜의 하나로 치부될 수 없다. 이는 만물 인터넷 시대로 접어들며 인류가 마주한 가장 본질적인 질문, 즉 “어떻게 물리적 세계의 파편화된 수많은 제약 속에서 생성되는 모든 형태의 데이터를 거대한 하나의 생명수 흐름처럼 연속적으로 다룰 수 있는가?“에 대한 치열한 기술적 탐구이자 가장 정답에 근접한 철학적 대답이다. 기존 통신 기술들이 타협해 온 관습적인 아키텍처의 분절을 과감히 파괴하고, Zeno의 역설을 뛰어넘는 0(Zero)의 네트워크 오버헤드로 무한하고 연속적인 연결성을 추구하는 Zenoh의 대담한 여정은, 앞으로 다가올 수십 년간의 차세대 사이버 물리 시스템과 소프트웨어 아키텍처를 굳건히 지탱할 가장 든든한 초석이 될 것임에 틀림없다.</p>
<h2>9. Works cited</h2>
<ol>
<li>Eclipse zenoh | projects.eclipse.org, accessed February 25, 2026, https://projects.eclipse.org/proposals/eclipse-zenoh</li>
<li>Zenoh-based Dataflow Framework for Autonomous Vehicles, accessed February 25, 2026, https://www.researchgate.net/publication/359676592_Zenoh-based_Dataflow_Framework_for_Autonomous_Vehicles</li>
<li>Zenoh: Unifying Communication, Storage and Computation from the, accessed February 25, 2026, https://www.researchgate.net/publication/373757741_Zenoh_Unifying_Communication_Storage_and_Computation_from_the_Cloud_to_the_Microcontroller</li>
<li>ADLINK Tech | Eclipse Zenoh Zero-overhead middleware, accessed February 25, 2026, https://www.adlinktech.com.cn/fr/zenoh</li>
<li>Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute, accessed February 25, 2026, https://zenoh.io/</li>
<li>Citizen Zero Issue 03 - Issuu, accessed February 25, 2026, https://issuu.com/citizenzeromagazine/docs/citizen_zero_three-final</li>
<li>Eclipse zenoh: The Edge Data Fabric, accessed February 25, 2026, https://newsroom.eclipse.org/eclipse-newsletter/2021/july/eclipse-zenoh-edge-data-fabric</li>
<li>Zenoh-based Dataflow Framework for Autonomous Vehicles - Zenodo, accessed February 25, 2026, https://zenodo.org/records/5734287/files/AVS_21___Final___Zenoh_based_data_flow_framework_for_autonomous_vehicles.pdf</li>
<li>Research: Is Zeno’s Paradox the First Non-Euclidean Proposal?, accessed February 25, 2026, https://euclid.int/blog/research-is-zenos-paradox-the-first-non-euclidean-proposal.html</li>
<li>Provoked by Zeno’s Paradoxes - MIT Physics, accessed February 25, 2026, https://physics.mit.edu/news/provoked-by-zenos-paradoxes/</li>
<li>Zeno’s paradoxes - Wikipedia, accessed February 25, 2026, <a href="https://en.wikipedia.org/wiki/Zeno&#x27;s_paradoxes">https://en.wikipedia.org/wiki/Zeno%27s_paradoxes</a></li>
<li>The Paradoxes of Zeno | Religion and Philosophy | Research Starters, accessed February 25, 2026, https://www.ebsco.com/research-starters/religion-and-philosophy/paradoxes-zeno</li>
<li>Zeno’s Paradoxes of Motion - University of Pittsburgh, accessed February 25, 2026, https://sites.pitt.edu/~jdnorton/teaching/paradox/chapters/Zeno/Zeno.html</li>
<li>Angelo CORSARO | CEO/CTO | PhD | Corporate | Research profile, accessed February 25, 2026, https://www.researchgate.net/profile/Angelo-Corsaro</li>
<li>zenoh – the ZEro Network OverHead protocol | PDF - Slideshare, accessed February 25, 2026, https://www.slideshare.net/slideshow/zenoh-the-zero-network-overhead-protocol/143226836</li>
<li>Eclipse Zenoh: Understanding the Protocol and its Potential in Robotic, accessed February 25, 2026, https://archive.fosdem.org/2025/events/attachments/fosdem-2025-5446-eclipse-zenoh-understanding-the-protocol-and-its-potential-in-robotic/slides/238781/2025-02-0_orHjQuB.pdf</li>
<li>Zenoh Protocol Security Analysis - Census Labs, accessed February 25, 2026, https://census-labs.com/news/2025/03/17/zenoh-protocol-security-analysis/</li>
<li>zenoh: zero overhead pub/sub store/query compute | PDF - Slideshare, accessed February 25, 2026, https://www.slideshare.net/slideshow/zenoh-zero-overhead-pubsub-storequery-compute/234677562</li>
<li>Comparison of FastDDS, Zenoh and vSomeIP - ResearchGate, accessed February 25, 2026, https://www.researchgate.net/publication/391461415_Automotive_Middleware_Performance_Comparison_of_FastDDS_Zenoh_and_vSomeIP</li>
<li>(PDF) Stepping Toward Zenoh Protocol in Automotive Scenarios, accessed February 25, 2026, https://www.researchgate.net/publication/395746250_Stepping_towards_Zenoh_Protocol_in_Automotive_Scenarios/download</li>
<li>‪Angelo Corsaro‬ - ‪Google Scholar‬, accessed February 25, 2026, https://scholar.google.com/citations?user=o0xJE_4AAAAJ&amp;hl=en</li>
<li>zenoh-python, accessed February 25, 2026, https://zenoh-python.readthedocs.io/_/downloads/en/latest/pdf/</li>
<li>Enabling Location-aware Operation in Decentralized IoT … - POLITesi, accessed February 25, 2026, https://www.politesi.polimi.it/retrieve/c1c829b4-ae83-4e22-a453-4c71a6e8ed96/2024_04_Visotto.pdf</li>
<li>Advanced Zenoh Tutorial – Part II - Speaker Deck, accessed February 25, 2026, https://speakerdeck.com/kydos/advanced-zenoh-tutorial-part-ii</li>
<li>A Dataflow-Oriented Approach for Machine-Learning-Powered, accessed February 25, 2026, https://www.mdpi.com/2079-9292/12/18/3940</li>
<li>How does the Zenoh protocol enhance edge device operation?, accessed February 25, 2026, https://www.microcontrollertips.com/how-does-the-zenoh-protocol-enhance-edge-device-operation/</li>
<li>README.md - biyooon-ex/zenohex - GitHub, accessed February 25, 2026, https://github.com/biyooon-ex/zenohex/blob/main/README.md</li>
<li>Zenoh router - Datadog Docs, accessed February 25, 2026, https://docs.datadoghq.com/integrations/zenoh-router/</li>
<li>Resource Hub for Zenoh - ZettaScale Technology, accessed February 25, 2026, https://www.zettascale.tech/news/resource-hub-for-zenoh/</li>
<li>ROSCon 2024 Highlights: Conversations with Dexory, Asimovo, and, accessed February 25, 2026, https://audrownashpodcast.com/episodes/16-roscon</li>
<li>Exploring communication and streaming technologies for remote, accessed February 25, 2026, <a href="https://repository.tugraz.at/publications/marc21/0yj1n-5ct95/files/Exploring%20communication%20and%20streaming%20technologies%20for%20remote%20operations%20and%20fleet%20management-1_noSig.pdf?download=1">https://repository.tugraz.at/publications/marc21/0yj1n-5ct95/files/Exploring%20communication%20and%20streaming%20technologies%20for%20remote%20operations%20and%20fleet%20management-1_noSig.pdf?download=1</a></li>
<li>Eclipse Zenoh 1.0.0 Takes Flight - ZettaScale Technology, accessed February 25, 2026, https://www.zettascale.tech/news/eclipse-zenoh-1-0-0-takes-flight/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>