<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Appsmith 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Appsmith 안내서</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">서비스 (Services)</a> / <a href="index.html">Appsmith</a> / <span>Appsmith 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>Appsmith 안내서</h1>
<h2>1.  Appsmith: 개발자 중심 로우코드 플랫폼의 이해</h2>
<h3>1.1 Appsmith의 정의와 핵심 가치 제안</h3>
<p>Appsmith는 내부 관리 도구, 대시보드, 관리자 패널과 같은 맞춤형 비즈니스 소프트웨어를 신속하게 구축, 배포, 관리할 수 있도록 설계된 오픈소스 로우코드(low-code) 플랫폼이다.1 이 플랫폼의 핵심 가치는 개발 속도와 애플리케이션의 강력함 사이의 균형을 맞추는 데 있다. 직관적인 드래그 앤 드롭(drag-and-drop) 인터페이스를 제공하여 UI 개발 시간을 획기적으로 단축하면서도, JavaScript를 통한 코드 수준의 제어 및 확장성을 보장하여 복잡하고 정교한 애플리케이션 구축을 가능하게 한다.1 이는 전통적인 개발 방식이 제공하는 완전한 통제력과 로우코드 플랫폼이 제공하는 빠른 개발 속도라는 두 가지 장점을 결합하려는 시도로 볼 수 있다.7</p>
<p>Appsmith의 또 다른 핵심 가치는 오픈소스(Apache 2.0 라이선스)라는 점이다.9 이는 특정 벤더에 대한 기술적 종속성을 제거하고, 소스 코드의 투명성을 통해 보안에 대한 신뢰를 높이며, 활발한 커뮤니티의 지원을 받을 수 있음을 의미한다. 사용자에게 애플리케이션에 대한 완전한 통제권을 부여함으로써, 기업은 비즈니스 핵심 인프라를 외부 플랫폼에 의존하는 리스크 없이 구축할 수 있다.1</p>
<h3>1.2 주요 대상 사용자 및 시장 포지셔닝</h3>
<p>Appsmith는 코딩 경험이 없는 비즈니스 사용자를 주 대상으로 하는 ‘노코드(no-code)’ 플랫폼과 명확한 선을 긋는다. 이 플랫폼의 주 사용자는 엔지니어와 개발자다.2 따라서 SQL 쿼리, API 연동, JavaScript 로직 작성에 익숙한 기술팀이 Appsmith의 잠재력을 최대한 활용할 수 있다.11</p>
<p>시장에서 Appsmith는 ‘개발자 우선(Developer-first)’ 로우코드 플랫폼으로 포지셔닝하고 있다. 이는 로우코드의 생산성 향상 이점을 누리기 위해 개발자들이 기존에 사용하던 검증된 워크플로우, 특히 Git을 이용한 버전 관리와 같은 핵심 개발 프랙티스를 포기할 필요가 없도록 플랫폼을 설계했다는 의미다.6 이러한 접근 방식은 로우코드 도구가 개발자를 대체하는 것이 아니라, 개발자의 역량을 강화하고 반복적인 UI 개발과 같은 지루한 작업에서 해방시켜 비즈니스 로직 구현에 더 집중할 수 있도록 돕는 ’생산성 증폭기’로서의 역할을 강조한다. 이는 로우코드 시장이 초기 ‘코딩의 민주화’ 단계를 넘어, 전문 개발자들의 생산성을 극대화하는 방향으로 성숙하고 있음을 보여주는 중요한 지표다.</p>
<h3>1.3 핵심 사용 사례</h3>
<p>Appsmith는 다양한 내부 운영 도구를 구축하는 데 활용될 수 있으며, 주요 사용 사례는 다음과 같다.</p>
<ul>
<li>
<p><strong>내부 대시보드</strong>: 운영 현황, 실시간 판매 데이터, 제품 재고 등을 시각화하여 모니터링하는 대시보드를 신속하게 구축한다.2</p>
</li>
<li>
<p><strong>관리자 패널 및 CRUD 앱</strong>: 데이터베이스의 데이터를 관리하기 위한 CRUD(Create, Read, Update, Delete) 인터페이스와 관리자 패널을 구축한다. 사용자 인증, 데이터 필터링, 역할 기반 접근 제어(RBAC)와 같은 필수 기능을 쉽게 통합할 수 있다.2</p>
</li>
<li>
<p><strong>신속한 프로토타이핑</strong>: 본격적인 개발 프로젝트에 착수하기 전에 아이디어를 빠르게 시각화하고 기능적 프로토타입을 제작하여 사용자의 피드백을 받거나 기술적 타당성을 검증한다.2</p>
</li>
<li>
<p><strong>맞춤형 비즈니스 워크플로우</strong>: HR 부서의 채용 승인 시스템, IT 지원팀의 티켓 관리 도구, 재무팀의 보고서 자동화 툴 등 각 부서의 고유한 비즈니스 프로세스를 자동화하는 맞춤형 애플리케이션을 개발한다.2</p>
</li>
</ul>
<p>실제 기업 활용 사례로, GSK는 3,500대의 Linux 서버 패치 작업을 자동화하는 앱을 단 한 번의 스프린트만에 구축했으며, Block은 새로운 고객 신청 처리 속도를 50% 향상시켰다. 또한 HeyJobs는 레거시 캠페인 관리 애플리케이션에 새로운 기능을 추가하는 속도를 90%나 단축하는 성과를 거두었다.9</p>
<h2>2.  Appsmith 아키텍처 심층 분석</h2>
<h3>2.1 MVC(Model-View-Controller) 유사 아키텍처</h3>
<p>Appsmith는 현대 웹 애플리케이션 개발에서 널리 사용되는 MVC(Model-View-Controller) 디자인 패턴과 유사한 구조를 채택하고 있다. 이는 애플리케이션의 구성 요소를 데이터(Model), 사용자 인터페이스(View), 그리고 비즈니스 로직(Controller)으로 명확하게 분리하여 코드의 유지보수성과 확장성을 높이는 아키텍처다.6</p>
<ul>
<li>
<p><strong>Model (모델) - 데이터소스(Datasources)</strong>: 데이터소스는 애플리케이션의 데이터를 담당한다. PostgreSQL과 같은 데이터베이스, 외부 REST API 등 데이터가 저장되고 관리되는 서비스와의 연결 정보를 캡슐화한다. 데이터소스는 한 번 설정되면 해당 작업 공간(Workspace) 내의 모든 애플리케이션에서 공유되어 재사용될 수 있다.14</p>
</li>
<li>
<p><strong>View (뷰) - 위젯(Widgets)</strong>: 위젯은 사용자에게 보여지는 UI 요소를 구성한다. 테이블, 차트, 입력 필드, 버튼 등 Appsmith가 제공하는 다양한 시각적 컴포넌트들이 여기에 해당한다.14 위젯의 속성(예: 텍스트 내용, 색상, 표시 여부)은 정적인 값으로 설정하거나, 다른 데이터의 상태에 따라 동적으로 변하도록 JavaScript 표현식을 사용하여 바인딩할 수 있다.</p>
</li>
<li>
<p><strong>Controller (컨트롤러) - 쿼리(Queries) 및 JavaScript</strong>: 쿼리와 JavaScript 코드는 모델과 뷰 사이의 상호작용을 제어하는 컨트롤러 역할을 수행한다. 사용자가 뷰(위젯)와 상호작용할 때, 컨트롤러는 모델(데이터소스)로부터 데이터를 가져오거나(Read) 모델에 데이터를 저장하는(Write) 로직을 실행한다.14 쿼리가 실행된 후 반환된 데이터는 해당 쿼리 객체의<code>data</code> 속성에 저장되며, 이 데이터는 다시 뷰(위젯)에 바인딩되어 사용자에게 표시된다.</p>
</li>
</ul>
<h3>2.2 핵심 구성 요소의 상호작용 및 데이터 흐름</h3>
<p>Appsmith 내에서의 데이터 흐름은 크게 읽기(Read)와 쓰기(Write) 두 가지로 나눌 수 있다.</p>
<ul>
<li><strong>읽기 흐름 (Read Flow: Model → Controller → View)</strong>: 이 흐름은 데이터베이스의 데이터를 사용자에게 보여주는 과정이다.</li>
</ul>
<ol>
<li>
<p><strong>Controller (쿼리)</strong> 가 <strong>Model (데이터소스)</strong> 에 데이터 조회를 요청한다 (예: <code>SELECT * FROM users;</code>).</p>
</li>
<li>
<p><strong>Model</strong>은 요청된 데이터를 반환한다.</p>
</li>
<li>
<p><strong>Controller (JavaScript)</strong> 는 필요에 따라 반환된 데이터를 가공하거나 변환한다.</p>
</li>
<li>
<p>가공된 데이터는 <strong>View (테이블 위젯)</strong> 에 바인딩되어 사용자 화면에 표시된다.14</p>
</li>
</ol>
<ul>
<li><strong>쓰기 흐름 (Write Flow: View → Controller → Model)</strong>: 이 흐름은 사용자가 입력한 데이터를 데이터베이스에 저장하는 과정이다.</li>
</ul>
<ol>
<li>
<p>사용자가 <strong>View (폼 위젯)</strong> 에 데이터를 입력하고 ‘저장’ 버튼을 클릭한다.</p>
</li>
<li>
<p><strong>Controller (쿼리/JavaScript)</strong> 는 폼 위젯에서 입력된 데이터를 가져와 유효성을 검사하고, 이를 기반으로 <code>INSERT</code> 또는 <code>UPDATE</code> 쿼리를 실행한다.</p>
</li>
<li>
<p>생성된 쿼리는 <strong>Model (데이터소스)</strong> 에 전달되어 데이터베이스에 변경 사항을 적용한다.14</p>
</li>
</ol>
<p>자체 호스팅 환경에서 Appsmith는 일반적으로 단일 Docker 컨테이너로 배포된다. 이 컨테이너 내부에는 UI를 담당하는 React 프론트엔드, 핵심 비즈니스 로직을 처리하는 Java 기반 백엔드 서버, 실시간 동기화를 위한 경량 Node.js 서버(RTS), 그리고 애플리케이션의 구성 정보와 사용자 데이터 등을 저장하는 MongoDB가 포함되어 있다. Caddy 또는 NGINX는 리버스 프록시 서버로서 외부 요청을 적절한 내부 서비스로 라우팅하는 역할을 한다.15</p>
<h3>2.3 반응형 바인딩(Reactive Bindings)의 원리와 장점</h3>
<p>Appsmith 아키텍처의 핵심적인 특징 중 하나는 ’반응형 바인딩’이다. 이는 애플리케이션 내의 어떤 데이터(예: 쿼리 결과, 위젯의 입력값)가 변경되었을 때, 그 데이터에 의존하는 다른 모든 UI 요소들이 별도의 명령 없이 자동으로 업데이트되는 메커니즘을 의미한다.14</p>
<p>이러한 반응성은 개발자가 UI와 데이터 상태를 일치시키기 위해 복잡한 이벤트 핸들러나 콜백 함수 체인을 직접 작성해야 하는 부담을 덜어준다. 대신, 개발자는 ‘어떻게’ UI를 업데이트할지를 절차적으로 코딩하는 대신, 특정 데이터 상태에서 UI가 ’어떤 모습이어야 하는지’를 선언적으로 정의하기만 하면 된다. 예를 들어, 테이블에서 특정 행이 선택되었을 때만 ‘삭제’ 버튼을 활성화하고 싶다면, 버튼의 ‘Disabled’ 속성에 <code>{{ Table1.selectedRow? false : true }}</code> 와 같은 표현식을 바인딩하면 된다. Appsmith의 반응형 시스템이 <code>Table1.selectedRow</code>의 값이 변하는 것을 감지하고 버튼의 활성화 상태를 자동으로 갱신해준다.14</p>
<p>이러한 선언적 UI 패러다임은 React와 같은 현대 프론트엔드 프레임워크의 핵심 철학이기도 하다. Appsmith가 이 패러다임을 로우코드 환경에 성공적으로 이식했기 때문에, 현대 웹 개발에 익숙한 개발자들에게 매우 직관적이고 친숙하게 느껴지는 것이다. 이는 복잡한 프론트엔드 개발의 본질적인 어려움인 ’상태 관리(state management)’를 플랫폼 수준에서 추상화하여 해결하려는 아키텍처적 선택이며, 개발자가 UI 상태 동기화라는 부수적인 작업에서 벗어나 핵심 비즈니스 로직에 집중하게 함으로써 로우코드의 진정한 가치인 생산성 향상을 실현한다.</p>
<h2>3.  핵심 기능 및 역량 분석</h2>
<h3>3.1 시각적 UI 빌더</h3>
<p>Appsmith의 UI 개발은 그리드 스타일의 캔버스 위에서 이루어진다. 사용자는 좌측의 위젯 패널에서 테이블, 차트, 폼, 버튼 등 45개 이상(자료에 따라 80개 이상으로도 언급됨)의 사전 구축된 위젯을 캔버스로 드래그 앤 드롭하여 인터페이스를 시각적으로 구성할 수 있다.2 이 위젯들은 React를 기반으로 만들어졌으며, 반응형 디자인을 지원하여 데스크톱, 태블릿, 모바일 등 다양한 화면 크기에 자동으로 최적화된다.17</p>
<h3>3.2 데이터소스 통합</h3>
<p>Appsmith는 강력한 데이터 연결성을 자랑한다.</p>
<ul>
<li>
<p><strong>데이터베이스</strong>: PostgreSQL, MongoDB, MySQL, Microsoft SQL Server, Snowflake, Redis 등 25개 이상의 주요 관계형 및 NoSQL 데이터베이스에 대한 네이티브 커넥터를 제공한다.2</p>
</li>
<li>
<p><strong>API</strong>: 모든 REST 또는 GraphQL API 엔드포인트에 연결할 수 있어, 사실상 모든 종류의 백엔드 시스템 및 마이크로서비스와 연동이 가능하다.2</p>
</li>
<li>
<p><strong>SaaS 통합</strong>: Google Sheets, Airtable, Salesforce, HubSpot, Twilio 등 널리 사용되는 SaaS(Software as a Service) 도구와도 직접 통합하여 데이터를 가져오거나 내보낼 수 있다.12</p>
</li>
</ul>
<h3>3.3 JavaScript 확장성</h3>
<p>Appsmith의 가장 큰 특징 중 하나는 플랫폼 전반에 걸쳐 JavaScript를 사용하여 로직을 확장할 수 있다는 점이다.</p>
<ul>
<li>
<p><strong>인라인 코딩</strong>: 위젯의 속성, 쿼리 파라미터 등 플랫폼의 거의 모든 입력 필드에 <code>{{ }}</code> (Mustache) 구문을 사용하여 JavaScript 코드를 직접 삽입할 수 있다. 이를 통해 데이터를 동적으로 변환하고, 입력값의 유효성을 검사하며, 조건부 로직을 구현하는 등 무한한 유연성을 확보할 수 있다.2</p>
</li>
<li>
<p><strong>JS 객체(JS Objects)</strong>: 여러 곳에서 재사용될 함수나 변수들은 중앙화된 JavaScript 편집기 내에서 ’JS 객체’로 정의하고 관리할 수 있다. 이는 복잡한 비즈니스 로직을 모듈화하여 코드의 가독성과 유지보수성을 크게 향상시킨다.9</p>
</li>
<li>
<p><strong>외부 라이브러리</strong>: <code>lodash</code>, <code>moment.js</code>와 같은 유용한 외부 JavaScript 라이브러리를 가져와(import) 사용할 수 있어, 플랫폼이 기본적으로 제공하지 않는 복잡한 데이터 처리나 날짜 조작 등을 손쉽게 구현할 수 있다.9</p>
</li>
</ul>
<h3>3.4 보안 및 거버넌스</h3>
<p>엔터프라이즈 환경에서 요구되는 강력한 보안 및 관리 기능을 제공한다.</p>
<ul>
<li>
<p><strong>역할 기반 접근 제어(RBAC)</strong>: 사용자에게 관리자(Administrator), 개발자(Developer), 앱 뷰어(App Viewer) 등 사전 정의된 역할을 부여하여 리소스에 대한 접근 권한을 체계적으로 관리할 수 있다. 비즈니스 및 엔터프라이즈 플랜에서는 조직의 요구에 맞게 권한을 세밀하게 조정한 커스텀 역할을 생성하는 것도 가능하다.2</p>
</li>
<li>
<p><strong>SSO 및 사용자 프로비저닝</strong>: SAML, OIDC(OpenID Connect)와 같은 표준 프로토콜을 지원하여 Okta, Azure AD 등 기존의 사내 인증 시스템과 연동한 싱글 사인온(SSO)을 구현할 수 있다. 또한, SCIM 프로토콜을 통해 사용자 정보를 자동으로 동기화(프로비저닝)할 수 있다.6</p>
</li>
<li>
<p><strong>감사 로그</strong>: 누가, 언제, 어떤 작업을 수행했는지 상세한 활동 기록을 추적할 수 있는 감사 로그 기능을 제공하여 규정 준수 및 보안 감사를 지원한다.6</p>
</li>
<li>
<p><strong>자체 호스팅(Self-hosting)</strong>: Docker, Kubernetes 등 다양한 환경을 지원하여 기업의 자체 인프라 내에 Appsmith를 직접 설치하고 운영할 수 있다. 이를 통해 데이터가 외부로 유출되는 것을 원천적으로 차단할 수 있으며, 외부 네트워크와 완전히 격리된 Air-gapped 환경에서의 배포도 지원하여 최고 수준의 데이터 보안을 요구하는 금융, 국방 등의 산업에서도 활용이 가능하다.2</p>
</li>
</ul>
<h3>3.5 AI 기반 개발 지원</h3>
<p>최신 AI 기술을 통합하여 개발 생산성을 한 단계 더 끌어올린다.</p>
<ul>
<li>
<p><strong>AI 앱 및 에이전트 구축</strong>: OpenAI의 GPT, Anthropic의 Claude 등 최신 대규모 언어 모델(LLM)을 데이터베이스 및 다른 애플리케이션과 연결하여 맞춤형 AI 기반 애플리케이션 및 자동화 에이전트를 구축할 수 있다.3</p>
</li>
<li>
<p><strong>내장 코파일럿(Copilot)</strong>: Appsmith 플랫폼에 내장된 ’Appsmith AI’는 개발 과정에서 적절한 위젯을 추천하거나, 필요한 SQL 쿼리 및 JavaScript 코드를 자동으로 생성해주는 보조 개발자 역할을 수행한다.11</p>
</li>
<li>
<p><strong>자연어 기반 개발</strong>: “사용자 목록을 보여주는 테이블을 만들어줘“와 같은 자연어 프롬프트를 입력하면, Appsmith AI가 필요한 UI 컴포넌트나 코드를 생성해준다. 중요한 점은, 이렇게 생성된 결과물을 개발자가 직접 확인하고 수정할 수 있어 완전한 제어권을 유지할 수 있다는 것이다.9</p>
</li>
</ul>
<p>이러한 기능 세트는 Appsmith가 ‘탈출구(Escape Hatch)’ 철학을 기반으로 설계되었음을 보여준다. 대부분의 로우코드 플랫폼은 초기 개발은 쉽지만, 조금만 복잡한 요구사항이 발생하면 플랫폼의 한계에 부딪혀 결국 처음부터 다시 개발해야 하는 ‘로우코드의 절벽(low-code cliff)’ 문제에 직면한다. 하지만 Appsmith는 플랫폼이 제공하는 추상화(드래그 앤 드롭, 자동 쿼리 생성 등)를 통해 80%의 일반적인 작업을 신속하게 처리하고, 나머지 20%의 복잡하고 특수한 요구사항은 JavaScript 코드 삽입, 외부 라이브러리 활용, 자체 호스팅 등 강력한 ’탈출구’를 통해 해결할 수 있도록 보장한다. 이 철학은 Appsmith를 단순한 ’툴’을 넘어, 엔터프라이즈급의 복잡하고 장기적인 프로젝트를 수행할 수 있는 신뢰할 수 있는 ’플랫폼’으로 만들어주는 핵심적인 차별점이다.</p>
<h2>4.  실전 가이드: PostgreSQL을 활용한 CRUD 애플리케이션 구축</h2>
<p>이 섹션에서는 Appsmith와 PostgreSQL 데이터베이스를 연동하여 기본적인 데이터 관리 애플리케이션(CRUD)을 구축하는 전 과정을 단계별로 상세히 안내한다.</p>
<h3>4.1 단계: 환경 설정</h3>
<p>개발 환경은 Appsmith가 제공하는 클라우드 서비스를 이용하거나, 자체 서버에 직접 설치하는 방식 중 선택할 수 있다.</p>
<h4>4.1.1 Appsmith Cloud 시작하기</h4>
<p>가장 빠르고 간편한 방법은 Appsmith Cloud를 이용하는 것이다. 별도의 설치 과정 없이 <code>appsmith.com</code>에서 무료 계정을 생성하면 즉시 애플리케이션 개발을 시작할 수 있다. 이 방식은 인프라 관리에 대한 부담 없이 Appsmith의 핵심 기능에 집중하고 싶을 때 적합하다.4</p>
<h4>4.1.2 Docker를 이용한 자체 호스팅(Self-Hosting) 환경 구축</h4>
<p>데이터 보안이 중요하거나, 사내망에 있는 데이터베이스에 직접 연결해야 하는 경우 자체 호스팅 방식을 사용해야 한다. Docker를 이용하면 로컬 개발 머신이나 프라이빗 클라우드 서버에 손쉽게 Appsmith 인스턴스를 구축할 수 있다.25</p>
<ol>
<li>
<p><strong>사전 요구사항</strong>: 서버에 Docker(버전 20.10.7 이상)와 Docker Compose(버전 1.29.2 이상)가 설치되어 있어야 한다.26</p>
</li>
<li>
<p><strong><code>docker-compose.yml</code> 파일 작성</strong>: Appsmith 설치를 위한 디렉터리를 생성한 후, 해당 디렉터리 내에 아래와 같이 <code>docker-compose.yml</code> 파일을 작성한다.</p>
<pre><code class="language-YAML">version: "3"
services:
 appsmith:
   image: index.docker.io/appsmith/appsmith-ee
   container_name: appsmith
   ports:
     - "80:80"
     - "443:443"
   volumes:
     -./stacks:/appsmith-stacks
   restart: unless-stopped
</code></pre>
</li>
</ol>
<pre><code>
위 설정에서 `image`는 `appsmith-ee`(상용 에디션, 무료 플랜 포함)를 사용한다. 완전한 오픈소스 버전인 커뮤니티 에디션을 사용하려면 `appsmith-ce`로 변경한다.26

3. **컨테이너 실행**: 터미널에서 `docker-compose.yml` 파일이 있는 디렉터리로 이동한 후, 다음 명령어를 실행하여 컨테이너를 시작한다.

   ```Bash
   docker-compose up -d
</code></pre>
<p>이 명령은 필요한 도커 이미지를 다운로드하고 백그라운드에서 컨테이너를 실행한다. 초기 구동에는 최대 5분 정도 소요될 수 있다.26</p>
<ol start="4">
<li><strong>초기 설정</strong>: 웹 브라우저에서 <code>http://localhost</code> (또는 서버 IP 주소)로 접속하여 초기 관리자 계정을 생성하면 설치가 완료된다.</li>
</ol>
<p>자체 호스팅은 클라우드 버전에 비해 데이터의 완전한 통제권을 보장하고, 로컬 데이터베이스에 직접 연결할 수 있으며, Kubernetes를 활용한 고가용성(High Availability) 구성으로 성능과 확장성을 확보할 수 있다는 장점이 있다.8</p>
<h3>4.2 단계: PostgreSQL 데이터베이스 연동</h3>
<p>환경 설정이 완료되면, Appsmith 애플리케이션과 PostgreSQL 데이터베이스를 연결해야 한다.</p>
<h4>4.2.1 데이터소스 연결 설정</h4>
<ol>
<li>
<p>Appsmith 애플리케이션 편집기 화면의 왼쪽 탐색기에서 ‘Data’ 섹션의 ‘+’ 아이콘을 클릭한다.</p>
</li>
<li>
<p>사용 가능한 데이터소스 목록에서 ’PostgreSQL’을 선택한다.29</p>
</li>
<li>
<p>연결 설정 화면에서 다음 정보를 입력한다 31:</p>
</li>
</ol>
<ul>
<li>
<p><strong>Connection Mode</strong>: <code>Read / Write</code> 또는 <code>Read Only</code> 중 선택한다.</p>
</li>
<li>
<p><strong>Host Address</strong>: 데이터베이스 서버의 도메인 이름 또는 IP 주소를 입력한다.</p>
</li>
<li>
<p><strong>Port</strong>: PostgreSQL 기본 포트인 5432 또는 실제 사용 중인 포트 번호를 입력한다.</p>
</li>
<li>
<p><strong>Database Name</strong>: 연결할 데이터베이스의 이름을 입력한다.</p>
</li>
<li>
<p><strong>Authentication</strong>: 사용자 이름(User)과 비밀번호(Password)를 입력한다.</p>
</li>
<li>
<p><strong>SSL Mode</strong>: 보안 연결을 위한 SSL 모드를 선택한다. <code>Disable</code>, <code>Allow</code>, <code>Prefer</code>, <code>Require</code> 등의 옵션이 있으며, 데이터 통신을 암호화하기 위해 <code>Require</code> 모드 사용을 강력히 권장한다.31</p>
</li>
</ul>
<ol start="4">
<li>‘Test Connection’ 버튼을 클릭하여 연결 정보를 확인한 후, ‘Save’ 버튼을 눌러 데이터소스 설정을 저장한다.</li>
</ol>
<h4>4.2.2 연결 문제 해결(Troubleshooting)</h4>
<ul>
<li>
<p><strong>Appsmith Cloud IP 화이트리스팅</strong>: Appsmith Cloud 버전을 사용하는 경우, PostgreSQL 서버의 방화벽 또는 네트워크 보안 설정(<code>pg_hba.conf</code> 파일 등)에서 Appsmith의 고정 IP 주소인 <code>18.223.74.85</code>와 <code>3.131.104.27</code>로부터의 접속을 허용해야 한다. 이를 설정하지 않으면 연결 오류가 발생할 수 있다.31</p>
</li>
<li>
<p><strong>로컬 DB 연결</strong>: 자체 호스팅 환경에서 Docker 컨테이너로 실행 중인 로컬 PostgreSQL에 연결할 때는, Host Address에 <code>localhost</code> 대신 Docker의 내부 네트워크 주소인 <code>host.docker.internal</code>을 사용하거나, 두 컨테이너를 동일한 Docker 네트워크에 배치한 후 PostgreSQL 컨테이너의 이름을 호스트 주소로 사용해야 한다.34</p>
</li>
<li>
<p><strong>외부 PostgreSQL(AWS RDS 등) 연결</strong>: 자체 호스팅 Appsmith를 AWS RDS와 같은 외부 관리형 PostgreSQL에 연결하려면, <code>docker-compose.yml</code> 파일이나 Kubernetes 설정 파일에 환경 변수를 추가해야 한다. <code>APPSMITH_KEYCLOAK_DB_URL</code> 변수에 <code>postgresql://&lt;username&gt;:&lt;password&gt;@&lt;hostname&gt;/&lt;database_name&gt;?sslmode=require</code> 형식으로 연결 문자열을 설정하고, <code>SQL_TLS_ENABLED</code>를 <code>true</code>로 설정하여 SSL 연결을 활성화한다.36</p>
</li>
</ul>
<h3>4.3 단계: 데이터 조회(Read) 및 시각화</h3>
<p>데이터베이스 연결이 완료되면, 데이터를 조회하여 화면에 표시하는 기능을 구현한다.</p>
<ol>
<li>
<p><strong>테이블 위젯 추가</strong>: UI 편집기에서 ‘Widgets’ 패널을 열고 ‘Table’ 위젯을 캔버스로 드래그 앤 드롭한다.29</p>
</li>
<li>
<p><strong><code>SELECT</code> 쿼리 작성</strong>: ‘Data’ 패널에서 방금 생성한 PostgreSQL 데이터소스를 선택하고 ’+ New Query’를 클릭한다. 쿼리 편집기에 데이터를 조회하기 위한 SQL 문을 작성한다. 예를 들어, <code>users</code> 테이블의 모든 데이터를 조회하는 쿼리는 다음과 같다.</p>
<pre><code class="language-SQL">SELECT * FROM public.users;
</code></pre>
</li>
</ol>
<pre><code>
쿼리 이름을 `getUsers`와 같이 식별하기 쉬운 이름으로 변경한다.29

3. **데이터 바인딩**: 캔버스에 추가한 테이블 위젯을 선택하고, 오른쪽 속성 패널에서 'Table Data' 속성을 찾는다. 여기에 `{{getUsers.data}}`를 입력한다. 이 Mustache 구문은 `getUsers` 쿼리가 실행된 후 반환된 데이터(`data` 속성)를 테이블 위젯에 연결하라는 의미다. 쿼리가 성공적으로 실행되면 테이블에 데이터가 자동으로 채워진다.29

4. **서버 사이드 페이지네이션 및 검색 구현**:

- **페이지네이션**: 대용량 데이터를 효율적으로 처리하기 위해 서버 사이드 페이지네이션을 구현한다. 테이블 위젯은 현재 페이지 번호(`pageNo`)와 페이지당 행 수(`pageSize`) 속성을 제공한다. 이를 활용하여 `SELECT` 쿼리를 다음과 같이 수정한다.

     ```SQL
     SELECT * FROM public.users
     ORDER BY id
     LIMIT {{ usersTable.pageSize }}
     OFFSET {{ usersTable.pageOffset }};
</code></pre>
<p><code>usersTable</code>은 테이블 위젯의 이름이다. 이제 사용자가 테이블 하단의 페이지네이션 컨트롤을 조작하면, <code>pageSize</code>와 <code>pageOffset</code> 값이 자동으로 변경되고, 이 값이 반영된 쿼리가 서버로 전송되어 해당 페이지의 데이터만 가져오게 된다.31</p>
<ul>
<li>
<p><strong>검색</strong>: 검색 기능을 위해 ‘Input’ 위젯을 추가하고 이름을 <code>searchInput</code>으로 지정한다. 그 후, <code>getUsers</code> 쿼리를 다음과 같이 수정하여 입력 위젯의 텍스트를 <code>WHERE</code> 절의 <code>ILIKE</code> 조건과 바인딩한다.</p>
<pre><code class="language-SQL">SELECT * FROM public.users
WHERE name ILIKE '%{{searchInput.text}}%'
ORDER BY id
LIMIT {{ usersTable.pageSize }}
OFFSET {{ usersTable.pageOffset }};
</code></pre>
</li>
</ul>
<pre><code>
이제 사용자가 `searchInput` 위젯에 텍스트를 입력할 때마다 쿼리가 자동으로 재실행되어 검색 결과가 테이블에 실시간으로 반영된다.38

### 4.4 단계: 데이터 생성(Create)


사용자가 새로운 데이터를 입력하고 데이터베이스에 저장하는 기능을 구현한다.

1. **폼(Form) 위젯 추가**: 데이터 입력을 위한 UI로 'Form' 위젯을 캔버스에 추가한다. 폼 내부에 'Input', 'Select' 등 필요한 위젯들을 배치하여 사용자 이름, 이메일 등의 정보를 입력받도록 구성한다.41

2. **데이터 유효성 검사**: 각 입력 위젯의 속성 패널에서 'Validation' 섹션을 설정한다. 예를 들어, 특정 필드를 필수 입력(`Required`)으로 설정하거나, 이메일 형식에 맞는 정규 표현식(`Regex`)을 지정할 수 있다. 폼 위젯은 내부의 모든 입력 위젯이 유효성 검사를 통과할 때까지 'Submit' 버튼을 자동으로 비활성화하여 잘못된 데이터가 제출되는 것을 방지한다.41

3. **`INSERT` 쿼리 작성**: 새로운 `INSERT` 쿼리를 생성하고, `VALUES` 절에 폼 위젯 내부의 입력 위젯 값을 바인딩한다.

   ```SQL
   INSERT INTO public.users (name, email, gender)
   VALUES (
      '{{nameInput.text}}',
      '{{emailInput.text}}',
      '{{genderSelect.selectedOptionValue}}'
   );
</code></pre>
<p>여기서 <code>nameInput</code>, <code>emailInput</code>, <code>genderSelect</code>는 폼 내부에 있는 각 위젯의 이름이다.31</p>
<ol start="4">
<li>
<p><strong>폼 제출 이벤트 연결</strong>: 폼 위젯의 ‘Submit’ 버튼을 선택하고, 속성 패널의 ‘onClick’ 이벤트에 방금 생성한 <code>INSERT</code> 쿼리를 실행하도록 설정한다.</p>
</li>
<li>
<p><strong>UI 동기화</strong>: <code>INSERT</code> 쿼리가 성공적으로 실행되었을 때의 동작을 정의하기 위해 ‘onSuccess’ 콜백을 설정한다. 여기에 데이터 조회 쿼리(<code>getUsers.run()</code>)를 다시 실행하도록 추가하면, 데이터가 추가된 후 테이블이 자동으로 새로고침된다. 추가로 <code>showAlert('사용자가 추가되었습니다.', 'success')</code> 함수를 호출하여 사용자에게 성공 메시지를 보여줄 수 있다.41</p>
</li>
</ol>
<h3>4.5 단계: 데이터 수정(Update) 및 삭제(Delete)</h3>
<p>기존 데이터를 수정하거나 삭제하는 기능을 구현한다.</p>
<h4>4.5.1 데이터 수정(Update)</h4>
<ol>
<li>
<p><strong>수정 폼 준비</strong>: 데이터를 생성할 때 사용한 폼 위젯을 수정 기능에도 활용한다.</p>
</li>
<li>
<p><strong>데이터 바인딩</strong>: 테이블 위젯에서 특정 행을 클릭했을 때, 해당 행의 데이터가 수정 폼에 자동으로 채워지도록 설정한다. 각 입력 위젯의 ‘Default Value’ 속성에 <code>{{usersTable.selectedRow.column_name}}</code> 형식으로 바인딩한다. 예를 들어, 이름 입력 필드의 ’Default Value’는 <code>{{usersTable.selectedRow.name}}</code>이 된다.44</p>
</li>
<li>
<p><strong><code>UPDATE</code> 쿼리 작성</strong>: 새로운 <code>UPDATE</code> 쿼리를 생성한다. <code>SET</code> 절에는 수정 폼의 입력 위젯 값을, <code>WHERE</code> 절에는 테이블에서 선택된 행의 고유 ID(<code>id</code>)를 바인딩하여 수정할 대상을 특정한다.</p>
<pre><code class="language-SQL">UPDATE public.users
SET
   name = '{{nameInput.text}}',
   email = '{{emailInput.text}}'
WHERE id = {{usersTable.selectedRow.id}};
</code></pre>
</li>
</ol>
<pre><code>
이 쿼리는 `usersTable`에서 선택된 행의 `id`와 일치하는 레코드를 `nameInput`과 `emailInput`의 현재 값으로 업데이트한다.31

4. **수정 이벤트 연결**: 수정 폼의 'Submit' 버튼(레이블을 'Update'로 변경)의 'onClick' 이벤트에 `UPDATE` 쿼리를 실행하도록 설정한다. 'onSuccess' 콜백에는 `getUsers.run()`을 추가하여 수정 후 테이블을 새로고침한다.

#### 4.5.2 데이터 삭제(Delete)


1. **삭제 버튼 추가**: 테이블 위젯의 속성 패널에서 'Columns' 설정을 열고, '+ Add a new column'을 클릭하여 새 열을 추가한다. 이 열의 'Column Type'을 'Button'으로 설정하고, 버튼 레이블을 '삭제'로 지정한다.46

2. **`DELETE` 쿼리 작성**: 새로운 `DELETE` 쿼리를 생성한다. `WHERE` 절에 `triggeredRow` 속성을 사용하여 삭제 버튼이 클릭된 행의 ID를 바인딩한다.

   ```SQL
   DELETE FROM public.users WHERE id = {{usersTable.triggeredRow.id}};
</code></pre>
<p><code>triggeredRow</code>는 테이블 내에서 이벤트(이 경우, 버튼 클릭)를 발생시킨 행의 데이터를 담고 있는 특별한 속성이다.31</p>
<ol start="3">
<li><strong>삭제 이벤트 연결</strong>: 테이블에 추가한 ‘삭제’ 버튼의 ‘onClick’ 이벤트에 <code>DELETE</code> 쿼리를 실행하도록 설정한다. ‘onSuccess’ 콜백에 <code>getUsers.run()</code>을 추가하여 삭제 후 테이블을 새로고침하는 것을 잊지 말아야 한다.</li>
</ol>
<p>이러한 CRUD 구현 방식은 Appsmith의 ‘데이터 중심 UI(Data-Centric UI)’ 개발 패러다임을 잘 보여준다. 개발자는 UI 이벤트를 직접 처리하고 DOM을 조작하는 대신, ’쿼리’라는 추상화된 데이터 작업 단위를 정의하고 이를 UI 위젯의 이벤트(onClick, onSuccess)와 속성(Table Data, Default Value)에 ’바인딩’한다. 이 접근법은 UI 로직과 비즈니스 로직(데이터 처리)을 명확하게 분리하여 코드의 복잡성을 크게 낮추고, 애플리케이션의 예측 가능성과 유지보수성을 높이는 강력한 추상화를 제공한다.</p>
<h2>5.  고급 개발 기법</h2>
<p>Appsmith는 기본적인 CRUD 기능을 넘어, JavaScript를 활용한 복잡한 로직 구현, 외부 시스템과의 유연한 연동, 정교한 상태 관리 등 고급 개발 기법을 지원하여 프로 코드(Pro-code) 수준의 애플리케이션 구축을 가능하게 한다.</p>
<h3>5.1 JavaScript를 활용한 동적 UI 제어 및 데이터 변환</h3>
<p>Appsmith의 거의 모든 곳에서 JavaScript를 사용하여 정적인 UI와 데이터를 동적으로 변환할 수 있다.</p>
<ul>
<li>
<p><strong>데이터 변환</strong>: 데이터소스에서 가져온 원본 데이터가 UI 위젯이 요구하는 형식과 다를 경우, JavaScript를 사용하여 즉석에서 변환할 수 있다.</p>
</li>
<li>
<p><code>map()</code>: API로부터 받은 사용자 객체 배열에서 이름과 ID만 추출하여 Select 위젯의 옵션 형식(<code>{ label: 'John Doe', value: 1 }</code>)으로 변환하는 데 사용된다.47</p>
<pre><code class="language-JavaScript">{{ getUsers.data.map(user =&gt; ({ label: user.name, value: user.id })) }}
</code></pre>
</li>
</ul>
<pre><code>
- `filter()`: 전체 제품 목록에서 특정 조건(예: 가격이 100달러 미만)을 만족하는 제품만 필터링하여 테이블에 표시할 수 있다.47

- `reduce()`: 주문 목록 배열에서 총 주문 금액을 계산하는 등 집계 값을 구하는 데 유용하다.47

- **내장 라이브러리 활용**: `moment.js`가 내장되어 있어, `{{moment(currentRow.created_at).format('YYYY-MM-DD')}}`와 같이 복잡한 날짜 및 시간 형식 변환을 손쉽게 처리할 수 있다.47

- **동적 위젯 속성 제어**: 위젯의 속성을 고정된 값 대신 JavaScript 표현식에 바인딩하여, 다른 데이터의 상태에 따라 UI가 동적으로 반응하도록 만들 수 있다.

- **조건부 서식**: 테이블 셀의 배경색을 주문 상태(`status`) 값에 따라 다르게 표시할 수 있다.

    ```JavaScript
    {{ currentRow.status === 'completed'? 'green' : 'orange' }}
</code></pre>
<p>이 코드를 셀의 ‘Background Color’ 속성에 바인딩하면, 상태가 ’completed’인 행의 배경색은 녹색, 그 외에는 주황색으로 표시된다.47</p>
<ul>
<li><strong>Setter 메서드</strong>: JS 객체 내에서 <code>widgetName.setVisibility(boolean)</code>, <code>widgetName.setURL('...')</code>과 같은 Setter 메서드를 호출하여 프로그래밍 방식으로 다른 위젯의 상태를 직접 제어할 수 있다. 이는 복잡한 상호작용 로직을 구현할 때 유용하다.49</li>
</ul>
<h3>5.2 <code>fetch()</code> API를 이용한 비동기적 외부 API 호출</h3>
<p>Appsmith의 내장 쿼리 빌더 외에도, 표준 웹 API인 <code>fetch()</code>를 JS 객체 내에서 사용하여 더욱 유연하게 외부 API를 호출할 수 있다. 이는 <code>async/await</code> 문법과 함께 사용되어 비동기 코드를 간결하게 작성하도록 돕는다.52</p>
<ul>
<li>
<p><strong>GET 요청 예제</strong>:</p>
<pre><code class="language-JavaScript">export default {
  fetchUsers: async () =&gt; {
    const response = await fetch('https://api.example.com/users');
    const users = await response.json();
    return users;
  }
}
</code></pre>
</li>
</ul>
<pre><code>
- **POST 요청 예제 (파일 업로드)**:

  ```JavaScript
  export default {
    uploadFile: async () =&gt; {
      const file = FilePicker1.files;
      const formData = new FormData();
      formData.append('file', file);
  
      await fetch('https://api.example.com/upload', {
        method: 'POST',
        body: formData,
      });
      showAlert('File uploaded!', 'success');
    }
  }
</code></pre>
<ul>
<li><strong>동적 파라미터를 사용한 반복 호출</strong>: 쿼리나 API의 <code>run()</code> 함수에 파라미터를 전달하여 동일한 로직을 다른 데이터로 반복 실행할 수 있다. 예를 들어, 테이블에서 선택된 여러 사용자의 ID 배열을 순회하며 각 사용자를 삭제하는 API를 호출하는 것이 가능하다.53</li>
</ul>
<h3>5.3 <code>appsmith.store</code>를 활용한 전역 상태 관리(Global State Management)</h3>
<p><code>appsmith.store</code>는 애플리케이션 전역에서 접근할 수 있는 클라이언트 측 저장소로, 페이지 이동 시에도 유지되어야 하는 상태나 여러 컴포넌트가 공유하는 데이터를 관리하는 데 사용된다.</p>
<ul>
<li>
<p><strong>데이터 저장</strong>: <code>storeValue(key, value, persist)</code> 함수를 사용하여 데이터를 저장한다.</p>
<pre><code class="language-JavaScript">// 'currentUser'라는 키로 사용자 객체를 저장
{{ storeValue('currentUser', { id: 1, name: 'Admin' }) }}
</code></pre>
</li>
</ul>
<pre><code>
`persist` 인자를 `true`(기본값)로 설정하면 브라우저의 로컬 스토리지에 저장되어 브라우저를 닫았다 열어도 데이터가 유지된다. `false`로 설정하면 세션 스토리지에 저장되어 탭을 닫으면 데이터가 사라진다.48

- **데이터 조회**: `{{appsmith.store.key}}` 구문을 사용하여 저장된 값을 읽어온다.

  ```JavaScript
  // Text 위젯에 현재 사용자의 이름을 표시
  Hello, {{ appsmith.store.currentUser.name }}
</code></pre>
<ul>
<li>
<p><strong>비동기 처리</strong>: <code>storeValue()</code> 함수는 비동기적으로 동작하므로, 값을 저장한 직후에 해당 값을 사용해야 하는 경우 <code>async/await</code>를 사용하여 실행 순서를 보장해야 한다.48</p>
<pre><code class="language-JavaScript">export default {
  login: async () =&gt; {
    const user = await loginApi.run();
    await storeValue('token', user.token); // 토큰 저장이 완료될 때까지 대기
    navigateTo('Dashboard');
  }
}
</code></pre>
</li>
</ul>
<pre><code>
### 5.4 Git을 연동한 버전 관리 및 협업 워크플로우


Appsmith는 Git과의 네이티브 통합을 지원하여, 로우코드로 개발된 애플리케이션을 프로 코드 프로젝트처럼 체계적으로 관리하고 여러 개발자가 협업할 수 있도록 한다.57

- **핵심 워크플로우**:

1. **저장소 연결**: Appsmith 애플리케이션을 GitHub, GitLab, Bitbucket 등 원하는 원격 Git 저장소에 연결한다.

2. **브랜치 관리**: 기능 개발, 버그 수정 등을 위해 새로운 브랜치를 생성하고(`feature/new-dashboard`), 해당 브랜치에서 작업을 진행한다.57

3. **커밋 및 푸시**: UI 변경, 쿼리 수정 등 작업이 완료되면 변경 사항을 의미 있는 메시지와 함께 로컬 브랜치에 커밋하고, 원격 저장소로 푸시한다.59 Appsmith는 애플리케이션의 모든 구성 요소(위젯, 쿼리, JS 객체 등)를 JSON 및 JavaScript 파일 형태로 직렬화하여 Git에서 텍스트 기반으로 변경 사항을 추적할 수 있도록 한다.60

4. **풀 리퀘스트(PR) 및 코드 리뷰**: 작업이 완료된 브랜치를 `main`이나 `develop`과 같은 핵심 브랜치로 병합하기 위해 풀 리퀘스트를 생성한다. 동료 개발자들은 PR을 통해 변경 사항을 검토하고 피드백을 제공할 수 있다.

5. **병합 및 배포**: 코드 리뷰가 완료되고 승인되면, PR을 핵심 브랜치로 병합한다. 특정 브랜치(예: `production` 브랜치)에 변경 사항이 병합될 때마다 CI/CD 파이프라인(예: GitHub Actions, Jenkins)을 트리거하여 Appsmith 애플리케이션을 자동으로 배포하도록 구성할 수 있다.9

이러한 고급 기능들은 Appsmith가 단순한 '앱 빌더'를 넘어, JavaScript 생태계와 GitOps와 같은 현대적인 개발 프랙티스를 완전히 포용하는 '통합 개발 환경(IDE)'에 가깝다는 것을 보여준다. 개발자는 필요에 따라 추상화 수준을 자유롭게 조절하며, 로우코드의 편리함과 프로 코드의 유연성 사이를 넘나들 수 있다. 이는 Appsmith가 단기적인 프로토타이핑 도구를 넘어, 장기적인 유지보수가 가능한 엔터프라이즈 애플리케이션을 구축하기 위한 전략적 선택이 될 수 있음을 의미한다.

## 6.  배포, 공유 및 거버넌스


애플리케이션 개발을 완료한 후에는 이를 사용자에게 배포하고, 접근 권한을 관리하며, 필요에 따라 기존 시스템과 통합하는 과정이 필요하다. Appsmith는 이러한 애플리케이션 생애주기 전반을 지원하는 강력한 기능을 제공한다.

### 6.1 애플리케이션 배포 및 공유 전략


- **배포**: 개발 환경(Edit Mode)에서 만들어진 애플리케이션은 편집기 우측 상단의 'Deploy' 버튼을 클릭하여 사용자에게 제공되는 라이브 버전으로 즉시 게시할 수 있다.4

- **사용자 초대 및 공유**: 'Share' 버튼을 통해 다른 사용자를 이메일 주소로 작업 공간(Workspace)에 초대할 수 있다. 이때 사용자에게 적절한 역할(Administrator, Developer, App Viewer)을 부여하여 애플리케이션에 대한 접근 수준을 제어한다.2

- **공개/비공개 공유**: 애플리케이션 설정에서 'Make application public' 옵션을 활성화하면, 생성된 URL을 가진 누구나 로그인 없이 애플리케이션에 접근할 수 있다. 이 옵션을 비활성화하면 작업 공간에 초대된 특정 사용자만 로그인 후 접근할 수 있는 비공개 앱으로 유지된다.61

### 6.2 임베딩(Embedding)을 통한 기존 시스템과의 통합


Appsmith 애플리케이션은 독립적으로 사용하는 것뿐만 아니라, `&lt;iframe&gt;` 태그를 이용하여 기존의 다른 웹사이트나 사내 포털에 완벽하게 통합될 수 있다.

- **공개 임베딩(Public Embed)**: 공개로 설정된 Appsmith 앱은 제공되는 임베드 URL을 `&lt;iframe&gt;`의 `src` 속성에 넣어 어떤 웹페이지에든 손쉽게 삽입할 수 있다.61

- **비공개 임베딩(Private Embed)**: 엔터프라이즈 플랜에서 제공되는 이 기능은 보안이 중요한 내부 시스템 통합에 필수적이다. SSO(Single Sign-On)와 연동하여, 사용자가 부모 애플리케이션(예: 사내 포털)에 이미 로그인한 상태라면, 임베드된 Appsmith 앱에 별도로 다시 로그인할 필요 없이 자동으로 인증이 처리된다. 이를 통해 사용자는 여러 시스템을 하나의 통합된 환경처럼 매끄럽게 사용할 수 있다.9

- **상호작용**: `postWindowMessage()` API를 사용하면 부모 애플리케이션과 임베드된 Appsmith 앱 간에 데이터를 주고받는 양방향 통신이 가능하다. 예를 들어, 부모 애플리케이션에서 특정 고객 ID를 Appsmith 앱으로 전달하면, 임베드된 대시보드가 해당 고객의 정보만 필터링하여 보여주는 동적인 상호작용을 구현할 수 있다.64

### 6.3 역할 기반 접근 제어(RBAC) 심화: 커스텀 역할 및 권한 설정


조직의 규모가 커지고 애플리케이션의 복잡성이 증가함에 따라, 세분화된 권한 관리가 중요해진다. Appsmith는 이를 위해 강력한 역할 기반 접근 제어(RBAC) 기능을 제공한다.

- **기본 역할**: Appsmith는 인스턴스, 작업 공간, 애플리케이션의 세 가지 레벨에서 즉시 사용 가능한 기본 역할(Administrator, Developer, App Viewer)을 제공한다. 이 역할들은 일반적인 협업 시나리오에 필요한 권한들을 미리 정의해두었다.2

- **세분화된 접근 제어(Granular Access Control - GAC)**: 비즈니스 플랜 이상에서는 '커스텀 역할(Custom Roles)'을 생성하여 조직의 고유한 보안 정책에 맞는 맞춤형 권한 체계를 구축할 수 있다.23

- **권한 설정**: 커스텀 역할을 생성할 때, 특정 역할이 애플리케이션, 페이지, 데이터소스, 쿼리 등 각 개별 리소스에 대해 생성(Create), 보기(View), 수정(Edit), 삭제(Delete), 실행(Execute) 권한 중 어떤 것을 가질지 세밀하게 제어할 수 있다.68 예를 들어, '영업팀' 역할은 고객 데이터소스에 대한 조회(View) 및 실행(Execute) 권한만 가지지만, 고객 정보 페이지에 대한 수정(Edit) 권한은 갖지 못하도록 설정할 수 있다. 또한, 특정 사용자 그룹이 새로운 작업 공간을 생성하지 못하도록 제한하는 것도 가능하다.70

이러한 배포, 공유, 거버넌스 기능들은 Appsmith가 단순히 빠르게 앱을 만드는 도구를 넘어, 기업 환경에서 내부 도구의 전체 생애주기를 관리할 수 있는 플랫폼임을 보여준다. 특히 비공개 임베딩과 세분화된 접근 제어 기능은 Appsmith가 팀 단위의 소규모 프로젝트에서 시작하여 전사적인 표준 내부 도구 플랫폼으로 확장될 수 있는 잠재력을 뒷받침하는 핵심 요소다. 이는 플랫폼의 기능 설계가 초기 도입부터 기업의 성장과 확장에 따른 거버넌스 요구사항까지 모두 고려하는 장기적인 비전과 비즈니스 모델에 기반하고 있음을 시사한다.

## 7.  비교 분석 및 평가


### 7.1 주요 경쟁 플랫폼(Retool, Budibase)과의 비교 분석


Appsmith는 로우코드 시장에서 여러 플랫폼과 경쟁하고 있으며, 그중 가장 대표적인 경쟁자는 Retool과 Budibase이다. 각 플랫폼은 서로 다른 철학과 강점을 가지고 있어, 도입을 고려하는 조직의 특성과 요구사항에 따라 적합성이 달라진다.

- **Appsmith**: '개발자 우선' 철학을 바탕으로, 오픈소스(Apache 2.0) 라이선스와 강력한 JavaScript 확장성, 그리고 네이티브 Git 통합을 핵심 강점으로 내세운다. 코딩에 익숙하고 기존 개발 워크플로우를 유지하면서 생산성을 높이고자 하는 개발팀에게 가장 이상적인 선택이다.72

- **Retool**: 시장에서 가장 성숙하고 기능적으로 풍부한 플랫폼으로 평가받는다. 상용(Closed-source) 제품으로, 강력하고 유연한 개발 환경을 제공하지만, 경쟁 플랫폼에 비해 가격이 높고 특히 자체 호스팅 시 추가적인 비용 부담이 클 수 있다.75

- **Budibase**: 사용 편의성에 중점을 둔 플랫폼으로, 코딩 경험이 적은 IT 팀이나 기술에 익숙한 현업 사용자가 간단한 내부 앱을 빠르게 구축하는 데 최적화되어 있다. 내장 데이터베이스를 제공하고 시각적인 로우코드 자동화 빌더가 강점이지만, Appsmith만큼 코드 기반의 깊이 있는 커스터마이징과 확장성은 제한적이다.72

다음 표는 세 플랫폼의 핵심적인 특징을 요약하여 비교한 것이다.

| 기능/특징              | Appsmith                     | Retool             | Budibase               |
| ------------------ | ---------------------------- | ------------------ | ---------------------- |
| **타겟 사용자**         | 개발자, 엔지니어                    | 개발자                | IT 팀, 기술 지식이 있는 현업 사용자 |
| **라이선스**           | 오픈소스 (Apache 2.0)            | 상용 (Closed-source) | 오픈소스 (AGPL v3)         |
| **핵심 철학**          | 개발자 우선, 코드 확장성               | 기능 풍부, 엔터프라이즈급     | 사용 편의성, 빠른 앱 생성        |
| **JavaScript 확장성** | 매우 높음 (JS 객체, 외부 라이브러리)      | 높음                 | 제한적 (기본 로직 위주)         |
| **Git 통합**         | 네이티브 지원 (핵심 기능)              | 유료 플랜 기능           | 지원                     |
| **배포 옵션**          | 클라우드, 자체 호스팅 (Docker, K8s)   | 클라우드, 자체 호스팅       | 클라우드, 자체 호스팅           |
| **가격 모델**          | 사용자 기반 (무료 티어 존재)            | 사용자 기반 (가격 높음)     | 사용자 기반 (무료 티어 존재)      |
| **차별점**            | 강력한 JS/Git 통합, 활발한 오픈소스 커뮤니티 | 가장 성숙하고 많은 기능 제공   | 내장 DB, 로우코드 자동화 빌더     |

### 7.2 Appsmith의 장점 및 단점에 대한 비판적 고찰


#### 7.2.1 장점 (Pros)


- **오픈소스 및 자체 호스팅**: 소스 코드에 대한 완전한 접근성과 자체 인프라에 배포할 수 있는 유연성은 데이터에 대한 완전한 통제권과 높은 수준의 보안을 보장하며, 특정 벤더에 종속되는 것을 방지한다.10

- **개발자 친화적**: Git 네이티브 통합, 플랫폼 어디서나 사용 가능한 JavaScript, SQL 쿼리 편집기 등은 기존 개발자들의 워크플로우와 도구 체인을 존중하며, 새로운 기술 학습에 대한 부담을 최소화한다.2

- **높은 유연성 및 확장성**: 거의 모든 REST/GraphQL API와 연동할 수 있고, 외부 JavaScript 라이브러리를 가져와 사용할 수 있어 플랫폼의 기능을 사실상 무한히 확장할 수 있다.2

- **비용 효율성**: 강력한 기능을 갖춘 커뮤니티 에디션은 사용자 수 제한 없이 무료로 사용할 수 있으며, 유료 플랜 역시 경쟁 플랫폼 대비 합리적인 가격 정책을 가지고 있다.2

#### 7.2.2 단점 (Cons)


- **가파른 학습 곡선**: 개발자를 대상으로 설계되었기 때문에, 코딩이나 데이터베이스에 대한 경험이 부족한 비개발자나 '시민 개발자(Citizen Developer)'에게는 진입 장벽이 높게 느껴질 수 있다.10

- **UI 커스터마이징 한계**: 드래그 앤 드롭 방식은 신속한 UI 구성을 가능하게 하지만, 순수 프론트엔드 코딩(HTML/CSS)으로 구현할 수 있는 수준의 매우 세밀하고 독창적인 UI/UX 커스터마이징에는 한계가 있다는 사용자 피드백이 존재한다.18

- **성능 문제**: 수십만 건 이상의 매우 큰 데이터셋을 다루거나, 다수의 동시 사용자가 접속하는 복잡한 애플리케이션에서는 UI 반응 속도가 저하되는 등 성능 문제가 발생할 수 있다는 보고가 있다.10

- **웹 애플리케이션 전용**: Appsmith는 웹 기반의 내부 도구를 만드는 데 특화되어 있으며, 앱 스토어에 배포할 수 있는 네이티브 모바일 앱이나 데스크톱 애플리케이션 개발은 지원하지 않는다.10

결론적으로, Appsmith의 장점과 단점은 동전의 양면과 같다. '개발자 친화성'과 'JavaScript 기반의 무한한 확장성'이라는 가장 큰 장점은, 동시에 '비개발자에게는 높은 진입 장벽'이라는 단점을 만들어낸다. 이는 Appsmith가 '모두를 위한 로우코드'가 아닌, '특정 페르소나(개발자)를 위한 최고의 로우코드'를 지향하는 명확한 전략적 선택의 결과다. 따라서 조직이 Appsmith 도입을 결정할 때는 단순히 기능 목록을 비교하는 것을 넘어, 내부 개발팀의 기술 역량과 조직 문화가 Appsmith의 철학과 부합하는지에 대한 깊은 이해가 선행되어야 한다.

## 8.  결론: Appsmith 도입을 위한 전략적 제언


### 8.1 보고서 핵심 내용 요약


Appsmith는 개발자의 생산성 극대화에 초점을 맞춘 독보적인 오픈소스 로우코드 플랫폼이다. MVC와 유사한 아키텍처와 반응형 데이터 바인딩을 기반으로 하여 복잡한 UI 상태 관리를 단순화한다. 무엇보다 강력한 JavaScript 확장성과 네이티브 Git 통합은 Appsmith가 단순한 개발 도구를 넘어, 기존의 전문적인 개발 워크플로우와 완벽하게 조화를 이루는 개발 환경임을 증명한다. 이를 통해 개발팀은 반복적인 UI 개발에서 벗어나 핵심적인 비즈니스 가치 창출에 집중할 수 있다.

### 8.2 Appsmith가 최적의 선택이 될 수 있는 시나리오 분석


Appsmith는 모든 상황에 맞는 만능 해결책은 아니지만, 다음과 같은 특정 시나리오에서 가장 큰 가치를 발휘할 수 있다.

- **기술 역량이 높은 개발팀이 내부 도구 개발을 주도하는 경우**: JavaScript, SQL, Git에 익숙한 개발자들은 Appsmith의 유연성과 확장성을 십분 활용하여 고품질의 내부 도구를 기존 개발 방식보다 몇 배 빠르게 구축할 수 있다.

- **데이터 보안 및 규정 준수가 매우 중요한 경우**: 자체 호스팅(Self-hosting) 및 외부 네트워크와 완전히 격리된 Air-gapped 배포 옵션은 금융, 헬스케어, 공공 부문과 같이 데이터 주권과 보안이 최우선인 조직에 강력한 솔루션을 제공한다.

- **기존 시스템(레거시 포함)을 확장하고 통합해야 하는 경우**: 다양한 데이터베이스 및 API 커넥터와 유연한 임베딩 기능은 기존의 레거시 시스템을 현대적인 웹 UI로 감싸거나, 여러 시스템에 분산된 데이터를 하나의 통합된 뷰로 제공하는 프로젝트에 매우 효과적이다.

- **비용에 민감하거나 벤더 종속성을 피하고 싶은 경우**: 강력한 기능을 대부분 포함하고 있는 무료 커뮤니티 에디션은 초기 비용 부담 없이 로우코드 플랫폼을 도입하려는 스타트업이나 중소기업에 매력적인 대안이 될 수 있다.

### 8.3 성공적인 도입을 위한 권장 사항


Appsmith의 도입 효과를 극대화하기 위해서는 다음과 같은 전략적 접근이 권장된다.

1. **명확한 목표 설정**: 모든 종류의 애플리케이션을 Appsmith로 개발하려 하기보다는, 가장 큰 투자 대비 효과(ROI)를 기대할 수 있는 영역에 집중해야 한다. 데이터베이스의 데이터를 관리하는 CRUD 앱, 여러 데이터 소스를 취합하는 관리자 패널, 실시간 운영 현황 대시보드와 같이 명확한 목적을 가진 내부 도구부터 시작하는 것이 좋다.

2. **팀 구성 및 교육**: 프로젝트를 주도할 팀은 JavaScript와 SQL에 대한 기본적인 이해를 갖춘 인력으로 구성하는 것이 바람직하다. Appsmith가 제공하는 풍부한 공식 문서, 튜토리얼, 커뮤니티 포럼을 활용하여 초기 학습 곡선을 완만하게 만들 수 있다.

3. **점진적 도입**: 조직 전체에 한 번에 도입하기보다는, 작은 규모의 파일럿 프로젝트로 시작하여 성공 사례를 만드는 것이 중요하다. 이 성공 사례를 바탕으로 플랫폼의 가치를 조직 내에 입증하고, 점진적으로 사용 범위와 규모를 확대해 나가는 전략이 효과적이다.

4. **거버넌스 계획 수립**: 초기 단계부터 거버넌스에 대한 규칙을 수립해야 한다. 데이터소스 접근 권한 관리, 역할 기반 접근 제어(RBAC) 정책 정의, Git 브랜치 전략 수립 등을 통해 애플리케이션의 수가 늘어나도 혼란 없이 체계적으로 관리할 수 있는 기반을 마련해야 한다.

## 9. 참고 자료


1. What is Appsmith? Docs, Demo and How to Deploy - Shakudo, https://www.shakudo.io/integrations/appsmith
2. Appsmith Review 2025: Key Features, Pricing, Pros &amp; Cons - Superblocks, https://www.superblocks.com/blog/appsmith-review
3. appsmithorg/appsmith: Platform to build admin panels, internal tools, and dashboards. Integrates with 25+ databases and any API. - GitHub, https://github.com/appsmithorg/appsmith
4. Introduction | Appsmith, https://docs.appsmith.com/
5. Appsmith Review: Pricing, Features, Pros, Cons &amp; Alternatives - NoCodeList, https://nocodelist.co/software/appsmith
6. Why We Think Appsmith Is the #1 Open-source Low-code Platform, https://www.appsmith.com/blog/buying-guide-why-appsmith
7. Traditional Software Development vs. Low Code: Which Is Best for Your Business?, https://www.appsmith.com/low-code-for-developers/traditional-development-vs-lowcode
8. Combining the Power of DevOps and Low-Code with Appsmith, https://www.appsmith.com/blog/self-host-and-cicd
9. Appsmith | Open-Source Low-Code Application Platform, https://www.appsmith.com/
10. Appsmith Review (2024): Pros, Cons &amp; Is It Worth It? - Blaze.tech, https://www.blaze.tech/post/appsmith-reviews
11. Appsmith Review for 2025: Key Features and Alternatives | Adalo Blog, https://www.adalo.com/posts/appsmith
12. Appsmith review 2025: Main features, pros, cons, and alternatives - AppMySite, https://www.appmysite.com/blog/appsmith-review/
13. Generate and Build a CRUD App from Any Database with One Click - Appsmith, https://www.appsmith.com/blog/generate-a-crud-app-from-any-database-with-one-click
14. Overview - Appsmith docs, https://docs.appsmith.com/build-apps/overview
15. Deployment Architecture - Appsmith docs, https://docs.appsmith.com/getting-started/setup/deployment-architecture
16. The Appsmith Self-Hosted Architecture, https://community.appsmith.com/content/blog/appsmith-self-hosted-architecture
17. What is Appsmith: Tool overview + 3 strongest competitors | UI Bakery Blog, https://uibakery.io/blog/what-is-appsmith
18. Appsmith Platform Guide: Features, Pros &amp; Cons - Akveo, https://www.akveo.com/blog/appsmith-platform-guide
19. PostgreSQL Integration - Appsmith, https://www.appsmith.com/integration/postgresql
20. Reference - Appsmith docs, https://docs.appsmith.com/connect-data/reference
21. Write Code in Appsmith, https://docs.appsmith.com/core-concepts/writing-code
22. JS Objects - Appsmith docs, https://docs.appsmith.com/core-concepts/writing-code/javascript-editor-beta
23. Granular Access Control | Appsmith, https://docs.appsmith.com/advanced-concepts/granular-access-control
24. Differences between Cloud and Self-Hosted versions of Appsmith ..., https://community.appsmith.com/content/blog/differences-between-cloud-and-self-hosted-versions-appsmith
25. Self Hosting - Appsmith docs, https://docs.appsmith.com/getting-started/setup
26. Docker | Appsmith, https://docs.appsmith.com/getting-started/setup/installation-guides/docker
27. How to Self-host Appsmith with Docker Compose | Linode Docs, https://www.linode.com/docs/guides/deploy-appsmith-docker/
28. How to Deploy Appsmith on private instance using Docker - DEV Community, https://dev.to/noviicee/how-to-deploy-appsmith-on-private-instance-using-docker-eig
29. Build Your First App - Appsmith docs, https://docs.appsmith.com/getting-started/tutorials/build-your-first-app
30. How to Migrate Data From Sheets to Postgresql - the Appsmith Community, https://community.appsmith.com/tutorial/how-migrate-data-sheets-postgresql
31. PostgreSQL - Appsmith docs, https://docs.appsmith.com/connect-data/reference/querying-postgres
32. Security - Appsmith docs, https://docs.appsmith.com/product/security
33. Cannot connect AppSmith to local PostgreSQL server - Stack Overflow, https://stackoverflow.com/questions/72551483/cannot-connect-appsmith-to-local-postgresql-server
34. Connect to Local Datasource - Appsmith docs, https://docs.appsmith.com/connect-data/how-to-guides/how-to-work-with-local-apis-on-appsmith
35. App smith connectivity with local database - Stack Overflow, https://stackoverflow.com/questions/72685276/app-smith-connectivity-with-local-database
36. Configure External PostgreSQL (AWS RDS) | Appsmith, https://docs.appsmith.com/getting-started/setup/instance-configuration/external-postgresql-rds
37. Configure PostgreSQL for SAML SSO (Azure) - Appsmith docs, https://docs.appsmith.com/getting-started/setup/installation-guides/azure/setup-to-integrate-sso
38. Display and Lookup Data in Table | Appsmith, https://docs.appsmith.com/build-apps/how-to-guides/display-search-and-filter-table-data
39. Sample Apps - Appsmith docs, https://docs.appsmith.com/learning-and-resources/sample-apps
40. Implementing Server Side Pagination and Search Using Postgresql in Appsmith, https://community.appsmith.com/content/guide/implementing-server-side-pagination-and-search-using-postgresql-appsmith
41. Insert Data | Appsmith, https://docs.appsmith.com/build-apps/how-to-guides/insert-data
42. Insert and Update data in SQL - Appsmith docs, https://docs.appsmith.com/connect-data/how-to-guides/insert-and-update-data-in-sql
43. How To Use The Form Widget - YouTube, https://www.youtube.com/watch?v=UgpQ0ZOnzdg
44. Quickstart | Appsmith, https://docs.appsmith.com/getting-started/tutorials/the-basics/work-with-data-in-ui
45. Update data - Appsmith docs, https://docs.appsmith.com/build-apps/how-to-guides/submit-form-data
46. Edit Table Data Inline | Appsmith, https://docs.appsmith.com/reference/widgets/table/inline-editing
47. Data Transformation | Appsmith, https://docs.appsmith.com/write-code/reference/transform-data
48. storeValue() | Appsmith, https://docs.appsmith.com/reference/appsmith-framework/widget-actions/store-value
49. Bind Data to Widgets | Appsmith, https://docs.appsmith.com/core-concepts/building-ui/dynamic-ui
50. List - Appsmith docs, https://docs.appsmith.com/reference/widgets/list
51. Container - Appsmith docs, https://docs.appsmith.com/reference/widgets/container
52. Fetch API | Appsmith, https://docs.appsmith.com/write-code/reference/Fetch-API
53. Pass Runtime Parameters to Queries - Appsmith docs, https://docs.appsmith.com/connect-data/how-to-guides/how-to-pass-params-to-an-api
54. How Do I Get a Javascript Loop to Work with an API? - Appsmith Community Portal, https://community.appsmith.com/solution/how-do-i-get-javascript-loop-work-api
55. store object - Appsmith docs, https://docs.appsmith.com/reference/appsmith-framework/context-object
56. Global Functions - Appsmith docs, https://docs.appsmith.com/reference/appsmith-framework/widget-actions
57. Version Control With Git | Appsmith, https://docs.appsmith.com/advanced-concepts/version-control-with-git
58. Introducing Version Control with Git - Appsmith, https://www.appsmith.com/blog/introducing-version-control-with-git
59. Package Version Control | Appsmith, https://docs.appsmith.com/packages/reference/versioning
60. Git in Appsmith: The Details behind Our Implementation, https://www.appsmith.com/blog/appsmith-git-internal-tools-2
61. Embed Appsmith | Appsmith, https://docs.appsmith.com/advanced-concepts/embed-appsmith-into-existing-application
62. Iframe - Appsmith docs, https://docs.appsmith.com/reference/widgets/iframe
63. How To Set Up Private Embedding With SSO - YouTube, https://www.youtube.com/watch?v=Zoiy1tKcjzU
64. Communicate with Embedded Appsmith, https://docs.appsmith.com/build-apps/how-to-guides/send-messages-between-your-app-and-appsmith
65. Embed Anything! Introducing the New iFrame Widget - Appsmith, https://www.appsmith.com/blog/embed-anything-introducing-the-new-iframe-widget
66. Roles - Appsmith docs, https://docs.appsmith.com/advanced-concepts/granular-access-control/roles
67. Default Roles | Appsmith, https://docs.appsmith.com/advanced-concepts/granular-access-control/reference/default-roles
68. Custom Roles - Appsmith docs, https://docs.appsmith.com/advanced-concepts/granular-access-control/reference/custom-roles
69. Permissions - Appsmith docs, https://docs.appsmith.com/advanced-concepts/granular-access-control/reference/permissions
70. Can I Restrict User From Viewing One Page of the Application? - the Appsmith Community, https://community.appsmith.com/solution/can-i-restrict-user-viewing-one-page-application
71. Restricting Users From Creating New Workspaces | Appsmith Community Portal, https://community.appsmith.com/tutorial/restricting-users-creating-new-workspaces
72. Appsmith vs Budibase vs ToolJet: The 2025 open-source internal tool builder showdown, https://blog.tooljet.ai/appsmith-vs-budibase-vs-tooljet/
73. The Best Open-Source Alternatives to Retool In 2025 - NocoBase, https://www.nocobase.com/en/blog/retool-open-source-alternatives
74. Appsmith vs Budibase: In-Depth Comparison, https://budibase.com/blog/alternatives/appsmith-vs-budibase/
75. Budibase vs. Retool: Detailed Comparison of Low-Code Tools ..., https://www.appsmith.com/blog/budibase-vs-retool
76. Appsmith VS Retool VS Budibase or something else. What are your choices? - Reddit, https://www.reddit.com/r/selfhosted/comments/yvq6oj/appsmith_vs_retool_vs_budibase_or_something_else/
77. Appsmith Pros and Cons | User Likes &amp; Dislikes - G2, https://www.g2.com/products/appsmith/reviews?qs=pros-and-cons
78. A review of Appsmith : r/nocode - Reddit, https://www.reddit.com/r/nocode/comments/1b6777a/a_review_of_appsmith/
79. AWS Marketplace: Appsmith Community Edition Reviews, https://aws.amazon.com/marketplace/reviews/reviews-list/prodview-mclslaty46ah4
80. Appsmith Reviews 2025: Details, Pricing, &amp; Features - G2, https://www.g2.com/products/appsmith/reviews
</code></pre>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>