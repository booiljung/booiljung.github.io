<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:제어공학의 핵심 목표 안정성, 과도 응답, 정상상태 오차에 대한 안내서</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>제어공학의 핵심 목표 안정성, 과도 응답, 정상상태 오차에 대한 안내서</h1>
                    <nav class="breadcrumbs"><a href="../index.html">Home</a> / <a href="index.html">제어공학 (Control Engineering)</a> / <span>제어공학의 핵심 목표 안정성, 과도 응답, 정상상태 오차에 대한 안내서</span></nav>
                </div>
            </header>
            <article>
                <h1>제어공학의 핵심 목표 안정성, 과도 응답, 정상상태 오차에 대한 안내서</h1>
<h2>1.  제어공학의 근본 목표</h2>
<h3>1.1 제어 시스템의 정의와 필요성</h3>
<p>제어공학(Control Engineering)은 다양한 동적 시스템(dynamic system)의 거동을 원하는 대로 조작하고 유지하기 위한 이론과 기술을 다루는 학문 분야다.1 여기서 동적 시스템이란 기계, 전기, 화학 공정 등 시간에 따라 상태가 변하는 모든 시스템을 포괄한다. 제어공학의 본질은 “어떤 대상이 특정 목표 상태를 따르도록 만드는 것“으로 요약할 수 있다.2 예를 들어, 자동차의 크루즈 컨트롤 시스템은 운전자가 설정한 속도를 유지하기 위해 엔진의 스로틀 개방도를 자동으로 조절하며, 이는 제어공학의 대표적인 응용 사례다.3</p>
<p>현대 기술 사회에서 제어공학은 보이지 않는 곳에서 핵심적인 역할을 수행한다. 가정에서 사용하는 세탁기, 에어컨부터 시작하여 반도체 양산 공정, 발전소의 터빈 제어, 고성능 전투기의 비행 제어, 로봇 팔의 정밀 작업에 이르기까지 그 적용 범위는 실로 방대하다.3 이처럼 제어 시스템은 인간의 개입 없이도 시스템이 정해진 목표를 안정적으로 수행하도록 만들어 생산성과 안전성, 편의성을 극대화하는 데 필수적이다.</p>
<h3>1.2 개루프(Open-Loop)와 폐루프(Closed-Loop) 시스템</h3>
<p>제어 시스템은 그 구조에 따라 크게 개루프 시스템과 폐루프 시스템으로 나뉜다.</p>
<p>**개루프 제어(Open-Loop Control)**는 시스템의 출력값을 되먹임(feedback)하지 않고, 미리 정해진 입력에 따라 순차적으로 동작하는 방식이다.5 가장 고전적인 예로 타이머에 따라 세탁, 헹굼, 탈수 과정을 순서대로 진행하는 구형 세탁기를 들 수 있다.3 이 방식은 구조가 간단하고 비용이 저렴하다는 장점이 있지만, 시스템의 실제 동작 상태를 확인하지 않기 때문에 예측하지 못한 외란(disturbance)이나 시스템 특성 변화에 대응할 수 없다는 치명적인 단점을 가진다. 예를 들어, 세탁물의 양이 달라져도 정해진 시간만큼만 세탁하므로 최적의 세탁 품질을 보장하기 어렵다.</p>
<p>**폐루프 제어(Closed-Loop Control)**는 제어공학의 정수라 할 수 있는 피드백(feedback) 메커니즘을 기반으로 한다. 이 방식은 시스템의 실제 출력값을 센서로 측정하여 목표값(reference 또는 setpoint)과 비교하고, 그 결과 발생하는 오차(error)를 줄이는 방향으로 제어 입력을 지속해서 수정한다.4 앞서 언급한 크루즈 컨트롤이 바로 폐루프 제어의 예시이다. 차량의 실제 속도를 속도 센서로 측정하여 운전자가 설정한 목표 속도와 비교하고, 만약 오르막길을 만나 속도가 줄어들면 오차를 감지하여 스로틀을 더 열어 출력을 높인다.</p>
<p>이 피드백의 도입은 제어 시스템이 단순한 자동화 장치를 넘어, 변화하는 환경에 적응하고 목표를 강인하게(robust) 달성하는 ‘지능적’ 시스템으로 도약하는 계기가 되었다. 개루프 시스템이 이상적인 환경을 가정한다면, 폐루프 시스템은 모델링의 불확실성, 예측 불가능한 외란, 시스템 노후화 등 현실 세계의 불완전함을 인정하고 이를 적극적으로 극복하려는 시도다. 따라서 제어공학의 발전 역사는 곧 피드백 이론의 발전 역사와 그 궤를 같이한다고 해도 과언이 아니다.</p>
<h3>1.3 제어기 설계의 3대 핵심 목표</h3>
<p>효과적인 폐루프 제어 시스템을 설계하고 해석하기 위한 평가는 다음의 세 가지 핵심 목표를 기준으로 이루어진다.5</p>
<ol>
<li>
<p><strong>안정성 (Stability):</strong> 시스템이 발산하지 않고 안정된 상태를 유지할 수 있는가? 안정성은 시스템이 제 기능을 하기 위한 가장 기본적인 전제조건이다. 불안정한 시스템은 제어 불능 상태에 빠져 파괴적인 결과를 초래할 수 있으므로, 안정성 확보는 제어기 설계의 최우선 과제다.</p>
</li>
<li>
<p><strong>과도 응답 (Transient Response):</strong> 시스템이 한 정상상태에서 다른 정상상태로 이동할 때, 얼마나 빠르고 부드럽게 도달하는가? 이는 시스템의 동적 성능(dynamic performance)을 나타내는 척도로, 응답 속도, 진동(oscillation), 오버슈트(overshoot) 등의 지표로 평가된다.</p>
</li>
<li>
<p><strong>정상상태 오차 (Steady-State Error):</strong> 과도 상태가 끝난 후, 시스템의 출력이 목표값에 얼마나 정확하게 도달하는가? 이는 시스템의 정적 성능(static performance) 또는 정밀도(accuracy)를 나타내는 척도다.</p>
</li>
</ol>
<p>중요한 점은 이 세 가지 목표가 서로 독립적이지 않다는 것이다. 대부분의 경우, 하나의 성능 지표를 개선하려는 시도가 다른 지표를 악화시키는 **상충관계(Trade-off)**가 존재한다.8 예를 들어, 응답 속도를 높이기 위해 제어기 이득(gain)을 높이면 정상상태 오차는 줄어들 수 있지만, 시스템이 불안정해지거나 과도 응답 시 오버슈트가 커질 수 있다. 따라서 제어기 설계란, 주어진 시스템의 요구 사양을 만족시키기 위해 이 세 가지 목표 사이에서 최적의 균형점을 찾아가는 정교한 과정이라 할 수 있다.10</p>
<h2>2.  안정성: 시스템 존립의 제1원칙</h2>
<h3>2.1 안정성의 정의</h3>
<p>제어 시스템에서 안정성은 시스템의 출력이 제어 불가능한 상태로 발산하지 않고 유한한 범위 내에 머무르는 성질을 의미한다. 이는 제어 시스템이 의미를 갖기 위한 가장 근본적인 전제조건이다. 안정성에 대한 정의는 여러 가지가 있으나, 선형 시불변(Linear Time-Invariant, LTI) 시스템에서는 주로 다음 두 가지 관점에서 정의된다.</p>
<h4>2.1.1 BIBO (Bounded-Input, Bounded-Output) 안정성</h4>
<p>BIBO 안정성은 시스템의 안정성을 정의하는 가장 일반적이고 직관적인 방법이다. 이는 “유한한(bounded) 크기의 입력이 시스템에 가해졌을 때, 그 결과로 나오는 출력 또한 반드시 유한한 크기를 가져야 한다“는 것을 의미한다.11 만약 어떤 유한한 입력에 대해 출력이 시간이 지남에 따라 무한대로 발산한다면, 그 시스템은 BIBO 불안정하다고 정의한다. 이 정의는 시스템의 내부 구조를 알지 못하더라도 입출력 관계만으로 안정성을 판단할 수 있게 해준다.</p>
<h4>2.1.2 특성 방정식과 극점(Pole)의 위치</h4>
<p>LTI 시스템의 동적 특성은 전달함수(transfer function)로 표현되며, 특히 폐루프 전달함수의 분모를 0으로 만드는 방정식, 즉 **특성 방정식(characteristic equation)**이 시스템의 안정성을 결정하는 핵심적인 역할을 한다.</p>
<p>단위 피드백 시스템의 폐루프 전달함수 <span class="math math-inline">T(s)</span>는 다음과 같이 주어진다.</p>
<p><span class="math math-display">
T(s) = \frac{C(s)}{R(s)} = \frac{G(s)}{1 + G(s)}
</span><br />
여기서 특성 방정식은 <span class="math math-inline">1 + G(s) = 0</span> 이다 (보다 일반적인 피드백 시스템에서는 <span class="math math-inline">1 + G(s)H(s) = 0</span> 이다). 이 방정식의 근(root)을 시스템의 **폐루프 극점(closed-loop pole)**이라고 부른다.11 시스템의 시간 응답은 이 극점들의 위치에 의해 결정되며, 따라서 안정성 역시 극점의 위치를 통해 판별할 수 있다.</p>
<p>극점의 위치는 복소 s-평면(s-plane) 상에 표현되는데, 이 평면은 실수축(Real Axis)과 허수축(Imaginary Axis)으로 구성된다. 극점의 위치에 따른 안정성 조건은 다음과 같다.</p>
<ul>
<li>
<p><strong>안정 (Stable):</strong> 시스템이 안정하기 위한 필요충분조건은 <strong>모든 폐루프 극점이 s-평면의 좌반면(Left-Half Plane, LHP)에 존재하는 것</strong>이다.12 LHP에 있는 극점 <span class="math math-inline">p = -\sigma + j\omega</span>는 시간 응답에서 <span class="math math-inline">e^{-\sigma t}</span> 항을 생성한다. 여기서 실수부 <span class="math math-inline">\sigma</span>가 양수이므로, 이 항은 시간이 지남에 따라 0으로 수렴하여 응답을 안정시킨다.</p>
</li>
<li>
<p><strong>불안정 (Unstable):</strong> 단 하나의 극점이라도 s-평면의 <strong>우반면(Right-Half Plane, RHP)에 존재하면</strong> 시스템은 불안정하다. RHP에 있는 극점 <span class="math math-inline">p = \sigma + j\omega</span>는 시간 응답에서 <span class="math math-inline">e^{\sigma t}</span> 항을 생성하며, <span class="math math-inline">\sigma &gt; 0</span>이므로 이 항은 시간이 지남에 따라 무한대로 발산하여 시스템을 불안정하게 만든다.11</p>
</li>
<li>
<p><strong>임계 안정 (Marginally Stable):</strong> 극점이 <strong>허수축(imaginary axis) 상에 존재하고, 중근(repeated poles)이 아닐 경우</strong>, 시스템은 임계 안정 상태에 있다고 한다.11 이 경우 응답은 발산하지는 않지만, 감쇠하지 않는 일정한 크기의 진동을 지속하게 된다. 만약 허수축 상에 중근이 존재하면, 응답은 <span class="math math-inline">t \sin(\omega t)</span>와 같은 형태로 발산하므로 불안정하다.</p>
</li>
</ul>
<p>결론적으로, 시스템의 안정성을 판별하는 것은 특성 방정식의 모든 근이 s-평면의 좌반면에 위치하는지를 확인하는 문제로 귀결된다.</p>
<h3>2.2 대수적 판별법: Routh-Hurwitz 안정도 판별법</h3>
<p>고차 시스템의 특성 방정식의 근을 직접 계산하는 것은 매우 번거롭고 어려운 일이다. Routh-Hurwitz 안정도 판별법은 특성 방정식의 근을 직접 구하지 않고, 방정식의 계수들만을 이용하여 RHP에 존재하는 근의 개수를 판별할 수 있는 강력한 대수적 도구다.11</p>
<h4>2.2.1 판별 절차</h4>
<p>주어진 n차 특성 방정식을 다음과 같이 표현하자.</p>
<p><span class="math math-display">
a_n s^n + a_{n-1} s^{n-1} + \dots + a_1 s + a_0 = 0
</span></p>
<ol>
<li>
<p><strong>필요조건 확인:</strong> 시스템이 안정하기 위한 필요조건은 <strong>특성 방정식의 모든 계수(<span class="math math-inline">a_n, a_{n-1}, \dots, a_0</span>)가 존재하고(0이 아니고) 부호가 동일해야 한다</strong>는 것이다.15 만약 계수 중에 0이 있거나 부호가 다른 것이 있다면, 시스템은 RHP 또는 허수축에 근을 가지므로 불안정하거나 임계 안정 상태다. 이 조건은 필요조건일 뿐 충분조건은 아니므로, 조건을 만족하더라도 시스템이 불안정할 수 있다.</p>
</li>
<li>
<p><strong>Routh 배열 구성:</strong> 특성 방정식의 계수들을 이용하여 다음과 같은 Routh 배열(Routh table)을 구성한다.15</p>
</li>
</ol>
<ul>
<li>
<p>첫 번째 행에는 최고차항부터 짝수 번째 계수(<span class="math math-inline">a_n, a_{n-2}, \dots</span>)를 나열한다.</p>
</li>
<li>
<p>두 번째 행에는 홀수 번째 계수(<span class="math math-inline">a_{n-1}, a_{n-3}, \dots</span>)를 나열한다.</p>
</li>
<li>
<p>세 번째 행부터는 바로 위 두 행의 원소들을 이용하여 다음 규칙에 따라 계산한다.</p>
</li>
</ul>
<table><thead><tr><th><span class="math math-inline">s^n</span></th><th><span class="math math-inline">a_n</span></th><th><span class="math math-inline">a_{n-2}</span></th><th><span class="math math-inline">a_{n-4}</span></th><th><span class="math math-inline">\dots</span></th></tr></thead><tbody>
<tr><td><span class="math math-inline">s^{n-1}</span></td><td><span class="math math-inline">a_{n-1}</span></td><td><span class="math math-inline">a_{n-3}</span></td><td><span class="math math-inline">a_{n-5}</span></td><td><span class="math math-inline">\dots</span></td></tr>
<tr><td><span class="math math-inline">s^{n-2}</span></td><td><span class="math math-inline">b_1</span></td><td><span class="math math-inline">b_2</span></td><td><span class="math math-inline">b_3</span></td><td><span class="math math-inline">\dots</span></td></tr>
<tr><td><span class="math math-inline">s^{n-3}</span></td><td><span class="math math-inline">c_1</span></td><td><span class="math math-inline">c_2</span></td><td><span class="math math-inline">\dots</span></td><td></td></tr>
<tr><td><span class="math math-inline">\vdots</span></td><td><span class="math math-inline">\vdots</span></td><td><span class="math math-inline">\vdots</span></td><td></td><td></td></tr>
<tr><td><span class="math math-inline">s^0</span></td><td><span class="math math-inline">d_1</span></td><td></td><td></td><td></td></tr>
</tbody></table>
<p>여기서 <span class="math math-inline">b_1, b_2, c_1</span> 등은 다음과 같이 계산된다.<br />
<span class="math math-display">
b_1 = \frac{a_{n-1}a_{n-2} - a_n a_{n-3}}{a_{n-1}}
</span></p>
<p><span class="math math-display">
b_2 = \frac{a_{n-1}a_{n-4} - a_n a_{n-5}}{a_{n-1}}
</span></p>
<p><span class="math math-display">
c_1 = \frac{b_1 a_{n-3} - a_{n-1} b_2}{b_1}
</span></p>
<ol start="3">
<li><strong>안정도 판별:</strong> Routh 배열의 <strong>제1열에 있는 모든 원소들(<span class="math math-inline">a_n, a_{n-1}, b_1, c_1, \dots, d_1</span>)의 부호를 조사한다.</strong> 제1열 원소들의 <strong>부호가 바뀌는 횟수</strong>가 바로 RHP에 존재하는 특성 방정식 근의 개수와 정확히 일치한다.17 따라서, 시스템이 안정하기 위한 필요충분조건은 <strong>Routh 배열 제1열의 모든 원소들의 부호가 동일한 것</strong>이다.15</li>
</ol>
<h4>2.2.2 특수 경우 처리</h4>
<p>Routh 배열을 구성하는 과정에서 두 가지 특수한 경우가 발생할 수 있다.</p>
<ul>
<li>
<p><strong>제1열에 0이 나타나는 경우:</strong> 어떤 행의 첫 번째 원소만 0이고 나머지 원소는 0이 아닐 경우, 계산을 계속할 수 없다. 이 경우, 0을 매우 작은 양수 <span class="math math-inline">\epsilon</span>으로 치환한 후, <span class="math math-inline">\epsilon \to 0^+</span>의 극한을 고려하여 계산을 진행한다.15 제1열에서 <span class="math math-inline">\epsilon</span>의 위아래 원소의 부호를 비교하여 부호 변화 여부를 판단한다.</p>
</li>
<li>
<p><strong>한 행의 모든 원소가 0이 되는 경우:</strong> 이는 특성 방정식이 허수축에 대해 대칭적인 근(예: 허수축 상의 공액근, 원점 대칭인 실수근 등)을 가짐을 의미한다. 이 경우, 0이 된 행 바로 위의 행의 계수들을 이용하여 <strong>보조 방정식(auxiliary equation)</strong> <span class="math math-inline">A(s)</span>를 만든다. 그리고 이 보조 방정식을 <span class="math math-inline">s</span>에 대해 미분한 <span class="math math-inline">dA(s)/ds</span>의 계수들로 0이 된 행을 대체하여 배열 계산을 계속 진행한다.15 보조 방정식의 근 또한 특성 방정식의 근이므로, 이를 통해 허수축 상의 근을 직접 찾을 수도 있다.</p>
</li>
</ul>
<h3>2.3 그래프적 판별법 1: 근궤적 기법 (Root Locus Method)</h3>
<p>Routh-Hurwitz 판별법이 시스템의 안정 여부만을 알려주는 ’판별기’라면, 근궤적 기법은 시스템 파라미터(주로 제어기 이득 <span class="math math-inline">K</span>)의 변화에 따라 안정성이 어떻게 변하고 시스템의 동적 성능이 어떻게 달라지는지를 시각적으로 보여주는 강력한 ‘설계 및 분석’ 도구다.14</p>
<p>근궤적이란, 개루프 전달함수 <span class="math math-inline">G(s)H(s)</span>에 이득 <span class="math math-inline">K</span>가 곱해진 시스템에서 <span class="math math-inline">K</span>를 0부터 무한대까지 변화시킬 때, 폐루프 극점들이 s-평면 상에서 그리는 궤적을 의미한다.20 특성 방정식은 <span class="math math-inline">1 + KG(s)H(s) = 0</span> 이므로, 근궤적은 <span class="math math-inline">KG(s)H(s) = -1</span>을 만족하는 모든 복소수 <span class="math math-inline">s</span>의 집합이다. 이 복소수 방정식은 다음과 같은 두 개의 조건으로 분리될 수 있다.</p>
<ol>
<li>
<p><strong>각도 조건 (Angle Condition):</strong> <span class="math math-inline">\angle G(s)H(s) = \pm 180^\circ(2k+1)</span>, (단, <span class="math math-inline">k = 0, 1, 2, \dots</span>)</p>
</li>
<li>
<p><strong>크기 조건 (Magnitude Condition):</strong> <span class="math math-inline">K\vert G(s)H(s)\vert = 1</span></p>
</li>
</ol>
<p>근궤적 선도는 각도 조건을 만족하는 모든 점들을 s-평면에 그린 것이며, 특정 <span class="math math-inline">K</span> 값에 대한 극점의 위치는 크기 조건을 이용하여 찾을 수 있다.14</p>
<h4>2.3.1 근궤적 작도 규칙</h4>
<p>복잡한 계산 없이 근궤도의 대략적인 형태를 그리기 위해 다음과 같은 규칙들이 사용된다.</p>
<ol>
<li>
<p><strong>출발점과 종착점:</strong> 근궤적은 <span class="math math-inline">K=0</span>일 때 개루프 극점에서 출발하여, <span class="math math-inline">K=\infty</span>일 때 개루프 영점에서 끝난다.14 영점의 개수가 극점의 개수보다 적을 경우, 일부 궤적은 무한대로 향한다.</p>
</li>
<li>
<p><strong>대칭성:</strong> 개루프 전달함수의 계수들이 모두 실수이므로, 극점과 영점은 실수이거나 복소 공액쌍으로 존재한다. 따라서 근궤적은 항상 실수축에 대해 대칭이다.21</p>
</li>
<li>
<p><strong>실수축 상의 궤적:</strong> 실수축 상의 어떤 점을 기준으로 그 점의 오른쪽에 위치하는 개루프 극점과 영점의 총 개수가 홀수이면, 그 점은 근궤적 상에 존재한다.21</p>
</li>
<li>
<p><strong>점근선:</strong> 무한대로 향하는 궤적은 점근선을 따라간다. 극점의 개수를 <span class="math math-inline">n</span>, 영점의 개수를 <span class="math math-inline">m</span>이라 할 때, <span class="math math-inline">n-m</span>개의 점근선이 존재한다.</p>
</li>
</ol>
<ul>
<li>
<p><strong>점근선의 각도:</strong> <span class="math math-inline">\phi_a = \frac{\pm 180^\circ(2k+1)}{n-m}</span> (단, <span class="math math-inline">k = 0, 1, 2, \dots, n-m-1</span>).22</p>
</li>
<li>
<p><strong>실수축 교차점:</strong> <span class="math math-inline">\sigma_a = \frac{\sum (\text{모든 극점}) - \sum (\text{모든 영점})}{n-m}</span>.22</p>
</li>
</ul>
<ol start="5">
<li>
<p><strong>이탈점(Breakaway Point) 및 진입점(Break-in Point):</strong> 두 개 이상의 궤적이 실수축에서 만나 복소평면으로 갈라지는 지점(이탈점) 또는 복소평면에서 실수축으로 합쳐지는 지점(진입점)을 의미한다. 이 지점들은 특성 방정식을 <span class="math math-inline">K</span>에 대해 정리한 식 <span class="math math-inline">K = -1/G(s)H(s)</span>를 <span class="math math-inline">s</span>에 대해 미분하여 <span class="math math-inline">dK/ds = 0</span>을 만족하는 근을 구함으로써 찾을 수 있다.23</p>
</li>
<li>
<p><strong>허수축 교차점:</strong> 근궤적이 허수축을 가로지르는 점은 시스템이 임계 안정 상태가 되는 지점이다. 이 점은 Routh-Hurwitz 판별법을 이용하여 특정 행을 0으로 만드는 <span class="math math-inline">K</span> 값을 찾거나, 특성 방정식에 <span class="math math-inline">s=j\omega</span>를 대입하여 실수부와 허수부를 각각 0으로 만드는 <span class="math math-inline">\omega</span>와 <span class="math math-inline">K</span> 값을 구함으로써 찾을 수 있다.23</p>
</li>
</ol>
<p>근궤적을 통해 설계자는 이득 <span class="math math-inline">K</span> 값의 변화에 따른 시스템의 안정성 변화를 직관적으로 파악할 수 있다. 예를 들어, 근궤적이 허수축을 넘어 RHP로 진입하는 <span class="math math-inline">K</span> 값의 범위를 알면, 시스템이 안정하기 위한 이득의 범위를 결정할 수 있다.</p>
<h3>2.4 그래프적 판별법 2: 주파수 응답 기법 (Frequency Response Method)</h3>
<p>주파수 응답 기법은 시스템에 정현파(sinusoidal) 입력을 가했을 때, 정상상태에서 출력이 어떻게 나타나는지를 분석하는 방법이다. 이 방법의 가장 큰 장점은 시스템의 정확한 수학적 모델(전달함수)을 모르더라도, 실험적으로 주파수 응답 데이터만 얻으면 시스템의 안정성을 분석할 수 있다는 점이다.25</p>
<h4>2.4.1 나이퀴스트 안정도 판별법 (Nyquist Stability Criterion)</h4>
<p>나이퀴스트 판별법은 개루프 전달함수의 주파수 응답 <span class="math math-inline">G(j\omega)H(j\omega)</span>를 복소평면에 그린 궤적, 즉 **나이퀴스트 선도(Nyquist plot)**를 이용하여 폐루프 시스템의 안정도를 판별하는 강력한 그래프적 도구다.25</p>
<p>이 방법은 복소 해석학의 **편각 원리(Argument Principle)**에 기반한다. 편각 원리를 안정도 판별에 적용한 핵심 공식은 다음과 같다.</p>
<p><span class="math math-display">
Z = N + P
</span><br />
각 변수의 의미는 다음과 같다.27</p>
<ul>
<li>
<p><span class="math math-inline">P</span>: s-평면의 RHP에 존재하는 <strong>개루프(open-loop)</strong> 극점의 개수. 이는 시스템 설계 시 보통 알려져 있는 값이다. 만약 개루프 시스템 자체가 안정하다면 <span class="math math-inline">P=0</span>이다.</p>
</li>
<li>
<p><span class="math math-inline">N</span>: 나이퀴스트 선도(<span class="math math-inline">\omega</span>가 <span class="math math-inline">-\infty</span>에서 <span class="math math-inline">+\infty</span>까지 변할 때의 <span class="math math-inline">G(j\omega)H(j\omega)</span> 궤적)가 복소평면 상의 <strong>임계점 <code>(-1, j0)</code>을 시계방향(CW)으로 감싸는(encircle) 횟수</strong>. 반시계방향(CCW)으로 감싸면 음수로 계산한다.</p>
</li>
<li>
<p><span class="math math-inline">Z</span>: s-평면의 RHP에 존재하는 <strong>폐루프(closed-loop)</strong> 극점의 개수. 이 값이 바로 우리가 알고자 하는 값이다.</p>
</li>
</ul>
<p>폐루프 시스템이 안정하려면 RHP에 폐루프 극점이 없어야 하므로, <strong>안정 조건은 <span class="math math-inline">Z=0</span>이다.</strong> 따라서, 나이퀴스트 판별법을 이용한 안정성 분석은 <span class="math math-inline">P</span> 값을 알고, 나이퀴스트 선도를 그려 <span class="math math-inline">N</span> 값을 구한 뒤, <span class="math math-inline">Z = N + P</span>를 계산하여 <span class="math math-inline">Z</span>가 0인지를 확인하는 과정이다.</p>
<p>특히, 개루프 시스템이 안정한 경우(<span class="math math-inline">P=0</span>), 폐루프 시스템이 안정하기 위한 조건은 <span class="math math-inline">Z = N = 0</span>이 된다. 즉, <strong>나이퀴스트 선도가 <code>(-1, j0)</code> 점을 감싸지 않아야 한다</strong>는 간단한 조건으로 귀결된다.27</p>
<h4>2.4.2 상대 안정도 (Relative Stability)</h4>
<p>나이퀴스트 선도는 시스템의 안정 여부(절대 안정도)뿐만 아니라, 시스템이 안정하다면 “얼마나” 안정적인지, 즉 안정성의 여유가 어느 정도인지를 나타내는 **상대 안정도(Relative Stability)**에 대한 중요한 정보를 제공한다.13 상대 안정도는 시스템 모델의 불확실성이나 파라미터 변화에 대한 시스템의 강인성(Robustness)을 나타내는 척도이며, 이득 여유와 위상 여유로 정량화된다.</p>
<ul>
<li>
<p><strong>이득 여유 (Gain Margin, GM):</strong> 위상 지연이 정확히 <code>-180°</code>가 되는 주파수(위상 교차 주파수, <span class="math math-inline">\omega_{pc}</span>)에서, 시스템이 불안정해지기(이득이 1이 되기)까지 추가적으로 허용할 수 있는 이득의 크기를 의미한다. 나이퀴스트 선도에서는 궤적이 음의 실수축을 가로지르는 점의 크기의 역수로 정의된다. 예를 들어, 이 점이 <code>-0.5</code>라면 이득 여유는 2(6dB)이며, 이는 이득을 2배까지 키워도 시스템이 안정함을 의미한다.25</p>
</li>
<li>
<p><strong>위상 여유 (Phase Margin, PM):</strong> 개루프 이득의 크기가 1 (0dB)이 되는 주파수(이득 교차 주파수, <span class="math math-inline">\omega_{gc}</span>)에서, 시스템이 불안정해지기(위상이 -180°가 되기)까지의 추가적인 위상 지연 허용치를 각도로 나타낸 것이다. 나이퀴스트 선도에서는 원점에서 거리가 1인 단위원과 궤적이 만나는 점과 음의 실수축이 이루는 각도로 정의된다.25</p>
</li>
</ul>
<p>일반적으로 이득 여유는 6dB 이상, 위상 여유는 30°~60° 정도를 확보하는 것이 바람직하다고 알려져 있다.25 이 값들은 시스템의 ’안전 마진’을 의미하며, 특히 위상 여유는 과도 응답 특성과 밀접한 관련이 있다. 위상 여유가 작을수록 과도 응답 시 오버슈트와 진동(ringing)이 심해지는 경향이 있다.30</p>
<p>이처럼 안정성을 판별하는 세 가지 주요 방법—Routh-Hurwitz, 근궤적, 나이퀴스트—은 동일한 질문에 대해 각기 다른 관점과 정보를 제공하는 상호 보완적인 도구들이다. Routh-Hurwitz는 특성 방정식의 계수만으로 안정 여부를 신속하게 판별하는 대수적 방법이다. 근궤적은 시스템 파라미터(이득) 변화에 따른 극점의 동적인 움직임을 시각화하여 안정성뿐만 아니라 과도 응답 특성까지 예측하게 해주는 설계 지향적 도구다. 나이퀴스트 판별법은 시스템의 수학적 모델이 불완전하거나 실험 데이터만 있을 때도 적용 가능한 강력한 분석 도구이며, 상대 안정도라는 중요한 강인성 척도를 제공한다. 따라서 제어 시스템 엔지니어는 문제의 성격에 따라 이 도구들을 적절히 선택하고 조합하여 시스템을 종합적으로 분석하고 설계해야 한다.</p>
<h2>3.  과도 응답: 동적 성능의 척도</h2>
<h3>3.1 과도 응답의 정의</h3>
<p>과도 응답(Transient Response)이란, 시스템에 기준 입력이 인가되거나 외란이 발생하는 등 시스템의 상태가 변화할 때, 출력이 새로운 정상상태(steady-state)에 도달하기 전까지 나타나는 동적인 응답을 의미한다.32 이 응답 구간에서는 일반적으로 출력 신호가 진동하거나 시간에 따라 변하는 파형을 그린다. 과도 응답 특성은 시스템이 얼마나 빠르고, 부드럽고, 안정적으로 목표값에 접근하는지를 나타내는 동적 성능의 핵심 지표다. 우수한 제어 시스템은 원하는 과도 응답 특성을 갖도록 설계되어야 한다.</p>
<h3>3.2 표준 시험 입력 (Standard Test Inputs)</h3>
<p>시스템의 과도 응답 성능을 객관적이고 일관된 기준으로 평가하기 위해, 수학적으로 정의된 몇 가지 표준 시험 입력을 사용한다.33</p>
<ul>
<li>
<p><strong>단위 계단 입력 (Unit Step Input):</strong> 시간 <span class="math math-inline">t=0</span>에서 입력값이 0에서 1로 순간적으로 변하고 그 값을 유지하는 신호다. 수학적으로 <span class="math math-inline">r(t) = u(t)</span>, 라플라스 변환으로는 <span class="math math-inline">R(s) = 1/s</span>로 표현된다. 이는 시스템의 위치를 갑자기 변경시키는 상황을 모사하며, 과도 응답 특성을 분석하는 데 가장 보편적으로 사용된다. 단위 계단 입력에 대한 응답을 인디셜 응답(indicial response)이라고도 한다.33</p>
</li>
<li>
<p><strong>단위 임펄스 입력 (Unit Impulse Input):</strong> 시간 <span class="math math-inline">t=0</span>에서 무한대의 크기를 갖고 면적은 1인 이상적인 충격 신호다. 수학적으로 <span class="math math-inline">r(t) = \delta(t)</span>, 라플라스 변환으로는 <span class="math math-inline">R(s) = 1</span>로 표현된다. 이는 시스템에 가해지는 순간적인 충격에 대한 고유 응답 특성을 파악하는 데 사용된다. LTI 시스템의 임펄스 응답은 시스템 전달함수의 역 라플라스 변환과 같다.32</p>
</li>
<li>
<p><strong>단위 경사 입력 (Unit Ramp Input):</strong> 시간 <span class="math math-inline">t=0</span>부터 일정한 기울기(1)로 계속 증가하는 신호다. 수학적으로 <span class="math math-inline">r(t) = t \cdot u(t)</span>, 라플라스 변환으로는 <span class="math math-inline">R(s) = 1/s^2</span>로 표현된다. 이는 목표값이 일정한 속도로 움직이는 상황을 모사하며, 시스템의 속도 추종 성능을 평가하는 데 사용된다. 경사 입력에 대한 응답을 등속 응답이라고도 한다.33</p>
</li>
</ul>
<h3>3.3 차 시스템의 과도 응답</h3>
<p>가장 간단한 동적 시스템인 1차 시스템의 표준 전달함수는 다음과 같다.</p>
<p><span class="math math-display">
G(s) = \frac{1}{Ts + 1}
</span><br />
이 시스템의 과도 응답 특성은 오직 하나의 파라미터, 즉 **시정수(Time Constant, T)**에 의해 결정된다.32 시정수는 시스템 응답의 빠르기를 나타내는 척도다. 단위 계단 입력을 가했을 때, 1차 시스템의 시간 응답 <span class="math math-inline">y(t)</span>는 다음과 같다.</p>
<p><span class="math math-display">
y(t) = 1 - e^{-t/T}
</span><br />
이 식으로부터 시정수 <span class="math math-inline">T</span>의 의미를 파악할 수 있다.</p>
<ul>
<li>
<p>시간이 <span class="math math-inline">t=T</span>일 때, 응답 <span class="math math-inline">y(T) = 1 - e^{-1} \approx 0.632</span>가 되어 최종값의 63.2%에 도달한다.</p>
</li>
<li>
<p>시간이 <span class="math math-inline">t=4T</span>가 되면, 응답 <span class="math math-inline">y(4T) = 1 - e^{-4} \approx 0.982</span>로 최종값의 98% 이상에 도달하므로, 실용적으로 <span class="math math-inline">4T</span>를 1차 시스템의 정착 시간(settling time)으로 간주하기도 한다.32</p>
</li>
</ul>
<p>결론적으로, 시정수 <span class="math math-inline">T</span>가 작을수록 시스템은 더 빨리 정상상태에 도달하며, 이는 더 빠른 응답 속도를 의미한다.</p>
<h3>3.4 차 시스템의 과도 응답</h3>
<p>실제 물리 시스템은 질량, 관성, 탄성, 인덕턴스, 커패시턴스 등의 요소를 포함하므로 2차 시스템으로 근사되는 경우가 매우 많다. 따라서 2차 시스템의 과도 응답 분석은 제어공학에서 매우 중요하다. 2차 시스템의 표준 폐루프 전달함수는 다음과 같이 표현된다.35</p>
<p><span class="math math-display">
\frac{C(s)}{R(s)} = \frac{\omega_n^2}{s^2 + 2\zeta\omega_n s + \omega_n^2}
</span><br />
이 시스템의 특성은 두 개의 중요한 파라미터에 의해 결정된다.</p>
<ul>
<li>
<p><span class="math math-inline">\zeta</span> (zeta): <strong>감쇠비(Damping Ratio)</strong>. 시스템의 진동 감쇠 정도를 나타내는 무차원 수.</p>
</li>
<li>
<p><span class="math math-inline">\omega_n</span> (omega-n): <strong>비감쇠 고유 주파수(Undamped Natural Frequency)</strong>. 감쇠가 없을 때(<span class="math math-inline">\zeta=0</span>) 시스템이 진동하는 주파수(rad/s).</p>
</li>
</ul>
<h4>3.4.1 감쇠비(<span class="math math-inline">\zeta</span>)에 따른 응답 분류</h4>
<p>2차 시스템의 과도 응답 형태는 특성 방정식 <span class="math math-inline">s^2 + 2\zeta\omega_n s + \omega_n^2 = 0</span>의 근, 즉 폐루프 극점의 형태에 따라 결정되며, 이는 감쇠비 <span class="math math-inline">\zeta</span> 값에 의해 좌우된다.37</p>
<ul>
<li>
<p><strong>부족 감쇠 (Underdamped, 0 &lt; <span class="math math-inline">\zeta</span> &lt; 1):</strong> 가장 일반적인 응답 형태로, 출력이 목표값을 지나쳤다가(오버슈트) 진동하면서 점차 정상상태로 수렴한다. 이 경우 특성 방정식은 한 쌍의 복소 공액근 <span class="math math-inline">s = -\zeta\omega_n \pm j\omega_n\sqrt{1-\zeta^2}</span>을 갖는다.37</p>
</li>
<li>
<p><strong>임계 감쇠 (Critically Damped, <span class="math math-inline">\zeta</span> = 1):</strong> 오버슈트 없이 가장 빠르게 정상상태에 도달하는 이상적인 응답이다. 특성 방정식은 <span class="math math-inline">s = -\omega_n</span>이라는 실수의 중근을 갖는다.37</p>
</li>
<li>
<p><strong>과다 감쇠 (Overdamped, <span class="math math-inline">\zeta</span> &gt; 1):</strong> 오버슈트 없이 느리게 정상상태로 수렴하는 응답이다. 특성 방정식은 서로 다른 두 개의 음의 실근을 갖는다.37</p>
</li>
<li>
<p><strong>무감쇠 (Undamped, <span class="math math-inline">\zeta</span> = 0):</strong> 감쇠 없이 일정한 진폭으로 계속 진동하는 응답이다. 특성 방정식은 순허수근 <span class="math math-inline">s = \pm j\omega_n</span>을 갖는다.37</p>
</li>
</ul>
<h3>3.5 과도 응답 성능 지표 (Performance Indices)</h3>
<p>실용적인 제어 시스템 설계에서는 주로 약간의 오버슈트를 허용하면서도 빠른 응답을 얻을 수 있는 부족 감쇠(<span class="math math-inline">0 &lt; \zeta &lt; 1</span>) 시스템을 목표로 한다. 이러한 부족 감쇠 응답의 성능을 정량적으로 평가하기 위해 다음과 같은 지표들이 사용된다.32</p>
<ul>
<li>
<p><strong>상승 시간 (Rise Time, <span class="math math-inline">t_r</span>):</strong> 응답이 최종값의 특정 범위(예: 10%에서 90% 또는 부족 감쇠의 경우 0%에서 100%)에 도달하는 데 걸리는 시간이다. 시스템의 반응 속도를 나타내는 직접적인 척도다.</p>
</li>
<li>
<p><strong>최대값 시간 (Peak Time, <span class="math math-inline">t_p</span>):</strong> 응답이 첫 번째 최고점, 즉 피크(peak)에 도달하는 데 걸리는 시간이다.</p>
</li>
<li>
<p><strong>최대 오버슈트 (Maximum Overshoot, <span class="math math-inline">M_p</span>):</strong> 응답의 최대값이 최종 정상상태 값을 초과하는 가장 큰 양을 의미한다. 보통 최종값에 대한 백분율(<code>%OS</code>)로 표현하며, 시스템의 상대적인 안정성을 나타내는 중요한 지표다.</p>
</li>
<li>
<p><strong>정착 시간 (Settling Time, <span class="math math-inline">t_s</span>):</strong> 응답 곡선이 최종값의 특정 허용 오차 범위(일반적으로 ±2% 또는 ±5%) 내로 들어와서 다시는 그 범위를 벗어나지 않는 데 걸리는 시간이다. 응답이 얼마나 빨리 안정되는지를 나타낸다.</p>
</li>
</ul>
<p>이 성능 지표들은 2차 시스템의 파라미터 <span class="math math-inline">\zeta</span>와 <span class="math math-inline">\omega_n</span>에 의해 수학적으로 결정된다. 이는 역으로, 원하는 성능 지표(예: 오버슈트 10% 이하, 정착 시간 2초 이내)를 만족시키기 위해 필요한 <span class="math math-inline">\zeta</span>와 <span class="math math-inline">\omega_n</span> 값을 결정할 수 있음을 의미하며, 이는 제어기 설계의 핵심 과정이다.</p>
<p>2차 시스템의 과도 응답 성능 지표들은 s-평면 상의 극점 위치 <span class="math math-inline">s = -\sigma \pm j\omega_d</span> (<span class="math math-inline">\sigma = \zeta\omega_n</span>, <span class="math math-inline">\omega_d = \omega_n\sqrt{1-\zeta^2}</span>)와 직접적인 기하학적 관계를 맺는다. 극점의 위치를 조절하는 것은 곧 과도 응답 특성을 설계하는 것과 같다.</p>
<p>단위 계단 응답식 <span class="math math-inline">y(t) = 1 - \frac{e^{-\sigma t}}{\sqrt{1-\zeta^2}}\sin(\omega_d t + \theta)</span>에서, 응답의 감쇠 속도는 포락선(envelope) <span class="math math-inline">e^{-\sigma t}</span>에 의해 결정된다. 이 감쇠율은 극점의 실수부 <span class="math math-inline">-\sigma</span>의 크기에 비례한다. 따라서 정착 시간(<span class="math math-inline">t_s \approx 4/\sigma</span>)은 극점이 s-평면의 왼쪽으로 멀어질수록(실수부의 절댓값이 커질수록) 짧아진다. 이는 더 빠르고 안정적인 응답을 의미한다.</p>
<p>응답의 진동 주파수는 <span class="math math-inline">\sin(\omega_d t + \theta)</span>의 감쇠 진동 주파수 <span class="math math-inline">\omega_d</span>에 의해 결정되며, 이는 극점의 허수부 크기와 같다. 상승 시간과 최대값 시간은 이 <span class="math math-inline">\omega_d</span>에 반비례하므로, 극점이 허수축을 따라 위아래로 멀어질수록 응답이 더 빠르게 진동한다.</p>
<p>마지막으로, 최대 오버슈트는 오직 감쇠비 <span class="math math-inline">\zeta</span>에만 의존한다. s-평면에서 <span class="math math-inline">\zeta</span>는 원점과 극점을 잇는 선이 음의 실수축과 이루는 각도 <span class="math math-inline">\theta</span>와 <span class="math math-inline">\zeta = \cos(\theta)</span>의 관계를 가진다. 극점이 허수축에 가까워질수록(각도 <span class="math math-inline">\theta</span>가 90도에 가까워질수록) <span class="math math-inline">\zeta</span>는 작아지고 오버슈트는 급격히 커진다.</p>
<p>이처럼 s-평면상의 극점 위치는 과도 응답의 핵심 지표들을 시각적으로 함축하고 있으며, 제어기 설계는 원하는 성능을 만족시키는 극점의 위치를 찾아가는 과정이라고 할 수 있다.</p>
<p>다음 표는 2차 부족 감쇠 시스템의 주요 성능 지표와 그 계산식을 요약한 것이다. 이 표는 제어기 설계 시 정량적인 목표 사양을 만족시키기 위한 파라미터 값을 결정하는 데 매우 유용하게 사용된다.</p>
<table><thead><tr><th>성능 지표</th><th>기호</th><th>공식</th><th>설명</th></tr></thead><tbody>
<tr><td>상승 시간</td><td><span class="math math-inline">t_r</span></td><td><span class="math math-inline">\frac{\pi - \theta}{\omega_d}</span> (단, <span class="math math-inline">\theta = \cos^{-1}\zeta</span>)</td><td>응답이 최종값의 0%에서 100%에 도달하는 시간</td></tr>
<tr><td>최대값 시간</td><td><span class="math math-inline">t_p</span></td><td><span class="math math-inline">\frac{\pi}{\omega_d}</span></td><td>응답이 첫 번째 피크에 도달하는 시간</td></tr>
<tr><td>최대 오버슈트</td><td><span class="math math-inline">M_p</span> (<code>%OS</code>)</td><td><span class="math math-inline">e^{-\frac{\pi\zeta}{\sqrt{1-\zeta^2}}} \times 100</span></td><td>최종값을 초과하는 최대 편차의 백분율</td></tr>
<tr><td>정착 시간 (2% 기준)</td><td><span class="math math-inline">t_s</span></td><td><span class="math math-inline">\approx \frac{4}{\zeta\omega_n} = \frac{4}{\sigma}</span></td><td>응답이 최종값의 ±2% 이내로 수렴하는 시간</td></tr>
</tbody></table>
<h2>4.  정상상태 오차: 정밀도의 한계</h2>
<h3>4.1 정상상태 오차의 정의</h3>
<p>정상상태 오차(Steady-State Error)는 시스템의 과도 응답이 충분한 시간이 흘러 사라진 후, 즉 시스템이 정상상태에 도달했을 때, 목표 입력 <span class="math math-inline">r(t)</span>와 실제 출력 <span class="math math-inline">c(t)</span> 사이에 남아있는 차이를 의미한다.42 수학적으로는 다음과 같이 정의된다.</p>
<p><span class="math math-display">
e_{ss} = \lim_{t \to \infty} e(t) = \lim_{t \to \infty} [r(t) - c(t)]
</span><br />
정상상태 오차는 시스템의 <strong>정밀도(accuracy)</strong> 또는 **추종 성능(tracking performance)**을 평가하는 핵심적인 척도다. 이상적인 제어 시스템이라면 어떠한 목표 입력에 대해서도 오차 없이 정확하게 추종해야 하지만, 실제 시스템에서는 여러 요인으로 인해 오차가 발생할 수 있다. 제어기 설계의 중요한 목표 중 하나는 이 정상상태 오차를 허용 범위 이내로 줄이거나 완전히 제거하는 것이다.42</p>
<h3>4.2 최종값 정리 (Final Value Theorem)</h3>
<p>정상상태 오차를 계산하기 위해 시간 응답 <span class="math math-inline">e(t)</span>를 직접 구하고 <span class="math math-inline">t \to \infty</span>의 극한을 취하는 것은 매우 번거롭다. 최종값 정리는 시간 영역에서의 극한값을 라플라스 변환된 s-영역에서 직접 계산할 수 있게 해주는 매우 유용한 수학적 도구다.43</p>
<p><span class="math math-display">
e_{ss} = \lim_{t \to \infty} e(t) = \lim_{s \to 0} sE(s)
</span><br />
여기서 <span class="math math-inline">E(s)</span>는 오차 신호 <span class="math math-inline">e(t)</span>의 라플라스 변환이다. 단위 피드백 시스템에서 오차 <span class="math math-inline">E(s)</span>는 다음과 같이 표현된다.</p>
<p><span class="math math-display">
E(s) = R(s) - C(s) = R(s) - \frac{G(s)}{1+G(s)}R(s) = \frac{1}{1+G(s)}R(s)
</span><br />
따라서 정상상태 오차는 최종값 정리를 이용하여 다음과 같이 계산할 수 있다.</p>
<p><span class="math math-display">
e_{ss} = \lim_{s \to 0} s \frac{1}{1+G(s)}R(s)
</span><br />
<strong>매우 중요한 전제조건:</strong> 최종값 정리는 시스템이 <strong>안정할 때만</strong> 적용할 수 있다.44 즉,</p>
<p><span class="math math-inline">sE(s)</span>의 모든 극점이 s-평면의 좌반면에 있어야 한다. 만약 시스템이 불안정하여 출력이 발산하는 경우, 정상상태 자체가 존재하지 않으므로 정상상태 오차를 논하는 것은 의미가 없다. 따라서 정상상태 오차를 계산하기 전에는 반드시 시스템의 안정성을 먼저 확인해야 한다.</p>
<h3>4.3 시스템 유형 (System Type)</h3>
<p>정상상태 오차의 크기는 입력 신호의 종류와 시스템의 특성에 따라 결정된다. 특히, 개루프 전달함수 <span class="math math-inline">G(s)H(s)</span>가 원점(<span class="math math-inline">s=0</span>)에서 몇 개의 극점, 즉 **적분기(integrator)**를 가지고 있는지가 정상상태 오차를 결정하는 가장 중요한 요소다. 이 원점에서의 극점 개수 <span class="math math-inline">j</span>를 **시스템 유형(System Type)**이라고 정의한다.44</p>
<p><span class="math math-display">
G(s)H(s) = \frac{K(s+z_1)(s+z_2)\cdots}{s^j(s+p_1)(s+p_2)\cdots}
</span></p>
<ul>
<li>
<p><strong>Type 0 시스템:</strong> <span class="math math-inline">j=0</span>. 개루프 전달함수에 적분기가 없는 경우.</p>
</li>
<li>
<p><strong>Type 1 시스템:</strong> <span class="math math-inline">j=1</span>. 개루프 전달함수에 적분기가 하나 있는 경우.</p>
</li>
<li>
<p><strong>Type 2 시스템:</strong> <span class="math math-inline">j=2</span>. 개루프 전달함수에 적분기가 두 개 있는 경우.</p>
</li>
</ul>
<p>시스템 유형이 높을수록 더 복잡한 형태의 입력 신호를 오차 없이 추종할 수 있는 능력이 향상된다. 이는 적분기가 과거의 오차를 누적하여 오차가 0이 될 때까지 제어 입력을 계속해서 증가(또는 감소)시키는 역할을 하기 때문이다. 즉, 적분기는 시스템에 일종의 ’기억력’을 부여하여, 상수 형태의 오차가 지속되는 것을 용납하지 않는다. 예를 들어, Type 1 시스템에 일정한 목표값(계단 입력)이 주어지면, 초기에는 오차가 발생하지만 적분기가 이 오차를 계속 누적하여 제어 출력을 높인다. 이 과정은 출력이 목표값에 정확히 도달하여 오차가 0이 될 때까지 계속된다. 오차가 0이 되면 적분기의 입력이 0이 되어 현재의 제어 출력을 유지함으로써 정상상태에 도달한다. 이처럼 적분기의 존재는 정상상태 오차를 제거하는 핵심적인 메커니즘이다.</p>
<h3>4.4 정적 오차 상수 (Static Error Constants)</h3>
<p>입력 신호의 종류와 시스템 유형에 따른 정상상태 오차를 보다 체계적으로 분석하기 위해 <strong>정적 오차 상수</strong>를 정의한다.48 이 상수들은 <span class="math math-inline">s \to 0</span>일 때의 개루프 전달함수의 이득을 나타내며, 정상상태 오차와 반비례 관계에 있다.</p>
<ul>
<li>
<p><strong>위치 오차 상수 (Position Error Constant, <span class="math math-inline">K_p</span>):</strong> 단위 계단 입력에 대한 정상상태 오차를 결정한다.<br />
<span class="math math-display">
K_p = \lim_{s \to 0} G(s)H(s)
</span><br />
이때 정상상태 오차는 <span class="math math-inline">e_{ss} = \frac{1}{1+K_p}</span> 이다.</p>
</li>
<li>
<p><strong>속도 오차 상수 (Velocity Error Constant, <span class="math math-inline">K_v</span>):</strong> 단위 경사 입력에 대한 정상상태 오차를 결정한다.</p>
<p><span class="math math-display">
K_v = \lim_{s \to 0} sG(s)H(s)
</span><br />
이때 정상상태 오차는 <span class="math math-inline">e_{ss} = \frac{1}{K_v}</span> 이다.</p>
</li>
<li>
<p><strong>가속도 오차 상수 (Acceleration Error Constant, <span class="math math-inline">K_a</span>):</strong> 단위 포물선 입력에 대한 정상상태 오차를 결정한다.</p>
<p><span class="math math-display">
K_v = \lim_{s \to 0} sG(s)H(s)
</span><br />
이때 정상상태 오차는 <span class="math math-inline">e_{ss} = \frac{1}{K_a}</span> 이다.</p>
</li>
</ul>
<h3>4.5 입력과 시스템 유형에 따른 정상상태 오차 분석</h3>
<p>정적 오차 상수의 정의를 시스템 유형에 따라 계산해보면, 각 시스템 유형이 어떤 종류의 입력까지 오차 없이 추종할 수 있는지를 명확하게 알 수 있다.49</p>
<ul>
<li>
<p><strong>Type 0 시스템 (<span class="math math-inline">j=0</span>):</strong></p>
</li>
<li>
<p><span class="math math-inline">K_p = \lim_{s \to 0} G(s)H(s) = \text{상수}</span>.</p>
</li>
<li>
<p><span class="math math-inline">K_v = \lim_{s \to 0} sG(s)H(s) = 0</span>.</p>
</li>
<li>
<p><span class="math math-inline">K_a = \lim_{s \to 0} s^2G(s)H(s) = 0</span>.</p>
</li>
<li>
<p><strong>결과:</strong> 계단 입력에 대해 일정한 오차(<span class="math math-inline">1/(1+K_p)</span>)를 가지며, 경사 및 포물선 입력에 대해서는 오차가 무한대로 발산하여 추종하지 못한다.</p>
</li>
<li>
<p><strong>Type 1 시스템 (<span class="math math-inline">j=1</span>):</strong></p>
</li>
<li>
<p><span class="math math-inline">K_p = \lim_{s \to 0} G(s)H(s) = \infty</span>.</p>
</li>
<li>
<p><span class="math math-inline">K_v = \lim_{s \to 0} sG(s)H(s) = \text{상수}</span>.</p>
</li>
<li>
<p><span class="math math-inline">K_a = \lim_{s \to 0} s^2G(s)H(s) = 0</span>.</p>
</li>
<li>
<p><strong>결과:</strong> 계단 입력을 오차 없이 추종하며(<span class="math math-inline">e_{ss}=0</span>), 경사 입력에 대해 일정한 오차(<span class="math math-inline">1/K_v</span>)를 갖는다. 포물선 입력은 추종하지 못한다.</p>
</li>
<li>
<p><strong>Type 2 시스템 (<span class="math math-inline">j=2</span>):</strong></p>
</li>
<li>
<p><span class="math math-inline">K_p = \infty</span>, <span class="math math-inline">K_v = \infty</span>.</p>
</li>
<li>
<p><span class="math math-inline">K_a = \lim_{s \to 0} s^2G(s)H(s) = \text{상수}</span>.</p>
</li>
<li>
<p><strong>결과:</strong> 계단 입력과 경사 입력을 모두 오차 없이 추종하며(<span class="math math-inline">e_{ss}=0</span>), 포물선 입력에 대해 일정한 오차(<span class="math math-inline">1/K_a</span>)를 갖는다.</p>
</li>
</ul>
<p>이러한 관계는 제어기 구조 설계의 핵심적인 지침을 제공한다. 예를 들어, 레이더가 등속으로 움직이는 비행기를 오차 없이 추적해야 한다면, 제어 시스템은 최소한 Type 2 시스템이 되어야 한다는 결론을 내릴 수 있다 (비행기의 등속 운동은 시간에 대한 위치가 경사 함수이므로). 다음 표는 이러한 관계를 명확하게 요약한다.</p>
<table><thead><tr><th>시스템 유형</th><th>입력: 단위 계단 (<span class="math math-inline">r(t)=u(t)</span>)</th><th>입력: 단위 경사 (<span class="math math-inline">r(t)=t</span>)</th><th>입력: 단위 포물선 (<span class="math math-inline">r(t)=0.5t^2</span>)</th></tr></thead><tbody>
<tr><td><strong>Type 0</strong></td><td><span class="math math-inline">e_{ss} = \frac{1}{1+K_p}</span> (상수)</td><td><span class="math math-inline">e_{ss} = \infty</span></td><td><span class="math math-inline">e_{ss} = \infty</span></td></tr>
<tr><td></td><td><span class="math math-inline">K_p = \text{상수}</span></td><td><span class="math math-inline">K_v = 0</span></td><td><span class="math math-inline">K_a = 0</span></td></tr>
<tr><td><strong>Type 1</strong></td><td><span class="math math-inline">e_{ss} = 0</span></td><td><span class="math math-inline">e_{ss} = \frac{1}{K_v}</span> (상수)</td><td><span class="math math-inline">e_{ss} = \infty</span></td></tr>
<tr><td></td><td><span class="math math-inline">K_p = \infty</span></td><td><span class="math math-inline">K_v = \text{상수}</span></td><td><span class="math math-inline">K_a = 0</span></td></tr>
<tr><td><strong>Type 2</strong></td><td><span class="math math-inline">e_{ss} = 0</span></td><td><span class="math math-inline">e_{ss} = 0</span></td><td><span class="math math-inline">e_{ss} = \frac{1}{K_a}</span> (상수)</td></tr>
<tr><td></td><td><span class="math math-inline">K_p = \infty</span></td><td><span class="math math-inline">K_v = \infty</span></td><td><span class="math math-inline">K_a = \text{상수}</span></td></tr>
</tbody></table>
<h2>5.  결론: 설계의 예술, 상충관계의 이해</h2>
<h3>5.1 성능 지표 간의 상충관계</h3>
<p>지금까지 살펴본 제어공학의 세 가지 핵심 목표—안정성, 과도 응답, 정상상태 오차—는 독립적인 지표가 아니라 서로 복잡하게 얽혀 있는 상충관계(Trade-off)에 있다.8 제어기 설계의 본질은 이러한 상충관계를 이해하고, 주어진 요구 사양을 만족시키는 최적의 균형점을 찾는 과정이다.</p>
<p>이 상충관계를 가장 명확하게 보여주는 예는 시스템의 **전체 이득(Overall Gain, <span class="math math-inline">K</span>)**을 조절하는 것이다. 이득 <span class="math math-inline">K</span>는 오차 신호를 증폭하여 제어 입력으로 만드는 비례 상수로, 제어기의 가장 기본적인 조절 파라미터다.</p>
<ul>
<li>
<p><strong>이득 증가의 긍정적 효과:</strong></p>
</li>
<li>
<p><strong>정상상태 오차 감소:</strong> 이득 <span class="math math-inline">K</span>를 높이면 정적 오차 상수(<span class="math math-inline">K_p, K_v, K_a</span>)가 비례하여 커지므로, 정상상태 오차는 감소한다.53 이는 시스템의 정밀도를 향상시킨다.</p>
</li>
<li>
<p><strong>응답 속도 증가:</strong> 이득이 높으면 작은 오차에도 큰 제어력이 발생하므로 시스템이 더 빠르게 반응하여 상승 시간이 짧아지는 경향이 있다.55</p>
</li>
<li>
<p><strong>이득 증가의 부정적 효과:</strong></p>
</li>
<li>
<p><strong>안정성 저하:</strong> 근궤적 선도에서 이득 <span class="math math-inline">K</span>가 증가하면 폐루프 극점은 일반적으로 s-평면의 우측으로 이동하는 경향이 있다. 이로 인해 시스템의 상대적 안정성(이득 여유 및 위상 여유)이 감소하며, <span class="math math-inline">K</span>가 특정 임계값을 넘어서면 극점이 RHP로 진입하여 시스템 전체가 불안정해질 수 있다.31</p>
</li>
<li>
<p><strong>과도 응답 악화:</strong> 이득이 증가하면 극점이 허수축에 가까워져 감쇠비 <span class="math math-inline">\zeta</span>가 감소한다. 이는 과도 응답 시 오버슈트와 진동을 크게 증가시켜 시스템의 안정성을 해치고 부드러운 동작을 방해한다.53 또한, 높은 이득은 센서 노이즈와 같은 고주파 외란을 증폭시켜 시스템 성능을 저하시킬 수 있다.</p>
</li>
</ul>
<p>이처럼 이득 <span class="math math-inline">K</span>를 조절하는 것만으로는 빠른 응답, 작은 오차, 그리고 충분한 안정성을 동시에 달성하기 어렵다. 하나의 성능을 얻으면 다른 성능을 희생해야 하는 상황에 직면하게 된다.</p>
<h3>5.2 최적의 제어기 설계를 위한 종합적 고찰</h3>
<p>이러한 근본적인 상충관계를 극복하기 위해 더 정교한 제어기 구조가 필요하다. 산업계에서 가장 널리 사용되는 <strong>PID(Proportional-Integral-Derivative) 제어기</strong>는 바로 이 문제를 해결하기 위해 고안되었다.55</p>
<ul>
<li>
<p><strong>비례(P) 제어:</strong> 현재 오차에 비례하는 제어 입력을 생성한다. 기본적인 제어 동작을 수행하지만, 정상상태 오차를 완전히 제거하기 어렵고 안정성과의 상충관계가 뚜렷하다.</p>
</li>
<li>
<p><strong>적분(I) 제어:</strong> 과거의 오차를 누적하여 제어 입력을 생성한다. 앞서 살펴보았듯이, 이 누적 효과는 정상상태 오차를 제거하는 데 매우 효과적이다. 하지만 적분기는 위상 지연을 유발하여 시스템의 안정성을 저하시키고 과도 응답을 느리게 만들 수 있다.</p>
</li>
<li>
<p><strong>미분(D) 제어:</strong> 오차의 변화율(미래의 오차 예측)에 비례하는 제어 입력을 생성한다. 이는 시스템이 목표값에 너무 빠르게 접근할 때 제동을 거는 효과를 주어, 오버슈트를 줄이고 과도 응답을 개선하며 안정성을 높이는 역할을 한다.56</p>
</li>
</ul>
<p>제어 설계의 상충관계는 물리 시스템의 근본적인 한계, 즉 ’에너지’와 ’정보’의 제약에서 비롯된다. 시스템의 반응 속도를 높이려면 짧은 시간에 더 많은 에너지를 투입해야 하며, 이는 시스템의 관성으로 인해 필연적으로 오버슈트와 진동(에너지의 출렁임)을 유발한다. 또한, 시스템의 동특성이나 외부 환경에 대한 정보가 불확실할수록, 안정성을 보장하기 위해 보수적이고 느린 제어기를 선택할 수밖에 없다.</p>
<p>PID 제어기와 같은 복잡한 제어기는 단순히 수학적 기교가 아니다. 이는 시스템의 동적 특성에 대한 더 많은 ‘정보’—현재 오차(P), 과거 오차의 누적(I), 미래 오차의 예측(D)—를 종합적으로 활용하여, 시스템의 에너지를 더 지능적으로 배분하려는 시도다.</p>
<p>결론적으로, 제어기 설계는 과학적 분석과 공학적 절충의 예술이다. 안정성이라는 절대적인 제약 조건 하에서, 근궤적, 보드 선도, 나이퀴스트 선도 등 다양한 분석 도구를 종합적으로 활용하여, 요구되는 과도 응답 사양(속도와 부드러움)과 정상상태 오차 사양(정밀도) 사이의 최적의 균형점을 찾아내는 과정이다. 이를 통해 우리는 불확실한 현실 세계 속에서 기계와 시스템이 우리의 의도대로 정밀하고 안정적으로 작동하도록 만들 수 있다.</p>
<h2>6. 참고 자료</h2>
<ol>
<li>ko.wikipedia.org, <a href="https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99#:~:text=%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99%EC%9D%80%20%EB%8B%A4%EC%96%91%ED%95%9C%20%EB%8F%99%EC%97%AD%ED%95%99,%ED%95%98%EC%9C%84%20%EB%B6%84%EC%95%BC%EB%A1%9C%20%EA%B0%84%EC%A3%BC%EB%90%9C%EB%8B%A4.">https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99#:~:text=%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99%EC%9D%80%20%EB%8B%A4%EC%96%91%ED%95%9C%20%EB%8F%99%EC%97%AD%ED%95%99,%ED%95%98%EC%9C%84%20%EB%B6%84%EC%95%BC%EB%A1%9C%20%EA%B0%84%EC%A3%BC%EB%90%9C%EB%8B%A4.</a></li>
<li>제어란 무엇인가 - 공대조교형 연구실, https://prideasanengineer.tistory.com/2</li>
<li>제어공학 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99">https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99</a></li>
<li>제어공학 - 나무위키, <a href="https://namu.wiki/w/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99">https://namu.wiki/w/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99</a></li>
<li>제어 시스템의 기본 개념, http://elearning.kocw.net/document/lec/2012/SeoulTECH/ParkMinkee/ControlEngineering_02.pdf</li>
<li>제어계측공학(制御計測工學) - 한국민족문화대백과사전, https://encykorea.aks.ac.kr/Article/E0051331</li>
<li>제어기 설계 요소 - 몽키로 전력 변환하기, https://monkeypower.tistory.com/38</li>
<li>트레이드오프 - 위키백과, 우리 모두의 백과사전, <a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EC%98%A4%ED%94%84">https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EC%98%A4%ED%94%84</a></li>
<li>“타이어가 자식”… 전기차 타이어 성능구현, 상충관계 해소가 관건 - 머니S, https://www.moneys.co.kr/article/2024032210144084881</li>
<li>4.1 steady-state accuracy, https://www.uomustansiriyah.edu.iq/media/lectures/5/5_2017_03_14!12_17_17_PM.pdf</li>
<li>[제어공학] 제어시스템의 안정도 - 공부해서 남주자, <a href="https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%A0%9C%EC%96%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%95%88%EC%A0%95%EB%8F%84">https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%A0%9C%EC%96%B4%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%95%88%EC%A0%95%EB%8F%84</a></li>
<li>선형 시스템 - 제어 공학 요약 - CtrlMan - 티스토리, https://stella47.tistory.com/337</li>
<li>안정성 구분, 안정도 구분 - [정보통신기술용어해설], http://www.ktword.co.kr/test/view/view.php?no=962</li>
<li>근궤적법(root-locus method)_1 - Intuitive-Robotics - 티스토리, https://intuitive-robotics.tistory.com/1</li>
<li>(고전제어이론) 11.Routh’s stability criterion - 백호ROBOTICS REPORT - 티스토리, https://beckho.tistory.com/56</li>
<li>제어공학 주요 요약(특성방정식의 근의 위치, Routh-Hurwitz 판별) 안정도(1) - YouTube, https://www.youtube.com/watch?v=zh206tZ1jY8</li>
<li>The Stability of Linear Feedback System - 정리노트, https://roboharco12.tistory.com/13</li>
<li>6.2 The Routh-Hurwitz Stability Criterion - 궁금한걸 해결해야 잠이온다 - 티스토리, https://jxkim04.tistory.com/10</li>
<li>【자동제어】RH 판별법 모든 경우의수 총정리! - 철의전사 블로그, https://ironwarrior.tistory.com/107</li>
<li>intuitive-robotics.tistory.com, <a href="https://intuitive-robotics.tistory.com/1#:~:text=%EC%A6%89%2C%20%EA%B7%BC%EA%B6%A4%EC%A0%81%EB%B2%95%EC%9D%80,%EB%98%90%EB%8A%94%20%EC%84%A4%EA%B3%84%ED%95%98%EB%8A%94%20%EB%B0%A9%EB%B2%95%EC%9D%B4%EB%8B%A4.">https://intuitive-robotics.tistory.com/1#:~:text=%EC%A6%89%2C%20%EA%B7%BC%EA%B6%A4%EC%A0%81%EB%B2%95%EC%9D%80,%EB%98%90%EB%8A%94%20%EC%84%A4%EA%B3%84%ED%95%98%EB%8A%94%20%EB%B0%A9%EB%B2%95%EC%9D%B4%EB%8B%A4.</a></li>
<li>[ROOT LOCUS] 근궤적 기법 - 1 - Homo Robotics - 티스토리, https://homo-robotics.tistory.com/12</li>
<li>[제어공학] 13. 근궤적 - 서랍장 - 티스토리, https://e-dist.tistory.com/19</li>
<li>근궤적법(root-locus method)_2 - Intuitive-Robotics - 티스토리, https://intuitive-robotics.tistory.com/2</li>
<li>자동제어 Lecture#11. 근궤적 그리기 규칙 part3 (ch5.2보충) - YouTube, https://www.youtube.com/watch?v=8ln2TvAnJz4</li>
<li>(고전제어이론) 20.Nyquist stability criterion - 백호ROBOTICS REPORT - 티스토리, https://beckho.tistory.com/71</li>
<li>주파수 ω값에 따른 개루프 전달함수 G(ｊω) 의 크기와 위상을 극좌표상에, https://mclab-me.pusan.ac.kr/bbs/mclab/5076/642682/download.do</li>
<li>핵심: 나이퀴스트 안정도 판별법 (Nyquist Stability Criterion) - 김대호기술사의 전기스쿨, <a href="https://kimdaeho.com/school/bbs_detail.php?bbs_num=1160&amp;tb=board_enterprs_story&amp;id&amp;pg=1&amp;links_number">https://kimdaeho.com/school/bbs_detail.php?bbs_num=1160&amp;tb=board_enterprs_story&amp;id=&amp;pg=1&amp;links_number=</a></li>
<li>[제어공학] 11-2. 제어계의 안정도(나이퀴스트 안정도 판별법) - 서랍장, https://e-dist.tistory.com/17</li>
<li>제어 시스템의 안정성 기준 - 헬로티, https://www.hellot.net/news/article.html?no=14005</li>
<li>제어 시스템의 안정성 기준, https://www.onsemi.jp/site/pdf/electronic_engineering-oct_issue.pdf</li>
<li>Gain and phase margins | Control Theory Class Notes - Fiveable, https://library.fiveable.me/control-theory/unit-4/gain-phase-margins/study-guide/TV75MlMZArEM8MVo</li>
<li>[제어공학] 시스템의 과도응답(transient response) - 1차 시스템 - 공부해서 남주자, <a href="https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B3%BC%EB%8F%84%EC%9D%91%EB%8B%B5transient-response">https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B3%BC%EB%8F%84%EC%9D%91%EB%8B%B5transient-response</a></li>
<li>[제어공학] 3. 자동제어계의 과도응답 - 서랍장, https://e-dist.tistory.com/5</li>
<li>과도응답의 시간영역 성능 레포트 - 해피캠퍼스, https://www.happycampus.com/report-doc/4191803/</li>
<li>[제어공학] 4강. 2차시스템의 시간응답 (1) - YouTube, https://www.youtube.com/watch?v=aS4XFe_fudw</li>
<li>[제어공학] 시스템의 과도응답(transient response) - 2차 시스템 - 공부해서 남주자, <a href="https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B3%BC%EB%8F%84%EC%9D%91%EB%8B%B5transient-response-2%EC%B0%A8%EC%8B%9C%EC%8A%A4%ED%85%9C">https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B3%BC%EB%8F%84%EC%9D%91%EB%8B%B5transient-response-2%EC%B0%A8%EC%8B%9C%EC%8A%A4%ED%85%9C</a></li>
<li>Second Order System Transient Response - Tutorials Point, https://www.tutorialspoint.com/second-order-system-transient-response</li>
<li>Response of Second Order System - GeeksforGeeks, https://www.geeksforgeeks.org/electronics-engineering/response-of-second-order-system/</li>
<li>SECTION 4: SECOND-ORDER TRANSIENT RESPONSE, <a href="https://web.engr.oregonstate.edu/~webbky/ENGR202_files/SECTION%204%20Second%20Order%20Transient%20Response.pdf">https://web.engr.oregonstate.edu/~webbky/ENGR202_files/SECTION%204%20Second%20Order%20Transient%20Response.pdf</a></li>
<li>2차 시스템 과도응답 - [정보통신기술용어해설], http://www.ktword.co.kr/test/view/view.php?no=4645</li>
<li>[제어공학] 7. 과도응답의 시간특성 및 정상편차 - 서랍장 - 티스토리, https://e-dist.tistory.com/12</li>
<li>[제어공학] 시스템의 정상상태응답(steady-state response) - 공부해서 남주자 - 티스토리, <a href="https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%A0%95%EC%83%81%EC%83%81%ED%83%9C%EC%9D%91%EB%8B%B5steady-state-response">https://study2give.tistory.com/entry/%EC%A0%9C%EC%96%B4%EA%B3%B5%ED%95%99-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%A0%95%EC%83%81%EC%83%81%ED%83%9C%EC%9D%91%EB%8B%B5steady-state-response</a></li>
<li>Steady State Error - Emma Benjaminson, https://sassafras13.github.io/SteadyStateError/</li>
<li>Extras: Steady-State Error - Control Tutorials for MATLAB and Simulink, https://ctms.engin.umich.edu/CTMS/index.php?aux=Extras_Ess</li>
<li>정상상태 오차 - [정보통신기술용어해설], http://www.ktword.co.kr/test/view/view.php?no=4671</li>
<li>[제어공학] 7강. 정상상태와 I제어 - YouTube, https://www.youtube.com/watch?v=Rc6DXl68mqQ</li>
<li>Final Value Theorem and Steady State Error - YouTube, https://www.youtube.com/watch?v=PXxveGoNRUw</li>
<li>Control Systems - Steady State Errors - Tutorialspoint, https://www.tutorialspoint.com/control_systems/control_systems_steady_state_errors.htm</li>
<li>CTM: Steady State Error - diism@unisi, https://www3.diism.unisi.it/~control/ctm/extras/ess/ess.html</li>
<li>정적 오차상수 (정상상태 오차, System type) - Intuitive-Robotics - 티스토리, https://intuitive-robotics.tistory.com/182</li>
<li>【자동제어】정상상태오차 완전정복 - 3 - 철의전사 블로그, https://ironwarrior.tistory.com/97</li>
<li>정상상태 오차에 의한 시스템 형 - [정보통신기술용어해설], http://www.ktword.co.kr/test/view/view.php?no=5499</li>
<li>Control Systems, Lecture 8: Transient response. - YouTube, https://www.youtube.com/watch?v=J8jp_3KaXLw</li>
<li>원하는 성능을 쉽게 달성하기 위한 적응형 제어 이득 기반 비선형 제어기 설계, <a href="https://icros.org/Newsletter/202304/data/4.%EC%95%8C%EA%B8%B0%EC%89%AC%EC%9A%B4%EC%A0%9C%EC%96%B4%EC%9D%B4%EB%A1%A0.pdf">https://icros.org/Newsletter/202304/data/4.%EC%95%8C%EA%B8%B0%EC%89%AC%EC%9A%B4%EC%A0%9C%EC%96%B4%EC%9D%B4%EB%A1%A0.pdf</a></li>
<li>Controller Gain - IACS Engineering, https://www.iacsengineering.com/controller-gain/</li>
<li>[Control] PID 제어 - velog, <a href="https://velog.io/@717lumos/Control-PID-%EC%A0%9C%EC%96%B4">https://velog.io/@717lumos/Control-PID-%EC%A0%9C%EC%96%B4</a></li>
<li>Control Gain Tuning: Techniques &amp; Methods | StudySmarter, https://www.studysmarter.co.uk/explanations/engineering/robotics-engineering/control-gain-tuning/</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>