<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIJUNG:Rerun.io</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117607984-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117607984-2');
    </script>

    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        startup: {
          ready: () => {
            // pulldown-cmark 출력을 MathJax 형식으로 변환
            document.querySelectorAll('.math-inline').forEach(node => {
              node.outerHTML = '$' + node.innerText + '$';
            });
            document.querySelectorAll('.math-display').forEach(node => {
              node.outerHTML = '$$' + node.innerText + '$$';
            });
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.mjs';
        let theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: false, theme: theme });
        
        document.addEventListener("DOMContentLoaded", function() {
            var mermaidBlocks = document.querySelectorAll("pre > code.language-mermaid");
            mermaidBlocks.forEach(function(block) {
                var pre = block.parentElement;
                var div = document.createElement("div");
                div.className = "mermaid";
                div.textContent = block.textContent.trim();
                pre.replaceWith(div);
            });
            mermaid.run({
                querySelector: '.mermaid'
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            var toggler = document.getElementsByClassName("caret");
            for (var i = 0; i < toggler.length; i++) {
                toggler[i].addEventListener("click", function() {
                    this.parentElement.querySelector(".nested").classList.toggle("active");
                    this.classList.toggle("caret-down");
                });
            }
            
            // 활성 경로 자동 확장
            var activeLink = document.querySelector(".sidebar .active");
            if (activeLink) {
                var parents = [];
                var el = activeLink;
                while (el) {
                    if (el.classList && el.classList.contains("nested")) {
                        el.classList.add("active");
                        // 이 중첩된 목록의 캐럿 찾기
                        // 중첩된 목록은 캐럿이 있는 li 안에 있습니다
                        var li = el.parentElement;
                        if (li) {
                            var caret = li.querySelector(".caret");
                            if (caret) {
                                caret.classList.add("caret-down");
                            }
                        }
                    }
                    el = el.parentElement;
                    if (el && el.classList.contains("sidebar")) break;
                }
            }


        });
    </script>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <main class="content">
            <header>
                <div class="header-content">
                    <h1>Rerun.io</h1>
                    <nav class="breadcrumbs"><a href="../../index.html">Home</a> / <a href="../index.html">프레임워크 라이브러리 (Framework libraries)</a> / <a href="index.html">Rerun.io</a> / <span>Rerun.io</span></nav>
                </div>
            </header>
            <article>
                <h1>Rerun.io</h1>
<p>2025-12-17, G30DR</p>
<h2>1.  서론: 다중 모달 데이터의 폭발과 관측 가능성의 위기</h2>
<h3>1.1  피지컬 AI의 부상과 데이터 복잡성의 증가</h3>
<p>인공지능 기술의 발전은 디지털 영역을 넘어 물리적 세계와 상호작용하는 ’피지컬 AI(Physical AI)’의 시대로 진입하고 있다. 자율 주행 자동차, 지능형 로봇, 드론, 증강 현실(AR) 및 가상 현실(VR) 기기, 그리고 스마트 팩토리의 자동화 시스템 등은 모두 피지컬 AI의 범주에 속한다. 이들 시스템의 핵심은 물리적 환경을 인지(Perception)하고, 판단(Planning)하며, 행동(Action)하는 일련의 루프를 수행한다는 점이다. 1</p>
<p>과거의 소프트웨어 시스템이 주로 텍스트 로그나 정형화된 데이터베이스 트랜잭션을 처리했다면, 피지컬 AI 시스템은 본질적으로 이질적이고 비동기적인 ‘다중 모달(Multimodal)’ 데이터를 생성한다. 여기에는 고해상도 카메라의 RGB 이미지, LiDAR의 3차원 포인트 클라우드(Point Cloud), 레이더(Radar) 신호, IMU(관성 측정 장치)의 가속도 및 자이로스코프 데이터, 그리고 신경망 내부의 텐서(Tensor) 연산 값과 신뢰도 점수(Confidence score) 등이 포함된다. 2</p>
<p>이러한 데이터의 폭발적인 증가는 엔지니어와 연구자들에게 ’관측 가능성(Observability)의 위기’를 초래했다. 서로 다른 주기로 발생하는(Multi-rate) 센서 데이터와 알고리즘의 출력값을 시간 축에 따라 정확하게 동기화하고, 이를 3차원 공간상의 위치 정보(Spatial context)와 결합하여 직관적으로 이해하는 것은 매우 난해한 과제가 되었다. 3</p>
<h3>1.2  기존 시각화 도구의 한계</h3>
<p>로보틱스 및 컴퓨터 비전 분야에서는 오랫동안 RViz(ROS Visualization)나 TensorBoard와 같은 도구들이 표준으로 사용되어 왔다. 그러나 이러한 도구들은 현대적인 피지컬 AI 개발 환경의 요구사항을 완전히 충족시키지 못하고 있다.</p>
<ul>
<li><strong>RViz:</strong> ROS(Robot Operating System) 생태계에 강력하게 결합되어 있어, ROS를 사용하지 않는 환경(예: PyTorch 기반의 순수 딥러닝 연구, 임베디드 C++ 시스템 등)에서는 도입이 어렵다. 또한, 사용자 인터페이스(UI)가 노후화되었으며, 데이터의 실시간 모니터링에는 강점이 있으나 과거 데이터를 되감아 분석하거나(Scrubbing) 데이터를 쿼리하는 기능은 제한적이다. 1</li>
<li><strong>TensorBoard:</strong> 딥러닝 모델의 학습 지표(Loss, Accuracy)나 스칼라 값의 추이를 시각화하는 데에는 탁월하지만, 3차원 공간 데이터나 복잡한 센서 퓨전 데이터를 시각화하는 기능은 부족하다. 3D 포인트 클라우드나 카메라 이미지를 텐서보드에 로깅할 수는 있으나, 이를 인터랙티브하게 조작하거나 시간적 흐름에 따라 정밀하게 분석하는 경험은 제공하지 못한다. 3</li>
<li><strong>Foxglove:</strong> 웹 기반의 현대적인 UI와 협업 기능을 제공하며 RViz의 강력한 대안으로 부상했으나, 주로 완성된 데이터(rosbag, MCAP 등)를 사후 분석하거나 운영 중인 로봇 플릿(Fleet)을 관제하는 데 초점을 맞추고 있다. 개발자가 알고리즘을 작성하는 도중(Inner loop)에 빠르게 데이터를 찍어보는 ‘디버깅’ 용도보다는 ’플랫폼’으로서의 성격이 강하다. 5</li>
</ul>
<h3>1.3  Rerun.io의 등장 배경과 철학</h3>
<p>Rerun.io(이하 Rerun)는 이러한 배경에서 “피지컬 AI를 위한 시각화 인프라“를 표방하며 등장했다. Rerun의 핵심 철학은 개발자가 코드 내부에서 발생하는 복잡한 데이터를 마치 텍스트 로그를 출력하듯(<code>print()</code>) 간편하게 시각화할 수 있어야 한다는 것이다. 1 Rerun은 단순한 3D 뷰어가 아니라, 시간 정보가 포함된 멀티모달 데이터를 수집(Ingest), 저장(Store), 쿼리(Query), 시각화(Visualize)하는 통합 데이터 스택으로 설계되었다. 3</p>
<p>본 보고서는 Rerun의 아키텍처, 기능, 생태계, 그리고 경쟁 도구와의 비교 분석을 통해, Rerun이 왜 현대 로보틱스 및 AI 개발의 필수 도구로 자리 잡고 있는지 심층적으로 분석한다.</p>
<h2>2.  Rerun의 핵심 아키텍처와 기술적 기반</h2>
<p>Rerun이 기존 도구들과 차별화되는 가장 큰 요인은 그 기저에 있는 데이터 모델과 기술 스택에 있다. Rerun은 게임 엔진의 설계를 차용한 엔티티 컴포넌트 시스템(ECS)과 고성능 데이터 처리를 위한 Apache Arrow를 결합하여, 유연성과 성능이라는 두 마리 토끼를 동시에 잡았다.</p>
<h3>2.1  엔티티 컴포넌트 시스템 (ECS: Entity Component System)</h3>
<p>Rerun의 데이터 모델은 전통적인 관계형 데이터베이스(RDB)나 객체 지향 프로그래밍(OOP)의 계층적 구조와 다르다. Rerun은 데이터의 유연한 확장을 위해 ECS 패턴을 채택했다. 1</p>
<h4>2.1.1  엔티티 (Entity)</h4>
<p>엔티티는 시스템 내에서 식별 가능한 고유한 객체를 의미한다. Rerun에서 엔티티는 파일 시스템의 경로와 유사한 ’엔티티 경로(Entity Path)’로 표현된다. 예를 들어, 자율 주행 차량의 전방 카메라는 <code>/car/sensors/camera_front</code>와 같은 경로를 가질 수 있다. 엔티티 자체는 데이터를 포함하지 않으며, 단지 데이터를 담을 수 있는 컨테이너의 식별자 역할을 한다. 8</p>
<h4>2.1.2  컴포넌트 (Component)</h4>
<p>컴포넌트는 실제 데이터를 담고 있는 최소 단위이다. 위치(<code>Position3D</code>), 색상(<code>Color</code>), 반지름(<code>Radius</code>), 텍스트 라벨(<code>Text</code>), 텐서 데이터(<code>TensorData</code>) 등이 모두 컴포넌트이다. 하나의 엔티티는 여러 개의 컴포넌트를 가질 수 있다. 예를 들어, 포인트 클라우드를 표현하는 엔티티는 수만 개의 <code>Position3D</code> 컴포넌트와 이에 상응하는 <code>Color</code> 컴포넌트를 가질 수 있다. 8</p>
<h4>2.1.3  아키타입 (Archetype)</h4>
<p>ECS의 유연성은 때로 사용의 복잡성을 초래할 수 있다. 이를 해결하기 위해 Rerun은 ’아키타입’이라는 개념을 도입했다. 아키타입은 특정 데이터 유형을 표현하기 위해 필요한 컴포넌트들의 집합을 미리 정의해 둔 것이다. 예를 들어 <code>rr.Points3D</code> 아키타입은 내부적으로 <code>Position3D</code> 배열을 필수적으로 포함하고, <code>Color</code>, <code>Radius</code>, <code>Label</code> 등을 선택적으로 포함하도록 설계되어 있다. 개발자는 개별 컴포넌트를 일일이 조립하는 대신 아키타입을 사용하여 직관적으로 데이터를 로깅할 수 있다. 8</p>
<table><thead><tr><th><strong>용어</strong></th><th><strong>정의 및 역할</strong></th><th><strong>비유 (파일 시스템)</strong></th></tr></thead><tbody>
<tr><td><strong>Entity</strong></td><td>고유한 경로를 가진 객체 식별자</td><td>폴더 (Folder)</td></tr>
<tr><td><strong>Component</strong></td><td>실제 데이터 (위치, 색상 등)</td><td>파일 (File)</td></tr>
<tr><td><strong>Archetype</strong></td><td>컴포넌트들의 논리적 묶음 (API 레벨)</td><td>파일 템플릿</td></tr>
</tbody></table>
<p>이러한 ECS 구조 덕분에 Rerun은 스키마리스(Schema-less)에 가까운 유연성을 제공한다. 개발자는 로봇의 상태를 로깅하다가 언제든지 새로운 센서 데이터나 디버깅 정보를 기존 엔티티에 추가하거나 새로운 엔티티를 생성할 수 있으며, 이는 데이터베이스 스키마 변경 없이 즉시 반영된다. 1</p>
<h3>2.2  시간적 데이터 스토어 (Temporal Data Store)</h3>
<p>Rerun은 데이터를 단순한 최신 상태의 스냅샷으로 저장하지 않고, 모든 변경 사항을 시간 축에 따라 기록한다. 이를 통해 Rerun은 ’시간 여행’이 가능한 데이터베이스가 된다. 12</p>
<ul>
<li><strong>타임라인(Timeline):</strong> 사용자는 데이터를 기록할 때 하나 이상의 타임라인을 지정할 수 있다. 예를 들어, 카메라 이미지에는 ’프레임 번호(frame_idx)’와 ’캡처 시간(sensor_time)’이라는 두 개의 타임라인을 부여할 수 있다. Rerun 뷰어에서는 이 타임라인을 기준으로 데이터를 정렬하고 조회할 수 있다. 13</li>
<li><strong>Latest-at 쿼리:</strong> Rerun의 쿼리 엔진은 특정 시점(<code>t</code>)을 조회했을 때, 해당 시점보다 같거나 이전에 기록된 가장 최신 데이터를 반환하는 ‘Latest-at’ 시맨틱을 따른다. 이는 서로 다른 주기로 들어오는 센서 데이터(예: 30Hz 카메라와 100Hz IMU)를 동기화하여 보여주는 데 핵심적인 역할을 한다. 12</li>
</ul>
<h3>2.3  Apache Arrow 기반의 고성능 처리</h3>
<p>Rerun은 내부적으로 <strong>Apache Arrow</strong>를 데이터 포맷으로 사용한다. Arrow는 컬럼 기반(Columnar)의 메모리 포맷으로, 현대적인 CPU와 GPU의 SIMD(Single Instruction, Multiple Data) 명령어를 활용하여 대규모 데이터를 고속으로 처리하는 데 최적화되어 있다. 2</p>
<ul>
<li><strong>Zero-copy:</strong> Python SDK에서 NumPy 배열로 데이터를 로깅할 때, Rerun은 이를 Arrow 배열로 변환하여 Rust 백엔드로 전달한다. 이 과정에서 Arrow의 메모리 구조를 활용하여 불필요한 데이터 복사를 최소화(Zero-copy 또는 Near zero-copy)함으로써, 초당 수십 메가바이트의 고대역폭 데이터도 실시간으로 처리할 수 있다. 2</li>
<li><strong>효율적인 쿼리 및 캐싱:</strong> Rerun 0.13 버전 이후 도입된 프라이머리 쿼리 캐싱(Primary Query Caching)은 Arrow 포맷의 특성을 활용하여 시계열 데이터 조회 성능을 획기적으로 개선했다. 수백만 개의 데이터 포인트에 대한 범위 검색이나 집계 연산이 실시간 렌더링 루프(60Hz) 내에서 처리될 수 있는 것은 Arrow 기반의 최적화 덕분이다. 12</li>
</ul>
<h3>2.4  Rust와 WGPU를 통한 크로스 플랫폼 지원</h3>
<p>Rerun의 코어 엔진과 뷰어는 <strong>Rust</strong>로 작성되었다. Rust는 메모리 안전성을 보장하면서도 C++에 준하는 성능을 제공하여, 고성능 시각화 도구 개발에 적합하다. 렌더링 엔진으로는 <strong>wgpu</strong>를 사용한다. wgpu는 차세대 웹 표준인 WebGPU를 Rust로 구현한 것으로, 이를 통해 Rerun은 네이티브 데스크톱 애플리케이션뿐만 아니라 웹 브라우저에서도 하드웨어 가속을 활용한 고성능 3D 렌더링을 지원한다. 2 이는 연구 결과를 웹 링크 하나로 공유하거나, 주피터 노트북(Jupyter Notebook) 내에서 인터랙티브한 3D 시각화를 구현하는 기반이 된다. 15</p>
<h2>3.  Rerun SDK와 개발자 경험 (Developer Experience)</h2>
<p>Rerun은 “개발자를 위한 도구(Tool for Developers)“를 지향하며, 이를 위해 다양한 프로그래밍 언어에 대한 SDK(Software Development Kit)를 제공한다. 현재 <strong>Python</strong>, <strong>Rust</strong>, **C++**을 공식 지원하며, 각 언어의 특성에 맞는 관용적인(Idiomatic) API를 제공하면서도 기능적 동등성(Feature Parity)을 유지하고 있다. 4</p>
<h3>3.1  SDK 초기화 및 데이터 전송 모드</h3>
<p>Rerun을 사용하기 위해서는 먼저 <code>rr.init()</code> 함수를 호출하여 세션을 초기화해야 한다. 이때 ’애플리케이션 ID(Application ID)’를 지정하는데, 이는 뷰어의 레이아웃 설정(블루프린트)을 저장하고 불러오는 키 역할을 한다. 17</p>
<p>데이터를 뷰어로 전송하는 방식은 개발 환경과 목적에 따라 세 가지로 나뉜다: 15</p>
<ol>
<li><strong>Spawn 모드 (<code>rr.spawn()</code>):</strong> 로컬 머신에서 Rerun 뷰어 프로세스를 자식 프로세스로 실행하고, 데이터를 직접 파이프라인으로 연결한다. 별도의 서버 설정 없이 즉시 데이터를 확인하고 싶을 때 가장 간편한 방식이다.</li>
<li><strong>Connect 모드 (<code>rr.connect_grpc()</code>):</strong> 이미 실행 중인 Rerun 뷰어(또는 서버)에 네트워크(gRPC)를 통해 데이터를 전송한다. 원격 서버에서 실행되는 학습 코드나, 임베디드 장치인 로봇에서 실행되는 코드의 로그를 개발자 PC에서 실시간으로 모니터링할 때 사용된다. 18</li>
<li><strong>Save 모드 (<code>rr.save()</code>):</strong> 데이터를 실시간으로 전송하지 않고 로컬 디스크에 <code>.rrd</code> 파일(Rerun Recording Data)로 저장한다. 이는 나중에 뷰어에서 파일을 열어 분석하거나, 동료와 데이터를 공유할 때 유용하다.</li>
</ol>
<h3>3.2  로깅 워크플로우 (Logging Workflow)</h3>
<p>Rerun의 로깅 API는 매우 직관적이다. <code>rr.log()</code> 함수가 핵심이며, 엔티티 경로와 아키타입을 인자로 받는다.</p>
<p><strong>Python 예시:</strong></p>
<p>Python</p>
<pre><code>import rerun as rr
import numpy as np

# 초기화 및 뷰어 실행
rr.init("my_robotics_project", spawn=True)

# 1. 타임라인 설정 (선택 사항)
rr.set_time_sequence("frame_idx", 0)

# 2. 데이터 로깅 (3D 포인트)
positions = np.random.rand(100, 3)
colors = np.random.rand(100, 3)
rr.log("world/points", rr.Points3D(positions, colors=colors, radii=0.05))

# 3. 데이터 로깅 (이미지)
image = np.zeros((480, 640, 3), dtype=np.uint8)
rr.log("world/camera/rgb", rr.Image(image))
</code></pre>
<p>17</p>
<p>이 코드에서 볼 수 있듯이, 복잡한 설정 없이도 NumPy 배열을 그대로 전달하면 Rerun이 내부적으로 적절한 포맷으로 변환하여 시각화한다.</p>
<h3>3.3  언어별 SDK 특징 및 지원 현황</h3>
<h4>3.3.1  Python SDK</h4>
<p>데이터 사이언스 및 머신러닝 커뮤니티를 타겟으로 한다. <code>pip install rerun-sdk</code>로 쉽게 설치할 수 있으며, NumPy, Pandas, PyTorch 등 파이썬 생태계의 주요 라이브러리와 원활하게 통합된다. 특히 주피터 노트북 환경을 지원하여, 데이터 분석 과정에서 코드 셀 바로 아래에 인터랙티브 뷰어를 임베딩할 수 있다. 이는 실험 노트 작성이나 결과 보고서 생성에 매우 강력한 기능을 제공한다. 17</p>
<h4>3.3.2  Rust SDK</h4>
<p>Rerun의 네이티브 언어인 Rust SDK는 최고의 성능과 안전성을 제공한다. 타입 시스템을 통해 컴파일 타임에 데이터의 정합성을 검증할 수 있으며, 메모리 관리가 효율적이다. 고성능 로보틱스 미들웨어나 시뮬레이터를 개발할 때 적합하다. 2</p>
<h4>3.3.3  C++ SDK</h4>
<p>기존의 많은 로보틱스 시스템과 임베디드 소프트웨어가 C++로 작성되어 있다는 점을 고려하여 제공된다. Rerun 팀은 Rust로 작성된 코어 라이브러리를 기반으로 코드 생성(Code Generation) 기술을 사용하여 C++ SDK를 구축했다. 이를 통해 Python이나 Rust SDK와 100% 호환되는 바이너리(Arrow)를 생성하면서도 C++ 특유의 성능을 유지한다. CMake 및 Bazel 빌드 시스템을 지원하여 기존 프로젝트에 쉽게 통합할 수 있다. 16</p>
<h2>4.  시각화 기능과 데이터 타입 (Archetypes) 상세 분석</h2>
<p>Rerun은 다양한 도메인의 데이터를 처리하기 위해 풍부한 내장 아키타입(Archetype)을 제공한다. 이는 단순히 점이나 선을 그리는 것을 넘어, 데이터의 의미(Semantic)를 포함하는 고수준의 시각화 프리미티브를 제공한다. 11</p>
<h3>4.1  공간 데이터 (Spatial 2D &amp; 3D)</h3>
<p>Rerun의 가장 강력한 기능은 3차원 공간 데이터를 시간의 흐름에 따라 시각화하는 것이다.</p>
<ul>
<li><strong>3D Primitives:</strong> <code>Points3D</code>(점군), <code>Boxes3D</code>(OBB/AABB 박스), <code>Arrows3D</code>(벡터장), <code>Mesh3D</code>(삼각 메쉬) 등을 지원한다. 이는 LiDAR 센서 데이터, SLAM 알고리즘의 맵 포인트, 객체 검출 결과 등을 표현하는 데 사용된다. 11</li>
<li><strong>2D Primitives:</strong> <code>Points2D</code>, <code>Boxes2D</code>, <code>LineStrips2D</code> 등은 주로 카메라 이미지 위에 오버레이(Overlay)되어 객체 인식 결과(Bounding Box)나 랜드마크(Keypoints)를 표시하는 데 사용된다.</li>
<li><strong>좌표계 변환 (Transforms):</strong> <code>Transform3D</code>는 이동(Translation), 회전(Rotation), 크기(Scale) 정보를 포함하여 엔티티 간의 계층적 관계를 정의한다. 이를 통해 ’로봇의 몸체’를 기준으로 ’로봇 팔’이 움직이고, ‘로봇 팔’ 끝에 달린 ’카메라’가 움직이는 복잡한 키네마틱스(Kinematics)를 시각화할 수 있다. 21</li>
<li><strong>핀홀 카메라 모델 (Pinhole):</strong> 3차원 월드 좌표를 2차원 이미지 평면으로 투영하는 카메라의 내부 파라미터(Intrinsics)를 정의한다. 이를 설정하면 3D 뷰어 상에 카메라의 시야각(Frustum)이 표시되고, 3D 포인트 클라우드를 실제 카메라 이미지 위에 투영하여 정합성(Alignment)을 시각적으로 검증할 수 있다. 11</li>
</ul>
<h3>4.2  이미지 및 텐서 (Image &amp; Tensor)</h3>
<ul>
<li><strong>Image:</strong> RGB, RGBA, Grayscale, Depth 이미지뿐만 아니라 NV12, YUV와 같은 다양한 포맷을 지원한다. <code>EncodedImage</code>를 사용하면 JPEG이나 PNG로 압축된 바이너리를 그대로 로깅하여 네트워크 대역폭과 저장 공간을 절약할 수 있다. 11</li>
<li><strong>Segmentation:</strong> <code>SegmentationImage</code>는 각 픽셀이 클래스 ID를 가지는 이미지를 처리한다. <code>AnnotationContext</code>를 통해 각 ID에 해당하는 레이블 이름과 색상을 매핑하면, 뷰어에서 마우스를 호버했을 때 “Person”, “Car“와 같은 의미 있는 정보를 확인할 수 있다. 9</li>
<li><strong>Tensor:</strong> 다차원 배열 데이터를 그대로 시각화한다. 딥러닝 모델의 중간 레이어 출력(Feature Map)이나 가중치 분포 등을 분석할 때 유용하다. 텐서 뷰어는 데이터를 슬라이싱(Slicing)하거나 히트맵(Heatmap)으로 변환하여 보여준다. 11</li>
</ul>
<h3>4.3  시계열 플롯 및 텍스트 (Plots &amp; Text)</h3>
<ul>
<li><strong>Plots:</strong> <code>Scalars</code>, <code>BarChart</code>, <code>SeriesLines</code> 등을 통해 시간에 따른 수치 데이터의 변화를 그래프로 보여준다. 로봇의 배터리 잔량, 모터의 토크, 알고리즘의 오차율(Error metrics) 등을 모니터링하는 데 필수적이다. 11</li>
<li><strong>TextLog:</strong> 시스템 로그 메시지(INFO, WARN, ERROR)를 타임라인에 맞춰 기록한다. 특정 시점에 발생한 에러 로그를 클릭하면, 그 시점의 센서 데이터와 로봇 상태를 즉시 뷰어에서 확인할 수 있어 디버깅 효율을 극대화한다. 11</li>
</ul>
<h2>5.  블루프린트(Blueprints): 시각화의 코드화 및 협업</h2>
<p>Rerun 0.15 버전 이후 도입된 **블루프린트(Blueprint)**는 시각화의 패러다임을 ’설정’에서 ’데이터’로 전환시킨 혁신적인 기능이다. 블루프린트는 “어떤 데이터를 보여줄 것인가(What)“가 아닌, “데이터를 어떻게 보여줄 것인가(How)“를 정의한다. 22</p>
<h3>5.1  블루프린트의 개념 및 역할</h3>
<p>일반적인 시각화 도구에서 사용자가 창을 배치하고 카메라 각도를 조절하는 것은 일회성 설정에 불과하다. 프로그램을 재시작하거나 다른 사람에게 데이터를 공유하면 이 설정은 소실되거나 별도로 전달해야 한다. 그러나 Rerun에서 블루프린트는 그 자체로 저장 가능하고 전송 가능한 데이터 엔티티이다.</p>
<ul>
<li><strong>레이아웃 제어:</strong> 뷰어의 화면 분할(Grid, Vertical, Horizontal), 탭 구성 등을 정의한다.</li>
<li><strong>뷰 설정:</strong> 각 패널에 어떤 종류의 뷰(3D View, Tensor View 등)를 배치할지 결정한다.</li>
<li><strong>쿼리 및 오버라이드:</strong> 각 뷰에 어떤 엔티티 경로의 데이터를 표시할지 필터링하고, 특정 엔티티의 색상이나 크기 등을 강제로 덮어씌우는(Override) 설정을 포함한다. 22</li>
</ul>
<h3>5.2  프로그래매틱 블루프린트 (Programmatic Blueprints)</h3>
<p>블루프린트의 가장 강력한 점은 Python 코드로 작성할 수 있다는 것이다. <code>rerun.blueprint</code> API를 사용하면 데이터의 구조에 따라 동적으로 시각화 레이아웃을 생성할 수 있다.</p>
<p>예를 들어, “감지된 객체가 5개 이상일 때만 별도의 줌인 뷰를 띄운다“거나, “드론의 대수에 맞춰 자동으로 화면을 N분할 한다“는 로직을 코드에 구현할 수 있다. 이렇게 생성된 블루프린트는 <code>rr.send_blueprint()</code>를 통해 뷰어로 전송되어 즉시 반영된다. 이는 반복적인 실험 환경에서 매번 UI를 다시 세팅하는 수고를 덜어주며, 팀 전체가 동일한 표준화된 시각화 환경을 공유할 수 있게 한다. 17</p>
<h3>5.3  블루프린트의 저장과 공유</h3>
<p>설정된 블루프린트는 <code>.rbl</code> 파일로 저장하거나 코드 내에 포함시켜 버전 관리 시스템(Git)으로 관리할 수 있다. 이는 “시각화 환경의 코드화(Configuration as Code)“를 실현하여, 데이터 분석 및 디버깅 환경의 재현성을 보장한다. 24</p>
<h2>6.  경쟁 도구 비교 분석 (Landscape Analysis)</h2>
<p>Rerun의 가치를 명확히 하기 위해서는 기존의 도구들과의 비교가 필수적이다. 주요 비교 대상은 <strong>RViz</strong>, <strong>Foxglove</strong>, <strong>TensorBoard</strong>이다. 1</p>
<h3>6.1  Rerun vs. RViz</h3>
<p>RViz는 ROS 생태계의 표준 도구로, 로봇 개발자들에게 매우 친숙하다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Rerun</strong></th><th><strong>RViz</strong></th></tr></thead><tbody>
<tr><td><strong>의존성</strong></td><td>독립적 (ROS 불필요, Python/C++/Rust 라이브러리)</td><td>ROS/ROS2 설치 필수</td></tr>
<tr><td><strong>주 사용처</strong></td><td>알고리즘 개발, 디버깅, 데이터 분석 (Inner Loop)</td><td>실시간 로봇 상태 모니터링, 제어 (Runtime)</td></tr>
<tr><td><strong>시간 탐색</strong></td><td>강력함 (Scrubbing, 타임라인 쿼리)</td><td>제한적 (Rosbag 재생에 의존)</td></tr>
<tr><td><strong>UI/UX</strong></td><td>현대적, 반응형, 블루프린트 지원</td><td>노후화됨, 설정 저장이 번거로움</td></tr>
<tr><td><strong>인터랙션</strong></td><td>뷰어 조작 위주, 로봇 제어 기능 부족</td><td>인터랙티브 마커를 통한 로봇 제어 강력</td></tr>
</tbody></table>
<p><strong>결론:</strong> ROS 환경 내에서 로봇을 직접 제어하거나(MoveIt 등) 실시간 주행을 모니터링하는 데에는 RViz가 여전히 강점을 가지지만, 알고리즘 개발 단계에서 데이터를 심층 분석하거나 ROS 비의존적인 환경(딥러닝 연구 등)에서는 Rerun이 압도적인 우위를 점한다. 1</p>
<h3>6.2  Rerun vs. Foxglove</h3>
<p>Foxglove는 웹 기반의 로보틱스 데이터 플랫폼으로, RViz의 현대적인 대안으로 시작해 현재는 데이터 관리 플랫폼으로 진화했다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Rerun</strong></th><th><strong>Foxglove</strong></th></tr></thead><tbody>
<tr><td><strong>접근 방식</strong></td><td><strong>Code-first:</strong> 코드 내 삽입형 SDK 중심</td><td><strong>Platform-first:</strong> 데이터 수집/저장/관리 플랫폼 중심</td></tr>
<tr><td><strong>데이터 모델</strong></td><td>ECS 기반 (유연한 스키마)</td><td>ROS Message/MCAP/Protobuf (사전 정의된 스키마)</td></tr>
<tr><td><strong>주요 강점</strong></td><td>개발자 내부 루프(Inner loop) 가속화, 디버깅</td><td>완성된 데이터(Rosbag) 분석, 로봇 플릿(Fleet) 관리</td></tr>
<tr><td><strong>네트워크</strong></td><td>gRPC (실시간 고성능 전송)</td><td>WebSocket (범용성, Foxglove Bridge)</td></tr>
</tbody></table>
<p><strong>결론:</strong> Foxglove가 “운영 중인 로봇 군단(Fleet)“을 관리하고 수집된 데이터를 클라우드에서 분석하는 데 최적화되어 있다면, Rerun은 “개발자가 책상 앞에서 코드를 짜는 순간“에 발생하는 데이터를 즉시 확인하고 수정하는 데 초점을 맞추고 있다. 두 도구는 상호 보완적일 수 있다. 5</p>
<h3>6.3  Rerun vs. TensorBoard</h3>
<p>TensorBoard는 딥러닝 분야의 표준이다.</p>
<table><thead><tr><th><strong>특징</strong></th><th><strong>Rerun</strong></th><th><strong>TensorBoard</strong></th></tr></thead><tbody>
<tr><td><strong>데이터 유형</strong></td><td>멀티모달 (3D, 이미지, 텐서, 공간정보)</td><td>스칼라 (Loss, Accuracy), 그래프, 히스토그램</td></tr>
<tr><td><strong>시각화</strong></td><td>3D 공간 상의 상호작용 및 정합성 확인</td><td>차트 및 그래프 중심</td></tr>
<tr><td><strong>시간 축</strong></td><td>정밀한 타임라인 동기화 및 재생</td><td>스텝(Step) 단위의 단순 추이 확인</td></tr>
</tbody></table>
<p><strong>결론:</strong> 모델의 학습 경향(Loss 곡선 등)을 보는 데는 TensorBoard가 여전히 유효하지만, 모델이 실제 3D 공간에서 어떻게 인식을 수행하는지(예: 3D Bounding Box 정확도)를 확인하려면 Rerun이 필수적이다. 3</p>
<h2>7.  주요 사용 사례 (Use Cases)</h2>
<p>Rerun은 다양한 산업 현장에서 구체적인 문제 해결에 기여하고 있다. 25</p>
<h3>7.1  로보틱스: SLAM 및 내비게이션</h3>
<p>SLAM(Simultaneous Localization and Mapping) 알고리즘 개발 시, 로봇이 추정한 자신의 위치(Trajectory)와 센서로 구축한 지도(Map Points)가 실제 환경과 얼마나 일치하는지 확인해야 한다. Rerun은 수만 개의 포인트 클라우드를 실시간으로 렌더링하고, 카메라 이미지 뷰와 3D 뷰를 연동하여 특징점 매칭(Feature Matching)이 올바르게 되었는지 시각적으로 검증할 수 있게 한다. 25</p>
<h3>7.2  컴퓨터 비전: 3D 객체 인식 및 추적</h3>
<p>자율 주행이나 보안 카메라 시스템에서 객체 인식(Object Detection) 및 추적(Tracking) 알고리즘을 개발할 때, 2D 이미지 상의 바운딩 박스뿐만 아니라 이를 3D 공간으로 투영한 위치 정확도가 중요하다. Rerun을 사용하면 2D 이미지와 3D 월드 좌표계를 동시에 띄워놓고, 투영 행렬(Projection Matrix)의 정확성이나 칼만 필터(Kalman Filter)의 예측 궤적을 디버깅할 수 있다. 25</p>
<h3>7.3  생성형 AI: 3D 재구성 및 멀티모달 모델</h3>
<p>NeRF(Neural Radiance Fields)나 Gaussian Splatting과 같은 3D 재구성 모델의 학습 과정에서, 카메라 포즈 추정의 정확도와 렌더링 된 3D 장면의 품질을 실시간으로 확인할 수 있다. 또한 텍스트-이미지 멀티모달 모델의 경우, 입력된 텍스트 프롬프트와 생성된 이미지, 그리고 내부 어텐션 맵(Attention Map)을 함께 시각화하여 모델의 동작 원리를 분석하는 데 사용된다. 25</p>
<h2>8.  플랫폼 및 비즈니스 모델: Open Core 전략</h2>
<p>Rerun은 <strong>오픈 코어(Open Core)</strong> 비즈니스 모델을 채택하고 있다. 4</p>
<ul>
<li><strong>Rerun Open Source:</strong> GitHub에 공개된 핵심 SDK와 뷰어는 MIT 및 Apache 2.0 듀얼 라이선스로 제공되며, 누구나 무료로 사용할 수 있다. 이는 Rerun의 저변을 확대하고 개발자 생태계를 구축하는 기반이 된다. 로컬에서의 데이터 로깅, 시각화, 파일 저장(.rrd) 등 대부분의 개발 기능이 포함된다.</li>
<li><strong>Rerun Data Platform (상용):</strong> 기업 고객을 대상으로 하는 관리형 서비스이다. 오픈 소스 기능에 더해, 대규모 데이터의 클라우드 저장, 인덱싱 및 검색, 사용자 접근 제어(SSO), 팀 협업 기능 등을 제공한다. 이는 개별 개발자의 도구를 넘어 조직 전체의 데이터 인프라로 확장하고자 하는 Rerun의 비전을 보여준다. 26</li>
</ul>
<h2>9.  결론 및 향후 전망</h2>
<p>Rerun.io는 피지컬 AI 시대를 맞이하여 필연적으로 발생한 ‘데이터의 복잡성’ 문제를 해결하기 위한 가장 현대적이고 강력한 솔루션이다.</p>
<ol>
<li><strong>기술적 우위:</strong> ECS 아키텍처와 Apache Arrow, Rust/WGPU 기반의 기술 스택은 타협하지 않는 성능과 유연성을 제공한다. 이는 단순한 뷰어를 넘어 고성능 데이터베이스로서의 가능성을 보여준다.</li>
<li><strong>생태계 통합:</strong> Python, C++, Rust를 아우르는 SDK와 ROS, PyTorch 등 기존 생태계와의 매끄러운 통합은 Rerun의 도입 장벽을 획기적으로 낮추었다.</li>
<li><strong>미래 지향성:</strong> 블루프린트를 통한 시각화의 코드화, 웹 기반의 공유 기능 등은 원격 근무와 협업이 일상화된 현대 개발 환경에 최적화되어 있다.</li>
</ol>
<p>향후 Rerun은 단순한 시각화 도구를 넘어, 로보틱스 및 AI 데이터의 전체 수명 주기(Lifecycle)를 관리하는 표준 플랫폼으로 성장할 것으로 전망된다. 특히 비디오 스트리밍 지원 강화, 대용량 데이터셋 처리를 위한 클라우드 네이티브 기능 확장 등이 로드맵에 포함되어 있어, 그 활용 범위는 더욱 넓어질 것이다. 27 피지컬 AI를 연구하고 개발하는 모든 엔지니어에게 Rerun은 더 이상 선택이 아닌 필수적인 인프라로 자리 잡을 것이다.</p>
<h2>10. 참고 자료</h2>
<ol>
<li>Rerun.io: My Deep Dive into the Go-To Visualizer for Physical AI, https://skywork.ai/skypage/en/Rerun.io-My-Deep-Dive-into-the-Go-To-Visualizer-for-Physical-AI/1975249775198138368</li>
<li>About - Rerun, https://rerun.io/docs/reference/about</li>
<li>What is Rerun?, https://rerun.io/docs/overview/what-is-rerun</li>
<li>rerun-io/rerun: An open source SDK for logging, storing … - GitHub, https://github.com/rerun-io/rerun</li>
<li>RViz vs Foxglove vs Rerun (2025): A practical guide for robotics …, https://foxglove.dev/robotics/rviz-vs-foxglove-vs-rerun</li>
<li>Parts of Tensorboard are being rewritten in Rust for a 100× to 400 …, https://www.reddit.com/r/rust/comments/mzlg5s/parts_of_tensorboard_are_being_rewritten_in_rust/</li>
<li>Rerun vs. Foxglove: A practical guide for modern robotics …, https://foxglove.dev/robotics/rerun-vs-foxglove</li>
<li>Entities and Components - Rerun, https://rerun.io/docs/concepts/entity-component</li>
<li>The Entity Path Hierarchy - Rerun, https://rerun.io/docs/concepts/entity-path</li>
<li>Components - Rerun, https://rerun.io/docs/reference/types/components</li>
<li>Archetypes - Rerun, https://rerun.io/docs/reference/types/archetypes</li>
<li>How we sped up time series by 20-30x - Rerun, https://rerun.io/blog/primary-query-caching</li>
<li>Events and Timelines - Rerun, https://rerun.io/docs/concepts/timelines</li>
<li>r/rust - Rerun 0.24 released - a fast 2D/3D visualizer, now … - Reddit, https://www.reddit.com/r/rust/comments/1m2w4l8/rerun_024_released_a_fast_2d3d_visualizer_now/</li>
<li>Application model - Rerun, https://rerun.io/docs/concepts/app-model</li>
<li>Introducing the Rerun SDK for C++, https://rerun.io/blog/cpp-sdk</li>
<li>Send from Python - Rerun, https://rerun.io/docs/getting-started/data-in/python</li>
<li>Migrating from 0.22 to 0.23 - Rerun, https://rerun.io/docs/reference/migration/migration-0-23</li>
<li>Python - Rerun, https://rerun.io/docs/getting-started/quick-start/python</li>
<li>rerun-sdk - PyPI, https://pypi.org/project/rerun-sdk/</li>
<li>Spaces and Transforms - Rerun, https://rerun.io/docs/concepts/spaces-and-transforms</li>
<li>Blueprints - Rerun, https://rerun.io/docs/concepts/blueprints</li>
<li>Configure the Viewer - Rerun, https://rerun.io/docs/getting-started/configure-the-viewer</li>
<li>Navigating the Viewer - Rerun, https://rerun.io/docs/getting-started/navigating-the-viewer</li>
<li>Examples - Rerun, https://rerun.io/examples</li>
<li>Rerun — Rerun, https://www.rerun.io/</li>
<li>Releases · rerun-io/rerun - GitHub, https://github.com/rerun-io/rerun/releases</li>
<li>Rerun: Visualize Multimodal Data over Time | Hacker News, https://news.ycombinator.com/item?id=41355797</li>
</ol>

            </article>
            <footer>
                <p>Generated by Rust Site Gen</p>
            </footer>
        </main>
    </div>
</body>
</html>